[{"methodBody": ["METHOD_START", "{", "propertySource . setProperty ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.mock.env.MockEnvironment"}, {"methodBody": ["METHOD_START", "{", "this . setProperty ( key ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withProperty"], "fileName": "org.springframework.mock.env.MockEnvironment"}, {"methodBody": ["METHOD_START", "{", "this . source . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.mock.env.MockPropertySource"}, {"methodBody": ["METHOD_START", "{", "this . setProperty ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withProperty"], "fileName": "org.springframework.mock.env.MockPropertySource"}, {"methodBody": ["METHOD_START", "{", "return   this . body . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsBytes"], "fileName": "org.springframework.mock.http.MockHttpOutputMessage"}, {"methodBody": ["METHOD_START", "{", "return   getBodyAsString ( MockHttpOutputMessage . DEFAULT _ CHARSET )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsString"], "fileName": "org.springframework.mock.http.MockHttpOutputMessage"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    getBodyAsBytes (  )  ;", "return   new   St ( bytes ,    charset )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsString"], "fileName": "org.springframework.mock.http.MockHttpOutputMessage"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . clientHttpResponse )     !  =    null )  ,     \" No   ClientHttpResponse \"  )  ;", "return   this . clientHttpResponse ;", "}", "METHOD_END"], "methodName": ["executeInternal"], "fileName": "org.springframework.mock.http.client.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . executed ;", "}", "METHOD_END"], "methodName": ["isExecuted"], "fileName": "org.springframework.mock.http.client.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "this . httpMethod    =    httpMethod ;", "}", "METHOD_END"], "methodName": ["setMethod"], "fileName": "org.springframework.mock.http.client.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "this . clientHttpResponse    =    clientHttpResponse ;", "}", "METHOD_END"], "methodName": ["setResponse"], "fileName": "org.springframework.mock.http.client.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "this . uri    =    uri ;", "}", "METHOD_END"], "methodName": ["setURI"], "fileName": "org.springframework.mock.http.client.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return    (    body )     -  >     {", "this . body    =    body . cache (  )  ;", "return   this . body . then (  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["initDefaultWriteHandler"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( writeHandler ,     \"  ' writeHandler '    is   required \"  )  ;", "this . writeHandler    =    writeHandler ;", "}", "METHOD_END"], "methodName": ["setWriteHandler"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( charset ,     \"  ' charset '    must   not   be   null \"  )  ;", "byte [  ]    bytes    =    new   byte [ bufferdableByteCount (  )  ]  ;", "bufferd ( bytes )  ;", "return   new   String ( bytes ,    charset )  ;", "}", "METHOD_END"], "methodName": ["dumpString"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    getCharset (  )  ;", "return   Flux . from ( getBody (  )  )  . reduce ( bufferFactory . allocateBuffer (  )  ,     (    previous ,    current )     -  >     {", "previous . write ( current )  ;", "DataBufferUtils . release ( current )  ;", "return   previous ;", "}  )  . map (  (    buffer )     -  >    dumpSt ( buffer ,    charset )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsString"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    null ;", "MediaType   contType    =    getHeaders (  )  . getContType (  )  ;", "if    ( contType    !  =    null )     {", "charset    =    contType . getCharset (  )  ;", "}", "return   charset    !  =    null    ?    charset    :    StandardCharsets . UTF _  8  ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "setBody ( body ,    StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["setBody"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    toDataBuffer ( body ,    charset )  ;", "this . body    =    Flux . just ( buffer )  ;", "}", "METHOD_END"], "methodName": ["setBody"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "this . body    =    Flux . from ( body )  ;", "}", "METHOD_END"], "methodName": ["setBody"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    body . getBytes ( charset )  ;", "ByteBuffer   byteBuffer    =    ByteBuffer . wrap ( bytes )  ;", "return   this . bufferFory . wrap ( byteBuffer )  ;", "}", "METHOD_END"], "methodName": ["toDataBuffer"], "fileName": "org.springframework.mock.http.client.reactive.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( DELETE ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( GET ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HEAD ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["head"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    UriComponentsBuilder . fromUriString ( urlTemplate )  . buildAndExpand ( vars )  . encode (  )  . toUri (  )  ;", "return   new    . DefaultBodyBuilder ( method ,    url )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   new   MockServerHttpRequest . DefaultBodyBuilder ( method ,    url )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( OPTIONS ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["options"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( PATCH ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["patch"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( POST ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["post"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( PUT ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "HttpCookie   foo 1  1     =    new   HttpCookie (  \" foo 1  \"  ,     \" bar 1  \"  )  ;", "HttpCookie   foo 1  2     =    new   HttpCookie (  \" foo 1  \"  ,     \" bar 2  \"  )  ;", "HttpCookie   foo 2  1     =    new   HttpCookie (  \" foo 2  \"  ,     \" baz 1  \"  )  ;", "HttpCookie   foo 2  2     =    new   HttpCookie (  \" foo 2  \"  ,     \" baz 2  \"  )  ;", "request    =     . get (  \"  /  \"  )  . cookie ( foo 1  1  ,    foo 1  2  ,    foo 2  1  ,    foo 2  2  )  . build (  )  ;", "Assert . assertEquals ( Arrays . asList ( foo 1  1  ,    foo 1  2  )  ,    request . getCookies (  )  . get (  \" foo 1  \"  )  )  ;", "Assert . assertEquals ( Arrays . asList ( foo 2  1  ,    foo 2  2  )  ,    request . getCookies (  )  . get (  \" foo 2  \"  )  )  ;", "Assert . assertEquals ( Arrays . asList (  \" foo 1  = bar 1  \"  ,     \" foo 1  = bar 2  \"  ,     \" foo 2  = baz 1  \"  ,     \" foo 2  = baz 2  \"  )  ,    request . getHeaders (  )  . get ( COOKIE )  )  ;", "}", "METHOD_END"], "methodName": ["cookieHeaderSet"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / foo   bar ? a = b \"  )  . queryParam (  \" name   A \"  ,     \" value   A 1  \"  ,     \" value   A 2  \"  )  . queryParam (  \" name   B \"  ,     \" value   B 1  \"  )  . build (  )  ;", "Assert . assertEquals (  \"  / foo %  2  0 bar ? a = b & name %  2  0 A = value %  2  0 A 1  & name %  2  0 A = value %  2  0 A 2  & name %  2  0 B = value %  2  0 B 1  \"  ,    request . getURI (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParams"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( charset ,     \"  ' charset '    must   not   be   null \"  )  ;", "byte [  ]    bytes    =    new   byte [ buffdableByteCount (  )  ]  ;", "buffd ( bytes )  ;", "return   new   String ( bytes ,    charset )  ;", "}", "METHOD_END"], "methodName": ["bufferToString"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    Optional . ofNullable ( getHeaders (  )  . getContentType (  )  )  . map ( MimeType :  : getCharset )  . orElse ( StandardCharsets . UTF _  8  )  ;", "return   getBody (  )  . reduce ( bufferFactory (  )  . allocateBuffer (  )  ,     (    previous ,    current )     -  >     {", "previous . write ( current )  ;", "DataBufferUtils . release ( current )  ;", "return   previous ;", "}  )  . map (  (    buffer )     -  >    bufferToSt ( buffer ,    charset )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsString"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( writeHandler ,     \"  ' writeHandler '    is   required \"  )  ;", "this . body    =    Flux . error ( new   IllegalStateException (  \" Not   available   with   custom   write   handler .  \"  )  )  ;", "this . writeHandler    =    writeHandler ;", "}", "METHOD_END"], "methodName": ["setWriteHandler"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "ResponseCookie   foo 1  1     =    ResponseCookie . from (  \" foo 1  \"  ,     \" bar 1  \"  )  . build (  )  ;", "ResponseCookie   foo 1  2     =    ResponseCookie . from (  \" foo 1  \"  ,     \" bar 2  \"  )  . build (  )  ;", "ResponseCookie   foo 2  1     =    ResponseCookie . from (  \" foo 2  \"  ,     \" baz 1  \"  )  . build (  )  ;", "ResponseCookie   foo 2  2     =    ResponseCookie . from (  \" foo 2  \"  ,     \" baz 2  \"  )  . build (  )  ;", "response    =    new    (  )  ;", "response . addCookie ( foo 1  1  )  ;", "response . addCookie ( foo 1  2  )  ;", "response . addCookie ( foo 2  1  )  ;", "response . addCookie ( foo 2  2  )  ;", "response . applyCookies (  )  ;", "Assert . assertEquals ( Arrays . asList (  \" foo 1  = bar 1  \"  ,     \" foo 1  = bar 2  \"  ,     \" foo 2  = baz 1  \"  ,     \" foo 2  = baz 2  \"  )  ,    response . getHeaders (  )  . get ( SET _ COOKIE )  )  ;", "}", "METHOD_END"], "methodName": ["cookieHeaderSet"], "fileName": "org.springframework.mock.http.server.reactive.MockServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "this . jndiObjects . put ( name ,    object )  ;", "}", "METHOD_END"], "methodName": ["addObject"], "fileName": "org.springframework.mock.jndi.ExpectedLookupTemplate"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" Activating   simple   JNDI   environment \"  )  ;", "synchronized (  . initializationLock )     {", "if    (  !  (  . initialized )  )     {", "Assert . state (  (  !  ( NamingManager . hasInitialContextFactoryBuilder (  )  )  )  ,     (  \" Cannot   activate    :    there   is   already   a   JNDI   provider   registered .     \"     +     (  \" Note   that   JNDI   is   a   JVM - wide   service ,    shared   at   the   JVM   system   class   loader   level ,     \"     +     \" with   no   reset   option .    As   a   consequence ,    a   JNDI   provider   must   only   be   registered   once   per   JVM .  \"  )  )  )  ;", "NamingManager . setInitialContextFactoryBuilder ( this )  ;", ". initialized    =    true ;", "}", "}", ". activated    =    this ;", "}", "METHOD_END"], "methodName": ["activate"], "fileName": "org.springframework.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  (  \" Static   JNDI   bind :     [  \"     +    name )     +     \"  ]     =     [  \"  )     +    obj )     +     \"  ]  \"  )  )  ;", "}", "this . boundObjects . put ( name ,    obj )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.springframework.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . boundObjects . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" Deactivating   simple   JNDI   environment \"  )  ;", ". activated    =    null ;", "}", "METHOD_END"], "methodName": ["deactivate"], "fileName": "org.springframework.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "SimpleNamingContextBuilder   builder    =    SimpleNamingContextBuilder . activated ;", "if    ( builder    !  =    null )     {", "builder . clear (  )  ;", "} else    {", "builder    =    new   SimpleNamingContextBuilder (  )  ;", "builder . activate (  )  ;", "}", "return   builder ;", "}", "METHOD_END"], "methodName": ["emptyActivatedContextBuilder"], "fileName": "org.springframework.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   SimpleNamingContextBuilder . activated ;", "}", "METHOD_END"], "methodName": ["getCurrentContextBuilder"], "fileName": "org.springframework.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this . sourceStream ;", "}", "METHOD_END"], "methodName": ["getSourceStream"], "fileName": "org.springframework.mock.web.DelegatingServletInputStream"}, {"methodBody": ["METHOD_START", "{", "return   this . targetStream ;", "}", "METHOD_END"], "methodName": ["getTargetStream"], "fileName": "org.springframework.mock.web.DelegatingServletOutputStream"}, {"methodBody": ["METHOD_START", "{", "this . values . add ( value )  ;", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "CollectionUtils . mergeArrayIntoCollection ( values ,    this . values )  ;", "}", "METHOD_END"], "methodName": ["addValueArray"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "this . values . addAll ( values )  ;", "}", "METHOD_END"], "methodName": ["addValues"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Header   name   must   not   be   null \"  )  ;", "for    ( String   headerName    :    headers . keySet (  )  )     {", "if    ( headerName . equalsIgnoreCase ( name )  )     {", "return   headers . get ( headerName )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getByName"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . values . isEmpty (  )  )     ?    String . valueOf ( this . values . get (  0  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getStringValue"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "List < String >    stringList    =    new   ArrayList <  >  ( this . values . size (  )  )  ;", "for    ( Object   value    :    this . values )     {", "stringList . add ( value . toString (  )  )  ;", "}", "return   Collections . unmodifiableList ( stringList )  ;", "}", "METHOD_END"], "methodName": ["getStringValues"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . values . isEmpty (  )  )     ?    this . values . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . values )  ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "this . values . clear (  )  ;", "if    ( value    !  =    null )     {", "this . values . add ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.springframework.mock.web.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( handler ,     \" Dispatch   handler   must   not   be   null \"  )  ;", "hronized ( this )     {", "if    (  ( this . dispatchedPath )     =  =    null )     {", "this . dispatchHandlers . add ( handler )  ;", "} else    {", "handler . run (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addDispatchHandler"], "fileName": "org.springframework.mock.web.MockAsyncContext"}, {"methodBody": ["METHOD_START", "{", "return   this . dispatchedPath ;", "}", "METHOD_END"], "methodName": ["getDispatchedPath"], "fileName": "org.springframework.mock.web.MockAsyncContext"}, {"methodBody": ["METHOD_START", "{", "return   this . listeners ;", "}", "METHOD_END"], "methodName": ["getListeners"], "fileName": "org.springframework.mock.web.MockAsyncContext"}, {"methodBody": ["METHOD_START", "{", "if    ( targetWriter   instanceof   JspWriter )     {", "return    (  ( JspWriter )     ( targetWriter )  )  ;", "} else    {", "return   new   JspWriter ( response ,    targetWriter )  ;", "}", "}", "METHOD_END"], "methodName": ["adaptJspWriter"], "fileName": "org.springframework.mock.web.MockBodyContent"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Manager . evaluate (  \" JSP   EL   expression \"  ,    expression ,    expectedType ,    this . pageContext )  ;", "}    catch    ( JspException   ex )     {", "throw   new   ELException (  (  (  \" Parsing   of   JSP   EL   expression    \\  \"  \"     +    expression )     +     \"  \\  \"    failed \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doEvaluate"], "fileName": "org.springframework.mock.web.MockExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   this . request ;", "}", "METHOD_END"], "methodName": ["getRequest"], "fileName": "org.springframework.mock.web.MockFilterChain"}, {"methodBody": ["METHOD_START", "{", "return   this . response ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.springframework.mock.web.MockFilterChain"}, {"methodBody": ["METHOD_START", "{", "Filter [  ]    allFilters    =    ObjectUtils . addObjectToArray ( filters ,    new   MockFilterChain . ServletFilterProxy ( servlet )  )  ;", "return   Arrays . asList ( allFilters )  ;", "}", "METHOD_END"], "methodName": ["initFilterList"], "fileName": "org.springframework.mock.web.MockFilterChain"}, {"methodBody": ["METHOD_START", "{", "this . request    =    null ;", "this . response    =    null ;", "this . iator    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.mock.web.MockFilterChain"}, {"methodBody": ["METHOD_START", "{", "new   MockFilterChain ( mock ( Servlet . class )  ,     (  ( Filter )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["constructorNullFilter"], "fileName": "org.springframework.mock.web.MockFilterChainTests"}, {"methodBody": ["METHOD_START", "{", "new   MockFilterChain (  (  ( Servlet )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["constructorNullServlet"], "fileName": "org.springframework.mock.web.MockFilterChainTests"}, {"methodBody": ["METHOD_START", "{", "MockFilterChain   chain    =    new   MockFilterChain (  )  ;", "chain . doFilter ( this . request ,    this . response )  ;", "assertThat ( chain . getRequest (  )  ,    is ( request )  )  ;", "assertThat ( chain . getResponse (  )  ,    is ( response )  )  ;", "try    {", "chain . doFilter ( this . request ,    this . response )  ;", "fail (  \" Expected   Exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" This   FilterChain   has   already   been   called !  \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doFilterEmptyChain"], "fileName": "org.springframework.mock.web.MockFilterChainTests"}, {"methodBody": ["METHOD_START", "{", "MockFilterChain   chain    =    new   MockFilterChain (  )  ;", "chain . doFilter ( null ,    this . response )  ;", "}", "METHOD_END"], "methodName": ["doFilterNullRequest"], "fileName": "org.springframework.mock.web.MockFilterChainTests"}, {"methodBody": ["METHOD_START", "{", "MockFilterChain   chain    =    new   MockFilterChain (  )  ;", "chain . doFilter ( this . request ,    null )  ;", "}", "METHOD_END"], "methodName": ["doFilterNullResponse"], "fileName": "org.springframework.mock.web.MockFilterChainTests"}, {"methodBody": ["METHOD_START", "{", "Servlet   servlet    =    mock ( Servlet . class )  ;", "chain    =    new    ( servlet )  ;", "chain . doFilter ( this . request ,    this . response )  ;", "verify ( servlet )  . service ( this . request ,    this . response )  ;", "try    {", "chain . doFilter ( this . request ,    this . response )  ;", "fail (  \" Expected   Exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" This   FilterChain   has   already   been   called !  \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doFilterWithServlet"], "fileName": "org.springframework.mock.web.MockFilterChainTests"}, {"methodBody": ["METHOD_START", "{", "Servlet   servlet    =    mock ( Servlet . class )  ;", ". MockFilter   filter 2     =    new    . MockFilter ( servlet )  ;", ". MockFilter   filter 1     =    new    . MockFilter ( null )  ;", "MockFilterChain   chain    =    new   MockFilterChain ( servlet ,    filter 1  ,    filter 2  )  ;", "chain . doFilter ( this . request ,    this . response )  ;", "assertTrue ( filter 1  . invoked )  ;", "assertTrue ( filter 2  . invoked )  ;", "verify ( servlet )  . service ( this . request ,    this . response )  ;", "try    {", "chain . doFilter ( this . request ,    this . response )  ;", "fail (  \" Expected   Exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" This   FilterChain   has   already   been   called !  \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doFilterWithServletAndFilters"], "fileName": "org.springframework.mock.web.MockFilterChainTests"}, {"methodBody": ["METHOD_START", "{", "this . request    =    new   MockHttpServletRequest (  )  ;", "this . response    =    new   MockHttpServletResponse (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.mock.web.MockFilterChainTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . initParameters . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addInitParameter"], "fileName": "org.springframework.mock.web.MockFilterConfig"}, {"methodBody": ["METHOD_START", "{", "if    (  ( CONTENT _ TYPE . equalsIgnoreCase ( name )  )     &  &     (  !  ( this . headers . containsKey ( CONTENT _ TYPE )  )  )  )     {", "setContentType ( value . toString (  )  )  ;", "} else", "if    (  ( HttpHeaders . ACCEPT _ LANGUAGE . equalsIgnoreCase ( name )  )     &  &     (  !  ( this . headers . containsKey ( HttpHeaders . ACCEPT _ LANGUAGE )  )  )  )     {", "try    {", "http . HttpHeaders   headers    =    new   http . HttpHeaders (  )  ;", "headers . add ( HttpHeaders . ACCEPT _ LANGUAGE ,    value . toString (  )  )  ;", "setPreferredLocales ( headers . getAcceptLanguageAsLocales (  )  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "doAddHeaderValue ( name ,    value ,    true )  ;", "}", "} else    {", "doAddHeaderValue ( name ,    value ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["addHeader"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "addParameter ( name ,    new   String [  ]  {    value    }  )  ;", "}", "METHOD_END"], "methodName": ["addParameter"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "String [  ]    oldArr    =    this . parameters . get ( name )  ;", "if    ( oldArr    !  =    null )     {", "String [  ]    newArr    =    new   String [  ( oldArr . length )     +     ( values . length )  ]  ;", "System . arraycopy ( oldArr ,     0  ,    newArr ,     0  ,    oldArr . length )  ;", "System . arraycopy ( values ,     0  ,    newArr ,    oldArr . length ,    values . length )  ;", "this . parameters . put ( name ,    newArr )  ;", "} else    {", "this . parameters . put ( name ,    values )  ;", "}", "}", "METHOD_END"], "methodName": ["addParameter"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( params ,     \" Parameter   map   must   not   be   null \"  )  ;", "params . forEach (  (    key ,    value )     -  >     {", "if    ( value   instanceof   String )     {", "addParameter ( key ,     (  ( String )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   String [  ]  )     {", "addParameter ( key ,     (  ( String [  ]  )     ( value )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  \" Parameter   map   value   must   be   single   value    \"     +     \"    or   array   of   type    [  \"  )     +     ( String . class . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addParameters"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . parts . add ( part . getName (  )  ,    part )  ;", "}", "METHOD_END"], "methodName": ["addPart"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( locale ,     \" Locale   must   not   be   null \"  )  ;", "this . locales . add (  0  ,    locale )  ;", "updateAcceptLanguageHeader (  )  ;", "}", "METHOD_END"], "methodName": ["addPreferredLocale"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . userRoles . add ( role )  ;", "}", "METHOD_END"], "methodName": ["addUserRole"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( this . session )     !  =    null )  ,     \" The   request   does   not   have   a   session \"  )  ;", "if    (  ( this . session )    instanceof   ssion )     {", "return    (  ( ssion )     ( session )  )  . changeSessionId (  )  ;", "}", "return   this . session . getId (  )  ;", "}", "METHOD_END"], "methodName": ["changeSessionId"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( this . active ,     \" Request   is   not   active   anymore \"  )  ;", "}", "METHOD_END"], "methodName": ["checkActive"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . attributes . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearAttributes"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . active    =    false ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "HeaderValueHolder   header    =    HeaderValueHolder . getByName ( this . headers ,    name )  ;", "Assert . notNull ( value ,     \" Header   value   must   not   be   null \"  )  ;", "if    (  ( header    =  =    null )     |  |    replace )     {", "header    =    new   HeaderValueHolder (  )  ;", "this . headers . put ( name ,    header )  ;", "}", "if    ( value   instanceof   Collection )     {", "header . addValues (  (  ( Collection <  ?  >  )     ( value )  )  )  ;", "} else", "if    ( value . getClass (  )  . isArray (  )  )     {", "header . addValueArray ( value )  ;", "} else    {", "header . addValue ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["doAddHeaderValue"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . content ;", "}", "METHOD_END"], "methodName": ["getContentAsByteArray"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . characterEncoding )     !  =    null )  ,     (  \" Cannot   get   content   as   a   String   for   a   null   character   encoding .     \"     +     \" Consider   setting   the   characterEncoding   in   the   request .  \"  )  )  ;", "if    (  ( this . content )     =  =    null )     {", "return   null ;", "}", "return   new   String ( this . content ,    this . characterEncoding )  ;", "}", "METHOD_END"], "methodName": ["getContentAsString"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "close (  )  ;", "carAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . active ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "for    ( String   dateFormat    :    MockHttpServletRequest . DATE _ FORMATS )     {", "SimpleDateFormat   simpleDateFormat    =    new   SimpleDateFormat ( dateFormat ,    Locale . US )  ;", "simpleDateFormat . setTimeZone ( MockHttpServletRequest . GMT )  ;", "try    {", "return   simpleDateFormat . parse ( value )  . getTime (  )  ;", "}    catch    ( ParseException   ex )     {", "}", "}", "throw   new   IllegalArgumentException (  (  (  (  (  \" Cannot   parse   date   value    '  \"     +    value )     +     \"  '    for    '  \"  )     +    name )     +     \"  '    header \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDateHeader"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . parameters . clear (  )  ;", "}", "METHOD_END"], "methodName": ["removeAllParameters"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . parameters . remove ( name )  ;", "}", "METHOD_END"], "methodName": ["removeParameter"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . asyncContext    =    asyncContext ;", "}", "METHOD_END"], "methodName": ["setAsyncContext"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . asyncStarted    =    asyncStarted ;", "}", "METHOD_END"], "methodName": ["setAsyncStarted"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . asyncSupported    =    asyncSupported ;", "}", "METHOD_END"], "methodName": ["setAsyncSupported"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . authType    =    authType ;", "}", "METHOD_END"], "methodName": ["setAuthType"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . content    =    content ;", "}", "METHOD_END"], "methodName": ["setContent"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . contentType    =    contentType ;", "if    ( contentType    !  =    null )     {", "try    {", "MediaType   mediaType    =    MediaType . parseMediaType ( contentType )  ;", "if    (  ( mediaType . getCharset (  )  )     !  =    null )     {", "this . characterEncoding    =    mediaType . getCharset (  )  . name (  )  ;", "}", "}    catch    ( IllegalArgumentException   ex )     {", "int   charsetIndex    =    contentType . toLowerCase (  )  . indexOf (  . CHARSET _ PREFIX )  ;", "if    ( charsetIndex    !  =     (  -  1  )  )     {", "this . characterEncoding    =    contentType . substring (  ( charsetIndex    +     (  . CHARSET _ PREFIX . length (  )  )  )  )  ;", "}", "}", "updateContentTypeHeader (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . contextPath    =    contextPath ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . cookies    =     ( ObjectUtils . isEmpty ( cookies )  )     ?    null    :    cookies ;", "this . headers . remove ( COOKIE )  ;", "if    (  ( this . cookies )     !  =    null )     {", "Arrays . stream ( this . cookies )  . map (  (    c )     -  >     (  ( c . getName (  )  )     +     '  =  '  )     +     (  ( c . getValue (  )  )     =  =    null    ?     \"  \"     :    c . getValue (  )  )  )  . forEach (  (    value )     -  >    doAddHeaderValue ( Headers . COOKIE ,    value ,    false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setCookies"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . dispatcherType    =    dispatcherType ;", "}", "METHOD_END"], "methodName": ["setDispatcherType"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . localAddr    =    localAddr ;", "}", "METHOD_END"], "methodName": ["setLocalAddr"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . localName    =    localName ;", "}", "METHOD_END"], "methodName": ["setLocalName"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . localPort    =    localPort ;", "}", "METHOD_END"], "methodName": ["setLocalPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . method    =    method ;", "}", "METHOD_END"], "methodName": ["setMethod"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "setParameter ( name ,    new   String [  ]  {    value    }  )  ;", "}", "METHOD_END"], "methodName": ["setParameter"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . parameters . put ( name ,    values )  ;", "}", "METHOD_END"], "methodName": ["setParameter"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( params ,     \" Parameter   map   must   not   be   null \"  )  ;", "params . forEach (  (    key ,    value )     -  >     {", "if    ( value   instanceof   String )     {", "setParameter ( key ,     (  ( String )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   String [  ]  )     {", "setParameter ( key ,     (  ( String [  ]  )     ( value )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  \" Parameter   map   value   must   be   single   value    \"     +     \"    or   array   of   type    [  \"  )     +     ( String . class . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setParameters"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . pathInfo    =    pathInfo ;", "}", "METHOD_END"], "methodName": ["setPathInfo"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( locales ,     \" Locale   list   must   not   be   empty \"  )  ;", "this . locales . clear (  )  ;", "this . locales . addAll ( locales )  ;", "updateAcceptLanguageHeader (  )  ;", "}", "METHOD_END"], "methodName": ["setPreferredLocales"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . protocol    =    protocol ;", "}", "METHOD_END"], "methodName": ["setProtocol"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . queryString    =    queryString ;", "}", "METHOD_END"], "methodName": ["setQueryString"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . remoteAddr    =    remoteAddr ;", "}", "METHOD_END"], "methodName": ["setRemoteAddr"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . remoteHost    =    remoteHost ;", "}", "METHOD_END"], "methodName": ["setRemoteHost"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . remotePort    =    remotePort ;", "}", "METHOD_END"], "methodName": ["setRemotePort"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . remoteUser    =    remoteUser ;", "}", "METHOD_END"], "methodName": ["setRemoteUser"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestURI    =    requestURI ;", "}", "METHOD_END"], "methodName": ["setRequestURI"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestedSessionId    =    requestedSessionId ;", "}", "METHOD_END"], "methodName": ["setRequestedSessionId"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestedSessionIdFromCookie    =    requestedSessionIdFromCookie ;", "}", "METHOD_END"], "methodName": ["setRequestedSessionIdFromCookie"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestedSessionIdFromURL    =    requestedSessionIdFromURL ;", "}", "METHOD_END"], "methodName": ["setRequestedSessionIdFromURL"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestedSessionIdValid    =    requestedSessionIdValid ;", "}", "METHOD_END"], "methodName": ["setRequestedSessionIdValid"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . scheme    =    scheme ;", "}", "METHOD_END"], "methodName": ["setScheme"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . secure    =    secure ;", "}", "METHOD_END"], "methodName": ["setSecure"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . serverName    =    serverName ;", "}", "METHOD_END"], "methodName": ["setServerName"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . serverPort    =    serverPort ;", "}", "METHOD_END"], "methodName": ["setServerPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . servletPath    =    servletPath ;", "}", "METHOD_END"], "methodName": ["setServletPath"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . session    =    session ;", "if    ( session   instanceof   ssion )     {", "ssion   mockSession    =     (  ( ssion )     ( session )  )  ;", "mockSession . access (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setSession"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . userPrincipal    =    userPrincipal ;", "}", "METHOD_END"], "methodName": ["setUserPrincipal"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setAcceptLanguageAsLocales ( this . locales )  ;", "doAddHeaderValue ( ACCEPT _ LANGUAGE ,    headers . getFirst ( ACCEPT _ LANGUAGE )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["updateAcceptLanguageHeader"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasLength ( this . contentType )  )     {", "StringBuilder   sb    =    new   StringBuilder ( this . contentType )  ;", "if    (  (  !  ( this . contentType . toLowerCase (  )  . contains (  . CHARSET _ PREFIX )  )  )     &  &     ( StringUtils . hasLength ( this . characterEncoding )  )  )     {", "sb . append (  \"  ;  \"  )  . append (  . CHARSET _ PREFIX )  . append ( this . characterEncoding )  ;", "}", "doAddHeaderValue ( CONTENT _ TYPE ,    sb . toString (  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["updateContentTypeHeader"], "fileName": "org.springframework.mock.web.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "request . setParameter (  \" key 1  \"  ,     \" value 1  \"  )  ;", "request . setParameter (  \" key 2  \"  ,     \" value 2  \"  )  ;", "Map < String ,    Object >    params    =    new   HashMap <  >  (  2  )  ;", "params . put (  \" key 1  \"  ,     \" newValue 1  \"  )  ;", "params . put (  \" key 3  \"  ,    new   String [  ]  {     \" value 3 A \"  ,     \" value 3 B \"     }  )  ;", "request . addParameters ( params )  ;", "String [  ]    values 1     =    request . getParameterValues (  \" key 1  \"  )  ;", "assertEquals (  2  ,    values 1  . length )  ;", "assertEquals (  \" value 1  \"  ,    values 1  [  0  ]  )  ;", "assertEquals (  \" newValue 1  \"  ,    values 1  [  1  ]  )  ;", "assertEquals (  \" value 2  \"  ,    request . getParameter (  \" key 2  \"  )  )  ;", "String [  ]    values 3     =    request . getParameterValues (  \" key 3  \"  )  ;", "assertEquals (  2  ,    values 3  . length )  ;", "assertEquals (  \" value 3 A \"  ,    values 3  [  0  ]  )  ;", "assertEquals (  \" value 3 B \"  ,    values 3  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["addMultipleParameters"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( enum 1  )  ;", "assertNotNull ( enum 2  )  ;", "int   count    =     0  ;", "while    ( enum 1  . hasMoreElements (  )  )     {", "assertTrue (  \" enumerations   must   be   al   in   length \"  ,    enum 2  . hasMoreElements (  )  )  ;", "assertEquals (  (  \" enumeration   element    #  \"     +     (  +  + count )  )  ,    enum 1  . nextElement (  )  ,    enum 2  . nextElement (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertEqualEnumerations"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain \"  ;", "r . addHeader ( CONTENT _ TYPE ,    contentType )  ;", "assertEquals ( contentType ,    r . getContentType (  )  )  ;", "assertEquals ( contentType ,    r . getHeader ( CONTENT _ TYPE )  )  ;", "assertNull ( r . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeHeader"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain ; charset = UTF -  8  \"  ;", "r . addHeader ( CONTENT _ TYPE ,    contentType )  ;", "assertEquals ( contentType ,    r . getContentType (  )  )  ;", "assertEquals ( contentType ,    r . getHeader ( CONTENT _ TYPE )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    r . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeHeaderUTF8"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "Cookie   cookie 1     =    new   Cookie (  \" foo \"  ,     \" bar \"  )  ;", "Cookie   cookie 2     =    new   Cookie (  \" baz \"  ,     \" qux \"  )  ;", "r . setCookies ( cookie 1  ,    cookie 2  )  ;", "Cookie [  ]    cookies    =    r . getCookies (  )  ;", "List < String >    cookieHeaders    =    Collections . list ( r . getHeaders (  \" Cookie \"  )  )  ;", "assertEquals (  2  ,    cookies . length )  ;", "assertEquals (  \" foo \"  ,    cookies [  0  ]  . getName (  )  )  ;", "assertEquals (  \" bar \"  ,    cookies [  0  ]  . getValue (  )  )  ;", "assertEquals (  \" baz \"  ,    cookies [  1  ]  . getName (  )  )  ;", "assertEquals (  \" qux \"  ,    cookies [  1  ]  . getValue (  )  )  ;", "assertEquals ( Arrays . asList (  \" foo = bar \"  ,     \" baz = qux \"  )  ,    cookieHeaders )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "Locale   originalDefaultLocale    =    Locale . getDefault (  )  ;", "try    {", "Locale   newDefaultLocale    =     ( originalDefaultLocale . equals ( Locale . GERMANY )  )     ?    Locale . FRANCE    :    Locale . GERMANY ;", "Locale . setDefault ( newDefaultLocale )  ;", "request    =    new    (  )  ;", "assertFalse ( newDefaultLocale . equals ( request . getLocale (  )  )  )  ;", "assertEquals ( Locale . ENGLISH ,    request . getLocale (  )  )  ;", "}    finally    {", "Locale . setDefault ( originalDefaultLocale )  ;", "}", "}", "METHOD_END"], "methodName": ["defaultLocale"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage (  \" Cannot   get   content   as   a   String   for   a   null   character   encoding \"  )  ;", "r . getContentAsString (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsStringWithoutSettingCharacterEncoding"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setServerPort (  8  0  8  0  )  ;", "request . sURI (  \"  / path \"  )  ;", "assertEquals (  \" http :  /  / localhost :  8  0  8  0  / path \"  ,    request . gURL (  )  . toString (  )  )  ;", "request . setScheme (  \" https \"  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setServerPort (  8  4  4  3  )  ;", "assertEquals (  \" https :  /  / example . com :  8  4  4  3  / path \"  ,    request . gURL (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestURL"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   requestURL    =    request . getRequestURL (  )  ;", "assertEquals (  \" http :  /  / localhost \"  ,    requestURL . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestURLWithDefaults"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setScheme (  \" https \"  )  ;", "request . setServerPort (  4  4  3  )  ;", "StringBuffer   requestURL    =    request . gURL (  )  ;", "assertEquals (  \" https :  /  / localhost \"  ,    requestURL . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestURLWithDefaultsAndHttps"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   testServer    =     \" test . server \"  ;", "request . addHeader (  . HOST ,    testServer )  ;", "StringBuffer   requestURL    =    request . getRequestURL (  )  ;", "assertEquals (  (  \" http :  /  /  \"     +    testServer )  ,    requestURL . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestURLWithHostHeader"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   testServer    =     \" test . server :  9  9  9  9  \"  ;", "request . addHeader (  . HOST ,    testServer )  ;", "StringBuffer   requestURL    =    request . getRequestURL (  )  ;", "assertEquals (  (  \" http :  /  /  \"     +    testServer )  ,    requestURL . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestURLWithHostHeaderAndPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setServerPort (  (  -  9  9  )  )  ;", "StringBuffer   requestURL    =    request . gURL (  )  ;", "assertEquals (  \" http :  /  / localhost \"  ,    requestURL . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestURLWithNegativePort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setRequestURI ( null )  ;", "StringBuffer   requestURL    =    request . getRequestURL (  )  ;", "assertEquals (  \" http :  /  / localhost \"  ,    requestURL . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestURLWithNullRequestUri"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   ipv 6 Address    =     \"  [  2  0  0  1  : db 8  :  0  :  1  ]  :  8  0  8  1  \"  ;", "request . addHeader (  . HOST ,    ipv 6 Address )  ;", "assertEquals (  \"  2  0  0  1  : db 8  :  0  :  1  \"  ,    request . getServerName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerNameViaHostHeaderAsIpv6AddressWithPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   ipv 6 Address    =     \"  [  2  0  0  1  : db 8  :  0  :  1  ]  \"  ;", "request . addHeader (  . HOST ,    ipv 6 Address )  ;", "assertEquals (  \"  2  0  0  1  : db 8  :  0  :  1  \"  ,    request . getServerName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerNameViaHostHeaderAsIpv6AddressWithoutPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   testServer    =     \" test . server \"  ;", "request . addHeader (  . HOST ,     ( testServer    +     \"  :  8  0  8  0  \"  )  )  ;", "assertEquals ( testServer ,    request . getServerName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerNameViaHostHeaderWithPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   testServer    =     \" test . server \"  ;", "request . addHeader (  . HOST ,    testServer )  ;", "assertEquals ( testServer ,    request . getServerName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerNameViaHostHeaderWithoutPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setServerName (  \" example . com \"  )  ;", "assertEquals (  \" example . com \"  ,    request . getServerName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerNameWithCustomName"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" localhost \"  ,    request . getServerName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerNameWithDefaultName"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   testServer    =     \"  [  2  0  0  1  : db 8  :  0  :  1  ]  \"  ;", "int   testPort    =     9  9  9  9  ;", "request . addHeader (  . HOST ,     (  ( testServer    +     \"  :  \"  )     +    testPort )  )  ;", "assertEquals ( testPort ,    request . getServerPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerPortViaHostHeaderAsIpv6AddressWithPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   testServer    =     \"  [  2  0  0  1  : db 8  :  0  :  1  ]  \"  ;", "request . addHeader (  . HOST ,    testServer )  ;", "assertEquals (  8  0  ,    request . getServerPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerPortViaHostHeaderAsIpv6AddressWithoutPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   testServer    =     \" test . server \"  ;", "int   testPort    =     9  9  9  9  ;", "request . addHeader (  . HOST ,     (  ( testServer    +     \"  :  \"  )     +    testPort )  )  ;", "assertEquals ( testPort ,    request . getServerPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerPortViaHostHeaderWithPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   testServer    =     \" test . server \"  ;", "request . addHeader (  . HOST ,    testServer )  ;", "assertEquals (  8  0  ,    request . getServerPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerPortViaHostHeaderWithoutPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setServerPort (  8  0  8  0  )  ;", "assertEquals (  8  0  8  0  ,    request . getServerPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerPortWithCustomPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  8  0  ,    request . getServerPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServerPortWithDefaultPort"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    new   Date (  )  ;", "r . addHeader ( IF _ MODIFIED _ SINCE ,    date )  ;", "assertEquals ( date . getTime (  )  ,    r . getDateHeader ( IF _ MODIFIED _ SINCE )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaderDate"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . addHeader ( IF _ MODIFIED _ SINCE ,     \" Tue ,     2  1  - Jul -  1  5     1  0  :  0  0  :  0  0    GMT \"  )  ;", "assertEquals (  1  4  3  7  4  7  2  8  0  0  0  0  0 L ,    request . getDateHeader ( IF _ MODIFIED _ SINCE )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaderFirstVariantFormatedDate"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . addHeader ( IF _ MODIFIED _ SINCE ,     \" This   is   not   a   date \"  )  ;", "request . getDateHeader ( IF _ MODIFIED _ SINCE )  ;", "}", "METHOD_END"], "methodName": ["httpHeaderFormatedDateError"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =     \" Header 1  \"  ;", "r . addHeader ( headerName ,     \" value 1  \"  )  ;", "Enumeration < String >    rHeaders    =    r . getHeaderNames (  )  ;", "assertNotNull ( rHeaders )  ;", "assertEquals (  \" HTTP   header   casing   not   being   preserved \"  ,    headerName ,    rHeaders . nextElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaderNameCasingIsPreserved"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . addHeader ( IF _ MODIFIED _ SINCE ,     \" Tue ,     2  1    Jul    2  0  1  5     1  0  :  0  0  :  0  0    GMT \"  )  ;", "assertEquals (  1  4  3  7  4  7  2  8  0  0  0  0  0 L ,    request . getDateHeader ( IF _ MODIFIED _ SINCE )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaderRfcFormatedDate"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . addHeader ( IF _ MODIFIED _ SINCE ,     \" Tue   Jul    2  1     1  0  :  0  0  :  0  0     2  0  1  5  \"  )  ;", "assertEquals (  1  4  3  7  4  7  2  8  0  0  0  0  0 L ,    request . getDateHeader ( IF _ MODIFIED _ SINCE )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaderSecondVariantFormatedDate"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "long   timestamp    =    new   Date (  )  . getTime (  )  ;", "r . addHeader ( IF _ MODIFIED _ SINCE ,    timestamp )  ;", "assertEquals ( timestamp ,    r . getDateHeader ( IF _ MODIFIED _ SINCE )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaderTimestamp"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . addHeader (  \" Accept - Language \"  ,     \" en _ US \"  )  ;", "assertEquals ( Locale . ENGLISH ,    request . getLocale (  )  )  ;", "assertEquals (  \" en _ US \"  ,    request . getHeader (  \" Accept - Language \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidAcceptLanguageHeader"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( request . isSecure (  )  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setSecure ( false )  ;", "assertFalse ( request . isSecure (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSecureWithHttpSchemeAndSecureFlagIsFalse"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( request . isSecure (  )  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setSecure ( true )  ;", "assertTrue ( request . isSecure (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSecureWithHttpSchemeAndSecureFlagIsTrue"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( request . isSecure (  )  )  ;", "request . setScheme (  \" https \"  )  ;", "request . setSecure ( false )  ;", "assertTrue ( request . isSecure (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSecureWithHttpsSchemeAndSecureFlagIsFalse"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( request . isSecure (  )  )  ;", "request . setScheme (  \" https \"  )  ;", "request . setSecure ( true )  ;", "assertTrue ( request . isSecure (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSecureWithHttpsSchemeAndSecureFlagIsTrue"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  -  1  )  ,    request . getContentLength (  )  )  ;", "assertNotNull ( request . getInputStream (  )  )  ;", "assertEquals (  (  -  1  )  ,    request . getInputStream (  )  . read (  )  )  ;", "assertNull ( request . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["noContent"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( request . getCookies (  )  )  ;", "}", "METHOD_END"], "methodName": ["noCookies"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   headerValue    =     \" fr - ch ,    fr ; q =  0  .  9  ,    en -  *  ; q =  0  .  8  ,    de ; q =  0  .  7  ,     *  ; q =  0  .  5  \"  ;", "r . addHeader (  \" Accept - Language \"  ,    headerValue )  ;", "List < Locale >    actual    =    Collections . list ( r . getLocales (  )  )  ;", "assertEquals ( Arrays . asList ( Locale . forLanguageTag (  \" fr - ch \"  )  ,    Locale . forLanguageTag (  \" fr \"  )  ,    Locale . forLanguageTag (  \" en \"  )  ,    Locale . forLanguageTag (  \" de \"  )  )  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["preferredLocalesFromAcceptLanguageHeader"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( MockHttpServletRequest . DEFAULT _ PROTOCOL ,    request . getProtocol (  )  )  ;", "assertEquals ( MockHttpServletRequest . DEFAULT _ SCHEME ,    request . getScheme (  )  )  ;", "request . setProtocol (  \" HTTP /  2  .  0  \"  )  ;", "request . setScheme (  \" https \"  )  ;", "assertEquals (  \" HTTP /  2  .  0  \"  ,    request . getProtocol (  )  )  ;", "assertEquals (  \" https \"  ,    request . getScheme (  )  )  ;", "}", "METHOD_END"], "methodName": ["protocolAndScheme"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setParameter (  \" key 1  \"  ,     \" value 1  \"  )  ;", "Map < String ,    Object >    params    =    new   HashMap <  >  (  2  )  ;", "params . put (  \" key 2  \"  ,     \" value 2  \"  )  ;", "params . put (  \" key 3  \"  ,    new   String [  ]  {     \" value 3 A \"  ,     \" value 3 B \"     }  )  ;", "request . addParameters ( params )  ;", "assertEquals (  3  ,    request . getParameterMap (  )  . size (  )  )  ;", "request . removeAllParameters (  )  ;", "assertEquals (  0  ,    request . getParameterMap (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["removeAllParameters"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setCharacterEncoding (  \" UTF -  8  \"  )  ;", "request . setContentType (  \" test / plain \"  )  ;", "assertEquals (  \" test / plain \"  ,    request . getContentType (  )  )  ;", "assertEquals (  \" test / plain ; charset = UTF -  8  \"  ,    request . getHeader ( CONTENT _ TYPE )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    request . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["setCharacterEncodingThenContentType"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =     \" request   body \"  . getBytes (  )  ;", "request . setContent ( bytes )  ;", "assertEquals ( bytes . length ,    request . getContentLength (  )  )  ;", "assertNotNull ( request . getContentAsByteArray (  )  )  ;", "assertEquals ( bytes ,    request . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentAndGetContentAsByteArray"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   palindrome    =     \" ablE   was   I   ere   I   saw   Elba \"  ;", "byte [  ]    bytes    =    palindrome . getBytes (  \" UTF -  1  6  \"  )  ;", "r . setCharacterEncoding (  \" UTF -  1  6  \"  )  ;", "r . setContent ( bytes )  ;", "assertEquals ( bytes . length ,    r . getContentLength (  )  )  ;", "assertNotNull ( r . getContentAsString (  )  )  ;", "assertEquals ( palindrome ,    r . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentAndGetContentAsStringWithExplicitCharacterEncoding"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =     \" body \"  . getBytes ( Charset . defaultCharset (  )  )  ;", "r . setContent ( bytes )  ;", "assertEquals ( bytes . length ,    r . getContentLength (  )  )  ;", "assertNotNull ( r . getInputStream (  )  )  ;", "assertEquals (  \" body \"  ,    StreamUtils . copyToString ( r . getInputStream (  )  ,    Charset . defaultCharset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentAndGetInputStream"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain \"  ;", "r . setContentType ( contentType )  ;", "assertEquals ( contentType ,    r . getContentType (  )  )  ;", "assertEquals ( contentType ,    r . getHeader ( CONTENT _ TYPE )  )  ;", "assertNull ( r . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain ; charset =  \\  \" utf -  8  \\  \"  ; foo =  \\  \" charset = bar \\  \"  ; foocharset = bar ; foo = bar \"  ;", "r . addHeader ( CONTENT _ TYPE ,    contentType )  ;", "assertEquals ( contentType ,    r . getContentType (  )  )  ;", "assertEquals ( contentType ,    r . getHeader ( CONTENT _ TYPE )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    r . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentTypeHeaderWithMoreComplexCharsetSyntax"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setContentType (  \" test / plain \"  )  ;", "request . setCharacterEncoding (  \" UTF -  8  \"  )  ;", "assertEquals (  \" test / plain \"  ,    request . getContentType (  )  )  ;", "assertEquals (  \" test / plain ; charset = UTF -  8  \"  ,    request . getHeader ( CONTENT _ TYPE )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    request . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentTypeThenCharacterEncoding"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain ; charset = UTF -  8  \"  ;", "r . setContentType ( contentType )  ;", "assertEquals ( contentType ,    r . getContentType (  )  )  ;", "assertEquals ( contentType ,    r . getHeader ( CONTENT _ TYPE )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    r . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentTypeUTF8"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setParameter (  \" key 1  \"  ,     \" value 1  \"  )  ;", "request . setParameter (  \" key 2  \"  ,     \" value 2  \"  )  ;", "Map < String ,    Object >    params    =    new   HashMap <  >  (  2  )  ;", "params . put (  \" key 1  \"  ,     \" newValue 1  \"  )  ;", "params . put (  \" key 3  \"  ,    new   String [  ]  {     \" value 3 A \"  ,     \" value 3 B \"     }  )  ;", "request . setParameters ( params )  ;", "String [  ]    values 1     =    request . getParameterValues (  \" key 1  \"  )  ;", "assertEquals (  1  ,    values 1  . length )  ;", "assertEquals (  \" newValue 1  \"  ,    request . getParameter (  \" key 1  \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    request . getParameter (  \" key 2  \"  )  )  ;", "String [  ]    values 3     =    request . getParameterValues (  \" key 3  \"  )  ;", "assertEquals (  2  ,    values 3  . length )  ;", "assertEquals (  \" value 3 A \"  ,    values 3  [  0  ]  )  ;", "assertEquals (  \" value 3 B \"  ,    values 3  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["setMultipleParameters"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "List < Locale >    preferredLocales    =    Arrays . asList ( Locale . ITALY ,    Locale . CHINA )  ;", "r . setPreferredLocales ( preferredLocales )  ;", "assertEqualEnumerations ( Collections . enumeration ( preferredLocales )  ,    r . getLocales (  )  )  ;", "assertEquals (  \" it - it ,    zh - cn \"  ,    r . getHeader ( ACCEPT _ LANGUAGE )  )  ;", "}", "METHOD_END"], "methodName": ["setPreferredLocales"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setPreferredLocales ( new   ArrayList <  >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPreferredLocalesWithEmptyList"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "request . setPreferredLocales ( null )  ;", "}", "METHOD_END"], "methodName": ["setPreferredLocalesWithNullList"], "fileName": "org.springframework.mock.web.MockHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( setSpecialHeader ( name ,    value )  )     {", "return ;", "}", "doAddHeaderValue ( name ,    value ,    false )  ;", "}", "METHOD_END"], "methodName": ["addHeaderValue"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( includedUrl ,     \" Included   URL   must   not   be   null \"  )  ;", "this . includedUrls . add ( includedUrl )  ;", "}", "METHOD_END"], "methodName": ["addIncludedUrl"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "HeaderValueHolder   header    =    HeaderValueHolder . getByName ( this . headers ,    name )  ;", "Assert . notNull ( value ,     \" Header   value   must   not   be   null \"  )  ;", "if    ( header    =  =    null )     {", "header    =    new   HeaderValueHolder (  )  ;", "this . headers . put ( name ,    header )  ;", "}", "if    ( replace )     {", "header . setValue ( value )  ;", "} else    {", "header . addValue ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["doAddHeaderValue"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   newDateFormat (  )  . format ( new   Date ( date )  )  ;", "}", "METHOD_END"], "methodName": ["formatDate"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . content . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsByteArray"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return    ( this . characterEncoding )     !  =    null    ?    this . content . toString ( this . characterEncoding )     :    this . content . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsString"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( this . contentLength )  )  ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . contentLength ;", "}", "METHOD_END"], "methodName": ["getContentLengthLong"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Cookie   name   must   not   be   null \"  )  ;", "for    ( Cookie   cookie    :    this . cookies )     {", "if    ( name . equals ( cookie . getName (  )  )  )     {", "return   cookie ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCookie"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "buf . append ( cookie . getName (  )  )  . append (  '  =  '  )  . append (  (  ( cookie . getValue (  )  )     =  =    null    ?     \"  \"     :    cookie . getValue (  )  )  )  ;", "if    ( StringUtils . hasText ( cookie . getPath (  )  )  )     {", "buf . append (  \"  ;    Path =  \"  )  . append ( cookie . getPath (  )  )  ;", "}", "if    ( StringUtils . hasText ( cookie . getDomain (  )  )  )     {", "buf . append (  \"  ;    Domain =  \"  )  . append ( cookie . getDomain (  )  )  ;", "}", "int   maxAge    =    cookie . getMaxAge (  )  ;", "if    ( maxAge    >  =     0  )     {", "buf . append (  \"  ;    Max - Age =  \"  )  . append ( maxAge )  ;", "buf . append (  \"  ;    Expires =  \"  )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setExpires (  ( maxAge    >     0     ?     ( System . currentTimeMillis (  )  )     +     (  1  0  0  0 L    *    maxAge )     :     0  )  )  ;", "buf . append ( headers . getFirst ( EXPIRES )  )  ;", "}", "if    ( cookie . getSecure (  )  )     {", "buf . append (  \"  ;    Secure \"  )  ;", "}", "if    ( cookie . isHttpOnly (  )  )     {", "buf . append (  \"  ;    HttpOnly \"  )  ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getCookieHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . cookies . toArray ( new   Cookie [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getCookies"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "String   headerValue    =    getHeader ( name )  ;", "if    ( headerValue    =  =    null )     {", "return    -  1  ;", "}", "try    {", "return   newDateFormat (  )  . parse ( getHeader ( name )  )  . getTime (  )  ;", "}    catch    ( ParseException   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Value   for   header    '  \"     +    name )     +     \"  '    is   not   a   valid   Date :     \"  )     +    headerValue )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDateHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . errorMessage ;", "}", "METHOD_END"], "methodName": ["getErrorMessage"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . forwardedUrl ;", "}", "METHOD_END"], "methodName": ["getForwardedUrl"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "HeaderValueHolder   header    =    HeaderValueHolder . getByName ( this . headers ,    name )  ;", "return   header    !  =    null    ?    header . getValue (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getHeaderValue"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "HeaderValueHolder   header    =    HeaderValueHolder . getByName ( this . headers ,    name )  ;", "if    ( header    !  =    null )     {", "return   header . getValues (  )  ;", "} else    {", "return   Collections . emptyList (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getHeaderValues"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "int   count    =    this . includedUrls . size (  )  ;", "Assert . state (  ( count    <  =     1  )  ,     (  )     -  >     \" More   than    1    URL   included    -    check   getIncludedUrls   instead :     \"     +     ( this . includedUrls )  )  ;", "return   count    =  =     1     ?    this . includedUrls . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getIncludedUrl"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . includedUrls ;", "}", "METHOD_END"], "methodName": ["getIncludedUrls"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   getHeader ( LOCATION )  ;", "}", "METHOD_END"], "methodName": ["getRedirectedUrl"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . charset ;", "}", "METHOD_END"], "methodName": ["isCharset"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . outputStreamAccessAllowed ;", "}", "METHOD_END"], "methodName": ["isOutputStreamAccessAllowed"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . writerAccessAllowed ;", "}", "METHOD_END"], "methodName": ["isWriterAccessAllowed"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "SimpleDateFormat   dateFormat    =    new   SimpleDateFormat ( MockHttpServletResponse . DATE _ FORMAT ,    Locale . US )  ;", "dateFormat . setTimeZone ( MockHttpServletResponse . GMT )  ;", "return   dateFormat ;", "}", "METHOD_END"], "methodName": ["newDateFormat"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . committed    =    committed ;", "}", "METHOD_END"], "methodName": ["setCommitted"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "int   bufSize    =    getBufferSize (  )  ;", "if    (  ( bufSize    >     0  )     &  &     (  ( this . content . size (  )  )     >    bufSize )  )     {", "setCommitted ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["setCommittedIfBufferSizeExceeded"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . forwardedUrl    =    forwardedUrl ;", "}", "METHOD_END"], "methodName": ["setForwardedUrl"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "if    ( setSpecialHeader ( name ,    value )  )     {", "return ;", "}", "doAddHeaderValue ( name ,    value ,    true )  ;", "}", "METHOD_END"], "methodName": ["setHeaderValue"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . includedUrls . clear (  )  ;", "if    ( includedUrl    !  =    null )     {", "this . includedUrls . add ( includedUrl )  ;", "}", "}", "METHOD_END"], "methodName": ["setIncludedUrl"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . outputStreamAccessAllowed    =    outputStreamAccessAllowed ;", "}", "METHOD_END"], "methodName": ["setOutputStreamAccessAllowed"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "if    ( CONTENT _ TYPE . equalsIgnoreCase ( name )  )     {", "setContentType ( value . toString (  )  )  ;", "return   true ;", "} else", "if    ( HttpHeaders . CONTENT _ LENGTH . equalsIgnoreCase ( name )  )     {", "setContentLength (  ( value   instanceof   Number    ?     (  ( Number )     ( value )  )  . intValue (  )     :    Integer . parseInt ( value . toString (  )  )  )  )  ;", "return   true ;", "} else", "if    ( HttpHeaders . CONTENT _ LANGUAGE . equalsIgnoreCase ( name )  )     {", "http . HttpHeaders   headers    =    new   http . HttpHeaders (  )  ;", "headers . add ( HttpHeaders . CONTENT _ LANGUAGE ,    value . toString (  )  )  ;", "Locale   language    =    headers . getContentLanguage (  )  ;", "this . locale    =     ( language    !  =    null )     ?    language    :    getDefault (  )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["setSpecialHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . writerAccessAllowed    =    writerAccessAllowed ;", "}", "METHOD_END"], "methodName": ["setWriterAccessAllowed"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . contentType )     !  =    null )     {", "StringBuilder   sb    =    new   StringBuilder ( this . contentType )  ;", "if    (  (  !  ( this . contentType . toLowerCase (  )  . contains (  . CHARSET _ PREFIX )  )  )     &  &     ( this . charset )  )     {", "sb . append (  \"  ;  \"  )  . append (  . CHARSET _ PREFIX )  . append ( this . characterEncoding )  ;", "}", "doAddHeaderValue ( CONTENT _ TYPE ,    sb . toString (  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["updateContentTypeHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "response . addDateHeader (  \" Last - Modified \"  ,     1  4  3  7  4  7  2  8  0  0  0  0  0 L )  ;", "response . addDateHeader (  \" Last - Modified \"  ,     1  4  3  7  4  7  2  8  0  1  0  0  0 L )  ;", "assertEquals (  \" Tue ,     2  1    Jul    2  0  1  5     1  0  :  0  0  :  0  0    GMT \"  ,    response . getHeaders (  \" Last - Modified \"  )  . get (  0  )  )  ;", "assertEquals (  \" Tue ,     2  1    Jul    2  0  1  5     1  0  :  0  0  :  0  1    GMT \"  ,    response . getHeaders (  \" Last - Modified \"  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["addDateHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . setContentLength (  6  6  )  ;", "assertEquals (  6  6  ,    response . getContentLength (  )  )  ;", "assertEquals (  \"  6  6  \"  ,    response . getHeader (  \" Content - Length \"  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . addHeader (  \" Content - Length \"  ,     \"  6  6  \"  )  ;", "assertEquals (  6  6  ,    response . getContentLength (  )  )  ;", "assertEquals (  \"  6  6  \"  ,    response . getHeader (  \" Content - Length \"  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLengthHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . addIntHeader (  \" Content - Length \"  ,     6  6  )  ;", "assertEquals (  6  6  ,    response . getContentLength (  )  )  ;", "assertEquals (  \"  6  6  \"  ,    response . getHeader (  \" Content - Length \"  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLengthIntHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain \"  ;", "response . addHeader (  \" Content - Type \"  ,    contentType )  ;", "assertEquals ( contentType ,    response . getContentType (  )  )  ;", "assertEquals ( contentType ,    response . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals ( DEFAULT _ CHARACTER _ ENCODING ,    response . getCharacterEncoding (  )  )  ;", "response    =    new    (  )  ;", "response . setHeader (  \" Content - Type \"  ,    contentType )  ;", "assertEquals ( contentType ,    response . getContentType (  )  )  ;", "assertEquals ( contentType ,    response . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals ( DEFAULT _ CHARACTER _ ENCODING ,    response . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain ; charset = UTF -  8  \"  ;", "response . setHeader (  \" Content - Type \"  ,    contentType )  ;", "assertEquals ( contentType ,    response . getContentType (  )  )  ;", "assertEquals ( contentType ,    response . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    response . getCharacterEncoding (  )  )  ;", "response    =    new    (  )  ;", "response . addHeader (  \" Content - Type \"  ,    contentType )  ;", "assertEquals ( contentType ,    response . getContentType (  )  )  ;", "assertEquals ( contentType ,    response . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    response . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeHeaderUTF8"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain ; charset =  \\  \" utf -  8  \\  \"  ; foo =  \\  \" charset = bar \\  \"  ; foocharset = bar ; foo = bar \"  ;", "response . setHeader (  \" Content - Type \"  ,    contentType )  ;", "assertEquals ( contentType ,    response . getContentType (  )  )  ;", "assertEquals ( contentType ,    response . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    response . getCharacterEncoding (  )  )  ;", "response    =    new    (  )  ;", "response . addHeader (  \" Content - Type \"  ,    contentType )  ;", "assertEquals ( contentType ,    response . getContentType (  )  )  ;", "assertEquals ( contentType ,    response . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    response . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeHeaderWithMoreComplexCharsetSyntax"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "Cookie   cookie    =    new   Cookie (  \" foo \"  ,     \" bar \"  )  ;", "cookie . setPath (  \"  / path \"  )  ;", "cookie . setDomain (  \" example . com \"  )  ;", "cookie . setMaxAge (  0  )  ;", "cookie . setSecure ( true )  ;", "cookie . setHttpOnly ( true )  ;", "r . addCookie ( cookie )  ;", "assertEquals (  (  \" foo = bar ;    Path =  / path ;    Domain = example . com ;     \"     +     (  \" Max - Age =  0  ;    Expires = Thu ,     1    Jan    1  9  7  0     0  0  :  0  0  :  0  0    GMT ;     \"     +     \" Secure ;    HttpOnly \"  )  )  ,    r . getHeader ( SET _ COOKIE )  )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "long   time    =     1  4  3  7  4  7  2  8  0  0  0  0  0 L ;", "r . setDateHeader (  \" Last - Modified \"  ,    time )  ;", "assertEquals (  \" Tue ,     2  1    Jul    2  0  1  5     1  0  :  0  0  :  0  0    GMT \"  ,    r . getHeader (  \" Last - Modified \"  )  )  ;", "assertEquals ( time ,    r . getDateHeader (  \" Last - Modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getDateHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . setHeader (  \" Last - Modified \"  ,     \" invalid \"  )  ;", "assertEquals (  \" invalid \"  ,    response . getHeader (  \" Last - Modified \"  )  )  ;", "response . getDateHeader (  \" Last - Modified \"  )  ;", "}", "METHOD_END"], "methodName": ["getInvalidDateHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( response . getHeader (  \" Last - Modified \"  )  )  ;", "assertEquals (  (  -  1  )  ,    response . getDateHeader (  \" Last - Modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getNonExistentDateHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "final   String   headerName    =     \" Header 1  \"  ;", "r . addHeader ( headerName ,     \" value 1  \"  )  ;", "Collection < String >    rHeaders    =    r . getHeaderNames (  )  ;", "assertNotNull ( rHeaders )  ;", "assertEquals (  1  ,    rHeaders . size (  )  )  ;", "assertEquals (  \" HTTP   header   casing   not   being   preserved \"  ,    headerName ,    rHeaders . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaderNameCasingIsPreserved"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   redirectUrl    =     \"  / redirect \"  ;", "r . setHeader (  \" Location \"  ,    redirectUrl )  ;", "assertEquals ( redirectUrl ,    r . getRedirectedUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["locationHeaderUpdatesGetRedirectedUrl"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . sendError ( SC _ NOT _ FOUND )  ;", "response . setStatus ( SC _ OK )  ;", "assertEquals ( SC _ NOT _ FOUND ,    response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["modifyStatusAfterSendError"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . sendError ( SC _ NOT _ FOUND )  ;", "response . setStatus ( SC _ INTERNAL _ SERVER _ ERROR ,     \" Server   Error \"  )  ;", "assertEquals ( SC _ NOT _ FOUND ,    response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["modifyStatusMessageAfterSendError"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   redirectUrl    =     \"  / redirect \"  ;", "r . sendRedirect ( redirectUrl )  ;", "assertEquals ( SC _ MOVED _ TEMPORARILY ,    r . getStatus (  )  )  ;", "assertEquals ( redirectUrl ,    r . getHeader (  \" Location \"  )  )  ;", "assertEquals ( redirectUrl ,    r . getRedirectedUrl (  )  )  ;", "assertTrue ( r . isCommitted (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendRedirect"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( response . isCommitted (  )  )  ;", "response . getOutputStream (  )  . write (  ' X '  )  ;", "assertFalse ( response . isCommitted (  )  )  ;", "response . flushBuffer (  )  ;", "assertTrue ( response . isCommitted (  )  )  ;", "assertEquals (  1  ,    response . getContentAsByteArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["servletOutputStreamCommittedOnFlushBuffer"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( response . isCommitted (  )  )  ;", "response . getOutputStream (  )  . write (  ' X '  )  ;", "assertFalse ( response . isCommitted (  )  )  ;", "response . getOutputStream (  )  . flush (  )  ;", "assertTrue ( response . isCommitted (  )  )  ;", "assertEquals (  1  ,    response . getContentAsByteArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["servletOutputStreamCommittedOnOutputStreamFlush"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( response . isCommitted (  )  )  ;", "response . getOutputStream (  )  . write (  ' X '  )  ;", "assertFalse ( response . isCommitted (  )  )  ;", "int   size    =    response . getBufferSize (  )  ;", "response . getOutputStream (  )  . write ( new   byte [ size ]  )  ;", "assertTrue ( response . isCommitted (  )  )  ;", "assertEquals (  ( size    +     1  )  ,    response . getContentAsByteArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["servletOutputStreamCommittedWhenBufferSizeExceeded"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . getWriter (  )  . write (  ' X '  )  ;", "assertEquals (  \" X \"  ,    response . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["servletWriterAutoFlushedForChar"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . getWriter (  )  . write (  \" XY \"  . toCharArray (  )  )  ;", "assertEquals (  \" XY \"  ,    response . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["servletWriterAutoFlushedForCharArray"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . getWriter (  )  . write (  \" X \"  )  ;", "assertEquals (  \" X \"  ,    response . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["servletWriterAutoFlushedForString"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( response . isCommitted (  )  )  ;", "response . getWriter (  )  . write (  \" X \"  )  ;", "assertFalse ( response . isCommitted (  )  )  ;", "response . getWriter (  )  . flush (  )  ;", "assertTrue ( response . isCommitted (  )  )  ;", "assertEquals (  1  ,    response . getContentAsByteArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["servletWriterCommittedOnWriterFlush"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( response . isCommitted (  )  )  ;", "response . getWriter (  )  . write (  \" X \"  )  ;", "assertFalse ( response . isCommitted (  )  )  ;", "int   size    =    response . getBufferSize (  )  ;", "char [  ]    data    =    new   char [ size ]  ;", "Arrays . fill ( data ,     ' p '  )  ;", "response . getWriter (  )  . write ( data )  ;", "assertTrue ( response . isCommitted (  )  )  ;", "assertEquals (  ( size    +     1  )  ,    response . getContentAsByteArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["servletWriterCommittedWhenBufferSizeExceeded"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . setCharacterEncoding (  \" UTF -  8  \"  )  ;", "response . setContentType (  \" test / plain \"  )  ;", "assertEquals (  \" test / plain \"  ,    response . getContentType (  )  )  ;", "assertEquals (  \" test / plain ; charset = UTF -  8  \"  ,    response . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    response . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["setCharacterEncodingThenContentType"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain \"  ;", "r . setContentType ( contentType )  ;", "assertEquals ( contentType ,    r . getContentType (  )  )  ;", "assertEquals ( contentType ,    r . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals ( DEFAULT _ CHARACTER _ ENCODING ,    r . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . setContentType (  \" test / plain \"  )  ;", "response . setCharacterEncoding (  \" UTF -  8  \"  )  ;", "assertEquals (  \" test / plain \"  ,    response . getContentType (  )  )  ;", "assertEquals (  \" test / plain ; charset = UTF -  8  \"  ,    response . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    response . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentTypeThenCharacterEncoding"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" test / plain ; charset = UTF -  8  \"  ;", "r . setContentType ( contentType )  ;", "assertEquals (  \" UTF -  8  \"  ,    r . getCharacterEncoding (  )  )  ;", "assertEquals ( contentType ,    r . getContentType (  )  )  ;", "assertEquals ( contentType ,    r . getHeader (  \" Content - Type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentTypeUTF8"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . setDateHeader (  \" Last - Modified \"  ,     1  4  3  7  4  7  2  8  0  0  0  0  0 L )  ;", "assertEquals (  \" Tue ,     2  1    Jul    2  0  1  5     1  0  :  0  0  :  0  0    GMT \"  ,    response . getHeader (  \" Last - Modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setDateHeader"], "fileName": "org.springframework.mock.web.MockHttpServletResponseTests"}, {"methodBody": ["METHOD_START", "{", "this . lastAccessedTime    =    System . currentTimeMillis (  )  ;", "this . isNew    =    false ;", "}", "METHOD_END"], "methodName": ["access"], "fileName": "org.springframework.mock.web.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  !  ( isInvalid (  )  )  )  ,     \" The   session   has   already   been   invalidated \"  )  ;", "}", "METHOD_END"], "methodName": ["assertIsValid"], "fileName": "org.springframework.mock.web.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "this . id    =    Integer . toString (  (  ( MockHttpSession . nextId )  +  +  )  )  ;", "return   this . id ;", "}", "METHOD_END"], "methodName": ["changeSessionId"], "fileName": "org.springframework.mock.web.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator < Map . Entry < String ,    Object >  >    it    =    this . attributes . entrySet (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Map . Entry < String ,    Object >    entry    =    it . next (  )  ;", "String   name    =    entry . getKey (  )  ;", "Object   value    =    entry . getValue (  )  ;", "it . remove (  )  ;", "if    ( value   instanceof   BindingListener )     {", "(  ( BindingListener )     ( value )  )  . valueUnbound ( new   BindingEvent ( this ,    name ,    value )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["clearAttributes"], "fileName": "org.springframework.mock.web.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( state   instanceof   Map )  ,     \" Serialized   state   needs   to   be   of   type    [ Map ]  \"  )  ;", "this . attributes . putAll (  (  ( Map < St ,    Object >  )     ( state )  )  )  ;", "}", "METHOD_END"], "methodName": ["deserializeState"], "fileName": "org.springframework.mock.web.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "return   this . invalid ;", "}", "METHOD_END"], "methodName": ["isInvalid"], "fileName": "org.springframework.mock.web.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "HashMap < String ,    Serializable >    state    =    new   HashMap <  >  (  )  ;", "for    ( Iterator < Map . Entry < String ,    Object >  >    it    =    this . attributes . entrySet (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Map . Entry < String ,    Object >    entry    =    it . next (  )  ;", "String   name    =    entry . getKey (  )  ;", "Object   value    =    entry . getValue (  )  ;", "it . remove (  )  ;", "if    ( value   instanceof   Serializable )     {", "state . put ( name ,     (  ( Serializable )     ( value )  )  )  ;", "} else    {", "if    ( value   instanceof   BindingListener )     {", "(  ( BindingListener )     ( value )  )  . valueUnbound ( new   BindingEvent ( this ,    name ,    value )  )  ;", "}", "}", "}", "return   state ;", "}", "METHOD_END"], "methodName": ["serializeState"], "fileName": "org.springframework.mock.web.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "this . isNew    =    value ;", "}", "METHOD_END"], "methodName": ["setNew"], "fileName": "org.springframework.mock.web.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . getAttributeNames (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNamesOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . getAttribute (  \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . getCreationTime (  )  ;", "}", "METHOD_END"], "methodName": ["getCreationTimeOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . getLastAccessedTime (  )  ;", "}", "METHOD_END"], "methodName": ["getLastAccessedTimeOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . getValueNames (  )  ;", "}", "METHOD_END"], "methodName": ["getValueNamesOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . getValue (  \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["getValueOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( session . isInvalid (  )  )  ;", "session . invalidate (  )  ;", "assertTrue ( session . isInvalid (  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidateOnce"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . invalidate (  )  ;", "}", "METHOD_END"], "methodName": ["invalidateTwice"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . isNew (  )  ;", "}", "METHOD_END"], "methodName": ["isNewOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . putValue (  \" name \"  ,     \" value \"  )  ;", "}", "METHOD_END"], "methodName": ["putValueOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . removeAttribute (  \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["removeAttributeOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . removeValue (  \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["removeValueOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "session . invalidate (  )  ;", "session . setAttribute (  \" name \"  ,     \" value \"  )  ;", "}", "METHOD_END"], "methodName": ["setAttributeOnInvalidatedSession"], "fileName": "org.springframework.mock.web.MockHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . targetWriter )     =  =    null )     {", "this . targetWriter    =    this . response . getWriter (  )  ;", "}", "return   this . targetWriter ;", "}", "METHOD_END"], "methodName": ["getTargetWriter"], "fileName": "org.springframework.mock.web.MockJspWriter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( file ,     \" MultipartFile   must   not   be   null \"  )  ;", "this . multipartFiles . add ( file . getName (  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["addFile"], "fileName": "org.springframework.mock.web.MockMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Set < String >    fileNames    =    new   HashSet <  >  (  )  ;", "Iterator < String >    fileIter    =    request . getFileNames (  )  ;", "while    ( fileIter . hasNext (  )  )     {", "fileNames . add ( fileIter . next (  )  )  ;", "}", "assertEquals (  2  ,    fileNames . size (  )  )  ;", "assertTrue ( fileNames . contains (  \" file 1  \"  )  )  ;", "assertTrue ( fileNames . contains (  \" file 2  \"  )  )  ;", "File   file 1     =    request . getFile (  \" file 1  \"  )  ;", "File   file 2     =    request . getFile (  \" file 2  \"  )  ;", "Map < String ,    File >    fileMap    =    request . getFileMap (  )  ;", "List < String >    fileMapKeys    =    new   LinkedList ( fileMap . keySet (  )  )  ;", "assertEquals (  2  ,    fileMapKeys . size (  )  )  ;", "assertEquals ( file 1  ,    fileMap . get (  \" file 1  \"  )  )  ;", "assertEquals ( file 2  ,    fileMap . get (  \" file 2  \"  )  )  ;", "assertEquals (  \" file 1  \"  ,    file 1  . getName (  )  )  ;", "assertEquals (  \"  \"  ,    file 1  . getOriginalFilename (  )  )  ;", "assertNull ( file 1  . getContentType (  )  )  ;", "assertTrue ( ObjectUtils . nullSafeEquals (  \" myContent 1  \"  . getBytes (  )  ,    file 1  . getBytes (  )  )  )  ;", "assertTrue ( ObjectUtils . nullSafeEquals (  \" myContent 1  \"  . getBytes (  )  ,    FileCopyUtils . copyToByteArray ( file 1  . getInputStream (  )  )  )  )  ;", "assertEquals (  \" file 2  \"  ,    file 2  . getName (  )  )  ;", "assertEquals (  \" myOrigFilename \"  ,    file 2  . getOriginalFilename (  )  )  ;", "assertEquals (  \" text / plain \"  ,    file 2  . getContentType (  )  )  ;", "assertTrue ( ObjectUtils . nullSafeEquals (  \" myContent 2  \"  . getBytes (  )  ,    file 2  . getBytes (  )  )  )  ;", "assertTrue ( ObjectUtils . nullSafeEquals (  \" myContent 2  \"  . getBytes (  )  ,    FileCopyUtils . copyToByteArray ( file 2  . getInputStream (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestMultipartHttpServletRequest"], "fileName": "org.springframework.mock.web.MockMultipartHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "assertFalse ( request . getFileNames (  )  . hasNext (  )  )  ;", "assertNull ( request . getFile (  \" file 1  \"  )  )  ;", "assertNull ( request . getFile (  \" file 2  \"  )  )  ;", "assertTrue ( request . getFileMap (  )  . isEmpty (  )  )  ;", "request . addFile ( new   MockMultipartFile (  \" file 1  \"  ,     \" myContent 1  \"  . getBytes (  )  )  )  ;", "request . addFile ( new   MockMultipartFile (  \" file 2  \"  ,     \" myOrigFilename \"  ,     \" text / plain \"  ,     \" myContent 2  \"  . getBytes (  )  )  )  ;", "doTestMultipartHttpServletRequest ( request )  ;", "}", "METHOD_END"], "methodName": ["mockMultipartHttpServletRequestWithByteArray"], "fileName": "org.springframework.mock.web.MockMultipartHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "request . addFile ( new   MockMultipartFile (  \" file 1  \"  ,    new   ByteArrayInputStream (  \" myContent 1  \"  . getBytes (  )  )  )  )  ;", "request . addFile ( new   MockMultipartFile (  \" file 2  \"  ,     \" myOrigFilename \"  ,     \" text / plain \"  ,    new   ByteArrayInputStream (  \" myContent 2  \"  . getBytes (  )  )  )  )  ;", "doTestMultipartHttpServletRequest ( request )  ;", "}", "METHOD_END"], "methodName": ["mockMultipartHttpServletRequestWithInputStream"], "fileName": "org.springframework.mock.web.MockMultipartHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "return   Collections . enumeration ( new   LinkedHashSet <  >  ( this . attributes . keySet (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNames"], "fileName": "org.springframework.mock.web.MockPageContext"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . response )    instanceof   MockHttpServletResponse )  ,     \" MockHttpServletResponse   required \"  )  ;", "return    (  ( MockHttpServletResponse )     ( this . response )  )  . getntAsByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsByteArray"], "fileName": "org.springframework.mock.web.MockPageContext"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . response )    instanceof   MockHttpServletResponse )  ,     \" MockHttpServletResponse   required \"  )  ;", "return    (  ( MockHttpServletResponse )     ( this . response )  )  . getntAsString (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsString"], "fileName": "org.springframework.mock.web.MockPageContext"}, {"methodBody": ["METHOD_START", "{", "ctx . setAttribute ( key ,    value ,    APPLICATION _ SCOPE )  ;", "ctx . removeAttribute ( key )  ;", "assertNull ( ctx . getAttribute ( key ,    PAGE _ SCOPE )  )  ;", "assertNull ( ctx . getAttribute ( key ,    APPLICATION _ SCOPE )  )  ;", "assertNull ( ctx . getAttribute ( key ,    REQUEST _ SCOPE )  )  ;", "assertNull ( ctx . getAttribute ( key ,    SESSION _ SCOPE )  )  ;", "}", "METHOD_END"], "methodName": ["removeAttributeWithNoScopeSpecifiedRemovesValueFromAllScopes"], "fileName": "org.springframework.mock.web.MockPageContextTests"}, {"methodBody": ["METHOD_START", "{", "ctx . setAttribute ( key ,    value )  ;", "assertEquals ( value ,    ctx . getAttribute ( key ,    PAGE _ SCOPE )  )  ;", "assertNull ( ctx . getAttribute ( key ,    APPLICATION _ SCOPE )  )  ;", "assertNull ( ctx . getAttribute ( key ,    REQUEST _ SCOPE )  )  ;", "assertNull ( ctx . getAttribute ( key ,    SESSION _ SCOPE )  )  ;", "}", "METHOD_END"], "methodName": ["setAttributeWithNoScopeUsesPageScope"], "fileName": "org.springframework.mock.web.MockPageContextTests"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.mock.web.MockPart"}, {"methodBody": ["METHOD_START", "{", "if    ( response   instanceof   MockHttpServletResponse )     {", "return    (  ( MockHttpServletResponse )     ( response )  )  ;", "}", "if    ( response   instanceof   HttpServletResponseWrapper )     {", "return   getMockHttpServletResponse (  (  ( HttpServletResponseWrapper )     ( response )  )  . getResponse (  )  )  ;", "}", "throw   new   IllegalArgumentException (  \"    requires   MockHttpServletResponse \"  )  ;", "}", "METHOD_END"], "methodName": ["getMockHttpServletResponse"], "fileName": "org.springframework.mock.web.MockRequestDispatcher"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . initParameters . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addInitParameter"], "fileName": "org.springframework.mock.web.MockServletConfig"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . initParameters . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addInitParameter"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( fileExtension ,     \"  ' fileExtension '    must   not   be   null \"  )  ;", "this . mimeTypes . put ( fileExtension ,    mimeType )  ;", "}", "METHOD_END"], "methodName": ["addMimeType"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . declaredRoles )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredRoles"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultServletName ;", "}", "METHOD_END"], "methodName": ["getDefaultServletName"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( path . startsWith (  \"  /  \"  )  )  )     {", "path    =     \"  /  \"     +    path ;", "}", "return    ( this . resourceBasePath )     +    path ;", "}", "METHOD_END"], "methodName": ["getResourceLocation"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . contexts . put ( contextPath ,    context )  ;", "}", "METHOD_END"], "methodName": ["registerContext"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" RequestDispatcher   name   must   not   be   null \"  )  ;", "Assert . notNull ( requestDispatcher ,     \" RequestDispatcher   must   not   be   null \"  )  ;", "this . namedRequestDispatchers . put ( name ,    requestDispatcher )  ;", "}", "METHOD_END"], "methodName": ["registerNamedDispatcher"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . contextPath    =    contextPath ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( defaultServletName ,     \" defaultServletName   must   not   be   null   or   empty \"  )  ;", "unregisterNamedDispatcher ( this . defaultServletName )  ;", "this . defaultServletName    =    defaultServletName ;", "registerNamedDispatcher ( this . defaultServletName ,    new   MockRequestDispatcher ( this . defaultServletName )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultServletName"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . effectiveMajorVersion    =    effectiveMajorVersion ;", "}", "METHOD_END"], "methodName": ["setEffectiveMajorVersion"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . effectiveMinorVersion    =    effectiveMinorVersion ;", "}", "METHOD_END"], "methodName": ["setEffectiveMinorVersion"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . majorVersion    =    majorVersion ;", "}", "METHOD_END"], "methodName": ["setMajorVersion"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . minorVersion    =    minorVersion ;", "}", "METHOD_END"], "methodName": ["setMinorVersion"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . servletContextName    =    servletContextName ;", "}", "METHOD_END"], "methodName": ["setServletContextName"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" RequestDispatcher   name   must   not   be   null \"  )  ;", "this . namedRequestDispatchers . remove ( name )  ;", "}", "METHOD_END"], "methodName": ["unregisterNamedDispatcher"], "fileName": "org.springframework.mock.web.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . assertNull ( sc . getFilterRegistration (  \" filter \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getFilterRegistration"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,     ?    extends   FilterRegistration >    filterRegistrations    =    sc . getFilterRegistrations (  )  ;", "Assert . assertNotNull ( filterRegistrations )  ;", "Assert . assertEquals (  0  ,    filterRegistrations . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFilterRegistrations"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  \" text / html \"  ,    sc . getMimeType (  \" test . html \"  )  )  ;", "Assert . assertEquals (  \" image / gif \"  ,    sc . getMimeType (  \" test . gif \"  )  )  ;", "Assert . assertNull ( sc . getMimeType (  \" test . foobar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMimeType"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "sc . addMimeType (  \" enigma \"  ,    new   MediaType (  \" text \"  ,     \" enigma \"  )  )  ;", "Assert . assertEquals (  \" text / enigma \"  ,    sc . getMimeType (  \" filename . enigma \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMimeTypeWithCustomConfiguredType"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =     \" default \"  ;", "RequestDispatcher   namedDispatcher    =    sc . getNamedDispatcher ( name )  ;", "Assert . assertNotNull ( namedDispatcher )  ;", "MockHttpResponse   response    =    new   MockHttpResponse (  )  ;", "namedDispatcher . forward ( new   MockHttpRequest ( sc )  ,    response )  ;", "Assert . assertEquals ( name ,    response . getForwardedUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNamedDispatcherForDefaultServlet"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertNull ( sc . getServletRegistration (  \" servlet \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getServletRegistration"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,     ?    extends   ServletRegistration >    servletRegistrations    =    sc . getServletRegistrations (  )  ;", "Assert . assertNotNull ( servletRegistrations )  ;", "Assert . assertEquals (  0  ,    servletRegistrations . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getServletRegistrations"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    paths    =    sc . getResourcePaths (  \"  / web \"  )  ;", "Assert . assertNotNull ( paths )  ;", "Assert . assertTrue ( paths . contains (  \"  / web /  . class \"  )  )  ;", "}", "METHOD_END"], "methodName": ["listFiles"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    paths    =    sc . getResourcePaths (  \"  / web / invalid \"  )  ;", "Assert . assertNull ( paths )  ;", "}", "METHOD_END"], "methodName": ["listInvalidPath"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    paths    =    sc . getResourcePaths (  \"  / web / MockServletContextTests . class \"  )  ;", "Assert . assertNull ( paths )  ;", "}", "METHOD_END"], "methodName": ["listNonDirectory"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    paths    =    sc . getResourcePaths (  \"  /  \"  )  ;", "Assert . assertNotNull ( paths )  ;", "Assert . assertTrue ( paths . contains (  \"  / web /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["listSubdirectories"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =     \" test - servlet \"  ;", "final   String   url    =     \"  / test \"  ;", "Assert . assertNull ( sc . getNamedDispatcher ( name )  )  ;", "sc . registerNamedDispatcher ( name ,    new   MockRequestDispatcher ( url )  )  ;", "RequestDispatcher   namedDispatcher    =    sc . getNamedDispatcher ( name )  ;", "Assert . assertNotNull ( namedDispatcher )  ;", "MockHttpResponse   response    =    new   MockHttpResponse (  )  ;", "namedDispatcher . forward ( new   MockHttpRequest ( sc )  ,    response )  ;", "Assert . assertEquals ( url ,    response . getForwardedUrl (  )  )  ;", "sc . unregisterNamedDispatcher ( name )  ;", "Assert . assertNull ( sc . getNamedDispatcher ( name )  )  ;", "}", "METHOD_END"], "methodName": ["registerAndUnregisterNamedDispatcher"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   sc 2     =    new   MockServletContext (  )  ;", "sc . setContextPath (  \"  /  \"  )  ;", "sc . registerContext (  \"  / second \"  ,    sc 2  )  ;", "Assert . assertSame ( sc ,    sc . getContext (  \"  /  \"  )  )  ;", "Assert . assertSame ( sc 2  ,    sc . getContext (  \"  / second \"  )  )  ;", "}", "METHOD_END"], "methodName": ["registerContextAndGetContext"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  3  ,    sc . getMajorVersion (  )  )  ;", "Assert . assertEquals (  1  ,    sc . getMinorVersion (  )  )  ;", "Assert . assertEquals (  3  ,    sc . getEffectiveMajorVersion (  )  )  ;", "Assert . assertEquals (  1  ,    sc . getEffectiveMinorVersion (  )  )  ;", "sc . setMajorVersion (  4  )  ;", "sc . setMinorVersion (  0  )  ;", "sc . setEffectiveMajorVersion (  4  )  ;", "sc . setEffectiveMinorVersion (  0  )  ;", "Assert . assertEquals (  4  ,    sc . getMajorVersion (  )  )  ;", "Assert . assertEquals (  0  ,    sc . getMinorVersion (  )  )  ;", "Assert . assertEquals (  4  ,    sc . getEffectiveMajorVersion (  )  )  ;", "Assert . assertEquals (  0  ,    sc . getEffectiveMinorVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["servletVersion"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "final   String   originalDefault    =     \" default \"  ;", "final   String   newDefault    =     \" test \"  ;", "Assert . assertNotNull ( sc . getNamedDispatcher ( originalDefault )  )  ;", "sc . setDefaultName ( newDefault )  ;", "Assert . assertEquals ( newDefault ,    sc . getDefaultName (  )  )  ;", "Assert . assertNull ( sc . getNamedDispatcher ( originalDefault )  )  ;", "RequestDispatcher   namedDispatcher    =    sc . getNamedDispatcher ( newDefault )  ;", "Assert . assertNotNull ( namedDispatcher )  ;", "MockHttpResponse   response    =    new   MockHttpResponse (  )  ;", "namedDispatcher . forward ( new   MockHttpRequest ( sc )  ,    response )  ;", "Assert . assertEquals ( newDefault ,    response . getForwardedUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultServletName"], "fileName": "org.springframework.mock.web.MockServletContextTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MockServerRequest . BuilderImpl (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.mock.web.reactive.function.server.MockServerRequest"}, {"methodBody": ["METHOD_START", "{", "return   new   MockServerWebExchange ( requestBuilder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.mock.web.server.MockServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "return   new   MockServerWebExchange ( request )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.mock.web.server.MockServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "IfProfileValue   ifProfileValue    =    AnnotatedElementUtils . findMergedAnnotation ( testClass ,    IfProfileValue . class )  ;", "return    . isTestEnabledInThisEnvironment (  . retrieveProfileValueSource ( testClass )  ,    ifProfileValue )  ;", "}", "METHOD_END"], "methodName": ["isTestEnabledInThisEnvironment"], "fileName": "org.springframework.test.annotation.ProfileValueUtils"}, {"methodBody": ["METHOD_START", "{", "return   ProfileValueUtils . isTestEnabledInThisEnvironment ( ProfileValueUtils . retrieveProfileValueSource ( testClass )  ,    testMethod ,    testClass )  ;", "}", "METHOD_END"], "methodName": ["isTestEnabledInThisEnvironment"], "fileName": "org.springframework.test.annotation.ProfileValueUtils"}, {"methodBody": ["METHOD_START", "{", "IfProfileValue   ifProfileValue    =    AnnotatedElementUtils . findMergedAnnotation ( testClass ,    IfProfileValue . class )  ;", "boolean   classLevelEnabled    =     . isTestEnabledInThisEnvironment ( profileValueSource ,    ifProfileValue )  ;", "if    ( classLevelEnabled )     {", "ifProfileValue    =    AnnotatedElementUtils . findMergedAnnotation ( testMethod ,    IfProfileValue . class )  ;", "return    . isTestEnabledInThisEnvironment ( profileValueSource ,    ifProfileValue )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTestEnabledInThisEnvironment"], "fileName": "org.springframework.test.annotation.ProfileValueUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ifProfileValue    =  =    null )     {", "return   true ;", "}", "String   environmentValue    =    profileValueSource . get ( ifProfileValue . name (  )  )  ;", "String [  ]    annotatedValues    =    ifProfileValue . values (  )  ;", "if    ( StringUtils . hasLength ( ifProfileValue . value (  )  )  )     {", "Assert . isTrue (  (  ( annotatedValues . length )     =  =     0  )  ,     (  )     -  >     \" Setting   both   the    ' value '    and    ' values '    attributes    \"     +     \" of    @ IfProfileValue   is   not   allowed :    choose   one   or   the   other .  \"  )  ;", "annotatedValues    =    new   String [  ]  {    ifProfileValue . value (  )     }  ;", "}", "for    ( String   value    :    annotatedValues )     {", "if    ( ObjectUtils . nullSafeEquals ( value ,    environmentValue )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isTestEnabledInThisEnvironment"], "fileName": "org.springframework.test.annotation.ProfileValueUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testClass ,     \" testClass   must   not   be   null \"  )  ;", "Class < ProfileValueSourceConfiguration >    annotationType    =    ProfileValueSourceConfiguration . class ;", "ProfileValueSourceConfiguration   config    =    AnnotatedElementUtils . findMergedAnnotation ( testClass ,    annotationType )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  \" Retrieved    @ ProfileValueSourceConfiguration    [  \"     +    config )     +     \"  ]    for   test   class    [  \"  )     +     ( testClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "Class <  ?    extends   ProfileValueSource >    profileValueSourceType ;", "if    ( config    !  =    null )     {", "profileValueSourceType    =    config . value (  )  ;", "} else    {", "profileValueSourceType    =     (  ( Class <  ?    extends   ProfileValueSource >  )     ( AnnotationUtils . getDefaultValue ( annotationType )  )  )  ;", "Assert . state (  ( profileValueSourceType    !  =    null )  ,     \" No   default   ProfileValueSource   class \"  )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  \" Retrieved   ProfileValueSource   type    [  \"     +    profileValueSourceType )     +     \"  ]    for   class    [  \"  )     +     ( testClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "ProfileValueSource   profileValueSource ;", "if    (  ( SystemProfileValueSource . class )     =  =    profileValueSourceType )     {", "profileValueSource    =    SystemProfileValueSource . getInstance (  )  ;", "} else    {", "try    {", "profileValueSource    =    ReflectionUtils . accessibleConstructor ( profileValueSourceType )  . newInstance (  )  ;", "}    catch    ( Exception   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  (  (  (  \" Could   not   instantiate   a   ProfileValueSource   of   type    [  \"     +    profileValueSourceType )     +     \"  ]    for   class    [  \"  )     +     ( testClass . getName (  )  )  )     +     \"  ]  :    using   default .  \"  )  ,    ex )  ;", "}", "profileValueSource    =    SystemProfileValueSource . getInstance (  )  ;", "}", "}", "return   profileValueSource ;", "}", "METHOD_END"], "methodName": ["retrieveProfileValueSource"], "fileName": "org.springframework.test.annotation.ProfileValueUtils"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  (  (  \" Test   class    [  \"     +    testClass )     +     \"  ]    should   be   disbled .  \"  )  ,    ProfileValueUtils . isTestEnabledInThisEnvironment ( testClass )  )  ;", "}", "METHOD_END"], "methodName": ["assertClassIsDisabled"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  (  \" Test   class    [  \"     +    testClass )     +     \"  ]    should   be   enabled .  \"  )  ,    ProfileValueUtils . isTestEnabledInThisEnvironment ( testClass )  )  ;", "}", "METHOD_END"], "methodName": ["assertClassIsEnabled"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   testMethod    =    testClass . getMethod ( methodName )  ;", "assertFalse (  (  (  \" Test   method    [  \"     +    testMethod )     +     \"  ]    should   be   disabled .  \"  )  ,     . isTestEnabledInThisEnvironment ( testMethod ,    testClass )  )  ;", "}", "METHOD_END"], "methodName": ["assertMethodIsDisabled"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   testMethod    =    testClass . getMethod ( methodName )  ;", "assertFalse (  (  (  (  (  \" Test   method    [  \"     +    testMethod )     +     \"  ]    should   be   disabled   for   ProfileValueSource    [  \"  )     +    profileValueSource )     +     \"  ]  .  \"  )  ,     . isTestEnabledInThisEnvironment ( profileValueSource ,    testMethod ,    testClass )  )  ;", "}", "METHOD_END"], "methodName": ["assertMethodIsDisabled"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   testMethod    =    testClass . getMethod ( methodName )  ;", "assertTrue (  (  (  \" Test   method    [  \"     +    testMethod )     +     \"  ]    should   be   enabled .  \"  )  ,     . isTestEnabledInThisEnvironment ( testMethod ,    testClass )  )  ;", "}", "METHOD_END"], "methodName": ["assertMethodIsEnabled"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   testMethod    =    testClass . getMethod ( methodName )  ;", "assertTrue (  (  (  (  (  \" Test   method    [  \"     +    testMethod )     +     \"  ]    should   be   enabled   for   ProfileValueSource    [  \"  )     +    profileValueSource )     +     \"  ]  .  \"  )  ,     . isTestEnabledInThisEnvironment ( profileValueSource ,    testMethod ,    testClass )  )  ;", "}", "METHOD_END"], "methodName": ["assertMethodIsEnabled"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertClassIsEnabled ( ProfileValueUtilsTests . NonAnnotated . class )  ;", "assertClassIsEnabled ( ProfileValueUtilsTests . EnabledAnnotatedSingleValue . class )  ;", "assertClassIsEnabled ( ProfileValueUtilsTests . EnabledAnnotatedMultiValue . class )  ;", "assertClassIsEnabled ( ProfileValueUtilsTests . MetaEnabledClass . class )  ;", "assertClassIsEnabled ( ProfileValueUtilsTests . MetaEnabledWithCustomProfileValueSourceClass . class )  ;", "assertClassIsEnabled ( ProfileValueUtilsTests . EnabledWithCustomProfileValueSourceOnTestInterface . class )  ;", "assertClassIsDisabled ( ProfileValueUtilsTests . DisabledAnnotatedSingleValue . class )  ;", "assertClassIsDisabled ( ProfileValueUtilsTests . DisabledAnnotatedSingleValueOnTestInterface . class )  ;", "assertClassIsDisabled ( ProfileValueUtilsTests . DisabledAnnotatedMultiValue . class )  ;", "assertClassIsDisabled ( ProfileValueUtilsTests . MetaDisabledClass . class )  ;", "assertClassIsDisabled ( ProfileValueUtilsTests . MetaDisabledWithCustomProfileValueSourceClass . class )  ;", "}", "METHOD_END"], "methodName": ["isTestEnabledInThisEnvironmentForProvidedClass"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertMethodIsEnabled ( ProfileValueUtilsTests . NON _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . NonAnnotated . class )  ;", "assertMethodIsEnabled ( ProfileValueUtilsTests . NON _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . EnabledAnnotatedSingleValue . class )  ;", "assertMethodIsEnabled ( ProfileValueUtilsTests . ENABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . EnabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . DISABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . EnabledAnnotatedSingleValue . class )  ;", "assertMethodIsEnabled ( ProfileValueUtilsTests . NON _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . MetaEnabledAnnotatedSingleValue . class )  ;", "assertMethodIsEnabled ( ProfileValueUtilsTests . ENABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . MetaEnabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . DISABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . MetaEnabledAnnotatedSingleValue . class )  ;", "assertMethodIsEnabled ( ProfileValueUtilsTests . NON _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . EnabledAnnotatedMultiValue . class )  ;", "assertMethodIsEnabled ( ProfileValueUtilsTests . ENABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . EnabledAnnotatedMultiValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . DISABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . EnabledAnnotatedMultiValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . NON _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . DisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . ENABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . DisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . DISABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . DisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . NON _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . DisabledAnnotatedSingleValueOnTestInterface . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . NON _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . MetaDisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . ENABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . MetaDisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . DISABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . MetaDisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . NON _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . DisabledAnnotatedMultiValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . ENABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . DisabledAnnotatedMultiValue . class )  ;", "assertMethodIsDisabled ( ProfileValueUtilsTests . DISABLED _ ANNOTATED _ METHOD ,    ProfileValueUtilsTests . DisabledAnnotatedMultiValue . class )  ;", "}", "METHOD_END"], "methodName": ["isTestEnabledInThisEnvironmentForProvidedMethodAndClass"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ProfileValueSource   profileValueSource    =    SystemProfileValueSource . getInstance (  )  ;", "assertMethodIsEnabled ( profileValueSource ,     . NON _ ANNOTATED _ METHOD ,     . NonAnnotated . class )  ;", "assertMethodIsEnabled ( profileValueSource ,     . NON _ ANNOTATED _ METHOD ,     . EnabledAnnotatedSingleValue . class )  ;", "assertMethodIsEnabled ( profileValueSource ,     . ENABLED _ ANNOTATED _ METHOD ,     . EnabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( profileValueSource ,     . DISABLED _ ANNOTATED _ METHOD ,     . EnabledAnnotatedSingleValue . class )  ;", "assertMethodIsEnabled ( profileValueSource ,     . NON _ ANNOTATED _ METHOD ,     . EnabledAnnotatedMultiValue . class )  ;", "assertMethodIsEnabled ( profileValueSource ,     . ENABLED _ ANNOTATED _ METHOD ,     . EnabledAnnotatedMultiValue . class )  ;", "assertMethodIsDisabled ( profileValueSource ,     . DISABLED _ ANNOTATED _ METHOD ,     . EnabledAnnotatedMultiValue . class )  ;", "assertMethodIsDisabled ( profileValueSource ,     . NON _ ANNOTATED _ METHOD ,     . DisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( profileValueSource ,     . ENABLED _ ANNOTATED _ METHOD ,     . DisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( profileValueSource ,     . DISABLED _ ANNOTATED _ METHOD ,     . DisabledAnnotatedSingleValue . class )  ;", "assertMethodIsDisabled ( profileValueSource ,     . NON _ ANNOTATED _ METHOD ,     . DisabledAnnotatedMultiValue . class )  ;", "assertMethodIsDisabled ( profileValueSource ,     . ENABLED _ ANNOTATED _ METHOD ,     . DisabledAnnotatedMultiValue . class )  ;", "assertMethodIsDisabled ( profileValueSource ,     . DISABLED _ ANNOTATED _ METHOD ,     . DisabledAnnotatedMultiValue . class )  ;", "}", "METHOD_END"], "methodName": ["isTestEnabledInThisEnvironmentForProvidedProfileValueSourceMethodAndClass"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( ProfileValueUtilsTests . NAME ,    ProfileValueUtilsTests . VALUE )  ;", "}", "METHOD_END"], "methodName": ["setProfileValue"], "fileName": "org.springframework.test.annotation.ProfileValueUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   SystemProfileValueSource . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.test.annotation.SystemProfileValueSource"}, {"methodBody": ["METHOD_START", "{", "Repeat   repeat    =    AnnotatedElementUtils . findMergedAnnotation ( method ,    Repeat . class )  ;", "if    ( repeat    =  =    null )     {", "return    1  ;", "}", "return   Math . max (  1  ,    repeat . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRepeatCount"], "fileName": "org.springframework.test.annotation.TestAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Timed   timed    =    AnnotatedElementUtils . findMergedAnnotation ( method ,    Timed . class )  ;", "if    ( timed    =  =    null )     {", "return    0  ;", "}", "return   Math . max (  0  ,    timed . millis (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTimeout"], "fileName": "org.springframework.test.annotation.TestAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBootstrapContext ( testClass ,    cacheAwareContextLoaderDelegate )  ;", "}", "METHOD_END"], "methodName": ["buildBootstrapContext"], "fileName": "org.springframework.test.context.BootstrapTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   BootstrapUtils . resolveTestContextBootstrapper ( bootstrapContext )  ;", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapper"], "fileName": "org.springframework.test.context.BootstrapTestUtils"}, {"methodBody": ["METHOD_START", "{", "CacheAwareContextLoaderDelegate   cacheAwareContextLoaderDelegate    =    BootstrapUtils . createCacheAwareContextLoaderDelegate (  )  ;", "Class <  ?    extends   BootstrapContext >    clazz    =    null ;", "try    {", "clazz    =     (  ( Class <  ?    extends   BootstrapContext >  )     ( ClassUtils . forName ( BootstrapUtils . DEFAULT _ BOOTSTRAP _ CONTEXT _ CLASS _ NAME ,    BootstrapUtils . class . getClassLoader (  )  )  )  )  ;", "Constructor <  ?    extends   BootstrapContext >    constructor    =    clazz . getConstructor ( Class . class ,    CacheAwareContextLoaderDelegate . class )  ;", "if    ( BootstrapUtils . logger . isDebugEnabled (  )  )     {", "BootstrapUtils . logger . debug ( String . format (  \" Instantiating   BootstrapContext   using   constructor    [  % s ]  \"  ,    constructor )  )  ;", "}", "return   BeanUtils . instantiateClass ( constructor ,    testClass ,    cacheAwareContextLoaderDelegate )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   load   BootstrapContext    [  \"     +    clazz )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createBootstrapContext"], "fileName": "org.springframework.test.context.BootstrapUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   CacheAwareContextLoaderDelegate >    clazz    =    null ;", "try    {", "clazz    =     (  ( Class <  ?    extends   CacheAwareContextLoaderDelegate >  )     ( ClassUtils . forName (  . DEFAULT _ CACHE _ AWARE _ CONTEXT _ LOADER _ DELEGATE _ CLASS _ NAME ,     . class . getClassLoader (  )  )  )  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Instantiating   CacheAwareContextLoaderDelegate   from   class    [  % s ]  \"  ,    clazz . getName (  )  )  )  ;", "}", "return   BeanUtils . instantiateClass ( clazz ,    CacheAwareContextLoaderDelegate . class )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   load   CacheAwareContextLoaderDelegate    [  \"     +    clazz )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createCacheAwareContextLoaderDelegate"], "fileName": "org.springframework.test.context.BootstrapUtils"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   classLoader    =    BootstrapUtils . class . getClassLoader (  )  ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . findMergedAnnotationAttributes ( testClass ,    BootstrapUtils . WEB _ APP _ CONFIGURATION _ ANNOTATION _ CLASS _ NAME ,    false ,    false )  ;", "if    ( attributes    !  =    null )     {", "return   ClassUtils . forName ( BootstrapUtils . DEFAULT _ WEB _ TEST _ CONTEXT _ BOOTSTRAPPER _ CLASS _ NAME ,    classLoader )  ;", "}", "return   ClassUtils . forName ( BootstrapUtils . DEFAULT _ TEST _ CONTEXT _ BOOTSTRAPPER _ CLASS _ NAME ,    classLoader )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultTestContextBootstrapper"], "fileName": "org.springframework.test.context.BootstrapUtils"}, {"methodBody": ["METHOD_START", "{", "Set < BootstrapWith >    annotations    =    AnnotatedElementUtils . findAllMergedAnnotations ( testClass ,    BootstrapWith . class )  ;", "if    ( annotations . isEmpty (  )  )     {", "return   null ;", "}", "Assert . state (  (  ( annotations . size (  )  )     <  =     1  )  ,     (  )     -  >    String . format (  \" Configuration   error :    found   multiple   declarations   of    @ BootstrapWith   for   test   class    [  % s ]  :     % s \"  ,    testClass . getName (  )  ,    annotations )  )  ;", "return   annotations . iterator (  )  . next (  )  . value (  )  ;", "}", "METHOD_END"], "methodName": ["resolveExplicitTestContextBootstrapper"], "fileName": "org.springframework.test.context.BootstrapUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    bootstrapContext . getTestClass (  )  ;", "Class <  ?  >    clazz    =    null ;", "try    {", "clazz    =     . resolveExplicitTestContextBootstrapper ( testClass )  ;", "if    ( clazz    =  =    null )     {", "clazz    =     . resolveDefaultTestContextBootstrapper ( testClass )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Instantiating   TestContextBootstrapper   for   test   class    [  % s ]    from   class    [  % s ]  \"  ,    testClass . getName (  )  ,    clazz . getName (  )  )  )  ;", "}", "TestContextBootstrapper   testContextBootstrapper    =    BeanUtils . instantiateClass ( clazz ,    TestContextBootstrapper . class )  ;", "testContextBootstrapper . setBootstrapContext ( bootstrapContext )  ;", "return   testContextBootstrapper ;", "}    catch    ( IllegalStateException   ex )     {", "throw   ex ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   load   TestContextBootstrapper    [  \"     +    clazz )     +     \"  ]  .    Specify    @ BootstrapWith ' s    ' value '    attribute   or   make   the   default   bootstrapper   class   available .  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapper"], "fileName": "org.springframework.test.context.BootstrapUtils"}, {"methodBody": ["METHOD_START", "{", "BootstrapContext   bootstrapContext    =    BootstrapTestUtils . buildBootstrapContext ( testClass ,    delegate )  ;", "TestContextBootstrapper   bootstrapper    =     . resolveTestContextBootstrapper ( bootstrapContext )  ;", "Assert . assertNotNull ( bootstrapper )  ;", "Assert . assertEquals ( expectedBootstrapper ,    bootstrapper . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertBootstrapper"], "fileName": "org.springframework.test.context.BootstrapUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertBootstrapper ( BootstrapUtilsTests . NonAnnotatedClass . class ,    DefaultTestContextBootstrapper . class )  ;", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapperForNonAnnotatedClass"], "fileName": "org.springframework.test.context.BootstrapUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertBootstrapper ( BootstrapUtilsTests . WebAppConfigurationAnnotatedClass . class ,    WebTestContextBootstrapper . class )  ;", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapperForWebAppConfigurationAnnotatedClass"], "fileName": "org.springframework.test.context.BootstrapUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertBootstrapper ( BootstrapUtilsTests . DirectBootstrapWithAnnotationClass . class ,    BootstrapUtilsTests . FooBootstrapper . class )  ;", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapperWithDirectBootstrapWithAnnotation"], "fileName": "org.springframework.test.context.BootstrapUtilsTests"}, {"methodBody": ["METHOD_START", "{", "BootstrapContext   bootstrapContext    =    BootstrapTestUtils . buildBootstrapContext ( BootstrapUtilsTests . DoubleMetaAnnotatedBootstrapWithAnnotationClass . class ,    delegate )  ;", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( CoreMatchers . containsString (  \" found   multiple   declarations   of    @ BootstrapWith \"  )  )  ;", "exception . expectMessage ( CoreMatchers . containsString ( BootstrapUtilsTests . FooBootstrapper . class . getName (  )  )  )  ;", "exception . expectMessage ( CoreMatchers . containsString ( BootstrapUtilsTests . BarBootstrapper . class . getName (  )  )  )  ;", "BootstrapUtils . resolveTestContextBootstrapper ( bootstrapContext )  ;", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapperWithDoubleMetaBootstrapWithAnnotation"], "fileName": "org.springframework.test.context.BootstrapUtilsTests"}, {"methodBody": ["METHOD_START", "{", "BootstrapContext   bootstrapContext    =    BootstrapTestUtils . buildBootstrapContext ( BootstrapUtilsTests . EmptyBootstrapWithAnnotationClass . class ,    delegate )  ;", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( CoreMatchers . containsString (  \" Specify    @ BootstrapWith ' s    ' value '    attribute \"  )  )  ;", "BootstrapUtils . resolveTestContextBootstrapper ( bootstrapContext )  ;", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapperWithEmptyBootstrapWithAnnotation"], "fileName": "org.springframework.test.context.BootstrapUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertBootstrapper ( BootstrapUtilsTests . InheritedBootstrapWithAnnotationClass . class ,    BootstrapUtilsTests . FooBootstrapper . class )  ;", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapperWithInheritedBootstrapWithAnnotation"], "fileName": "org.springframework.test.context.BootstrapUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertBootstrapper ( BootstrapUtilsTests . MetaAnnotatedBootstrapWithAnnotationClass . class ,    BootstrapUtilsTests . BarBootstrapper . class )  ;", "}", "METHOD_END"], "methodName": ["resolveTestContextBootstrapperWithMetaBootstrapWithAnnotation"], "fileName": "org.springframework.test.context.BootstrapUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . classes ;", "}", "METHOD_END"], "methodName": ["getClasses"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . contextLoaderClass ;", "}", "METHOD_END"], "methodName": ["getContextLoaderClass"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . declaringClass ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . initializers ;", "}", "METHOD_END"], "methodName": ["getInitializers"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . locations ;", "}", "METHOD_END"], "methodName": ["getLocations"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return    ( getClasses (  )  . length )     >     0  ;", "}", "METHOD_END"], "methodName": ["hasClasses"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return    ( getLocations (  )  . length )     >     0  ;", "}", "METHOD_END"], "methodName": ["hasLocations"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return    ( hasLocations (  )  )     |  |     ( hasClasses (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasResources"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . inheritInitializers ;", "}", "METHOD_END"], "methodName": ["isInheritInitializers"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . inheritLocations ;", "}", "METHOD_END"], "methodName": ["isInheritLocations"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "this . classes    =    classes ;", "}", "METHOD_END"], "methodName": ["setClasses"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "this . locations    =    locations ;", "}", "METHOD_END"], "methodName": ["setLocations"], "fileName": "org.springframework.test.context.ContextConfigurationAttributes"}, {"methodBody": ["METHOD_START", "{", "runTestAndVerifyHierarchies ( ContextHierarchyDirtiesContextTests . ClassLevelDirtiesContextWithCurrentLevelModeTestCase . class ,    true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["classLevelDirtiesContextWithCurrentLevelHierarchyMode"], "fileName": "org.springframework.test.context.ContextHierarchyDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "runTestAndVerifyHierarchies ( ContextHierarchyDirtiesContextTests . ClassLevelDirtiesContextWithExhaustiveModeTestCase . class ,    false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["classLevelDirtiesContextWithExhaustiveHierarchyMode"], "fileName": "org.springframework.test.context.ContextHierarchyDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "ContextHierarchyDirtiesContextTests . context    =    null ;", "ContextHierarchyDirtiesContextTests . foo    =    null ;", "ContextHierarchyDirtiesContextTests . bar    =    null ;", "ContextHierarchyDirtiesContextTests . baz    =    null ;", "}", "METHOD_END"], "methodName": ["cleanUp"], "fileName": "org.springframework.test.context.ContextHierarchyDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "runTestAndVerifyHierarchies ( ContextHierarchyDirtiesContextTests . MethodLevelDirtiesContextWithCurrentLevelModeTestCase . class ,    true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["methodLevelDirtiesContextWithCurrentLevelHierarchyMode"], "fileName": "org.springframework.test.context.ContextHierarchyDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "runTestAndVerifyHierarchies ( ContextHierarchyDirtiesContextTests . MethodLevelDirtiesContextWithExhaustiveModeTestCase . class ,    false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["methodLevelDirtiesContextWithExhaustiveHierarchyMode"], "fileName": "org.springframework.test.context.ContextHierarchyDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "JUnitCore   jUnitCore    =    new   JUnitCore (  )  ;", "Result   result    =    jUnitCore . run ( testClass )  ;", "assertTrue (  \" all   tests   passed \"  ,    result . wasSuccessful (  )  )  ;", "assertThat (  . context ,    notNullValue (  )  )  ;", "ConfigurableApplicationContext   bazContext    =     (  ( ConfigurableApplicationContext )     (  . context )  )  ;", "assertEquals (  \" baz \"  ,     . baz )  ;", "assertThat (  \" bazContext # isActive (  )  \"  ,    bazContext . isActive (  )  ,    is ( isBazContextActive )  )  ;", "ConfigurableApplicationContext   barContext    =     (  ( ConfigurableApplicationContext )     ( bazContext . getParent (  )  )  )  ;", "assertThat ( barContext ,    notNullValue (  )  )  ;", "assertEquals (  \" bar \"  ,     . bar )  ;", "assertThat (  \" barContext # isActive (  )  \"  ,    barContext . isActive (  )  ,    is ( isBarContextActive )  )  ;", "ConfigurableApplicationContext   fooContext    =     (  ( ConfigurableApplicationContext )     ( barContext . getParent (  )  )  )  ;", "assertThat ( fooContext ,    notNullValue (  )  )  ;", "assertEquals (  \" foo \"  ,     . foo )  ;", "assertThat (  \" fooContext # isActive (  )  \"  ,    fooContext . isActive (  )  ,    is ( isFooContextActive )  )  ;", "}", "METHOD_END"], "methodName": ["runTestAndVerifyHierarchies"], "fileName": "org.springframework.test.context.ContextHierarchyDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "return   this . activeProfiles ;", "}", "METHOD_END"], "methodName": ["getActiveProfiles"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . classes ;", "}", "METHOD_END"], "methodName": ["getClasses"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . contextCustomizers ;", "}", "METHOD_END"], "methodName": ["getContextCustomizers"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . contextInitializerClasses ;", "}", "METHOD_END"], "methodName": ["getContextInitializerClasses"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . contextLoader ;", "}", "METHOD_END"], "methodName": ["getContextLoader"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . locations ;", "}", "METHOD_END"], "methodName": ["getLocations"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . parent )     =  =    null )     {", "return   null ;", "}", "Assert . state (  (  ( this . cacheAwareContextLoaderDelegate )     !  =    null )  ,     \" Cannot   retrieve   a   parent   application   context   without   access   to   the   CacheAwareContextLoaderDelegate \"  )  ;", "return   this . cacheAwareContextLoaderDelegate . loa ( this . parent )  ;", "}", "METHOD_END"], "methodName": ["getParentApplicationContext"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . propertySourceLocations ;", "}", "METHOD_END"], "methodName": ["getPropertySourceLocations"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . propertySourceProperties ;", "}", "METHOD_END"], "methodName": ["getPropertySourceProperties"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . testClass ;", "}", "METHOD_END"], "methodName": ["getTestClass"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    !  ( ObjectUtils . isEmpty ( getClasses (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasClasses"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    !  ( ObjectUtils . isEmpty ( getLocations (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasLocations"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    ( hasLocations (  )  )     |  |     ( hasClasses (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasResources"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   contextLoader    !  =    null    ?    contextLoader . getClass (  )  . getName (  )     :     \" null \"  ;", "}", "METHOD_END"], "methodName": ["nullSafeClassName"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( activeProfiles    =  =    null )     {", "return    . EMPTY _ STRING _ ARRAY ;", "}", "Set < String >    profilesSet    =    new   LinkedHashSet <  >  ( Arrays . asList ( activeProfiles )  )  ;", "return   StringUtils . toStringArray ( profilesSet )  ;", "}", "METHOD_END"], "methodName": ["processActiveProfiles"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   classes    !  =    null    ?    classes    :    MergedContextConfiguration . EMPTY _ CLASS _ ARRAY ;", "}", "METHOD_END"], "methodName": ["processClasses"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   contextCustomizers    !  =    null    ?    Collections . unmodifiableSet ( contextCustomizers )     :    MergedContextConfiguration . EMPTY _ CONTEXT _ CUSTOMIZERS ;", "}", "METHOD_END"], "methodName": ["processContextCustomizers"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   contextInitializerClasses    !  =    null    ?    Collections . unmodifiableSet ( contextInitializerClasses )     :    MergedContextConfiguration . EMPTY _ INITIALIZER _ CLASSES ;", "}", "METHOD_END"], "methodName": ["processContextInitializerClasses"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   array    !  =    null    ?    array    :    MergedContextConfiguration . EMPTY _ STRING _ ARRAY ;", "}", "METHOD_END"], "methodName": ["processStrings"], "fileName": "org.springframework.test.context.MergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( null ,    null ,    null ,    null ,    null )  ;", "assertEquals ( mergedConfig ,    mergedConfig )  ;", "assertNotEquals ( mergedConfig ,    null )  ;", "assertNotEquals ( mergedConfig ,     1  )  ;", "}", "METHOD_END"], "methodName": ["equalsBasics"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes 1     =    new   Class <  ?  >  [  ]  {    String . class ,    Integer . class    }  ;", "Class <  ?  >  [  ]    classes 2     =    new   Class <  ?  >  [  ]  {    Boolean . class ,    Number . class    }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes 1  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes 2  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertNotEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "assertNotEquals ( mergedConfig 2  ,    mergedConfig 1  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithDifferentConfigClasses"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Set < ContextCustomizer >    customizers 1     =    Collections . singleton ( mock ( ContextCustomizer . class )  )  ;", "Set < ContextCustomizer >    customizers 2     =    Collections . singleton ( mock ( ContextCustomizer . class )  )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    null ,     . EMPTY _ STRING _ ARRAY ,    null ,    null ,    customizers 1  ,    loader ,    null ,    null )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    null ,     . EMPTY _ STRING _ ARRAY ,    null ,    null ,    customizers 2  ,    loader ,    null ,    null )  ;", "assertNotEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "assertNotEquals ( mergedConfig 2  ,    mergedConfig 1  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithDifferentContextCustomizers"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses 1     =    new   HashSet <  >  (  )  ;", "initializerClasses 1  . add (  . FooInitializer . class )  ;", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses 2     =    new   HashSet <  >  (  )  ;", "initializerClasses 2  . add (  . BarInitializer . class )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    initializerClasses 1  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    initializerClasses 2  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertNotEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "assertNotEquals ( mergedConfig 2  ,    mergedConfig 1  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithDifferentInitializers"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    locations 1     =    new   String [  ]  {     \" foo \"  ,     \" bar }  \"     }  ;", "String [  ]    locations 2     =    new   String [  ]  {     \" baz \"  ,     \" quux }  \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    locations 1  ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    locations 2  ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertNotEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "assertNotEquals ( mergedConfig 2  ,    mergedConfig 1  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithDifferentLocations"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   parent 1     =    new   MergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" foo \"  ,     \" bar }  \"     }  ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   parent 2     =    new   MergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" baz \"  ,     \" quux \"     }  ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    null ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader ,    null ,    parent 1  )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    null ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader ,    null ,    parent 2  )  ;", "assertNotEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "assertNotEquals ( mergedConfig 2  ,    mergedConfig 1  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithDifferentParents"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    activeProfiles 1     =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"     }  ;", "String [  ]    activeProfiles 2     =    new   String [  ]  {     \" X \"  ,     \" Y \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 1  ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 2  ,    loader )  ;", "assertNotEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "assertNotEquals ( mergedConfig 2  ,    mergedConfig 1  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithDifferentProfiles"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithEmptyArrays"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    new   AnnotationConfigContextLoader (  )  )  ;", "assertNotEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "assertNotEquals ( mergedConfig 2  ,    mergedConfig 1  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithEmptyArraysAndDifferentLoaders"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    null ,    null ,    null ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    null ,    null ,    null ,    loader )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithNullArrays"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( null ,    null ,    null ,    null ,    null )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( null ,    null ,    null ,    null ,    null )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithNulls"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes    =    new   Class <  ?  >  [  ]  {    String . class ,    Integer . class    }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameConfigClasses"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Set < ContextCustomizer >    customizers    =    Collections . singleton ( mock ( ContextCustomizer . class )  )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    null ,     . EMPTY _ STRING _ ARRAY ,    null ,    null ,    customizers ,    loader ,    null ,    null )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    null ,     . EMPTY _ STRING _ ARRAY ,    null ,    null ,    customizers ,    loader ,    null ,    null )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameContextCustomizers"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    activeProfiles 1     =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"     }  ;", "String [  ]    activeProfiles 2     =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"  ,     \" catbert \"  ,     \" dogbert \"  ,     \" catbert \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 1  ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 2  ,    loader )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameDuplicateProfiles"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses 1     =    new   HashSet <  >  (  )  ;", "initializerClasses 1  . add (  . FooInitializer . class )  ;", "initializerClasses 1  . add (  . BarInitializer . class )  ;", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses 2     =    new   HashSet <  >  (  )  ;", "initializerClasses 2  . add (  . BarInitializer . class )  ;", "initializerClasses 2  . add (  . FooInitializer . class )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    initializerClasses 1  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    initializerClasses 2  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameInitializers"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    locations    =    new   String [  ]  {     \" foo \"  ,     \" bar }  \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    locations ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    locations ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameLocations"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   parent    =    new   MergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" foo \"  ,     \" bar }  \"     }  ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    null ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader ,    null ,    parent )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    null ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader ,    null ,    parent )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "assertEquals ( mergedConfig 2  ,    mergedConfig 1  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameParent"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    activeProfiles    =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles ,    loader )  ;", "assertEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameProfiles"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    activeProfiles 1     =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"     }  ;", "String [  ]    activeProfiles 2     =    new   String [  ]  {     \" dogbert \"  ,     \" catbert \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 1  ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 2  ,    loader )  ;", "assertNotEquals ( mergedConfig 1  ,    mergedConfig 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameProfilesReversed"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes 1     =    new   Class <  ?  >  [  ]  {    String . class ,    Integer . class    }  ;", "Class <  ?  >  [  ]    classes 2     =    new   Class <  ?  >  [  ]  {    Boolean . class ,    Number . class    }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes 1  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes 2  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertNotEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithDifferentConfigClasses"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses 1     =    new   HashSet <  >  (  )  ;", "initializerClasses 1  . add (  . FooInitializer . class )  ;", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses 2     =    new   HashSet <  >  (  )  ;", "initializerClasses 2  . add (  . BarInitializer . class )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    initializerClasses 1  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    initializerClasses 2  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertNotEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithDifferentInitializers"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    locations 1     =    new   String [  ]  {     \" foo \"  ,     \" bar }  \"     }  ;", "String [  ]    locations 2     =    new   String [  ]  {     \" baz \"  ,     \" quux }  \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    locations 1  ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    locations 2  ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertNotEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithDifferentLocations"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   parent 1     =    new   MergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" foo \"  ,     \" bar }  \"     }  ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   parent 2     =    new   MergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" baz \"  ,     \" quux \"     }  ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    null ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader ,    null ,    parent 1  )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    null ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader ,    null ,    parent 2  )  ;", "assertNotEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithDifferentParents"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    activeProfiles 1     =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"     }  ;", "String [  ]    activeProfiles 2     =    new   String [  ]  {     \" X \"  ,     \" Y \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 1  ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 2  ,    loader )  ;", "assertNotEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithDifferentProfiles"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithEmptyArrays"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    new   AnnotationConfigContextLoader (  )  )  ;", "assertNotEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithEmptyArraysAndDifferentLoaders"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    null ,    null ,    null ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    null ,    null ,    null ,    loader )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithNullArrays"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( null ,    null ,    null ,    null ,    null )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( null ,    null ,    null ,    null ,    null )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithNulls"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes    =    new   Class <  ?  >  [  ]  {    String . class ,    Integer . class    }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithSameConfigClasses"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    activeProfiles 1     =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"     }  ;", "String [  ]    activeProfiles 2     =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"  ,     \" catbert \"  ,     \" dogbert \"  ,     \" catbert \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 1  ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 2  ,    loader )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithSameDuplicateProfiles"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses 1     =    new   HashSet <  >  (  )  ;", "initializerClasses 1  . add (  . FooInitializer . class )  ;", "initializerClasses 1  . add (  . BarInitializer . class )  ;", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses 2     =    new   HashSet <  >  (  )  ;", "initializerClasses 2  . add (  . BarInitializer . class )  ;", "initializerClasses 2  . add (  . FooInitializer . class )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    initializerClasses 1  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    initializerClasses 2  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithSameInitializers"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    locations    =    new   String [  ]  {     \" foo \"  ,     \" bar }  \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    locations ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    locations ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithSameLocations"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   parent    =    new   MergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" foo \"  ,     \" bar }  \"     }  ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    null ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader ,    null ,    parent )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    MergedContextConfigurationTests . EMPTY _ CLASS _ ARRAY ,    null ,    MergedContextConfigurationTests . EMPTY _ STRING _ ARRAY ,    loader ,    null ,    parent )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithSameParent"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    activeProfiles    =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles ,    loader )  ;", "assertEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithSameProfiles"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    activeProfiles 1     =    new   String [  ]  {     \" catbert \"  ,     \" dogbert \"     }  ;", "String [  ]    activeProfiles 2     =    new   String [  ]  {     \" dogbert \"  ,     \" catbert \"     }  ;", "MergedContextConfiguration   mergedConfig 1     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 1  ,    loader )  ;", "MergedContextConfiguration   mergedConfig 2     =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    activeProfiles 2  ,    loader )  ;", "assertNotEquals ( mergedConfig 1  . hashCode (  )  ,    mergedConfig 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithSameProfilesReversed"], "fileName": "org.springframework.test.context.MergedContextConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "TestContextManager   tcm    =    new   TestContextManager ( TestContextConcurrencyTests . TestCase . class )  ;", "IntStream . range (  1  ,     2  0  )  . forEach (  (    i )     -  >     {", "TestContextConcurrencyTests . actualMethods . clear (  )  ;", "Arrays . stream ( TestContextConcurrencyTests . TestCase . class . getDeclaredMethods (  )  )  . parallel (  )  . forEach (  (    testMethod )     -  >     {", "try    {", "tcm . beforeTestClass (  )  ;", "tcm . beforeTestMethod ( TestContextConcurrencyTests . testInstance ,    testMethod )  ;", "tcm . afterTestMethod ( TestContextConcurrencyTests . testInstance ,    testMethod ,    null )  ;", "tcm . afterTestClass (  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "}  )  ;", "Assert . assertThat ( TestContextConcurrencyTests . actualMethods ,    CoreMatchers . equalTo ( TestContextConcurrencyTests . expectedMethods )  )  ;", "}  )  ;", "Assert . assertEquals (  0  ,    tcm . getTestContext (  )  . attributeNames (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["invokeTestContextManagerFromConcurrentThreads"], "fileName": "org.springframework.test.context.TestContextConcurrencyTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    getTestContext (  )  . getTestClass (  )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" afterTestClass (  )  :    class    [  \"     +     ( testClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "getTestContext (  )  . updateState ( null ,    null ,    null )  ;", "Throwable   afterTestClassException    =    null ;", "for    ( TestExecutionListener   testExecutionListener    :    getReversedTestExecutionListeners (  )  )     {", "try    {", "testExecutionListener . afterTestClass ( getTestContext (  )  )  ;", "}    catch    ( Throwable   ex )     {", "logException ( ex ,     \" afterTestClass \"  ,    testExecutionListener ,    testClass )  ;", "if    ( afterTestClassException    =  =    null )     {", "afterTestClassException    =    ex ;", "} else    {", "afterTestClassException . addSuppressed ( ex )  ;", "}", "}", "}", "this . testContextHolder . remove (  )  ;", "if    ( afterTestClassException    !  =    null )     {", "ReflectionUtils . rethrowException ( afterTestClassException )  ;", "}", "}", "METHOD_END"], "methodName": ["afterTestClass"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "String   callbackName    =     \" afterTestExecution \"  ;", "prepareForAfterCallback ( callbackName ,    testInstance ,    testMethod ,    exception )  ;", "Throwable   afterTestExecutionException    =    null ;", "for    ( TestExecutionListener   testExecutionListener    :    getReversedTestExecutionListeners (  )  )     {", "try    {", "testExecutionListener . afterTestExecution ( get (  )  )  ;", "}    catch    ( Throwable   ex )     {", "logException ( ex ,    callbackName ,    testExecutionListener ,    testInstance ,    testMethod )  ;", "if    ( afterTestExecutionException    =  =    null )     {", "afterTestExecutionException    =    ex ;", "} else    {", "afterTestExecutionException . addSuppressed ( ex )  ;", "}", "}", "}", "if    ( afterTestExecutionException    !  =    null )     {", "ReflectionUtils . rethrowException ( afterTestExecutionException )  ;", "}", "}", "METHOD_END"], "methodName": ["afterTestExecution"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "String   callbackName    =     \" afterTestMethod \"  ;", "prepareForAfterCallback ( callbackName ,    testInstance ,    testMethod ,    exception )  ;", "Throwable   afterTestMethodException    =    null ;", "for    ( TestExecutionListener   testExecutionListener    :    getReversedTestExecutionListeners (  )  )     {", "try    {", "testExecutionListener . afterTestMethod ( get (  )  )  ;", "}    catch    ( Throwable   ex )     {", "logException ( ex ,    callbackName ,    testExecutionListener ,    testInstance ,    testMethod )  ;", "if    ( afterTestMethodException    =  =    null )     {", "afterTestMethodException    =    ex ;", "} else    {", "afterTestMethodException . addSuppressed ( ex )  ;", "}", "}", "}", "if    ( afterTestMethodException    !  =    null )     {", "ReflectionUtils . rethrowException ( afterTestMethodException )  ;", "}", "}", "METHOD_END"], "methodName": ["afterTestMethod"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    getTestContext (  )  . getTestClass (  )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" beforeTestClass (  )  :    class    [  \"     +     ( testClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "getTestContext (  )  . updateState ( null ,    null ,    null )  ;", "for    ( TestExecutionListener   testExecutionListener    :    getTestExecutionListeners (  )  )     {", "try    {", "testExecutionListener . beforeTestClass ( getTestContext (  )  )  ;", "}    catch    ( Throwable   ex )     {", "logException ( ex ,     \" beforeTestClass \"  ,    testExecutionListener ,    testClass )  ;", "ReflectionUtils . rethrowException ( ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["beforeTestClass"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "String   callbackName    =     \" beforeTestExecution \"  ;", "prepareForBeforeCallback ( callbackName ,    testInstance ,    testMethod )  ;", "for    ( TestExecutionListener   testExecutionListener    :    getTestExecutionListeners (  )  )     {", "try    {", "testExecutionListener . beforeTestExecution ( get (  )  )  ;", "}    catch    ( Throwable   ex )     {", "handleBeforeException ( ex ,    callbackName ,    testExecutionListener ,    testInstance ,    testMethod )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["beforeTestExecution"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "String   callbackName    =     \" beforeTestMethod \"  ;", "prepareForBeforeCallback ( callbackName ,    testInstance ,    testMethod )  ;", "for    ( TestExecutionListener   testExecutionListener    :    getTestExecutionListeners (  )  )     {", "try    {", "testExecutionListener . beforeTestMethod ( get (  )  )  ;", "}    catch    ( Throwable   ex )     {", "handleBeforeException ( ex ,    callbackName ,    testExecutionListener ,    testInstance ,    testMethod )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["beforeTestMethod"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?    extends   TestContext >    constructor    =    ClassUtils . getConstructorIfAvailable ( testContext . getClass (  )  ,    testContext . getClass (  )  )  ;", "if    ( constructor    !  =    null )     {", "try    {", "ReflectionUtils . makeAccessible ( constructor )  ;", "return   constructor . newInstance ( testContext )  ;", "}    catch    ( Exception   ex )     {", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( String . format (  (  \" Failed   to   invoke   copy   constructor   for    [  % s ]  ;     \"     +     \" concurrent   test   execution   is   therefore   likely   not   supported .  \"  )  ,    testContext )  ,    ex )  ;", "}", "}", "}", "return   testContext ;", "}", "METHOD_END"], "methodName": ["copyTestContext"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "List < TestExecutionListener >    listenersReversed    =    new   ArrayList <  >  ( getTestExecutionListeners (  )  )  ;", "Collections . reverse ( listenersReversed )  ;", "return   listenersReversed ;", "}", "METHOD_END"], "methodName": ["getReversedTestExecutionListeners"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "return   this . testContextHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["getTestContext"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "return   this . testExecutionListeners ;", "}", "METHOD_END"], "methodName": ["getTestExecutionListeners"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "logException ( ex ,    callbackName ,    testExecutionListener ,    testInstance ,    testMethod )  ;", "ReflectionUtils . rethrowException ( ex )  ;", "}", "METHOD_END"], "methodName": ["handleBeforeException"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "if    ( TestContextManager . logger . isWarnEnabled (  )  )     {", "TestContextManager . logger . warn ( String . format (  (  \" Caught   exception   while   invoking    '  % s '    callback   on    \"     +     \" TestExecutionListener    [  % s ]    for   test   class    [  % s ]  \"  )  ,    callbackName ,    testExecutionListener ,    testClass )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["logException"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "if    ( TestContextManager . logger . isWarnEnabled (  )  )     {", "TestContextManager . logger . warn ( String . format (  (  \" Caught   exception   while   invoking    '  % s '    callback   on    \"     +     \" TestExecutionListener    [  % s ]    for   test   method    [  % s ]    and   test   instance    [  % s ]  \"  )  ,    callbackName ,    testExecutionListener ,    testMethod ,    testInstance )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["logException"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "if    ( TestContextManager . logger . isTraceEnabled (  )  )     {", "TestContextManager . logger . trace ( String . format (  \"  % s (  )  :    instance    [  % s ]  ,    method    [  % s ]  ,    exception    [  % s ]  \"  ,    callbackName ,    testInstance ,    testMethod ,    exception )  )  ;", "}", "getTestContext (  )  . updateState ( testInstance ,    testMethod ,    exception )  ;", "}", "METHOD_END"], "methodName": ["prepareForAfterCallback"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "if    ( TestContextManager . logger . isTraceEnabled (  )  )     {", "TestContextManager . logger . trace ( String . format (  \"  % s (  )  :    instance    [  % s ]  ,    method    [  % s ]  \"  ,    callbackName ,    testInstance ,    testMethod )  )  ;", "}", "getTestContext (  )  . updateState ( testInstance ,    testMethod ,    null )  ;", "}", "METHOD_END"], "methodName": ["prepareForBeforeCallback"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "if    ( TestContextManager . logger . isTraceEnabled (  )  )     {", "TestContextManager . logger . trace (  (  (  \" prepareTestInstance (  )  :    instance    [  \"     +    testInstance )     +     \"  ]  \"  )  )  ;", "}", "getTestContext (  )  . updateState ( testInstance ,    null ,    null )  ;", "for    ( TestExecutionListener   testExecutionListener    :    getTestExecutionListeners (  )  )     {", "try    {", "testExecutionListener . prepareTestInstance ( getTestContext (  )  )  ;", "}    catch    ( Throwable   ex )     {", "if    ( TestContextManager . logger . isErrorEnabled (  )  )     {", "TestContextManager . logger . error (  (  (  (  (  \" Caught   exception   while   allowing   TestExecutionListener    [  \"     +    testExecutionListener )     +     \"  ]    to   prepare   test   instance    [  \"  )     +    testInstance )     +     \"  ]  \"  )  ,    ex )  ;", "}", "ReflectionUtils . rethrowException ( ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["prepareTestInstance"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "registerTestExecutionListeners ( testExecutionListeners . toArray ( new   TestExecutionListener [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["registerTestExecutionListeners"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "for    ( TestExecutionListener   listener    :    testExecutionListeners )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  \" Registering   TestExecutionListener :     \"     +    listener )  )  ;", "}", "this . testExecutionListeners . add ( listener )  ;", "}", "}", "METHOD_END"], "methodName": ["registerTestExecutionListeners"], "fileName": "org.springframework.test.context.TestContextManager"}, {"methodBody": ["METHOD_START", "{", "test (  \" afterTestClass \"  ,    TestContextManagerSuppressedExceptionsTests . FailingAfterTestClassTestCase . class ,     (    tcm ,    c ,    m )     -  >    tcm . afterTestClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["afterTestClass"], "fileName": "org.springframework.test.context.TestContextManagerSuppressedExceptionsTests"}, {"methodBody": ["METHOD_START", "{", "test (  \" afterTestExecution \"  ,    TestContextManagerSuppressedExceptionsTests . FailingAfterTestExecutionTestCase . class ,     (    tcm ,    c ,    m )     -  >    tcm . afterTestExecution ( this ,    m ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["afterTestExecution"], "fileName": "org.springframework.test.context.TestContextManagerSuppressedExceptionsTests"}, {"methodBody": ["METHOD_START", "{", "test (  \" afterTestMethod \"  ,    TestContextManagerSuppressedExceptionsTests . FailingAfterTestMethodTestCase . class ,     (    tcm ,    c ,    m )     -  >    tcm . afterTestMethod ( this ,    m ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["afterTestMethod"], "fileName": "org.springframework.test.context.TestContextManagerSuppressedExceptionsTests"}, {"methodBody": ["METHOD_START", "{", "TestContextManager   testContextManager    =    new   TestContextManager ( testClass )  ;", "assertEquals (  \" Registered   TestExecutionListeners \"  ,     2  ,    testContextManager . getTestExecutionListeners (  )  . size (  )  )  ;", "try    {", "Method   testMethod    =    getClass (  )  . getMethod (  \" toString \"  )  ;", "callback . invoke ( testContextManager ,    testClass ,    testMethod )  ;", "fail (  \" should   have   thrown   an   AssertionError \"  )  ;", "}    catch    ( AssertionError   err )     {", "assertEquals (  ( useCase    +     \"  -  2  \"  )  ,    err . getMessage (  )  )  ;", "Throwable [  ]    suppressed    =    err . getSuppressed (  )  ;", "assertEquals (  1  ,    suppressed . length )  ;", "assertEquals (  ( useCase    +     \"  -  1  \"  )  ,    suppressed [  0  ]  . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.context.TestContextManagerSuppressedExceptionsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  (  \" execution   order    (  \"     +    usageContext )     +     \"  )     =  =  >  \"  )  ,    Arrays . asList ( expectedBeforeTestMethodCalls )  ,    TestContextManagerTests . executionOrder )  ;", "}", "METHOD_END"], "methodName": ["assertExecutionOrder"], "fileName": "org.springframework.test.context.TestContextManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Registered   TestExecutionListeners \"  ,     3  ,    this . testContextManager . getTestExecutionListeners (  )  . size (  )  )  ;", "this . testContextManager . beforeTestMethod ( this ,    this . testMethod )  ;", ". assertExecutionOrder (  \" beforeTestMethod \"  ,     \" beforeTestMethod -  1  \"  ,     \" beforeTestMethod -  2  \"  ,     \" beforeTestMethod -  3  \"  )  ;", "this . testContextManager . beforeTestExecution ( this ,    this . testMethod )  ;", ". assertExecutionOrder (  \" beforeTestExecution \"  ,     \" beforeTestMethod -  1  \"  ,     \" beforeTestMethod -  2  \"  ,     \" beforeTestMethod -  3  \"  ,     \" beforeTestExecution -  1  \"  ,     \" beforeTestExecution -  2  \"  ,     \" beforeTestExecution -  3  \"  )  ;", "this . testContextManager . afterTestExecution ( this ,    this . testMethod ,    null )  ;", ". assertExecutionOrder (  \" afterTestExecution \"  ,     \" beforeTestMethod -  1  \"  ,     \" beforeTestMethod -  2  \"  ,     \" beforeTestMethod -  3  \"  ,     \" beforeTestExecution -  1  \"  ,     \" beforeTestExecution -  2  \"  ,     \" beforeTestExecution -  3  \"  ,     \" afterTestExecution -  3  \"  ,     \" afterTestExecution -  2  \"  ,     \" afterTestExecution -  1  \"  )  ;", "this . testContextManager . afterTestMethod ( this ,    this . testMethod ,    null )  ;", ". assertExecutionOrder (  \" afterTestMethod \"  ,     \" beforeTestMethod -  1  \"  ,     \" beforeTestMethod -  2  \"  ,     \" beforeTestMethod -  3  \"  ,     \" beforeTestExecution -  1  \"  ,     \" beforeTestExecution -  2  \"  ,     \" beforeTestExecution -  3  \"  ,     \" afterTestExecution -  3  \"  ,     \" afterTestExecution -  2  \"  ,     \" afterTestExecution -  1  \"  ,     \" afterTestMethod -  3  \"  ,     \" afterTestMethod -  2  \"  ,     \" afterTestMethod -  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["listenerExecutionOrder"], "fileName": "org.springframework.test.context.TestContextManagerTests"}, {"methodBody": ["METHOD_START", "{", "BootstrapContext   bootstrapContext    =    new   DefaultBootstrapContext ( testClass ,    cacheAwareContextLoaderDelegate )  ;", "Bootstrapper   testContextBootstrapper    =    BootstrapUtils . resolveBootstrapper ( bootstrapContext )  ;", "return   testContextBootstrapper . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildTestContext"], "fileName": "org.springframework.test.context.TestContextTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   TestContextTestUtils . buildTestContext ( testClass ,    new   DefaultCacheAwareContextLoaderDelegate ( contextCache )  )  ;", "}", "METHOD_END"], "methodName": ["buildTestContext"], "fileName": "org.springframework.test.context.TestContextTestUtils"}, {"methodBody": ["METHOD_START", "{", "TestContextManager   testContextManager    =    new   TestContextManager ( testClass )  ;", "assertEquals (  (  \" Num   registered   TELs   for    \"     +    testClass )  ,    expected ,    testContextManager . get (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumRegisteredListeners"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "TestContextManager   testContextManager    =    new   TestContextManager ( testClass )  ;", "assertEquals (  (  \" TELs   registered   for    \"     +     ( testClass . getSimpleName (  )  )  )  ,    names ( expected )  ,    names ( classes ( testContextManager )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertRegisteredListeners"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "return   testContextManager . getTestExecutionListeners (  )  . stream (  )  . map ( Object :  : getClass )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["classes"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . ExplicitListenersTestCase . class ,     3  )  ;", "}", "METHOD_END"], "methodName": ["customListeners"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertRegisteredListeners ( TestExecutionListenersTests . ExplicitListenersOnTestInterfaceTestCase . class ,    Arrays . asList ( TestExecutionListenersTests . FooTestExecutionListener . class ,    TestExecutionListenersTests . BarTestExecutionListener . class )  )  ;", "}", "METHOD_END"], "methodName": ["customListenersDeclaredOnInterface"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . MetaTestCase . class ,     3  )  ;", "}", "METHOD_END"], "methodName": ["customListenersRegisteredViaMetaAnnotation"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . MetaNonInheritedListenersWithOverridesTestCase . class ,     8  )  ;", "}", "METHOD_END"], "methodName": ["customListenersRegisteredViaMetaAnnotationWithNonInheritedListenersWithOverrides"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . MetaWithOverridesTestCase . class ,     3  )  ;", "}", "METHOD_END"], "methodName": ["customListenersRegisteredViaMetaAnnotationWithOverrides"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . MetaInheritedListenersWithOverridesTestCase . class ,     5  )  ;", "}", "METHOD_END"], "methodName": ["customsListenersRegisteredViaMetaAnnotationWithInheritedListenersWithOverrides"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    expected    =    Arrays . asList ( ServletTestExecutionListener . class ,    DirtiesContextBeforeModesTestExecutionListener . class ,    DependencyInjectionTestExecutionListener . class ,    DirtiesContextTestExecutionListener . class ,    TransactionalTestExecutionListener . class ,    SqlScriptsTestExecutionListener . class )  ;", "assertRegisteredListeners (  . DefaultListenersTestCase . class ,    expected )  ;", "}", "METHOD_END"], "methodName": ["defaultListeners"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    expected    =    Arrays . asList ( ServletTestExecutionListener . class ,    DirtiesContextBeforeModesTestExecutionListener . class ,    DependencyInjectionTestExecutionListener . class ,    DirtiesContextTestExecutionListener . class ,    TransactionalTestExecutionListener . class ,    SqlScriptsTestExecutionListener . class ,    TestExecutionListenersTests . BazTestExecutionListener . class )  ;", "assertRegisteredListeners ( TestExecutionListenersTests . MergedDefaultListenersWithCustomListenerAppendedTestCase . class ,    expected )  ;", "}", "METHOD_END"], "methodName": ["defaultListenersMergedWithCustomListenerAppended"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    expected    =    Arrays . asList ( ServletTestExecutionListener . class ,    DirtiesContextBeforeModesTestExecutionListener . class ,    DependencyInjectionTestExecutionListener . class ,    TestExecutionListenersTests . BarTestExecutionListener . class ,    DirtiesContextTestExecutionListener . class ,    TransactionalTestExecutionListener . class ,    SqlScriptsTestExecutionListener . class )  ;", "assertRegisteredListeners ( TestExecutionListenersTests . MergedDefaultListenersWithCustomListenerInsertedTestCase . class ,    expected )  ;", "}", "METHOD_END"], "methodName": ["defaultListenersMergedWithCustomListenerInserted"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    expected    =    Arrays . asList ( TestExecutionListenersTests . QuuxTestExecutionListener . class ,    ServletTestExecutionListener . class ,    DirtiesContextBeforeModesTestExecutionListener . class ,    DependencyInjectionTestExecutionListener . class ,    DirtiesContextTestExecutionListener . class ,    TransactionalTestExecutionListener . class ,    SqlScriptsTestExecutionListener . class )  ;", "assertRegisteredListeners ( TestExecutionListenersTests . MergedDefaultListenersWithCustomListenerPrependedTestCase . class ,    expected )  ;", "}", "METHOD_END"], "methodName": ["defaultListenersMergedWithCustomListenerPrepended"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertRegisteredListeners ( TestExecutionListenersTests . InheritedDefaultListenersTestCase . class ,    Arrays . asList ( TestExecutionListenersTests . QuuxTestExecutionListener . class )  )  ;", "assertRegisteredListeners ( TestExecutionListenersTests . SubInheritedDefaultListenersTestCase . class ,    Arrays . asList ( TestExecutionListenersTests . QuuxTestExecutionListener . class )  )  ;", "assertRegisteredListeners ( TestExecutionListenersTests . SubSubInheritedDefaultListenersTestCase . class ,    Arrays . asList ( TestExecutionListenersTests . QuuxTestExecutionListener . class ,    TestExecutionListenersTests . EnigmaTestExecutionListener . class )  )  ;", "}", "METHOD_END"], "methodName": ["inheritedDefaultListeners"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . InheritedListenersTestCase . class ,     4  )  ;", "}", "METHOD_END"], "methodName": ["inheritedListeners"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . MetaInheritedListenersTestCase . class ,     4  )  ;", "}", "METHOD_END"], "methodName": ["inheritedListenersRegisteredViaMetaAnnotation"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "new   TestContextManager ( TestExecutionListenersTests . DuplicateListenersConfigTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["listenersAndValueAttributesDeclared"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "return   classes . stream (  )  . map ( Class :  : getSimpleName )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["names"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertRegisteredListeners ( TestExecutionListenersTests . NonInheritedDefaultListenersTestCase . class ,    Arrays . asList ( TestExecutionListenersTests . QuuxTestExecutionListener . class )  )  ;", "}", "METHOD_END"], "methodName": ["nonInheritedDefaultListeners"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . NonInheritedListenersTestCase . class ,     1  )  ;", "}", "METHOD_END"], "methodName": ["nonInheritedListeners"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRegisteredListeners ( TestExecutionListenersTests . MetaNonInheritedListenersTestCase . class ,     1  )  ;", "}", "METHOD_END"], "methodName": ["nonInheritedListenersRegisteredViaMetaAnnotation"], "fileName": "org.springframework.test.context.TestExecutionListenersTests"}, {"methodBody": ["METHOD_START", "{", "runTestClassAndAssertStats ( ClassLevelDirtiesContextTestNGTests . CleanTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   clean   test   class \"  ,     1  ,    ClassLevelDirtiesContextTestNGTests . cacheHits . get (  )  ,    ClassLevelDirtiesContextTestNGTests . cacheMisses . incrementAndGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertBehaviorForCleanTestCase"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTestNGTests"}, {"methodBody": ["METHOD_START", "{", "final   int   expectedTestFailureCount    =     0  ;", "final   int   expectedTestStartedCount    =    expectedTestCount ;", "final   int   expectedTestFinishedCount    =    expectedTestCount ;", "final   TrackingListener   listener    =    new   TrackingListener (  )  ;", "final   TestNG   testNG    =    new   TestNG (  )  ;", "testNG . addListener (  (  ( ITestNGListener )     ( listener )  )  )  ;", "testNG . setTestClasses ( new   Class <  ?  >  [  ]  {    testClass    }  )  ;", "testNG . setVerbose (  0  )  ;", "testNG . run (  )  ;", "assertEquals (  (  (  \" Failures   for   test   class    [  \"     +    testClass )     +     \"  ]  .  \"  )  ,    expectedTestFailureCount ,    listener . testFailureCount )  ;", "assertEquals (  (  (  \" Tests   started   for   test   class    [  \"     +    testClass )     +     \"  ]  .  \"  )  ,    expectedTestStartedCount ,    listener . testStartCount )  ;", "assertEquals (  (  (  \" Successful   tests   for   test   class    [  \"     +    testClass )     +     \"  ]  .  \"  )  ,    expectedTestFinishedCount ,    listener . testSuccessCount )  ;", "}", "METHOD_END"], "methodName": ["runTestClassAndAssertStats"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTestNGTests"}, {"methodBody": ["METHOD_START", "{", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithCleanMethodsAndDefaultModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   default   class   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithCleanMethodsAndDefaultModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   clean   test   method   and   default   class   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithCleanMethodsAndAfterClassModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ CLASS   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithCleanMethodsAndAfterClassModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ CLASS   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithAfterEachTestMethodModeTestCase . class ,     3  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ EACH _ TEST _ METHOD   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . addAndGet (  2  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithAfterEachTestMethodModeTestCase . class ,     3  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ EACH _ TEST _ METHOD   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . addAndGet (  2  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . incrementAndGet (  )  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . incrementAndGet (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . incrementAndGet (  )  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . incrementAndGet (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithCleanMethodsAndAfterClassModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ CLASS   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyDirtiesContextBehavior"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTestNGTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics (  \" AfterClass \"  ,     0  ,    ClassLevelDirtiesContextTestNGTests . cacheHits . get (  )  ,    ClassLevelDirtiesContextTestNGTests . cacheMisses . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalCacheState"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTestNGTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . resetContextCache (  )  ;", ". cacheHits . set (  0  )  ;", ". cacheMisses . set (  0  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" BeforeClass \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyInitialCacheState"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTestNGTests"}, {"methodBody": ["METHOD_START", "{", "runTestClassAndAssertStats ( ClassLevelDirtiesContextTests . CleanTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   clean   test   class \"  ,     1  ,    ClassLevelDirtiesContextTests . cacheHits . get (  )  ,    ClassLevelDirtiesContextTests . cacheMisses . incrementAndGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertBehaviorForCleanTestCase"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "JUnitTestingUtils . runTestsAndAssertCounters ( testClass ,    expectedTestCount ,     0  ,    expectedTestCount ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["runTestClassAndAssertStats"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithCleanMethodsAndDefaultModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   default   class   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithCleanMethodsAndDefaultModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   clean   test   method   and   default   class   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithCleanMethodsAndAfterClassModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ CLASS   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithCleanMethodsAndAfterClassModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ CLASS   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithAfterEachTestMethodModeTestCase . class ,     3  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ EACH _ TEST _ METHOD   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . addAndGet (  2  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithAfterEachTestMethodModeTestCase . class ,     3  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ EACH _ TEST _ METHOD   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . addAndGet (  2  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . incrementAndGet (  )  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . incrementAndGet (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . incrementAndGet (  )  )  ;", "runTestClassAndAssertStats (  . InheritedClassLevelDirtiesContextWithDirtyMethodsTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   inherited   class - level    @ DirtiesContext   with   dirty   test   method \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . incrementAndGet (  )  )  ;", "assertBehaviorForCleanTestCase (  )  ;", "runTestClassAndAssertStats (  . ClassLevelDirtiesContextWithCleanMethodsAndAfterClassModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   AFTER _ CLASS   mode \"  ,     0  ,     . cacheHits . incrementAndGet (  )  ,     . cacheMisses . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyDirtiesContextBehavior"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics (  \" AfterClass \"  ,     0  ,    ClassLevelDirtiesContextTests . cacheHits . get (  )  ,    ClassLevelDirtiesContextTests . cacheMisses . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalCacheState"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . resetContextCache (  )  ;", ". cacheHits . set (  0  )  ;", ". cacheMisses . set (  0  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" BeforeClass \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyInitialCacheState"], "fileName": "org.springframework.test.context.cache.ClassLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics ( DefaultCacheAwareContextLoaderDelegate . defaultContextCache ,    usageScenario ,    expectedSize ,    expectedHitCount ,    expectedMissCount )  ;", "}", "METHOD_END"], "methodName": ["assertContextCacheStatistics"], "fileName": "org.springframework.test.context.cache.ContextCacheTestUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  (  \" Verifying   number   of   contexts   in   cache    (  \"     +    usageScenario )     +     \"  )  .  \"  )  ,    expectedSize ,    contextCache . size (  )  )  ;", "assertEquals (  (  (  \" Verifying   number   of   cache   hits    (  \"     +    usageScenario )     +     \"  )  .  \"  )  ,    expectedHitCount ,    contextCache . getHitCount (  )  )  ;", "assertEquals (  (  (  \" Verifying   number   of   cache   misses    (  \"     +    usageScenario )     +     \"  )  .  \"  )  ,    expectedMissCount ,    contextCache . getMissCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertContextCacheStatistics"], "fileName": "org.springframework.test.context.cache.ContextCacheTestUtils"}, {"methodBody": ["METHOD_START", "{", "DefaultCacheAwareContextLoaderDelegate . defaultContextCache . reset (  )  ;", "}", "METHOD_END"], "methodName": ["resetContextCache"], "fileName": "org.springframework.test.context.cache.ContextCacheTestUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" parent   context   count \"  ,    expected ,    contextCache . getParentContextCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertParentContextCount"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( MergedContextConfiguration )     ( ReflectionTestUtils . getField ( testContext ,     \" mergedContextConfiguration \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedContextConfiguration"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" initial   state \"  ,     0  ,     0  ,     0  )  ;", "assertParentContextCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["initialCacheState"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "TestContext   testContext    =    TestContextTestUtils . buildTestContext ( testClass ,    contextCache )  ;", "return   testContext . getApplicationContext (  )  ;", "}", "METHOD_END"], "methodName": ["loadContext"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( loadContext ( testClass )  )  ;", "Utils . assertContextCacheStatistics ( contextCache ,    testClass . getName (  )  ,    expectedSize ,    expectedHitCount ,    expectedMissCount )  ;", "}", "METHOD_END"], "methodName": ["loadCtxAndAssertStats"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "TestContext   testContext 3 a    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 aTestCase . class ,    contextCache )  ;", "testContext 3 a . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A \"  ,     3  ,     0  ,     3  )  ;", "assertParentContextCount (  2  )  ;", "TestContext   testContext 3 b    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 bTestCase . class ,    contextCache )  ;", "testContext 3 b . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A   and   B \"  ,     4  ,     1  ,     4  )  ;", "assertParentContextCount (  2  )  ;", "contextCache . remove ( getMergedContextConfiguration ( testContext 3 a )  . getParent (  )  . getParent (  )  ,    DirtiesContext . HierarchyMode . CURRENT _ LEVEL )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" removed   level    1  \"  ,     0  ,     1  ,     4  )  ;", "assertParentContextCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["removeContextHierarchyCacheLevel1"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "TestContext   testContext 3 a    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 aTestCase . class ,    contextCache )  ;", "testContext 3 a . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A \"  ,     3  ,     0  ,     3  )  ;", "assertParentContextCount (  2  )  ;", "TestContext   testContext 3 b    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 bTestCase . class ,    contextCache )  ;", "testContext 3 b . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A   and   B \"  ,     4  ,     1  ,     4  )  ;", "assertParentContextCount (  2  )  ;", "contextCache . remove ( getMergedContextConfiguration ( testContext 3 a )  . getParent (  )  . getParent (  )  ,    DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" removed   level    1  \"  ,     0  ,     1  ,     4  )  ;", "assertParentContextCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["removeContextHierarchyCacheLevel1WithExhaustiveMode"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "TestContext   testContext 3 a    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 aTestCase . class ,    contextCache )  ;", "testContext 3 a . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A \"  ,     3  ,     0  ,     3  )  ;", "assertParentContextCount (  2  )  ;", "TestContext   testContext 3 b    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 bTestCase . class ,    contextCache )  ;", "testContext 3 b . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A   and   B \"  ,     4  ,     1  ,     4  )  ;", "assertParentContextCount (  2  )  ;", "contextCache . remove ( getMergedContextConfiguration ( testContext 3 a )  . getParent (  )  ,    DirtiesContext . HierarchyMode . CURRENT _ LEVEL )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" removed   level    2  \"  ,     1  ,     1  ,     4  )  ;", "assertParentContextCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["removeContextHierarchyCacheLevel2"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "TestContext   testContext 3 a    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 aTestCase . class ,    contextCache )  ;", "testContext 3 a . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A \"  ,     3  ,     0  ,     3  )  ;", "assertParentContextCount (  2  )  ;", "TestContext   testContext 3 b    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 bTestCase . class ,    contextCache )  ;", "testContext 3 b . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A   and   B \"  ,     4  ,     1  ,     4  )  ;", "assertParentContextCount (  2  )  ;", "contextCache . remove ( getMergedContextConfiguration ( testContext 3 a )  . getParent (  )  ,    DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" removed   level    2  \"  ,     0  ,     1  ,     4  )  ;", "assertParentContextCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["removeContextHierarchyCacheLevel2WithExhaustiveMode"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "TestContext   testContext 3 a    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 aTestCase . class ,    contextCache )  ;", "testContext 3 a . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A \"  ,     3  ,     0  ,     3  )  ;", "assertParentContextCount (  2  )  ;", "TestContext   testContext 3 b    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 bTestCase . class ,    contextCache )  ;", "testContext 3 b . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A   and   B \"  ,     4  ,     1  ,     4  )  ;", "assertParentContextCount (  2  )  ;", "contextCache . remove ( getMergedContextConfiguration ( testContext 3 a )  ,    DirtiesContext . HierarchyMode . CURRENT _ LEVEL )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" removed   level    3  - A \"  ,     3  ,     1  ,     4  )  ;", "assertParentContextCount (  2  )  ;", "contextCache . remove ( getMergedContextConfiguration ( testContext 3 b )  . getParent (  )  ,    DirtiesContext . HierarchyMode . CURRENT _ LEVEL )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" removed   level    2  \"  ,     1  ,     1  ,     4  )  ;", "assertParentContextCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["removeContextHierarchyCacheLevel3Then2"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "TestContext   testContext 3 a    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 aTestCase . class ,    contextCache )  ;", "testContext 3 a . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A \"  ,     3  ,     0  ,     3  )  ;", "assertParentContextCount (  2  )  ;", "TestContext   testContext 3 b    =    TestContextTestUtils . buildTestContext ( ContextCacheTests . ClassHierarchyContextHierarchyLevel 3 bTestCase . class ,    contextCache )  ;", "testContext 3 b . getApplicationContext (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" level    3  ,    A   and   B \"  ,     4  ,     1  ,     4  )  ;", "assertParentContextCount (  2  )  ;", "contextCache . remove ( getMergedContextConfiguration ( testContext 3 a )  ,    DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" removed   level    3  - A \"  ,     0  ,     1  ,     4  )  ;", "assertParentContextCount (  0  )  ;", "contextCache . remove ( getMergedContextConfiguration ( testContext 3 b )  . getParent (  )  ,    DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "ContextCacheTestUtils . assertContextCacheStatistics ( contextCache ,     \" removed   level    2  \"  ,     0  ,     1  ,     4  )  ;", "assertParentContextCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["removeContextHierarchyCacheLevel3Then2WithExhaustiveMode"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "int   hits    =     0  ;", "int   misses    =     0  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 1 TestCase . class ,     (  +  + size )  ,    hits ,     (  +  + misses )  )  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 1 TestCase . class ,    size ,     (  +  + hits )  ,    misses )  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 2 TestCase . class ,     (  +  + size )  ,     (  +  + hits )  ,     (  +  + misses )  )  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 2 TestCase . class ,    size ,     (  +  + hits )  ,    misses )  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 2 TestCase . class ,    size ,     (  +  + hits )  ,    misses )  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 3 aTestCase . class ,     (  +  + size )  ,     (  +  + hits )  ,     (  +  + misses )  )  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 3 aTestCase . class ,    size ,     (  +  + hits )  ,    misses )  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 3 bTestCase . class ,     (  +  + size )  ,     (  +  + hits )  ,     (  +  + misses )  )  ;", "loadCtxAndAssertStats (  . ClassHierarchyContextHierarchyLevel 3 bTestCase . class ,    size ,     (  +  + hits )  ,    misses )  ;", "}", "METHOD_END"], "methodName": ["verifyCacheBehaviorForContextHierarchies"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "int   hit    =     0  ;", "int   miss    =     0  ;", "loadCtxAndAssertStats (  . FooBarProfilesTestCase . class ,     (  +  + size )  ,    hit ,     (  +  + miss )  )  ;", "loadCtxAndAssertStats (  . FooBarProfilesTestCase . class ,    size ,     (  +  + hit )  ,    miss )  ;", "loadCtxAndAssertStats (  . BarFooProfilesTestCase . class ,     (  +  + size )  ,    hit ,     (  +  + miss )  )  ;", "loadCtxAndAssertStats (  . FooBarProfilesTestCase . class ,    size ,     (  +  + hit )  ,    miss )  ;", "loadCtxAndAssertStats (  . FooBarProfilesTestCase . class ,    size ,     (  +  + hit )  ,    miss )  ;", "loadCtxAndAssertStats (  . BarFooProfilesTestCase . class ,    size ,     (  +  + hit )  ,    miss )  ;", "loadCtxAndAssertStats (  . FooBarActiveProfilesResolverTestCase . class ,    size ,     (  +  + hit )  ,    miss )  ;", "}", "METHOD_END"], "methodName": ["verifyCacheKeyIsBasedOnActiveProfiles"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "loadCtxAndAssertStats ( ContextCacheTests . AnnotationConfigContextLoaderTestCase . class ,     1  ,     0  ,     1  )  ;", "loadCtxAndAssertStats ( ContextCacheTests . AnnotationConfigContextLoaderTestCase . class ,     1  ,     1  ,     1  )  ;", "loadCtxAndAssertStats ( ContextCacheTests . CustomAnnotationConfigContextLoaderTestCase . class ,     2  ,     1  ,     2  )  ;", "loadCtxAndAssertStats ( ContextCacheTests . CustomAnnotationConfigContextLoaderTestCase . class ,     2  ,     2  ,     2  )  ;", "loadCtxAndAssertStats ( ContextCacheTests . AnnotationConfigContextLoaderTestCase . class ,     2  ,     3  ,     2  )  ;", "loadCtxAndAssertStats ( ContextCacheTests . CustomAnnotationConfigContextLoaderTestCase . class ,     2  ,     4  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["verifyCacheKeyIsBasedOnContextLoader"], "fileName": "org.springframework.test.context.cache.ContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   maxSize    =    SpringProperties . getProperty (  . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME )  ;", "if    ( StringUtils . hasText ( maxSize )  )     {", "return   Integer . parseInt ( maxSize . trim (  )  )  ;", "}", "}    catch    ( Exception   ex )     {", "}", "return    . DEFAULT _ MAX _ CONTEXT _ CACHE _ SIZE ;", "}", "METHOD_END"], "methodName": ["retrieveMaxCacheSize"], "fileName": "org.springframework.test.context.cache.ContextCacheUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ContextCache . DEFAULT _ MAX _ CONTEXT _ CACHE _ SIZE ,    ContextCacheUtils . retrieveMaxCacheSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDefaultValue"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . clearProperty ( ContextCache . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME )  ;", "SpringProperties . setProperty ( ContextCache . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME ,    null )  ;", "}", "METHOD_END"], "methodName": ["clearProperties"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "SpringProperties . setProperty ( ContextCache . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME ,     \" bogus \"  )  ;", ". assertDefaultValue (  )  ;", "}", "METHOD_END"], "methodName": ["retrieveMaxCacheSizeFromBogusSpringProperty"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( ContextCache . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME ,     \" bogus \"  )  ;", ". assertDefaultValue (  )  ;", "}", "METHOD_END"], "methodName": ["retrieveMaxCacheSizeFromBogusSystemProperty"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "SpringProperties . setProperty ( ContextCache . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME ,     \"  3  .  1  4  \"  )  ;", ". assertDefaultValue (  )  ;", "}", "METHOD_END"], "methodName": ["retrieveMaxCacheSizeFromDecimalSpringProperty"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheUtilsTests . assertDefaultValue (  )  ;", "}", "METHOD_END"], "methodName": ["retrieveMaxCacheSizeFromDefault"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "SpringProperties . setProperty ( ContextCache . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME ,     \"  9  9  \"  )  ;", "assertEquals (  9  9  ,     . retrieveMaxCacheSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["retrieveMaxCacheSizeFromSpringProperty"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( ContextCache . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME ,     \"  4  2  \"  )  ;", "assertEquals (  4  2  ,     . retrieveMaxCacheSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["retrieveMaxCacheSizeFromSystemProperty"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( ContextCache . MAX _ CONTEXT _ CACHE _ SIZE _ PROPERTY _ NAME ,     \"  4  2  \\ t \"  )  ;", "assertEquals (  4  2  ,     . retrieveMaxCacheSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["retrieveMaxCacheSizeFromSystemPropertyContainingWhitespace"], "fileName": "org.springframework.test.context.cache.ContextCacheUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . contextCache ;", "}", "METHOD_END"], "methodName": ["getContextCache"], "fileName": "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate"}, {"methodBody": ["METHOD_START", "{", "ContextLoader   contextLoader    =    mergedContextConfiguration . getContextLoader (  )  ;", "Assert . notNull ( contextLoader ,     (  \" Cannot   load   an   ApplicationContext   with   a   NULL    ' contextLoader '  .     \"     +     \" Consider   annotating   your   test   class   with    @ ContextConfiguration   or    @ ContextHierarchy .  \"  )  )  ;", "ApplicationContext   applicationContext ;", "if    ( contextLoader   instanceof   SmartContextLoader )     {", "SmartContextLoader   smartContextLoader    =     (  ( SmartContextLoader )     ( contextLoader )  )  ;", "applicationContext    =    smartContextLoader . loadContext ( mergedContextConfiguration )  ;", "} else    {", "String [  ]    locations    =    mergedContextConfiguration . getLocations (  )  ;", "Assert . notNull ( locations ,     (  \" Cannot   load   an   ApplicationContext   with   a   NULL    ' locations '    array .     \"     +     \" Consider   annotating   your   test   class   with    @ ContextConfiguration   or    @ ContextHierarchy .  \"  )  )  ;", "applicationContext    =    contextLoader . loadContext ( locations )  ;", "}", "return   applicationContext ;", "}", "METHOD_END"], "methodName": ["loadContextInternal"], "fileName": "org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   this . maxSize ;", "}", "METHOD_END"], "methodName": ["getMaxSize"], "fileName": "org.springframework.test.context.cache.DefaultContextCache"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( key ,     \" Key   must   not   be   null \"  )  ;", "Set < Mergedonfiguration >    children    =    this . hierarchyMap . get ( key )  ;", "if    ( children    !  =    null )     {", "for    ( Mergedonfiguration   child    :    children )     {", "remove ( removedContexts ,    child )  ;", "}", "this . hierarchyMap . remove ( key )  ;", "}", "ApplicationContext   context    =    this . contextMap . remove ( key )  ;", "if    ( context   instanceof   ConfigurableApplicationContext )     {", "(  ( ConfigurableApplicationContext )     ( context )  )  . close (  )  ;", "}", "removedContexts . add ( key )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.springframework.test.context.cache.DefaultContextCache"}, {"methodBody": ["METHOD_START", "{", "Map < MergedContextConfiguration ,    ApplicationContext >    contextMap    =     (  ( Map < MergedContextConfiguration ,    ApplicationContext >  )     ( ReflectionTestUtils . getField ( cache ,     \" contextMap \"  )  )  )  ;", "List < String >    actualNames    =    contextMap . keySet (  )  . stream (  )  . map (  (    cfg )     -  >    cfg . getClasses (  )  [  0  ]  )  . map ( Class :  : getSimpleName )  . collect ( Collectors . toList (  )  )  ;", "assertEquals ( Arrays . asList ( expectedNames )  ,    actualNames )  ;", "}", "METHOD_END"], "methodName": ["assertCacheContents"], "fileName": "org.springframework.test.context.cache.LruContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MergedContextConfiguration ( null ,    null ,    new   Class <  ?  >  [  ]  {    clazz    }  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["config"], "fileName": "org.springframework.test.context.cache.LruContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "DefaultContextCache   cache    =    new   DefaultContextCache (  2  )  ;", "cache . put (  . fooConfig ,    fooContext )  ;", "cache . put (  . barConfig ,    barContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  ,     \" Bar \"  )  ;", "cache . put (  . bazConfig ,    bazContext )  ;", ". assertCacheContents ( cache ,     \" Bar \"  ,     \" Baz \"  )  ;", "verify ( fooContext ,    times (  1  )  )  . close (  )  ;", "cache . put (  . abcConfig ,    abcContext )  ;", ". assertCacheContents ( cache ,     \" Baz \"  ,     \" Abc \"  )  ;", "verify ( barContext ,    times (  1  )  )  . close (  )  ;", "verify ( abcContext ,    never (  )  )  . close (  )  ;", "verify ( bazContext ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["ensureEvictedContextsAreClosed"], "fileName": "org.springframework.test.context.cache.LruContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "DefaultContextCache   cache    =    new   DefaultContextCache (  3  )  ;", "cache . put (  . fooConfig ,    fooContext )  ;", "cache . put (  . barConfig ,    barContext )  ;", "cache . put (  . bazConfig ,    bazContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  ,     \" Bar \"  ,     \" Baz \"  )  ;", "cache . get (  . fooConfig )  ;", ". assertCacheContents ( cache ,     \" Bar \"  ,     \" Baz \"  ,     \" Foo \"  )  ;", "cache . get (  . barConfig )  ;", ". assertCacheContents ( cache ,     \" Baz \"  ,     \" Foo \"  ,     \" Bar \"  )  ;", "cache . get (  . bazConfig )  ;", ". assertCacheContents ( cache ,     \" Foo \"  ,     \" Bar \"  ,     \" Baz \"  )  ;", "cache . get (  . barConfig )  ;", ". assertCacheContents ( cache ,     \" Foo \"  ,     \" Baz \"  ,     \" Bar \"  )  ;", "}", "METHOD_END"], "methodName": ["ensureLruOrderingIsUpdated"], "fileName": "org.springframework.test.context.cache.LruContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "new   DefaultContextCache (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["maxCacheSizeNegativeOne"], "fileName": "org.springframework.test.context.cache.LruContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "DefaultContextCache   cache    =    new   DefaultContextCache (  1  )  ;", "assertEquals (  0  ,    cache . size (  )  )  ;", "assertEquals (  1  ,    cache . getMaxSize (  )  )  ;", "cache . put (  . fooConfig ,    fooContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  )  ;", "cache . put (  . fooConfig ,    fooContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  )  ;", "cache . put (  . barConfig ,    barContext )  ;", ". assertCacheContents ( cache ,     \" Bar \"  )  ;", "cache . put (  . fooConfig ,    fooContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  )  ;", "}", "METHOD_END"], "methodName": ["maxCacheSizeOne"], "fileName": "org.springframework.test.context.cache.LruContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "DefaultContextCache   cache    =    new   DefaultContextCache (  3  )  ;", "assertEquals (  0  ,    cache . size (  )  )  ;", "assertEquals (  3  ,    cache . getMaxSize (  )  )  ;", "cache . put (  . fooConfig ,    fooContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  )  ;", "cache . put (  . fooConfig ,    fooContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  )  ;", "cache . put (  . barConfig ,    barContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  ,     \" Bar \"  )  ;", "cache . put (  . bazConfig ,    bazContext )  ;", ". assertCacheContents ( cache ,     \" Foo \"  ,     \" Bar \"  ,     \" Baz \"  )  ;", "cache . put (  . abcConfig ,    abcContext )  ;", ". assertCacheContents ( cache ,     \" Bar \"  ,     \" Baz \"  ,     \" Abc \"  )  ;", "}", "METHOD_END"], "methodName": ["maxCacheSizeThree"], "fileName": "org.springframework.test.context.cache.LruContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "new   DefaultContextCache (  0  )  ;", "}", "METHOD_END"], "methodName": ["maxCacheSizeZero"], "fileName": "org.springframework.test.context.cache.LruContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" context   must   not   be   null \"  ,    this . context )  ;", "assertTrue (  \" context   must   be   active \"  ,    this . context . isActive (  )  )  ;", "assertNotNull (  \" count   must   not   be   null \"  ,    this . count )  ;", "assertEquals (  \" count :     \"  ,    expectedContextCreationCount ,    this . count . intValue (  )  )  ;", "assertEquals (  \" context   creation   count :     \"  ,    expectedContextCreationCount ,     . contextCount . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["performAssertions"], "fileName": "org.springframework.test.context.cache.MethodLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "performAssertions (  1  )  ;", "}", "METHOD_END"], "methodName": ["test01"], "fileName": "org.springframework.test.context.cache.MethodLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "performAssertions (  2  )  ;", "}", "METHOD_END"], "methodName": ["test02_dirtyContextBeforeTestMethod"], "fileName": "org.springframework.test.context.cache.MethodLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "performAssertions (  2  )  ;", "}", "METHOD_END"], "methodName": ["test03_dirtyContextAferTestMethod"], "fileName": "org.springframework.test.context.cache.MethodLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "performAssertions (  3  )  ;", "}", "METHOD_END"], "methodName": ["test04"], "fileName": "org.springframework.test.context.cache.MethodLevelDirtiesContextTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics (  \" dirtyContext (  )  \"  ,     1  ,     0  ,     1  )  ;", "assertNotNull (  \" The   application   context   should   have   been   autowired .  \"  ,    this . applicationContext )  ;", ". dirtiedApplicationContext    =    this . applicationContext ;", "}", "METHOD_END"], "methodName": ["dirtyContext"], "fileName": "org.springframework.test.context.cache.SpringRunnerContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics (  \" verifyContextWasDirtied (  )  \"  ,     1  ,     0  ,     2  )  ;", "assertNotNull (  \" The   application   context   should   have   been   autowired .  \"  ,    this . applicationContext )  ;", "assertNotSame (  \" The   application   context   should   have   been    ' dirtied '  .  \"  ,     . dirtiedApplicationContext ,    this . applicationContext )  ;", ". dirtiedApplicationContext    =    this . applicationContext ;", "}", "METHOD_END"], "methodName": ["verifyContextDirty"], "fileName": "org.springframework.test.context.cache.SpringRunnerContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics (  \" verifyContextWasNotDirtied (  )  \"  ,     1  ,     1  ,     2  )  ;", "assertNotNull (  \" The   application   context   should   have   been   autowired .  \"  ,    this . applicationContext )  ;", "assertSame (  \" The   application   context   should   NOT   have   been    ' dirtied '  .  \"  ,     . dirtiedApplicationContext ,    this . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["verifyContextNotDirty"], "fileName": "org.springframework.test.context.cache.SpringRunnerContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics (  \" AfterClass \"  ,     1  ,     1  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalCacheState"], "fileName": "org.springframework.test.context.cache.SpringRunnerContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "SpringRunnerContextCacheTests . dirtiedApplicationContext    =    null ;", "ContextCacheTestUtils . resetContextCache (  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" BeforeClass \"  ,     0  ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["verifyInitialCacheState"], "fileName": "org.springframework.test.context.cache.SpringRunnerContextCacheTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   dog   field   should   have   been   autowired .  \"  ,    this . dog )  ;", "assertEquals (  \" Fido \"  ,    this . dog . getName (  )  )  ;", "assertNotNull (  \" TheString 2    field   should   have   been   autowired .  \"  ,    thisString 2  )  ;", "assertEquals (  \" Test   String    #  2  \"  ,    thisString 2  )  ;", "}", "METHOD_END"], "methodName": ["verifyExtendedAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.configuration.ContextConfigurationWithPropertiesExtendingPropertiesAndInheritedLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   dog   field   should   have   been   autowired .  \"  ,    this . dog )  ;", "assertEquals (  \" Fido \"  ,    this . dog . getName (  )  )  ;", "assertNotNull (  \" TheString 2    field   should   have   been   autowired .  \"  ,    thisString 2  )  ;", "assertEquals (  \" Test   String    #  2  \"  ,    thisString 2  )  ;", "}", "METHOD_END"], "methodName": ["verifyExtendedAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.configuration.ContextConfigurationWithPropertiesExtendingPropertiesTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( employee )  ;", "assertEquals (  \" dev \"  ,    employee . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["profileFromTestInterface"], "fileName": "org.springframework.test.context.configuration.interfaces.ActiveProfilesInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["injectedBean"], "fileName": "org.springframework.test.context.configuration.interfaces.BootstrapWithInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( employee )  ;", "assertEquals (  \" Dilbert \"  ,    employee . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["profileFromTestInterface"], "fileName": "org.springframework.test.context.configuration.interfaces.ContextConfigurationInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNotNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertNull (  \" grandparent   ApplicationContext \"  ,    getParent (  )  . getParent (  )  )  ;", "assertEquals (  \" foo \"  ,    foo )  ;", "assertEquals (  \" bar \"  ,    bar )  ;", "assertEquals (  \" baz - child \"  ,    baz )  ;", "}", "METHOD_END"], "methodName": ["loadContextHierarchy"], "fileName": "org.springframework.test.context.configuration.interfaces.ContextHierarchyInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "JUnitTestingUtils . runTestsAndAssertCounters ( testClass ,    expectedTestCount ,     0  ,    expectedTestCount ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["runTestClassAndAssertStats"], "fileName": "org.springframework.test.context.configuration.interfaces.DirtiesContextInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "runTestClassAndAssertStats ( DirtiesContextInterfaceTests . ClassLevelDirtiesContextWithCleanMethodsAndDefaultModeTestCase . class ,     1  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" after   class - level    @ DirtiesContext   with   clean   test   method   and   default   class   mode \"  ,     0  ,    DirtiesContextInterfaceTests . cacheHits . get (  )  ,    DirtiesContextInterfaceTests . cacheMisses . incrementAndGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyDirtiesContextBehavior"], "fileName": "org.springframework.test.context.configuration.interfaces.DirtiesContextInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . assertContextCacheStatistics (  \" AfterClass \"  ,     0  ,    DirtiesContextInterfaceTests . cacheHits . get (  )  ,    DirtiesContextInterfaceTests . cacheMisses . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalCacheState"], "fileName": "org.springframework.test.context.configuration.interfaces.DirtiesContextInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "ContextCacheTestUtils . resetContextCache (  )  ;", ". cacheHits . set (  0  )  ;", ". cacheMisses . set (  0  )  ;", "ContextCacheTestUtils . assertContextCacheStatistics (  \" BeforeClass \"  ,     0  ,     . cacheHits . get (  )  ,     . cacheMisses . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyInitialCacheState"], "fileName": "org.springframework.test.context.configuration.interfaces.DirtiesContextInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.configuration.interfaces.SqlConfigInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  3  )  ;", "}", "METHOD_END"], "methodName": ["methodLevelScripts"], "fileName": "org.springframework.test.context.configuration.interfaces.SqlConfigInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( property (  \" foo \"  )  ,    is (  \" bar \"  )  )  ;", "assertThat ( property (  \" enigma \"  )  ,    is (  \"  4  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertiesAreAvailableInEnvironment"], "fileName": "org.springframework.test.context.configuration.interfaces.TestPropertySourceInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "return   env . getProperty ( key )  ;", "}", "METHOD_END"], "methodName": ["property"], "fileName": "org.springframework.test.context.configuration.interfaces.TestPropertySourceInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wac )  ;", "}", "METHOD_END"], "methodName": ["wacLoaded"], "fileName": "org.springframework.test.context.configuration.interfaces.WebAppConfigurationInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" test   override \"  ,    env . getProperty (  \" explicit \"  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPropertiesAreAvailableInEnvironment"], "fileName": "org.springframework.test.context.env.ApplicationPropertyOverridePropertiesFileTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  (  \" Value   of   key    [  \"     +    key )     +     \"  ]  .  \"  )  ,    expected ,    env . getProperty ( key )  )  ;", "}", "METHOD_END"], "methodName": ["assertEnvironmentValue"], "fileName": "org.springframework.test.context.env.DefaultPropertiesFileDetectionTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEnvironmentValue (  \" riddle \"  ,     \" auto   detected \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyPropertiesAreAvailableInEnvironment"], "fileName": "org.springframework.test.context.env.DefaultPropertiesFileDetectionTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "String   userHomeKey    =     \" user . home \"  ;", "assertEquals ( System . ge ( userHomeKey )  ,    env . ge ( userHomeKey )  )  ;", "assertEquals (  \" enigma \"  ,    env . ge (  \" explicit \"  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPropertiesAreAvailableInEnvironment"], "fileName": "org.springframework.test.context.env.ExplicitPropertiesFileTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "super . verifyPropertiesAreAvailableInEnvironment (  )  ;", "assertEnvironmentValue (  \" enigma \"  ,     \" auto   detected \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyPropertiesAreAvailableInEnvironment"], "fileName": "org.springframework.test.context.env.ExtendedDefaultPropertiesFileDetectionTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" inlined \"  ,    env . getProperty (  \" explicit \"  )  )  ;", "assertEquals (  \" inlined \"  ,    this . explicit )  ;", "}", "METHOD_END"], "methodName": ["inlinedPropertyOverridesValueFromPropertiesFile"], "fileName": "org.springframework.test.context.env.InlinedPropertiesOverridePropertiesFilesTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( property (  \" foo \"  )  ,    is (  \" bar \"  )  )  ;", "assertThat ( property (  \" baz \"  )  ,    is (  \" quux \"  )  )  ;", "assertThat ( property (  \" enigma \"  )  ,    is (  \"  4  2  \"  )  )  ;", "assertThat ( property (  \" x . y . z \"  )  ,    is (  \" a = b = c \"  )  )  ;", "assertThat ( property (  \" server . url \"  )  ,    is (  \" http :  /  / example . com \"  )  )  ;", "assertThat ( property (  \" key . value .  1  \"  )  ,    is (  \" key = value \"  )  )  ;", "assertThat ( property (  \" key . value .  2  \"  )  ,    is (  \" key = value \"  )  )  ;", "assertThat ( property (  \" key . value .  3  \"  )  ,    is (  \" key : value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertiesAreAvailableInEnvironment"], "fileName": "org.springframework.test.context.env.InlinedPropertiesTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "return   env . getProperty ( key )  ;", "}", "METHOD_END"], "methodName": ["property"], "fileName": "org.springframework.test.context.env.InlinedPropertiesTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    expectedPropertyNames    =    new   String [  ]  {     \" foo \"  ,     \" baz \"  ,     \" enigma \"  ,     \" x . y . z \"  ,     \" server . url \"  ,     \" key . value .  1  \"  ,     \" key . value .  2  \"  ,     \" key . value .  3  \"     }  ;", "EnumerablePropertySource   eps    =     (  ( EnumerablePropertySource )     ( env . getPropertySources (  )  . get ( Utils . INLINED _ PROPERTIES _ PROPERTY _ SOURCE _ NAME )  )  )  ;", "assertArrayEquals ( expectedPropertyNames ,    eps . getPropertyNames (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyNameOrderingIsPreservedInEnvironment"], "fileName": "org.springframework.test.context.env.InlinedPropertiesTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  4  2  ,    env . getProperty (  \" extended \"  ,    Integer . class )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyExtendedPropertiesAreAvailableInEnvironment"], "fileName": "org.springframework.test.context.env.MergedPropertiesFilesTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( SystemPropertyOverridePropertiesFileTestPropertySourceTests . KEY ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["removeSystemProperty"], "fileName": "org.springframework.test.context.env.SystemPropertyOverridePropertiesFileTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( SystemPropertyOverridePropertiesFileTestPropertySourceTests . KEY ,     \" override   me !  \"  )  ;", "}", "METHOD_END"], "methodName": ["setSystemProperty"], "fileName": "org.springframework.test.context.env.SystemPropertyOverridePropertiesFileTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" enigma \"  ,    env . getProperty ( SystemPropertyOverridePropertiesFileTestPropertySourceTests . KEY )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPropertiesAreAvailableInEnvironment"], "fileName": "org.springframework.test.context.env.SystemPropertyOverridePropertiesFileTestPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Andy \"  ,    andy 2  . getName (  )  )  ;", "assertEquals (  \" Andy \"  ,    andy . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpr5847"], "fileName": "org.springframework.test.context.expression.ExpressionUsageTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Dave \"  ,    props . getProperty (  \" user . name \"  )  )  ;", "assertEquals (  \" Andy \"  ,    props . getProperty (  \" username \"  )  )  ;", "assertEquals (  \" exists \"  ,    props . getProperty (  \" Dave \"  )  )  ;", "assertEquals (  \" exists   also \"  ,    props . getProperty (  \" Andy \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpr5906"], "fileName": "org.springframework.test.context.expression.ExpressionUsageTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   field   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" Dilbert \"  ,    this . employee . getN (  )  )  ;", "assertNotNull (  \" The   pet   field   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Dogbert \"  ,    this . pet . getN (  )  )  ;", "assertEquals (  \" The   foo   field   should   have   been   autowired .  \"  ,     \" Foo \"  ,    this . foo )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.groovy.DefaultScriptDetectionGroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" The   foo   field   should   have   been   autowired .  \"  ,     \" Foo \"  ,    this . foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.groovy.DefaultScriptDetectionXmlSupersedesGroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   GenericGroovyApplicationContext ( getClass (  )  ,     \" context . groovy \"  )  ;", "String   foo    =    ctx . getBean (  \" foo \"  ,    String . class )  ;", "assertEquals (  \" Foo \"  ,    foo )  ;", "String   bar    =    ctx . getBean (  \" bar \"  ,    String . class )  ;", "assertEquals (  \" Bar \"  ,    bar )  ;", "Pet   pet    =    ctx . getBean ( Pet . class )  ;", "assertNotNull (  \" pet \"  ,    pet )  ;", "assertEquals (  \" Dogbert \"  ,    pet . getName (  )  )  ;", "Employee   employee    =    ctx . getBean ( Employee . class )  ;", "assertNotNull (  \" employee \"  ,    employee )  ;", "assertEquals (  \" Dilbert \"  ,    employee . getName (  )  )  ;", "assertEquals (  \"  ?  ?  ?  \"  ,    employee . getCompany (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyScriptUsingGenericGroovyApplicationContext"], "fileName": "org.springframework.test.context.groovy.GroovyControlGroupTests"}, {"methodBody": ["METHOD_START", "{", "this . bar    =    bar ;", "}", "METHOD_END"], "methodName": ["setBar"], "fileName": "org.springframework.test.context.groovy.GroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . employee    =    employee ;", "}", "METHOD_END"], "methodName": ["setEmployee"], "fileName": "org.springframework.test.context.groovy.GroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertNull (  \" The   nonrequiredLong   property   should   NOT   have   been   autowired .  \"  ,    this . nonrequiredLong )  ;", "assertNotNull (  \" The   application      should   have   been   autowired .  \"  ,    this . applicationContext )  ;", "assertNotNull (  \" The   pet   field   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Dogbert \"  ,    this . pet . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.groovy.GroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   setter   method   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" Dilbert \"  ,    this . employee . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredMethods"], "fileName": "org.springframework.test.context.groovy.GroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" This   test   bean   should   have   been   initialized   due   to   InitializingBean   semantics .  \"  ,    this . beanInitialized )  ;", "}", "METHOD_END"], "methodName": ["verifyBeanInitialized"], "fileName": "org.springframework.test.context.groovy.GroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  \" The   bean   name   of   this   test   instance   should   have   been   set   to   the   fully   qualified   class   name    \"     +     \" due   to   BeanNameAware   semantics .  \"  )  ,    getClass (  )  . getName (  )  ,    this . beanName )  ;", "}", "METHOD_END"], "methodName": ["verifyBeanNameSet"], "fileName": "org.springframework.test.context.groovy.GroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" The   foo   field   should   have   been   wired   via    @ Resource .  \"  ,     \" Foo \"  ,    this . foo )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceAnnotationWiredFields"], "fileName": "org.springframework.test.context.groovy.GroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" The   bar   method   should   have   been   wired   via    @ Resource .  \"  ,     \" Bar \"  ,    this . bar )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceAnnotationWiredMethods"], "fileName": "org.springframework.test.context.groovy.GroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   field   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" Dilbert \"  ,    this . employee . getName (  )  )  ;", "assertNotNull (  \" The   pet   field   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Dogbert \"  ,    this . pet . getName (  )  )  ;", "assertEquals (  \" The   foo   field   should   have   been   autowired .  \"  ,     \"    Foo \"  ,    this . foo )  ;", "assertEquals (  \" The   bar   field   should   have   been   autowired .  \"  ,     \" XML   Bar \"  ,    this . bar )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.groovy.MixedXmlAndGroovySpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return    \" Dev   Foo \"  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.hierarchies.meta.DevConfig"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Dev   Foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.hierarchies.meta.MetaHierarchyLevelOneTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Prod   Bar \"  ,    bar )  ;", "}", "METHOD_END"], "methodName": ["bar"], "fileName": "org.springframework.test.context.hierarchies.meta.MetaHierarchyLevelTwoTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNotNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertNull (  \" grandparent   ApplicationContext \"  ,    getParent (  )  . getParent (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.meta.MetaHierarchyLevelTwoTests"}, {"methodBody": ["METHOD_START", "{", "return    \" Production   Foo \"  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.hierarchies.meta.ProductionConfig"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNotNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertNull (  \" grandparent   ApplicationContext \"  ,    getParent (  )  . getParent (  )  )  ;", "assertEquals (  \" parent \"  ,    parent )  ;", "assertEquals (  \" parent    +    user \"  ,    user )  ;", "assertEquals (  \" from   UserConfig \"  ,    beanFromUserConfig )  ;", "}", "METHOD_END"], "methodName": ["loadContextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.standard.ClassHierarchyWithMergedConfigLevelOneTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" baz - child \"  ,    baz . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCleanChildContext"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCleanParentContext"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" dlihc - zab \"  ,    baz . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDirtyChildContext"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" oof \"  ,    foo . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDirtyParentContext"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertCleanParentContext (  )  ;", "assertCleanChildContext (  )  ;", "}", "METHOD_END"], "methodName": ["assertOriginalState"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "foo . reverse (  )  ;", "baz . reverse (  )  ;", "}", "METHOD_END"], "methodName": ["reverseStringBuffers"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertOriginalState (  )  ;", "reverseStBuffers (  )  ;", "}", "METHOD_END"], "methodName": ["test1_verifyOriginalStateAndDirtyContexts"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertDirtyParentContext (  )  ;", "assertDirtyChildContext (  )  ;", "}", "METHOD_END"], "methodName": ["test2_verifyContextsWereDirtiedAndTriggerExhaustiveCacheClearing"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertOriginalState (  )  ;", "reverseStBuffers (  )  ;", "}", "METHOD_END"], "methodName": ["test3_verifyOriginalStateWasReinstatedAndDirtyContextsAndTriggerCurrentLevelCacheClearing"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertDirtyParentContext (  )  ;", "assertCleanChildContext (  )  ;", "}", "METHOD_END"], "methodName": ["test4_verifyParentContextIsStillDirtyButChildContextHasBeenReinstated"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNotNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertNull (  \" grandparent   ApplicationContext \"  ,    getParent (  )  . getParent (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyContextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.standard.DirtiesContextWithContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["loadContextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.standard.SingleTestClassWithSingleLevelContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNotNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertNull (  \" grandparent   ApplicationContext \"  ,    getParent (  )  . getParent (  )  )  ;", "assertEquals (  \" foo \"  ,    foo )  ;", "assertEquals (  \" bar \"  ,    bar )  ;", "assertEquals (  \" baz - child \"  ,    baz )  ;", "}", "METHOD_END"], "methodName": ["loadContextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.standard.SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNotNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertNull (  \" grandparent   ApplicationContext \"  ,    getParent (  )  . getParent (  )  )  ;", "assertEquals (  \" foo \"  ,    foo )  ;", "assertEquals (  \" bar \"  ,    bar )  ;", "assertEquals (  \" baz - child \"  ,    baz )  ;", "}", "METHOD_END"], "methodName": ["loadContextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.standard.SingleTestClassWithTwoLevelContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertEquals (  \" foo - level -  1  \"  ,    foo )  ;", "assertEquals (  \" bar \"  ,    bar )  ;", "}", "METHOD_END"], "methodName": ["loadContextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.standard.TestHierarchyLevelOneWithBareContextConfigurationInSubclassTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertEquals (  \" foo - level -  1  \"  ,    foo )  ;", "assertEquals (  \" bar \"  ,    bar )  ;", "}", "METHOD_END"], "methodName": ["loadContextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.standard.TestHierarchyLevelOneWithBareContextConfigurationInSuperclassTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" child   ApplicationContext \"  ,     ;", "assertNull (  \" parent   ApplicationContext \"  ,    getParent (  )  )  ;", "assertEquals (  \" foo - level -  1  \"  ,    foo )  ;", "assertEquals (  \" bar \"  ,    bar )  ;", "}", "METHOD_END"], "methodName": ["loadContextHierarchy"], "fileName": "org.springframework.test.context.hierarchies.standard.TestHierarchyLevelOneWithSingleLevelContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "assertEquals (  \" bar \"  ,    bar )  ;", "ApplicationCparent    =    wac . getParent (  )  ;", "assertNotNull ( parent )  ;", "assertTrue (  ( parent   instanceof   WebApplicationC )  ;", "WebApplicationCroot    =     (  ( WebApplicationC    ( parent )  )  ;", "assertFalse ( root . getBeansOfType ( String . class )  . containsKey (  \" bar \"  )  )  ;", "ServletCchildServletC =    wac . getServletC )  ;", "assertNotNull ( childServletC ;", "ServletCrootServletC =    root . getServletC )  ;", "assertNotNull ( rootServletC ;", "assertSame ( childServletC   rootServletC ;", "assertSame ( root ,    rootServletCgetAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ;", "assertSame ( root ,    childServletCgetAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ;", "}", "METHOD_END"], "methodName": ["verifyRootWacSupport"], "fileName": "org.springframework.test.context.hierarchies.web.ControllerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   parent    =    wac . getParent (  )  ;", "assertNotNull ( parent )  ;", "assertTrue (  ( parent   instanceof   WebApplicationContext )  )  ;", "ApplicationContext   grandParent    =    parent . getParent (  )  ;", "assertNotNull ( grandParent )  ;", "assertFalse (  ( grandParent   instanceof   WebApplicationContext )  )  ;", "ServletContext   dServletContext    =    wac . getServletContext (  )  ;", "assertNotNull ( dServletContext )  ;", "ServletContext   rootServletContext    =     (  ( WebApplicationContext )     ( parent )  )  . getServletContext (  )  ;", "assertNotNull ( rootServletContext )  ;", "assertSame ( dServletContext ,    rootServletContext )  ;", "assertSame ( parent ,    rootServletContext . getAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ;", "assertSame ( parent ,    dServletContext . getAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ;", "assertEquals (  \" ear \"  ,    ear )  ;", "assertEquals (  \" root \"  ,    root )  ;", "assertEquals (  \" d \"  ,    d )  ;", "}", "METHOD_END"], "methodName": ["verifyDispatcherWacConfig"], "fileName": "org.springframework.test.context.hierarchies.web.DispatcherWacRootWacEarTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  (  (    instanceof   WebApplicationContext )  )  ;", "assertNull ( getParent (  )  )  ;", "assertEquals (  \" ear \"  ,    ear )  ;", "}", "METHOD_END"], "methodName": ["verifyEarConfig"], "fileName": "org.springframework.test.context.hierarchies.web.EarTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   parent    =    wac . getParent (  )  ;", "assertNotNull ( parent )  ;", "assertFalse (  ( parent   instanceof   WebApplicationContext )  )  ;", "assertEquals (  \" ear \"  ,    ear )  ;", "assertEquals (  \" root \"  ,    root )  ;", "}", "METHOD_END"], "methodName": ["verifyRootWacConfig"], "fileName": "org.springframework.test.context.hierarchies.web.RootWacEarTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,     1  ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["composedSqlAnnotation"], "fileName": "org.springframework.test.context.jdbc.ComposedAnnotationSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.CustomScriptSyntaxSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  3  )  ;", "}", "METHOD_END"], "methodName": ["methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.CustomScriptSyntaxSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    JdbcTestUtils . countRowsInTable ( jdbcTemplate ,     \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.DataSourceOnlySqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.jdbc.DataSourceOnlySqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["test01_classLevelScripts"], "fileName": "org.springframework.test.context.jdbc.DataSourceOnlySqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertNumUsers (  2  )  ;", "}", "METHOD_END"], "methodName": ["test02_methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.DataSourceOnlySqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.DefaultScriptDetectionSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  2  )  ;", "}", "METHOD_END"], "methodName": ["classLevel"], "fileName": "org.springframework.test.context.jdbc.DefaultScriptDetectionSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  3  )  ;", "}", "METHOD_END"], "methodName": ["methodLevel"], "fileName": "org.springframework.test.context.jdbc.DefaultScriptDetectionSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "return   new   EmbeddedDatabaseBuilder (  )  . setName (  \" empty - sql - scripts - test - db \"  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["dataSource"], "fileName": "org.springframework.test.context.jdbc.EmptyDatabaseConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   DataSourceTransactionManager ( dataSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionManager"], "fileName": "org.springframework.test.context.jdbc.EmptyDatabaseConfig"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.GlobalCustomScriptSyntaxSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  3  )  ;", "}", "METHOD_END"], "methodName": ["methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.GlobalCustomScriptSyntaxSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    expected    =    Arrays . asList ( users )  ;", "Collections . sort ( expected )  ;", "List < String >    actual    =    jdbcTemplate . queryForList (  \" select   name   from   user \"  ,    String . class )  ;", "Collections . sort ( actual )  ;", "assertEquals (  \" Users   in   database ;  \"  ,    expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertUsers"], "fileName": "org.springframework.test.context.jdbc.InferredDataSourceSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertUsers ( new   JdbcTemplate ( d 1  )  ,     \" Dilbert \"  ,     \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["database1"], "fileName": "org.springframework.test.context.jdbc.InferredDataSourceSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertUsers ( new   JdbcTemplate ( d 2  )  ,     \" Dilbert \"  ,     \" Catbert \"  )  ;", "}", "METHOD_END"], "methodName": ["database2"], "fileName": "org.springframework.test.context.jdbc.InferredDataSourceSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    expected    =    Arrays . asList ( users )  ;", "Colles . sort ( expected )  ;", "List < String >    actual    =    jdbcTemplate . queryForList (  \" select   name   from   user \"  ,    String . class )  ;", "Colles . sort ( actual )  ;", "assertEquals (  \" Users   in   database ;  \"  ,    expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertUsers"], "fileName": "org.springframework.test.context.jdbc.InferredDataSourceTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertUsers ( new   JdbcTemplate ( dataSource 1  )  ,     \" Dilbert \"  ,     \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["database1"], "fileName": "org.springframework.test.context.jdbc.InferredDataSourceTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertUsers ( new   JdbcTemplate ( dataSource 2  )  ,     \" Dilbert \"  ,     \" Catbert \"  )  ;", "}", "METHOD_END"], "methodName": ["database2"], "fileName": "org.springframework.test.context.jdbc.InferredDataSourceTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . blockCommentEndDelimiter ;", "}", "METHOD_END"], "methodName": ["getBlockCommentEndDelimiter"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . blockCommentStartDelimiter ;", "}", "METHOD_END"], "methodName": ["getBlockCommentStartDelimiter"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . commentPrefix ;", "}", "METHOD_END"], "methodName": ["getCommentPrefix"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . dataSource ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . encoding ;", "}", "METHOD_END"], "methodName": ["getEncoding"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "E   value    =    attributes . getEnum ( attributeName )  ;", "if    ( value    =  =    inheritedOrDefaultValue )     {", "value    =    defaultValue ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["getEnum"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . errorMode ;", "}", "METHOD_END"], "methodName": ["getErrorMode"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . separator ;", "}", "METHOD_END"], "methodName": ["getSeparator"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "String   value    =    attributes . getString ( attributeName )  ;", "if    (  \"  \"  . equals ( value )  )     {", "value    =    defaultValue ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["getString"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionMode ;", "}", "METHOD_END"], "methodName": ["getTransactionMode"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfig"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( cfg )  ;", "assertEquals (  \" dataSource \"  ,     \"  \"  ,    cfg . getDataSource (  )  )  ;", "assertEquals (  \" transactionManager \"  ,     \"  \"  ,    cfg . getTransactionManager (  )  )  ;", "assertEquals (  \" transactionMode \"  ,     . TransactionMode . INFERRED ,    cfg . getTransactionMode (  )  )  ;", "assertEquals (  \" encoding \"  ,     \"  \"  ,    cfg . getEncoding (  )  )  ;", "assertEquals (  \" separator \"  ,    DEFAULT _ STATEMENT _ SEPARATOR ,    cfg . getSeparator (  )  )  ;", "assertEquals (  \" commentPrefix \"  ,    DEFAULT _ COMMENT _ PREFIX ,    cfg . getCommentPrefix (  )  )  ;", "assertEquals (  \" blockCommentStartDelimiter \"  ,    DEFAULT _ BLOCK _ COMMENT _ START _ DELIMITER ,    cfg . getBlockCommentStartDelimiter (  )  )  ;", "assertEquals (  \" blockCommentEndDelimiter \"  ,    DEFAULT _ BLOCK _ COMMENT _ END _ DELIMITER ,    cfg . getBlockCommentEndDelimiter (  )  )  ;", "assertEquals (  \" errorMode \"  ,     . ErrorMode . FAIL _ ON _ ERROR ,    cfg . getErrorMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDefaults"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfigTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    MergedSqlConfigTests . GlobalConfigClass . class . getMethod (  \" globalConfigMethod \"  )  ;", "SqlConfig   localSqlConfig    =    method . getAnnotation ( Sql . class )  . config (  )  ;", "MergedSqlConfig   cfg    =    new   MergedSqlConfig ( localSqlConfig ,    MergedSqlConfigTests . GlobalConfigClass . class )  ;", "assertNotNull ( cfg )  ;", "assertEquals (  \" dataSource \"  ,     \"  \"  ,    cfg . getDataSource (  )  )  ;", "assertEquals (  \" transactionManager \"  ,     \"  \"  ,    cfg . getTransactionManager (  )  )  ;", "assertEquals (  \" transactionMode \"  ,    SqlConfig . TransactionMode . INFERRED ,    cfg . getTransactionMode (  )  )  ;", "assertEquals (  \" encoding \"  ,     \" global \"  ,    cfg . getEncoding (  )  )  ;", "assertEquals (  \" separator \"  ,     \"  \\ n \"  ,    cfg . getSeparator (  )  )  ;", "assertEquals (  \" commentPrefix \"  ,    DEFAULT _ COMMENT _ PREFIX ,    cfg . getCommentPrefix (  )  )  ;", "assertEquals (  \" blockCommentStartDelimiter \"  ,    DEFAULT _ BLOCK _ COMMENT _ START _ DELIMITER ,    cfg . getBlockCommentStartDelimiter (  )  )  ;", "assertEquals (  \" blockCommentEndDelimiter \"  ,    DEFAULT _ BLOCK _ COMMENT _ END _ DELIMITER ,    cfg . getBlockCommentEndDelimiter (  )  )  ;", "assertEquals (  \" errorMode \"  ,    SqlConfig . ErrorMode . IGNORE _ FAILED _ DROPS ,    cfg . getErrorMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["globalConfig"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfigTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    MergedSqlConfigTests . GlobalConfigWithDefaultsClass . class . getMethod (  \" globalConfigMethod \"  )  ;", "SqlConfig   localSqlConfig    =    method . getAnnotation ( Sql . class )  . config (  )  ;", "MergedSqlConfig   cfg    =    new   MergedSqlConfig ( localSqlConfig ,    MergedSqlConfigTests . GlobalConfigWithDefaultsClass . class )  ;", "assertDefaults ( cfg )  ;", "}", "METHOD_END"], "methodName": ["globalConfigWithDefaults"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfigTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    MergedSqlConfigTests . GlobalConfigClass . class . getMethod (  \" globalConfigWithLocalOverridesMethod \"  )  ;", "SqlConfig   localSqlConfig    =    method . getAnnotation ( Sql . class )  . config (  )  ;", "MergedSqlConfig   cfg    =    new   MergedSqlConfig ( localSqlConfig ,    MergedSqlConfigTests . GlobalConfigClass . class )  ;", "assertNotNull ( cfg )  ;", "assertEquals (  \" dataSource \"  ,     \"  \"  ,    cfg . getDataSource (  )  )  ;", "assertEquals (  \" transactionManager \"  ,     \"  \"  ,    cfg . getTransactionManager (  )  )  ;", "assertEquals (  \" transactionMode \"  ,    SqlConfig . TransactionMode . INFERRED ,    cfg . getTransactionMode (  )  )  ;", "assertEquals (  \" encoding \"  ,     \" local \"  ,    cfg . getEncoding (  )  )  ;", "assertEquals (  \" separator \"  ,     \"  @  @  \"  ,    cfg . getSeparator (  )  )  ;", "assertEquals (  \" commentPrefix \"  ,    DEFAULT _ COMMENT _ PREFIX ,    cfg . getCommentPrefix (  )  )  ;", "assertEquals (  \" blockCommentStartDelimiter \"  ,    DEFAULT _ BLOCK _ COMMENT _ START _ DELIMITER ,    cfg . getBlockCommentStartDelimiter (  )  )  ;", "assertEquals (  \" blockCommentEndDelimiter \"  ,    DEFAULT _ BLOCK _ COMMENT _ END _ DELIMITER ,    cfg . getBlockCommentEndDelimiter (  )  )  ;", "assertEquals (  \" errorMode \"  ,    SqlConfig . ErrorMode . CONTINUE _ ON _ ERROR ,    cfg . getErrorMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["globalConfigWithLocalOverrides"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfigTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    getClass (  )  . getMethod (  \" localConfigMethodWithContinueOnError \"  )  ;", "SqlConfig   localSqlConfig    =    method . getAnnotation ( Sql . class )  . config (  )  ;", "cfg    =    new    ( localSqlConfig ,    getClass (  )  )  ;", "assertNotNull ( cfg )  ;", "assertEquals (  \" errorMode \"  ,    SqlConfig . ErrorMode . CONTINUE _ ON _ ERROR ,    cfg . getErrorMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["localConfigWithContinueOnError"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfigTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    getClass (  )  . getMethod (  \" localConfigMethodWithCustomValues \"  )  ;", "SqlConfig   localSqlConfig    =    method . getAnnotation ( Sql . class )  . config (  )  ;", "cfg    =    new    ( localSqlConfig ,    getClass (  )  )  ;", "assertNotNull ( cfg )  ;", "assertEquals (  \" dataSource \"  ,     \" ds \"  ,    cfg . getDataSource (  )  )  ;", "assertEquals (  \" transactionManager \"  ,     \" txMgr \"  ,    cfg . getTransactionManager (  )  )  ;", "assertEquals (  \" transactionMode \"  ,    SqlConfig . TransactionMode . ISOLATED ,    cfg . getTransactionMode (  )  )  ;", "assertEquals (  \" encoding \"  ,     \" enigma \"  ,    cfg . getEncoding (  )  )  ;", "assertEquals (  \" separator \"  ,     \"  \\ n \"  ,    cfg . getSeparator (  )  )  ;", "assertEquals (  \" commentPrefix \"  ,     \"  `  \"  ,    cfg . getCommentPrefix (  )  )  ;", "assertEquals (  \" blockCommentStartDelimiter \"  ,     \"  <  <  \"  ,    cfg . getBlockCommentStartDelimiter (  )  )  ;", "assertEquals (  \" blockCommentEndDelimiter \"  ,     \"  >  >  \"  ,    cfg . getBlockCommentEndDelimiter (  )  )  ;", "assertEquals (  \" errorMode \"  ,    SqlConfig . ErrorMode . IGNORE _ FAILED _ DROPS ,    cfg . getErrorMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["localConfigWithCustomValues"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfigTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    getClass (  )  . getMethod (  \" localConfigMethodWithDefaults \"  )  ;", "SqlConfig   localSqlConfig    =    method . getAnnotation ( Sql . class )  . config (  )  ;", "cfg    =    new    ( localSqlConfig ,    getClass (  )  )  ;", "assertDefaults ( cfg )  ;", "}", "METHOD_END"], "methodName": ["localConfigWithDefaults"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfigTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    getClass (  )  . getMethod (  \" localConfigMethodWithIgnoreFailedDrops \"  )  ;", "SqlConfig   localSqlConfig    =    method . getAnnotation ( Sql . class )  . config (  )  ;", "cfg    =    new    ( localSqlConfig ,    getClass (  )  )  ;", "assertNotNull ( cfg )  ;", "assertEquals (  \" errorMode \"  ,    SqlConfig . ErrorMode . IGNORE _ FAILED _ DROPS ,    cfg . getErrorMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["localConfigWithIgnoreFailedDrops"], "fileName": "org.springframework.test.context.jdbc.MergedSqlConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.MetaAnnotationSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["metaSqlAnnotation"], "fileName": "org.springframework.test.context.jdbc.MetaAnnotationSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["metaSqlGroupAnnotation"], "fileName": "org.springframework.test.context.jdbc.MetaAnnotationSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    expected    =    Arrays . asList ( users )  ;", "Colles . sort ( expected )  ;", "List < String >    actual    =    jdbcTemplate . queryForList (  \" select   name   from   user \"  ,    String . class )  ;", "Colles . sort ( actual )  ;", "assertEquals (  \" Users   in   database ;  \"  ,    expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertUsers"], "fileName": "org.springframework.test.context.jdbc.MultipleDataSourcesAndTransactionManagersSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertUsers ( new   JdbcTemplate ( dataSource 1  )  ,     \" Dilbert \"  ,     \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["database1"], "fileName": "org.springframework.test.context.jdbc.MultipleDataSourcesAndTransactionManagersSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertUsers ( new   JdbcTemplate ( dataSource 2  )  ,     \" Dilbert \"  ,     \" Catbert \"  )  ;", "}", "METHOD_END"], "methodName": ["database2"], "fileName": "org.springframework.test.context.jdbc.MultipleDataSourcesAndTransactionManagersSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    expected    =    Arrays . asList ( users )  ;", "Colles . sort ( expected )  ;", "List < String >    actual    =    jdbcTemplate . queryForList (  \" select   name   from   user \"  ,    String . class )  ;", "Colles . sort ( actual )  ;", "assertEquals (  \" Users   in   database ;  \"  ,    expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertUsers"], "fileName": "org.springframework.test.context.jdbc.MultipleDataSourcesAndTransactionManagersTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertUsers ( new   JdbcTemplate ( dataSource 1  )  ,     \" Dilbert \"  ,     \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["database1"], "fileName": "org.springframework.test.context.jdbc.MultipleDataSourcesAndTransactionManagersTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertUsers ( new   JdbcTemplate ( dataSource 2  )  ,     \" Dilbert \"  ,     \" Catbert \"  )  ;", "}", "METHOD_END"], "methodName": ["database2"], "fileName": "org.springframework.test.context.jdbc.MultipleDataSourcesAndTransactionManagersTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    JdbcTestUtils . countRowsInTable ( jdbcTemplate ,     \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.NonTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.jdbc.NonTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["test01_classLevelScripts"], "fileName": "org.springframework.test.context.jdbc.NonTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  2  )  ;", "}", "METHOD_END"], "methodName": ["test02_methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.NonTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "return   new   EmbeddedDatabaseBuilder (  )  . setName (  \" populated - sql - scripts - test - db \"  )  . addScript (  \" classpath :  / org / springframework / test / context / jdbc / schema . sql \"  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["dataSource"], "fileName": "org.springframework.test.context.jdbc.PopulatedSchemaDatabaseConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   DataSourceTransactionManager ( dataSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionManager"], "fileName": "org.springframework.test.context.jdbc.PopulatedSchemaDatabaseConfig"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.PopulatedSchemaTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.PopulatedSchemaTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  0  )  ;", "}", "METHOD_END"], "methodName": ["verifyPreAndPostTransactionDatabaseState"], "fileName": "org.springframework.test.context.jdbc.PopulatedSchemaTransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,     1  ,    JdbcTestUtils . countRowsInTable ( thisTemplate ,     \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["dataSourceTest"], "fileName": "org.springframework.test.context.jdbc.PrimaryDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.jdbc.PrimaryDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.RepeatableSqlAnnotationSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["test01_classLevelScripts"], "fileName": "org.springframework.test.context.jdbc.RepeatableSqlAnnotationSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  2  )  ;", "}", "METHOD_END"], "methodName": ["test02_methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.RepeatableSqlAnnotationSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.jdbc.RequiresNewTransactionSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.RequiresNewTransactionSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  0  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.jdbc.RequiresNewTransactionSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.RequiresNewTransactionSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    testContext . getTestClass (  )  ;", "Method   method    =    testContext . getTestMethod (  )  ;", "String   elementType    =     ( classLevel )     ?     \" class \"     :     \" method \"  ;", "String   elementName    =     ( classLevel )     ?    clazz . getName (  )     :    method . toString (  )  ;", "String   resourcePath    =    ClassUtils . convertClassNameToResourcePath ( clazz . getName (  )  )  ;", "if    (  ! classLevel )     {", "resourcePath    +  =     \"  .  \"     +     ( method . getName (  )  )  ;", "}", "resourcePath    +  =     \"  . sql \"  ;", "String   prefixedResourcePath    =     ( ResourceUtils . CLASSPATH _ URL _ PREFIX )     +    resourcePath ;", "ClassPathResource   classPathResource    =    new   ClassPathResource ( resourcePath )  ;", "if    ( classPathResource . exists (  )  )     {", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( String . format (  \" Detected   default   SQL   script    \\  \"  % s \\  \"    for   test    % s    [  % s ]  \"  ,    prefixedResourcePath ,    elementType ,    elementName )  )  ;", "}", "return   prefixedResourcePath ;", "} else    {", "String   msg    =    String . format (  (  \" Could   not   detect   default   SQL   script   for   test    % s    [  % s ]  :     \"     +     (  \"  % s   does   not   exist .    Either   declare   statements   or   scripts   via    @ Sql   or   make   the    \"     +     \" default   SQL   script   available .  \"  )  )  ,    elementType ,    elementName ,    classPathResource )  ;", ". logger . error ( msg )  ;", "throw   new   IllegalStateException ( msg )  ;", "}", "}", "METHOD_END"], "methodName": ["detectDefaultScript"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "boolean   classLevel    =    false ;", "Set < Sql >    sqlAnnotations    =    AnnotatedElementUtils . getMergedRepeatableAnnotations ( testContext . getTestMethod (  )  ,    Sql . class ,    SqlGroup . class )  ;", "if    ( sqlAnnotations . isEmpty (  )  )     {", "sqlAnnotations    =    AnnotatedElementUtils . getMergedRepeatableAnnotations ( testContext . getTestClass (  )  ,    Sql . class ,    SqlGroup . class )  ;", "if    (  !  ( sqlAnnotations . isEmpty (  )  )  )     {", "classLevel    =    true ;", "}", "}", "for    ( Sql   sql    :    sqlAnnotations )     {", "execute ( sql ,    executionPhase ,    testContext ,    classLevel )  ;", "}", "}", "METHOD_END"], "methodName": ["executeSqlScripts"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "if    ( executionPhase    !  =     ( sql . executionPhase (  )  )  )     {", "return ;", "}", "MergedSqlConfig   mergedSqlConfig    =    new   MergedSqlConfig ( sql . config (  )  ,    testContext . getTestClass (  )  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Processing    % s   for   execution   phase    [  % s ]    and   test   context    % s .  \"  ,    mergedSqlConfig ,    executionPhase ,    testContext )  )  ;", "}", "final   ResourceDatabasePopulator   populator    =    new   ResourceDatabasePopulator (  )  ;", "populator . setSqlScriptEncoding ( mergedSqlConfig . getEncoding (  )  )  ;", "populator . setSeparator ( mergedSqlConfig . getSeparator (  )  )  ;", "populator . setCommentPrefix ( mergedSqlConfig . getCommentPrefix (  )  )  ;", "populator . setBlockCommentStartDelimiter ( mergedSqlConfig . getBlockCommentStartDelimiter (  )  )  ;", "populator . setBlockCommentEndDelimiter ( mergedSqlConfig . getBlockCommentEndDelimiter (  )  )  ;", "populator . setContinueOnError (  (  ( mergedSqlConfig . getErrorMode (  )  )     =  =     ( SqlConfig . ErrorMode . CONTINUE _ ON _ ERROR )  )  )  ;", "populator . setIgnoreFailedDrops (  (  ( mergedSqlConfig . getErrorMode (  )  )     =  =     ( SqlConfig . ErrorMode . IGNORE _ FAILED _ DROPS )  )  )  ;", "String [  ]    scripts    =    getScripts ( sql ,    testContext ,    classLevel )  ;", "scripts    =    TestContextResourceUtils . convertToClasspathResourcePaths ( testContext . getTestClass (  )  ,    scripts )  ;", "List < Resource >    scriptResources    =    TestContextResourceUtils . convertToResourceList ( testContext . getApplicationContext (  )  ,    scripts )  ;", "for    ( String   stmt    :    sql . statements (  )  )     {", "if    ( StringUtils . hasText ( stmt )  )     {", "stmt    =    stmt . trim (  )  ;", "scriptResources . add ( new   ByteArrayResource ( stmt . getBytes (  )  ,     (  \" from   inlined   SQL   statement :     \"     +    stmt )  )  )  ;", "}", "}", "populator . setScripts ( scriptResources . toArray ( new   Resource [  0  ]  )  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Executing   SQL   scripts :     \"     +     ( ObjectUtils . nullSafeToString ( scriptResources )  )  )  )  ;", "}", "String   dsName    =    mergedSqlConfig . getDataSource (  )  ;", "String   tmName    =    mergedSqlConfig . getTransactionManager (  )  ;", "DataSource   dataSource    =    TestContextTransactionUtils . retrieveDataSource ( testContext ,    dsName )  ;", "PlatformTransactionManager   txMgr    =    TestContextTransactionUtils . retrieveTransactionManager ( testContext ,    tmName )  ;", "boolean   newTxRequired    =     ( mergedSqlConfig . getTransactionMode (  )  )     =  =     ( SqlConfig . TransactionMode . ISOLATED )  ;", "if    ( txMgr    =  =    null )     {", "Assert . state (  (  ! newTxRequired )  ,     (  )     -  >    String . format (  (  \" Failed   to   execute   SQL   scripts   for   test   context    % s :     \"     +     (  \" cannot   execute   SQL   scripts   using   Transaction   Mode    \"     +     \"  [  % s ]    without   a   PlatformTransactionManager .  \"  )  )  ,    testContext ,    TransactionMode . ISOLATED )  )  ;", "Assert . state (  ( dataSource    !  =    null )  ,     (  )     -  >    String . format (  (  \" Failed   to   execute   SQL   scripts   for   test   context    % s :     \"     +     \" supply   at   least   a   DataSource   or   PlatformTransactionManager .  \"  )  ,    testContext )  )  ;", "populator . execute ( dataSource )  ;", "} else    {", "DataSource   dataSourceFromTxMgr    =    getDataSourceFromTransactionManager ( txMgr )  ;", "if    (  (  ( dataSource    !  =    null )     &  &     ( dataSourceFromTxMgr    !  =    null )  )     &  &     (  !  ( dataSource . equals ( dataSourceFromTxMgr )  )  )  )     {", "throw   new   IllegalStateException ( String . format (  (  \" Failed   to   execute   SQL   scripts   for   test   context    % s :     \"     +     (  \" the   configured   DataSource    [  % s ]     ( named    '  % s '  )    is   not   the   one   associated   with    \"     +     \" transaction   manager    [  % s ]     ( named    '  % s '  )  .  \"  )  )  ,    testContext ,    dataSource . getClass (  )  . getName (  )  ,    dsName ,    txMgr . getClass (  )  . getName (  )  ,    tmName )  )  ;", "}", "if    ( dataSource    =  =    null )     {", "dataSource    =    dataSourceFromTxMgr ;", "Assert . state (  ( dataSource    !  =    null )  ,     (  )     -  >    String . format (  (  \" Failed   to   execute   SQL   scripts   for    \"     +     \" test   context    % s :    could   not   obtain   DataSource   from   transaction   manager    [  % s ]     ( named    '  % s '  )  .  \"  )  ,    testContext ,    txMgr . getClass (  )  . getName (  )  ,    tmName )  )  ;", "}", "final   DataSource   finalDataSource    =    dataSource ;", "int   propagation    =     ( newTxRequired )     ?    TransactionDefinition . PROPAGATION _ REQUIRES _ NEW    :    TransactionDefinition . PROPAGATION _ REQUIRED ;", "TransactionAttribute   txAttr    =    TestContextTransactionUtils . createDelegatingTransactionAttribute ( testContext ,    new   DefaultTransactionAttribute ( propagation )  )  ;", "new   TransactionTemplate ( txMgr ,    txAttr )  . execute (  (    status )     -  >     {", "populator . execute ( finalDataSource )  ;", "return   null ;", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["executeSqlScripts"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   getDataSourceMethod    =    transacManager . getClass (  )  . getMethod (  \" getDataSource \"  )  ;", "Object   obj    =    ReflecUtils . invokeMethod ( getDataSourceMethod ,    transacManager )  ;", "if    ( obj   instanceof   DataSource )     {", "return    (  ( DataSource )     ( obj )  )  ;", "}", "}    catch    ( Excep   ex )     {", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDataSourceFromTransactionManager"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "String [  ]    scripts    =    sql . scripts (  )  ;", "if    (  ( ObjectUtils . isEmpty ( scripts )  )     &  &     ( ObjectUtils . isEmpty ( sql . statements (  )  )  )  )     {", "scripts    =    new   String [  ]  {    detectDefaultScript ( testContext ,    classLevel )     }  ;", "}", "return   scripts ;", "}", "METHOD_END"], "methodName": ["getScripts"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "try    {", "l . beforeTestMethod ( testContext )  ;", "fail (  \" Should   have   thrown   an   IllegalStateException .  \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "assertTrue (  (  \" Exception   message   should   contain :     \"     +    msg )  ,    e . getMessage (  )  . contains ( msg )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertExceptionContains"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    mock ( ApplicationContext . class )  ;", "given ( ctx . getResource ( anyString (  )  )  )  . willReturn ( mock ( Resource . class )  )  ;", "given ( ctx . getAutowireCapableBeanFactory (  )  )  . willReturn ( mock ( AutowireCapableBeanFactory . class )  )  ;", "Class <  ?  >    clazz    =     . IsolatedWithoutTxMgr . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" foo \"  )  )  ;", "given ( testContext . getApplicationContext (  )  )  . willReturn ( ctx )  ;", "assertExceptionContains (  \" cannot   execute   SQL   scripts   using   Transaction   Mode    [ ISOLATED ]    without   a   PlatformTransactionManager \"  )  ;", "}", "METHOD_END"], "methodName": ["isolatedTxModeDeclaredWithoutTxMgr"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    mock ( ApplicationContext . class )  ;", "given ( ctx . getResource ( anyString (  )  )  )  . willReturn ( mock ( Resource . class )  )  ;", "given ( ctx . getAutowireCapableBeanFactory (  )  )  . willReturn ( mock ( AutowireCapableBeanFactory . class )  )  ;", "Class <  ?  >    clazz    =     . MissingDataSourceAndTxMgr . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" foo \"  )  )  ;", "given ( testContext . getApplicationContext (  )  )  . willReturn ( ctx )  ;", "assertExceptionContains (  \" supply   at   least   a   DataSource   or   PlatformTransactionManager \"  )  ;", "}", "METHOD_END"], "methodName": ["missingDataSourceAndTxMgr"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    SqlScriptsTestExecutionListenerTests . MissingValueAndScriptsAndStatementsAtClassLevel . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" foo \"  )  )  ;", "assertExceptionContains (  (  ( clazz . getSimpleName (  )  )     +     \"  . sql \"  )  )  ;", "}", "METHOD_END"], "methodName": ["missingValueAndScriptsAndStatementsAtClassLevel"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    SqlScriptsTestExecutionListenerTests . MissingValueAndScriptsAndStatementsAtMethodLevel . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" foo \"  )  )  ;", "assertExceptionContains (  (  (  ( clazz . getSimpleName (  )  )     +     \"  . foo \"  )     +     \"  . sql \"  )  )  ;", "}", "METHOD_END"], "methodName": ["missingValueAndScriptsAndStatementsAtMethodLevel"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    SqlScriptsTestExecutionListenerTests . ValueAndScriptsDeclared . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" foo \"  )  )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( either ( containsString (  \" attribute    ' value '    and   its   alias    ' scripts '  \"  )  )  . or ( containsString (  \" attribute    ' scripts '    and   its   alias    ' value '  \"  )  )  )  ;", "exception . expectMessage ( either ( containsString (  \" values   of    [  { foo }  ]    and    [  { bar }  ]  \"  )  )  . or ( containsString (  \" values   of    [  { bar }  ]    and    [  { foo }  ]  \"  )  )  )  ;", "exception . expectMessage ( containsString (  \" but   only   one   is   permitted \"  )  )  ;", "listener . beforeTestMethod ( testContext )  ;", "}", "METHOD_END"], "methodName": ["valueAndScriptsDeclared"], "fileName": "org.springframework.test.context.jdbc.SqlScriptsTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  \" test 0  1  \"  . equals ( testName . getMethodName (  )  )  )     {", "try    {", "assertNumUsers (  9  9  )  ;", "fail (  \" Should   throw   a   BadSqlGrammarException   after   test 0  1  ,    assuming    ' drop - schema . sql '    was   executed \"  )  ;", "}    catch    ( BadSqlGrammarException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.jdbc.TransactionalAfterTestMethodSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.TransactionalAfterTestMethodSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["test01"], "fileName": "org.springframework.test.context.jdbc.TransactionalAfterTestMethodSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  2  )  ;", "}", "METHOD_END"], "methodName": ["test02"], "fileName": "org.springframework.test.context.jdbc.TransactionalAfterTestMethodSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.TransactionalInlinedStatementsSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "return   JdbcTestUtils . countRowsInTable ( this . jdbcTemplate ,    tableName )  ;", "}", "METHOD_END"], "methodName": ["countRowsInTable"], "fileName": "org.springframework.test.context.jdbc.TransactionalInlinedStatementsSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.jdbc.TransactionalInlinedStatementsSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["test01_classLevelScripts"], "fileName": "org.springframework.test.context.jdbc.TransactionalInlinedStatementsSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  3  )  ;", "}", "METHOD_END"], "methodName": ["test02_methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.TransactionalInlinedStatementsSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table .  \"  ,    expected ,    countRowsInTable (  \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.jdbc.TransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "return   JdbcTestUtils . countRowsInTable ( this . jdbcTemplate ,    tableName )  ;", "}", "METHOD_END"], "methodName": ["countRowsInTable"], "fileName": "org.springframework.test.context.jdbc.TransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.jdbc.TransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["test01_classLevelScripts"], "fileName": "org.springframework.test.context.jdbc.TransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  2  )  ;", "}", "METHOD_END"], "methodName": ["test02_methodLevelScripts"], "fileName": "org.springframework.test.context.jdbc.TransactionalSqlScriptsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( context . getElement (  )  . isPresent (  )  ,     \" No   AnnotatedElement \"  )  ;", "AnnotatedElement   element    =    context . getElement (  )  . get (  )  ;", "Optional < A >    annotation    =     . findMergedAnnotation ( element ,    annotationType )  ;", "if    (  !  ( annotation . isPresent (  )  )  )     {", "String   reason    =    String . format (  \"  % s   is   enabled   since    @  % s   is   not   present \"  ,    element ,    annotationType . getSimpleName (  )  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( reason )  ;", "}", "return   ConditionEvaluationResult . enabled ( reason )  ;", "}", "String   expression    =    annotation . map ( expressionExtractor )  . map ( String :  : trim )  . filter ( StringUtils :  : hasLength )  . orElseThrow (  (  )     -  >    new   IllegalStateException ( String . format (  \" The   expression   in    @  % s   on    [  % s ]    must   not   be   blank \"  ,    annotationType . getSimpleName (  )  ,    element )  )  )  ;", "boolean   loadContext    =    loadContextExtractor . apply ( annotation . get (  )  )  ;", "boolean   evaluatedToTrue    =    evaluateExpression ( expression ,    loadContext ,    annotationType ,    context )  ;", "if    ( evaluatedToTrue )     {", "String   adjective    =     ( enabledOnTrue )     ?     \" enabled \"     :     \" disabled \"  ;", "String   reason    =    annotation . map ( reasonExtractor )  . filter ( StringUtils :  : hasText )  . orElseGet (  (  )     -  >    String . format (  \"  % s   is    % s   because    @  % s (  \\  \"  % s \\  \"  )    evaluated   to   true \"  ,    element ,    adjective ,    annotationType . getSimpleName (  )  ,    expression )  )  ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( reason )  ;", "}", "return   enabledOnTrue    ?    ConditionEvaluationResult . enabled ( reason )     :    ConditionEvaluationResult . disabled ( reason )  ;", "} else    {", "String   adjective    =     ( enabledOnTrue )     ?     \" disabled \"     :     \" enabled \"  ;", "String   reason    =    String . format (  \"  % s   is    % s   because    @  % s (  \\  \"  % s \\  \"  )    did   not   evaluate   to   true \"  ,    element ,    adjective ,    annotationType . getSimpleName (  )  ,    expression )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( reason )  ;", "}", "return   enabledOnTrue    ?    ConditionEvaluationResult . disabled ( reason )     :    ConditionEvaluationResult . enabled ( reason )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluateAnnotation"], "fileName": "org.springframework.test.context.junit.jupiter.AbstractExpressionEvaluatingCondition"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( context . getElement (  )  . isPresent (  )  ,     \" No   AnnotatedElement \"  )  ;", "AnnotatedElement   element    =    context . getElement (  )  . get (  )  ;", "GenericApplicationContext   gac    =    null ;", "ApplicationContext   applicationContext ;", "if    ( loadContext )     {", "applicationContext    =    SpringExtension . getApplicationContext ( context )  ;", "} else    {", "gac    =    new   GenericApplicationContext (  )  ;", "gac . refresh (  )  ;", "applicationContext    =    gac ;", "}", "if    (  !  ( applicationContext   instanceof   ConfigurableApplicationContext )  )     {", "if    (  . logger . isWarnEnabled (  )  )     {", "String   contextType    =    applicationContext . getClass (  )  . getName (  )  ;", ". logger . warn ( String . format (  (  \"  @  % s (  \\  \"  % s \\  \"  )    could   not   be   evaluated   on    [  % s ]    since   the   test    \"     +     \" ApplicationContext    [  % s ]    is   not   a   ConfigurableApplicationContext \"  )  ,    annotationType . getSimpleName (  )  ,    expression ,    element ,    contextType )  )  ;", "}", "return   false ;", "}", "ConfigurableBeanFactory   configurableBeanFactory    =     (  ( ConfigurableApplicationContext )     ( applicationContext )  )  . getBeanFactory (  )  ;", "BeanExpressionResolver   expressionResolver    =    configurableBeanFactory . getBeanExpressionResolver (  )  ;", "Assert . state (  ( expressionResolver    !  =    null )  ,     \" No   BeanExpressionResolver \"  )  ;", "BeanExpressionContext   beanExpressionContext    =    new   BeanExpressionContext ( configurableBeanFactory ,    null )  ;", "Object   result    =    expressionResolver . evaluate ( configurableBeanFactory . resolveEmbeddedValue ( expression )  ,    beanExpressionContext )  ;", "if    ( gac    !  =    null )     {", "gac . close (  )  ;", "}", "if    ( result   instanceof   Boolean )     {", "return    (  ( Boolean )     ( result )  )  ;", "} else", "if    ( result   instanceof   String )     {", "String   str    =     (  ( String )     ( result )  )  . trim (  )  . toLowerCase (  )  ;", "if    (  \" true \"  . equals ( str )  )     {", "return   true ;", "}", "Assert . state (  \" false \"  . equals ( str )  ,     (  )     -  >    String . format (  \"  @  % s (  \\  \"  % s \\  \"  )    on    % s   must   evaluate   to    \\  \" true \\  \"    or    \\  \" false \\  \"  ,    not    \\  \"  % s \\  \"  \"  ,    annotationType . getSimpleName (  )  ,    expression ,    element ,    result )  )  ;", "return   false ;", "} else    {", "String   message    =    String . format (  \"  @  % s (  \\  \"  % s \\  \"  )    on    % s   must   evaluate   to   a   String   or   a   Boolean ,    not    % s \"  ,    annotationType . getSimpleName (  )  ,    expression ,    element ,     ( result    !  =    null    ?    result . getClass (  )  . getName (  )     :     \" null \"  )  )  ;", "throw   new   IllegalStateException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluateExpression"], "fileName": "org.springframework.test.context.junit.jupiter.AbstractExpressionEvaluatingCondition"}, {"methodBody": ["METHOD_START", "{", "return   Optional . ofNullable ( AnnotatedElementUtils . findMergedAnnotation ( element ,    annotationType )  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotation"], "fileName": "org.springframework.test.context.junit.jupiter.AbstractExpressionEvaluatingCondition"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( applicationC    \" ApplicationCshould   have   been   injected   into   method   by   Spring \"  )  ;", "assertEquals ( dilbert ,    applicationCgetBean (  \" dilbert \"  ,    Person . class )  )  ;", "}", "METHOD_END"], "methodName": ["applicationContextInjected"], "fileName": "org.springframework.test.context.junit.jupiter.ComposedSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dilbert ,     \" Person   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dilbert \"  ,    dilbert . getName (  )  ,     \" Person ' s   name \"  )  ;", "assertEquals (  2  ,    people . size (  )  ,     \" Number   of   Person   objects   in    \"  )  ;", "}", "METHOD_END"], "methodName": ["springBeansInjected"], "fileName": "org.springframework.test.context.junit.jupiter.ComposedSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   exception    =    assertThrows ( IllegalStateException . class ,     (  )     -  >    condition . evaluateExecutionCondition ( buildExtensionContext ( methodName )  )  )  ;", "assertThat ( exception . getMessage (  )  ,    containsString (  \" must   not   be   blank \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertExpressionIsBlank"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( result )  ;", "if    ( disabled )     {", "assertTrue ( result . is (  )  )  ;", "} else    {", "assertFalse ( result . is (  )  )  ;", "}", "Optional < String >    reason    =    result . getReason (  )  ;", "assertTrue ( reason . isPresent (  )  )  ;", "assertThat ( reason . get (  )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertResult"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    DisabledIfConditionTests . SpringTestCase . class ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,    methodName )  ;", "Store   store    =    mock ( Store . class )  ;", "when ( store . getOrComputeIfAbsent ( any (  )  ,    any (  )  ,    any (  )  )  )  . thenReturn ( new   TestContextManager ( testClass )  )  ;", "ExtensionContext   extensionContext    =    mock ( ExtensionContext . class )  ;", "when ( extensionContext . getTestClass (  )  )  . thenReturn ( Optional . of ( testClass )  )  ;", "when ( extensionContext . getElement (  )  )  . thenReturn ( Optional . of ( method )  )  ;", "when ( extensionContext . getStore ( any (  )  )  )  . thenReturn ( store )  ;", "return   extensionContext ;", "}", "METHOD_END"], "methodName": ["buildExtensionContext"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "assertAll (  (  )     -  >    assertExpressionIsBlank (  \" emptyExpression \"  )  ,     (  )     -  >    assertExpressionIsBlank (  \" blankExpression \"  )  )  ;", "}", "METHOD_END"], "methodName": ["disabledByEmptyExpression"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "assertResult ( condition . evaluateExecutionCondition ( buildExtensionContext (  \" customReason \"  )  )  ,    true ,    is ( equalTo (  \" Because .  .  .     4  2  !  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["disabledWithCustomReason"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "assertResult ( condition . evaluateExecutionCondition ( buildExtensionContext (  \" defaultReason \"  )  )  ,    true ,    CoreMatchers . endsWith (  \" defaultReason (  )    is   disabled   because    @ DisabledIf (  \\  \"  #  {  1     +     1    eq    2  }  \\  \"  )    evaluated   to   true \"  )  )  ;", "}", "METHOD_END"], "methodName": ["disabledWithDefaultReason"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" nonBooleanOrStringExpression \"  ;", "IllegalStateException   exception    =    assertThrows ( IllegalStateException . class ,     (  )     -  >    condition . evaluateExecutionCondition ( buildExtensionContext ( methodName )  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,    methodName )  ;", "assertThat ( exception . getMessage (  )  ,    is ( equalTo (  (  (  \"  @  (  \\  \"  #  {  6     *     7  }  \\  \"  )    on    \"     +    method )     +     \"    must   evaluate   to   a   String   or   a   Boolean ,    not   Integer \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidExpressionEvaluationType"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "assertResult ( condition . evaluateExecutionCondition ( buildExtensionContext (  \" missingDisabledIf \"  )  )  ,    false ,    CoreMatchers . endsWith (  \" missingDisabledIf (  )    is   enabled   since    @ DisabledIf   is   not   present \"  )  )  ;", "}", "METHOD_END"], "methodName": ["missingDisabledIf"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "assertResult ( condition . evaluateExecutionCondition ( buildExtensionContext (  \" neverDisabledWithDefaultReason \"  )  )  ,    false ,    CoreMatchers . endsWith (  \" neverDisabledWithDefaultReason (  )    is   enabled   because    @ DisabledIf (  \\  \" false \\  \"  )    did   not   evaluate   to   true \"  )  )  ;", "}", "METHOD_END"], "methodName": ["notDisabledWithDefaultReason"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" stringExpressionThatIsNeitherTrueNorFalse \"  ;", "IllegalStateException   exception    =    assertThrows ( IllegalStateException . class ,     (  )     -  >    condition . evaluateExecutionCondition ( buildExtensionContext ( methodName )  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,    methodName )  ;", "assertThat ( exception . getMessage (  )  ,    is ( equalTo (  (  (  \"  @  (  \\  \"  #  {  \\  ' enigma \\  '  }  \\  \"  )    on    \"     +    method )     +     \"    must   evaluate   to    \\  \" true \\  \"    or    \\  \" false \\  \"  ,    not    \\  \" enigma \\  \"  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["unsupportedStringEvaluationValue"], "fileName": "org.springframework.test.context.junit.jupiter.DisabledIfConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   FailingBeforeAndAfterMethodsSpringExtensionTests . testClasses (  )  . map (  (    clazz )     -  >    dynamicTest ( clazz . getSimpleName (  )  ,     (  )     -  >    runTestAndAssertCounters ( clazz )  )  )  ;", "}", "METHOD_END"], "methodName": ["generateTests"], "fileName": "org.springframework.test.context.junit.jupiter.FailingBeforeAndAfterMethodsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( testClass    =  =     ( FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingBeforeTestClassTestCase . class )  )     |  |     ( testClass    =  =     ( FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingAfterTestClassTestCase . class )  )  )     {", "return    0  ;", "}", "return    1  ;", "}", "METHOD_END"], "methodName": ["getExpectedFailedCount"], "fileName": "org.springframework.test.context.junit.jupiter.FailingBeforeAndAfterMethodsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "return   testClass    =  =     ( FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingBeforeTestClassTestCase . class )     ?     0     :     1  ;", "}", "METHOD_END"], "methodName": ["getExpectedStartedCount"], "fileName": "org.springframework.test.context.junit.jupiter.FailingBeforeAndAfterMethodsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "return   testClass    =  =     ( FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingAfterTestClassTestCase . class )     ?     1     :     0  ;", "}", "METHOD_END"], "methodName": ["getExpectedSucceededCount"], "fileName": "org.springframework.test.context.junit.jupiter.FailingBeforeAndAfterMethodsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "Launcher   launcher    =    LauncherFactory . create (  )  ;", ". ExceptionTrackingListener   listener    =    new    . ExceptionTrackingListener (  )  ;", "launcher . registerTestExecutionListeners ( listener )  ;", "launcher . execute ( request (  )  . selectors ( selectClass ( testClass )  )  . build (  )  )  ;", "TestExecutionSummary   summary    =    listener . getSummary (  )  ;", "String   name    =    testClass . getSimpleName (  )  ;", "int   expectedStartedCount    =    getExpectedStartedCount ( testClass )  ;", "int   expectedSucceededCount    =    getExpectedSucceededCount ( testClass )  ;", "int   expectedFailedCount    =    getExpectedFailedCount ( testClass )  ;", "assertAll (  (  )     -  >    assertEquals (  1  ,    summary . getTestsFoundCount (  )  ,     (  )     -  >    name    +     \"  :    tests   found \"  )  ,     (  )     -  >    assertEquals (  0  ,    summary . getTestsSkippedCount (  )  ,     (  )     -  >    name    +     \"  :    tests   skipped \"  )  ,     (  )     -  >    assertEquals (  0  ,    summary . getTestsAbortedCount (  )  ,     (  )     -  >    name    +     \"  :    tests   aborted \"  )  ,     (  )     -  >    assertEquals ( expectedStartedCount ,    summary . getTestsStartedCount (  )  ,     (  )     -  >    name    +     \"  :    tests   started \"  )  ,     (  )     -  >    assertEquals ( expectedSucceededCount ,    summary . getTestsSucceededCount (  )  ,     (  )     -  >    name    +     \"  :    tests   succeeded \"  )  ,     (  )     -  >    assertEquals ( expectedFailedCount ,    summary . getTestsFailedCount (  )  ,     (  )     -  >    name    +     \"  :    tests   failed \"  )  )  ;", "if    ( expectedFailedCount    >     0  )     {", "assertEquals (  1  ,    listener . exceptions . size (  )  ,     \" exceptions   expected \"  )  ;", "Throwable   exception    =    listener . exceptions . get (  0  )  ;", "if    (  !  ( exception   instanceof   AssertionFailedError )  )     {", "throw   new   AssertionFailedError (  (  (  ( exception . getClass (  )  . getName (  )  )     +     \"    is   not   an   instance   of    \"  )     +     ( AssertionFailedError . class . getName (  )  )  )  ,    exception )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["runTestAndAssertCounters"], "fileName": "org.springframework.test.context.junit.jupiter.FailingBeforeAndAfterMethodsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "return   Stream . of ( FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingBeforeTestClassTestCase . class ,    FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingAfterTestClassTestCase . class ,    FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingPrepareTestInstanceTestCase . class ,    FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingBeforeTestMethodTestCase . class ,    FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingBeforeTestExecutionTestCase . class ,    FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingAfterTestExecutionTestCase . class ,    FailingBeforeAndAfterMethodsSpringExtensionTests . AlwaysFailingAfterTestMethodTestCase . class ,    FailingBeforeAndAfterMethodsSpringExtensionTests . FailingBeforeTransactionTestCase . class ,    FailingBeforeAndAfterMethodsSpringExtensionTests . FailingAfterTransactionTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["testClasses"], "fileName": "org.springframework.test.context.junit.jupiter.FailingBeforeAndAfterMethodsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "Executable   executable    =    parameter . getDeclaringExecutable (  )  ;", "if    (  (  ( executable   instanceof   Constructor )     &  &     ( ClassUtils . isInnerClass ( executable . getDeclaringClass (  )  )  )  )     &  &     (  ( executable . getParameterAnnotations (  )  . length )     =  =     (  ( executable . getParameterCount (  )  )     -     1  )  )  )     {", "return   index    =  =     0     ?     . EMPTY _ ANNOTATED _ ELEMENT    :    executable . getParameters (  )  [  ( index    -     1  )  ]  ;", "}", "return   parameter ;", "}", "METHOD_END"], "methodName": ["getEffectiveAnnotatedParameter"], "fileName": "org.springframework.test.context.junit.jupiter.ParameterAutowireUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ApplicationContext . class . isAssignableFrom ( parameter . getType (  )  )  )     {", "return   true ;", "}", "AnnotatedElement   annotatedParameter    =     . getEffectiveAnnotatedParameter ( parameter ,    parameterIndex )  ;", "return    (  ( AnnotatedElementUtils . hasAnnotation ( annotatedParameter ,    Autowired . class )  )     |  |     ( AnnotatedElementUtils . hasAnnotation ( annotatedParameter ,    Qualifier . class )  )  )     |  |     ( AnnotatedElementUtils . hasAnnotation ( annotatedParameter ,    Value . class )  )  ;", "}", "METHOD_END"], "methodName": ["isAutowirable"], "fileName": "org.springframework.test.context.junit.jupiter.ParameterAutowireUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElement   annotatedParameter    =    ParameterAutowireUtils . getEffectiveAnnotatedParameter ( parameter ,    parameterIndex )  ;", "Autowired   autowired    =    AnnotatedElementUtils . findMergedAnnotation ( annotatedParameter ,    Autowired . class )  ;", "boolean   required    =     ( autowired    =  =    null )     |  |     ( autowired . required (  )  )  ;", "MethodParameter   methodParameter    =    SynthesizingMethodParameter . forParameter ( parameter )  ;", "DependencyDescriptor   descriptor    =    new   DependencyDescriptor ( methodParameter ,    required )  ;", "descriptor . setContainingClass ( containingClass )  ;", "return   applicationContext . getAutowireCapableBeanFactory (  )  . resolveDependency ( descriptor ,    null )  ;", "}", "METHOD_END"], "methodName": ["resolveDependency"], "fileName": "org.springframework.test.context.junit.jupiter.ParameterAutowireUtils"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( applicationC    \" ApplicationCshould   have   been   injected   by   Spring \"  )  ;", "assertEquals ( this . dilbert ,    applicationCgetBean (  \" dilbert \"  ,    Person . class )  )  ;", "}", "METHOD_END"], "methodName": ["applicationContextInjectedIntoMethod"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( this . dilbert ,     \" Dilbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dilbert \"  ,    this . dilbert . getName (  )  ,     \" Person ' s   name \"  )  ;", "assertEquals (  2  ,    this . people . size (  )  ,     \" Number   of   people   in    \"  )  ;", "assertNotNull ( this . dog ,     \" Dogbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dogbert \"  ,    this . dog . getName (  )  ,     \" Dog ' s   name \"  )  ;", "assertNotNull ( this . cat ,     \" Catbert   should   have   been    @ Autowired   by   Spring   as   the    @ Primary   cat \"  )  ;", "assertEquals (  \" Catbert \"  ,    this . cat . getName (  )  ,     \" Primary   cat ' s   name \"  )  ;", "assertEquals (  2  ,    this . cats . size (  )  ,     \" Number   of   cats   in    \"  )  ;", "assertNotNull ( this . enigma ,     \" Enigma   should   have   been   injected   via    @ Value   by   Spring \"  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    this . enigma ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFields"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dog ,     \" Optional   dog   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertTrue ( dog . isPresent (  )  ,     \" Value   of   Optional   should   be    ' present '  \"  )  ;", "assertEquals (  \" Dogbert \"  ,    dog . get (  )  . getName (  )  ,     \" Dog ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterAsJavaUtilOptional"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( primaryCat ,     \" Primary   cat   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Catbert \"  ,    primaryCat . getName (  )  ,     \" Primary   cat ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterByTypeForPrimaryBean"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dog ,     \" Dogbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dogbert \"  ,    dog . getName (  )  ,     \" Dog ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterByTypeForSingleBean"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( peopleParam ,     \" list   of   people   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  2  ,    peopleParam . size (  )  ,     \" Number   of   people   in    \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterOfList"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( number ,     \" Optional   number   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertFalse ( number . isPresent (  )  ,     \" Value   of   Optional   number   should   not   be    ' present '  \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterThatDoesNotExistAsJavaUtilOptional"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( number ,     \" Non - required   number   should   have   been    @ Autowired   as    ' null '    by   Spring \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterThatDoesNotExistButIsNotRequired"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( person ,     \" Wally   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Wally \"  ,    person . getName (  )  ,     \" Person ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterWithExplicitQualifier"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wally ,     \" Wally   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Wally \"  ,    wally . getName (  )  ,     \" Person ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterWithImplicitQualifierBasedOnParameterName"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( applicationC    \" GenericApplicationCshould   have   been   injected   by   Spring \"  )  ;", "assertEquals ( this . dilbert ,    applicationCgetBean (  \" dilbert \"  ,    Person . class )  )  ;", "}", "METHOD_END"], "methodName": ["genericApplicationContextInjectedIntoMethod"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( testInfo ,     \" TestInfo   should   have   been   injected   by   JUnit \"  )  ;", "assertNotNull ( testReporter ,     \" TestReporter   should   have   been   injected   by   JUnit \"  )  ;", "assertNotNull (  ,     \" ApplicationContext   should   have   been   injected   by   Spring \"  )  ;", "assertNotNull ( kittyCat ,     \" Cat   should   have   been    @ Autowired   by   Spring \"  )  ;", "}", "METHOD_END"], "methodName": ["junitAndSpringMethodInjectionCombined"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( defaultValue ,     \" Default   value   should   have   been   injected   via    @ Value   by   Spring \"  )  ;", "assertEquals ( false ,    defaultValue ,     \" default   value \"  )  ;", "}", "METHOD_END"], "methodName": ["valueParameterFromDefaultValueForPropertyPlaceholder"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( enigmaParam ,     \" Enigma   should   have   been   injected   via    @ Value   by   Spring \"  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    enigmaParam ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["valueParameterFromPropertyPlaceholder"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( name ,     \" Dilbert ' s   name   should   have   been   injected   via   SpEL   expression   in    @ Value   by   Spring \"  )  ;", "assertEquals (  \" Dilbert \"  ,    name ,     \" name   from   SpEL   expression \"  )  ;", "}", "METHOD_END"], "methodName": ["valueParameterFromSpelExpression"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( hello ,     \" hello   should   have   been   injected   via   SpEL   expression   in    @ Value   by   Spring \"  )  ;", "assertEquals (  \" Hello    4  2  \"  ,    hello ,     \" hello   from   SpEL   expression \"  )  ;", "}", "METHOD_END"], "methodName": ["valueParameterFromSpelExpressionWithNestedPropertyPlaceholder"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  9  9  ,    num )  ;", "}", "METHOD_END"], "methodName": ["valueParameterWithPrimitiveType"], "fileName": "org.springframework.test.context.junit.jupiter.RegisterExtensionSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "return   SpringExtension . getTestContextManager ( context )  . getTestContext (  )  . getApplicationContext (  )  ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtension"}, {"methodBody": ["METHOD_START", "{", "return   context . getRoot (  )  . getStore ( SpringExtension . NAMESPACE )  ;", "}", "METHOD_END"], "methodName": ["getStore"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtension"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( context ,     \" ExtensionContext   must   not   be   null \"  )  ;", "Class <  ?  >    testClass    =    context . getRequiredTestClass (  )  ;", "Store   store    =     . getStore ( context )  ;", "return   store . getOrComputeIfAbsent ( testClass ,    TestContextManager :  : new ,    TestContextManager . class )  ;", "}", "METHOD_END"], "methodName": ["getTestContextManager"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtension"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( catName ,    context . getBean ( beanName ,    Cat . class )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["cats"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionParameterizedTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( dogName ,    context . getBean ( beanName ,    Dog . class )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["dogs"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionParameterizedTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( people . stream (  )  . map ( Person :  : getName )  . filter (  (    str )     -  >    name . equals ( str )  )  . findFirst (  )  . isPresent (  )  )  ;", "}", "METHOD_END"], "methodName": ["people"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionParameterizedTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( applicationC    \" ApplicationCshould   have   been   injected   by   Spring \"  )  ;", "assertEquals ( this . dilbert ,    applicationCgetBean (  \" dilbert \"  ,    Person . class )  )  ;", "}", "METHOD_END"], "methodName": ["applicationContextInjectedIntoMethod"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( this . dilbert ,     \" Dilbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dilbert \"  ,    this . dilbert . getName (  )  ,     \" Person ' s   name \"  )  ;", "assertEquals (  2  ,    this . people . size (  )  ,     \" Number   of   people   in    \"  )  ;", "assertNotNull ( this . dog ,     \" Dogbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dogbert \"  ,    this . dog . getName (  )  ,     \" Dog ' s   name \"  )  ;", "assertNotNull ( this . cat ,     \" Catbert   should   have   been    @ Autowired   by   Spring   as   the    @ Primary   cat \"  )  ;", "assertEquals (  \" Catbert \"  ,    this . cat . getName (  )  ,     \" Primary   cat ' s   name \"  )  ;", "assertEquals (  2  ,    this . cats . size (  )  ,     \" Number   of   cats   in    \"  )  ;", "assertNotNull ( this . enigma ,     \" Enigma   should   have   been   injected   via    @ Value   by   Spring \"  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    this . enigma ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFields"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dog ,     \" Optional   dog   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertTrue ( dog . isPresent (  )  ,     \" Value   of   Optional   should   be    ' present '  \"  )  ;", "assertEquals (  \" Dogbert \"  ,    dog . get (  )  . getName (  )  ,     \" Dog ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterAsJavaUtilOptional"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( primaryCat ,     \" Primary   cat   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Catbert \"  ,    primaryCat . getName (  )  ,     \" Primary   cat ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterByTypeForPrimaryBean"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dog ,     \" Dogbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dogbert \"  ,    dog . getName (  )  ,     \" Dog ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterByTypeForSingleBean"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( peopleParam ,     \" list   of   people   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  2  ,    peopleParam . size (  )  ,     \" Number   of   people   in    \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterOfList"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( number ,     \" Optional   number   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertFalse ( number . isPresent (  )  ,     \" Value   of   Optional   number   should   not   be    ' present '  \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterThatDoesNotExistAsJavaUtilOptional"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( number ,     \" Non - required   number   should   have   been    @ Autowired   as    ' null '    by   Spring \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterThatDoesNotExistButIsNotRequired"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( person ,     \" Wally   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Wally \"  ,    person . getName (  )  ,     \" Person ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterWithExplicitQualifier"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wally ,     \" Wally   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Wally \"  ,    wally . getName (  )  ,     \" Person ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterWithImplicitQualifierBasedOnParameterName"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( applicationC    \" GenericApplicationCshould   have   been   injected   by   Spring \"  )  ;", "assertEquals ( this . dilbert ,    applicationCgetBean (  \" dilbert \"  ,    Person . class )  )  ;", "}", "METHOD_END"], "methodName": ["genericApplicationContextInjectedIntoMethod"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( testInfo ,     \" TestInfo   should   have   been   injected   by   JUnit \"  )  ;", "assertNotNull ( testReporter ,     \" TestReporter   should   have   been   injected   by   JUnit \"  )  ;", "assertNotNull (  ,     \" ApplicationContext   should   have   been   injected   by   Spring \"  )  ;", "assertNotNull ( kittyCat ,     \" Cat   should   have   been    @ Autowired   by   Spring \"  )  ;", "}", "METHOD_END"], "methodName": ["junitAndSpringMethodInjectionCombined"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( defaultValue ,     \" Default   value   should   have   been   injected   via    @ Value   by   Spring \"  )  ;", "assertEquals ( false ,    defaultValue ,     \" default   value \"  )  ;", "}", "METHOD_END"], "methodName": ["valueParameterFromDefaultValueForPropertyPlaceholder"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( enigmaParam ,     \" Enigma   should   have   been   injected   via    @ Value   by   Spring \"  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    enigmaParam ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["valueParameterFromPropertyPlaceholder"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( name ,     \" Dilbert ' s   name   should   have   been   injected   via   SpEL   expression   in    @ Value   by   Spring \"  )  ;", "assertEquals (  \" Dilbert \"  ,    name ,     \" name   from   SpEL   expression \"  )  ;", "}", "METHOD_END"], "methodName": ["valueParameterFromSpelExpression"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( hello ,     \" hello   should   have   been   injected   via   SpEL   expression   in    @ Value   by   Spring \"  )  ;", "assertEquals (  \" Hello    4  2  \"  ,    hello ,     \" hello   from   SpEL   expression \"  )  ;", "}", "METHOD_END"], "methodName": ["valueParameterFromSpelExpressionWithNestedPropertyPlaceholder"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  9  9  ,    num )  ;", "}", "METHOD_END"], "methodName": ["valueParameterWithPrimitiveType"], "fileName": "org.springframework.test.context.junit.jupiter.SpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( applicationC    \" ApplicationCshould   have   been   injected   by   Spring \"  )  ;", "assertEquals ( this . dilbert ,    applicationCgetBean (  \" dilbert \"  ,    Person . class )  )  ;", "}", "METHOD_END"], "methodName": ["applicationContextInjected"], "fileName": "org.springframework.test.context.junit.jupiter.SpringJUnitJupiterAutowiredConstructorInjectionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( this . dilbert ,     \" Dilbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dilbert \"  ,    this . dilbert . getName (  )  ,     \" Person ' s   name \"  )  ;", "assertNotNull ( this . dog ,     \" Dogbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dogbert \"  ,    this . dog . getName (  )  ,     \" Dog ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["beansInjected"], "fileName": "org.springframework.test.context.junit.jupiter.SpringJUnitJupiterAutowiredConstructorInjectionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( this . enigma ,     \" Enigma   should   have   been   injected   via    @ Value   by   Spring \"  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    this . enigma ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderInjected"], "fileName": "org.springframework.test.context.junit.jupiter.SpringJUnitJupiterAutowiredConstructorInjectionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( applicationC    \" ApplicationCshould   have   been   injected   by   Spring \"  )  ;", "assertEquals ( this . dilbert ,    applicationCgetBean (  \" dilbert \"  ,    Person . class )  )  ;", "}", "METHOD_END"], "methodName": ["applicationContextInjected"], "fileName": "org.springframework.test.context.junit.jupiter.SpringJUnitJupiterConstructorInjectionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( this . dilbert ,     \" Dilbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dilbert \"  ,    this . dilbert . getName (  )  ,     \" Person ' s   name \"  )  ;", "assertNotNull ( this . dog ,     \" Dogbert   should   have   been    @ Autowired   by   Spring \"  )  ;", "assertEquals (  \" Dogbert \"  ,    this . dog . getName (  )  ,     \" Dog ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["beansInjected"], "fileName": "org.springframework.test.context.junit.jupiter.SpringJUnitJupiterConstructorInjectionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( this . enigma ,     \" Enigma   should   have   been   injected   via    @ Value   by   Spring \"  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    this . enigma ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderInjected"], "fileName": "org.springframework.test.context.junit.jupiter.SpringJUnitJupiterConstructorInjectionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( this . testInfo ,     \" TestInfo   should   have   been   injected   by   JUnit \"  )  ;", "}", "METHOD_END"], "methodName": ["testInfoInjected"], "fileName": "org.springframework.test.context.junit.jupiter.SpringJUnitJupiterConstructorInjectionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Cat (  \" Catbert \"  )  ;", "}", "METHOD_END"], "methodName": ["catbert"], "fileName": "org.springframework.test.context.junit.jupiter.TestConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   Person (  \" Dilbert \"  )  ;", "}", "METHOD_END"], "methodName": ["dilbert"], "fileName": "org.springframework.test.context.junit.jupiter.TestConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   Dog (  \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["dogbert"], "fileName": "org.springframework.test.context.junit.jupiter.TestConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   Cat (  \" Garfield \"  )  ;", "}", "METHOD_END"], "methodName": ["garfield"], "fileName": "org.springframework.test.context.junit.jupiter.TestConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   Person (  \" Wally \"  )  ;", "}", "METHOD_END"], "methodName": ["wally"], "fileName": "org.springframework.test.context.junit.jupiter.TestConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.test.context.junit.jupiter.comics.Character"}, {"methodBody": ["METHOD_START", "{", "GenericComicCharactersInterfaceDefaultMethodsTests . assertNotNull ( character ,     \" Character   should   have   been    @ Autowired   by   Spring \"  )  ;", "GenericComicCharactersInterfaceDefaultMethodsTests . assertEquals ( getExpectedName (  )  ,    character . getName (  )  ,     \" character ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterWithGenericBean"], "fileName": "org.springframework.test.context.junit.jupiter.defaultmethods.GenericComicCharactersInterfaceDefaultMethodsTests"}, {"methodBody": ["METHOD_START", "{", "GenericComicCharactersInterfaceDefaultMethodsTests . assertEquals ( getExpectedNumCharacters (  )  ,    characters . size (  )  ,     \" Number   of   characters   in   context \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterWithParameterizedList"], "fileName": "org.springframework.test.context.junit.jupiter.defaultmethods.GenericComicCharactersInterfaceDefaultMethodsTests"}, {"methodBody": ["METHOD_START", "{", "GenericComicCharactersTests . assertNotNull ( this . character ,     \" Character   should   have   been    @ Autowired   by   Spring \"  )  ;", "GenericComicCharactersTests . assertEquals ( getExpectedName (  )  ,    character . getName (  )  ,     \" character ' s   name \"  )  ;", "GenericComicCharactersTests . assertEquals ( getExpectedNumCharacters (  )  ,    this . characters . size (  )  ,     \" Number   of   characters   in   context \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFields"], "fileName": "org.springframework.test.context.junit.jupiter.generics.GenericComicCharactersTests"}, {"methodBody": ["METHOD_START", "{", "GenericComicCharactersTests . assertNotNull ( character ,     \" Character   should   have   been    @ Autowired   by   Spring \"  )  ;", "GenericComicCharactersTests . assertEquals ( getExpectedName (  )  ,    character . getName (  )  ,     \" character ' s   name \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiredParameterByTypeForSingleGenericBean"], "fileName": "org.springframework.test.context.junit.jupiter.generics.GenericComicCharactersTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["topLevelTest"], "fileName": "org.springframework.test.context.junit.jupiter.nested.NestedTestsWithConstructorInjectionWithSpringAndJUnitJupiterTests"}, {"methodBody": ["METHOD_START", "{", "Assertions . assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["topLevelTest"], "fileName": "org.springframework.test.context.junit.jupiter.nested.NestedTestsWithSpringAndJUnitJupiterTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / person /  4  2  \"  )  . accept ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . name \"  ,    is (  \" Dilbert \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPerson42"], "fileName": "org.springframework.test.context.junit.jupiter.web.MultipleWebRequestsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / person /  9  9  \"  )  . accept ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . name \"  ,    is (  \" Wally \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPerson99"], "fileName": "org.springframework.test.context.junit.jupiter.web.MultipleWebRequestsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( wac )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . alwaysExpect ( MockMvcResultMatchers . content (  )  . contentTypeCompatibleWith ( APPLICATION _ JSON )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setUpMockMvc"], "fileName": "org.springframework.test.context.junit.jupiter.web.MultipleWebRequestsSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "if    ( id    =  =     4  2  )     {", "return   new    (  \" Dilbert \"  )  ;", "}", "return   new    (  \" Wally \"  )  ;", "}", "METHOD_END"], "methodName": ["getPerson"], "fileName": "org.springframework.test.context.junit.jupiter.web.PersonController"}, {"methodBody": ["METHOD_START", "{", "return   new   PersonController (  )  ;", "}", "METHOD_END"], "methodName": ["personController"], "fileName": "org.springframework.test.context.junit.jupiter.web.WebConfig"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . webAppContextSetup ( wac )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person /  4  2  \"  )  . accept ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . name \"  ,    is (  \" Dilbert \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["springMvcTest"], "fileName": "org.springframework.test.context.junit.jupiter.web.WebSpringExtensionTests"}, {"methodBody": ["METHOD_START", "{", "return   JdbcTestUtils . countRowsInTable ( this . jdbcTemplate ,    tableName )  ;", "}", "METHOD_END"], "methodName": ["countRowsInTable"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   JdbcTestUtils . countRowsInTableWhere ( this . jdbcTemplate ,    tableName ,    whereClause )  ;", "}", "METHOD_END"], "methodName": ["countRowsInTableWhere"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   JdbcTestUtils . deleteFromTableWhere ( jdbcTemplate ,    tableName ,    whereClause ,    args )  ;", "}", "METHOD_END"], "methodName": ["deleteFromTableWhere"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   JdbcTestUtils . deleteFromTables ( this . jdbcTemplate ,    names )  ;", "}", "METHOD_END"], "methodName": ["deleteFromTables"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "JdbcTestUtils . dropTables ( this . jdbcTemplate ,    names )  ;", "}", "METHOD_END"], "methodName": ["dropTables"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "DataSource   ds    =    this . jdbcTemplate . getDataSource (  )  ;", "Assert . state (  ( ds    !  =    null )  ,     \" No   DataSource   set \"  )  ;", "Assert . state (  (  ( this . applicationContext )     !  =    null )  ,     \" No   ApplicationContext   set \"  )  ;", "Resource   resource    =    this . applicationContext . getResource ( sqlResourcePath )  ;", "new   jdbc . datasource . init . ResourceDatabasePopulator ( continueOnError ,    false ,    this . sqlScriptEncoding ,    resource )  . execute ( ds )  ;", "}", "METHOD_END"], "methodName": ["executeSqlScript"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate . setDataSource ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . sqlScriptEncoding    =    sqlScriptEncoding ;", "}", "METHOD_END"], "methodName": ["setSqlScriptEncoding"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" INSERT   INTO   person   VALUES (  ?  )  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["addPerson"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" DELETE   FROM   person \"  )  ;", "}", "METHOD_END"], "methodName": ["clearPersonTable"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . queryForObject (  \" SELECT   COUNT (  0  )    FROM   person \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["countRowsInPersonTable"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" DELETE   FROM   person   WHERE   name =  ?  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["deletePerson"], "fileName": "org.springframework.test.context.junit4.AbstractTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "assertShouldBeInTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["after"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,     3  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( BeforeAndAfterTransactionAnnotationTests . jdbcTemplate )  )  ;", "assertEquals (  \" Verifying   the   total   number   of   calls   to   beforeTransaction (  )  .  \"  ,     2  ,    BeforeAndAfterTransactionAnnotationTests . numBeforeTransactionCalls )  ;", "assertEquals (  \" Verifying   the   total   number   of   calls   to   afterTransaction (  )  .  \"  ,     2  ,    BeforeAndAfterTransactionAnnotationTests . numAfterTransactionCalls )  ;", "}", "METHOD_END"], "methodName": ["afterClass"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "this . inTransaction    =    false ;", "(  . numAfterTransactionCalls )  +  +  ;", "assertEquals (  \" Deleting   yoda \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . deletePerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . YODA )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   after   a   transactional   test   method .  \"  ,     0  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "boolean   shouldBeInTransaction    =     !  ( testName . getMethodName (  )  . equals (  \" nonTransactionalMethod \"  )  )  ;", "TransactionTestUtils . assertInTransaction ( shouldBeInTransaction )  ;", "}", "METHOD_END"], "methodName": ["assertShouldBeInTransaction"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "assertShouldBeInTransaction (  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   before   a   test   method .  \"  ,     ( this . inTransaction    ?     1     :     0  )  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["before"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "BeforeAndAfterTransactionAnnotationTests . numBeforeTransactionCalls    =     0  ;", "BeforeAndAfterTransactionAnnotationTests . numAfterTransactionCalls    =     0  ;", "}", "METHOD_END"], "methodName": ["beforeClass"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "this . inTransaction    =    true ;", "(  . numBeforeTransactionCalls )  +  +  ;", "AbstractTransactionalSpringRunnerTests . clearPersonTable (  . jdbcTemplate )  ;", "assertEquals (  \" Adding   yoda \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . YODA )  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals (  \" Adding   luke \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . LUKE )  )  ;", "assertEquals (  \" Adding   leia \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . LEIA )  )  ;", "assertEquals (  \" Adding   yoda \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . YODA )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   without   a   transaction .  \"  ,     3  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["nonTransactionalMethod"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "BeforeAndAfterTransactionAnnotationTests . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertEquals (  \" Adding   jane \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . JANE )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   within   transactionalMethod 1  (  )  .  \"  ,     2  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["transactionalMethod1"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertEquals (  \" Adding   jane \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . JANE )  )  ;", "assertEquals (  \" Adding   sue \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . SUE )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   within   transactionalMethod 2  (  )  .  \"  ,     3  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["transactionalMethod2"], "fileName": "org.springframework.test.context.junit4.BeforeAndAfterTransactionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "fail (  \" The   body   of   a   disabled   test   should   never   be   executed !  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIfProfileValueDisabled"], "fileName": "org.springframework.test.context.junit4.ClassLevelDisabledSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertEquals (  \" Deleting   bob \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . deletePerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . BOB )  )  ;", "assertEquals (  \" Adding   jane \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . JANE )  )  ;", "assertEquals (  \" Adding   sue \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . SUE )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   within   a   transaction .  \"  ,     2  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithinTransaction"], "fileName": "org.springframework.test.context.junit4.ClassLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals (  \" Adding   luke \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . LUKE )  )  ;", "assertEquals (  \" Adding   leia \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . LEIA )  )  ;", "assertEquals (  \" Adding   yoda \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . YODA )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   without   a   transaction .  \"  ,     4  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithoutTransaction"], "fileName": "org.springframework.test.context.junit4.ClassLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "ClassLevelTransactionalSpringRunnerTests . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.ClassLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,     4  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( ClassLevelTransactionalSpringRunnerTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalTestData"], "fileName": "org.springframework.test.context.junit4.ClassLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "AbstractTransactionalSpringRunnerTests . clearPersonTable ( ClassLevelTransactionalSpringRunnerTests . jdbcTemplate )  ;", "assertEquals (  \" Adding   bob \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson ( ClassLevelTransactionalSpringRunnerTests . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . BOB )  )  ;", "assertEquals (  \" Verifying   the   initial   number   of   rows   in   the   person   table .  \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( ClassLevelTransactionalSpringRunnerTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyInitialTestData"], "fileName": "org.springframework.test.context.junit4.ClassLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   super . jdbcTemplate . update (  \" INSERT   INTO   person   VALUES (  ?  )  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["addPerson"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Deleting   yoda \"  ,     1  ,    deletePerson ( ConcreteTransactionalJUnit 4 SpringContextTests . YODA )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   after   a   transactional   test   method .  \"  ,     1  ,    countRowsInPersonTable (  )  )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   before   a   transactional   test   method .  \"  ,     1  ,    countRowsInPersonTable (  )  )  ;", "assertEquals (  \" Adding   yoda \"  ,     1  ,    addPerson (  . YODA )  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   countRowsInTable (  \" person \"  )  ;", "}", "METHOD_END"], "methodName": ["countRowsInPersonTable"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   super . jdbcTemplate . update (  \" DELETE   FROM   person   WHERE   name =  ?  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["deletePerson"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertEquals (  \" Adding   jane \"  ,     1  ,    addPerson (  . JANE )  )  ;", "assertEquals (  \" Adding   sue \"  ,     1  ,    addPerson (  . SUE )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   in   modifyTestDataWithinTransaction (  )  .  \"  ,     4  ,    countRowsInPersonTable (  )  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithinTransaction"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . bar    =    bar ;", "}", "METHOD_END"], "methodName": ["setBar"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . employee    =    employee ;", "}", "METHOD_END"], "methodName": ["setEmployee"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   before   a   test   method .  \"  ,     ( TransactionTestUtils . inTransaction (  )     ?     2     :     1  )  ,    countRowsInPersonTable (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   after   a   test   method .  \"  ,     ( TransactionTestUtils . inTransaction (  )     ?     4     :     1  )  ,    countRowsInPersonTable (  )  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertNull (  \" The   nonrequiredLong   property   should   NOT   have   been   autowired .  \"  ,    this . nonrequiredLong )  ;", "assertNotNull (  \" The   pet   field   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Fido \"  ,    this . pet . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertNotNull (  \" The   employee   setter   method   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredMethods"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertNotNull (  \" The   application   context   should   have   been   set   due   to   ApplicationContextAware   semantics .  \"  ,    super . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["verifyApplicationContext"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertTrue (  \" This   test   bean   should   have   been   initialized   due   to   InitializingBean   semantics .  \"  ,    this . beanInitialized )  ;", "}", "METHOD_END"], "methodName": ["verifyBeanInitialized"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals (  (  \" The   bean   name   of   this   test   instance   should   have   been   set   to   the   fully   qualified   class   name    \"     +     \" due   to   BeanNameAware   semantics .  \"  )  ,    getClass (  )  . getName (  )  ,    this . beanName )  ;", "}", "METHOD_END"], "methodName": ["verifyBeanNameSet"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals (  \" The   foo   field   should   have   been   wired   via    @ Resource .  \"  ,     \" Foo \"  ,    this . foo )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceAnnotationWiredFields"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals (  \" The   bar   method   should   have   been   wired   via    @ Resource .  \"  ,     \" Bar \"  ,    this . bar )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceAnnotationWiredMethods"], "fileName": "org.springframework.test.context.junit4.ConcreteTransactionalJUnit4SpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["injectedBean"], "fileName": "org.springframework.test.context.junit4.ContextCustomizerSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   cat   field   should   have   been   autowired .  \"  ,    this . cat )  ;", "assertEquals (  \" Garfield \"  ,    this . cat . getName (  )  )  ;", "assertNotNull (  \" TheString   field   should   have   been   autowired .  \"  ,    thisString )  ;", "assertEquals (  \" Test   String \"  ,    thisString )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.junit4.CustomDefaultContextLoaderClassSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertEquals (  \" Deleting   bob \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . deletePerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . BOB )  )  ;", "assertEquals (  \" Adding   jane \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . JANE )  )  ;", "assertEquals (  \" Adding   sue \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . SUE )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   within   a   transaction .  \"  ,     2  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithinTransaction"], "fileName": "org.springframework.test.context.junit4.DefaultRollbackFalseRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "DefaultRollbackFalseRollbackAnnotationTransactionalTests . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.DefaultRollbackFalseRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,     2  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( DefaultRollbackFalseRollbackAnnotationTransactionalTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalTestData"], "fileName": "org.springframework.test.context.junit4.DefaultRollbackFalseRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "AbstractTransactionalSpringRunnerTests . clearPersonTable ( DefaultRollbackFalseRollbackAnnotationTransactionalTests . jdbcTemplate )  ;", "assertEquals (  \" Adding   bob \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson ( DefaultRollbackFalseRollbackAnnotationTransactionalTests . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . BOB )  )  ;", "assertEquals (  \" Verifying   the   initial   number   of   rows   in   the   person   table .  \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( DefaultRollbackFalseRollbackAnnotationTransactionalTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyInitialTestData"], "fileName": "org.springframework.test.context.junit4.DefaultRollbackFalseRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertEquals (  \" Adding   jane \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . JANE )  )  ;", "assertEquals (  \" Adding   sue \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . SUE )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   within   a   transaction .  \"  ,     3  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithinTransaction"], "fileName": "org.springframework.test.context.junit4.DefaultRollbackTrueRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "DefaultRollbackTrueRollbackAnnotationTransactionalTests . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.DefaultRollbackTrueRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,    DefaultRollbackTrueRollbackAnnotationTransactionalTests . originalNumRows ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( DefaultRollbackTrueRollbackAnnotationTransactionalTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalTestData"], "fileName": "org.springframework.test.context.junit4.DefaultRollbackTrueRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "DefaultRollbackTrueRollbackAnnotationTransactionalTests . originalNumRows    =    AbstractTransactionalSpringRunnerTests . clearPersonTable ( DefaultRollbackTrueRollbackAnnotationTransactionalTests . jdbcTemplate )  ;", "assertEquals (  \" Adding   bob \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson ( DefaultRollbackTrueRollbackAnnotationTransactionalTests . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . BOB )  )  ;", "assertEquals (  \" Verifying   the   initial   number   of   rows   in   the   person   table .  \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( DefaultRollbackTrueRollbackAnnotationTransactionalTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyInitialTestData"], "fileName": "org.springframework.test.context.junit4.DefaultRollbackTrueRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "return   new   EmbeddedDatabaseBuilder (  )  . generateUniqueName ( true )  . addScript (  \" classpath :  / org / springframework / test / jdbc / schema . sql \"  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["dataSource"], "fileName": "org.springframework.test.context.junit4.EmbeddedPersonDatabaseTestsConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   DataSourceTransactionManager ( dataSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["txMgr"], "fileName": "org.springframework.test.context.junit4.EmbeddedPersonDatabaseTestsConfig"}, {"methodBody": ["METHOD_START", "{", "EnabledAndIgnoredSpringRunnerTests . numTestsExecuted    =     0  ;", "System . setProperty ( EnabledAndIgnoredSpringRunnerTests . NAME ,    EnabledAndIgnoredSpringRunnerTests . VALUE )  ;", "}", "METHOD_END"], "methodName": ["setProfileValue"], "fileName": "org.springframework.test.context.junit4.EnabledAndIgnoredSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "( EnabledAndIgnoredSpringRunnerTests . numTestsExecuted )  +  +  ;", "fail (  \" The   body   of   a   disabled   test   should   never   be   executed !  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIfProfileValueDisabled"], "fileName": "org.springframework.test.context.junit4.EnabledAndIgnoredSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "( EnabledAndIgnoredSpringRunnerTests . numTestsExecuted )  +  +  ;", "}", "METHOD_END"], "methodName": ["testIfProfileValueEnabledViaMultipleValues"], "fileName": "org.springframework.test.context.junit4.EnabledAndIgnoredSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "( EnabledAndIgnoredSpringRunnerTests . numTestsExecuted )  +  +  ;", "}", "METHOD_END"], "methodName": ["testIfProfileValueEnabledViaSingleValue"], "fileName": "org.springframework.test.context.junit4.EnabledAndIgnoredSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "( EnabledAndIgnoredSpringRunnerTests . numTestsExecuted )  +  +  ;", "}", "METHOD_END"], "methodName": ["testIfProfileValueNotConfigured"], "fileName": "org.springframework.test.context.junit4.EnabledAndIgnoredSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "( EnabledAndIgnoredSpringRunnerTests . numTestsExecuted )  +  +  ;", "fail (  \" The   body   of   an   ignored   test   should   never   be   executed !  \"  )  ;", "}", "METHOD_END"], "methodName": ["testJUnitIgnoreAnnotation"], "fileName": "org.springframework.test.context.junit4.EnabledAndIgnoredSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   number   of   tests   executed .  \"  ,     3  ,    EnabledAndIgnoredSpringRunnerTests . numTestsExecuted )  ;", "}", "METHOD_END"], "methodName": ["verifyNumTestsExecuted"], "fileName": "org.springframework.test.context.junit4.EnabledAndIgnoredSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "JUnitTestingUtils . runTestsAndAssertCounters ( SpringRunner . class ,    ExpectedExceptionSpringRunnerTests . ExpectedExceptionSpringRunnerTestCase . class ,     1  ,     0  ,     1  ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["expectedExceptions"], "fileName": "org.springframework.test.context.junit4.ExpectedExceptionSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   SpringRunner . class ;", "}", "METHOD_END"], "methodName": ["getRunnerClass"], "fileName": "org.springframework.test.context.junit4.FailingBeforeAndAfterMethodsSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "int   expectedStartedCount    =     ( this . clazz . getSimpleName (  )  . startsWith (  \" AlwaysFailingBeforeTestClass \"  )  )     ?     0     :     1  ;", "int   expectedFinishedCount    =     ( this . clazz . getSimpleName (  )  . startsWith (  \" AlwaysFailingBeforeTestClass \"  )  )     ?     0     :     1  ;", "JUnitTestingUtils . runTestsAndAssertCounters ( getRunnerClass (  )  ,    this . clazz ,    expectedStartedCount ,     1  ,    expectedFinishedCount ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["runTestAndAssertCounters"], "fileName": "org.springframework.test.context.junit4.FailingBeforeAndAfterMethodsSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  {    FailingBeforeAndAfterMethodsSpringRunnerTests . AlwaysFailingBeforeTestClassTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRunnerTests . AlwaysFailingAfterTestClassTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRunnerTests . AlwaysFailingPrepareTestInstanceTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRunnerTests . AlwaysFailingBeforeTestMethodTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRunnerTests . AlwaysFailingBeforeTestExecutionTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRunnerTests . AlwaysFailingAfterTestExecutionTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRunnerTests . AlwaysFailingAfterTestMethodTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRunnerTests . FailingBeforeTransactionTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRunnerTests . FailingAfterTransactionTestCase . class . getSimpleName (  )     }  ;", "}", "METHOD_END"], "methodName": ["testCases"], "fileName": "org.springframework.test.context.junit4.FailingBeforeAndAfterMethodsSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TrackingTestNGTestListener   listener    =    new   TrackingTestNGTestListener (  )  ;", "TestNG   testNG    =    new   TestNG (  )  ;", "testNG . addListener (  (  ( ITestNGListener )     ( listener )  )  )  ;", "testNG . setTestClasses ( new   Class <  ?  >  [  ]  {    this . clazz    }  )  ;", "testNG . setVerbose (  0  )  ;", "testNG . run (  )  ;", "String   name    =    this . clazz . getSimpleName (  )  ;", "assertEquals (  (  (  \" tests   started   for    [  \"     +    name )     +     \"  ]     =  =  >     \"  )  ,    this . expectedTestStartCount ,    listener . testStartCount )  ;", "assertEquals (  (  (  \" successful   tests   for    [  \"     +    name )     +     \"  ]     =  =  >     \"  )  ,    this . expectedTestSuccessCount ,    listener . testSuccessCount )  ;", "assertEquals (  (  (  \" failed   tests   for    [  \"     +    name )     +     \"  ]     =  =  >     \"  )  ,    this . expectedFailureCount ,    listener . testFailureCount )  ;", "assertEquals (  (  (  \" failed   configurations   for    [  \"     +    name )     +     \"  ]     =  =  >     \"  )  ,    this . expectedFailedConfigurationsCount ,    listener . failedConfigurationsCount )  ;", "}", "METHOD_END"], "methodName": ["runTestAndAssertCounters"], "fileName": "org.springframework.test.context.junit4.FailingBeforeAndAfterMethodsTestNGTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  [  ]  {    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . AlwaysFailingBeforeTestClassTestCase . class . getSimpleName (  )  ,     1  ,     0  ,     0  ,     1     }  ,    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . AlwaysFailingAfterTestClassTestCase . class . getSimpleName (  )  ,     1  ,     1  ,     0  ,     1     }  ,    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . AlwaysFailingPrepareTestInstanceTestCase . class . getSimpleName (  )  ,     1  ,     0  ,     0  ,     1     }  ,    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . AlwaysFailingBeforeTestMethodTestCase . class . getSimpleName (  )  ,     1  ,     0  ,     0  ,     1     }  ,    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . AlwaysFailingBeforeTestExecutionTestCase . class . getSimpleName (  )  ,     1  ,     0  ,     1  ,     0     }  ,    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . AlwaysFailingAfterTestExecutionTestCase . class . getSimpleName (  )  ,     1  ,     0  ,     1  ,     0     }  ,    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . AlwaysFailingAfterTestMethodTestCase . class . getSimpleName (  )  ,     1  ,     1  ,     0  ,     1     }  ,    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . FailingBeforeTransactionTestCase . class . getSimpleName (  )  ,     1  ,     0  ,     0  ,     1     }  ,    new   Object [  ]  {    FailingBeforeAndAfterMethodsTestNGTests . FailingAfterTransactionTestCase . class . getSimpleName (  )  ,     1  ,     1  ,     0  ,     1     }     }  ;", "}", "METHOD_END"], "methodName": ["testData"], "fileName": "org.springframework.test.context.junit4.FailingBeforeAndAfterMethodsTestNGTests"}, {"methodBody": ["METHOD_START", "{", "EnabledAndIgnoredSpringRunnerTests . numTestsExecuted    =     0  ;", "System . setProperty ( EnabledAndIgnoredSpringRunnerTests . NAME ,     \"  9  9  9  9  9  9  9  9  9  9  9  9  \"  )  ;", "}", "METHOD_END"], "methodName": ["setProfileValue"], "fileName": "org.springframework.test.context.junit4.HardCodedProfileValueSourceSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "JUnitTestingUtils . runTestsAndAssertCounters ( null ,    testClass ,    expectedStartedCount ,    expectedFailedCount ,    expectedFinishedCount ,    expectedIgnoredCount ,    expectedAssumptionFailedCount )  ;", "}", "METHOD_END"], "methodName": ["runTestsAndAssertCounters"], "fileName": "org.springframework.test.context.junit4.JUnitTestingUtils"}, {"methodBody": ["METHOD_START", "{", "TrackingRunListener   listener    =    new   TrackingRunListener (  )  ;", "if    ( runnerClass    !  =    null )     {", "Constructor <  ?  >    constructor    =    runnerClass . getConstructor ( Class . class )  ;", "Runner   runner    =     (  ( Runner )     ( Bean . instantiateClass ( constructor ,    testClass )  )  )  ;", "RunNotifier   notifier    =    new   RunNotifier (  )  ;", "notifier . addListener ( listener )  ;", "runner . run ( notifier )  ;", "} else    {", "JUnitCore   junit    =    new   JUnitCore (  )  ;", "junit . addListener ( listener )  ;", "junit . run ( testClass )  ;", "}", "Assertions . assertAll (  (  )     -  >    assertEquals ( expectedStartedCount ,    listener . getTestStartedCount (  )  ,     (  (  \" tests   started   for    [  \"     +    testClass )     +     \"  ]  \"  )  )  ,     (  )     -  >    assertEquals ( expectedFailedCount ,    listener . getTestFailureCount (  )  ,     (  (  \" tests   failed   for    [  \"     +    testClass )     +     \"  ]  \"  )  )  ,     (  )     -  >    assertEquals ( expectedFinishedCount ,    listener . getTestFinishedCount (  )  ,     (  (  \" tests   finished   for    [  \"     +    testClass )     +     \"  ]  \"  )  )  ,     (  )     -  >    assertEquals ( expectedIgnoredCount ,    listener . getTestIgnoredCount (  )  ,     (  (  \" tests   ignored   for    [  \"     +    testClass )     +     \"  ]  \"  )  )  ,     (  )     -  >    assertEquals ( expectedAssumptionFailedCount ,    listener . getTestAssumptionFailureCount (  )  ,     (  (  \" failed   assumptions   for    [  \"     +    testClass )     +     \"  ]  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["runTestsAndAssertCounters"], "fileName": "org.springframework.test.context.junit4.JUnitTestingUtils"}, {"methodBody": ["METHOD_START", "{", "JUnitCore   junit    =    new   JUnitCore (  )  ;", "TrackingRunListener   listener    =    new   TrackingRunListener (  )  ;", "junit . addListener ( listener )  ;", "junit . run ( computer ,    testClasses )  ;", "Assertions . assertAll (  (  )     -  >    assertEquals ( expectedStartedCount ,    listener . getTestStartedCount (  )  ,     \" tests   started \"  )  ,     (  )     -  >    assertEquals ( expectedFailedCount ,    listener . getTestFailureCount (  )  ,     \" tests   failed \"  )  ,     (  )     -  >    assertEquals ( expectedFinishedCount ,    listener . getTestFinishedCount (  )  ,     \" tests   finished \"  )  ,     (  )     -  >    assertEquals ( expectedIgnoredCount ,    listener . getTestIgnoredCount (  )  ,     \" tests   ignored \"  )  ,     (  )     -  >    assertEquals ( expectedAssumptionFailedCount ,    listener . getTestAssumptionFailureCount (  )  ,     \" failed   assumptions \"  )  )  ;", "}", "METHOD_END"], "methodName": ["runTestsAndAssertCounters"], "fileName": "org.springframework.test.context.junit4.JUnitTestingUtils"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertEquals (  \" Deleting   bob \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . deletePerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . BOB )  )  ;", "assertEquals (  \" Adding   jane \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . JANE )  )  ;", "assertEquals (  \" Adding   sue \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . SUE )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   within   a   transaction .  \"  ,     2  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithinTransaction"], "fileName": "org.springframework.test.context.junit4.MethodLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals (  \" Adding   luke \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . LUKE )  )  ;", "assertEquals (  \" Adding   leia \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . LEIA )  )  ;", "assertEquals (  \" Adding   yoda \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson (  . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . YODA )  )  ;", "assertEquals (  \" Verifying   the   number   of   rows   in   the   person   table   without   a   transaction .  \"  ,     4  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable (  . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithoutTransaction"], "fileName": "org.springframework.test.context.junit4.MethodLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "MethodLevelTransactionalSpringRunnerTests . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.MethodLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,     4  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( MethodLevelTransactionalSpringRunnerTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalTestData"], "fileName": "org.springframework.test.context.junit4.MethodLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "AbstractTransactionalSpringRunnerTests . clearPersonTable ( MethodLevelTransactionalSpringRunnerTests . jdbcTemplate )  ;", "assertEquals (  \" Adding   bob \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . addPerson ( MethodLevelTransactionalSpringRunnerTests . jdbcTemplate ,    AbstractTransactionalSpringRunnerTests . BOB )  )  ;", "assertEquals (  \" Verifying   the   initial   number   of   rows   in   the   person   table .  \"  ,     1  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( MethodLevelTransactionalSpringRunnerTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyInitialTestData"], "fileName": "org.springframework.test.context.junit4.MethodLevelTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["contextConfigurationAnnotationIsOptional"], "fileName": "org.springframework.test.context.junit4.OptionalContextConfigurationSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedDependencyInjectionTests . invocationCount . set (  0  )  ;", "}", "METHOD_END"], "methodName": ["BeforeClass"], "fileName": "org.springframework.test.context.junit4.ParameterizedDependencyInjectionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  [  ]  {    new   String [  ]  {     \" employee 1  \"  ,     \" John   Smith \"     }  ,    new   String [  ]  {     \" employee 2  \"  ,     \" Jane   Smith \"     }     }  ;", "}", "METHOD_END"], "methodName": ["employeeData"], "fileName": "org.springframework.test.context.junit4.ParameterizedDependencyInjectionTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedDependencyInjectionTests . testContextManager . prepareTestInstance ( this )  ;", "}", "METHOD_END"], "methodName": ["injectDependencies"], "fileName": "org.springframework.test.context.junit4.ParameterizedDependencyInjectionTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   times   the   parameterized   test   method   was   executed .  \"  ,    ParameterizedDependencyInjectionTests . employeeData (  )  . length ,    ParameterizedDependencyInjectionTests . invocationCount . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyNumParameterizedRuns"], "fileName": "org.springframework.test.context.junit4.ParameterizedDependencyInjectionTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedDependencyInjectionTests . invocationCount . incrementAndGet (  )  ;", "assertNotNull (  \" The   pet   field   should   have   been   autowired .  \"  ,    this . pet )  ;", "Employee   employee    =    this . applicationContext . getBean ( this . employeeBeanName ,    Employee . class )  ;", "assertEquals (  (  (  \" Name   of   the   employee   configured   as   bean    [  \"     +     ( this . employeeBeanName )  )     +     \"  ]  .  \"  )  ,    this . employeeName ,    employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPetAndEmployee"], "fileName": "org.springframework.test.context.junit4.ParameterizedDependencyInjectionTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   cat   field   should   have   been   autowired .  \"  ,    this . cat )  ;", "assertEquals (  \" Garfield \"  ,    this . cat . getName (  )  )  ;", "assertNotNull (  \" TheString   field   should   have   been   autowired .  \"  ,    thisString )  ;", "assertEquals (  \" Test   String \"  ,    thisString )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.junit4.PropertiesBasedSpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "RepeatedSpringRunnerTests . invocationCount . set (  0  )  ;", "JUnitTestingUtils . runTestsAndAssertCounters ( getRunnerClass (  )  ,    this . testClass ,    expectedStartedCount ,    expectedFailureCount ,    expectedFinishedCount ,     0  ,     0  )  ;", "assertEquals (  (  (  \" invocations   for    [  \"     +     ( testClass )  )     +     \"  ]  :  \"  )  ,    expectedInvocationCount ,    RepeatedSpringRunnerTests . invocationCount . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertRepetitions"], "fileName": "org.springframework.test.context.junit4.RepeatedSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   SpringRunner . class ;", "}", "METHOD_END"], "methodName": ["getRunnerClass"], "fileName": "org.springframework.test.context.junit4.RepeatedSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  [  ]  {    new   Object [  ]  {    RepeatedSpringRunnerTests . NonAnnotatedRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     1     }  ,    new   Object [  ]  {    RepeatedSpringRunnerTests . DefaultRepeatValueRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     1     }  ,    new   Object [  ]  {    RepeatedSpringRunnerTests . NegativeRepeatValueRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     1     }  ,    new   Object [  ]  {    RepeatedSpringRunnerTests . RepeatedFiveTimesRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     5     }  ,    new   Object [  ]  {    RepeatedSpringRunnerTests . RepeatedFiveTimesViaMetaAnnotationRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     5     }  ,    new   Object [  ]  {    RepeatedSpringRunnerTests . TimedRepeatedTestCase . class . getSimpleName (  )  ,     3  ,     4  ,     4  ,     (  (  5     +     1  )     +     4  )     +     1  0     }     }  ;", "}", "METHOD_END"], "methodName": ["repetitionData"], "fileName": "org.springframework.test.context.junit4.RepeatedSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "RollbackOverrideDefaultRollbackFalseRollbackAnnotationTransactionalTests . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.RollbackOverrideDefaultRollbackFalseRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,    RollbackOverrideDefaultRollbackFalseRollbackAnnotationTransactionalTests . originalNumRows ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( RollbackOverrideDefaultRollbackFalseRollbackAnnotationTransactionalTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalTestData"], "fileName": "org.springframework.test.context.junit4.RollbackOverrideDefaultRollbackFalseRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,    RollbackOverrideDefaultRollbackFalseTransactionalTests . originalNumRows ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( RollbackOverrideDefaultRollbackFalseTransactionalTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalTestData"], "fileName": "org.springframework.test.context.junit4.RollbackOverrideDefaultRollbackFalseTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,     3  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( RollbackOverrideDefaultRollbackTrueRollbackAnnotationTransactionalTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalTestData"], "fileName": "org.springframework.test.context.junit4.RollbackOverrideDefaultRollbackTrueRollbackAnnotationTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "RollbackOverrideDefaultRollbackTrueTransactionalTests . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.RollbackOverrideDefaultRollbackTrueTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   the   final   number   of   rows   in   the   person   table   after   all   tests .  \"  ,     3  ,    AbstractTransactionalSpringRunnerTests . countRowsInPersonTable ( RollbackOverrideDefaultRollbackTrueTransactionalTests . jdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["verifyFinalTestData"], "fileName": "org.springframework.test.context.junit4.RollbackOverrideDefaultRollbackTrueTransactionalTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" testA \"  ,    name . getMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testA"], "fileName": "org.springframework.test.context.junit4.SpringJUnit47ClassRunnerRuleTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" testB \"  ,    name . getMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testB"], "fileName": "org.springframework.test.context.junit4.SpringJUnit47ClassRunnerRuleTests"}, {"methodBody": ["METHOD_START", "{", "return   new   TestContextManager ( clazz )  ;", "}", "METHOD_END"], "methodName": ["createTestContextManager"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "for    ( Field   field    :    testClass . getFields (  )  )     {", "Assert . state (  (  !  ( SpringClassRule . class . isAssignableFrom ( field . getType (  )  )  )  )  ,     (  )     -  >    String . format (  (  \" Detected   SpringClassRule   field   in   test   class    [  % s ]  ,     \"     +     \" but   SpringClassRule   cannot   be   used   with   the    .  \"  )  ,    testClass . getName (  )  )  )  ;", "Assert . state (  (  !  ( SpringMethodRule . class . isAssignableFrom ( field . getType (  )  )  )  )  ,     (  )     -  >    String . format (  (  \" Detected   SpringMethodRule   field   in   test   class    [  % s ]  ,     \"     +     \" but   SpringMethodRule   cannot   be   used   with   the    .  \"  )  ,    testClass . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureSpringRulesAreNotPresent"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "Test   test    =    frameworkMethod . getAnnotation ( Test . class )  ;", "return    ( test    !  =    null )     &  &     (  ( test . expected (  )  )     !  =     ( None . class )  )     ?    test . expected (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getExpectedException"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "Test   test    =    frameworkMethod . getAnnotation ( Test . class )  ;", "return    ( test    !  =    null )     &  &     (  ( test . timeout (  )  )     >     0  )     ?    test . timeout (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getJUnitTimeout"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "return   TestAnnotationUtils . getTimeout ( frameworkMethod . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSpringTimeout"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "return   this . testContextManager ;", "}", "METHOD_END"], "methodName": ["getTestContextManager"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    frameworkMethod . getMethod (  )  ;", "return    ( method . isAnnotationPresent ( Ignore . class )  )     |  |     (  !  ( ProfileValueUtils . isTestEnabledInThisEnvironment ( method ,    getTestClass (  )  . getJavaClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTestMethodIgnored"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "return   new   RunAfterTestExecutionCallbacks ( statement ,    testInstance ,    frameworkMethod . getMethod (  )  ,    getTestContextManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["withAfterTestExecutionCallbacks"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "return   new   RunBeforeTestExecutionCallbacks ( statement ,    testInstance ,    frameworkMethod . getMethod (  )  ,    getTestContextManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["withBeforeTestExecutionCallbacks"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "return   new   SpringRepeat ( next ,    frameworkMethod . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["withPotentialRepeat"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    ReflectionUtils . invokeMethod ( SpringJUnit 4 ClassRunner . withRulesMethod ,    this ,    frameworkMethod ,    testInstance ,    statement )  ;", "Assert . state (  ( result   instanceof   Statement )  ,     \" withRules   mismatch \"  )  ;", "return    (  ( Statement )     ( result )  )  ;", "}", "METHOD_END"], "methodName": ["withRulesReflectively"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner"}, {"methodBody": ["METHOD_START", "{", "this . bar    =    bar ;", "}", "METHOD_END"], "methodName": ["setBar"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "this . employee    =    employee ;", "}", "METHOD_END"], "methodName": ["setEmployee"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "this . literalParameterValue    =    literalParameterValue ;", "}", "METHOD_END"], "methodName": ["setLiteralParameterValue"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "this . spelParameterValue    =    spelParameterValue ;", "}", "METHOD_END"], "methodName": ["setSpelParameterValue"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertNull (  \" The   nonrequiredLong   field   should   NOT   have   been   autowired .  \"  ,    this . nonrequiredLong )  ;", "assertEquals (  \" The   quux   field   should   have   been   autowired   via    @ Autowired   and    @ Qualifier .  \"  ,     \" Quux \"  ,    this . quux )  ;", "assertEquals (  \" The   namedFoo   field   should   have   been   injected   via    @ Inject   and    @ Named .  \"  ,     \" Quux \"  ,    this . namedQuux )  ;", "assertSame (  \"  @ Autowired /  @ Qualifier   and    @ Inject /  @ Named   quux   should   be   the   same   object .  \"  ,    this . quux ,    this . namedQuux )  ;", "assertNotNull (  \" The   pet   field   should   have   been   autowired .  \"  ,    this . autowiredPet )  ;", "assertNotNull (  \" The   pet   field   should   have   been   injected .  \"  ,    this . injectedPet )  ;", "assertEquals (  \" Fido \"  ,    this . autowiredPet . getName (  )  )  ;", "assertEquals (  \" Fido \"  ,    this . injectedPet . getName (  )  )  ;", "assertSame (  \"  @ Autowired   and    @ Inject   pet   should   be   the   same   object .  \"  ,    this . autowiredPet ,    this . injectedPet )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredAndInjectedFields"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   setter   method   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredMethods"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   application   context   should   have   been   set   due   to   ApplicationContextAware   semantics .  \"  ,    this . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["verifyApplicationContextSet"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Literal    @ Value   field   should   have   been   autowired \"  ,    this . literalFieldValue )  ;", "assertNotNull (  \" SpEL    @ Value   field   should   have   been   autowired .  \"  ,    this . spelFieldValue )  ;", "assertEquals (  \" enigma \"  ,    this . literalFieldValue )  ;", "assertEquals ( Boolean . TRUE ,    this . spelFieldValue )  ;", "}", "METHOD_END"], "methodName": ["verifyAutowiredAtValueFields"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Literal    @ Value   method   parameter   should   have   been   autowired .  \"  ,    this . literalParameterValue )  ;", "assertNotNull (  \" SpEL    @ Value   method   parameter   should   have   been   autowired .  \"  ,    this . spelParameterValue )  ;", "assertEquals (  \" enigma \"  ,    this . literalParameterValue )  ;", "assertEquals ( Boolean . TRUE ,    this . spelParameterValue )  ;", "}", "METHOD_END"], "methodName": ["verifyAutowiredAtValueMethods"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" This   test   bean   should   have   been   initialized   due   to   InitializingBean   semantics .  \"  ,    this . beanInitialized )  ;", "}", "METHOD_END"], "methodName": ["verifyBeanInitialized"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" The   bean   name   of   this   test   instance   should   have   been   set   due   to   BeanNameAware   semantics .  \"  ,    getClass (  )  . getName (  )  ,    this . beanName )  ;", "}", "METHOD_END"], "methodName": ["verifyBeanNameSet"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" The   foo   field   should   have   been   injected   via    @ Resource .  \"  ,     \" Foo \"  ,    this . foo )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceAnnotationInjectedFields"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" The   bar   method   should   have   been   wired   via    @ Resource .  \"  ,     \" Bar \"  ,    this . bar )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceAnnotationInjectedMethods"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerAppCtxTests"}, {"methodBody": ["METHOD_START", "{", "SpringJUnit 4 ClassRunner   runner    =    new   SpringJUnit 4 ClassRunner ( getClass (  )  )     {", "@ Override", "protected   TestContextManager   createTestContextManager ( Class <  ?  >    clazz )     {", "return   new   TestContextManager ( clazz )     {", "@ Override", "public   void   prepareTestInstance ( Object   testInstance )     {", "throw   new   RuntimeException (  \" This   RuntimeException   should   be   caught   and   wrapped   in   an   Exception .  \"  )  ;", "}", "}  ;", "}", "}  ;", "runner . createTest (  )  ;", "}", "METHOD_END"], "methodName": ["checkThatExceptionsAreNotSilentlySwallowed"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerTests"}, {"methodBody": ["METHOD_START", "{", "SpringJUnit 4 ClassRunner   runner    =    new   SpringJUnit 4 ClassRunner ( getClass (  )  )  ;", "long   timeout    =    runner . getSpringTimeout ( new   FrameworkMethod ( getClass (  )  . getDeclaredMethod (  \" springTimeoutWithMetaAnnotation \"  )  )  )  ;", "assertEquals (  1  0  ,    timeout )  ;", "}", "METHOD_END"], "methodName": ["getSpringTimeoutViaMetaAnnotation"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerTests"}, {"methodBody": ["METHOD_START", "{", "SpringJUnit 4 ClassRunner   runner    =    new   SpringJUnit 4 ClassRunner ( getClass (  )  )  ;", "long   timeout    =    runner . getSpringTimeout ( new   FrameworkMethod ( getClass (  )  . getDeclaredMethod (  \" springTimeoutWithMetaAnnotationAndOverride \"  )  )  )  ;", "assertEquals (  4  2  ,    timeout )  ;", "}", "METHOD_END"], "methodName": ["getSpringTimeoutViaMetaAnnotationWithOverride"], "fileName": "org.springframework.test.context.junit4.SpringJUnit4ClassRunnerTests"}, {"methodBody": ["METHOD_START", "{", "fail (  \" The   body   of   an   ignored   test   should   never   be   executed !  \"  )  ;", "}", "METHOD_END"], "methodName": ["alwaysFailsButShouldBeIgnored"], "fileName": "org.springframework.test.context.junit4.StandardJUnit4FeaturesTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( true )  ;", "}", "METHOD_END"], "methodName": ["alwaysSucceeds"], "fileName": "org.springframework.test.context.junit4.StandardJUnit4FeaturesTests"}, {"methodBody": ["METHOD_START", "{", "new   ArrayList <  >  (  )  . get (  1  )  ;", "}", "METHOD_END"], "methodName": ["expectingAnIndexOutOfBoundsException"], "fileName": "org.springframework.test.context.junit4.StandardJUnit4FeaturesTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( false )  ;", "fail (  \" A   failed   assumption   should   preclude   imminent   fail !  \"  )  ;", "}", "METHOD_END"], "methodName": ["failedAssumptionShouldPrecludeImminentFailure"], "fileName": "org.springframework.test.context.junit4.StandardJUnit4FeaturesTests"}, {"methodBody": ["METHOD_START", "{", "( this . beforeCounter )  +  +  ;", "}", "METHOD_END"], "methodName": ["incrementBeforeCounter"], "fileName": "org.springframework.test.context.junit4.StandardJUnit4FeaturesTests"}, {"methodBody": ["METHOD_START", "{", "( StandardJUnit 4 FeaturesTests . staticBeforeCounter )  +  +  ;", "}", "METHOD_END"], "methodName": ["incrementStaticBeforeCounter"], "fileName": "org.springframework.test.context.junit4.StandardJUnit4FeaturesTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    this . beforeCounter )  ;", "}", "METHOD_END"], "methodName": ["verifyBeforeAnnotation"], "fileName": "org.springframework.test.context.junit4.StandardJUnit4FeaturesTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( StandardJUnit 4 FeaturesTests . staticBeforeCounter )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyBeforeClassAnnotation"], "fileName": "org.springframework.test.context.junit4.StandardJUnit4FeaturesTests"}, {"methodBody": ["METHOD_START", "{", "return   SpringRunner . class ;", "}", "METHOD_END"], "methodName": ["getRunnerClass"], "fileName": "org.springframework.test.context.junit4.TimedSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   TimedSpringRunnerTests . TimedSpringRunnerTestCase . class ;", "}", "METHOD_END"], "methodName": ["getTestCase"], "fileName": "org.springframework.test.context.junit4.TimedSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "JUnitTestingUtils . runTestsAndAssertCounters ( getRunnerClass (  )  ,    getTestCase (  )  ,     7  ,     5  ,     7  ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["timedTests"], "fileName": "org.springframework.test.context.junit4.TimedSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "}", "METHOD_END"], "methodName": ["notTransactionalWithJUnitTimeout"], "fileName": "org.springframework.test.context.junit4.TimedTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "}", "METHOD_END"], "methodName": ["notTransactionalWithSpringTimeout"], "fileName": "org.springframework.test.context.junit4.TimedTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "}", "METHOD_END"], "methodName": ["transactionalWithJUnitTimeout"], "fileName": "org.springframework.test.context.junit4.TimedTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "}", "METHOD_END"], "methodName": ["transactionalWithSpringTimeout"], "fileName": "org.springframework.test.context.junit4.TimedTransactionalSpringRunnerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . testAssumptionFailureCount . get (  )  ;", "}", "METHOD_END"], "methodName": ["getTestAssumptionFailureCount"], "fileName": "org.springframework.test.context.junit4.TrackingRunListener"}, {"methodBody": ["METHOD_START", "{", "return   this . testFailureCount . get (  )  ;", "}", "METHOD_END"], "methodName": ["getTestFailureCount"], "fileName": "org.springframework.test.context.junit4.TrackingRunListener"}, {"methodBody": ["METHOD_START", "{", "return   this . testFinishedCount . get (  )  ;", "}", "METHOD_END"], "methodName": ["getTestFinishedCount"], "fileName": "org.springframework.test.context.junit4.TrackingRunListener"}, {"methodBody": ["METHOD_START", "{", "return   this . testIgnoredCount . get (  )  ;", "}", "METHOD_END"], "methodName": ["getTestIgnoredCount"], "fileName": "org.springframework.test.context.junit4.TrackingRunListener"}, {"methodBody": ["METHOD_START", "{", "return   this . testStartedCount . get (  )  ;", "}", "METHOD_END"], "methodName": ["getTestStartedCount"], "fileName": "org.springframework.test.context.junit4.TrackingRunListener"}, {"methodBody": ["METHOD_START", "{", "return    \" bar \"  ;", "}", "METHOD_END"], "methodName": ["bar"], "fileName": "org.springframework.test.context.junit4.aci.annotation.BarConfig"}, {"methodBody": ["METHOD_START", "{", "return    \" dev   profile   config \"  ;", "}", "METHOD_END"], "methodName": ["baz"], "fileName": "org.springframework.test.context.junit4.aci.annotation.DevProfileConfig"}, {"methodBody": ["METHOD_START", "{", "return    \" foo \"  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.aci.annotation.FooConfig"}, {"methodBody": ["METHOD_START", "{", "return    \" global   config \"  ;", "}", "METHOD_END"], "methodName": ["baz"], "fileName": "org.springframework.test.context.junit4.aci.annotation.GlobalConfig"}, {"methodBody": ["METHOD_START", "{", "return    \" foo \"  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.aci.annotation.GlobalConfig"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  2  ,    strings . size (  )  )  ;", "Assert . assertEquals (  \" foo \"  ,    foo )  ;", "Assert . assertEquals (  \" bar \"  ,    bar )  ;", "}", "METHOD_END"], "methodName": ["beansFromInitializerAndComposedAnnotation"], "fileName": "org.springframework.test.context.junit4.aci.annotation.InitializerConfiguredViaMetaAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.aci.annotation.InitializerWithoutConfigFilesOrClassesTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "assertEquals (  \" foo \"  ,    bar )  ;", "assertEquals (  \" dev   profile   c \"  ,    baz )  ;", "}", "METHOD_END"], "methodName": ["activeBeans"], "fileName": "org.springframework.test.context.junit4.aci.annotation.MultipleInitializersAnnotationConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( OrderedInitializersAnnotationConfigTests . PROFILE _ GLOBAL ,    foo )  ;", "assertEquals ( OrderedInitializersAnnotationConfigTests . PROFILE _ GLOBAL ,    bar )  ;", "assertEquals ( OrderedInitializersAnnotationConfigTests . PROFILE _ TWO ,    baz )  ;", "}", "METHOD_END"], "methodName": ["activeBeans"], "fileName": "org.springframework.test.context.junit4.aci.annotation.OrderedInitializersAnnotationConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    enigma )  ;", "}", "METHOD_END"], "methodName": ["customPropertySourceConfiguredViaContextInitializer"], "fileName": "org.springframework.test.context.junit4.aci.annotation.PropertySourcesInitializerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "assertEquals (  \" foo \"  ,    bar )  ;", "assertEquals (  \" global   c \"  ,    baz )  ;", "}", "METHOD_END"], "methodName": ["activeBeans"], "fileName": "org.springframework.test.context.junit4.aci.annotation.SingleInitializerAnnotationConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "assertEquals (  \" foo \"  ,    bar )  ;", "assertEquals (  \" dev   profile   c \"  ,    baz )  ;", "}", "METHOD_END"], "methodName": ["activeBeans"], "fileName": "org.springframework.test.context.junit4.aci.xml.MultipleInitializersXmlConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   field   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyEmployeeSetFromBaseContextConfig"], "fileName": "org.springframework.test.context.junit4.annotation.DefaultConfigClassesBaseTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   pet   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Fido \"  ,    this . pet . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPetSetFromExtendedContextConfig"], "fileName": "org.springframework.test.context.junit4.annotation.DefaultConfigClassesInheritedTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   field   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyEmployeeSetFromBaseContextConfig"], "fileName": "org.springframework.test.context.junit4.annotation.DefaultLoaderDefaultConfigClassesBaseTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   pet   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Fido \"  ,    this . pet . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPetSetFromExtendedContextConfig"], "fileName": "org.springframework.test.context.junit4.annotation.DefaultLoaderDefaultConfigClassesInheritedTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyEmployeeSetFromBaseContextConfig"], "fileName": "org.springframework.test.context.junit4.annotation.DefaultLoaderExplicitConfigClassesBaseTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   pet   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Fido \"  ,    this . pet . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPetSetFromExtendedContextConfig"], "fileName": "org.springframework.test.context.junit4.annotation.DefaultLoaderExplicitConfigClassesInheritedTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyEmployeeSetFromBaseContextConfig"], "fileName": "org.springframework.test.context.junit4.annotation.ExplicitConfigClassesBaseTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   pet   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Fido \"  ,    this . pet . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPetSetFromExtendedContextConfig"], "fileName": "org.springframework.test.context.junit4.annotation.ExplicitConfigClassesInheritedTests"}, {"methodBody": ["METHOD_START", "{", "return    \" Bar \"  ;", "}", "METHOD_END"], "methodName": ["bar"], "fileName": "org.springframework.test.context.junit4.annotation.PojoAndStringConfig"}, {"methodBody": ["METHOD_START", "{", "Employee   employee    =    new   Employee (  )  ;", "employee . setN (  \" John   Smith \"  )  ;", "employee . setAge (  4  2  )  ;", "employee . setCompany (  \" Acme   Widgets ,    Inc .  \"  )  ;", "return   employee ;", "}", "METHOD_END"], "methodName": ["employee"], "fileName": "org.springframework.test.context.junit4.annotation.PojoAndStringConfig"}, {"methodBody": ["METHOD_START", "{", "return    \" Foo \"  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.annotation.PojoAndStringConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   Pet (  \" Fido \"  )  ;", "}", "METHOD_END"], "methodName": ["pet"], "fileName": "org.springframework.test.context.junit4.annotation.PojoAndStringConfig"}, {"methodBody": ["METHOD_START", "{", "return    \" Quux \"  ;", "}", "METHOD_END"], "methodName": ["quux"], "fileName": "org.springframework.test.context.junit4.annotation.PojoAndStringConfig"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Resolver   Foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.annotation.meta.ConfigClassesAndProfileResolverWithCustomDefaultsMetaConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Local   Dev   Foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.annotation.meta.ConfigClassesAndProfileResolverWithCustomDefaultsMetaConfigWithOverridesTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Local   Dev   Foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.annotation.meta.ConfigClassesAndProfilesMetaConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Dev   Foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.annotation.meta.ConfigClassesAndProfilesWithCustomDefaultsMetaConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyEmployee"], "fileName": "org.springframework.test.context.junit4.annotation.meta.ConfigClassesAndProfilesWithCustomDefaultsMetaConfigWithOverridesTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Production   Foo \"  ,    this . foo )  ;", "}", "METHOD_END"], "methodName": ["verifyFoo"], "fileName": "org.springframework.test.context.junit4.annotation.meta.ConfigClassesAndProfilesWithCustomDefaultsMetaConfigWithOverridesTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   pet   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Fido \"  ,    this . pet . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPet"], "fileName": "org.springframework.test.context.junit4.annotation.meta.ConfigClassesAndProfilesWithCustomDefaultsMetaConfigWithOverridesTests"}, {"methodBody": ["METHOD_START", "{", "return    \" Local   Dev   Foo \"  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.annotation.meta.LocalDevConfig"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Production   Foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.annotation.meta.MetaMetaConfigDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "}", "METHOD_END"], "methodName": ["abortIfLongRunningTestGroupIsNotEnabled"], "fileName": "org.springframework.test.context.junit4.concurrency.SpringJUnit4ConcurrencyTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( Arrays . stream ( this . testClasses )  . map ( ReflectionUtils :  : getUniqueDeclaredMethods )  . flatMap ( Arrays :  : stream )  . filter (  (    method )     -  >    hasAnnotation ( method ,    annotationType )  )  . count (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["countAnnotatedMethods"], "fileName": "org.springframework.test.context.junit4.concurrency.SpringJUnit4ConcurrencyTests"}, {"methodBody": ["METHOD_START", "{", "final   int   FAILED    =     0  ;", "final   int   ABORTED    =     0  ;", "final   int   IGNORED    =    countAnnotatedMethods ( Ignore . class )  ;", "final   int   TESTS    =     ( countAnnotatedMethods ( Tlass )  )     -    IGNORED ;", "JUnitTestingUtils . runTestsAndAssertCounters ( new   ParallelComputer ( true ,    true )  ,    TESTS ,    FAILED ,    TESTS ,    IGNORED ,    ABORTED ,    this . testClasses )  ;", "}", "METHOD_END"], "methodName": ["runAllTestsConcurrently"], "fileName": "org.springframework.test.context.junit4.concurrency.SpringJUnit4ConcurrencyTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" XML \"  ,    fooFromXml )  ;", "assertEquals (  \" Java \"  ,    fooFromJava )  ;", "assertEquals (  \" enigma   from   XML \"  ,    enigma )  ;", "}", "METHOD_END"], "methodName": ["verifyContentsOfHybridApplicationContext"], "fileName": "org.springframework.test.context.junit4.hybrid.HybridContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["topLevelTest"], "fileName": "org.springframework.test.context.junit4.nested.NestedTestsWithSpringRulesTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   number   of   rows   in   the    ' person '    table .  \"  ,    expectedCount ,    countRowsInPersonTable (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertPersonCount"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "return   countRowsInTable (  \" person \"  )  ;", "}", "METHOD_END"], "methodName": ["countRowsInPersonTable"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "Person   sam    =    personService . findByName ( HibernateSessionFlushingTests . SAM )  ;", "assertNotNull (  \" Should   be   able   to   find   Sam \"  ,    sam )  ;", "DriversLicense   driversLicense    =    sam . getDriversLicense (  )  ;", "assertNotNull (  \" Sam ' s   driver ' s   license   should   not   be   null \"  ,    driversLicense )  ;", "assertEquals (  \" Verifying   Sam ' s   driver ' s   license   number \"  ,    Long . valueOf (  1  2  3  4  )  ,    driversLicense . getNumber (  )  )  ;", "}", "METHOD_END"], "methodName": ["findSam"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "DriversLicense   driversLicense    =    new   DriversLicense (  2 L ,     2  2  2  2 L )  ;", "Person   juergen    =    new   Person (  . JUERGEN ,    driversLicense )  ;", "int   numRows    =    countRowsInPersonTable (  )  ;", "personService . save ( juergen )  ;", "assertPersonCount (  ( numRows    +     1  )  )  ;", "assertNotNull (  \" Should   be   able   to   save   and   retrieve   Juergen \"  ,    personService . findByName (  . JUERGEN )  )  ;", "assertNotNull (  \" Juergen ' s   ID   should   have   been   set \"  ,    juergen . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["saveJuergenWithDriversLicense"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "personService . save ( new   Person ( HibernateSessionFlushingTests . JUERGEN )  )  ;", "}", "METHOD_END"], "methodName": ["saveJuergenWithNullDriversLicense"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertNotNull (  \" PersonService   should   have   been   autowired .  \"  ,    personService )  ;", "assertNotNull (  \" actory   should   have   been   autowired .  \"  ,    sessionFactory )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "Person   sam    =    personService . findByName ( HibernateSessionFlushingTests . SAM )  ;", "assertNotNull (  \" Should   be   able   to   find   Sam \"  ,    sam )  ;", "sam . setDriversLicense ( null )  ;", "personService . save ( sam )  ;", "}", "METHOD_END"], "methodName": ["updateSamWithNullDriversLicense"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "updateSamWithNullDriversLicense (  )  ;", "try    {", "sactory . getCurrentSession (  )  . flush (  )  ;", "}    catch    ( PersistenceException   ex )     {", "throw   ex . getCause (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateSamWithNullDriversLicenseWithSessionFlush"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "updateSamWithNullDriversLicense (  )  ;", "}", "METHOD_END"], "methodName": ["updateSamWithNullDriversLicenseWithoutSessionFlush"], "fileName": "org.springframework.test.context.junit4.orm.HibernateSessionFlushingTests"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.test.context.junit4.orm.domain.DriversLicense"}, {"methodBody": ["METHOD_START", "{", "return   this . number ;", "}", "METHOD_END"], "methodName": ["getNumber"], "fileName": "org.springframework.test.context.junit4.orm.domain.DriversLicense"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.test.context.junit4.orm.domain.DriversLicense"}, {"methodBody": ["METHOD_START", "{", "this . number    =    number ;", "}", "METHOD_END"], "methodName": ["setNumber"], "fileName": "org.springframework.test.context.junit4.orm.domain.DriversLicense"}, {"methodBody": ["METHOD_START", "{", "return   this . driversLicense ;", "}", "METHOD_END"], "methodName": ["getDriversLicense"], "fileName": "org.springframework.test.context.junit4.orm.domain.Person"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.test.context.junit4.orm.domain.Person"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.test.context.junit4.orm.domain.Person"}, {"methodBody": ["METHOD_START", "{", "this . driversLicense    =    driversLicense ;", "}", "METHOD_END"], "methodName": ["setDriversLicense"], "fileName": "org.springframework.test.context.junit4.orm.domain.Person"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.test.context.junit4.orm.domain.Person"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.test.context.junit4.orm.domain.Person"}, {"methodBody": ["METHOD_START", "{", "assertNull (  \" employee   bean   should   not   be   created   for   the   default   profile \"  ,    employee )  ;", "}", "METHOD_END"], "methodName": ["employee"], "fileName": "org.springframework.test.context.junit4.profile.annotation.DefaultProfileAnnotationConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( pet )  ;", "assertEquals (  \" Fido \"  ,    pet . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["pet"], "fileName": "org.springframework.test.context.junit4.profile.annotation.DefaultProfileAnnotationConfigTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Pet (  \" Fido \"  )  ;", "}", "METHOD_END"], "methodName": ["pet"], "fileName": "org.springframework.test.context.junit4.profile.annotation.DefaultProfileConfig"}, {"methodBody": ["METHOD_START", "{", "Employee   employee    =    new   Employee (  )  ;", "employee . setN (  \" John   Smith \"  )  ;", "employee . setAge (  4  2  )  ;", "employee . setCompany (  \" Acme   Widgets ,    Inc .  \"  )  ;", "return   employee ;", "}", "METHOD_END"], "methodName": ["employee"], "fileName": "org.springframework.test.context.junit4.profile.annotation.DevProfileConfig"}, {"methodBody": ["METHOD_START", "{", "assertNull (  \" employee   bean   should   not   be   created   for   the   default   profile \"  ,    employee )  ;", "}", "METHOD_END"], "methodName": ["employee"], "fileName": "org.springframework.test.context.junit4.profile.importresource.DefaultProfileAnnotationConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( pet )  ;", "assertEquals (  \" Fido \"  ,    pet . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["pet"], "fileName": "org.springframework.test.context.junit4.profile.importresource.DefaultProfileAnnotationConfigTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Pet (  \" Fido \"  )  ;", "}", "METHOD_END"], "methodName": ["pet"], "fileName": "org.springframework.test.context.junit4.profile.importresource.DefaultProfileConfig"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( Arrays . asList ( applicationContext . getEnvironment (  )  . getActiveProfiles (  )  )  . contains ( getClass (  )  . getSimpleName (  )  . toLowerCase (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.context.junit4.profile.resolver.ClassNameActiveProfilesResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertNull (  \" employee   bean   should   not   be   created   for   the   default   profile \"  ,    employee )  ;", "}", "METHOD_END"], "methodName": ["employee"], "fileName": "org.springframework.test.context.junit4.profile.xml.DefaultProfileXmlConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( pet )  ;", "assertEquals (  \" Fido \"  ,    pet . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["pet"], "fileName": "org.springframework.test.context.junit4.profile.xml.DefaultProfileXmlConfigTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" TestRule   should   have   been    @ Autowired \"  ,    autowiredTestRule )  ;", "assertFalse (  \"  @ Autowired   TestRule   should   NOT   have   been   applied \"  ,    autowiredTestRule . applied )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.context.junit4.rules.AutowiredRuleTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.junit4.rules.BaseAppCtxRuleTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  {    FailingBeforeAndAfterMethodsSpringRuleTests . AlwaysFailingBeforeTestClassSpringRuleTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRuleTests . AlwaysFailingAfterTestClassSpringRuleTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRuleTests . AlwaysFailingPrepareTestInstanceSpringRuleTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRuleTests . AlwaysFailingBeforeTestMethodSpringRuleTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRuleTests . AlwaysFailingAfterTestMethodSpringRuleTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRuleTests . FailingBeforeTransactionSpringRuleTestCase . class . getSimpleName (  )  ,    FailingBeforeAndAfterMethodsSpringRuleTests . FailingAfterTransactionSpringRuleTestCase . class . getSimpleName (  )     }  ;", "}", "METHOD_END"], "methodName": ["testData"], "fileName": "org.springframework.test.context.junit4.rules.FailingBeforeAndAfterMethodsSpringRuleTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedSpringRuleTests . invocationCount . set (  0  )  ;", "}", "METHOD_END"], "methodName": ["BeforeClass"], "fileName": "org.springframework.test.context.junit4.rules.ParameterizedSpringRuleTests"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  [  ]  {    new   String [  ]  {     \" employee 1  \"  ,     \" John   Smith \"     }  ,    new   String [  ]  {     \" employee 2  \"  ,     \" Jane   Smith \"     }     }  ;", "}", "METHOD_END"], "methodName": ["employeeData"], "fileName": "org.springframework.test.context.junit4.rules.ParameterizedSpringRuleTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   times   the   parameterized   test   method   was   executed .  \"  ,    ParameterizedSpringRuleTests . employeeData (  )  . length ,    ParameterizedSpringRuleTests . invocationCount . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyNumParameterizedRuns"], "fileName": "org.springframework.test.context.junit4.rules.ParameterizedSpringRuleTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedSpringRuleTests . invocationCount . incrementAndGet (  )  ;", "assertNotNull (  \" The   pet   field   should   have   been   autowired .  \"  ,    this . pet )  ;", "Employee   employee    =    this . applicationContext . getBean ( this . employeeBeanName ,    Employee . class )  ;", "assertEquals (  (  (  \" Name   of   the   employee   configured   as   bean    [  \"     +     ( this . employeeBeanName )  )     +     \"  ]  .  \"  )  ,    this . employeeName ,    employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPetAndEmployee"], "fileName": "org.springframework.test.context.junit4.rules.ParameterizedSpringRuleTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  [  ]  {    new   Object [  ]  {    RepeatedSpringRuleTests . NonAnnotatedRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     1     }  ,    new   Object [  ]  {    RepeatedSpringRuleTests . DefaultRepeatValueRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     1     }  ,    new   Object [  ]  {    RepeatedSpringRuleTests . NegativeRepeatValueRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     1     }  ,    new   Object [  ]  {    RepeatedSpringRuleTests . RepeatedFiveTimesRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     5     }  ,    new   Object [  ]  {    RepeatedSpringRuleTests . RepeatedFiveTimesViaMetaAnnotationRepeatedTestCase . class . getSimpleName (  )  ,     0  ,     1  ,     1  ,     5     }  ,    new   Object [  ]  {    RepeatedSpringRuleTests . TimedRepeatedTestCase . class . getSimpleName (  )  ,     3  ,     4  ,     4  ,     (  (  5     +     1  )     +     4  )     +     1  0     }     }  ;", "}", "METHOD_END"], "methodName": ["repetitionData"], "fileName": "org.springframework.test.context.junit4.rules.RepeatedSpringRuleTests"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . stream ( testClass . getFields (  )  )  . filter (  (    field )     -  >     !  ( Modifier . isStatic ( field . getModifiers (  )  )  )  )  . filter (  (    field )     -  >    Modifier . isPublic ( field . getModifiers (  )  )  )  . filter (  (    field )     -  >    SpringMethodRule . class . isAssignableFrom ( field . getType (  )  )  )  . findFirst (  )  ;", "}", "METHOD_END"], "methodName": ["findSpringMethodRuleField"], "fileName": "org.springframework.test.context.junit4.rules.SpringClassRule"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testClass ,     \" testClass   must   not   be   null \"  )  ;", "return    . testContextManagerCache . computeIfAbsent ( testClass ,    TestContextManager :  : new )  ;", "}", "METHOD_END"], "methodName": ["getTestContextManager"], "fileName": "org.springframework.test.context.junit4.rules.SpringClassRule"}, {"methodBody": ["METHOD_START", "{", "Field   ruleField    =    SpringClassRule . findSpringMethodRuleField ( testClass )  . orElseThrow (  (  )     -  >    new   IllegalStateException ( String . format (  (  \" Failed   to   find    ' public   SpringMethodRule '    field   in   test   class    [  % s ]  .     \"     +     \" Consult   the   \"  )  ,    testClass . getName (  )  )  )  )  ;", "Assert . state ( ruleField . isAnnotationPresent ( Rule . class )  ,     (  )     -  >    String . format (  (  \" SpringMethodRule   field    [  % s ]    must   be   annotated   with   JUnit ' s    @ Rule   annotation .     \"     +     \" Consult   the   \"  )  ,    ruleField )  )  ;", "}", "METHOD_END"], "methodName": ["validateSpringMethodRuleConfiguration"], "fileName": "org.springframework.test.context.junit4.rules.SpringClassRule"}, {"methodBody": ["METHOD_START", "{", "return   new   RunAfterTestClassCallbacks ( next ,    testContextManager )  ;", "}", "METHOD_END"], "methodName": ["withAfterTestClassCallbacks"], "fileName": "org.springframework.test.context.junit4.rules.SpringClassRule"}, {"methodBody": ["METHOD_START", "{", "return   new   RunBeforeTestClassCallbacks ( next ,    testContextManager )  ;", "}", "METHOD_END"], "methodName": ["withBeforeTestClassCallbacks"], "fileName": "org.springframework.test.context.junit4.rules.SpringClassRule"}, {"methodBody": ["METHOD_START", "{", "return   new   ProfileValueChecker ( next ,    testClass ,    null )  ;", "}", "METHOD_END"], "methodName": ["withProfileValueCheck"], "fileName": "org.springframework.test.context.junit4.rules.SpringClassRule"}, {"methodBody": ["METHOD_START", "{", "return   new   SpringClassRule . TestContextManagerCacheEvictor ( next ,    testClass )  ;", "}", "METHOD_END"], "methodName": ["withTestContextManagerCacheEviction"], "fileName": "org.springframework.test.context.junit4.rules.SpringClassRule"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . stream ( testClass . getFields (  )  )  . filter ( ReflectionUtils :  : isPublicStaticFinal )  . filter (  (    field )     -  >     . class . isAssignableFrom ( field . getType (  )  )  )  . findFirst (  )  ;", "}", "METHOD_END"], "methodName": ["findSpringClassRuleField"], "fileName": "org.springframework.test.context.junit4.rules.SpringMethodRule"}, {"methodBody": ["METHOD_START", "{", "Field   ruleField    =    SpringMethodRule . findSpringClassRuleField ( testClass )  . orElseThrow (  (  )     -  >    new   IllegalStateException ( String . format (  (  \" Failed   to   find    ' public   static   final   SpringClassRule '    field   in   test   class    [  % s ]  .     \"     +     \" Consult   the   \"  )  ,    testClass . getName (  )  )  )  )  ;", "Assert . state ( ruleField . isAnnotationPresent ( ClassRule . class )  ,     (  )     -  >    String . format (  (  \" SpringClassRule   field    [  % s ]    must   be   annotated   with   JUnit ' s    @ ClassRule   annotation .     \"     +     \" Consult   the   \"  )  ,    ruleField )  )  ;", "Object   result    =    ReflectionUtils . getField ( ruleField ,    null )  ;", "Assert . state (  ( result   instanceof   SpringClassRule )  ,     \" SpringClassRule   field   mismatch \"  )  ;", "return    (  ( SpringClassRule )     ( result )  )  ;", "}", "METHOD_END"], "methodName": ["validateSpringClassRuleConfiguration"], "fileName": "org.springframework.test.context.junit4.rules.SpringMethodRule"}, {"methodBody": ["METHOD_START", "{", "return   new   RunAfterTestMethodCallbacks ( next ,    testInstance ,    testMethod ,    testContextManager )  ;", "}", "METHOD_END"], "methodName": ["withAfterTestMethodCallbacks"], "fileName": "org.springframework.test.context.junit4.rules.SpringMethodRule"}, {"methodBody": ["METHOD_START", "{", "return   new   RunBeforeTestMethodCallbacks ( next ,    testInstance ,    testMethod ,    testContextManager )  ;", "}", "METHOD_END"], "methodName": ["withBeforeTestMethodCallbacks"], "fileName": "org.springframework.test.context.junit4.rules.SpringMethodRule"}, {"methodBody": ["METHOD_START", "{", "return   new   SpringRepeat ( next ,    testMethod )  ;", "}", "METHOD_END"], "methodName": ["withPotentialRepeat"], "fileName": "org.springframework.test.context.junit4.rules.SpringMethodRule"}, {"methodBody": ["METHOD_START", "{", "return   new   SpringFailOnTimeout ( next ,    testMethod )  ;", "}", "METHOD_END"], "methodName": ["withPotentialTimeout"], "fileName": "org.springframework.test.context.junit4.rules.SpringMethodRule"}, {"methodBody": ["METHOD_START", "{", "return   new   ProfileValueChecker ( next ,    testInstance . getClass (  )  ,    testMethod )  ;", "}", "METHOD_END"], "methodName": ["withProfileValueCheck"], "fileName": "org.springframework.test.context.junit4.rules.SpringMethodRule"}, {"methodBody": ["METHOD_START", "{", "return   new   RunPrepareTestInstanceCallbacks ( next ,    testInstance ,    testContextManager )  ;", "}", "METHOD_END"], "methodName": ["withTestInstancePreparation"], "fileName": "org.springframework.test.context.junit4.rules.SpringMethodRule"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" bar \"  ,    bar )  ;", "}", "METHOD_END"], "methodName": ["bar"], "fileName": "org.springframework.test.context.junit4.rules.Subclass1AppCtxRuleTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" baz \"  ,    baz )  ;", "}", "METHOD_END"], "methodName": ["baz"], "fileName": "org.springframework.test.context.junit4.rules.Subclass2AppCtxRuleTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "}", "METHOD_END"], "methodName": ["transactionalWithJUnitRuleBasedTimeout"], "fileName": "org.springframework.test.context.junit4.rules.TimedTransactionalSpringRuleTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyEmployeeSetFromBaseContextConfig"], "fileName": "org.springframework.test.context.junit4.spr3896.DefaultLocationsBaseTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   pet   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Fido \"  ,    this . pet . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPetSetFromExtendedContextConfig"], "fileName": "org.springframework.test.context.junit4.spr3896.DefaultLocationsInheritedTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   should   have   been   autowired .  \"  ,    this . employee )  ;", "assertEquals (  \" John   Smith \"  ,    this . employee . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyEmployeeSetFromBaseContextConfig"], "fileName": "org.springframework.test.context.junit4.spr3896.ExplicitLocationsBaseTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   pet   should   have   been   autowired .  \"  ,    this . pet )  ;", "assertEquals (  \" Fido \"  ,    this . pet . getN (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPetSetFromExtendedContextConfig"], "fileName": "org.springframework.test.context.junit4.spr3896.ExplicitLocationsInheritedTests"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" afterTestSuite (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["afterTestSuite"], "fileName": "org.springframework.test.context.junit4.spr4868.Jsr250LifecycleTests"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" beforeAllTests (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["beforeAllTests"], "fileName": "org.springframework.test.context.junit4.spr4868.Jsr250LifecycleTests"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" setUp (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.context.junit4.spr4868.Jsr250LifecycleTests"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" tearDown (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.test.context.junit4.spr4868.Jsr250LifecycleTests"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" test 1  (  )  \"  )  ;", "assertNotNull ( lBean )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "org.springframework.test.context.junit4.spr4868.Jsr250LifecycleTests"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" test 2  (  )  \"  )  ;", "assertNotNull ( lBean )  ;", "}", "METHOD_END"], "methodName": ["test2"], "fileName": "org.springframework.test.context.junit4.spr4868.Jsr250LifecycleTests"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" destroying \"  )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.test.context.junit4.spr4868.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" initializing \"  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.test.context.junit4.spr4868.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "assertThat ( foo ,    equalTo (  \" normal \"  )  )  ;", "assertThat ( customFoo ,    equalTo (  \" custom \"  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.context.junit4.spr6128.AutowiredQualifierTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["dummyTest"], "fileName": "org.springframework.test.context.junit4.spr8849.TestClass1"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["dummyTest"], "fileName": "org.springframework.test.context.junit4.spr8849.TestClass2"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["dummyTest"], "fileName": "org.springframework.test.context.junit4.spr8849.TestClass3"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["dummyTest"], "fileName": "org.springframework.test.context.junit4.spr8849.TestClass4"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Deleting   yoda \"  ,     1  ,    deletePerson ( AbstractTransactionalAnnotatedConfigClassTests . YODA )  )  ;", "assertNumRowsInPersonTable (  0  ,     \" after   a   transactional   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  (  \" Adding    '  \"     +    name )     +     \"  '  \"  )  ,     1  ,    createPerson ( name )  )  ;", "}", "METHOD_END"], "methodName": ["assertAddPerson"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  (  \" the   number   of   rows   in   the   person   table    (  \"     +    testState )     +     \"  )  .  \"  )  ,    expectedNumRows ,    countRowsInTable (  \" person \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumRowsInPersonTable"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" The   employee   should   have   been   autowired .  \"  ,    employee )  ;", "assertEquals (  \" John   Smith \"  ,    employee . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiringFromConfigClass"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRowsInPersonTable (  0  ,     \" before   a   transactional   test   method \"  )  ;", "assertAddPerson (  . YODA )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . queryForObject (  (  \" SELECT   COUNT (  0  )    FROM    \"     +    tableName )  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["countRowsInTable"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" INSERT   INTO   person   VALUES (  ?  )  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["createPerson"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" DELETE   FROM   person   WHERE   name =  ?  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["deletePerson"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertAddPerson (  . JANE )  ;", "assertAddPerson (  . SUE )  ;", "assertNumRowsInPersonTable (  3  ,     \" in   modifyTestDataWithinTransaction (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithinTransaction"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "this . dataSourceViaInjection    =    dataSource ;", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "this . dataSourceFromTxManager    =    transactionManager . getDataSource (  )  ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRowsInPersonTable (  ( TransactionTestUtils . inTransaction (  )     ?     1     :     0  )  ,     \" before   a   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRowsInPersonTable (  ( TransactionTestUtils . inTransaction (  )     ?     3     :     0  )  ,     \" after   a   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.test.context.junit4.spr9051.AbstractTransactionalAnnotatedConfigClassTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( enigma )  ;", "assertNotNull ( lifecycleBean )  ;", "assertTrue ( lifecycleBean . isInitialized (  )  )  ;", "Set < String >    names    =    new   HashSet <  >  (  )  ;", "names . add ( enigma . toString (  )  )  ;", "names . add ( lifecycleBean . getName (  )  )  ;", "assertEquals ( names ,    new   HashSet ( Arrays . asList (  \" enigma    #  1  \"  ,     \" enigma    #  2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR_9051"], "fileName": "org.springframework.test.context.junit4.spr9051.AnnotatedConfigClassesWithoutAtConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( injectedPrototypeBean )  ;", "assertTrue ( injectedPrototypeBean . isInitialized (  )  )  ;", "LifecycleBean   retrievedPrototypeBean    =    applicationCgetBean (  \" prototype \"  ,    LifecycleBean . class )  ;", "assertNotNull ( retrievedPrototypeBean )  ;", "assertTrue ( retrievedPrototypeBean . isInitialized (  )  )  ;", "assertNotSame ( injectedPrototypeBean ,    retrievedPrototypeBean )  ;", "}", "METHOD_END"], "methodName": ["prototypeLiteBean"], "fileName": "org.springframework.test.context.junit4.spr9051.AtBeanLiteModeScopeTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( injectedSingletonBean )  ;", "assertTrue ( injectedSingletonBean . isInitialized (  )  )  ;", "LifecycleBean   retrievedSingletonBean    =    applicationCgetBean (  \" singleton \"  ,    LifecycleBean . class )  ;", "assertNotNull ( retrievedSingletonBean )  ;", "assertTrue ( retrievedSingletonBean . isInitialized (  )  )  ;", "assertSame ( injectedSingletonBean ,    retrievedSingletonBean )  ;", "}", "METHOD_END"], "methodName": ["singletonLiteBean"], "fileName": "org.springframework.test.context.junit4.spr9051.AtBeanLiteModeScopeTests"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.test.context.junit4.spr9051.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "initialized    =    true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.test.context.junit4.spr9051.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   this . initialized ;", "}", "METHOD_END"], "methodName": ["isInitialized"], "fileName": "org.springframework.test.context.junit4.spr9051.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "assertSame ( dataSourceFromTxManager ,    dataSourceViaInjection )  ;", "}", "METHOD_END"], "methodName": ["compareDataSources"], "fileName": "org.springframework.test.context.junit4.spr9051.TransactionalAnnotatedConfigClassWithAtConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "assertNotSame ( dataSourceFromTxManager ,    dataSourceViaInjection )  ;", "}", "METHOD_END"], "methodName": ["compareDataSources"], "fileName": "org.springframework.test.context.junit4.spr9051.TransactionalAnnotatedConfigClassesWithoutAtConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . begun )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . commits )  ;", "assertEquals (  1  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . rollbacks )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . begun )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . commits )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.spr9604.LookUpTxMgrViaTransactionManagementConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . clear (  )  ;", "LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.spr9604.LookUpTxMgrViaTransactionManagementConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . begun )  ;", "assertEquals (  1  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . commits )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 1  . rollbacks )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . begun )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . commits )  ;", "assertEquals (  0  ,    LookUpTxMgrViaTransactionManagementConfigurerTests . txManager 2  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["transactionalTest"], "fileName": "org.springframework.test.context.junit4.spr9604.LookUpTxMgrViaTransactionManagementConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    LookUpNonexistentTxMgrTests . txManager . begun )  ;", "assertEquals (  0  ,    LookUpNonexistentTxMgrTests . txManager . inflight )  ;", "assertEquals (  0  ,    LookUpNonexistentTxMgrTests . txManager . commits )  ;", "assertEquals (  0  ,    LookUpNonexistentTxMgrTests . txManager . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["nonTransactionalTest"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpNonexistentTxMgrTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . begun )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . commits )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndDefaultNameTests"}, {"methodBody": ["METHOD_START", "{", "LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . clear (  )  ;", "LookUpTxMgrByTypeAndDefaultNameTests . txManager 2  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndDefaultNameTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . begun )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . commits )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndDefaultNameTests . txManager 1  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["transactionalTest"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndDefaultNameTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeAndNameTests . txManager 1  . begun )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndNameTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndNameTests . txManager 1  . commits )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeAndNameTests . txManager 1  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndNameTests"}, {"methodBody": ["METHOD_START", "{", "LookUpTxMgrByTypeAndNameTests . txManager 1  . clear (  )  ;", "LookUpTxMgrByTypeAndNameTests . txManager 2  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndNameTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeAndNameTests . txManager 1  . begun )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeAndNameTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndNameTests . txManager 1  . commits )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndNameTests . txManager 1  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["transactionalTest"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndNameTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . begun )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . commits )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndQualifierAtClassLevelTests"}, {"methodBody": ["METHOD_START", "{", "LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . clear (  )  ;", "LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 2  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndQualifierAtClassLevelTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . begun )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . commits )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndQualifierAtClassLevelTests . txManager 1  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["transactionalTest"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndQualifierAtClassLevelTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . begun )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . commits )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndQualifierAtMethodLevelTests"}, {"methodBody": ["METHOD_START", "{", "LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . clear (  )  ;", "LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 2  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndQualifierAtMethodLevelTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . begun )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . commits )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeAndQualifierAtMethodLevelTests . txManager 1  . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["transactionalTest"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeAndQualifierAtMethodLevelTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeTests . txManager . begun )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeTests . txManager . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeTests . txManager . commits )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeTests . txManager . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeTests"}, {"methodBody": ["METHOD_START", "{", "LookUpTxMgrByTypeTests . txManager . clear (  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    LookUpTxMgrByTypeTests . txManager . begun )  ;", "assertEquals (  1  ,    LookUpTxMgrByTypeTests . txManager . inflight )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeTests . txManager . commits )  ;", "assertEquals (  0  ,    LookUpTxMgrByTypeTests . txManager . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["transactionalTest"], "fileName": "org.springframework.test.context.junit4.spr9645.LookUpTxMgrByTypeTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "new    ( statement ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["negativeTimeout"], "fileName": "org.springframework.test.context.junit4.statements.SpringFailOnTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "doAnswer (  (  ( Answer < Void >  )     (  (    invocation )     -  >     {", "return   null ;", "}  )  )  )  . when ( statement )  . evaluate (  )  ;", "new    ( statement ,     1  0  0  )  . evaluate (  )  ;", "}", "METHOD_END"], "methodName": ["noExceptionThrownIfNoUserExceptionAndTimeoutDoesNotOccur"], "fileName": "org.springframework.test.context.junit4.statements.SpringFailOnTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "new    ( null ,     1  )  ;", "}", "METHOD_END"], "methodName": ["nullNextStatement"], "fileName": "org.springframework.test.context.junit4.statements.SpringFailOnTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "doAnswer (  (  ( Answer < Void >  )     (  (    invocation )     -  >     {", "TimeUnit . MILLISECONDS . sleep (  5  0  )  ;", "return   null ;", "}  )  )  )  . when ( statement )  . evaluate (  )  ;", "exception . expect ( TimeoutException . class )  ;", "new    ( statement ,     1  )  . evaluate (  )  ;", "}", "METHOD_END"], "methodName": ["timeoutExceptionThrownIfNoUserException"], "fileName": "org.springframework.test.context.junit4.statements.SpringFailOnTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "doThrow ( new   SpringFailOnTimeoutTests . Boom (  )  )  . when ( statement )  . evaluate (  )  ;", "exception . expect ( SpringFailOnTimeoutTests . Boom . class )  ;", "new   SpringFailOnTimeout ( statement ,     1  )  . evaluate (  )  ;", "}", "METHOD_END"], "methodName": ["userExceptionPropagates"], "fileName": "org.springframework.test.context.junit4.statements.SpringFailOnTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "return   objects ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "org.springframework.test.context.support.AbstractContextConfigurationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" declaring   class \"  ,    expectedDeclaringClass ,    attributes . getDeclaringClass (  )  )  ;", "assertArrayEquals (  \" locations \"  ,    expectedLocations ,    attributes . getLocations (  )  )  ;", "assertArrayEquals (  \" classes \"  ,    expectedClasses ,    attributes . getClasses (  )  )  ;", "assertEquals (  \" inherit   locations \"  ,    expectedInheritLocations ,    attributes . isInheritLocations (  )  )  ;", "assertEquals (  \" context   loader \"  ,    expectedContextLoaderClass ,    attributes . geLoaderClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAttributes"], "fileName": "org.springframework.test.context.support.AbstractContextConfigurationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertMergedConfig ( mergedConfig ,    expectedTestClass ,    expectedLocations ,    expectedClasses ,    AbstractContextConfigurationUtilsTests . EMPTY _ INITIALIZER _ CLASSES ,    expectedContextLoaderClass )  ;", "}", "METHOD_END"], "methodName": ["assertMergedConfig"], "fileName": "org.springframework.test.context.support.AbstractContextConfigurationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( mergedConfig )  ;", "assertEquals ( expectedTestClass ,    mergedConfig . getTestClass (  )  )  ;", "assertNotNull ( mergedConfig . getLocations (  )  )  ;", "assertArrayEquals ( expectedLocations ,    mergedConfig . getLocations (  )  )  ;", "assertNotNull ( mergedConfig . getClasses (  )  )  ;", "assertArrayEquals ( expectedClasses ,    mergedConfig . getClasses (  )  )  ;", "assertNotNull ( mergedConfig . getActiveProfiles (  )  )  ;", "if    ( expectedContextLoaderClass    =  =    null )     {", "assertNull ( mergedConfig . geLoader (  )  )  ;", "} else    {", "assertEquals ( expectedContextLoaderClass ,    mergedConfig . geLoader (  )  . getClass (  )  )  ;", "}", "assertNotNull ( mergedConfig . geInitializerClasses (  )  )  ;", "assertEquals ( expectedInitializerClasses ,    mergedConfig . geInitializerClasses (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMergedConfig"], "fileName": "org.springframework.test.context.support.AbstractContextConfigurationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "CacheAwareContextLoaderDelegate   cacheAwareContextLoaderDelegate    =    Mockito . mock ( CacheAwareContextLoaderDelegate . class )  ;", "BootstrapContext   bootstrapContext    =    BootstrapTestUtils . buildBootstrapContext ( testClass ,    cacheAwareContextLoaderDelegate )  ;", "TestContextBootstrapper   bootstrapper    =    BootstrapTestUtils . resolveTestContextBootstrapper ( bootstrapContext )  ;", "return   bootstrapper . buildMerged (  )  ;", "}", "METHOD_END"], "methodName": ["buildMergedContextConfiguration"], "fileName": "org.springframework.test.context.support.AbstractContextConfigurationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "for    ( ContextCustomizer   contextCustomizer    :    mergedConfig . getContextCustomizers (  )  )     {", "contextCustomizer . customizeContext ( context ,    mergedConfig )  ;", "}", "}", "METHOD_END"], "methodName": ["customizeContext"], "fileName": "org.springframework.test.context.support.AbstractContextLoader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "String [  ]    suffixes    =    getResourceSuffixes (  )  ;", "for    ( String   suffix    :    suffixes )     {", "Assert . hasText ( suffix ,     \" Resource   suffix   must   not   be   empty \"  )  ;", "String   resourcePath    =     ( ClassUtils . convertClassNameToResourcePath ( clazz . getName (  )  )  )     +    suffix ;", "String   prefixedResourcePath    =     ( ResourceUtils . CLASSPATH _ URL _ PREFIX )     +    resourcePath ;", "ClassPathResource   classPathResource    =    new   ClassPathResource ( resourcePath )  ;", "if    ( classPathResource . exists (  )  )     {", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( String . format (  \" Detected   default   resource   location    \\  \"  % s \\  \"    for   test   class    [  % s ]  \"  ,    prefixedResourcePath ,    clazz . getName (  )  )  )  ;", "}", "return   new   String [  ]  {    prefixedResourcePath    }  ;", "} else", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  (  \" Did   not   detect   default   resource   location   for   test   class    [  % s ]  :     \"     +     \"  % s   does   not   exist \"  )  ,    clazz . getName (  )  ,    classPathResource )  )  ;", "}", "}", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( String . format (  (  \" Could   not   detect   default   resource   locations   for   test   class    [  % s ]  :     \"     +     \" no   resource   found   for   suffixes    % s .  \"  )  ,    clazz . getName (  )  ,    ObjectUtils . nullSafeToString ( suffixes )  )  )  ;", "}", "return    . EMPTY _ STRING _ ARRAY ;", "}", "METHOD_END"], "methodName": ["generateDefaultLocations"], "fileName": "org.springframework.test.context.support.AbstractContextLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  {    getResourceSuffix (  )     }  ;", "}", "METHOD_END"], "methodName": ["getResourceSuffixes"], "fileName": "org.springframework.test.context.support.AbstractContextLoader"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses    =    mergedConfig . getContextInitializerClasses (  )  ;", "if    ( initializerClasses . isEmpty (  )  )     {", "return ;", "}", "List < ApplicationContextInitializer < ConfigurableApplicationContext >  >    initializerInstances    =    new   ArrayList <  >  (  )  ;", "Class <  ?  >    contextClass    =    context . getClass (  )  ;", "for    ( Class <  ?    extends   ApplicationContextInitializer <  ?  >  >    initializerClass    :    initializerClasses )     {", "Class <  ?  >    initializerContextClass    =    GenericTypeResolver . resolveTypeArgument ( initializerClass ,    ApplicationContextInitializer . class )  ;", "if    (  ( initializerContextClass    !  =    null )     &  &     (  !  ( initializerContextClass . isInstance ( context )  )  )  )     {", "throw   new   ApplicationContextException ( String . format (  (  \" Could   not   apply   context   initializer    [  % s ]    since   its   generic   parameter    [  % s ]     \"     +     (  \" is   not   assignable   from   the   type   of   application   context   used   by   this    \"     +     \" context   loader :     [  % s ]  \"  )  )  ,    initializerClass . getName (  )  ,    initializerContextClass . getName (  )  ,    contextClass . getName (  )  )  )  ;", "}", "initializerInstances . add (  (  ( ApplicationContextInitializer < ConfigurableApplicationContext >  )     ( BeanUtils . instantiateClass ( initializerClass )  )  )  )  ;", "}", "AnnotationAwareOrderComparator . sort ( initializerInstances )  ;", "for    ( ApplicationContextInitializer < ConfigurableApplicationContext >    initializer    :    initializerInstances )     {", "initializer . initialize ( context )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeApplicationContextInitializers"], "fileName": "org.springframework.test.context.support.AbstractContextLoader"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isGenerateDefaultLocations"], "fileName": "org.springframework.test.context.support.AbstractContextLoader"}, {"methodBody": ["METHOD_START", "{", "return   TestContextResourceUtils . convertToClasspathResourcePaths ( clazz ,    locations )  ;", "}", "METHOD_END"], "methodName": ["modifyLocations"], "fileName": "org.springframework.test.context.support.AbstractContextLoader"}, {"methodBody": ["METHOD_START", "{", "context . getEnvironment (  )  . setActiveProfiles ( mergedConfig . getActiveProfiles (  )  )  ;", "TestPropertySourceUtils . addPropertiesFilesToEnvironment ( context ,    mergedConfig . getPropertySourceLocations (  )  )  ;", "TestPropertySourceUtils . addInlinedPropertiesToEnvironment ( context ,    mergedConfig . getPropertySourceProperties (  )  )  ;", "invokeApplicationContextInitializers ( context ,    mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["prepareContext"], "fileName": "org.springframework.test.context.support.AbstractContextLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( AbstractDelegatingSmartContextLoader . logger . isDebugEnabled (  )  )     {", "AbstractDelegatingSmartContextLoader . logger . debug ( String . format (  \" Delegating   to    % s   to   load   context   from    % s .  \"  ,    AbstractDelegatingSmartContextLoader . name ( loader )  ,    mergedConfig )  )  ;", "}", "return   loader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["delegateLoading"], "fileName": "org.springframework.test.context.support.AbstractDelegatingSmartContextLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( AbstractDelegatingSmartContextLoader . logger . isDebugEnabled (  )  )     {", "AbstractDelegatingSmartContextLoader . logger . debug ( String . format (  \" Delegating   to    % s   to   process   context   configuration    % s .  \"  ,    AbstractDelegatingSmartContextLoader . name ( loader )  ,    configAttributes )  )  ;", "}", "loader . processContextConfiguration ( configAttributes )  ;", "}", "METHOD_END"], "methodName": ["delegateProcessing"], "fileName": "org.springframework.test.context.support.AbstractDelegatingSmartContextLoader"}, {"methodBody": ["METHOD_START", "{", "return   loader . getClass (  )  . getSimpleName (  )  ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "org.springframework.test.context.support.AbstractDelegatingSmartContextLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( loader    =  =     ( getAnnotationConfigLoader (  )  )  )     {", "return    ( mergedConfig . hasClasses (  )  )     &  &     (  !  ( mergedConfig . hasLocations (  )  )  )  ;", "} else    {", "return    ( mergedConfig . hasLocations (  )  )     &  &     (  !  ( mergedConfig . hasClasses (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.test.context.support.AbstractDelegatingSmartContextLoader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testContext ,     \" TestContext   must   not   be   null \"  )  ;", "Assert . notNull ( requiredClassMode ,     \" requiredClassMode   must   not   be   null \"  )  ;", "Class <  ?  >    testClass    =    testContext . getTestClass (  )  ;", "Assert . notNull ( testClass ,     \" The   test   class   of   the   supplied   TestContext   must   not   be   null \"  )  ;", "DirtiesContext   dirtiesContext    =    AnnotatedElementUtils . findMergedAnnotation ( testClass ,    DirtiesContext . class )  ;", "boolean   classAnnotated    =    dirtiesContext    !  =    null ;", "DirtiesContext . ClassMode   classMode    =     ( classAnnotated )     ?    dirtiesContext . classMode (  )     :    null ;", "if    (  . logger . isDebugEnabled (  )  )     {", "String   phase    =     ( requiredClassMode . name (  )  . startsWith (  \" BEFORE \"  )  )     ?     \" Before \"     :     \" After \"  ;", ". logger . debug ( String . format (  \"  % s   test   class :    context    % s ,    class   annotated   with    @ DirtiesContext    [  % s ]    with   mode    [  % s ]  .  \"  ,    phase ,    testContext ,    classAnnotated ,    classMode )  )  ;", "}", "if    ( classMode    =  =    requiredClassMode )     {", "dirtyContext ( testContext ,    dirtiesContext . hierarchyMode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["beforeOrAfterTestClass"], "fileName": "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testContext ,     \" TestContext   must   not   be   null \"  )  ;", "Assert . notNull ( requiredMethodMode ,     \" requiredMethodMode   must   not   be   null \"  )  ;", "Assert . notNull ( requiredClassMode ,     \" requiredClassMode   must   not   be   null \"  )  ;", "Class <  ?  >    testClass    =    testContext . getTestClass (  )  ;", "Method   testMethod    =    testContext . getTestMethod (  )  ;", "Assert . notNull ( testClass ,     \" The   test   class   of   the   supplied   TestContext   must   not   be   null \"  )  ;", "Assert . notNull ( testMethod ,     \" The   test   method   of   the   supplied   TestContext   must   not   be   null \"  )  ;", "DirtiesContext   methodAnn    =    AnnotatedElementUtils . findMergedAnnotation ( testMethod ,    DirtiesContext . class )  ;", "DirtiesContext   classAnn    =    AnnotatedElementUtils . findMergedAnnotation ( testClass ,    DirtiesContext . class )  ;", "boolean   methodAnnotated    =    methodAnn    !  =    null ;", "boolean   classAnnotated    =    classAnn    !  =    null ;", "DirtiesContext . MethodMode   methodMode    =     ( methodAnnotated )     ?    methodAnn . methodMode (  )     :    null ;", "DirtiesContext . ClassMode   classMode    =     ( classAnnotated )     ?    classAnn . classMode (  )     :    null ;", "if    (  . logger . isDebugEnabled (  )  )     {", "String   phase    =     ( requiredClassMode . name (  )  . startsWith (  \" BEFORE \"  )  )     ?     \" Before \"     :     \" After \"  ;", ". logger . debug ( String . format (  (  \"  % s   test   method :    context    % s ,    class   annotated   with    @ DirtiesContext    [  % s ]     \"     +     \" with   mode    [  % s ]  ,    method   annotated   with    @ DirtiesContext    [  % s ]    with   mode    [  % s ]  .  \"  )  ,    phase ,    testContext ,    classAnnotated ,    classMode ,    methodAnnotated ,    methodMode )  )  ;", "}", "if    (  ( methodMode    =  =    requiredMethodMode )     |  |     ( classMode    =  =    requiredClassMode )  )     {", "DirtiesContext . HierarchyMode   hierarchyMode    =     ( methodAnnotated )     ?    methodAnn . hierarchyMode (  )     :    classAnn . hierarchyMode (  )  ;", "dirtyContext ( testContext ,    hierarchyMode )  ;", "}", "}", "METHOD_END"], "methodName": ["beforeOrAfterTestMethod"], "fileName": "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "testContext . markApplicationContextDirty ( hierarchyMode )  ;", "testContext . setAttribute ( DependencyInjection . REINJECT _ DEPENDENCIES _ ATTRIBUTE ,    Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["dirtyContext"], "fileName": "org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "createBeanDefinitionReader ( context )  . loadBeanDefinitions ( mergedConfig . getLocations (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.test.context.support.AbstractGenericContextLoader"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . stream ( collections )  . allMatch ( Collection :  : isEmpty )  ;", "}", "METHOD_END"], "methodName": ["areAllEmpty"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "List < ContextConfigurationAttributes >    defaultConfigAttributesList    =    Collections . singletonList ( new   ContextConfigurationAttributes ( testClass )  )  ;", "ContextLoader   contextLoader    =    resolveContextLoader ( testClass ,    defaultConfigAttributesList )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info ( String . format (  \" Neither    @ ContextConfiguration   nor    @ ContextHierarchy   found   for   test   class    [  % s ]  ,    using    % s \"  ,    testClass . getName (  )  ,    contextLoader . getClass (  )  . getSimpleName (  )  )  )  ;", "}", "return   buildMergedContextConfiguration ( testClass ,    defaultConfigAttributesList ,    null ,    cacheAwareContextLoaderDelegate ,    false )  ;", "}", "METHOD_END"], "methodName": ["buildDefaultMergedContextConfiguration"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( configAttributesList ,     \" ContextConfigurationAttributes   list   must   not   be   null   or   empty \"  )  ;", "ContextLoader   contextLoader    =    resolveContextLoader ( testClass ,    configAttributesList )  ;", "List < String >    locations    =    new   ArrayList <  >  (  )  ;", "List < Class <  ?  >  >    classes    =    new   ArrayList <  >  (  )  ;", "List < Class <  ?  >  >    initializers    =    new   ArrayList <  >  (  )  ;", "for    ( ContextConfigurationAttributes   configAttributes    :    configAttributesList )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace ( String . format (  \" Processing   locations   and   classes   for   context   configuration   attributes    % s \"  ,    configAttributes )  )  ;", "}", "if    ( contextLoader   instanceof   SmartContextLoader )     {", "SmartContextLoader   smartContextLoader    =     (  ( SmartContextLoader )     ( contextLoader )  )  ;", "smartContextLoader . processContextConfiguration ( configAttributes )  ;", "locations . addAll (  0  ,    Arrays . asList ( configAttributes . getLocations (  )  )  )  ;", "classes . addAll (  0  ,    Arrays . asList ( configAttributes . getClasses (  )  )  )  ;", "} else    {", "String [  ]    processedLocations    =    contextLoader . processLocations ( configAttributes . getDeclaringClass (  )  ,    configAttributes . getLocations (  )  )  ;", "locations . addAll (  0  ,    Arrays . asList ( processedLocations )  )  ;", "}", "initializers . addAll (  0  ,    Arrays . asList ( configAttributes . getInitializers (  )  )  )  ;", "if    (  !  ( configAttributes . isInheritLocations (  )  )  )     {", "break ;", "}", "}", "Set < ContextCustomizer >    contextCustomizers    =    getContextCustomizers ( testClass ,    Collections . unmodifiableList ( configAttributesList )  )  ;", "Assert . state (  (  !  ( requireLocationsClassesOrInitializers    &  &     (  . areAllEmpty ( locations ,    classes ,    initializers ,    contextCustomizers )  )  )  )  ,     (  )     -  >    String . format (  (  \"  % s   was   unable   to   detect   defaults ,    and   no   ApplicationContextInitializers    \"     +     \" or   ContextCustomizers   were   declared   for   context   configuration   attributes    % s \"  )  ,    contextLoader . getClass (  )  . getSimpleName (  )  ,    configAttributesList )  )  ;", "MergedTestPropertySources   mergedTestPropertySources    =    TestPropertySourceUtils . buildMergedTestPropertySources ( testClass )  ;", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( testClass ,    StringUtils . toStringArray ( locations )  ,    ClassUtils . toClassArray ( classes )  ,    ApplicationContextInitializerUtils . resolveInitializerClasses ( configAttributesList )  ,    ActiveProfilesUtils . resolveActiveProfiles ( testClass )  ,    mergedTestPropertySources . getLocations (  )  ,    mergedTestPropertySources . getProperties (  )  ,    contextCustomizers ,    contextLoader ,    cacheAwareContextLoaderDelegate ,    parentConfig )  ;", "return   processMergedContextConfiguration ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["buildMergedContextConfiguration"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "return   getBootstrapContext (  )  . getCacheAwareContextLoaderDelegate (  )  ;", "}", "METHOD_END"], "methodName": ["getCacheAwareContextLoaderDelegate"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "return   SpringFactoriesLoader . loadFactories ( ContextCustomizerFactory . class ,    getClass (  )  . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["getContextCustomizerFactories"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "List < ContextCustomizerFactory >    factories    =    getContextCustomizerFactories (  )  ;", "Set < ContextCustomizer >    customizers    =    new   LinkedHashSet <  >  ( factories . size (  )  )  ;", "for    ( ContextCustomizerFactory   factory    :    factories )     {", "ContextCustomizer   customizer    =    factory . createContextCustomizer ( testClass ,    configAttributes )  ;", "if    ( customizer    !  =    null )     {", "customizers . add ( customizer )  ;", "}", "}", "return   customizers ;", "}", "METHOD_END"], "methodName": ["getContextCustomizers"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "List < String >    classNames    =    SpringFactoriesLoader . loadFactoryNames ( TestExecutionListener . class ,    getClass (  )  . getClassLoader (  )  )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info ( String . format (  \" Loaded   default   TestExecutionListener   class   names   from   location    [  % s ]  :     % s \"  ,    FACTORIES _ RESOURCE _ LOCATION ,    classNames )  )  ;", "}", "return   Collections . unmodifiableList ( classNames )  ;", "}", "METHOD_END"], "methodName": ["getDefaultTestExecutionListenerClassNames"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?    extends   TestExecutionListener >  >    defaultListenerClasses    =    new   LinkedHashSet <  >  (  )  ;", "ClassLoader   cl    =    getClass (  )  . getClassLoader (  )  ;", "for    ( String   className    :    getDefaulExecutionListenerClassNames (  )  )     {", "try    {", "defaultListenerClasses . add (  (  ( Class <  ?    extends   TestExecutionListener >  )     ( ClassUtils . forName ( className ,    cl )  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Could   not   load   default   TestExecutionListener   class    [  \"     +    className )     +     \"  ]  .    Specify   custom   listener   classes   or   make   the   default   listener   classes   available .  \"  )  ,    ex )  ;", "}", "}", "}", "return   defaultListenerClasses ;", "}", "METHOD_END"], "methodName": ["getDefaultTestExecutionListenerClasses"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "List < TestExecutionListener >    listeners    =    new   ArrayList <  >  ( classes . size (  )  )  ;", "for    ( Class <  ?    extends   TestExecutionListener >    listenerClass    :    classes )     {", "try    {", "listeners . add ( BeanUtils . instantiateClass ( listenerClass )  )  ;", "}    catch    ( BeanInstantiationException   ex )     {", "if    (  ( ex . getCause (  )  )    instanceof   NoClassDefFoundError )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug ( String . format (  (  \" Skipping   candidate   TestExecutionListener    [  % s ]    due   to   a   missing   dependency .     \"     +     (  \" Specify   custom   listener   classes   or   make   the   default   listener   classes    \"     +     \" and   their   required   dependencies   available .    Offending   class :     [  % s ]  \"  )  )  ,    listenerClass . getName (  )  ,    ex . getCause (  )  . getMessage (  )  )  )  ;", "}", "} else    {", "throw   ex ;", "}", "}", "}", "return   listeners ;", "}", "METHOD_END"], "methodName": ["instantiateListeners"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "return   mergedConfig ;", "}", "METHOD_END"], "methodName": ["processMergedContextConfiguration"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testClass ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( configAttributesList ,     \" ContextConfigurationAttributes   list   must   not   be   null \"  )  ;", "Class <  ?    extends   ContextLoader >    contextLoaderClass    =    resolveExpliciLoaderClass ( configAttributesList )  ;", "if    ( contextLoaderClass    =  =    null )     {", "contextLoaderClass    =    getDefaulLoaderClass ( testClass )  ;", "}", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace ( String . format (  \" Using   ContextLoader   class    [  % s ]    for   test   class    [  % s ]  \"  ,    contextLoaderClass . getName (  )  ,    testClass . getName (  )  )  )  ;", "}", "return   BeanUtils . instantiateClass ( contextLoaderClass ,    ContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["resolveContextLoader"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( configAttributesList ,     \" ContextConfigurationAttributes   list   must   not   be   null \"  )  ;", "for    ( ContextConfigurationAttributes   configAttributes    :    configAttributesList )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace ( String . format (  \" Resolving   ContextLoader   for   context   configuration   attributes    % s \"  ,    configAttributes )  )  ;", "}", "Class <  ?    extends   ContextLoader >    contextLoaderClass    =    configAttributes . geLoaderClass (  )  ;", "if    (  ( ContextLoader . class )     !  =    contextLoaderClass )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug ( String . format (  \" Found   explicit   ContextLoader   class    [  % s ]    for   context   configuration   attributes    % s \"  ,    contextLoaderClass . getName (  )  ,    configAttributes )  )  ;", "}", "return   contextLoaderClass ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveExplicitContextLoaderClass"], "fileName": "org.springframework.test.context.support.AbstractTestContextBootstrapper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testClass ,     \" Class   must   not   be   null \"  )  ;", "final   List < String [  ]  >    profileArrays    =    new   ArrayList <  >  (  )  ;", "Class < ActiveProfiles >    annotationType    =    ActiveProfiles . class ;", "MetaAnnotationUtils . AnnotationDescriptor < ActiveProfiles >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( testClass ,    annotationType )  ;", "if    (  ( descriptor    =  =    null )     &  &     (  . logger . isDebugEnabled (  )  )  )     {", ". logger . debug ( String . format (  \" Could   not   find   an    ' annotation   declaring   class '    for   annotation   type    [  % s ]    and   class    [  % s ]  \"  ,    annotationType . getName (  )  ,    testClass . getName (  )  )  )  ;", "}", "while    ( descriptor    !  =    null )     {", "Class <  ?  >    rootDeclaringClass    =    descriptor . getRootDeclaringClass (  )  ;", "Class <  ?  >    declaringClass    =    descriptor . getDeclaringClass (  )  ;", "ActiveProfiles   annotation    =    descriptor . synthesizeAnnotation (  )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace ( String . format (  \" Retrieved    @ ActiveProfiles    [  % s ]    for   declaring   class    [  % s ]  \"  ,    annotation ,    declaringClass . getName (  )  )  )  ;", "}", "Class <  ?    extends   ActiveProfilesResolver >    resolverClass    =    annotation . resolver (  )  ;", "if    (  ( ActiveProfilesResolver . class )     =  =    resolverClass )     {", "resolverClass    =    DefaultActiveProfilesResolver . class ;", "}", "ActiveProfilesResolver   resolver ;", "try    {", "resolver    =    BeanUtils . instantiateClass ( resolverClass ,    ActiveProfilesResolver . class )  ;", "}    catch    ( Exception   ex )     {", "String   msg    =    String . format (  (  \" Could   not   instantiate   ActiveProfilesResolver   of   type    [  % s ]     \"     +     \" for   test   class    [  % s ]  \"  )  ,    resolverClass . getName (  )  ,    rootDeclaringClass . getName (  )  )  ;", ". logger . error ( msg )  ;", "throw   new   IllegalStateException ( msg ,    ex )  ;", "}", "String [  ]    profiles    =    resolver . resolve ( rootDeclaringClass )  ;", "if    (  !  ( ObjectUtils . isEmpty ( profiles )  )  )     {", "profileArrays . add ( profiles )  ;", "}", "descriptor    =     ( annotation . inheritProfiles (  )  )     ?    MetaAnnotationUtils . findAnnotationDescriptor ( rootDeclaringClass . getSuperclass (  )  ,    annotationType )     :    null ;", "}", "Collections . reverse ( profileArrays )  ;", "final   Set < String >    activeProfiles    =    new   LinkedHashSet <  >  (  )  ;", "for    ( String [  ]    profiles    :    profileArrays )     {", "for    ( String   profile    :    profiles )     {", "if    ( StringUtils . hasText ( profile )  )     {", "activeProfiles . add ( profile . trim (  )  )  ;", "}", "}", "}", "return   StringUtils . toStringArray ( activeProfiles )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfiles"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtils"}, {"methodBody": ["METHOD_START", "{", "assertArrayEquals ( expected ,    ActiveProfilesUtils . resolveActiveProfiles ( testClass )  )  ;", "}", "METHOD_END"], "methodName": ["assertResolvedProfiles"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ActiveProfilesUtils . resolveActiveProfiles ( ActiveProfilesUtilsTests . ConflictingProfilesAndValueTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithConflictingProfilesAndValue"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . DefaultActiveProfilesResolverTestCase . class ,     \" default \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithDefaultActiveProfilesResolver"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . DuplicatedProfiles . class ,     \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithDuplicatedProfiles"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . EmptyProfiles . class ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithEmptyProfiles"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . ExtendedDefaultActiveProfilesResolverTestCase . class ,     \" default \"  ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithExtendedDefaultActiveProfilesResolver"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . InheritedClassesFoo . class ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithInheritedAnnotationAndClasses"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . InheritedLocationsFoo . class ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithInheritedAnnotationAndLocations"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . InheritedFooActiveProfilesResolverTestCase . class ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithInheritedResolver"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( AbstractContextConfigurationUtilsTests . LocationsBar . class ,     \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithLocalAndInheritedAnnotations"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . ExtendedDuplicatedProfiles . class ,     \" foo \"  ,     \" bar \"  ,     \" baz \"  ,     \" cat \"  ,     \" dog \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithLocalAndInheritedDuplicatedProfiles"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( AbstractContextConfigurationUtilsTests . MetaLocationsBar . class ,     \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithLocalAndInheritedMetaAnnotations"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( AbstractContextConfigurationUtilsTests . LocationsFoo . class ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithLocalAnnotation"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . MergedInheritedFooActiveProfilesResolverTestCase . class ,     \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithMergedInheritedResolver"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( AbstractContextConfigurationUtilsTests . MetaLocationsFoo . class ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithMetaAnnotation"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( AbstractContextConfigurationUtilsTests . MetaLocationsFooWithOverriddenAttributes . class ,     \" foo 1  \"  ,     \" foo 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithMetaAnnotationAndOverriddenAttributes"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( AbstractContextConfigurationUtilsTests . MetaLocationsFooWithOverrides . class ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithMetaAnnotationAndOverrides"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < ActiveProfilesUtilsTests . TestClassVerifyingActiveProfilesResolverTestCase >    testClass    =    ActiveProfilesUtilsTests . TestClassVerifyingActiveProfilesResolverTestCase . class ;", "assertResolvedProfiles ( testClass ,    testClass . getSimpleName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithMetaAnnotationAndTestClassVerifyingResolver"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( AbstractContextConfigurationUtilsTests . BareAnnotations . class ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithNoProfilesDeclared"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . Animals . class ,     \" dog \"  ,     \" cat \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithOverriddenAnnotation"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . MetaAnimals . class ,     \" dog \"  ,     \" cat \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithOverriddenMetaAnnotation"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . OverridenInheritedFooActiveProfilesResolverTestCase . class ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithOverridenInheritedResolver"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . FooActiveProfilesResolverTestCase . class ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithResolver"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . ResolverAndProfilesTestCase . class ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithResolverAndProfiles"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . ResolverAndValueTestCase . class ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithResolverAndValue"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( ActiveProfilesUtilsTests . NullActiveProfilesResolverTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithResolverThatReturnsNull"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ActiveProfilesUtils . resolveActiveProfiles ( ActiveProfilesUtilsTests . NoDefaultConstructorActiveProfilesResolverTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithResolverWithoutDefaultConstructor"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertResolvedProfiles ( AbstractContextConfigurationUtilsTests . Enigma . class ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["resolveActiveProfilesWithoutAnnotation"], "fileName": "org.springframework.test.context.support.ActiveProfilesUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationConfigContextLoaderUtils . detectDefaultConfigurationClasses ( declaringClass )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClasses"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoader"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( containsString (  \" does   not   support   resource   locations \"  )  )  ;", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" config . xml \"     }  ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    contextLoader )  ;", "contextLoader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["configMustNotContainLocations"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    contextLoader . detectDefaultConfigurationClasses ( ContextConfigurationInnerClassTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertEquals (  \" annotated   static   ContextConfiguration   should   be   considered .  \"  ,     1  ,    configClasses . length )  ;", "configClasses    =    contextLoader . detectDefaultConfigurationClasses ( AnnotatedFooConfigInnerClassTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertEquals (  \" annotated   static   FooConfig   should   be   considered .  \"  ,     1  ,    configClasses . length )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesForAnnotatedInnerClass"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    contextLoader . detectDefaultConfigurationClasses ( FinalConfigInnerClassTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertEquals (  \" final   annotated   static   Config   should   NOT   be   considered .  \"  ,     0  ,    configClasses . length )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesForFinalAnnotatedInnerClass"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    contextLoader . detectDefaultConfigurationClasses ( MultipleStaticConfigurationClassesTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertEquals (  \" multiple   annotated   static   classes   should   be   considered .  \"  ,     2  ,    configClasses . length )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesForMultipleAnnotatedInnerClasses"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    contextLoader . detectDefaultConfigurationClasses ( PlainVanillaFooConfigInnerClassTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertEquals (  \" non - annotated   static   FooConfig   should   NOT   be   considered .  \"  ,     0  ,    configClasses . length )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesForNonAnnotatedInnerClass"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    contextLoader . detectDefaultConfigurationClasses ( NonStaticConfigInnerClassesTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertEquals (  \" non - static   annotated   inner   classes   should   NOT   be   considered .  \"  ,     0  ,    configClasses . length )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesForNonStaticAnnotatedInnerClass"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    contextLoader . detectDefaultConfigurationClasses ( PrivateConfigInnerClassTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertEquals (  \" private   annotated   inner   classes   should   NOT   be   considered .  \"  ,     0  ,    configClasses . length )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesForPrivateAnnotatedInnerClass"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( declaringClass ,     \" Declaring   class   must   not   be   null \"  )  ;", "List < Class <  ?  >  >    configClasses    =    new   ArrayList <  >  (  )  ;", "for    ( Class <  ?  >    candidate    :    declaringClass . getDeclaredClasses (  )  )     {", "if    (  . isDefaultConfigurationClassCandidate ( candidate )  )     {", "configClasses . add ( candidate )  ;", "} else    {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  (  \" Ignoring   class    [  % s ]  ;    it   must   be   static ,    non - private ,    non - final ,    and   annotated    \"     +     \" with    @ Configuration   to   be   considered   a   default   configuration   class .  \"  )  ,    candidate . getName (  )  )  )  ;", "}", "}", "}", "if    ( configClasses . isEmpty (  )  )     {", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( String . format (  (  \" Could   not   detect   default   configuration   classes   for   test   class    [  % s ]  :     \"     +     (  \"  % s   does   not   declare   any   static ,    non - private ,    non - final ,    nested   classes    \"     +     \" annotated   with    @ Configuration .  \"  )  )  ,    declaringClass . getName (  )  ,    declaringClass . getSimpleName (  )  )  )  ;", "}", "}", "return   ClassUtils . toClassArray ( configClasses )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClasses"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( clazz    !  =    null )     &  &     ( AnnotationConfigContextLoaderUtils . isStaticNonPrivateAndNonFinal ( clazz )  )  )     &  &     ( AnnotatedElementUtils . hasAnnotation ( clazz ,    Configuration . class )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultConfigurationClassCandidate"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "int   modifiers    =    clazz . getModifiers (  )  ;", "return    (  ( Modifier . isSc ( modifiers )  )     &  &     (  !  ( Modifier . isPrivate ( modifiers )  )  )  )     &  &     (  !  ( Modifier . isFinal ( modifiers )  )  )  ;", "}", "METHOD_END"], "methodName": ["isStaticNonPrivateAndNonFinal"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    AnnotationConfigContextLoaderUtils . detectDefaultConfigurationClasses ( AnnotationConfigContextLoaderUtilsTests . MetaAnnotatedConfigTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    AnnotationConfigContextLoaderUtilsTests . MetaAnnotatedConfigTestCase . Config . class    }  ,    configClasses )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesWithConfigurationMetaAnnotation"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    AnnotationConfigContextLoaderUtils . detectDefaultConfigurationClasses ( AnnotationConfigContextLoaderUtilsTests . ExplicitConfigTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    AnnotationConfigContextLoaderUtilsTests . ExplicitConfigTestCase . Config . class    }  ,    configClasses )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesWithExplicitConfigurationAnnotation"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigContextLoaderUtils . detectDefaultConfigurationClasses ( null )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesWithNullDeclaringClass"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    configClasses    =    AnnotationConfigContextLoaderUtils . detectDefaultConfigurationClasses ( AnnotationConfigContextLoaderUtilsTests . NoConfigTestCase . class )  ;", "assertNotNull ( configClasses )  ;", "assertEquals (  0  ,    configClasses . length )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClassesWithoutConfigurationClass"], "fileName": "org.springframework.test.context.support.AnnotationConfigContextLoaderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( configAttributesList ,     \" ContextConfigurationAttributes   List   must   not   be   empty \"  )  ;", "Set < Class <  ?    extends   ApplicationContextInitializer <  ?  >  >  >    initializerClasses    =    new   LinkedHashSet <  >  (  )  ;", "for    ( ContextConfigurationAttributes   configAttributes    :    configAttributesList )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  \" Processing   context   initializers   for   configuration   attributes    \"     +    configAttributes )  )  ;", "}", "Collections . addAll ( initializerClasses ,    configAttributes . getInitializers (  )  )  ;", "if    (  !  ( configAttributes . isInheritInitializers (  )  )  )     {", "break ;", "}", "}", "return   initializerClasses ;", "}", "METHOD_END"], "methodName": ["resolveInitializerClasses"], "fileName": "org.springframework.test.context.support.ApplicationContextInitializerUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    BootstrapTestUtilsContextInitializerTests . InitializersBar . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assertMergedConfig ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    classes ( AbstractContextConfigurationUtilsTests . FooConfig . class ,    AbstractContextConfigurationUtilsTests . BarConfig . class )  ,    initializers ( BootstrapTestUtilsContextInitializerTests . FooInitializer . class ,    BootstrapTestUtilsContextInitializerTests . BarInitializer . class )  ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithLocalAndInheritedInitializer"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsContextInitializerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    BootstrapTestUtilsContextInitializerTests . InitializersFoo . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assertMergedConfig ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    classes ( AbstractContextConfigurationUtilsTests . FooConfig . class )  ,    initializers ( BootstrapTestUtilsContextInitializerTests . FooInitializer . class )  ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithLocalInitializerAndConfigClass"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsContextInitializerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    BootstrapTestUtilsContextInitializerTests . OverriddenInitializersBar . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assertMergedConfig ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    classes ( AbstractContextConfigurationUtilsTests . FooConfig . class ,    AbstractContextConfigurationUtilsTests . BarConfig . class )  ,    initializers ( BootstrapTestUtilsContextInitializerTests . BarInitializer . class )  ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithOverriddenInitializers"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsContextInitializerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    BootstrapTestUtilsContextInitializerTests . OverriddenInitializersAndClassesBar . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assertMergedConfig ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    classes ( AbstractContextConfigurationUtilsTests . BarConfig . class )  ,    initializers ( BootstrapTestUtilsContextInitializerTests . BarInitializer . class )  ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithOverriddenInitializersAndClasses"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsContextInitializerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    BootstrapTestUtilsContextInitializerTests . SingleInitializer . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assertMergedConfig ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    initializers ( BootstrapTestUtilsContextInitializerTests . FooInitializer . class )  ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithSingleLocalInitializer"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsContextInitializerTests"}, {"methodBody": ["METHOD_START", "{", "return   classes ;", "}", "METHOD_END"], "methodName": ["classes"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsContextInitializerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   HashSet ( Arrays . asList ( classes )  )  ;", "}", "METHOD_END"], "methodName": ["initializers"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsContextInitializerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . Enigma . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildImplicitMergedConfigWithoutAnnotation"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . OverriddenClassesBar . class ;", "Class <  ?  >  [  ]    expectedClasses    =    AbstractContextConfigurationUtilsTests . array ( AbstractContextConfigurationUtilsTests . BarConfig . class )  ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    expectedClasses ,    AnnotationConfigContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithAnnotationsAndOverriddenClasses"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . OverriddenLocationsBar . class ;", "String [  ]    expectedLocations    =    AbstractContextConfigurationUtilsTests . array (  \"  / bar . xml \"  )  ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    expectedLocations ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    AnnotationConfigContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithAnnotationsAndOverriddenLocations"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    webTestClass    =    AbstractContextConfigurationUtilsTests . WebClassesFoo . class ;", "Class <  ?  >    standardTestClass    =    AbstractContextConfigurationUtilsTests . ClassesFoo . class ;", "WebMergedContextConfiguration   web    =     (  ( WebMergedContextConfiguration )     ( buildMergedContextConfiguration ( webTestClass )  )  )  ;", "MergedContextConfiguration   standard    =    buildMergedContextConfiguration ( standardTestClass )  ;", "Assert . assertEquals ( web ,    web )  ;", "Assert . assertEquals ( standard ,    standard )  ;", "Assert . assertNotEquals ( standard ,    web )  ;", "Assert . assertNotEquals ( web ,    standard )  ;", "assert ( web ,    webTestClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    AbstractContextConfigurationUtilsTests . array ( AbstractContextConfigurationUtilsTests . FooConfig . class )  ,    WebDelegatingSmartContextLoader . class )  ;", "assert ( standard ,    standardTestClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    AbstractContextConfigurationUtilsTests . array ( AbstractContextConfigurationUtilsTests . FooConfig . class )  ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithAtWebAppConfigurationWithAnnotationAndClassesOnSuperclass"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . BareAnnotations . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assertMergedConfig ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . array (  \" classpath : org /  / test / context / support / AbstractContextConfigurationUtilsTests $ BareAnnotations - context . xml \"  )  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithBareAnnotations"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( CoreMatchers . startsWith (  (  \" DelegatingSmartContextLoader   was   unable   to   detect   defaults ,     \"     +     \" and   no   ApplicationContextInitializers   or   ContextCustomizers   were   declared   for   context   configuration   attributes \"  )  )  )  ;", "buildMergedContextConfiguration (  . MissingContextAttributesTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithContextConfigurationWithoutLocationsClassesOrInitializers"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . ClassesBar . class ;", "Class <  ?  >  [  ]    expectedClasses    =    AbstractContextConfigurationUtilsTests . array ( AbstractContextConfigurationUtilsTests . FooConfig . class ,    AbstractContextConfigurationUtilsTests . BarConfig . class )  ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    expectedClasses ,    AnnotationConfigContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithLocalAndInheritedAnnotationsAndClasses"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . LocationsBar . class ;", "String [  ]    expectedLocations    =    AbstractContextConfigurationUtilsTests . array (  \"  / foo . xml \"  ,     \"  / bar . xml \"  )  ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    expectedLocations ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    AnnotationConfigContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithLocalAndInheritedAnnotationsAndLocations"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . ClassesFoo . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    AbstractContextConfigurationUtilsTests . array ( AbstractContextConfigurationUtilsTests . FooConfig . class )  ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithLocalAnnotationAndClasses"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . LocationsFoo . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . array (  \" classpath :  / foo . xml \"  )  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithLocalAnnotationAndLocations"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . PropertiesClassesFoo . class ;", "Class <  ?    extends   ContextLoader >    expectedContextLoaderClass    =    GenericPropertiesContextLoader . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    AbstractContextConfigurationUtilsTests . array ( AbstractContextConfigurationUtilsTests . FooConfig . class )  ,    expectedContextLoaderClass )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithLocalAnnotationAndOverriddenContextLoaderAndClasses"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . PropertiesLocationsFoo . class ;", "Class <  ?    extends   ContextLoader >    expectedContextLoaderClass    =    GenericPropertiesContextLoader . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . array (  \" classpath :  / foo . properties \"  )  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    expectedContextLoaderClass )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithLocalAnnotationAndOverriddenContextLoaderAndLocations"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "buildMergedConfigWithMetaAnnotationAndClasses ( BootstrapTestUtilsMergedConfigTests . Dog . class )  ;", "buildMergedConfigWithMetaAnnotationAndClasses ( BootstrapTestUtilsMergedConfigTests . WorkingDog . class )  ;", "buildMergedConfigWithMetaAnnotationAndClasses ( BootstrapTestUtilsMergedConfigTests . GermanShepherd . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithMetaAnnotationAndClasses"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    AbstractContextConfigurationUtilsTests . array ( AbstractContextConfigurationUtilsTests . FooConfig . class ,    AbstractContextConfigurationUtilsTests . BarConfig . class )  ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithMetaAnnotationAndClasses"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    AbstractContextConfigurationUtilsTests . MetaLocationsFoo . class ;", "MergedContextConfiguration   mergedConfig    =    buildMergedContextConfiguration ( testClass )  ;", "assert ( mergedConfig ,    testClass ,    AbstractContextConfigurationUtilsTests . array (  \" classpath :  / foo . xml \"  )  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    DelegatingSmartContextLoader . class )  ;", "}", "METHOD_END"], "methodName": ["buildMergedConfigWithMetaAnnotationAndLocations"], "fileName": "org.springframework.test.context.support.BootstrapTestUtilsMergedConfigTests"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    List < ContextConfigurationAttributes >  >    map    =    new   LinkedHashMap <  >  (  )  ;", "int   hierarchyLevel    =     1  ;", "for    ( List < ContextConfigurationAttributes >    configAttributesList    :     . resolveContextHierarchyAttributes ( testClass )  )     {", "for    ( ContextConfigurationAttributes   configAttributes    :    configAttributesList )     {", "String   name    =    configAttributes . getName (  )  ;", "if    (  !  ( StringUtils . hasText ( name )  )  )     {", "name    =     (  . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +    hierarchyLevel ;", "}", "if    (  !  ( map . containsKey ( name )  )  )     {", "hierarchyLevel +  +  ;", "map . put ( name ,    new   ArrayList <  >  (  )  )  ;", "}", "map . get ( name )  . add ( configAttributes )  ;", "}", "}", "Set < List < ContextConfigurationAttributes >  >    set    =    new   HashSet <  >  ( map . values (  )  )  ;", "if    (  ( set . size (  )  )     !  =     ( map . size (  )  )  )     {", "String   msg    =    String . format (  (  \" The    @ ContextConfiguration   elements   configured   via    @ ContextHierarchy   in    \"     +     \" test   class    [  % s ]    and   its   superclasses   must   define   unique   contexts   per   hierarchy   level .  \"  )  ,    testClass . getName (  )  )  ;", ". logger . error ( msg )  ;", "throw   new   IllegalStateException ( msg )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["buildContextHierarchyMap"], "fileName": "org.springframework.test.context.support.ContextLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ContextLoaderUtils . logger . isTraceEnabled (  )  )     {", "ContextLoaderUtils . logger . trace ( String . format (  \" Retrieved    @ ContextConfiguration    [  % s ]    for   declaring   class    [  % s ]  .  \"  ,    contextConfiguration ,    declaringClass . getName (  )  )  )  ;", "}", "ContextConfigurationAttributes   attributes    =    new   ContextConfigurationAttributes ( declaringClass ,    contextConfiguration )  ;", "if    ( ContextLoaderUtils . logger . isTraceEnabled (  )  )     {", "ContextLoaderUtils . logger . trace (  (  \" Resolved   context   configuration   attributes :     \"     +    attributes )  )  ;", "}", "attributesList . add ( attributes )  ;", "}", "METHOD_END"], "methodName": ["convertContextConfigToConfigAttributesAndAddToList"], "fileName": "org.springframework.test.context.support.ContextLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testClass ,     \" Class   must   not   be   null \"  )  ;", "List < ContextConfigurationAttributes >    attributesList    =    new   ArrayList <  >  (  )  ;", "Class < ContextConfiguration >    annotationType    =    ContextConfiguration . class ;", "MetaAnnotationUtils . AnnotationDescriptor < ContextConfiguration >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( testClass ,    annotationType )  ;", "Assert . notNull ( descriptor ,     (  )     -  >    String . format (  \" Could   not   find   an    ' annotation   declaring   class '    for   annotation   type    [  % s ]    and   class    [  % s ]  \"  ,    annotationType . getName (  )  ,    testClass . getName (  )  )  )  ;", "while    ( descriptor    !  =    null )     {", ". convertContextConfigToConfigAttributesAndAddToList ( descriptor . synthesizeAnnotation (  )  ,    descriptor . getRootDeclaringClass (  )  ,    attributesList )  ;", "descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( descriptor . getRootDeclaringClass (  )  . getSuperclass (  )  ,    annotationType )  ;", "}", "return   attributesList ;", "}", "METHOD_END"], "methodName": ["resolveContextConfigurationAttributes"], "fileName": "org.springframework.test.context.support.ContextLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testClass ,     \" Class   must   not   be   null \"  )  ;", "Class < ContextConfiguration >    contextConfigType    =    ContextConfiguration . class ;", "Class < ContextHierarchy >    contextHierarchyType    =    ContextHierarchy . class ;", "List < List < ContextConfigurationAttributes >  >    hierarchyAttributes    =    new   ArrayList <  >  (  )  ;", "MetaAnnotationUtils . UntypedAnnotationDescriptor   desc    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( testClass ,    contextConfigType ,    contextHierarchyType )  ;", "Assert . notNull ( desc ,     (  )     -  >    String . format (  \" Could   not   find   an    ' annotation   declaring   class '    for   annotation   type    [  % s ]    or    [  % s ]    and   test   class    [  % s ]  \"  ,    contextConfigType . getName (  )  ,    contextHierarchyType . getName (  )  ,    testClass . getName (  )  )  )  ;", "while    ( desc    !  =    null )     {", "Class <  ?  >    rootDeclaringClass    =    desc . getRootDeclaringClass (  )  ;", "Class <  ?  >    declaringClass    =    desc . getDeclaringClass (  )  ;", "boolean   contextConfigDeclaredLocally    =    isAnnotationDeclaredLocally ( contextConfigType ,    declaringClass )  ;", "boolean   contextHierarchyDeclaredLocally    =    isAnnotationDeclaredLocally ( contextHierarchyType ,    declaringClass )  ;", "if    ( contextConfigDeclaredLocally    &  &    contextHierarchyDeclaredLocally )     {", "String   msg    =    String . format (  (  \" Class    [  % s ]    has   been   configured   with   both    @ ContextConfiguration    \"     +     (  \" and    @ ContextHierarchy .    Only   one   of   these   annotations   may   be   declared   on   a   test   class    \"     +     \" or   composed   annotation .  \"  )  )  ,    declaringClass . getName (  )  )  ;", ". logger . error ( msg )  ;", "throw   new   IllegalStateException ( msg )  ;", "}", "List < ContextConfigurationAttributes >    configAttributesList    =    new   ArrayList <  >  (  )  ;", "if    ( contextConfigDeclaredLocally )     {", "ContextConfiguration   contextConfiguration    =    AnnotationUtils . synthesizeAnnotation ( desc . getAnnotationAttributes (  )  ,    ContextConfiguration . class ,    desc . getRootDeclaringClass (  )  )  ;", ". convertContextConfigToConfigAttributesAndAddToList ( contextConfiguration ,    rootDeclaringClass ,    configAttributesList )  ;", "} else", "if    ( contextHierarchyDeclaredLocally )     {", "ContextHierarchy   contextHierarchy    =    getAnnotation ( declaringClass ,    contextHierarchyType )  ;", "if    ( contextHierarchy    !  =    null )     {", "for    ( ContextConfiguration   contextConfiguration    :    contextHierarchy . value (  )  )     {", ". convertContextConfigToConfigAttributesAndAddToList ( contextConfiguration ,    rootDeclaringClass ,    configAttributesList )  ;", "}", "}", "} else    {", "String   msg    =    String . format (  (  \" Test   class    [  % s ]    has   been   configured   with   neither    @ ContextConfiguration    \"     +     \" nor    @ ContextHierarchy   as   a   class - level   annotation .  \"  )  ,    rootDeclaringClass . getName (  )  )  ;", ". logger . error ( msg )  ;", "throw   new   IllegalStateException ( msg )  ;", "}", "hierarchyAttributes . add (  0  ,    configAttributesList )  ;", "desc    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( rootDeclaringClass . getSuperclass (  )  ,    contextConfigType ,    contextHierarchyType )  ;", "}", "return   hierarchyAttributes ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributes"], "fileName": "org.springframework.test.context.support.ContextLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "assertAttributes ( attributes ,    AbstractContextConfigurationUtilsTests . ClassesBar . class ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    new   Class <  ?  >  [  ]  {    AbstractContextConfigurationUtilsTests . BarConfig . class    }  ,    AnnotationConfigContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["assertClassesBarAttributes"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "assertAttributes ( attributes ,    AbstractContextConfigurationUtilsTests . ClassesFoo . class ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    new   Class <  ?  >  [  ]  {    AbstractContextConfigurationUtilsTests . FooConfig . class    }  ,    ContextLoader . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["assertClassesFooAttributes"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "assertAttributes ( attributes ,    AbstractContextConfigurationUtilsTests . LocationsBar . class ,    new   String [  ]  {     \"  / bar . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    AnnotationConfigContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["assertLocationsBarAttributes"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "assertAttributes ( attributes ,    AbstractContextConfigurationUtilsTests . LocationsFoo . class ,    new   String [  ]  {     \"  / foo . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["assertLocationsFooAttributes"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Class < AbstractContextConfigurationUtilsTests . BareAnnotations >    testClass    =    AbstractContextConfigurationUtilsTests . BareAnnotations . class ;", "List < Context >    attributesList    =    ContextLoaderUtils . resolveContext ( testClass )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  1  ,    attributesList . size (  )  )  ;", "assertAttributes ( attributesList . get (  0  )  ,    testClass ,    AbstractContextConfigurationUtilsTests . EMPTY _ STRING _ ARRAY ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithBareAnnotations"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( containsString (  . ConflictingLocations . class . getName (  )  )  )  ;", "exception . expectMessage ( either ( containsString (  \" attribute    ' value '    and   its   alias    ' locations '  \"  )  )  . or ( containsString (  \" attribute    ' locations '    and   its   alias    ' value '  \"  )  )  )  ;", "exception . expectMessage ( either ( containsString (  \" values   of    [  { x }  ]    and    [  { y }  ]  \"  )  )  . or ( containsString (  \" values   of    [  { y }  ]    and    [  { x }  ]  \"  )  )  )  ;", "exception . expectMessage ( containsString (  \" but   only   one   is   permitted \"  )  )  ;", "ContextLoaderUtils . resolveContextConfigurationAttributes (  . ConflictingLocations . class )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithConflictingLocations"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "List < ContextConfigurationAttributes >    attributesList    =    ContextLoaderUtils . resolveContextConfigurationAttributes ( AbstractContextConfigurationUtilsTests . ClassesBar . class )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  2  ,    attributesList . size (  )  )  ;", "assertClassesBarAttributes ( attributesList . get (  0  )  )  ;", "assertClassesFooAttributes ( attributesList . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithLocalAndInheritedAnnotationsAndClasses"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "List < ContextConfigurationAttributes >    attributesList    =    ContextLoaderUtils . resolveContextConfigurationAttributes ( AbstractContextConfigurationUtilsTests . LocationsBar . class )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  2  ,    attributesList . size (  )  )  ;", "assertLocationsBarAttributes ( attributesList . get (  0  )  )  ;", "assertLocationsFooAttributes ( attributesList . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithLocalAndInheritedAnnotationsAndLocations"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "List < ContextConfigurationAttributes >    attributesList    =    ContextLoaderUtils . resolveContextConfigurationAttributes ( AbstractContextConfigurationUtilsTests . ClassesFoo . class )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  1  ,    attributesList . size (  )  )  ;", "assertClassesFooAttributes ( attributesList . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithLocalAnnotationAndClasses"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "List < ContextConfigurationAttributes >    attributesList    =    ContextLoaderUtils . resolveContextConfigurationAttributes ( AbstractContextConfigurationUtilsTests . LocationsFoo . class )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  1  ,    attributesList . size (  )  )  ;", "assertLocationsFooAttributes ( attributesList . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithLocalAnnotationAndLocations"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "List < ContextConfigurationAttributes >    attributesList    =    ContextLoaderUtils . resolveContextConfigurationAttributes ( ContextLoaderUtilsConfigurationAttributesTests . LocationsAndClasses . class )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  1  ,    attributesList . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithLocationsAndClasses"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Class < AbstractContextConfigurationUtilsTests . MetaLocationsFoo >    testClass    =    AbstractContextConfigurationUtilsTests . MetaLocationsFoo . class ;", "List < Context >    attributesList    =    ContextLoaderUtils . resolveContext ( testClass )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  1  ,    attributesList . size (  )  )  ;", "assertAttributes ( attributesList . get (  0  )  ,    testClass ,    new   String [  ]  {     \"  / foo . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithMetaAnnotationAndLocations"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Class < AbstractContextConfigurationUtilsTests . MetaLocationsFooWithOverriddenAttributes >    testClass    =    AbstractContextConfigurationUtilsTests . MetaLocationsFooWithOverriddenAttributes . class ;", "List < Context >    attributesList    =    ContextLoaderUtils . resolveContext ( testClass )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  1  ,    attributesList . size (  )  )  ;", "assertAttributes ( attributesList . get (  0  )  ,    testClass ,    new   String [  ]  {     \" foo 1  . xml \"  ,     \" foo 2  . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithMetaAnnotationAndLocationsAndOverriddenAttributes"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Class < AbstractContextConfigurationUtilsTests . MetaLocationsFooWithOverrides >    testClass    =    AbstractContextConfigurationUtilsTests . MetaLocationsFooWithOverrides . class ;", "List < Context >    attributesList    =    ContextLoaderUtils . resolveContext ( testClass )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  1  ,    attributesList . size (  )  )  ;", "assertAttributes ( attributesList . get (  0  )  ,    testClass ,    new   String [  ]  {     \"  / foo . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithMetaAnnotationAndLocationsAndOverrides"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Class < AbstractContextConfigurationUtilsTests . MetaLocationsBar >    testClass    =    AbstractContextConfigurationUtilsTests . MetaLocationsBar . class ;", "List < Context >    attributesList    =    ContextLoaderUtils . resolveContext ( testClass )  ;", "assertNotNull ( attributesList )  ;", "assertEquals (  2  ,    attributesList . size (  )  )  ;", "assertAttributes ( attributesList . get (  0  )  ,    testClass ,    new   String [  ]  {     \"  / bar . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "assertAttributes ( attributesList . get (  1  )  ,    AbstractContextConfigurationUtilsTests . MetaLocationsFoo . class ,    new   String [  ]  {     \"  / foo . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveConfigAttributesWithMetaAnnotationAndLocationsInClassHierarchy"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsConfigurationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "try    {", ". buildContextHierarchyMap ( testClass )  ;", "fail (  \" Should   throw   an   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "String   msg    =    String . format (  \" The    @ ContextConfiguration   elements   configured   via    @ ContextHierarchy   in   test   class    [  % s ]    and   its   superclasses   must   define   unique   contexts   per   hierarchy   level .  \"  ,    testClass . getName (  )  )  ;", "assertEquals ( msg ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertContextConfigEntriesAreNotUnique"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  2  ,    hierarchyAttributes . size (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 1     =    hierarchyAttributes . get (  0  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 2     =    hierarchyAttributes . get (  1  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 1  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 2  )  ;", "assertEquals (  1  ,    configAttributesListClassLevel 1  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 1  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \" one . xml \"  )  )  ;", "assertEquals (  1  ,    configAttributesListClassLevel 2  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 2  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \" two . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertOneTwo"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertContextConfigEntriesAreNotUnique ( ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithMultiLevelContextHierarchyWithDuplicatedContextConfig . class )  ;", "}", "METHOD_END"], "methodName": ["buildContextHierarchyMapForSingleTestClassWithMultiLevelContextHierarchyWithDuplicatedContextConfig"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertContextConfigEntriesAreNotUnique ( ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithMultiLevelContextHierarchyWithEmptyContextConfig . class )  ;", "}", "METHOD_END"], "methodName": ["buildContextHierarchyMapForSingleTestClassWithMultiLevelContextHierarchyWithEmptyContextConfig"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < ContextConfigurationAttributes >  >    map    =    ContextLoaderUtils . buildContextHierarchyMap ( ContextLoaderUtilsContextHierarchyTests . TestClass 3 WithMultiLevelContextHierarchy . class )  ;", "assertThat ( map . size (  )  ,    is (  3  )  )  ;", "assertThat ( map . keySet (  )  ,    hasItems (  \" alpha \"  ,     \" beta \"  ,     \" gamma \"  )  )  ;", "List < ContextConfigurationAttributes >    alphaConfig    =    map . get (  \" alpha \"  )  ;", "assertThat ( alphaConfig . size (  )  ,    is (  3  )  )  ;", "assertThat ( alphaConfig . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  1  - A . xml \"  )  )  ;", "assertThat ( alphaConfig . get (  1  )  . getLocations (  )  [  0  ]  ,    is (  \"  2  - A . xml \"  )  )  ;", "assertThat ( alphaConfig . get (  2  )  . getLocations (  )  [  0  ]  ,    is (  \"  3  - A . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    betaConfig    =    map . get (  \" beta \"  )  ;", "assertThat ( betaConfig . size (  )  ,    is (  3  )  )  ;", "assertThat ( betaConfig . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  1  - B . xml \"  )  )  ;", "assertThat ( betaConfig . get (  1  )  . getLocations (  )  [  0  ]  ,    is (  \"  2  - B . xml \"  )  )  ;", "assertThat ( betaConfig . get (  2  )  . getLocations (  )  [  0  ]  ,    is (  \"  3  - B . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    gammaConfig    =    map . get (  \" gamma \"  )  ;", "assertThat ( gammaConfig . size (  )  ,    is (  1  )  )  ;", "assertThat ( gammaConfig . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  3  - C . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildContextHierarchyMapForTestClassHierarchyWithMultiLevelContextHierarchies"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < ContextConfigurationAttributes >  >    map    =    ContextLoaderUtils . buildContextHierarchyMap ( ContextLoaderUtilsContextHierarchyTests . TestClass 2 WithMultiLevelContextHierarchyWithOverriddenInitializers . class )  ;", "assertThat ( map . size (  )  ,    is (  2  )  )  ;", "assertThat ( map . keySet (  )  ,    hasItems (  \" alpha \"  ,     \" beta \"  )  )  ;", "List < ContextConfigurationAttributes >    alphaConfig    =    map . get (  \" alpha \"  )  ;", "assertThat ( alphaConfig . size (  )  ,    is (  2  )  )  ;", "assertThat ( alphaConfig . get (  0  )  . getLocations (  )  . length ,    is (  1  )  )  ;", "assertThat ( alphaConfig . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  1  - A . xml \"  )  )  ;", "assertThat ( alphaConfig . get (  0  )  . getInitializers (  )  . length ,    is (  0  )  )  ;", "assertThat ( alphaConfig . get (  1  )  . getLocations (  )  . length ,    is (  0  )  )  ;", "assertThat ( alphaConfig . get (  1  )  . getInitializers (  )  . length ,    is (  1  )  )  ;", "assertEquals ( ContextLoaderUtilsContextHierarchyTests . DummyApplicationContextInitializer . class ,    alphaConfig . get (  1  )  . getInitializers (  )  [  0  ]  )  ;", "List < ContextConfigurationAttributes >    betaConfig    =    map . get (  \" beta \"  )  ;", "assertThat ( betaConfig . size (  )  ,    is (  2  )  )  ;", "assertThat ( betaConfig . get (  0  )  . getLocations (  )  . length ,    is (  1  )  )  ;", "assertThat ( betaConfig . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  1  - B . xml \"  )  )  ;", "assertThat ( betaConfig . get (  0  )  . getInitializers (  )  . length ,    is (  0  )  )  ;", "assertThat ( betaConfig . get (  1  )  . getLocations (  )  . length ,    is (  0  )  )  ;", "assertThat ( betaConfig . get (  1  )  . getInitializers (  )  . length ,    is (  1  )  )  ;", "assertEquals ( ContextLoaderUtilsContextHierarchyTests . DummyApplicationContextInitializer . class ,    betaConfig . get (  1  )  . getInitializers (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["buildContextHierarchyMapForTestClassHierarchyWithMultiLevelContextHierarchiesAndOverriddenInitializers"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < ContextConfigurationAttributes >  >    map    =    ContextLoaderUtils . buildContextHierarchyMap ( ContextLoaderUtilsContextHierarchyTests . TestClass 2 WithMultiLevelContextHierarchyAndPartiallyNamedConfig . class )  ;", "String   level 1     =     \" parent \"  ;", "String   level 2     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     2  ;", "String   level 3     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     3  ;", "assertThat ( map . size (  )  ,    is (  3  )  )  ;", "assertThat ( map . keySet (  )  ,    hasItems ( level 1  ,    level 2  ,    level 3  )  )  ;", "Iterator < String >    levels    =    map . keySet (  )  . iterator (  )  ;", "assertThat ( levels . next (  )  ,    is ( level 1  )  )  ;", "assertThat ( levels . next (  )  ,    is ( level 2  )  )  ;", "assertThat ( levels . next (  )  ,    is ( level 3  )  )  ;", "List < ContextConfigurationAttributes >    level 1 Config    =    map . get ( level 1  )  ;", "assertThat ( level 1 Config . size (  )  ,    is (  2  )  )  ;", "assertThat ( level 1 Config . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  1  - A . xml \"  )  )  ;", "assertThat ( level 1 Config . get (  1  )  . getLocations (  )  [  0  ]  ,    is (  \"  2  - A . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    level 2 Config    =    map . get ( level 2  )  ;", "assertThat ( level 2 Config . size (  )  ,    is (  1  )  )  ;", "assertThat ( level 2 Config . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  1  - B . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    level 3 Config    =    map . get ( level 3  )  ;", "assertThat ( level 3 Config . size (  )  ,    is (  1  )  )  ;", "assertThat ( level 3 Config . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  2  - C . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildContextHierarchyMapForTestClassHierarchyWithMultiLevelContextHierarchiesAndPartiallyNamedConfig"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < ContextConfigurationAttributes >  >    map    =    ContextLoaderUtils . buildContextHierarchyMap ( ContextLoaderUtilsContextHierarchyTests . TestClass 3 WithMultiLevelContextHierarchyAndUnnamedConfig . class )  ;", "String   level 1     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     1  ;", "String   level 2     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     2  ;", "String   level 3     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     3  ;", "String   level 4     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     4  ;", "String   level 5     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     5  ;", "String   level 6     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     6  ;", "String   level 7     =     ( ContextLoaderUtils . GENERATED _ CONTEXT _ HIERARCHY _ LEVEL _ PREFIX )     +     7  ;", "assertThat ( map . size (  )  ,    is (  7  )  )  ;", "assertThat ( map . keySet (  )  ,    hasItems ( level 1  ,    level 2  ,    level 3  ,    level 4  ,    level 5  ,    level 6  ,    level 7  )  )  ;", "List < ContextConfigurationAttributes >    level 1 Config    =    map . get ( level 1  )  ;", "assertThat ( level 1 Config . size (  )  ,    is (  1  )  )  ;", "assertThat ( level 1 Config . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  1  - A . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    level 2 Config    =    map . get ( level 2  )  ;", "assertThat ( level 2 Config . size (  )  ,    is (  1  )  )  ;", "assertThat ( level 2 Config . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  1  - B . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    level 3 Config    =    map . get ( level 3  )  ;", "assertThat ( level 3 Config . size (  )  ,    is (  1  )  )  ;", "assertThat ( level 3 Config . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  2  - A . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    level 7 Config    =    map . get ( level 7  )  ;", "assertThat ( level 7 Config . size (  )  ,    is (  1  )  )  ;", "assertThat ( level 7 Config . get (  0  )  . getLocations (  )  [  0  ]  ,    is (  \"  3  - C . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildContextHierarchyMapForTestClassHierarchyWithMultiLevelContextHierarchiesAndUnnamedConfig"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithContextConfigurationAndContextHierarchy . class )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForSingleTestClassWithContextConfigurationAndContextHierarchy"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithContextConfigurationAndContextHierarchyOnSingleMetaAnnotation . class )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForSingleTestClassWithContextConfigurationAndContextHierarchyOnSingleMetaAnnotation"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "List < List < ContextConfigurationAttributes >  >    hierarchyAttributes    =    ContextLoaderUtils . resolveContextHierarchyAttributes ( AbstractContextConfigurationUtilsTests . BareAnnotations . class )  ;", "assertEquals (  1  ,    hierarchyAttributes . size (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesList    =    hierarchyAttributes . get (  0  )  ;", "assertEquals (  1  ,    configAttributesList . size (  )  )  ;", "debugConfigAttributes ( configAttributesList )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForSingleTestClassWithImplicitSingleLevelContextHierarchy"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "List < List < ContextConfigurationAttributes >  >    hierarchyAttributes    =    ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithSingleLevelContextHierarchy . class )  ;", "assertEquals (  1  ,    hierarchyAttributes . size (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesList    =    hierarchyAttributes . get (  0  )  ;", "assertEquals (  1  ,    configAttributesList . size (  )  )  ;", "debugConfigAttributes ( configAttributesList )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForSingleTestClassWithSingleLevelContextHierarchy"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "Class < ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithSingleLevelContextHierarchyFromMetaAnnotation >    testClass    =    ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithSingleLevelContextHierarchyFromMetaAnnotation . class ;", "List < List < ContextConfigurationAttributes >  >    hierarchyAttributes    =    ContextLoaderUtils . resolveContextHierarchyAttributes ( testClass )  ;", "assertEquals (  1  ,    hierarchyAttributes . size (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesList    =    hierarchyAttributes . get (  0  )  ;", "assertNotNull ( configAttributesList )  ;", "assertEquals (  1  ,    configAttributesList . size (  )  )  ;", "debugConfigAttributes ( configAttributesList )  ;", "assertAttributes ( configAttributesList . get (  0  )  ,    testClass ,    new   String [  ]  {     \" A . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForSingleTestClassWithSingleLevelContextHierarchyFromMetaAnnotation"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "Class < ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithTripleLevelContextHierarchy >    testClass    =    ContextLoaderUtilsContextHierarchyTests . SingleTestClassWithTripleLevelContextHierarchy . class ;", "List < List < ContextConfigurationAttributes >  >    hierarchyAttributes    =    ContextLoaderUtils . resolveContextHierarchyAttributes ( testClass )  ;", "assertEquals (  1  ,    hierarchyAttributes . size (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesList    =    hierarchyAttributes . get (  0  )  ;", "assertNotNull ( configAttributesList )  ;", "assertEquals (  3  ,    configAttributesList . size (  )  )  ;", "debugConfigAttributes ( configAttributesList )  ;", "assertAttributes ( configAttributesList . get (  0  )  ,    testClass ,    new   String [  ]  {     \" A . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "assertAttributes ( configAttributesList . get (  1  )  ,    testClass ,    new   String [  ]  {     \" B . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "assertAttributes ( configAttributesList . get (  2  )  ,    testClass ,    new   String [  ]  {     \" C . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForSingleTestClassWithTripleLevelContextHierarchy"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertOneTwo ( ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . TestClass 2 WithBareContextConfigurationInSubclass . class )  )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForTestClassHierarchyWithBareContextConfigurationInSubclass"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertOneTwo ( ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . TestClass 2 WithBareContextConfigurationInSuperclass . class )  )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForTestClassHierarchyWithBareContextConfigurationInSuperclass"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertOneTwo ( ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . TestClass 2 WithBareMetaContextConfigWithOverridesInSubclass . class )  )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForTestClassHierarchyWithBareMetaContextConfigWithOverridesInSubclass"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "assertOneTwo ( ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . TestClass 2 WithBareMetaContextConfigWithOverridesInSuperclass . class )  )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForTestClassHierarchyWithBareMetaContextConfigWithOverridesInSuperclass"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "List < List < ContextConfigurationAttributes >  >    hierarchyAttributes    =    ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . TestClass 3 WithMultiLevelContextHierarchy . class )  ;", "assertEquals (  3  ,    hierarchyAttributes . size (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 1     =    hierarchyAttributes . get (  0  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 1  )  ;", "assertEquals (  2  ,    configAttributesListClassLevel 1  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 1  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \"  1  - A . xml \"  )  )  ;", "assertThat ( configAttributesListClassLevel 1  . get (  1  )  . getLocations (  )  [  0  ]  ,    equalTo (  \"  1  - B . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 2     =    hierarchyAttributes . get (  1  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 2  )  ;", "assertEquals (  2  ,    configAttributesListClassLevel 2  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 2  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \"  2  - A . xml \"  )  )  ;", "assertThat ( configAttributesListClassLevel 2  . get (  1  )  . getLocations (  )  [  0  ]  ,    equalTo (  \"  2  - B . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 3     =    hierarchyAttributes . get (  2  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 3  )  ;", "assertEquals (  3  ,    configAttributesListClassLevel 3  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 3  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \"  3  - A . xml \"  )  )  ;", "assertThat ( configAttributesListClassLevel 3  . get (  1  )  . getLocations (  )  [  0  ]  ,    equalTo (  \"  3  - B . xml \"  )  )  ;", "assertThat ( configAttributesListClassLevel 3  . get (  2  )  . getLocations (  )  [  0  ]  ,    equalTo (  \"  3  - C . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForTestClassHierarchyWithMultiLevelContextHierarchies"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "List < List < ContextConfigurationAttributes >  >    hierarchyAttributes    =    ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . TestClass 3 WithSingleLevelContextHierarchy . class )  ;", "assertEquals (  3  ,    hierarchyAttributes . size (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 1     =    hierarchyAttributes . get (  0  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 1  )  ;", "assertEquals (  1  ,    configAttributesListClassLevel 1  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 1  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \" one . xml \"  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 2     =    hierarchyAttributes . get (  1  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 2  )  ;", "assertEquals (  1  ,    configAttributesListClassLevel 2  . size (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" two - A . xml \"  ,     \" two - B . xml \"     }  ,    configAttributesListClassLevel 2  . get (  0  )  . getLocations (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 3     =    hierarchyAttributes . get (  2  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 3  )  ;", "assertEquals (  1  ,    configAttributesListClassLevel 3  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 3  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \" three . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForTestClassHierarchyWithSingleLevelContextHierarchies"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "List < List < ContextConfigurationAttributes >  >    hierarchyAttributes    =    ContextLoaderUtils . resolveContextHierarchyAttributes ( ContextLoaderUtilsContextHierarchyTests . TestClass 3 WithSingleLevelContextHierarchyFromMetaAnnotation . class )  ;", "assertEquals (  3  ,    hierarchyAttributes . size (  )  )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 1     =    hierarchyAttributes . get (  0  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 1  )  ;", "assertEquals (  1  ,    configAttributesListClassLevel 1  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 1  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \" A . xml \"  )  )  ;", "assertAttributes ( configAttributesListClassLevel 1  . get (  0  )  ,    ContextLoaderUtilsContextHierarchyTests . TestClass 1 WithSingleLevelContextHierarchyFromMetaAnnotation . class ,    new   String [  ]  {     \" A . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 2     =    hierarchyAttributes . get (  1  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 2  )  ;", "assertEquals (  1  ,    configAttributesListClassLevel 2  . size (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" B - one . xml \"  ,     \" B - two . xml \"     }  ,    configAttributesListClassLevel 2  . get (  0  )  . getLocations (  )  )  ;", "assertAttributes ( configAttributesListClassLevel 2  . get (  0  )  ,    ContextLoaderUtilsContextHierarchyTests . TestClass 2 WithSingleLevelContextHierarchyFromMetaAnnotation . class ,    new   String [  ]  {     \" B - one . xml \"  ,     \" B - two . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "List < ContextConfigurationAttributes >    configAttributesListClassLevel 3     =    hierarchyAttributes . get (  2  )  ;", "debugConfigAttributes ( configAttributesListClassLevel 3  )  ;", "assertEquals (  1  ,    configAttributesListClassLevel 3  . size (  )  )  ;", "assertThat ( configAttributesListClassLevel 3  . get (  0  )  . getLocations (  )  [  0  ]  ,    equalTo (  \" C . xml \"  )  )  ;", "assertAttributes ( configAttributesListClassLevel 3  . get (  0  )  ,    ContextLoaderUtilsContextHierarchyTests . TestClass 3 WithSingleLevelContextHierarchyFromMetaAnnotation . class ,    new   String [  ]  {     \" C . xml \"     }  ,    AbstractContextConfigurationUtilsTests . EMPTY _ CLASS _ ARRAY ,    ContextLoader . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveContextHierarchyAttributesForTestClassHierarchyWithSingleLevelContextHierarchiesAndMetaAnnotations"], "fileName": "org.springframework.test.context.support.ContextLoaderUtilsContextHierarchyTests"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   builder    =    new   StringBuilder (  )  ;", "final   String   expectedContents    =     \" customizeContext (  )    was   called \"  ;", "new   GenericXmlContextLoader (  )     {", "@ Override", "protected   void   customizeContext ( GenericApplicationContext   context )     {", "assertFalse (  \" The   context   should   not   yet   have   been   refreshed .  \"  ,    context . isActive (  )  )  ;", "builder . append ( expectedContents )  ;", "}", "}  . loadContext (  \" classpath :  / org / springframework / test / context / support /  - context . xml \"  )  ;", "assertEquals (  \" customizeContext (  )    should   have   been   called .  \"  ,    expectedContents ,    builder . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeContext"], "fileName": "org.springframework.test.context.support.CustomizedGenericXmlContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    this . cacheAwareContextLoaderDelegate . loadContext ( this . mergedContextConfiguration )  ;", "if    ( context   instanceof   ConfigurableApplicationContext )     {", "@ SuppressWarnings (  \" resource \"  )", "ConfigurableApplicationContext   cac    =     (  ( ConfigurableApplicationContext )     ( context )  )  ;", "Assert . state ( cac . isActive (  )  ,     (  )     -  >     (  (  (  (  (  \" The   ApplicationContext   loaded   for    [  \"     +     ( mergedContextConfiguration )  )     +     \"  ]    is   not   active .    This   may   be   due   to   one   of   the   following   reasons :     \"  )     +     \"  1  )    the   context   was   closed   programmatically   by   user   code ;     \"  )     +     \"  2  )    the   context   was   closed   during   parallel   test   execution   either    \"  )     +     \" according   to    @ DirtiesContext   semantics   or   due   to   automatic   eviction    \"  )     +     \" from   the   ContextCache   due   to   a   maximum   cache   size   policy .  \"  )  ;", "}", "return   context ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.test.context.support.DefaultTestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . testClass ;", "}", "METHOD_END"], "methodName": ["getTestClass"], "fileName": "org.springframework.test.context.support.DefaultTestContext"}, {"methodBody": ["METHOD_START", "{", "Object   testInstance    =    this . testInstance ;", "Assert . state (  ( testInstance    !  =    null )  ,     \" No   test   instance \"  )  ;", "return   testInstance ;", "}", "METHOD_END"], "methodName": ["getTestInstance"], "fileName": "org.springframework.test.context.support.DefaultTestContext"}, {"methodBody": ["METHOD_START", "{", "Method   testMethod    =    this . testMethod ;", "Assert . state (  ( testMethod    !  =    null )  ,     \" No   test   method \"  )  ;", "return   testMethod ;", "}", "METHOD_END"], "methodName": ["getTestMethod"], "fileName": "org.springframework.test.context.support.DefaultTestContext"}, {"methodBody": ["METHOD_START", "{", "this . cacheAwareContextLoaderDelegate . closeContext ( this . mergedContextConfiguration ,    hierarchyMode )  ;", "}", "METHOD_END"], "methodName": ["markApplicationContextDirty"], "fileName": "org.springframework.test.context.support.DefaultTestContext"}, {"methodBody": ["METHOD_START", "{", "this . testInstance    =    testInstance ;", "this . testMethod    =    testMethod ;", "this . testException    =    testException ;", "}", "METHOD_END"], "methodName": ["updateState"], "fileName": "org.springframework.test.context.support.DefaultTestContext"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    loader . loadContext ( mergedConfig )  ;", "assertNotNull ( applicationContext )  ;", "assertEquals (  \" foo \"  ,    applicationContext . getBean ( String . class )  )  ;", "assertTrue (  ( applicationContext   instanceof   ConfigurableApplicationContext )  )  ;", "(  ( ConfigurableApplicationContext )     ( applicationContext )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["assertApplicationContextLoadsAndContainsFooString"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ObjectUtils . isEmpty ( array )  )  ;", "}", "METHOD_END"], "methodName": ["assertEmpty"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "loader . loadContext ( DelegatingSmartContextLoaderTests . EMPTY _ STRING _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["loadContextFromLocations"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( DelegatingSmartContextLoaderTests . ConfigClassTestCase . class ,    DelegatingSmartContextLoaderTests . EMPTY _ STRING _ ARRAY ,    new   Class <  ?  >  [  ]  {    DelegatingSmartContextLoaderTests . ConfigClassTestCase . Config . class    }  ,    DelegatingSmartContextLoaderTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertApplicationContextLoadsAndContainsFooString ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["loadContextWithConfigurationClass"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( startsWith (  \" Neither \"  )  )  ;", "expectedException . expectMessage ( endsWith (  \" declare   either    ' locations '    or    ' classes '    but   not   both .  \"  )  )  ;", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" test . xml \"     }  ,    new   Class <  ?  >  [  ]  {    getClass (  )     }  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "loader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["loadContextWithLocationsAndConfigurationClasses"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig    =    null ;", "loader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["loadContextWithNullConfig"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( DelegatingSmartContextLoaderTests . XmlTestCase . class ,    new   String [  ]  {     \" classpath :  / org / springframework / test / context / support / DelegatingSmartContextLoaderTests $ XmlTestCase - context . xml \"     }  ,    DelegatingSmartContextLoaderTests . EMPTY _ CLASS _ ARRAY ,    DelegatingSmartContextLoaderTests . EMPTY _ STRING _ ARRAY ,    loader )  ;", "assertApplicationContextLoadsAndContainsFooString ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["loadContextWithXmlConfig"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( startsWith (  \" Neither \"  )  )  ;", "expectedException . expectMessage ( containsString (  \" was   able   to   load   an   ApplicationContext   from \"  )  )  ;", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "loader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["loadContextWithoutLocationsAndConfigurationClasses"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes    =    new   Class <  ?  >  [  ]  {    getClass (  )     }  ;", "ContextConfigurationAttributes   configAttributes    =    new   ContextConfigurationAttributes ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    classes ,    true ,    null ,    true ,    ContextLoader . class )  ;", "loader . processContextConfiguration ( configAttributes )  ;", "assertArrayEquals ( classes ,    configAttributes . getClasses (  )  )  ;", ". assertEmpty ( configAttributes . getLocations (  )  )  ;", "}", "METHOD_END"], "methodName": ["processContextConfigurationWithConfigurationClass"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "ContextConfigurationAttributes   configAttributes    =    new   ContextConfigurationAttributes ( DelegatingSmartContextLoaderTests . ConfigClassTestCase . class ,    DelegatingSmartContextLoaderTests . EMPTY _ STRING _ ARRAY ,    DelegatingSmartContextLoaderTests . EMPTY _ CLASS _ ARRAY ,    true ,    null ,    true ,    ContextLoader . class )  ;", "loader . processContextConfiguration ( configAttributes )  ;", "assertEquals (  1  ,    configAttributes . getClasses (  )  . length )  ;", "DelegatingSmartContextLoaderTests . assertEmpty ( configAttributes . getLocations (  )  )  ;", "}", "METHOD_END"], "methodName": ["processContextConfigurationWithDefaultConfigurationClassGeneration"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( containsString (  \" both   default   locations   AND   default   configuration   classes   were   detected \"  )  )  ;", "ContextConfigurationAttributes   configAttributes    =    new   ContextConfigurationAttributes (  . ImproperDuplicateDefaultXmlAndConfigClassTestCase . class ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ CLASS _ ARRAY ,    true ,    null ,    true ,    ContextLoader . class )  ;", "loader . processContextConfiguration ( configAttributes )  ;", "}", "METHOD_END"], "methodName": ["processContextConfigurationWithDefaultXmlConfigAndConfigurationClassGeneration"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "ContextConfigurationAttributes   configAttributes    =    new   ContextConfigurationAttributes ( DelegatingSmartContextLoaderTests . XmlTestCase . class ,    DelegatingSmartContextLoaderTests . EMPTY _ STRING _ ARRAY ,    DelegatingSmartContextLoaderTests . EMPTY _ CLASS _ ARRAY ,    true ,    null ,    true ,    ContextLoader . class )  ;", "loader . processContextConfiguration ( configAttributes )  ;", "assertEquals (  1  ,    configAttributes . getLocations (  )  . length )  ;", "DelegatingSmartContextLoaderTests . assertEmpty ( configAttributes . getClasses (  )  )  ;", "}", "METHOD_END"], "methodName": ["processContextConfigurationWithDefaultXmlConfigGeneration"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    locations    =    new   String [  ]  {     \" classpath :  / foo . xml \"     }  ;", "ContextConfigurationAttributes   configAttributes    =    new   ContextConfigurationAttributes ( getClass (  )  ,    locations ,     . EMPTY _ CLASS _ ARRAY ,    true ,    null ,    true ,    ContextLoader . class )  ;", "loader . processContextConfiguration ( configAttributes )  ;", "assertArrayEquals ( locations ,    configAttributes . getLocations (  )  )  ;", ". assertEmpty ( configAttributes . getClasses (  )  )  ;", "}", "METHOD_END"], "methodName": ["processContextConfigurationWithLocation"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "loader . processLocations ( getClass (  )  ,    DelegatingSmartContextLoaderTests . EMPTY _ STRING _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["processLocations"], "fileName": "org.springframework.test.context.support.DelegatingSmartContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Object   bean    =    testContext . getTestInstance (  )  ;", "AutowireCapableBeanFactory   beanFactory    =    testContext . getApplicationContext (  )  . getAutowireCapableBeanFactory (  )  ;", "beanFactory . autowireBeanProperties ( bean ,    AUTOWIRE _ NO ,    false )  ;", "beanFactory . initializeBean ( bean ,    testContext . getTestClass (  )  . getName (  )  )  ;", "testContext . removeAttribute (  . REINJECT _ DEPENDENCIES _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["injectDependencies"], "fileName": "org.springframework.test.context.support.DependencyInjectionTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredLocallyAfterClass . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredLocallyOnClassAfterClass"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredLocallyAfterEachTestMethod . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredLocallyOnClassAfterEachTestMethod"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredLocallyBeforeClass . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredLocallyOnClassBeforeClass"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredLocallyBeforeEachTestMethod . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredLocallyOnClassBeforeEachTestMethod"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    getClass (  )  ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any (  . HierarchyMode . class )  )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredLocallyOnMethod"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredViaMetaAnnotationAfterClass . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredViaMetaAnnotationOnClassAfterClass"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredViaMetaAnnotationAfterEachTestMethod . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredViaMetaAnnotationOnClassAfterEachTestMethod"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextViaMetaAnnotationWithOverridenAttributes . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredViaMetaAnnotationWithOverridenAttributes"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextViaMetaAnnotationWithOverrides . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "beforeListener . beforeTestClass ( testContext )  ;", "afterListener . beforeTestClass ( testContext )  ;", "afterListener . afterTestClass ( testContext )  ;", "beforeListener . afterTestClass ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestClassForDirtiesContextDeclaredViaMetaAnnotationWithOverrides"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredLocallyAfterClass . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" clean \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredLocallyOnClassAfterClass"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredLocallyAfterEachTestMethod . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" clean \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredLocallyOnClassAfterEachTestMethod"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredLocallyBeforeClass . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" clean \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredLocallyOnClassBeforeClass"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredLocallyBeforeEachTestMethod . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" clean \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredLocallyOnClassBeforeEachTestMethod"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    getClass (  )  ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" dirtiesContextDeclaredLocallyWithAfterMethodMode \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any (  . HierarchyMode . class )  )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty (  . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredLocallyOnMethodWithAfterMethodMode"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    getClass (  )  ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" dirtiesContextDeclaredLocallyWithBeforeMethodMode \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty (  . HierarchyMode . EXHAUSTIVE )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty (  . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredLocallyOnMethodWithBeforeMethodMode"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    getClass (  )  ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" dirtiesContextDeclaredViaMetaAnnotationWithAfterMethodMode \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any (  . HierarchyMode . class )  )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty (  . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredOnMethodViaMetaAnnotationWithAfterMethodMode"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredViaMetaAnnotationAfterClass . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" clean \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredViaMetaAnnotationOnClassAfterClass"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextDeclaredViaMetaAnnotationAfterEachTestMethod . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" clean \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . EXHAUSTIVE )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextDeclaredViaMetaAnnotationOnClassAfterEachTestMethod"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    DirtiesContextTestExecutionListenerTests . DirtiesContextViaMetaAnnotationWithOverrides . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" clean \"  )  )  ;", "beforeListener . beforeTestMethod ( testContext )  ;", "afterListener . beforeTestMethod ( testContext )  ;", "verify ( testContext ,    times (  0  )  )  . markApplicationContextDirty ( any ( DirtiesContext . HierarchyMode . class )  )  ;", "afterListener . afterTestMethod ( testContext )  ;", "beforeListener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . markApplicationContextDirty ( DirtiesContext . HierarchyMode . CURRENT _ LEVEL )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterTestMethodForDirtiesContextViaMetaAnnotationWithOverrides"], "fileName": "org.springframework.test.context.support.DirtiesContextTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( containsString (  \" does   not   support   annotated   classes \"  )  )  ;", "GenericPropertiesContextLoader   loader    =    new   GenericPropertiesContextLoader (  )  ;", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    new   Class <  ?  >  [  ]  {    getClass (  )     }  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "loader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["configMustNotContainAnnotatedClasses"], "fileName": "org.springframework.test.context.support.GenericPropertiesContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "final   ContextConfiguration   contextConfig    =    this . testClass . getAnnotation ( ContextConfiguration . class )  ;", "final   ContextLoader   contextLoader    =    new   GenericXmlContextLoader (  )  ;", "final   String [  ]    configuredLocations    =     (  ( String [  ]  )     ( AnnotationUtils . getValue ( contextConfig )  )  )  ;", "final   String [  ]    processedLocations    =    contextLoader . processLocations ( this . testClass ,    configuredLocations )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  \"  )  ;", ". logger . debug (  (  \" Configured   locations :     \"     +     ( ObjectUtils . nullSafeToString ( configuredLocations )  )  )  )  ;", ". logger . debug (  (  \" Expected         locations :     \"     +     ( ObjectUtils . nullSafeToString ( this . expectedLocations )  )  )  )  ;", ". logger . debug (  (  \" Processed      locations :     \"     +     ( ObjectUtils . nullSafeToString ( processedLocations )  )  )  )  ;", "}", "assertArrayEquals (  (  (  \" Verifying   locations   for   test    [  \"     +     ( this . testClass )  )     +     \"  ]  .  \"  )  ,    this . expectedLocations ,    processedLocations )  ;", "}", "METHOD_END"], "methodName": ["assertContextConfigurationLocations"], "fileName": "org.springframework.test.context.support.GenericXmlContextLoaderResourceLocationsTests"}, {"methodBody": ["METHOD_START", "{", "@ ContextConfiguration", "class   ClasspathNonExistentDefaultLocationsTestCase    {  }", "@ ContextConfiguration", "class   ClasspathExistentDefaultLocationsTestCase    {  }", "@ ContextConfiguration (  {     \" context 1  . xml \"  ,     \" context 2  . xml \"     }  )", "class   ImplicitClasspathLocationsTestCase    {  }", "@ ContextConfiguration (  \" classpath : context . xml \"  )", "class   ExplicitClasspathLocationsTestCase    {  }", "@ ContextConfiguration (  \" file :  / testing / directory / context . xml \"  )", "class   ExplicitFileLocationsTestCase    {  }", "@ ContextConfiguration (  \" http :  /  / example . com / context . xml \"  )", "class   ExplicitUrlLocationsTestCase    {  }", "@ ContextConfiguration (  {     \" context 1  . xml \"  ,     \" classpath : context 2  . xml \"  ,     \"  / context 3  . xml \"  ,     \" file :  / testing / directory / context . xml \"  ,     \" http :  /  / example . com / context . xml \"     }  )", "class   ExplicitMixedPathTypesLocationsTestCase    {  }", "return   Arrays . asList ( new   Object [  ]  [  ]  {    new   Object [  ]  {    ClasspathNonExistentDefaultLocationsTestCase . class . getSimpleName (  )  ,    new   String [  ]  {        }     }  ,    new   Object [  ]  {    ClasspathExistentDefaultLocationsTestCase . class . getSimpleName (  )  ,    new   String [  ]  {     \" classpath : org / springframework / test / context / support /  $  1 ClasspathExistentDefaultLocationsTestCase - context . xml \"     }     }  ,    new   Object [  ]  {    ImplicitClasspathLocationsTestCase . class . getSimpleName (  )  ,    new   String [  ]  {     \" classpath :  / org / springframework / test / context / support / context 1  . xml \"  ,     \" classpath :  / org / springframework / test / context / support / context 2  . xml \"     }     }  ,    new   Object [  ]  {    ExplicitClasspathLocationsTestCase . class . getSimpleName (  )  ,    new   String [  ]  {     \" classpath : context . xml \"     }     }  ,    new   Object [  ]  {    ExplicitFileLocationsTestCase . class . getSimpleName (  )  ,    new   String [  ]  {     \" file :  / testing / directory / context . xml \"     }     }  ,    new   Object [  ]  {    ExplicitUrlLocationsTestCase . class . getSimpleName (  )  ,    new   String [  ]  {     \" http :  /  / example . com / context . xml \"     }     }  ,    new   Object [  ]  {    ExplicitMixedPathTypesLocationsTestCase . class . getSimpleName (  )  ,    new   String [  ]  {     \" classpath :  / org / springframework / test / context / support / context 1  . xml \"  ,     \" classpath : context 2  . xml \"  ,     \" classpath :  / context 3  . xml \"  ,     \" file :  / testing / directory / context . xml \"  ,     \" http :  /  / example . com / context . xml \"     }     }     }  )  ;", "}", "METHOD_END"], "methodName": ["contextConfigurationLocationsData"], "fileName": "org.springframework.test.context.support.GenericXmlContextLoaderResourceLocationsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( containsString (  \" does   not   support   annotated   classes \"  )  )  ;", "GenericXmlContextLoader   loader    =    new   GenericXmlContextLoader (  )  ;", "MergedContextConfiguration   mergedConfig    =    new   MergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    new   Class <  ?  >  [  ]  {    getClass (  )     }  ,     . EMPTY _ STRING _ ARRAY ,    loader )  ;", "loader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["configMustNotContainAnnotatedClasses"], "fileName": "org.springframework.test.context.support.GenericXmlContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "return   this . locations ;", "}", "METHOD_END"], "methodName": ["getLocations"], "fileName": "org.springframework.test.context.support.MergedTestPropertySources"}, {"methodBody": ["METHOD_START", "{", "return   this . properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.springframework.test.context.support.MergedTestPropertySources"}, {"methodBody": ["METHOD_START", "{", "String   resourcePath    =     ( ClassUtils . convertClassNameToResourcePath ( testClass . getName (  )  )  )     +     \"  . properties \"  ;", "String   prefixedResourcePath    =     ( ResourceUtils . CLASSPATH _ URL _ PREFIX )     +    resourcePath ;", "ClassPathResource   classPathResource    =    new   ClassPathResource ( resourcePath )  ;", "if    ( classPathResource . exists (  )  )     {", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( String . format (  \" Detected   default   properties   file    \\  \"  % s \\  \"    for   test   class    [  % s ]  \"  ,    prefixedResourcePath ,    testClass . getName (  )  )  )  ;", "}", "return   prefixedResourcePath ;", "} else    {", "String   msg    =    String . format (  (  \" Could   not   detect   default   properties   file   for   test    [  % s ]  :     \"     +     (  \"  % s   does   not   exist .    Either   declare   the    ' locations '    or    ' properties '    attributes    \"     +     \" of    @ TestPropertySource   or   make   the   default   properties   file   available .  \"  )  )  ,    testClass . getName (  )  ,    classPathResource )  ;", ". logger . error ( msg )  ;", "throw   new   IllegalStateException ( msg )  ;", "}", "}", "METHOD_END"], "methodName": ["detectDefaultPropertiesFile"], "fileName": "org.springframework.test.context.support.TestPropertySourceAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . declaringClass ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "org.springframework.test.context.support.TestPropertySourceAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . locations ;", "}", "METHOD_END"], "methodName": ["getLocations"], "fileName": "org.springframework.test.context.support.TestPropertySourceAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . inheritLocations ;", "}", "METHOD_END"], "methodName": ["isInheritLocations"], "fileName": "org.springframework.test.context.support.TestPropertySourceAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . inheritProperties ;", "}", "METHOD_END"], "methodName": ["isInheritProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceAttributes"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( context ,     \"  ' context '    must   not   be   null \"  )  ;", "Assert . notNull ( inlinedProperties ,     \"  ' inlinedProperties '    must   not   be   null \"  )  ;", ". addInlinedPropertiesToEnvironment ( context . getEnvironment (  )  ,    inlinedProperties )  ;", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironment"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( environment ,     \"  ' environment '    must   not   be   null \"  )  ;", "Assert . notNull ( inlinedProperties ,     \"  ' inlinedProperties '    must   not   be   null \"  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( inlinedProperties )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Adding   inlined   properties   to   environment :     \"     +     ( ObjectUtils . nullSafeToString ( inlinedProperties )  )  )  )  ;", "}", "MapPropertySource   ps    =     (  ( MapPropertySource )     ( environment . getPropertySources (  )  . get (  . INLINED _ PROPERTIES _ PROPERTY _ SOURCE _ NAME )  )  )  ;", "if    ( ps    =  =    null )     {", "ps    =    new   MapPropertySource (  . INLINED _ PROPERTIES _ PROPERTY _ SOURCE _ NAME ,    new   LinkedHashMap (  )  )  ;", "environment . getPropertySources (  )  . addFirst ( ps )  ;", "}", "ps . getSource (  )  . putAll (  . convertInlinedPropertiesToMap ( inlinedProperties )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironment"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( context ,     \"  ' context '    must   not   be   null \"  )  ;", "Assert . notNull ( locations ,     \"  ' locations '    must   not   be   null \"  )  ;", ". addPropertiesFilesToEnvironment ( context . getEnvironment (  )  ,    context ,    locations )  ;", "}", "METHOD_END"], "methodName": ["addPropertiesFilesToEnvironment"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( environment ,     \"  ' environment '    must   not   be   null \"  )  ;", "Assert . notNull ( resourceLoader ,     \"  ' resourceLoader '    must   not   be   null \"  )  ;", "Assert . notNull ( locations ,     \"  ' locations '    must   not   be   null \"  )  ;", "try    {", "for    ( String   location    :    locations )     {", "String   resolvedLocation    =    environment . resolveRequiredPlaceholders ( location )  ;", "Resource   resource    =    resourceLoader . getResource ( resolvedLocation )  ;", "environment . getPropertySources (  )  . addFirst ( new   core . io . support . ResourcePropertySource ( resource )  )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   add   PropertySource   to   Environment \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["addPropertiesFilesToEnvironment"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "Class < TestPropertySource >    annotationType    =    TestPropertySource . class ;", "MetaAnnotationUtils . AnnotationDescriptor < TestPropertySource >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( testClass ,    annotationType )  ;", "if    ( descriptor    =  =    null )     {", "return   new   MergedTestPropertySources (  )  ;", "}", "List < TestPropertySourceAttributes >    attributesList    =     . resolveTestPropertySourceAttributes ( testClass )  ;", "String [  ]    locations    =     . mergeLocations ( attributesList )  ;", "String [  ]    properties    =     . mergeProperties ( attributesList )  ;", "return   new   MergedTestPropertySources ( locations ,    properties )  ;", "}", "METHOD_END"], "methodName": ["buildMergedTestPropertySources"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( inlinedProperties ,     \"  ' inlinedProperties '    must   not   be   null \"  )  ;", "Map < String ,    Object >    map    =    new   LinkedHashMap <  >  (  )  ;", "Properties   props    =    new   Properties (  )  ;", "for    ( String   pair    :    inlinedProperties )     {", "if    (  !  ( StringUtils . hasText ( pair )  )  )     {", "continue ;", "}", "try    {", "props . load ( new   StringReader ( pair )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   IllegalStateException (  (  (  \" Failed   to   load   test   environment   property   from    [  \"     +    pair )     +     \"  ]  \"  )  ,    ex )  ;", "}", "Assert . state (  (  ( props . size (  )  )     =  =     1  )  ,     (  )     -  >     (  \" Failed   to   load   exactly   one   test   environment   property   from    [  \"     +    pair )     +     \"  ]  \"  )  ;", "for    ( String   name    :    props . stringPropertyNames (  )  )     {", "map . put ( name ,    props . ge ( name )  )  ;", "}", "props . clear (  )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["convertInlinedPropertiesToMap"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "List < String >    locations    =    new   ArrayList <  >  (  )  ;", "for    ( TestPropertySourceAttributes   attrs    :    attributesList )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace ( String . format (  \" Processing   locations   for   TestPropertySource   attributes    % s \"  ,    attrs )  )  ;", "}", "String [  ]    locationsArray    =    TestContextResourceUtils . convertToClasspathResourcePaths ( attrs . getDeclaringClass (  )  ,    attrs . getLocations (  )  )  ;", "locations . addAll (  0  ,    Arrays . asList ( locationsArray )  )  ;", "if    (  !  ( attrs . isInheritLocations (  )  )  )     {", "break ;", "}", "}", "return   StringUtils . toStringArray ( locations )  ;", "}", "METHOD_END"], "methodName": ["mergeLocations"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "List < String >    properties    =    new   ArrayList <  >  (  )  ;", "for    ( TestPropertySourceAttributes   attrs    :    attributesList )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace ( String . format (  \" Processing   inlined   properties   for   TestPropertySource   attributes    % s \"  ,    attrs )  )  ;", "}", "String [  ]    attrProps    =    attrs . getProperties (  )  ;", "if    ( attrProps    !  =    null )     {", "properties . addAll (  0  ,    Arrays . asList ( attrProps )  )  ;", "}", "if    (  !  ( attrs . isInheritProperties (  )  )  )     {", "break ;", "}", "}", "return   StringUtils . toStringArray ( properties )  ;", "}", "METHOD_END"], "methodName": ["mergeProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testClass ,     \" Class   must   not   be   null \"  )  ;", "List < TestPropertySourceAttributes >    attributesList    =    new   ArrayList <  >  (  )  ;", "Class < TestPropertySource >    annotationType    =    TestPropertySource . class ;", "MetaAnnotationUtils . AnnotationDescriptor < TestPropertySource >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( testClass ,    annotationType )  ;", "Assert . notNull ( descriptor ,    String . format (  \" Could   not   find   an    ' annotation   declaring   class '    for   annotation   type    [  % s ]    and   class    [  % s ]  \"  ,    annotationType . getName (  )  ,    testClass . getName (  )  )  )  ;", "while    ( descriptor    !  =    null )     {", "TestPropertySource   testPropertySource    =    descriptor . synthesizeAnnotation (  )  ;", "Class <  ?  >    rootDeclaringClass    =    descriptor . getRootDeclaringClass (  )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace ( String . format (  \" Retrieved    @ TestPropertySource    [  % s ]    for   declaring   class    [  % s ]  .  \"  ,    testPropertySource ,    rootDeclaringClass . getName (  )  )  )  ;", "}", "TestPropertySourceAttributes   attributes    =    new   TestPropertySourceAttributes ( rootDeclaringClass ,    testPropertySource )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  \" Resolved   TestPropertySource   attributes :     \"     +    attributes )  )  ;", "}", "attributesList . add ( attributes )  ;", "descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( rootDeclaringClass . getSuperclass (  )  ,    annotationType )  ;", "}", "return   attributesList ;", "}", "METHOD_END"], "methodName": ["resolveTestPropertySourceAttributes"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtils"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" inlined \"  )  ;", ". addInlinedPropertiesToEnvironment ( mock ( ConfigurableApplicationContext . class )  ,     (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironmentWithContextAndNullInlinedProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableEnvironment   environment    =    new   MockEnvironment (  )  ;", "MutablePropertySources   propertySources    =    environment . getPropertySources (  )  ;", "propertySources . remove ( MockPropertySource . MOCK _ PROPERTIES _ PROPERTY _ SOURCE _ NAME )  ;", "assertEquals (  0  ,    propertySources . size (  )  )  ;", "TestPropertySourceUtils . addInlinedPropertiesToEnvironment ( environment ,     . asArray (  \"        \"  )  )  ;", "assertEquals (  1  ,    propertySources . size (  )  )  ;", "assertEquals (  0  ,     (  ( Map )     ( propertySources . iterator (  )  . next (  )  . getSource (  )  )  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironmentWithEmptyProperty"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" inlined \"  )  ;", ". addInlinedPropertiesToEnvironment ( new   MockEnvironment (  )  ,     (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironmentWithEnvironmentAndNullInlinedProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage (  \" Failed   to   load   test   environment   property \"  )  ;", "TestPropertySourceUtils . addInlinedPropertiesToEnvironment ( new   MockEnvironment (  )  ,     . asArray (  \" key    =     \\  \\ uZZZZ \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironmentWithMalformedUnicodeInValue"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage (  \" Failed   to   load   exactly   one   test   environment   property \"  )  ;", "TestPropertySourceUtils . addInlinedPropertiesToEnvironment ( new   MockEnvironment (  )  ,     . asArray (  \" a = b \\ nx = y \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironmentWithMultipleKeyValuePairsInSingleInlinedProperty"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" context \"  )  ;", "TestPropertySourceUtils . addInlinedPropertiesToEnvironment (  (  ( ConfigurableApplicationContext )     ( null )  )  ,     . KEY _ VALUE _ PAIR )  ;", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironmentWithNullContext"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" environment \"  )  ;", "TestPropertySourceUtils . addInlinedPropertiesToEnvironment (  (  ( ConfigurableEnvironment )     ( null )  )  ,     . KEY _ VALUE _ PAIR )  ;", "}", "METHOD_END"], "methodName": ["addInlinedPropertiesToEnvironmentWithNullEnvironment"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" must   not   be   null \"  )  ;", ". addPropertiesFilesToEnvironment ( mock ( ConfigurableApplicationContext . class )  ,     (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addPropertiesFilesToEnvironmentWithContextAndNullLocations"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" must   not   be   null \"  )  ;", ". addPropertiesFilesToEnvironment ( new   MockEnvironment (  )  ,    mock ( ResourceLoader . class )  ,     (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addPropertiesFilesToEnvironmentWithEnvironmentAndNullLocations"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" must   not   be   null \"  )  ;", "TestPropertySourceUtils . addPropertiesFilesToEnvironment (  (  ( ConfigurableApplicationContext )     ( null )  )  ,     . FOO _ LOCATIONS )  ;", "}", "METHOD_END"], "methodName": ["addPropertiesFilesToEnvironmentWithNullContext"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" must   not   be   null \"  )  ;", "TestPropertySourceUtils . addPropertiesFilesToEnvironment (  (  ( ConfigurableEnvironment )     ( null )  )  ,    mock ( ResourceLoader . class )  ,     . FOO _ LOCATIONS )  ;", "}", "METHOD_END"], "methodName": ["addPropertiesFilesToEnvironmentWithNullEnvironment"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableEnvironment   environment    =    new   MockEnvironment (  )  ;", "MutablePropertySources   propertySources    =    environment . getPropertySources (  )  ;", "propertySources . remove ( MockPropertySource . MOCK _ PROPERTIES _ PROPERTY _ SOURCE _ NAME )  ;", "assertEquals (  0  ,    propertySources . size (  )  )  ;", "String   pair    =     \" key    =    value \"  ;", "ByteArrayResource   resource    =    new   ByteArrayResource ( pair . getBytes (  )  ,     (  \" from   inlined   property :     \"     +    pair )  )  ;", "ResourceLoader   resourceLoader    =    mock ( ResourceLoader . class )  ;", "when ( resourceLoader . getResource ( anyString (  )  )  )  . thenReturn ( resource )  ;", "TestPropertySourceUtils . addPropertiesFilesToEnvironment ( environment ,    resourceLoader ,     . FOO _ LOCATIONS )  ;", "assertEquals (  1  ,    propertySources . size (  )  )  ;", "assertEquals (  \" value \"  ,    environment . getProperty (  \" key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addPropertiesFilesToEnvironmentWithSinglePropertyFromVirtualFile"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   arr ;", "}", "METHOD_END"], "methodName": ["asArray"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MergedTestPropertySources   mergedPropertySources    =    TestPropertySourceUtils . buildMergedTestPropertySources ( testClass )  ;", "assertNotNull ( mergedPropertySources )  ;", "assertArrayEquals ( expectedLocations ,    mergedPropertySources . getLocations (  )  )  ;", "assertArrayEquals ( expectedProperties ,    mergedPropertySources . getProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMergedTestPropertySources"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalArgumentException . class )  ;", "expectedException . expectMessage (  \" inlined \"  )  ;", ". convertInlinedPropertiesToMap (  (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["convertInlinedPropertiesToMapWithNullInlinedProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( CoreMatchers . startsWith (  \" Could   not   detect   default   properties   file   for   test \"  )  )  ;", "expectedException . expectMessage ( containsString (  \" EmptyPropertySources . properties \"  )  )  ;", "TestPropertySourceUtils . buildMergedTestPropertySources (  . EmptyPropertySources . class )  ;", "}", "METHOD_END"], "methodName": ["emptyAnnotation"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( CoreMatchers . startsWith (  \" Could   not   detect   default   properties   file   for   test \"  )  )  ;", "expectedException . expectMessage ( containsString (  \" ExtendedEmptyPropertySources . properties \"  )  )  ;", "TestPropertySourceUtils . buildMergedTestPropertySources (  . ExtendedEmptyPropertySources . class )  ;", "}", "METHOD_END"], "methodName": ["extendedEmptyAnnotation"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestPropertySourceUtilsTests . assertMergedTestPropertySources ( TestPropertySourceUtilsTests . ExtendedPropertySources . class ,    TestPropertySourceUtilsTests . asArray (  \" classpath :  / foo 1  . xml \"  ,     \" classpath :  / foo 2  . xml \"  ,     \" classpath :  / bar 1  . xml \"  ,     \" classpath :  / bar 2  . xml \"  )  ,    TestPropertySourceUtilsTests . asArray (  \" k 1 a = v 1 a \"  ,     \" k 1 b :    v 1 b \"  ,     \" k 2 a   v 2 a \"  ,     \" k 2 b :    v 2 b \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extendedLocationsAndProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestPropertySourceUtilsTests . assertMergedTestPropertySources ( TestPropertySourceUtilsTests . InheritedPropertySources . class ,    TestPropertySourceUtilsTests . asArray (  \" classpath :  / foo 1  . xml \"  ,     \" classpath :  / foo 2  . xml \"  )  ,    TestPropertySourceUtilsTests . asArray (  \" k 1 a = v 1 a \"  ,     \" k 1 b :    v 1 b \"  )  )  ;", "}", "METHOD_END"], "methodName": ["inheritedLocationsAndProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestPropertySourceUtilsTests . assertMergedTestPropertySources ( TestPropertySourceUtilsTests . LocationsAndPropertiesPropertySources . class ,    TestPropertySourceUtilsTests . asArray (  \" classpath :  / foo 1  . xml \"  ,     \" classpath :  / foo 2  . xml \"  )  ,    TestPropertySourceUtilsTests . asArray (  \" k 1 a = v 1 a \"  ,     \" k 1 b :    v 1 b \"  )  )  ;", "}", "METHOD_END"], "methodName": ["locationsAndProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( AnnotationConfigurationException . class )  ;", "TestPropertySourceUtils . buildMergedTestPropertySources (  . LocationsAndValuePropertySources . class )  ;", "}", "METHOD_END"], "methodName": ["locationsAndValueAttributes"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestPropertySourceUtilsTests . assertMergedTestPropertySources ( TestPropertySourceUtilsTests . OverriddenLocationsPropertySources . class ,    TestPropertySourceUtilsTests . asArray (  \" classpath :  / baz . properties \"  )  ,    TestPropertySourceUtilsTests . asArray (  \" k 1 a = v 1 a \"  ,     \" k 1 b :    v 1 b \"  ,     \" key    =    value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["overriddenLocations"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestPropertySourceUtilsTests . assertMergedTestPropertySources ( TestPropertySourceUtilsTests . OverriddenLocationsAndPropertiesPropertySources . class ,    TestPropertySourceUtilsTests . asArray (  \" classpath :  / baz . properties \"  )  ,    TestPropertySourceUtilsTests . KEY _ VALUE _ PAIR )  ;", "}", "METHOD_END"], "methodName": ["overriddenLocationsAndProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestPropertySourceUtilsTests . assertMergedTestPropertySources ( TestPropertySourceUtilsTests . OverriddenPropertiesPropertySources . class ,    TestPropertySourceUtilsTests . asArray (  \" classpath :  / foo 1  . xml \"  ,     \" classpath :  / foo 2  . xml \"  ,     \" classpath :  / baz . properties \"  )  ,    TestPropertySourceUtilsTests . KEY _ VALUE _ PAIR )  ;", "}", "METHOD_END"], "methodName": ["overriddenProperties"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestPropertySourceUtilsTests . assertMergedTestPropertySources ( TestPropertySourceUtilsTests . ValuePropertySources . class ,    TestPropertySourceUtilsTests . asArray (  \" classpath :  / value . xml \"  )  ,    TestPropertySourceUtilsTests . EMPTY _ STRING _ ARRAY )  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.context.support.TestPropertySourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   testResultException    =    testResult . getThrowable (  )  ;", "if    ( testResultException   instanceof   InvocationTargetException )     {", "testResultException    =     (  ( InvocationTargetException )     ( testResultException )  )  . getCause (  )  ;", "}", "return   testResultException ;", "}", "METHOD_END"], "methodName": ["getTestResultException"], "fileName": "org.springframework.test.context.testng.AbstractTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . testContextManager . afterTestClass (  )  ;", "}", "METHOD_END"], "methodName": ["springTestContextAfterTestClass"], "fileName": "org.springframework.test.context.testng.AbstractTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . testManager . afterTestMethod ( this ,    testMethod ,    this . testException )  ;", "}    finally    {", "this . testException    =    null ;", "}", "}", "METHOD_END"], "methodName": ["springTestContextAfterTestMethod"], "fileName": "org.springframework.test.context.testng.AbstractTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . testContextManager . beforeTestClass (  )  ;", "}", "METHOD_END"], "methodName": ["springTestContextBeforeTestClass"], "fileName": "org.springframework.test.context.testng.AbstractTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . testContextManager . beforeTestMethod ( this ,    testMethod )  ;", "}", "METHOD_END"], "methodName": ["springTestContextBeforeTestMethod"], "fileName": "org.springframework.test.context.testng.AbstractTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . testContextManager . prepareTestInstance ( this )  ;", "}", "METHOD_END"], "methodName": ["springTestContextPrepareTestInstance"], "fileName": "org.springframework.test.context.testng.AbstractTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "throw    (  ( T )     ( t )  )  ;", "}", "METHOD_END"], "methodName": ["throwAs"], "fileName": "org.springframework.test.context.testng.AbstractTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "throwAs ( t )  ;", "throw   n   IllegalStateException ( t )  ;", "}", "METHOD_END"], "methodName": ["throwAsUncheckedException"], "fileName": "org.springframework.test.context.testng.AbstractTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( AnnotationConfigTransactionalTestNGSpringContextTests . numSetUpCalls ,    AnnotationConfigTransactionalTestNGSpringContextTests . NUM _ TESTS ,     \" number   of   calls   to   setUp (  )  .  \"  )  ;", "assertEquals ( AnnotationConfigTransactionalTestNGSpringContextTests . numSetUpCallsInTransaction ,    AnnotationConfigTransactionalTestNGSpringContextTests . NUM _ TX _ TESTS ,     \" number   of   calls   to   setUp (  )    within   a   transaction .  \"  )  ;", "assertEquals ( AnnotationConfigTransactionalTestNGSpringContextTests . numTearDownCalls ,    AnnotationConfigTransactionalTestNGSpringContextTests . NUM _ TESTS ,     \" number   of   calls   to   tearDown (  )  .  \"  )  ;", "assertEquals ( AnnotationConfigTransactionalTestNGSpringContextTests . numTearDownCallsInTransaction ,    AnnotationConfigTransactionalTestNGSpringContextTests . NUM _ TX _ TESTS ,     \" number   of   calls   to   tearDown (  )    within   a   transaction .  \"  )  ;", "}", "METHOD_END"], "methodName": ["afterClass"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( deletePerson ( AnnotationConfigTransactionalTestNGSpringContextTests . YODA )  ,     1  ,     \" Deleting   yoda \"  )  ;", "assertNumRowsInPersonTable (  1  ,     \" after   a   transactional   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( createPerson ( name )  ,     1  ,     (  (  \" Adding    '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAddPerson"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( countRowsInTable (  \" person \"  )  ,    expectedNumRows ,     (  (  \" the   number   of   rows   in   the   person   table    (  \"     +    testState )     +     \"  )  .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumRowsInPersonTable"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( employee ,     \" The   employee   should   have   been   autowired .  \"  )  ;", "assertEquals ( employee . getN (  )  ,     \" John   Smith \"  )  ;", "assertNotNull ( pet ,     \" The   pet   should   have   been   autowired .  \"  )  ;", "assertEquals ( pet . getN (  )  ,     \" Fido \"  )  ;", "}", "METHOD_END"], "methodName": ["autowiringFromConfigClass"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigTransactionalTestNGSpringContextTests . numSetUpCalls    =     0  ;", "AnnotationConfigTransactionalTestNGSpringContextTests . numSetUpCallsInTransaction    =     0  ;", "AnnotationConfigTransactionalTestNGSpringContextTests . numTearDownCalls    =     0  ;", "AnnotationConfigTransactionalTestNGSpringContextTests . numTearDownCallsInTransaction    =     0  ;", "}", "METHOD_END"], "methodName": ["beforeClass"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRowsInPersonTable (  1  ,     \" before   a   transactional   test   method \"  )  ;", "assertAddPerson (  . YODA )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" INSERT   INTO   person   VALUES (  ?  )  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["createPerson"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" DELETE   FROM   person   WHERE   name =  ?  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["deletePerson"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertAddPerson (  . JANE )  ;", "assertAddPerson (  . SUE )  ;", "assertNumRowsInPersonTable (  4  ,     \" in   modifyTestDataWithinTransaction (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithinTransaction"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "( AnnotationConfigTransactionalTestNGSpringContextTests . numSetUpCalls )  +  +  ;", "if    ( TransactionTestUtils . inTransaction (  )  )     {", "( AnnotationConfigTransactionalTestNGSpringContextTests . numSetUpCallsInTransaction )  +  +  ;", "}", "assertNumRowsInPersonTable (  ( TransactionTestUtils . inTransaction (  )     ?     2     :     1  )  ,     \" before   a   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "( AnnotationConfigTransactionalTestNGSpringContextTests . numTearDownCalls )  +  +  ;", "if    ( TransactionTestUtils . inTransaction (  )  )     {", "( AnnotationConfigTransactionalTestNGSpringContextTests . numTearDownCallsInTransaction )  +  +  ;", "}", "assertNumRowsInPersonTable (  ( TransactionTestUtils . inTransaction (  )     ?     4     :     1  )  ,     \" after   a   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.test.context.testng.AnnotationConfigTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ConcreteTransactionalTestNGSpringContextTests . numSetUpCalls ,    ConcreteTransactionalTestNGSpringContextTests . NUM _ TESTS ,     \" number   of   calls   to   setUp (  )  .  \"  )  ;", "assertEquals ( ConcreteTransactionalTestNGSpringContextTests . numSetUpCallsInTransaction ,    ConcreteTransactionalTestNGSpringContextTests . NUM _ TX _ TESTS ,     \" number   of   calls   to   setUp (  )    within   a   transaction .  \"  )  ;", "assertEquals ( ConcreteTransactionalTestNGSpringContextTests . numTearDownCalls ,    ConcreteTransactionalTestNGSpringContextTests . NUM _ TESTS ,     \" number   of   calls   to   tearDown (  )  .  \"  )  ;", "assertEquals ( ConcreteTransactionalTestNGSpringContextTests . numTearDownCallsInTransaction ,    ConcreteTransactionalTestNGSpringContextTests . NUM _ TX _ TESTS ,     \" number   of   calls   to   tearDown (  )    within   a   transaction .  \"  )  ;", "}", "METHOD_END"], "methodName": ["afterClass"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( deletePerson ( ConcreteTransactionalTestNGSpringContextTests . YODA )  ,     1  ,     \" Deleting   yoda \"  )  ;", "assertNumRowsInPersonTable (  1  ,     \" after   a   transactional   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( createPerson ( name )  ,     1  ,     (  (  \" Adding    '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAddPerson"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( countRowsInTable (  \" person \"  )  ,    expectedNumRows ,     (  (  \" the   number   of   rows   in   the   person   table    (  \"     +    testState )     +     \"  )  .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumRowsInPersonTable"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "ConcreteTransactionalTestNGSpringContextTests . numSetUpCalls    =     0  ;", "ConcreteTransactionalTestNGSpringContextTests . numSetUpCallsInTransaction    =     0  ;", "ConcreteTransactionalTestNGSpringContextTests . numTearDownCalls    =     0  ;", "ConcreteTransactionalTestNGSpringContextTests . numTearDownCallsInTransaction    =     0  ;", "}", "METHOD_END"], "methodName": ["beforeClass"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRowsInPersonTable (  1  ,     \" before   a   transactional   test   method \"  )  ;", "assertAddPerson (  . YODA )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" INSERT   INTO   person   VALUES (  ?  )  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["createPerson"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "return   jdbcTemplate . update (  \" DELETE   FROM   person   WHERE   name =  ?  \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["deletePerson"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertAddPerson (  . JANE )  ;", "assertAddPerson (  . SUE )  ;", "assertNumRowsInPersonTable (  4  ,     \" in   modifyTestDataWithinTransaction (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["modifyTestDataWithinTransaction"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . bar    =    bar ;", "}", "METHOD_END"], "methodName": ["setBar"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "this . employee    =    employee ;", "}", "METHOD_END"], "methodName": ["setEmployee"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "( ConcreteTransactionalTestNGSpringContextTests . numSetUpCalls )  +  +  ;", "if    ( TransactionTestUtils . inTransaction (  )  )     {", "( ConcreteTransactionalTestNGSpringContextTests . numSetUpCallsInTransaction )  +  +  ;", "}", "assertNumRowsInPersonTable (  ( TransactionTestUtils . inTransaction (  )     ?     2     :     1  )  ,     \" before   a   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "( ConcreteTransactionalTestNGSpringContextTests . numTearDownCalls )  +  +  ;", "if    ( TransactionTestUtils . inTransaction (  )  )     {", "( ConcreteTransactionalTestNGSpringContextTests . numTearDownCallsInTransaction )  +  +  ;", "}", "assertNumRowsInPersonTable (  ( TransactionTestUtils . inTransaction (  )     ?     4     :     1  )  ,     \" after   a   test   method \"  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertNull ( nonrequiredLong ,     \" The   nonrequiredLong   field   should   NOT   have   been   autowired .  \"  )  ;", "assertNotNull ( pet ,     \" The   pet   field   should   have   been   autowired .  \"  )  ;", "assertEquals ( pet . getName (  )  ,     \" Fido \"  ,     \" pet ' s   name .  \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredFields"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertNotNull ( employee ,     \" The   setEmployee (  )    method   should   have   been   autowired .  \"  )  ;", "assertEquals ( employee . getName (  )  ,     \" John   Smith \"  ,     \" employee ' s   name .  \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyAnnotationAutowiredMethods"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertNotNull ( super . applicationContext ,     \" The   application   context   should   have   been   set   due   to   ApplicationContextAware   semantics .  \"  )  ;", "Employee   employeeBean    =     (  ( Employee )     ( super . applicationContext . getBean (  \" employee \"  )  )  )  ;", "assertEquals ( employeeBean . getName (  )  ,     \" John   Smith \"  ,     \" employee ' s   name .  \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyApplicationContextSet"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertTrue ( beanInitialized ,     \" This   test   instance   should   have   been   initialized   due   to   InitializingBean   semantics .  \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyBeanInitialized"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals ( beanName ,    getClass (  )  . getName (  )  ,     \" The   bean   name   of   this   test   instance   should   have   been   set   due   to   BeanNameAware   semantics .  \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyBeanNameSet"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals ( foo ,     \" Foo \"  ,     \" The   foo   field   should   have   been   injected   via    @ Resource .  \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceAnnotationInjectedFields"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertEquals ( bar ,     \" Bar \"  ,     \" The   setBar (  )    method   should   have   been   injected   via    @ Resource .  \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceAnnotationInjectedMethods"], "fileName": "org.springframework.test.context.testng.ConcreteTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "performCommonAssertions (  )  ;", "this . dirtiedApplication    =    super . application ;", "}", "METHOD_END"], "methodName": ["dirtyContext"], "fileName": "org.springframework.test.context.testng.DirtiesContextTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertNotNull ( super . applicationContext ,     \" The   application   context   should   have   been   set   due   to   ApplicationContextAware   semantics .  \"  )  ;", "assertNotNull ( super . jdbcTemplate ,     \" The   JdbcTemplate   should   have   been   created   in   setDataSource (  )    via   DI   for   the   DataSource .  \"  )  ;", "}", "METHOD_END"], "methodName": ["performCommonAssertions"], "fileName": "org.springframework.test.context.testng.DirtiesContextTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "performCommonAssertions (  )  ;", "assertNotSame ( super . applicationContext ,    this . dirtiedApplicationContext ,     \" The   application      should   have   been    ' dirtied '  .  \"  )  ;", "this . dirtiedApplicationContext    =    super . applicationContext ;", "}", "METHOD_END"], "methodName": ["verifyContextWasDirtied"], "fileName": "org.springframework.test.context.testng.DirtiesContextTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . applicationContext ,    this . dirtiedApplicationContext ,     \" The   application   context   should   NOT   have   been    ' dirtied '  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyContextWasNotDirtied"], "fileName": "org.springframework.test.context.testng.DirtiesContextTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "}", "METHOD_END"], "methodName": ["testWithTimeout"], "fileName": "org.springframework.test.context.testng.TimedTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "}", "METHOD_END"], "methodName": ["testWithoutTimeout"], "fileName": "org.springframework.test.context.testng.TimedTransactionalTestNGSpringContextTests"}, {"methodBody": ["METHOD_START", "{", "em . flush (  )  ;", "}", "METHOD_END"], "methodName": ["synchronizePersistenceContext"], "fileName": "org.springframework.test.context.testng.transaction.ejb.AbstractEjbTxDaoTestNGTests"}, {"methodBody": ["METHOD_START", "{", "int   count    =    dao . getCount ( AbstractEjbTxDaoTestNGTests . TEST _ NAME )  ;", "assertEquals (  \" New   TestEntity   should   have   count =  0  .  \"  ,     0  ,    count )  ;", "}", "METHOD_END"], "methodName": ["test1InitialState"], "fileName": "org.springframework.test.context.testng.transaction.ejb.AbstractEjbTxDaoTestNGTests"}, {"methodBody": ["METHOD_START", "{", "int   count    =    dao . incrementCount ( AbstractEjbTxDaoTestNGTests . TEST _ NAME )  ;", "assertEquals (  \" Expected   count =  1    after   first   increment .  \"  ,     1  ,    count )  ;", "}", "METHOD_END"], "methodName": ["test2IncrementCount1"], "fileName": "org.springframework.test.context.testng.transaction.ejb.AbstractEjbTxDaoTestNGTests"}, {"methodBody": ["METHOD_START", "{", "int   count    =    dao . getCount ( AbstractEjbTxDaoTestNGTests . TEST _ NAME )  ;", "assertEquals (  \" Expected   count =  1    after   test 2 IncrementCount 1  (  )  .  \"  ,     1  ,    count )  ;", "count    =    dao . incrementCount ( AbstractEjbTxDaoTestNGTests . TEST _ NAME )  ;", "assertEquals (  \" Expected   count =  2    now .  \"  ,     2  ,    count )  ;", "}", "METHOD_END"], "methodName": ["test3IncrementCount2"], "fileName": "org.springframework.test.context.testng.transaction.ejb.AbstractEjbTxDaoTestNGTests"}, {"methodBody": ["METHOD_START", "{", "switch    ( method )     {", "case    \" commitTxAndStartNewTx \"     :", "case    \" commitTxButDoNotStartNewTx \"     :", "{", "assertUsers (  \" Dogbert \"  )  ;", "break ;", "}", "case    \" rollbackTxAndStartNewTx \"     :", "case    \" rollbackTxButDoNotStartNewTx \"     :", "case    \" startTxWithExistingTransaction \"     :", "{", "assertUsers (  \" Dilbert \"  )  ;", "break ;", "}", "case    \" rollbackTxAndStartNewTxWithDefaultCommitSemantics \"     :", "{", "assertUsers (  \" Dilbert \"  ,     \" Dogbert \"  )  ;", "break ;", "}", "default    :", "{", "TransactionTestUtils . fail (  (  \" missing    ' after    '    assertion   for   test   method :     \"     +     ( method )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    expected    =    Arrays . asList ( users )  ;", "Colles . sort ( expected )  ;", "List < String >    actual    =    jdbcTemplate . queryForList (  \" select   name   from   user \"  ,    String . class )  ;", "Colles . sort ( actual )  ;", "assertEquals (  \" Users   in   database ;  \"  ,    expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertUsers"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "deleteFromTables (  \" user \"  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data . sql \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "TestTransaction . flagForCommit (  )  ;", "assertFalse ( TestTransaction . isFlaggedForRollback (  )  )  ;", "TestTransaction . end (  )  ;", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertFalse ( TestTransaction . isActive (  )  )  ;", "assertUsers (  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data - add - dogbert . sql \"  ,    false )  ;", "assertUsers (  \" Dogbert \"  )  ;", "TestTransaction . start (  )  ;", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["commitTxAndStartNewTx"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "TestTransaction . flagForCommit (  )  ;", "assertFalse ( TestTransaction . isFlaggedForRollback (  )  )  ;", "TestTransaction . end (  )  ;", "assertFalse ( TestTransaction . isActive (  )  )  ;", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertUsers (  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data - add - dogbert . sql \"  ,    false )  ;", "assertUsers (  \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["commitTxButDoNotStartNewTx"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . end (  )  ;", "}", "METHOD_END"], "methodName": ["endTxWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . flagForCommit (  )  ;", "}", "METHOD_END"], "methodName": ["flagForCommitWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . flagForRollback (  )  ;", "}", "METHOD_END"], "methodName": ["flagForRollbackWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( TestTransaction . isActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["isActiveWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . isFlaggedForRollback (  )  ;", "}", "METHOD_END"], "methodName": ["isFlaggedForRollbackWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "assertTrue ( TestTransaction . isFlaggedForRollback (  )  )  ;", "TestTransaction . end (  )  ;", "assertFalse ( TestTransaction . isActive (  )  )  ;", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertUsers (  \" Dilbert \"  )  ;", "TestTransaction . start (  )  ;", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isFlaggedForRollback (  )  )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data - add - dogbert . sql \"  ,    false )  ;", "assertUsers (  \" Dilbert \"  ,     \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["rollbackTxAndStartNewTx"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "TestTransaction . flagForRollback (  )  ;", "assertTrue ( TestTransaction . isFlaggedForRollback (  )  )  ;", "TestTransaction . end (  )  ;", "assertFalse ( TestTransaction . isActive (  )  )  ;", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertUsers (  \" Dilbert \"  )  ;", "TestTransaction . start (  )  ;", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertFalse ( TestTransaction . isFlaggedForRollback (  )  )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data - add - dogbert . sql \"  ,    false )  ;", "assertUsers (  \" Dilbert \"  ,     \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["rollbackTxAndStartNewTxWithDefaultCommitSemantics"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TestUtils . assertInTtrue )  ;", "assertTrue ( TestTisActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "assertTrue ( TestTisFlaggedForRollback (  )  )  ;", "TestTend (  )  ;", "assertFalse ( TestTisActive (  )  )  ;", "TestUtils . assertInTfalse )  ;", "assertUsers (  \" Dilbert \"  )  ;", "}", "METHOD_END"], "methodName": ["rollbackTxButDoNotStartNewTx"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . start (  )  ;", "}", "METHOD_END"], "methodName": ["startTxWithExistingTransaction"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . start (  )  ;", "}", "METHOD_END"], "methodName": ["startTxWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.testng.transaction.programmatic.ProgrammaticTxMgmtTestNGTests"}, {"methodBody": ["METHOD_START", "{", "assertInjectedServletRequestEqualsRequestInRequestContextHolder (  )  ;", "}", "METHOD_END"], "methodName": ["ensureMocksAreReinjectedBetweenTests_1"], "fileName": "org.springframework.test.context.testng.web.ServletTestExecutionListenerTestNGIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertInjectedServletRequestEqualsRequestInRequestContextHolder (  )  ;", "}", "METHOD_END"], "methodName": ["ensureMocksAreReinjectedBetweenTests_2"], "fileName": "org.springframework.test.context.testng.web.ServletTestExecutionListenerTestNGIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  0  )  ;", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.transaction.PrimaryTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Number   of   rows   in   the    ' user '    table \"  ,    expected ,    JdbcTestUtils . countRowsInTable ( this . jdbcTemplate ,     \" user \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumUsers"], "fileName": "org.springframework.test.context.transaction.PrimaryTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertNumUsers (  0  )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.transaction.PrimaryTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource 1  )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.transaction.PrimaryTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "ClassPathResource   resource    =    new   ClassPathResource (  \"  / test / context / jdbc / data . sql \"  )  ;", "new   jdbc . datasource . init . ResourceDatabasePopulator ( resource )  . execute ( jdbcTemplate . getDataSource (  )  )  ;", "assertNumUsers (  1  )  ;", "}", "METHOD_END"], "methodName": ["transactionalTest"], "fileName": "org.springframework.test.context.transaction.PrimaryTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testContext ,     \" TestContext   must   not   be   null \"  )  ;", "Assert . notNull ( targetAttribute ,     \" Target   TransactionAttribute   must   not   be   null \"  )  ;", "return   new    . TestContextTransactionAttribute ( targetAttribute ,    testContext )  ;", "}", "METHOD_END"], "methodName": ["createDelegatingTransactionAttribute"], "fileName": "org.springframework.test.context.transaction.TestContextTransactionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( TestContextTransactionUtils . logger . isDebugEnabled (  )  )     {", "TestContextTransactionUtils . logger . debug ( String . format (  \" Caught   exception   while   retrieving    % s   for   test   context    % s \"  ,    beanType . getSimpleName (  )  ,    testContext )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["logBeansException"], "fileName": "org.springframework.test.context.transaction.TestContextTransactionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testContext ,     \" TestContext   must   not   be   null \"  )  ;", "BeanFactory   bf    =    testContext . getApplicationContext (  )  . getAutowireCapableBeanFactory (  )  ;", "try    {", "if    ( StringUtils . hasText ( name )  )     {", "return   bf . getBean ( name ,    DataSource . class )  ;", "}", "}    catch    ( BeansException   ex )     {", ". logger . error ( String . format (  \" Failed   to   retrieve   DataSource   named    '  % s '    for   test   context    % s \"  ,    name ,    testContext )  ,    ex )  ;", "throw   ex ;", "}", "try    {", "if    ( bf   instanceof   ListableBeanFactory )     {", "ListableBeanFactory   lbf    =     (  ( ListableBeanFactory )     ( bf )  )  ;", "Map < String ,    DataSource >    dataSources    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( lbf ,    DataSource . class )  ;", "if    (  ( dataSources . size (  )  )     =  =     1  )     {", "return   dataSources . values (  )  . iterator (  )  . next (  )  ;", "}", "try    {", "return   bf . getBean ( DataSource . class )  ;", "}    catch    ( BeansException   ex )     {", ". logBeansException ( testContext ,    ex ,    PlatformTransactionManager . class )  ;", "}", "}", "return   bf . getBean (  . DEFAULT _ DATA _ SOURCE _ NAME ,    DataSource . class )  ;", "}    catch    ( BeansException   ex )     {", ". logBeansException ( testContext ,    ex ,    DataSource . class )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["retrieveDataSource"], "fileName": "org.springframework.test.context.transaction.TestContextTransactionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( testContext ,     \" TestContext   must   not   be   null \"  )  ;", "BeanFactory   bf    =    testContext . getApplicationContext (  )  . getAutowireCapableBeanFactory (  )  ;", "try    {", "if    ( StringUtils . hasText ( name )  )     {", "return   bf . getBean ( name ,    PlatformTransactionManager . class )  ;", "}", "}    catch    ( BeansException   ex )     {", ". logger . error ( String . format (  \" Failed   to   retrieve   transaction   manager   named    '  % s '    for   test   context    % s \"  ,    name ,    testContext )  ,    ex )  ;", "throw   ex ;", "}", "try    {", "if    ( bf   instanceof   ListableBeanFactory )     {", "ListableBeanFactory   lbf    =     (  ( ListableBeanFactory )     ( bf )  )  ;", "Map < String ,    PlatformTransactionManager >    txMgrs    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( lbf ,    PlatformTransactionManager . class )  ;", "if    (  ( txMgrs . size (  )  )     =  =     1  )     {", "return   txMgrs . values (  )  . iterator (  )  . next (  )  ;", "}", "try    {", "return   bf . getBean ( PlatformTransactionManager . class )  ;", "}    catch    ( BeansException   ex )     {", ". logBeansException ( testContext ,    ex ,    PlatformTransactionManager . class )  ;", "}", "Map < String ,    TransactionManagementConfigurer >    configurers    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( lbf ,    TransactionManagementConfigurer . class )  ;", "Assert . state (  (  ( configurers . size (  )  )     <  =     1  )  ,     \" Only   one   TransactionManagementConfigurer   may   exist   in   the   ApplicationContext \"  )  ;", "if    (  ( configurers . size (  )  )     =  =     1  )     {", "return   configurers . values (  )  . iterator (  )  . next (  )  . annotationDrivenTransactionManager (  )  ;", "}", "}", "return   bf . getBean (  . DEFAULT _ TRANSACTION _ MANAGER _ NAME ,    PlatformTransactionManager . class )  ;", "}    catch    ( BeansException   ex )     {", ". logBeansException ( testContext ,    ex ,    PlatformTransactionManager . class )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["retrieveTransactionManager"], "fileName": "org.springframework.test.context.transaction.TestContextTransactionUtils"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . requireCurrentTransactionContext (  )  . endTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["end"], "fileName": "org.springframework.test.context.transaction.TestTransaction"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . setFlaggedForRollback ( false )  ;", "}", "METHOD_END"], "methodName": ["flagForCommit"], "fileName": "org.springframework.test.context.transaction.TestTransaction"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . setFlaggedForRollback ( true )  ;", "}", "METHOD_END"], "methodName": ["flagForRollback"], "fileName": "org.springframework.test.context.transaction.TestTransaction"}, {"methodBody": ["METHOD_START", "{", "TransactionContext   transactionContext    =    TransactionContextHolder . getCurrentTransactionContext (  )  ;", "if    ( transactionContext    !  =    null )     {", "TransactionStatus   transactionStatus    =    transactionContext . getTransactionStatus (  )  ;", "return    ( transactionStatus    !  =    null )     &  &     (  !  ( transactionStatus . isCompleted (  )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.springframework.test.context.transaction.TestTransaction"}, {"methodBody": ["METHOD_START", "{", "return   TestTransaction . requireCurrentTransactionContext (  )  . isFlaggedForRollback (  )  ;", "}", "METHOD_END"], "methodName": ["isFlaggedForRollback"], "fileName": "org.springframework.test.context.transaction.TestTransaction"}, {"methodBody": ["METHOD_START", "{", "TransactionContext   txContext    =    TransactionContextHolder . getCurrentTransactionContext (  )  ;", "Assert . state (  ( txContext    !  =    null )  ,     \" TransactionContext   is   not   active \"  )  ;", "return   txContext ;", "}", "METHOD_END"], "methodName": ["requireCurrentTransactionContext"], "fileName": "org.springframework.test.context.transaction.TestTransaction"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . requireCurrentTransactionContext (  )  . setFlaggedForRollback ( flag )  ;", "}", "METHOD_END"], "methodName": ["setFlaggedForRollback"], "fileName": "org.springframework.test.context.transaction.TestTransaction"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . requireCurrentTransactionContext (  )  . startTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.springframework.test.context.transaction.TestTransaction"}, {"methodBody": ["METHOD_START", "{", "if    ( TransactionContext . logger . isTraceEnabled (  )  )     {", "TransactionContext . logger . trace ( String . format (  \" Ending   transaction   for   test   context    % s ;    transaction   status    [  % s ]  ;    rollback    [  % s ]  \"  ,    this . testContext ,    this . transactionStatus ,    this . flaggedForRollback )  )  ;", "}", "Assert . state (  (  ( this . transactionStatus )     !  =    null )  ,     (  )     -  >     \" Failed   to   end   transaction    -    transaction   does   not   exist :     \"     +     ( this . testContext )  )  ;", "try    {", "if    ( this . flaggedForRollback )     {", "this . transactionManager . rollback ( this . transactionStatus )  ;", "} else    {", "this . transactionManager . commit ( this . transactionStatus )  ;", "}", "}    finally    {", "this . transactionStatus    =    null ;", "}", "if    ( TransactionContext . logger . isInfoEnabled (  )  )     {", "TransactionContext . logger . info (  (  (  ( this . flaggedForRollback    ?     \" Rolled   back \"     :     \" Committed \"  )     +     \"    transaction   for   test :     \"  )     +     ( this . testContext )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["endTransaction"], "fileName": "org.springframework.test.context.transaction.TransactionContext"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionStatus ;", "}", "METHOD_END"], "methodName": ["getTransactionStatus"], "fileName": "org.springframework.test.context.transaction.TransactionContext"}, {"methodBody": ["METHOD_START", "{", "return   this . flaggedForRollback ;", "}", "METHOD_END"], "methodName": ["isFlaggedForRollback"], "fileName": "org.springframework.test.context.transaction.TransactionContext"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . transactionStatus )     !  =    null )  ,     (  )     -  >     \" Failed   to   set   rollback   flag    -    transaction   does   not   exist :     \"     +     ( this . testContext )  )  ;", "this . flaggedForRollback    =    flaggedForRollback ;", "}", "METHOD_END"], "methodName": ["setFlaggedForRollback"], "fileName": "org.springframework.test.context.transaction.TransactionContext"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . transactionStatus )     =  =    null )  ,     \" Cannot   start   a   new   transaction   without   ending   the   existing   transaction   first \"  )  ;", "this . flaggedForRollback    =    this . defaultRollback ;", "this . transactionStatus    =    this . transactionManager . getTransaction ( this . transactionDefinition )  ;", "int   transactionsStarted    =    this . transactionsStarted . incrementAndGet (  )  ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( String . format (  \" Began   transaction    (  % s )    for   test   context    % s ;    transaction   manager    [  % s ]  ;    rollback    [  % s ]  \"  ,    transactionsStarted ,    this . testContext ,    this . transactionManager ,    flaggedForRollback )  )  ;", "}", "}", "METHOD_END"], "methodName": ["startTransaction"], "fileName": "org.springframework.test.context.transaction.TransactionContext"}, {"methodBody": ["METHOD_START", "{", "return   TransactionContextHolder . currentTransactionContext . get (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentTransactionContext"], "fileName": "org.springframework.test.context.transaction.TransactionContextHolder"}, {"methodBody": ["METHOD_START", "{", "TransactionContext   transactionContext    =    TransactionContextHolder . currentTransactionContext . get (  )  ;", "TransactionContextHolder . currentTransactionContext . remove (  )  ;", "return   transactionContext ;", "}", "METHOD_END"], "methodName": ["removeCurrentTransactionContext"], "fileName": "org.springframework.test.context.transaction.TransactionContextHolder"}, {"methodBody": ["METHOD_START", "{", "TransactionContextHolder . currentTransactionContext . set ( transactionContext )  ;", "}", "METHOD_END"], "methodName": ["setCurrentTransactionContext"], "fileName": "org.springframework.test.context.transaction.TransactionContextHolder"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . stream ( ReflectionUtils . getUniqueDeclaredMethods ( clazz )  )  . filter (  (    method )     -  >    AnnotatedElementUtils . hasAnnotation ( method ,    annotationType )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotatedMethods"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "return   TestContextTransactionUtils . retrieveTransactionManager ( testContext ,    null )  ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( qualifier )  )     {", "try    {", "BeanFactory   bf    =    testContext . getApplicationContext (  )  . getAutowireCapableBeanFactory (  )  ;", "return   BeanFactoryAnnotationUtils . qualifiedBeanOfType ( bf ,    PlatformTransactionManager . class ,    qualifier )  ;", "}    catch    ( RuntimeException   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn ( String . format (  \" Caught   exception   while   retrieving   transaction   manager   with   qualifier    '  % s '    for   test   context    % s \"  ,    qualifier ,    testContext )  ,    ex )  ;", "}", "throw   ex ;", "}", "}", "return   getTransactionManager ( testContext )  ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    testClass    =    testContext . getTestClass (  )  ;", "Rollback   rollback    =    AnnotatedElementUtils . findMergedAnnotation ( testClass ,    Rollback . class )  ;", "boolean   rollbackPresent    =    rollback    !  =    null ;", "if    ( rollbackPresent )     {", "boolean   defaultRollback    =    rollback . value (  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Retrieved   default    @ Rollback (  % s )    for   test   class    [  % s ]  .  \"  ,    defaultRollback ,    testClass . getName (  )  )  )  ;", "}", "return   defaultRollback ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isDefaultRollback"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "boolean   rollback    =    isDefaultRollback ( testContext )  ;", "Rollback   rollbackAnnotation    =    AnnotatedElementUtils . findMergedAnnotation ( testContext . getTestMethod (  )  ,    Rollback . class )  ;", "if    ( rollbackAnnotation    !  =    null )     {", "boolean   rollbackOverride    =    rollbackAnnotation . value (  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Method - level    @ Rollback (  % s )    overrides   default   rollback    [  % s ]    for   test   context    % s .  \"  ,    rollbackOverride ,    rollback ,    testContext )  )  ;", "}", "rollback    =    rollbackOverride ;", "} else    {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" No   method - level    @ Rollback   override :    using   default   rollback    [  % s ]    for   test   context    % s .  \"  ,    rollback ,    testContext )  )  ;", "}", "}", "return   rollback ;", "}", "METHOD_END"], "methodName": ["isRollback"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "Throwable   afterTransactionException    =    null ;", "List < Method >    methods    =    getAnnotatedMethods ( testContext . getTestClass (  )  ,    AfterTransaction . class )  ;", "for    ( Method   method    :    methods )     {", "try    {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Executing    @ AfterTransaction   method    [  \"     +    method )     +     \"  ]    for   test   context    \"  )     +    testContext )  )  ;", "}", "ReflectionUtils . makeAccessible ( method )  ;", "method . invoke ( testContext . getTestInstance (  )  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   targetException    =    ex . getTargetException (  )  ;", "if    ( afterTransactionException    =  =    null )     {", "afterTransactionException    =    targetException ;", "}", ". logger . error (  (  (  (  \" Exception   encountered   while   executing    @ AfterTransaction   method    [  \"     +    method )     +     \"  ]    for   test   context    \"  )     +    testContext )  ,    targetException )  ;", "}    catch    ( Exception   ex )     {", "if    ( afterTransactionException    =  =    null )     {", "afterTransactionException    =    ex ;", "}", ". logger . error (  (  (  (  \" Exception   encountered   while   executing    @ AfterTransaction   method    [  \"     +    method )     +     \"  ]    for   test   context    \"  )     +    testContext )  ,    ex )  ;", "}", "}", "if    ( afterTransactionException    !  =    null )     {", "ReflectionUtils . rethrowException ( afterTransactionException )  ;", "}", "}", "METHOD_END"], "methodName": ["runAfterTransactionMethods"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "try    {", "List < Method >    methods    =    getAnnotatedMethods ( testContext . getTestClass (  )  ,    BeforeTransaction . class )  ;", "Collections . reverse ( methods )  ;", "for    ( Method   method    :    methods )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Executing    @ BeforeTransaction   method    [  \"     +    method )     +     \"  ]    for   test   context    \"  )     +    testContext )  )  ;", "}", "ReflectionUtils . makeAccessible ( method )  ;", "method . invoke ( testContext . getTestInstance (  )  )  ;", "}", "}    catch    ( InvocationTargetException   ex )     {", "if    (  . logger . isErrorEnabled (  )  )     {", ". logger . error (  (  (  \" Exception   encountered   while   executing    @ BeforeTransaction   methods   for   test   context    \"     +    testContext )     +     \"  .  \"  )  ,    ex . getTargetException (  )  )  ;", "}", "ReflectionUtils . rethrowException ( ex . getTargetException (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["runBeforeTransactionMethods"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "assertAfterTestMethod ( TransactionalTestExecutionListenerTests . AfterTransactionDeclaredAsInterfaceDefaultMethodTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["afterTestMethodWithAfterTransactionDeclaredAsInterfaceDefaultMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertAfterTestMethod ( TransactionalTestExecutionListenerTests . AfterTransactionDeclaredLocallyTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["afterTestMethodWithAfterTransactionDeclaredLocally"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertAfterTestMethod ( TransactionalTestExecutionListenerTests . AfterTransactionDeclaredViaMetaAnnotationTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["afterTestMethodWithAfterTransactionDeclaredViaMetaAnnotation"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertAfterTestMethodWithTransactionalTestMethod ( clazz )  ;", "assertAfterTestMethodWithNonTransactionalTestMethod ( clazz )  ;", "}", "METHOD_END"], "methodName": ["assertAfterTestMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", ". Invocable   instance    =    BeanUtils . instantiateClass ( clazz )  ;", "given ( testContext . getTestInstance (  )  )  . willReturn ( instance )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" nonTransactionalTest \"  )  )  ;", "assertFalse (  \" callback   should   not   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "TransactionContextHolder . removeCurrentTransactionContext (  )  ;", "listener . beforeTestMethod ( testContext )  ;", "listener . afterTestMethod ( testContext )  ;", "assertFalse (  \" callback   should   not   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAfterTestMethodWithNonTransactionalTestMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", ". Invocable   instance    =    BeanUtils . instantiateClass ( clazz )  ;", "given ( testContext . getTestInstance (  )  )  . willReturn ( instance )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" transactionalTest \"  )  )  ;", "given ( tm . getTransaction ( BDDMockito . any ( TransactionDefinition . class )  )  )  . willReturn ( new   SimpleTransactionStatus (  )  )  ;", "assertFalse (  \" callback   should   not   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "TransactionContextHolder . removeCurrentTransactionContext (  )  ;", "listener . beforeTestMethod ( testContext )  ;", "assertFalse (  \" callback   should   not   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "listener . afterTestMethod ( testContext )  ;", "assertTrue (  \" callback   should   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAfterTestMethodWithTransactionalTestMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethodWithTransactionalTestMethod ( clazz )  ;", "assertBeforeTestMethodWithNonTransactionalTestMethod ( clazz )  ;", "}", "METHOD_END"], "methodName": ["assertBeforeTestMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", ". Invocable   instance    =    BeanUtils . instantiateClass ( clazz )  ;", "given ( testContext . getTestInstance (  )  )  . willReturn ( instance )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" nonTransactionalTest \"  )  )  ;", "assertFalse (  \" callback   should   not   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "TransactionContextHolder . removeCurrentTransactionContext (  )  ;", "listener . beforeTestMethod ( testContext )  ;", "assertFalse (  \" callback   should   not   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertBeforeTestMethodWithNonTransactionalTestMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethodWithTransactionalTestMethod ( clazz ,    true )  ;", "}", "METHOD_END"], "methodName": ["assertBeforeTestMethodWithTransactionalTestMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", ". Invocable   instance    =    BeanUtils . instantiateClass ( clazz )  ;", "given ( testContext . getTestInstance (  )  )  . willReturn ( instance )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" transactionalTest \"  )  )  ;", "assertFalse (  \" callback   should   not   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "TransactionContextHolder . removeCurrentTransactionContext (  )  ;", "listener . beforeTestMethod ( testContext )  ;", "assertEquals ( invokedInTx ,    instance . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertBeforeTestMethodWithTransactionalTestMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" test \"  )  )  ;", "assertEquals ( rollback ,    listener . isRollback ( testContext )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsRollback"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethod ( TransactionalTestExecutionListenerTests . BeforeTransactionDeclaredAsInterfaceDefaultMethodTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithBeforeTransactionDeclaredAsInterfaceDefaultMethod"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethod ( TransactionalTestExecutionListenerTests . BeforeTransactionDeclaredLocallyTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithBeforeTransactionDeclaredLocally"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethod ( TransactionalTestExecutionListenerTests . BeforeTransactionDeclaredViaMetaAnnotationTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithBeforeTransactionDeclaredViaMetaAnnotation"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethodWithTransactionalTestMethod ( TransactionalTestExecutionListenerTests . TransactionalDeclaredOnClassLocallyTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithTransactionalDeclaredOnClassLocally"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethodWithTransactionalTestMethod ( TransactionalTestExecutionListenerTests . TransactionalDeclaredOnClassViaMetaAnnotationTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithTransactionalDeclaredOnClassViaMetaAnnotation"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethodWithTransactionalTestMethod ( TransactionalTestExecutionListenerTests . TransactionalDeclaredOnClassViaMetaAnnotationWithOverrideTestCase . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithTransactionalDeclaredOnClassViaMetaAnnotationWithOverride"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethod ( TransactionalTestExecutionListenerTests . TransactionalDeclaredOnMethodLocallyTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithTransactionalDeclaredOnMethodLocally"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethod ( TransactionalTestExecutionListenerTests . TransactionalDeclaredOnMethodViaMetaAnnotationTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithTransactionalDeclaredOnMethodViaMetaAnnotation"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertBeforeTestMethodWithTransactionalTestMethod ( TransactionalTestExecutionListenerTests . TransactionalDeclaredOnMethodViaMetaAnnotationWithOverrideTestCase . class ,    false )  ;", "assertBeforeTestMethodWithNonTransactionalTestMethod ( TransactionalTestExecutionListenerTests . TransactionalDeclaredOnMethodViaMetaAnnotationWithOverrideTestCase . class )  ;", "}", "METHOD_END"], "methodName": ["beforeTestMethodWithTransactionalDeclaredOnMethodViaMetaAnnotationWithOverride"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionContextHolder . removeCurrentTransactionContext (  )  ;", "}", "METHOD_END"], "methodName": ["cleanUpThreadLocalStateForSubsequentTestClassesInSuite"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . ClassLevelRollbackViaMetaAnnotationTestCase . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithClassLevelRollbackViaMetaAnnotation"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . ClassLevelRollbackViaMetaAnnotationOnTestInterfaceTestCase . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithClassLevelRollbackViaMetaAnnotationOnTestInterface"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . ClassLevelRollbackWithExplicitValueTestCase . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithClassLevelRollbackWithExplicitValue"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . ClassLevelRollbackWithExplicitValueOnTestInterfaceTestCase . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithClassLevelRollbackWithExplicitValueOnTestInterface"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . EmptyClassLevelRollbackTestCase . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithEmptyClassLevelRollback"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . EmptyMethodLevelRollbackTestCase . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithEmptyMethodLevelRollback"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . MethodLevelRollbackViaMetaAnnotationTestCase . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithMethodLevelRollbackViaMetaAnnotation"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . MethodLevelRollbackWithExplicitValueTestCase . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithMethodLevelRollbackWithExplicitValue"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertIsRollback ( TransactionalTestExecutionListenerTests . MissingRollbackTestCase . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["isRollbackWithMissingRollback"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionalTestExecutionListener   listener    =    new   TransactionalTestExecutionListener (  )     {", "protected   PlatformTransactionManager   getTransactionManager ( TestContext   testContext ,    String   qualifier )     {", "return   null ;", "}", "}  ;", "Class <  ?    extends    . Invocable >    clazz    =     . TransactionalDeclaredOnClassLocallyTestCase . class ;", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( clazz )  ;", ". Invocable   instance    =    BeanUtils . instantiateClass ( clazz )  ;", "given ( testContext . getTestInstance (  )  )  . willReturn ( instance )  ;", "given ( testContext . getTestMethod (  )  )  . willReturn ( clazz . getDeclaredMethod (  \" transactionalTest \"  )  )  ;", "assertFalse (  \" callback   should   not   have   been   invoked \"  ,    instance . invoked (  )  )  ;", "TransactionContextHolder . removeCurrentTransactionContext (  )  ;", "try    {", "listener . beforeTestMethod ( testContext )  ;", "fail (  \" Should   have   thrown   an   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "assertTrue ( e . getMessage (  )  . startsWith (  \" Failed   to   retrieve   PlatformTransactionManager   for    @ Transactional   test \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["transactionalTestWithoutTransactionManager"], "fileName": "org.springframework.test.context.transaction.TransactionalTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "em . flush (  )  ;", "}", "METHOD_END"], "methodName": ["synchronizePersistenceContext"], "fileName": "org.springframework.test.context.transaction.ejb.AbstractEjbTxDaoTests"}, {"methodBody": ["METHOD_START", "{", "int   count    =    dao . getCount ( AbstractEjbTxDaoTests . TEST _ NAME )  ;", "assertEquals (  \" New   TestEntity   should   have   count =  0  .  \"  ,     0  ,    count )  ;", "}", "METHOD_END"], "methodName": ["test1InitialState"], "fileName": "org.springframework.test.context.transaction.ejb.AbstractEjbTxDaoTests"}, {"methodBody": ["METHOD_START", "{", "int   count    =    dao . incrementCount ( AbstractEjbTxDaoTests . TEST _ NAME )  ;", "assertEquals (  \" Expected   count =  1    after   first   increment .  \"  ,     1  ,    count )  ;", "}", "METHOD_END"], "methodName": ["test2IncrementCount1"], "fileName": "org.springframework.test.context.transaction.ejb.AbstractEjbTxDaoTests"}, {"methodBody": ["METHOD_START", "{", "int   count    =    dao . getCount ( AbstractEjbTxDaoTests . TEST _ NAME )  ;", "assertEquals (  \" Expected   count =  1    after   test 2 IncrementCount 1  (  )  .  \"  ,     1  ,    count )  ;", "count    =    dao . incrementCount ( AbstractEjbTxDaoTests . TEST _ NAME )  ;", "assertEquals (  \" Expected   count =  2    now .  \"  ,     2  ,    count )  ;", "}", "METHOD_END"], "methodName": ["test3IncrementCount2"], "fileName": "org.springframework.test.context.transaction.ejb.AbstractEjbTxDaoTests"}, {"methodBody": ["METHOD_START", "{", "return   getTestEntity ( name )  . getCount (  )  ;", "}", "METHOD_END"], "methodName": ["getCountInternal"], "fileName": "org.springframework.test.context.transaction.ejb.dao.AbstractEjbTxTestEntityDao"}, {"methodBody": ["METHOD_START", "{", "TestEntity   te    =    entityManager . find ( TestEntity . class ,    name )  ;", "if    ( te    =  =    null )     {", "te    =    new   TestEntity ( name ,     0  )  ;", "entityManager . persist ( te )  ;", "}", "return   te ;", "}", "METHOD_END"], "methodName": ["getTestEntity"], "fileName": "org.springframework.test.context.transaction.ejb.dao.AbstractEjbTxTestEntityDao"}, {"methodBody": ["METHOD_START", "{", "TestEntity   te    =    getTestEntity ( name )  ;", "int   count    =    te . getCount (  )  ;", "count +  +  ;", "te . setCount ( count )  ;", "return   count ;", "}", "METHOD_END"], "methodName": ["incrementCountInternal"], "fileName": "org.springframework.test.context.transaction.ejb.dao.AbstractEjbTxTestEntityDao"}, {"methodBody": ["METHOD_START", "{", "return   this . count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.test.context.transaction.ejb.model.TestEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.test.context.transaction.ejb.model.TestEntity"}, {"methodBody": ["METHOD_START", "{", "this . count    =    count ;", "}", "METHOD_END"], "methodName": ["setCount"], "fileName": "org.springframework.test.context.transaction.ejb.model.TestEntity"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.test.context.transaction.ejb.model.TestEntity"}, {"methodBody": ["METHOD_START", "{", "String   method    =    testName . getMethodName (  )  ;", "switch    ( method )     {", "case    \" commitTxAndStartNewTx \"     :", "case    \" commitTxButDoNotStartNewTx \"     :", "{", "assertUsers (  \" Dogbert \"  )  ;", "break ;", "}", "case    \" rollbackTxAndStartNewTx \"     :", "case    \" rollbackTxButDoNotStartNewTx \"     :", "case    \" startTxWithExistingTransaction \"     :", "{", "assertUsers (  \" Dilbert \"  )  ;", "break ;", "}", "case    \" rollbackTxAndStartNewTxWithDefaultCommitSemantics \"     :", "{", "assertUsers (  \" Dilbert \"  ,     \" Dogbert \"  )  ;", "break ;", "}", "default    :", "{", "TransactionTestUtils . fail (  (  \" missing    ' after    '    assertion   for   test   method :     \"     +    method )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["afterTransaction"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    expected    =    Arrays . asList ( users )  ;", "Colles . sort ( expected )  ;", "List < String >    actual    =    jdbcTemplate . queryForList (  \" select   name   from   user \"  ,    String . class )  ;", "Colles . sort ( actual )  ;", "assertEquals (  \" Users   in   database ;  \"  ,    expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertUsers"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "deleteFromTables (  \" user \"  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data . sql \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["beforeTransaction"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "TestTransaction . flagForCommit (  )  ;", "assertFalse ( TestTransaction . isFlaggedForRollback (  )  )  ;", "TestTransaction . end (  )  ;", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertFalse ( TestTransaction . isActive (  )  )  ;", "assertUsers (  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data - add - dogbert . sql \"  ,    false )  ;", "assertUsers (  \" Dogbert \"  )  ;", "TestTransaction . start (  )  ;", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["commitTxAndStartNewTx"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "TestTransaction . flagForCommit (  )  ;", "assertFalse ( TestTransaction . isFlaggedForRollback (  )  )  ;", "TestTransaction . end (  )  ;", "assertFalse ( TestTransaction . isActive (  )  )  ;", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertUsers (  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data - add - dogbert . sql \"  ,    false )  ;", "assertUsers (  \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["commitTxButDoNotStartNewTx"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "return   JdbcTestUtils . deleteFromTables ( this . jdbcTemplate ,    names )  ;", "}", "METHOD_END"], "methodName": ["deleteFromTables"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . end (  )  ;", "}", "METHOD_END"], "methodName": ["endTxWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    this . applicationContext . getResource ( sqlResourcePath )  ;", "new   jdbc . datasource . init . ResourceDatabasePopulator ( continueOnError ,    false ,    this . sqlScriptEncoding ,    resource )  . execute ( jdbcTemplate . getDataSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["executeSqlScript"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . flagForCommit (  )  ;", "}", "METHOD_END"], "methodName": ["flagForCommitWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . flagForRollback (  )  ;", "}", "METHOD_END"], "methodName": ["flagForRollbackWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( TestTransaction . isActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["isActiveWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . isFlaggedForRollback (  )  ;", "}", "METHOD_END"], "methodName": ["isFlaggedForRollbackWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "assertTrue ( TestTransaction . isFlaggedForRollback (  )  )  ;", "TestTransaction . end (  )  ;", "assertFalse ( TestTransaction . isActive (  )  )  ;", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertUsers (  \" Dilbert \"  )  ;", "TestTransaction . start (  )  ;", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isFlaggedForRollback (  )  )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data - add - dogbert . sql \"  ,    false )  ;", "assertUsers (  \" Dilbert \"  ,     \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["rollbackTxAndStartNewTx"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "TestTransaction . flagForRollback (  )  ;", "assertTrue ( TestTransaction . isFlaggedForRollback (  )  )  ;", "TestTransaction . end (  )  ;", "assertFalse ( TestTransaction . isActive (  )  )  ;", "TransactionTestUtils . assertInTransaction ( false )  ;", "assertUsers (  \" Dilbert \"  )  ;", "TestTransaction . start (  )  ;", "TransactionTestUtils . assertInTransaction ( true )  ;", "assertFalse ( TestTransaction . isFlaggedForRollback (  )  )  ;", "assertTrue ( TestTransaction . isActive (  )  )  ;", "executeSqlScript (  \" classpath :  / org /  / test / context / jdbc / data - add - dogbert . sql \"  ,    false )  ;", "assertUsers (  \" Dilbert \"  ,     \" Dogbert \"  )  ;", "}", "METHOD_END"], "methodName": ["rollbackTxAndStartNewTxWithDefaultCommitSemantics"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TestUtils . assertInTtrue )  ;", "assertTrue ( TestTisActive (  )  )  ;", "assertUsers (  \" Dilbert \"  )  ;", "deleteFromTables (  \" user \"  )  ;", "assertUsers (  )  ;", "assertTrue ( TestTisFlaggedForRollback (  )  )  ;", "TestTend (  )  ;", "assertFalse ( TestTisActive (  )  )  ;", "TestUtils . assertInTfalse )  ;", "assertUsers (  \" Dilbert \"  )  ;", "}", "METHOD_END"], "methodName": ["rollbackTxButDoNotStartNewTx"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . start (  )  ;", "}", "METHOD_END"], "methodName": ["startTxWithExistingTransaction"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "TestTransaction . start (  )  ;", "}", "METHOD_END"], "methodName": ["startTxWithNonExistentTransactionContext"], "fileName": "org.springframework.test.context.transaction.programmatic.ProgrammaticTxMgmtTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    convertedPaths    =    new   String [ paths . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( paths . length )  ;    i +  +  )     {", "String   path    =    paths [ i ]  ;", "if    ( path . startsWith (  . SLASH )  )     {", "convertedPaths [ i ]     =     ( ResourceUtils . CLASSPATH _ URL _ PREFIX )     +    path ;", "} else", "if    (  !  ( isUrl ( path )  )  )     {", "convertedPaths [ i ]     =     (  ( ResourceUtils . CLASSPATH _ URL _ PREFIX )     +     (  . SLASH )  )     +     ( cleanPath (  (  (  ( classPackageAsResourcePath ( clazz )  )     +     (  . SLASH )  )     +    path )  )  )  ;", "} else    {", "convertedPaths [ i ]     =    cleanPath ( path )  ;", "}", "}", "return   convertedPaths ;", "}", "METHOD_END"], "methodName": ["convertToClasspathResourcePaths"], "fileName": "org.springframework.test.context.util.TestContextResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   TestContextResourceUtils . stream ( resourceLoader ,    paths )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertToResourceList"], "fileName": "org.springframework.test.context.util.TestContextResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   TestContextResourceUtils . stream ( resourceLoader ,    paths )  . toArray ( Resource [  ]  :  : new )  ;", "}", "METHOD_END"], "methodName": ["convertToResources"], "fileName": "org.springframework.test.context.util.TestContextResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . stream ( paths )  . map ( resourceLoader :  : getResource )  ;", "}", "METHOD_END"], "methodName": ["stream"], "fileName": "org.springframework.test.context.util.TestContextResourceUtils"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" ServletCshould   be   set   in   the   WAC .  \"  ,    wac . getServletC )  )  ;", "assertNotNull (  \" ServletCshould   have   been   set   via   ServletCware .  \"  ,    servletC ;", "assertNotNull (  \" ServletCshould   have   been   autowired   from   the   WAC .  \"  ,    mockServletC ;", "assertNotNull (  \" MockHttpServletRequest   should   have   been   autowired   from   the   WAC .  \"  ,    request )  ;", "assertNotNull (  \" MockHttpServletResponse   should   have   been   autowired   from   the   WAC .  \"  ,    response )  ;", "assertNotNull (  \" MockHttpSession   should   have   been   autowired   from   the   WAC .  \"  ,    session )  ;", "assertNotNull (  \" ServletWebRequest   should   have   been   autowired   from   the   WAC .  \"  ,    webRequest )  ;", "Object   rootWac    =    mockServletCgetAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  ;", "assertNotNull (  (  \" Root   WAC   must   be   stored   in   the   ServletCas :     \"     +     ( WebApplicationCROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ,    rootWac )  ;", "assertSame (  \" test   WAC   and   Root   WAC   in   ServletCmust   be   the   same   object .  \"  ,    wac ,    rootWac )  ;", "assertSame (  \" ServletCinstances   must   be   the   same   object .  \"  ,    mockServletC   wac . getServletC )  )  ;", "assertSame (  \" ServletCin   the   WAC   and   in   the   mock   request \"  ,    mockServletC   request . getServletC )  )  ;", "assertEquals (  \" Getting   real   path   for   ServletCresource .  \"  ,    new   File (  \" src / main / webapp / index . jsp \"  )  . getCanonicalPath (  )  ,    mockServletCgetRealPath (  \" index . jsp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["basicWacFeatures"], "fileName": "org.springframework.test.context.web.AbstractBasicWacTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   parent    =    context . getParent (  )  ;", "if    (  ( parent    =  =    null )     |  |     (  !  ( parent   instanceof   WebApplicationContext )  )  )     {", "String   resourceBasePath    =    webMergedConfig . getResourceBasePath (  )  ;", "ResourceLoader   resourceLoader    =     ( resourceBasePath . startsWith ( CLASSPATH _ URL _ PREFIX )  )     ?    new   DefaultResourceLoader (  )     :    new   FileSystemResourceLoader (  )  ;", "ServletContext   servletContext    =    new   MockServletContext ( resourceBasePath ,    resourceLoader )  ;", "servletContext . setAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    context )  ;", "context . setServletContext ( servletContext )  ;", "} else    {", "ServletContext   servletContext    =    null ;", "while    ( parent    !  =    null )     {", "if    (  ( parent   instanceof   WebApplicationContext )     &  &     (  !  (  ( parent . getParent (  )  )    instanceof   WebApplicationContext )  )  )     {", "servletContext    =     (  ( WebApplicationContext )     ( parent )  )  . getServletContext (  )  ;", "break ;", "}", "parent    =    parent . getParent (  )  ;", "}", "Assert . state (  ( servletContext    !  =    null )  ,     \" Failed   to   find   root   WebApplicationContext   in   the   context   hierarchy \"  )  ;", "context . setServletContext ( servletContext )  ;", "}", "}", "METHOD_END"], "methodName": ["configureWebResources"], "fileName": "org.springframework.test.context.web.AbstractGenericWebContextLoader"}, {"methodBody": ["METHOD_START", "{", "super . customizeContext ( context ,    webMergedConfig )  ;", "}", "METHOD_END"], "methodName": ["customizeContext"], "fileName": "org.springframework.test.context.web.AbstractGenericWebContextLoader"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationConfigContextLoaderUtils . detectDefaultConfigurationClasses ( declaringClass )  ;", "}", "METHOD_END"], "methodName": ["detectDefaultConfigurationClasses"], "fileName": "org.springframework.test.context.web.AnnotationConfigWebContextLoader"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( containsString (  \" does   not   support   resource   locations \"  )  )  ;", "AnnotationConfigWebContextLoader   loader    =    new   AnnotationConfigWebContextLoader (  )  ;", "WebMergedContextConfiguration   mergedConfig    =    new   WebMergedContextConfiguration ( getClass (  )  ,    new   String [  ]  {     \" config . xml \"     }  ,     . EMPTY _ CLASS _ ARRAY ,    null ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,     \" resource / path \"  ,    loader ,    null ,    null )  ;", "loader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["configMustNotContainLocations"], "fileName": "org.springframework.test.context.web.AnnotationConfigWebContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" enigma \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["fooEnigmaAutowired"], "fileName": "org.springframework.test.context.web.BasicAnnotationConfigWacTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( servletContextAwareBean )  ;", "assertNotNull ( servletContextAwareBean . servletContext )  ;", "}", "METHOD_END"], "methodName": ["servletContextAwareBeanProcessed"], "fileName": "org.springframework.test.context.web.BasicAnnotationConfigWacTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Groovy   Foo \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["groovyFooAutowired"], "fileName": "org.springframework.test.context.web.BasicGroovyWacTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" bar \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["fooBarAutowired"], "fileName": "org.springframework.test.context.web.BasicXmlWacTests"}, {"methodBody": ["METHOD_START", "{", "return    \" enigma \"  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.test.context.web.FooConfig"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage ( containsString (  \" does   not   support   annotated   classes \"  )  )  ;", "GenericXmlWebContextLoader   loader    =    new   GenericXmlWebContextLoader (  )  ;", "WebMergedContextConfiguration   mergedConfig    =    new   WebMergedContextConfiguration ( getClass (  )  ,     . EMPTY _ STRING _ ARRAY ,    new   Class <  ?  >  [  ]  {    getClass (  )     }  ,    null ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,     . EMPTY _ STRING _ ARRAY ,     \" resource / path \"  ,    loader ,    null ,    null )  ;", "loader . loadContext ( mergedConfig )  ;", "}", "METHOD_END"], "methodName": ["configMustNotContainAnnotatedClasses"], "fileName": "org.springframework.test.context.web.GenericXmlWebContextLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" ServletContext   should   be   set   in   the   WAC .  \"  ,    wac . getServletContext (  )  )  ;", "assertNotNull (  \" ServletContext   should   have   been   set   via   ServletContextAware .  \"  ,    servletContext )  ;", "assertNotNull (  \" ServletContext   should   have   been   autowired   from   the   WAC .  \"  ,    mockServletContext )  ;", "assertNotNull (  \" MockHttpServletRequest   should   have   been   autowired   from   the   WAC .  \"  ,    request )  ;", "assertNotNull (  \" MockHttpServletResponse   should   have   been   autowired   from   the   WAC .  \"  ,    response )  ;", "assertNotNull (  \" MockHttpSession   should   have   been   autowired   from   the   WAC .  \"  ,    session )  ;", "assertNotNull (  \" ServletWebRequest   should   have   been   autowired   from   the   WAC .  \"  ,    webRequest )  ;", "Object   rootWac    =    mockServletContext . getAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  ;", "assertNotNull (  (  \" Root   WAC   must   be   stored   in   the   ServletContext   as :     \"     +     ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ,    rootWac )  ;", "assertSame (  \" test   WAC   and   Root   WAC   in   ServletContext   must   be   the   same   object .  \"  ,    wac ,    rootWac )  ;", "assertSame (  \" ServletContext   instances   must   be   the   same   object .  \"  ,    mockServletContext ,    wac . getServletContext (  )  )  ;", "assertSame (  \" ServletContext   in   the   WAC   and   in   the   mock   request \"  ,    mockServletContext ,    request . getServletContext (  )  )  ;", "assertEquals (  \" Getting   real   path   for   ServletContext   resource .  \"  ,    new   File (  \" src / main / webapp / index . jsp \"  )  . getCanonicalPath (  )  ,    mockServletContext . getRealPath (  \" index . jsp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["basicWacFeatures"], "fileName": "org.springframework.test.context.web.JUnit4SpringContextWebTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" enigma \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["fooEnigmaAutowired"], "fileName": "org.springframework.test.context.web.JUnit4SpringContextWebTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" ServletContext   should   be   set   in   the   WAC .  \"  ,    wac . getServletContext (  )  )  ;", "assertNotNull (  \" ServletContext   should   have   been   autowired   from   the   WAC .  \"  ,    mockServletContext )  ;", "Object   rootWac    =    mockServletContext . getAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  ;", "assertNotNull (  (  \" Root   WAC   must   be   stored   in   the   ServletContext   as :     \"     +     ( WebApplictext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ,    rootWac )  ;", "assertSame (  \" test   WAC   and   Root   WAC   in   ServletContext   must   be   the   same   object .  \"  ,    wac ,    rootWac )  ;", "assertSame (  \" ServletContext   instances   must   be   the   same   object .  \"  ,    mockServletContext ,    wac . getServletContext (  )  )  ;", "assertEquals (  \" Getting   real   path   for   ServletContext   resource .  \"  ,    new   File (  \" src / main / webapp / index . jsp \"  )  . getCanonicalPath (  )  ,    mockServletContext . getRealPath (  \" index . jsp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["basicWacFeatures"], "fileName": "org.springframework.test.context.web.MetaAnnotationConfigWacTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" enigma \"  ,    foo )  ;", "}", "METHOD_END"], "methodName": ["fooEnigmaAutowired"], "fileName": "org.springframework.test.context.web.MetaAnnotationConfigWacTests"}, {"methodBody": ["METHOD_START", "{", "final   String   beanName    =     \" requestScopedTestBean \"  ;", "final   String   Path    =     \"  / path \"  ;", "assertNull ( request . getAttribute ( beanName )  )  ;", "request . setContextPath ( Path )  ;", "TestBean   testBean    =    wac . getBean ( beanName ,    TestBean . class )  ;", "assertEquals ( Path ,    testBean . getName (  )  )  ;", "assertSame ( testBean ,    request . getAttribute ( beanName )  )  ;", "assertSame ( testBean ,    wac . getBean ( beanName ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["requestScope"], "fileName": "org.springframework.test.context.web.RequestAndSessionScopedBeansWacTests"}, {"methodBody": ["METHOD_START", "{", "final   String   beanName    =     \" sessionScopedTestBean \"  ;", "assertNull ( session . getAttribute ( beanName )  )  ;", "TestBean   testBean    =    wac . getBean ( beanName ,    TestBean . class )  ;", "assertSame ( testBean ,    session . getAttribute ( beanName )  )  ;", "assertSame ( testBean ,    wac . getBean ( beanName ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["sessionScope"], "fileName": "org.springframework.test.context.web.RequestAndSessionScopedBeansWacTests"}, {"methodBody": ["METHOD_START", "{", "JUnitTestingUtils . runTestsAndAssertCounters ( BasicAnnotationConfigWacTests . class ,     3  ,     0  ,     3  ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["ensureServletContextAwareBeanIsProcessedProperlyWhenExecutingJUnitManually"], "fileName": "org.springframework.test.context.web.ServletContextAwareBeanWacTests"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . TRUE . equals ( testContext . getAttribute ( ServletTestExecutionListener . POPULATED _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  )  ;", "}", "METHOD_END"], "methodName": ["alreadyPopulatedRequestContextHolder"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "return    ( Boolean . TRUE . equals ( testContext . getAttribute ( ServletTestExecutionListener . ACTIVATE _ LISTENER )  )  )     |  |     ( AnnotatedElementUtils . hasAnnotation ( testContext . getTestClass (  )  ,    WebAppConfiguration . class )  )  ;", "}", "METHOD_END"], "methodName": ["isActivated"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( isActivated ( testContext )  )  )     |  |     ( alreadyPopulatedRequestContextHolder ( testContext )  )  )     {", "return ;", "}", "ApplicationContext   context    =    testContext . getApplicationContext (  )  ;", "if    ( context   instanceof   WebApplicationContext )     {", "WebApplicationContext   wac    =     (  ( WebApplicationContext )     ( context )  )  ;", "ServletContext   servletContext    =    wac . getServletContext (  )  ;", "Assert . state (  ( servletContext   instanceof   MockServletContext )  ,     (  )     -  >    String . format (  \" The   WebApplicationContext   for   test   context    % s   must   be   configured   with   a   MockServletContext .  \"  ,    testContext )  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Setting   up   MockHttpServletRequest ,    MockHttpServletResponse ,    ServletWebRequest ,    and   RequestContextHolder   for   test   context    % s .  \"  ,    testContext )  )  ;", "}", "MockServletContext   mockServletContext    =     (  ( MockServletContext )     ( servletContext )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( mockServletContext )  ;", "request . setAttribute (  . CREATED _ BY _ THE _ TESTCONTEXT _ FRAMEWORK ,    Boolean . TRUE )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "ServletWebRequest   servletWebRequest    =    new   ServletWebRequest ( request ,    response )  ;", "RequestContextHolder . setRequestAttributes ( servletWebRequest )  ;", "testContext . setAttribute (  . POPULATED _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "testContext . setAttribute (  . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "if    ( wac   instanceof   ConfigurableApplicationContext )     {", "@ SuppressWarnings (  \" resource \"  )", "ConfigurableApplicationContext   configurableApplicationContext    =     (  ( ConfigurableApplicationContext )     ( wac )  )  ;", "ConfigurableListableBeanFactory   bf    =    configurableApplicationContext . getBeanFactory (  )  ;", "bf . registerResolvableDependency ( MockHttpServletResponse . class ,    response )  ;", "bf . registerResolvableDependency ( ServletWebRequest . class ,    servletWebRequest )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setUpRequestContextIfNecessary"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListener"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Injected   ServletRequest   must   be   stored   in   the   RequestContextHolder \"  ,    servletRequest ,     (  ( ServletRequestAttributes )     ( RequestContextHolder . getRequestAttributes (  )  )  )  . getRequest (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertInjectedServletRequestEqualsRequestInRequestContextHolder"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerJUnitIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertInjectedServletRequestEqualsRequestInRequestContextHolder (  )  ;", "}", "METHOD_END"], "methodName": ["ensureMocksAreReinjectedBetweenTests_1"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerJUnitIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertInjectedServletRequestEqualsRequestInRequestContextHolder (  )  ;", "}", "METHOD_END"], "methodName": ["ensureMocksAreReinjectedBetweenTests_2"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerJUnitIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( ServletTestExecutionListenerTests . NoAtWebAppConfigWebTestCase . class )  ;", "given ( testContext . getAttribute ( ServletTestExecutionListener . ACTIVATE _ LISTENER )  )  . willReturn ( true )  ;", "RequestContextHolder . resetRequestAttributes (  )  ;", "listener . beforeTestClass ( testContext )  ;", "assertRequestAttributesDoNotExist (  )  ;", "assertWebAppConfigTestCase (  )  ;", "}", "METHOD_END"], "methodName": ["activateListenerWithoutExistingRequestAttributes"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "assertNull (  \" request   attributes   should   not   exist \"  ,    RequestContextHolder . getRequestAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertRequestAttributesDoNotExist"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   requestAttributes    =    RequestContextHolder . getRequestAttributes (  )  ;", "assertNotNull (  \" request   attributes   should   exist \"  ,    requestAttributes )  ;", "return   requestAttributes ;", "}", "METHOD_END"], "methodName": ["assertRequestAttributesExist"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   requestAttributes    =    assertRequestAttributesExist (  )  ;", "Object   setUpOutsideOfStel    =    requestAttributes . getAttribute (  . SET _ UP _ OUTSIDE _ OF _ STEL ,    SCOPE _ REQUEST )  ;", "assertNull (  (  (  . SET _ UP _ OUTSIDE _ OF _ STEL )     +     \"    should   NOT   exist   as   a   request   attribute \"  )  ,    setUpOutsideOfStel )  ;", "}", "METHOD_END"], "methodName": ["assertSetUpOutsideOfStelAttributeDoesNotExist"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   requestAttributes    =    assertRequestAttributesExist (  )  ;", "Object   setUpOutsideOfStel    =    requestAttributes . getAttribute (  . SET _ UP _ OUTSIDE _ OF _ STEL ,    SCOPE _ REQUEST )  ;", "assertNotNull (  (  (  . SET _ UP _ OUTSIDE _ OF _ STEL )     +     \"    should   exist   as   a   request   attribute \"  )  ,    setUpOutsideOfStel )  ;", "}", "METHOD_END"], "methodName": ["assertSetUpOutsideOfStelAttributeExists"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "listener . prepareTestInstance ( testContext )  ;", "assertRequestAttributesExist (  )  ;", "assertSetUpOutsideOfStelAttributeDoesNotExist (  )  ;", "verify ( testContext ,    times (  1  )  )  . setAttribute (  . POPULATED _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "verify ( testContext ,    times (  1  )  )  . setAttribute (  . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "given ( testContext . getAttribute (  . POPULATED _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  )  . willReturn ( Boolean . TRUE )  ;", "given ( testContext . getAttribute (  . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  )  . willReturn ( Boolean . TRUE )  ;", "listener . beforeTestMethod ( testContext )  ;", "assertRequestAttributesExist (  )  ;", "assertSetUpOutsideOfStelAttributeDoesNotExist (  )  ;", "verify ( testContext ,    times (  1  )  )  . setAttribute (  . POPULATED _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "verify ( testContext ,    times (  1  )  )  . setAttribute (  . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "listener . afterTestMethod ( testContext )  ;", "verify ( testContext )  . removeAttribute (  . POPULATED _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  ;", "verify ( testContext )  . removeAttribute (  . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  ;", "assertRequestAttributesDoNotExist (  )  ;", "}", "METHOD_END"], "methodName": ["assertWebAppConfigTestCase"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( ServletTestExecutionListenerTests . AtWebAppConfigWebTestCase . class )  ;", "listener . beforeTestClass ( testContext )  ;", "assertRequestAttributesExist (  )  ;", "assertWebAppConfigTestCase (  )  ;", "}", "METHOD_END"], "methodName": ["atWebAppConfigTestCaseWithPresetRequestAttributes"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( ServletTestExecutionListenerTests . AtWebAppConfigWebTestCase . class )  ;", "RequestContextHolder . resetRequestAttributes (  )  ;", "listener . beforeTestClass ( testContext )  ;", "assertRequestAttributesDoNotExist (  )  ;", "assertWebAppConfigTestCase (  )  ;", "}", "METHOD_END"], "methodName": ["atWebAppConfigTestCaseWithoutExistingRequestAttributes"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( ServletTestExecutionListenerTests . LegacyWebTestCase . class )  ;", "listener . beforeTestClass ( testContext )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "listener . prepareTestInstance ( testContext )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "verify ( testContext ,    times (  0  )  )  . setAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "given ( testContext . getAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  )  . willReturn ( null )  ;", "listener . beforeTestMethod ( testContext )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "verify ( testContext ,    times (  0  )  )  . setAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "given ( testContext . getAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  )  . willReturn ( null )  ;", "listener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . removeAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "}", "METHOD_END"], "methodName": ["legacyWebTestCaseWithPresetRequestAttributes"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( ServletTestExecutionListenerTests . LegacyWebTestCase . class )  ;", "RequestContextHolder . resetRequestAttributes (  )  ;", "assertRequestAttributesDoNotExist (  )  ;", "listener . beforeTestClass ( testContext )  ;", "listener . prepareTestInstance ( testContext )  ;", "assertRequestAttributesDoNotExist (  )  ;", "verify ( testContext ,    times (  0  )  )  . setAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "given ( testContext . getAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  )  . willReturn ( null )  ;", "listener . beforeTestMethod ( testContext )  ;", "assertRequestAttributesDoNotExist (  )  ;", "verify ( testContext ,    times (  0  )  )  . setAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE ,    Boolean . TRUE )  ;", "listener . afterTestMethod ( testContext )  ;", "verify ( testContext ,    times (  1  )  )  . removeAttribute ( ServletTestExecutionListener . RESET _ REQUEST _ CONTEXT _ HOLDER _ ATTRIBUTE )  ;", "assertRequestAttributesDoNotExist (  )  ;", "}", "METHOD_END"], "methodName": ["legacyWebTestCaseWithoutExistingRequestAttributes"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "given ( wac . getServletContext (  )  )  . willReturn ( mockServletContext )  ;", "given ( testContext . getApplicationContext (  )  )  . willReturn ( wac )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( mockServletContext )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "ServletWebRequest   servletWebRequest    =    new   ServletWebRequest ( request ,    response )  ;", "request . setAttribute (  . SET _ UP _ OUTSIDE _ OF _ STEL ,     \" true \"  )  ;", "RequestContextHolder . setRequestAttributes ( servletWebRequest )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "BDDMockito .  < Class <  ?  >  > given ( testContext . getTestClass (  )  )  . willReturn ( getClass (  )  )  ;", "given ( testContext . getApplicationContext (  )  )  . willReturn ( mock ( ApplicationContext . class )  )  ;", "listener . beforeTestClass ( testContext )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "listener . prepareTestInstance ( testContext )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "listener . beforeTestMethod ( testContext )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "listener . afterTestMethod ( testContext )  ;", "assertSetUpOutsideOfStelAttributeExists (  )  ;", "}", "METHOD_END"], "methodName": ["standardApplicationContext"], "fileName": "org.springframework.test.context.web.ServletTestExecutionListenerTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    wac . getResource (  \"  / resources / Spring . js \"  )  ;", "Assert . assertNotNull ( resource )  ;", "Assert . assertTrue ( resource . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["webApplicationContextIsLoaded"], "fileName": "org.springframework.test.context.web.WebAppConfigurationBootstrapWithTests"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceBasePath ;", "}", "METHOD_END"], "methodName": ["getResourceBasePath"], "fileName": "org.springframework.test.context.web.WebMergedContextConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    ( AnnotatedElementUtils . findMergedAnnotationAttributes ( testClass ,    MockServerContainerContextCustomizerFactory . WEB _ APP _ CONFIGURATION _ ANNOTATION _ CLASS _ NAME ,    false ,    false )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isAnnotatedWithWebAppConfiguration"], "fileName": "org.springframework.test.context.web.socket.MockServerContainerContextCustomizerFactory"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  4  2  ,    serverContainer . getDefaultMaxTextMessageBufferSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["servletServerContainerFactoryBeanSupport"], "fileName": "org.springframework.test.context.web.socket.WebSocketServletServerContainerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Integer   result    =    jdbcTemplate . queryForObject (  (  \" SELECT   COUNT (  0  )    FROM    \"     +    tableName )  ,    Integer . class )  ;", "return   result    !  =    null    ?    result    :     0  ;", "}", "METHOD_END"], "methodName": ["countRowsInTable"], "fileName": "org.springframework.test.jdbc.JdbcTestUtils"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   COUNT (  0  )    FROM    \"     +    tableName ;", "if    ( String . hasText ( whereClause )  )     {", "sql    +  =     \"    WHERE    \"     +    whereClause ;", "}", "Integer   result    =    jdbcTemplate . queryForObject ( sql ,    Integer . class )  ;", "return   result    !  =    null    ?    result    :     0  ;", "}", "METHOD_END"], "methodName": ["countRowsInTableWhere"], "fileName": "org.springframework.test.jdbc.JdbcTestUtils"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" DELETE   FROM    \"     +    tableName ;", "if    ( StringUtils . hasText ( whereClause )  )     {", "sql    +  =     \"    WHERE    \"     +    whereClause ;", "}", "int   rowCount    =     (  ( args . length )     >     0  )     ?    jdbcTemplate . update ( sql ,    args )     :    jdbcTemplate . update ( sql )  ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  (  (  \" Deleted    \"     +    rowCount )     +     \"    rows   from   table    \"  )     +    tableName )  )  ;", "}", "return   rowCount ;", "}", "METHOD_END"], "methodName": ["deleteFromTableWhere"], "fileName": "org.springframework.test.jdbc.JdbcTestUtils"}, {"methodBody": ["METHOD_START", "{", "int   totalRowCount    =     0  ;", "for    ( String   tableName    :    tableNames )     {", "int   rowCount    =    jdbcTemplate . update (  (  \" DELETE   FROM    \"     +    tableName )  )  ;", "totalRowCount    +  =    rowCount ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  (  (  \" Deleted    \"     +    rowCount )     +     \"    rows   from   table    \"  )     +    tableName )  )  ;", "}", "}", "return   totalRowCount ;", "}", "METHOD_END"], "methodName": ["deleteFromTables"], "fileName": "org.springframework.test.jdbc.JdbcTestUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( String   tableName    :    tableNames )     {", "jdbcTemplate . execute (  (  \" DROP   TABLE    \"     +    tableName )  )  ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  \" Dropped   table    \"     +    tableName )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["dropTables"], "fileName": "org.springframework.test.jdbc.JdbcTestUtils"}, {"methodBody": ["METHOD_START", "{", "given ( jdbcTemplate . update (  \" DELETE   FROM   person   WHERE   name    =     ' Bob '    and   age    >     2  5  \"  )  )  . willReturn (  1  0  )  ;", "int   deleted    =     . deleteFromTableWhere ( jdbcTemplate ,     \" person \"  ,     \" name    =     ' Bob '    and   age    >     2  5  \"  )  ;", "assertThat ( deleted ,    equalTo (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteWithWhereClause"], "fileName": "org.springframework.test.jdbc.JdbcTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "given ( jdbcTemplate . update (  \" DELETE   FROM   person   WHERE   name    =     ?    and   age    >     ?  \"  ,     \" Bob \"  ,     2  5  )  )  . willReturn (  1  0  )  ;", "int   deleted    =     . deleteFromTableWhere ( jdbcTemplate ,     \" person \"  ,     \" name    =     ?    and   age    >     ?  \"  ,     \" Bob \"  ,     2  5  )  ;", "assertThat ( deleted ,    equalTo (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteWithWhereClauseAndArguments"], "fileName": "org.springframework.test.jdbc.JdbcTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "given ( jdbcTemplate . update (  \" DELETE   FROM   person \"  )  )  . willReturn (  1  0  )  ;", "int   deleted    =     . deleteFromTableWhere ( jdbcTemplate ,     \" person \"  ,    null )  ;", "assertThat ( deleted ,    equalTo (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteWithoutWhereClause"], "fileName": "org.springframework.test.jdbc.JdbcTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ! condition )     {", ". fail ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["assertCondition"], "fileName": "org.springframework.test.transaction.TransactionTestUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( transactionExpected )     {", ". assertCondition (  . inTransaction (  )  ,     \" The   current   thread   should   be   associated   with   a   transaction .  \"  )  ;", "} else    {", ". assertCondition (  (  !  (  . inTransaction (  )  )  )  ,     \" The   current   thread   should   not   be   associated   with   a   transaction \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertInTransaction"], "fileName": "org.springframework.test.transaction.TransactionTestUtils"}, {"methodBody": ["METHOD_START", "{", "throw   new   AssertionError ( message )  ;", "}", "METHOD_END"], "methodName": ["fail"], "fileName": "org.springframework.test.transaction.TransactionTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   TransactionSynchronizationManager . isActualTransactionActive (  )  ;", "}", "METHOD_END"], "methodName": ["inTransaction"], "fileName": "org.springframework.test.transaction.TransactionTestUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( candidate ,     \" Candidate   must   not   be   null \"  )  ;", "try    {", "if    (  ( Aop . isAopProxy ( candidate )  )     &  &     ( candidate   instanceof   Advised )  )     {", "Object   target    =     (  ( Advised )     ( candidate )  )  . getTargetSource (  )  . getTarget (  )  ;", "if    ( target    !  =    null )     {", "return    (  ( T )     ( target )  )  ;", "}", "}", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   unwrap   proxied   object \"  ,    ex )  ;", "}", "return    (  ( T )     ( candidate )  )  ;", "}", "METHOD_END"], "methodName": ["getTargetObject"], "fileName": "org.springframework.test.util.AopTestUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( candidate ,     \" Candidate   must   not   be   null \"  )  ;", "try    {", "if    (  ( AopUtils . isAopProxy ( candidate )  )     &  &     ( candidate   instanceof   Advised )  )     {", "Object   target    =     (  ( Advised )     ( candidate )  )  . getTargetSource (  )  . getTarget (  )  ;", "if    ( target    !  =    null )     {", "return    (  ( T )     (  . getUltimateTargetObject ( target )  )  )  ;", "}", "}", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   unwrap   proxied   object \"  ,    ex )  ;", "}", "return    (  ( T )     ( candidate )  )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObject"], "fileName": "org.springframework.test.util.AopTestUtils"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTarget ( foo )  ;", "pf . setProxyTargetClass ( true )  ;", ". Foo   proxy    =     (  (  . Foo )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  \" Proxy   is   a   CGLIB   proxy \"  ,    AopUtils . isCglibProxy ( proxy )  )  ;", "assertThat ( proxy ,    instanceOf (  . FooImpl . class )  )  ;", "return   proxy ;", "}", "METHOD_END"], "methodName": ["cglibProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getTargetObject ( foo )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getTargetObjectForNonProxiedObject"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtils . getTargetObject ( null )  ;", "}", "METHOD_END"], "methodName": ["getTargetObjectForNull"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getTargetObject ( cglibProxy ( cglibProxy ( foo )  )  )  ;", "assertNotSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getTargetObjectWrappedInDoubleCglibProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getTargetObject ( jdkProxy ( jdkProxy ( foo )  )  )  ;", "assertNotSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getTargetObjectWrappedInDoubleJdkDynamicProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getTargetObject ( cglibProxy ( foo )  )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getTargetObjectWrappedInSingleCglibProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getTargetObject ( jdkProxy ( foo )  )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getTargetObjectWrappedInSingleJdkDynamicProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getUltimateTargetObject ( foo )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObjectForNonProxiedObject"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtils . getUltimateTargetObject ( null )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObjectForNull"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getUltimateTargetObject ( jdkProxy ( jdkProxy ( cglibProxy ( foo )  )  )  )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObjectWrappedInCglibProxyWrappedInDoubleJdkDynamicProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getUltimateTargetObject ( jdkProxy ( cglibProxy ( foo )  )  )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObjectWrappedInCglibProxyWrappedInJdkDynamicProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getUltimateTargetObject ( cglibProxy ( cglibProxy ( foo )  )  )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObjectWrappedInDoubleCglibProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getUltimateTargetObject ( jdkProxy ( jdkProxy ( foo )  )  )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObjectWrappedInDoubleJdkDynamicProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getUltimateTargetObject ( cglibProxy ( foo )  )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObjectWrappedInSingleCglibProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AopTestUtilsTests . Foo   target    =    AopTestUtils . getUltimateTargetObject ( jdkProxy ( foo )  )  ;", "assertSame ( foo ,    target )  ;", "}", "METHOD_END"], "methodName": ["getUltimateTargetObjectWrappedInSingleJdkDynamicProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTarget ( foo )  ;", "pf . addInterface (  . Foo . class )  ;", ". Foo   proxy    =     (  (  . Foo )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  \" Proxy   is   a   JDK   dynamic   proxy \"  ,    AopUtils . isJdkDynamicProxy ( proxy )  )  ;", "assertThat ( proxy ,    instanceOf (  . Foo . class )  )  ;", "return   proxy ;", "}", "METHOD_END"], "methodName": ["jdkProxy"], "fileName": "org.springframework.test.util.AopTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . nullSafeEquals ( expected ,    actual )  )  )     {", ". fail ( message ,    ObjectUtils . nullSafeToString ( expected )  ,    ObjectUtils . nullSafeToString ( actual )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertEquals"], "fileName": "org.springframework.test.util.AssertionErrors"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . nullSafeEquals ( expected ,    actual )  )     {", "throw   new    (  (  (  (  ( message    +     \"    was   not   expected   to   be :  \"  )     +     \"  <  \"  )     +     ( ObjectUtils . nullSafeToString ( actual )  )  )     +     \"  >  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertNotEquals"], "fileName": "org.springframework.test.util.AssertionErrors"}, {"methodBody": ["METHOD_START", "{", "if    (  ! condition )     {", ". fail ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["assertTrue"], "fileName": "org.springframework.test.util.AssertionErrors"}, {"methodBody": ["METHOD_START", "{", "throw   new   AssertionError ( message )  ;", "}", "METHOD_END"], "methodName": ["fail"], "fileName": "org.springframework.test.util.AssertionErrors"}, {"methodBody": ["METHOD_START", "{", "throw   new   AssertionError (  (  (  (  (  ( message    +     \"    expected :  <  \"  )     +    expected )     +     \"  >    but   was :  <  \"  )     +    actual )     +     \"  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["fail"], "fileName": "org.springframework.test.util.AssertionErrors"}, {"methodBody": ["METHOD_START", "{", "assertJsonEqual ( expected ,    actual ,    false )  ;", "}", "METHOD_END"], "methodName": ["assertJsonEqual"], "fileName": "org.springframework.test.util.JsonExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "JSONAssert . assertEquals ( expected ,    actual ,    strict )  ;", "}", "METHOD_END"], "methodName": ["assertJsonEqual"], "fileName": "org.springframework.test.util.JsonExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "assertJsonNotEqual ( expected ,    actual ,    false )  ;", "}", "METHOD_END"], "methodName": ["assertJsonNotEqual"], "fileName": "org.springframework.test.util.JsonExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "JSONAssert . assertNotEquals ( expected ,    actual ,    strict )  ;", "}", "METHOD_END"], "methodName": ["assertJsonNotEqual"], "fileName": "org.springframework.test.util.JsonExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    evaluateJsonPath ( content )  ;", "String   reason    =     (  \" No   value   at   JSON   path    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  ;", "AssertionErrors . assertTrue ( reason ,     ( value    !  =    null )  )  ;", "if    (  ( pathIsIndefinite (  )  )     &  &     ( value   instanceof   List )  )     {", "AssertionErrors . assertTrue ( reason ,     (  !  (  (  ( List <  ?  >  )     ( value )  )  . isEmpty (  )  )  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["assertExistsAndReturn"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   actualValue    =    evaluateJsonPath ( content )  ;", "if    (  ( actualValue   instanceof   List )     &  &     (  !  ( expectedValue   instanceof   List )  )  )     {", "@ SuppressWarnings (  \" rawtypes \"  )", "List   actualValueList    =     (  ( List )     ( actualValue )  )  ;", "if    ( actualValueList . isEmpty (  )  )     {", "AssertionErrors . fail (  (  (  \" No   matching   value   at   JSON   path    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  )  )  ;", "}", "if    (  ( actualValueList . size (  )  )     !  =     1  )     {", "AssertionErrors . fail (  (  (  (  \" Got   a   list   of   values    \"     +    actualValue )     +     \"    instead   of   the   expected   single   value    \"  )     +    expectedValue )  )  ;", "}", "actualValue    =    actualValueList . get (  0  )  ;", "} else", "if    (  ( actualValue    !  =    null )     &  &     ( expectedValue    !  =    null )  )     {", "if    (  !  ( actualValue . getClass (  )  . equals ( expectedValue . getClass (  )  )  )  )     {", "actualValue    =    evaluateJsonPath ( content ,    expectedValue . getClass (  )  )  ;", "}", "}", "AssertionErrors . assertEquals (  (  (  \" JSON   path    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  )  ,    expectedValue ,    actualValue )  ;", "}", "METHOD_END"], "methodName": ["assertValue"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "T   value    =     (  ( T )     ( evaluateJsonPath ( content )  )  )  ;", "assertThat (  (  (  \" JSON   path    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  )  ,    value ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertValue"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "T   value    =     (  ( T )     ( evaluateJsonPath ( content ,    targetType )  )  )  ;", "assertThat (  (  (  \" JSON   path    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  )  ,    value ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertValue"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    assertExistsAndReturn ( content )  ;", "assertThat ( failureReason (  \" an   array \"  ,    value )  ,    value ,    instanceOf ( List . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    assertExistsAndReturn ( content )  ;", "assertThat ( failureReason (  \" a   boolean \"  ,    value )  ,    value ,    instanceOf ( Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsBoolean"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    evaluateJsonPath ( content )  ;", "AssertionErrors . assertTrue ( failureReason (  \" an   empty   value \"  ,    value )  ,    ObjectUtils . isEmpty ( value )  )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsEmpty"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    assertExistsAndReturn ( content )  ;", "assertThat ( failureReason (  \" a   map \"  ,    value )  ,    value ,    instanceOf ( Map . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    evaluateJsonPath ( content )  ;", "AssertionErrors . assertTrue ( failureReason (  \" a   non - empty   value \"  ,    value )  ,     (  !  ( ObjectUtils . isEmpty ( value )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmpty"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    assertExistsAndReturn ( content )  ;", "assertThat ( failureReason (  \" a   number \"  ,    value )  ,    value ,    instanceOf ( Number . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNumber"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    assertExistsAndReturn ( content )  ;", "assertThat ( failureReason (  \" a   st \"  ,    value )  ,    value ,    instanceOf ( St . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsString"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value ;", "try    {", "value    =    evaluate ( content )  ;", "}    catch    ( AssertionError   ex )     {", "return ;", "}", "String   reason    =    failureReason (  \" no   value \"  ,    value )  ;", "if    (  ( pathIsIndefinite (  )  )     &  &     ( value   instanceof   List )  )     {", "AssertionErrors . assertTrue ( reason ,     (  ( List <  ?  >  )     ( value )  )  . isEmpty (  )  )  ;", "} else    {", "AssertionErrors . assertTrue ( reason ,     ( value    =  =    null )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value ;", "try    {", "value    =    evaluate ( content )  ;", "}    catch    ( AssertionError   ex )     {", "return ;", "}", "if    (  ( pathIsIndefinite (  )  )     &  &     ( value   instanceof   List )  )     {", "AssertionErrors . assertTrue ( failureReason (  \" no   values \"  ,    value )  ,     (  ( List <  ?  >  )     ( value )  )  . isEmpty (  )  )  ;", "} else    {", "AssertionErrors . fail ( failureReason (  \" no   value \"  ,    value )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotHaveJsonPath"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   this . j . read ( content )  ;", "}    catch    ( Throwable   ex )     {", "String   message    =     (  \" No   value   at   JSON   path    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  ;", "throw   new   AssertionError ( message ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluateJsonPath"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . parse ( content )  . read ( this . expression ,    targetType )  ;", "}    catch    ( Throwable   ex )     {", "String   message    =     (  \" No   value   at   JSON   path    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  ;", "throw   new   AssertionError ( message ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluateJsonPath"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "assertExistsAndReturn ( content )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" Expected    % s   at   JSON   path    \\  \"  % s \\  \"    but   found :     % s \"  ,    expectedDescription ,    this . expression ,    ObjectUtils . nullSafeToString ( StringUtils . quoteIfString ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["failureReason"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    evaluateJsonPath ( content )  ;", "if    (  ( pathIsIndefinite (  )  )     &  &     ( value   instanceof   List )  )     {", "AssertionErrors . assertTrue (  (  (  \" No   values   for   JSON   path    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  )  ,     (  !  (  (  ( List <  ?  >  )     ( value )  )  . isEmpty (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["hasJsonPath"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . jsonPath . isDefinite (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathIsIndefinite"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . num \"  )  . assertValue ( JsonPathExpectationsHelperTests . CONTENT ,     5  )  ;", "}", "METHOD_END"], "methodName": ["assertValue"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . arr \"  )  . assertValueIsArray ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . emptyArray \"  )  . assertValueIsArray ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsArrayForAnEmptyArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . str \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   an   array   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     \\  ' foo \\  '  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsArray (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsArrayForNonArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . bool \"  )  . assertValueIsBoolean ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsBoolean"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . num \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   a   boolean   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     5  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsBoolean (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsBooleanForNonBoolean"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . emptyArray \"  )  . assertValueIsEmpty ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsEmptyForAnEmptyArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . emptyMap \"  )  . assertValueIsEmpty ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsEmptyForAnEmptyMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . emptyString \"  )  . assertValueIsEmpty ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsEmptyForAnEmptyString"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Dilbert '  )  ]  \"  )  . assertValueIsEmpty ( JsonPathExpectationsHelperTests . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsEmptyForIndefinatePathWithEmptyResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Bart '  )  ]  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   an   empty   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     [  {  \\  \" name \\  \"  :  \\  \" Bart \\  \"  }  ]  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsEmpty (  . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsEmptyForIndefinatePathWithResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . whitespace \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   an   empty   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     \\  '              \\  '  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsEmpty (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsEmptyForWhitespace"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . colorMap \"  )  . assertValueIsMap ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . emptyMap \"  )  . assertValueIsMap ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsMapForAnEmptyMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . str \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   a   map   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     \\  ' foo \\  '  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsMap (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsMapForNonMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . emptyArray \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   a   non - empty   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     [  ]  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsNotEmpty (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForAnEmptyArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . emptyMap \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   a   non - empty   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     {  }  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsNotEmpty (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForAnEmptyMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . emptyString \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   a   non - empty   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     \\  '  \\  '  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsNotEmpty (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForAnEmptyString"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . arr \"  )  . assertValueIsNotEmpty ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . bool \"  )  . assertValueIsNotEmpty ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForBoolean"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Dilbert '  )  ]  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   a   non - empty   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     [  ]  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsNotEmpty (  . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForIndefinatePathWithEmptyResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Bart '  )  ]  \"  )  . assertValueIsNotEmpty ( JsonPathExpectationsHelperTests . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForIndefinatePathWithResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . colorMap \"  )  . assertValueIsNotEmpty ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . num \"  )  . assertValueIsNotEmpty ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForNumber"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . str \"  )  . assertValueIsNotEmpty ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNotEmptyForString"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . num \"  )  . assertValueIsNumber ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNumber"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . bool \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   a   number   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :    true \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsNumber (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsNumberForNonNumber"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . str \"  )  . assertValueIsString ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsString"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . emptyString \"  )  . assertValueIsString ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsStringForAnEmptyString"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . bool \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   a   string   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :    true \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . assertValueIsString (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["assertValueIsStringForNonString"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . num \"  )  . assertValue ( JsonPathExpectationsHelperTests . CONTENT ,     5  .  0  )  ;", "}", "METHOD_END"], "methodName": ["assertValueWithNumberConversion"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . num \"  )  . assertValue ( JsonPathExpectationsHelperTests . CONTENT ,    Is . is (  5  .  0  )  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["assertValueWithNumberConversionAndMatcher"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . bogus \"  )  . doesNotExist ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . emptyArray \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   no   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     [  ]  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . doesNotExist (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistForAnEmptyArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . emptyMap \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   no   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     {  }  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . doesNotExist (  . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistForAnEmptyMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Dilbert '  )  ]  \"  )  . doesNotExist ( JsonPathExpectationsHelperTests . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistForIndefinatePathWithEmptyResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Bart '  )  ]  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" Expected   no   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"    but   found :     [  {  \\  \" name \\  \"  :  \\  \" Bart \\  \"  }  ]  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . doesNotExist (  . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistForIndefinatePathWithResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Bart '  )  ]  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  (  \" Expected   no   values   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"     \"  )     +     \" but   found :     [  {  \\  \" name \\  \"  :  \\  \" Bart \\  \"  }  ]  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . doesNotHaveJsonPath (  . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["doesNotHaveEmptyPathForIndefinatePathWithResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . abc \"  )  . doesNotHaveJsonPath (  \"  {  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotHaveJsonPath"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Dilbert '  )  ]  \"  )  . doesNotHaveJsonPath ( JsonPathExpectationsHelperTests . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["doesNotHaveJsonPathForIndefinatePathWithEmptyResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( AssertionError . class )  ;", "new    (  \"  $  . abc \"  )  . doesNotHaveJsonPath (  \"  {  \\  \" abc \\  \"  :    null }  \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotHaveJsonPathWithNull"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . str \"  )  . exists ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . emptyArray \"  )  . exists ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["existsForAnEmptyArray"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . emptyMap \"  )  . exists ( JsonPathExpectationsHelperTests . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["existsForAnEmptyMap"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Dilbert '  )  ]  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" No   value   at   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . exists (  . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["existsForIndefinatePathWithEmptyResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Bart '  )  ]  \"  )  . exists ( JsonPathExpectationsHelperTests . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["existsForIndefinatePathWithResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . abc \"  )  . hasJsonPath (  \"  {  \\  \" abc \\  \"  :     \\  \"  1  2  3  \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["hasJsonPath"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Dilbert '  )  ]  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  (  (  \" No   values   for   JSON   path    \\  \"  \"     +    expression )     +     \"  \\  \"  \"  )  )  ;", "new   JsonPathExpectationsHelper ( expression )  . hasJsonPath (  . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["hasJsonPathForIndefinatePathWithEmptyResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . familyMembers [  ?  (  @  . name    =  =     ' Bart '  )  ]  \"  )  . hasJsonPath ( JsonPathExpectationsHelperTests . SIMPSONS )  ;", "}", "METHOD_END"], "methodName": ["hasJsonPathForIndefinatePathWithResults"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathExpectationsHelper (  \"  $  . abc \"  )  . hasJsonPath (  \"  {  \\  \" abc \\  \"  :    null }  \"  )  ;", "}", "METHOD_END"], "methodName": ["hasJsonPathWithNull"], "fileName": "org.springframework.test.util.JsonPathExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( annotationTypes )  )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "for    ( Class <  ?  >    clazz    :    annotationTypes )     {", "if    (  !  (  . class . isAssignableFrom ( clazz )  )  )     {", "throw   new   IllegalArgumentException (  \" Array   elements   must   be   of   type    \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertNonEmptyAnnotationTypeArray"], "fileName": "org.springframework.test.util.MetaAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   MetaAnnotationUtils . findAnnotationDescriptor ( clazz ,    new   HashSet <  >  (  )  ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptor"], "fileName": "org.springframework.test.util.MetaAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( annotationType ,     \" Annotation   type   must   not   be   null \"  )  ;", "if    (  ( clazz    =  =    null )     |  |     (  ( Object . class )     =  =    clazz )  )     {", "return   null ;", "}", "if    ( AnnotationUtils . isAnnotationDeclaredLocally ( annotationType ,    clazz )  )     {", "return   new    . AnnotationDescriptor <  >  ( clazz ,    clazz . getAnnotation ( annotationType )  )  ;", "}", "for    ( Annotation   composedAnn    :    clazz . getDeclaredAnnotations (  )  )     {", "Class <  ?    extends   Annotation >    composedType    =    composedAnn . annotationType (  )  ;", "if    (  (  !  ( AnnotationUtils . isInJavaLangAnnotationPackage ( composedType . getName (  )  )  )  )     &  &     ( visited . add ( composedAnn )  )  )     {", ". AnnotationDescriptor < T >    descriptor    =     . findAnnotationDescriptor ( composedType ,    visited ,    annotationType )  ;", "if    ( descriptor    !  =    null )     {", "return   new    . AnnotationDescriptor <  >  ( clazz ,    descriptor . getDeclaringClass (  )  ,    composedAnn ,    descriptor . getAnnotation (  )  )  ;", "}", "}", "}", "for    ( Class <  ?  >    ifc    :    clazz . getInterfaces (  )  )     {", ". AnnotationDescriptor < T >    descriptor    =     . findAnnotationDescriptor ( ifc ,    visited ,    annotationType )  ;", "if    ( descriptor    !  =    null )     {", "return   new    . AnnotationDescriptor <  >  ( clazz ,    descriptor . getDeclaringClass (  )  ,    descriptor . getComposedAnnotation (  )  ,    descriptor . getAnnotation (  )  )  ;", "}", "}", "return    . findAnnotationDescriptor ( clazz . getSuperclass (  )  ,    visited ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptor"], "fileName": "org.springframework.test.util.MetaAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   MetaAnnotationUtils . findAnnotationDescriptorForTypes ( clazz ,    new   HashSet <  >  (  )  ,    annotationTypes )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypes"], "fileName": "org.springframework.test.util.MetaAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "MetaAnnotationUtils . assertNonEmptyAnnotationTypeArray ( annotationTypes ,     \" The   list   of   annotation   types   must   not   be   empty \"  )  ;", "if    (  ( clazz    =  =    null )     |  |     (  ( Object . class )     =  =    clazz )  )     {", "return   null ;", "}", "for    ( Class <  ?    extends   Annotation >    annotationType    :    annotationTypes )     {", "if    ( AnnotationUtils . isAnnotationDeclaredLocally ( annotationType ,    clazz )  )     {", "return   new   MetaAnnotationUtils . UntypedAnnotationDescriptor ( clazz ,    clazz . getAnnotation ( annotationType )  )  ;", "}", "}", "for    ( Annotation   composedAnnotation    :    clazz . getDeclaredAnnotations (  )  )     {", "if    (  (  !  ( AnnotationUtils . isInJavaLangAnnotationPackage ( composedAnnotation )  )  )     &  &     ( visited . add ( composedAnnotation )  )  )     {", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( composedAnnotation . annotationType (  )  ,    visited ,    annotationTypes )  ;", "if    ( descriptor    !  =    null )     {", "return   new   MetaAnnotationUtils . UntypedAnnotationDescriptor ( clazz ,    descriptor . getDeclaringClass (  )  ,    composedAnnotation ,    descriptor . getAnnotation (  )  )  ;", "}", "}", "}", "for    ( Class <  ?  >    ifc    :    clazz . getInterfaces (  )  )     {", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( ifc ,    visited ,    annotationTypes )  ;", "if    ( descriptor    !  =    null )     {", "return   new   MetaAnnotationUtils . UntypedAnnotationDescriptor ( clazz ,    descriptor . getDeclaringClass (  )  ,    descriptor . getComposedAnnotation (  )  ,    descriptor . getAnnotation (  )  )  ;", "}", "}", "return   MetaAnnotationUtils . findAnnotationDescriptorForTypes ( clazz . getSuperclass (  )  ,    visited ,    annotationTypes )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypes"], "fileName": "org.springframework.test.util.MetaAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "MetaAnnotationUtils . AnnotationDescriptor < Component >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( startClass ,    Component . class )  ;", "assertNotNull (  \" AnnotationDescriptor   should   not   be   null \"  ,    descriptor )  ;", "assertEquals (  \" rootDeclaringClass \"  ,    rootDeclaringClass ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals (  \" declaringClass \"  ,    declaringClass ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals (  \" annotationType \"  ,    Component . class ,    descriptor . getAnnotationType (  )  )  ;", "assertEquals (  \" component   name \"  ,    name ,    descriptor . getAnnotation (  )  . value (  )  )  ;", "assertNotNull (  \" composedAnnotation   should   not   be   null \"  ,    descriptor . getComposedAnnotation (  )  )  ;", "assertEquals (  \" composedAnnotationType \"  ,    composedAnnotationType ,    descriptor . getComposedAnnotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAtComponentOnComposedAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotation ( startClass ,    rootDeclaringClass ,    composedAnnotationType ,    name ,    composedAnnotationType )  ;", "}", "METHOD_END"], "methodName": ["assertAtComponentOnComposedAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotation ( rootDeclaringClass ,    rootDeclaringClass ,    name ,    composedAnnotationType )  ;", "}", "METHOD_END"], "methodName": ["assertAtComponentOnComposedAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < Component >    annotationType    =    Component . class ;", ". UntypedAnnotationDescriptor   descriptor    =     . findAnnotationDescriptorForTypes ( startClass ,    Service . class ,    annotationType ,    Order . class ,    Transactional . class )  ;", "assertNotNull (  \" UntypedAnnotationDescriptor   should   not   be   null \"  ,    descriptor )  ;", "assertEquals (  \" rootDeclaringClass \"  ,    rootDeclaringClass ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals (  \" declaringClass \"  ,    declaringClass ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals (  \" annotationType \"  ,    annotationType ,    descriptor . getAnnotationType (  )  )  ;", "assertEquals (  \" component   name \"  ,    name ,     (  ( Component )     ( descriptor . getAnnotation (  )  )  )  . value (  )  )  ;", "assertNotNull (  \" composedAnnotation   should   not   be   null \"  ,    descriptor . getComposedAnnotation (  )  )  ;", "assertEquals (  \" composedAnnotationType \"  ,    composedAnnotationType ,    descriptor . getComposedAnnotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAtComponentOnComposedAnnotationForMultipleCandidateTypes"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotationForMultipleCandidateTypes ( startClass ,    rootDeclaringClass ,    composedAnnotationType ,    name ,    composedAnnotationType )  ;", "}", "METHOD_END"], "methodName": ["assertAtComponentOnComposedAnnotationForMultipleCandidateTypes"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotationForMultipleCandidateTypes ( startClass ,    startClass ,    name ,    composedAnnotationType )  ;", "}", "METHOD_END"], "methodName": ["assertAtComponentOnComposedAnnotationForMultipleCandidateTypes"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MetaAnnotationUtils . AnnotationDescriptor < ContextConfiguration >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . MetaAnnotatedAndSuperAnnotatedContextConfigClass . class ,    ContextConfiguration . class )  ;", "assertNotNull (  \" AnnotationDescriptor   should   not   be   null \"  ,    descriptor )  ;", "assertEquals (  \" rootDeclaringClass \"  ,    MetaAnnotationUtilsTests . MetaAnnotatedAndSuperAnnotatedContextConfigClass . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals (  \" declaringClass \"  ,    MetaAnnotationUtilsTests . MetaConfig . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals (  \" annotationType \"  ,    ContextConfiguration . class ,    descriptor . getAnnotationType (  )  )  ;", "assertNotNull (  \" composedAnnotation   should   not   be   null \"  ,    descriptor . getComposedAnnotation (  )  )  ;", "assertEquals (  \" composedAnnotationType \"  ,    MetaAnnotationUtilsTests . MetaConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertArrayEquals (  \" configured   classes \"  ,    new   Class <  ?  >  [  ]  {    String . class    }  ,    descriptor . getAnnotationAttributes (  )  . getClassArray (  \" classes \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForClassWithLocalMetaAnnotationAndAnnotatedSuperclass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotation ( MetaAnnotationUtilsTests . ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface . class ,     \" meta 2  \"  ,    MetaAnnotationUtilsTests . Meta 2  . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForClassWithLocalMetaAnnotationAndMetaAnnotatedInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   rawAnnotation    =    AnnotationUtils . findAnnotation ( MetaAnnotationUtilsTests . ClassWithMetaAnnotatedInterface . class ,    Component . class )  ;", "MetaAnnotationUtils . AnnotationDescriptor < Component >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . ClassWithMetaAnnotatedInterface . class ,    Component . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . ClassWithMetaAnnotatedInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . Meta 1  . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . Meta 1  . class ,    descriptor . getComposedAnnotation (  )  . annotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForClassWithMetaAnnotatedInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotation ( MetaAnnotationUtilsTests . InterfaceWithMetaAnnotation . class ,     \" meta 1  \"  ,    MetaAnnotationUtilsTests . Meta 1  . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForInterfaceWithMetaAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationClass . class ,    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . NonInheritedAnnotationClass . class ,    Order . class )  . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationClass . class ,    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . SubNonInheritedAnnotationClass . class ,    Order . class )  . getRootDeclaringClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForNonInheritedAnnotationOnClass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Order   rawAnnotation    =    MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class . getAnnotation ( Order . class )  ;", "MetaAnnotationUtils . AnnotationDescriptor < Order >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . SubNonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . SubNonInheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForNonInheritedAnnotationOnInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotation ( MetaAnnotationUtilsTests . SubClassWithLocalMetaAnnotationAndMetaAnnotatedInterface . class ,    MetaAnnotationUtilsTests . ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface . class ,     \" meta 2  \"  ,    MetaAnnotationUtilsTests . Meta 2  . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForSubClassWithLocalMetaAnnotationAndMetaAnnotatedInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < MetaAnnotationUtilsTests . ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface >    startClass    =    MetaAnnotationUtilsTests . ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface . class ;", "assertAtComponentOnComposedAnnotationForMultipleCandidateTypes ( startClass ,     \" meta 2  \"  ,    MetaAnnotationUtilsTests . Meta 2  . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesForClassWithLocalMetaAnnotationAndMetaAnnotatedInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   rawAnnotation    =    AnnotationUtils . findAnnotation ( MetaAnnotationUtilsTests . ClassWithMetaAnnotatedInterface . class ,    Component . class )  ;", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . ClassWithMetaAnnotatedInterface . class ,    Service . class ,    Component . class ,    Order . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . ClassWithMetaAnnotatedInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . Meta 1  . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . Meta 1  . class ,    descriptor . getComposedAnnotation (  )  . annotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesForClassWithMetaAnnotatedInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < MetaAnnotationUtilsTests . InterfaceWithMetaAnnotation >    startClass    =    MetaAnnotationUtilsTests . InterfaceWithMetaAnnotation . class ;", "assertAtComponentOnComposedAnnotationForMultipleCandidateTypes ( startClass ,     \" meta 1  \"  ,    MetaAnnotationUtilsTests . Meta 1  . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesForInterfaceWithMetaAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationClass . class ,    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . NonInheritedAnnotationClass . class ,    Order . class )  . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationClass . class ,    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . SubNonInheritedAnnotationClass . class ,    Order . class )  . getRootDeclaringClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesForNonInheritedAnnotationOnClass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Order   rawAnnotation    =    MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class . getAnnotation ( Order . class )  ;", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . SubNonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . SubNonInheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesForNonInheritedAnnotationOnInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotationForMultipleCandidateTypes ( MetaAnnotationUtilsTests . SubClassWithLocalMetaAnnotationAndMetaAnnotatedInterface . class ,    MetaAnnotationUtilsTests . ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface . class ,     \" meta 2  \"  ,    MetaAnnotationUtilsTests . Meta 2  . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesForSubClassWithLocalMetaAnnotationAndMetaAnnotatedInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . InheritedAnnotationClass . class ,    Service . class ,    Component . class ,    Order . class )  ;", "assertNull (  \" Should   not   find    @ Component   on   InheritedAnnotationClass \"  ,    descriptor )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesOnAnnotatedClassWithMissingTargetMetaAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . MetaCycleAnnotatedClass . class ,    Service . class ,    Component . class ,    Order . class )  ;", "assertNull (  \" Should   not   find    @ Component   on   MetaCycleAnnotatedClass \"  ,    descriptor )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < MetaAnnotationUtilsTests . MetaMetaAnnotatedClass >    startClass    =    MetaAnnotationUtilsTests . MetaMetaAnnotatedClass . class ;", "assertAtComponentOnComposedAnnotationForMultipleCandidateTypes ( startClass ,    startClass ,    MetaAnnotationUtilsTests . Meta 2  . class ,     \" meta 2  \"  ,    MetaAnnotationUtilsTests . MetaMeta . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesOnMetaMetaAnnotatedClass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < MetaAnnotationUtilsTests . MetaMetaMetaAnnotatedClass >    startClass    =    MetaAnnotationUtilsTests . MetaMetaMetaAnnotatedClass . class ;", "assertAtComponentOnComposedAnnotationForMultipleCandidateTypes ( startClass ,    startClass ,    MetaAnnotationUtilsTests . Meta 2  . class ,     \" meta 2  \"  ,    MetaAnnotationUtilsTests . MetaMetaMeta . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesOnMetaMetaMetaAnnotatedClass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationClass . class ,    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . InheritedAnnotationClass . class ,    Transactional . class )  . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationClass . class ,    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . SubInheritedAnnotationClass . class ,    Transactional . class )  . getRootDeclaringClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesWithInheritedAnnotationOnClass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Transactional   rawAnnotation    =    MetaAnnotationUtilsTests . InheritedAnnotationInterface . class . getAnnotation ( Transactional . class )  ;", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . SubInheritedAnnotationInterface . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . SubInheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . SubSubInheritedAnnotationInterface . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . SubSubInheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesWithInheritedAnnotationOnInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < Component >    annotationType    =    Component . class ;", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes (  . HasLocalAndMetaComponentAnnotation . class ,    Transactional . class ,    annotationType ,    Order . class )  ;", "assertEquals (  . HasLocalAndMetaComponentAnnotation . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( annotationType ,    descriptor . getAnnotationType (  )  )  ;", "assertNull ( descriptor . getComposedAnnotation (  )  )  ;", "assertNull ( descriptor . getComposedAnnotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesWithLocalAndMetaComponentAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    startClass    =    MetaAnnotationUtilsTests . MetaConfigWithDefaultAttributesTestCase . class ;", "Class < ContextConfiguration >    annotationType    =    ContextConfiguration . class ;", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( startClass ,    Service . class ,    ContextConfiguration . class ,    Order . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( startClass ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( annotationType ,    descriptor . getAnnotationType (  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {        }  ,     (  ( ContextConfiguration )     ( descriptor . getAnnotation (  )  )  )  . value (  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    MetaAnnotationUtilsTests . MetaConfig . DevConfig . class ,    MetaAnnotationUtilsTests . MetaConfig . ProductionConfig . class    }  ,    descriptor . getAnnotationAttributes (  )  . getClassArray (  \" classes \"  )  )  ;", "assertNotNull ( descriptor . getComposedAnnotation (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . MetaConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesWithMetaAnnotationWithDefaultAttributes"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    startClass    =    MetaAnnotationUtilsTests . MetaConfigWithOverriddenAttributesTestCase . class ;", "Class < ContextConfiguration >    annotationType    =    ContextConfiguration . class ;", "MetaAnnotationUtils . UntypedAnnotationDescriptor   descriptor    =    MetaAnnotationUtils . findAnnotationDescriptorForTypes ( startClass ,    Service . class ,    ContextConfiguration . class ,    Order . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( startClass ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( annotationType ,    descriptor . getAnnotationType (  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {        }  ,     (  ( ContextConfiguration )     ( descriptor . getAnnotation (  )  )  )  . value (  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    MetaAnnotationUtilsTests . class    }  ,    descriptor . getAnnotationAttributes (  )  . getClassArray (  \" classes \"  )  )  ;", "assertNotNull ( descriptor . getComposedAnnotation (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . MetaConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesWithMetaAnnotationWithOverriddenAttributes"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < MetaAnnotationUtilsTests . HasMetaComponentAnnotation >    startClass    =    MetaAnnotationUtilsTests . HasMetaComponentAnnotation . class ;", "assertAtComponentOnComposedAnnotationForMultipleCandidateTypes ( startClass ,     \" meta 1  \"  ,    MetaAnnotationUtilsTests . Meta 1  . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesWithMetaComponentAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . NonAnnotatedInterface . class ,    Transactional . class ,    Component . class )  )  ;", "assertNull ( MetaAnnotationUtils . findAnnotationDescriptorForTypes ( MetaAnnotationUtilsTests . NonAnnotatedClass . class ,    Transactional . class ,    Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorForTypesWithNoAnnotationPresent"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MetaAnnotationUtils . AnnotationDescriptor < Component >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . InheritedAnnotationClass . class ,    Component . class )  ;", "assertNull (  \" Should   not   find    @ Component   on   InheritedAnnotationClass \"  ,    descriptor )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorOnAnnotatedClassWithMissingTargetMetaAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MetaAnnotationUtils . AnnotationDescriptor < Component >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . MetaCycleAnnotatedClass . class ,    Component . class )  ;", "assertNull (  \" Should   not   find    @ Component   on   MetaCycleAnnotatedClass \"  ,    descriptor )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < MetaAnnotationUtilsTests . MetaMetaAnnotatedClass >    startClass    =    MetaAnnotationUtilsTests . MetaMetaAnnotatedClass . class ;", "assertAtComponentOnComposedAnnotation ( startClass ,    startClass ,    MetaAnnotationUtilsTests . Meta 2  . class ,     \" meta 2  \"  ,    MetaAnnotationUtilsTests . MetaMeta . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorOnMetaMetaAnnotatedClass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < MetaAnnotationUtilsTests . MetaMetaMetaAnnotatedClass >    startClass    =    MetaAnnotationUtilsTests . MetaMetaMetaAnnotatedClass . class ;", "assertAtComponentOnComposedAnnotation ( startClass ,    startClass ,    MetaAnnotationUtilsTests . Meta 2  . class ,     \" meta 2  \"  ,    MetaAnnotationUtilsTests . MetaMetaMeta . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorOnMetaMetaMetaAnnotatedClass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationClass . class ,    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . InheritedAnnotationClass . class ,    Transactional . class )  . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationClass . class ,    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . SubInheritedAnnotationClass . class ,    Transactional . class )  . getRootDeclaringClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorWithInheritedAnnotationOnClass"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Transactional   rawAnnotation    =    MetaAnnotationUtilsTests . InheritedAnnotationInterface . class . getAnnotation ( Transactional . class )  ;", "MetaAnnotationUtils . AnnotationDescriptor < Transactional >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . SubInheritedAnnotationInterface . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . SubInheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . SubSubInheritedAnnotationInterface . class ,    Transactional . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( MetaAnnotationUtilsTests . SubSubInheritedAnnotationInterface . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( MetaAnnotationUtilsTests . InheritedAnnotationInterface . class ,    descriptor . getDeclaringClass (  )  )  ;", "assertEquals ( rawAnnotation ,    descriptor . getAnnotation (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorWithInheritedAnnotationOnInterface"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < Component >    annotationType    =    Component . class ;", "MetaAnnotationUtils . AnnotationDescriptor < Component >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor (  . HasLocalAndMetaComponentAnnotation . class ,    annotationType )  ;", "assertEquals (  . HasLocalAndMetaComponentAnnotation . class ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( annotationType ,    descriptor . getAnnotationType (  )  )  ;", "assertNull ( descriptor . getComposedAnnotation (  )  )  ;", "assertNull ( descriptor . getComposedAnnotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorWithLocalAndMetaComponentAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAtComponentOnComposedAnnotation ( MetaAnnotationUtilsTests . HasMetaComponentAnnotation . class ,     \" meta 1  \"  ,    MetaAnnotationUtilsTests . Meta 1  . class )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorWithMetaComponentAnnotation"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . NonAnnotatedInterface . class ,    Transactional . class )  )  ;", "assertNull ( MetaAnnotationUtils . findAnnotationDescriptor ( MetaAnnotationUtilsTests . NonAnnotatedClass . class ,    Transactional . class )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDescriptorWithNoAnnotationPresent"], "fileName": "org.springframework.test.util.MetaAnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class < OverriddenMetaAnnotationAttributesTests . MetaLocationsConfigTestCase >    declaringClass    =    OverriddenMetaAnnotationAttributesTests . MetaLocationsConfigTestCase . class ;", "MetaAnnotationUtils . AnnotationDescriptor < ContextConfiguration >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( declaringClass ,    ContextConfiguration . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( declaringClass ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( OverriddenMetaAnnotationAttributesTests . MetaLocationsConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertEquals ( ContextConfiguration . class ,    descriptor . getAnnotationType (  )  )  ;", "assertNotNull ( descriptor . getComposedAnnotation (  )  )  ;", "assertEquals ( OverriddenMetaAnnotationAttributesTests . MetaLocationsConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" foo . xml \"     }  ,    descriptor . getAnnotation (  )  . locations (  )  )  ;", "assertFalse ( descriptor . getAnnotation (  )  . inheritLocations (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextConfigurationLocationsAndInheritLocations"], "fileName": "org.springframework.test.util.OverriddenMetaAnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Class < OverriddenMetaAnnotationAttributesTests . MetaValueConfigTestCase >    declaringClass    =    OverriddenMetaAnnotationAttributesTests . MetaValueConfigTestCase . class ;", "MetaAnnotationUtils . AnnotationDescriptor < ContextConfiguration >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( declaringClass ,    ContextConfiguration . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( declaringClass ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( OverriddenMetaAnnotationAttributesTests . MetaValueConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertEquals ( ContextConfiguration . class ,    descriptor . getAnnotationType (  )  )  ;", "assertNotNull ( descriptor . getComposedAnnotation (  )  )  ;", "assertEquals ( OverriddenMetaAnnotationAttributesTests . MetaValueConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" foo . xml \"     }  ,    descriptor . getAnnotation (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextConfigurationValue"], "fileName": "org.springframework.test.util.OverriddenMetaAnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    declaringClass    =    OverriddenMetaAnnotationAttributesTests . OverriddenMetaLocationsConfigTestCase . class ;", "MetaAnnotationUtils . AnnotationDescriptor < ContextConfiguration >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( declaringClass ,    ContextConfiguration . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( declaringClass ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( OverriddenMetaAnnotationAttributesTests . MetaLocationsConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertEquals ( ContextConfiguration . class ,    descriptor . getAnnotationType (  )  )  ;", "assertNotNull ( descriptor . getComposedAnnotation (  )  )  ;", "assertEquals ( OverriddenMetaAnnotationAttributesTests . MetaLocationsConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" foo . xml \"     }  ,    descriptor . getAnnotation (  )  . locations (  )  )  ;", "assertFalse ( descriptor . getAnnotation (  )  . inheritLocations (  )  )  ;", "AnnotationAttributes   attributes    =    descriptor . getAnnotationAttributes (  )  ;", "assertArrayEquals ( new   String [  ]  {     \" bar . xml \"     }  ,    attributes . getStringArray (  \" locations \"  )  )  ;", "assertTrue ( attributes . getBoolean (  \" inheritLocations \"  )  )  ;", "}", "METHOD_END"], "methodName": ["overriddenContextConfigurationLocationsAndInheritLocations"], "fileName": "org.springframework.test.util.OverriddenMetaAnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    declaringClass    =    OverriddenMetaAnnotationAttributesTests . OverriddenMetaValueConfigTestCase . class ;", "MetaAnnotationUtils . AnnotationDescriptor < ContextConfiguration >    descriptor    =    MetaAnnotationUtils . findAnnotationDescriptor ( declaringClass ,    ContextConfiguration . class )  ;", "assertNotNull ( descriptor )  ;", "assertEquals ( declaringClass ,    descriptor . getRootDeclaringClass (  )  )  ;", "assertEquals ( OverriddenMetaAnnotationAttributesTests . MetaValueConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertEquals ( ContextConfiguration . class ,    descriptor . getAnnotationType (  )  )  ;", "assertNotNull ( descriptor . getComposedAnnotation (  )  )  ;", "assertEquals ( OverriddenMetaAnnotationAttributesTests . MetaValueConfig . class ,    descriptor . getComposedAnnotationType (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" foo . xml \"     }  ,    descriptor . getAnnotation (  )  . value (  )  )  ;", "AnnotationAttributes   attributes    =    descriptor . getAnnotationAttributes (  )  ;", "assertArrayEquals ( new   String [  ]  {     \" foo . xml \"     }  ,    attributes . getStringArray (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["overriddenContextConfigurationValue"], "fileName": "org.springframework.test.util.OverriddenMetaAnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionTestUtils . getField ( null ,    targetClass ,    name )  ;", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( targetObject    !  =    null )     |  |     ( targetClass    !  =    null )  )  ,     \" Either   targetObject   or   targetClass   for   the   field   must   be   specified \"  )  ;", "if    (  ( targetObject    !  =    null )     &  &     (  . springAopPresent )  )     {", "targetObject    =    AopTestUtils . getUltimateTargetObject ( targetObject )  ;", "}", "if    ( targetClass    =  =    null )     {", "targetClass    =    targetObject . getClass (  )  ;", "}", "Field   field    =    ReflectionUtils . findField ( targetClass ,    name )  ;", "if    ( field    =  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \" Could   not   find   field    '  % s '    on    % s   or   target   class    [  % s ]  \"  ,    name ,     . safeToString ( targetObject )  ,    targetClass )  )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Getting   field    '  % s '    from    % s   or   target   class    [  % s ]  \"  ,    name ,     . safeToString ( targetObject )  ,    targetClass )  )  ;", "}", "ReflectionUtils . makeAccessible ( field )  ;", "return   ReflectionUtils . getField ( field ,    targetObject )  ;", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionTestUtils . getField ( targetObject ,    null ,    name )  ;", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( target ,     \" Target   object   must   not   be   null \"  )  ;", "Assert . hasText ( name ,     \" Method   name   must   not   be   empty \"  )  ;", "String   getterMethodName    =    name ;", "if    (  !  ( name . startsWith (  . GETTER _ PREFIX )  )  )     {", "getterMethodName    =     (  . GETTER _ PREFIX )     +     ( StringUtils . capitalize ( name )  )  ;", "}", "Method   method    =    ReflectionUtils . findMethod ( target . getClass (  )  ,    getterMethodName )  ;", "if    (  ( method    =  =    null )     &  &     (  !  ( getterMethodName . equals ( name )  )  )  )     {", "getterMethodName    =    name ;", "method    =    ReflectionUtils . findMethod ( target . getClass (  )  ,    getterMethodName )  ;", "}", "if    ( method    =  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \" Could   not   find   getter   method    '  % s '    on    % s \"  ,    getterMethodName ,     . safeToString ( target )  )  )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Invoking   getter   method    '  % s '    on    % s \"  ,    getterMethodName ,     . safeToString ( target )  )  )  ;", "}", "ReflectionUtils . makeAccessible ( method )  ;", "return   ReflectionUtils . invokeMethod ( method ,    target )  ;", "}", "METHOD_END"], "methodName": ["invokeGetterMethod"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( target ,     \" Target   object   must   not   be   null \"  )  ;", "Assert . hasText ( name ,     \" Method   name   must   not   be   empty \"  )  ;", "try    {", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( target )  ;", "methodInvoker . setTargetMethod ( name )  ;", "methodInvoker . setArguments ( args )  ;", "methodInvoker . prepare (  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Invoking   method    '  % s '    on    % s   with   arguments    % s \"  ,    name ,     . safeToString ( target )  ,    ObjectUtils . nullSafeToString ( args )  )  )  ;", "}", "return    (  ( T )     ( methodInvoker . invoke (  )  )  )  ;", "}    catch    ( Exception   ex )     {", "ReflectionUtils . handleReflectionException ( ex )  ;", "throw   new   IllegalStateException (  \" Should   never   get   here \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . invokeSetterMethod ( target ,    name ,    value ,    null )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethod"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( target ,     \" Target   object   must   not   be   null \"  )  ;", "Assert . hasText ( name ,     \" Method   name   must   not   be   empty \"  )  ;", "Class <  ?  >  [  ]    paramTypes    =     ( type    !  =    null )     ?    new   Class <  ?  >  [  ]  {    type    }     :    null ;", "String   setterMethodName    =    name ;", "if    (  !  ( name . startsWith (  . SETTER _ PREFIX )  )  )     {", "setterMethodName    =     (  . SETTER _ PREFIX )     +     ( StringUtils . capitalize ( name )  )  ;", "}", "Method   method    =    ReflectionUtils . findMethod ( target . getClass (  )  ,    setterMethodName ,    paramTypes )  ;", "if    (  ( method    =  =    null )     &  &     (  !  ( setterMethodName . equals ( name )  )  )  )     {", "setterMethodName    =    name ;", "method    =    ReflectionUtils . findMethod ( target . getClass (  )  ,    setterMethodName ,    paramTypes )  ;", "}", "if    ( method    =  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \" Could   not   find   setter   method    '  % s '    on    % s   with   parameter   type    [  % s ]  \"  ,    setterMethodName ,     . safeToString ( target )  ,    type )  )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Invoking   setter   method    '  % s '    on    % s   with   value    [  % s ]  \"  ,    setterMethodName ,     . safeToString ( target )  ,    value )  )  ;", "}", "ReflectionUtils . makeAccessible ( method )  ;", "ReflectionUtils . invokeMethod ( method ,    target ,    value )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethod"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   St . format (  \" target   object    [  % s ]  \"  ,    target )  ;", "}    catch    ( Exception   ex )     {", "return   St . format (  \" target   of   type    [  % s ]    whose   toSt (  )    method   threw    [  % s ]  \"  ,     ( target    !  =    null    ?    target . getClass (  )  . getName (  )     :     \" unknown \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["safeToString"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( null ,    targetClass ,    name ,    value ,    null )  ;", "}", "METHOD_END"], "methodName": ["setField"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( null ,    targetClass ,    name ,    value ,    type )  ;", "}", "METHOD_END"], "methodName": ["setField"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( targetObject    !  =    null )     |  |     ( targetClass    !  =    null )  )  ,     \" Either   targetObject   or   targetClass   for   the   field   must   be   specified \"  )  ;", "if    (  ( targetObject    !  =    null )     &  &     (  . springAopPresent )  )     {", "targetObject    =    AopTestUtils . getUltimateTargetObject ( targetObject )  ;", "}", "if    ( targetClass    =  =    null )     {", "targetClass    =    targetObject . getClass (  )  ;", "}", "Field   field    =    ReflectionUtils . findField ( targetClass ,    name ,    type )  ;", "if    ( field    =  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \" Could   not   find   field    '  % s '    of   type    [  % s ]    on    % s   or   target   class    [  % s ]  \"  ,    name ,    type ,     . safeToString ( targetObject )  ,    targetClass )  )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Setting   field    '  % s '    of   type    [  % s ]    on    % s   or   target   class    [  % s ]    to   value    [  % s ]  \"  ,    name ,    type ,     . safeToString ( targetObject )  ,    targetClass ,    value )  )  ;", "}", "ReflectionUtils . makeAccessible ( field )  ;", "ReflectionUtils . setField ( field ,    targetObject ,    value )  ;", "}", "METHOD_END"], "methodName": ["setField"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( targetObject ,    name ,    value ,    null )  ;", "}", "METHOD_END"], "methodName": ["setField"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( targetObject ,    null ,    name ,    value ,    type )  ;", "}", "METHOD_END"], "methodName": ["setField"], "fileName": "org.springframework.test.util.ReflectionTestUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( person ,     \" id \"  ,    Long . valueOf (  9  9  )  ,    long . class )  ;", "ReflectionTestUtils . setField ( person ,     \" name \"  ,     \" Tom \"  )  ;", "ReflectionTestUtils . setField ( person ,     \" age \"  ,    Integer . valueOf (  4  2  )  )  ;", "ReflectionTestUtils . setField ( person ,     \" eyeColor \"  ,     \" blue \"  ,    String . class )  ;", "ReflectionTestUtils . setField ( person ,     \" likesPets \"  ,    Boolean . TRUE )  ;", "ReflectionTestUtils . setField ( person ,     \" favoriteNumber \"  ,     . PI ,    Number . class )  ;", "assertEquals ( Long . valueOf (  9  9  )  ,    ReflectionTestUtils . getField ( person ,     \" id \"  )  )  ;", "assertEquals (  \" Tom \"  ,    ReflectionTestUtils . getField ( person ,     \" name \"  )  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    ReflectionTestUtils . getField ( person ,     \" age \"  )  )  ;", "assertEquals (  \" blue \"  ,    ReflectionTestUtils . getField ( person ,     \" eyeColor \"  )  )  ;", "assertEquals ( Boolean . TRUE ,    ReflectionTestUtils . getField ( person ,     \" likesPets \"  )  )  ;", "assertEquals (  . PI ,    ReflectionTestUtils . getField ( person ,     \" favoriteNumber \"  )  )  ;", "assertEquals (  \" ID    ( private   field   in   a   superclass )  \"  ,     9  9  ,    person . getId (  )  )  ;", "assertEquals (  \" name    ( protected   field )  \"  ,     \" Tom \"  ,    person . getName (  )  )  ;", "assertEquals (  \" age    ( private   field )  \"  ,     4  2  ,    person . getAge (  )  )  ;", "assertEquals (  \" eye   color    ( package   private   field )  \"  ,     \" blue \"  ,    person . getEyeColor (  )  )  ;", "assertEquals (  \"  ' likes   pets '    flag    ( package   private   boolean   field )  \"  ,    true ,    person . likesPets (  )  )  ;", "assertEquals (  \"  ' favorite   number '     ( package   field )  \"  ,     . PI ,    person . getFavoriteNumber (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSetFieldAndGetFieldBehavior"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtilsTests . assertSetFieldAndGetFieldBehavior ( proxy )  ;", "assertEquals (  \" ID    ( private   field   in   a   superclass )  \"  ,     9  9  ,    target . getId (  )  )  ;", "assertEquals (  \" name    ( protected   field )  \"  ,     \" Tom \"  ,    target . getName (  )  )  ;", "assertEquals (  \" age    ( private   field )  \"  ,     4  2  ,    target . getAge (  )  )  ;", "assertEquals (  \" eye   color    ( package   private   field )  \"  ,     \" blue \"  ,    target . getEyeColor (  )  )  ;", "assertEquals (  \"  ' likes   pets '    flag    ( package   private   boolean   field )  \"  ,    true ,    target . likesPets (  )  )  ;", "assertEquals (  \"  ' favorite   number '     ( package   field )  \"  ,    ReflectionTestUtilsTests . PI ,    target . getFavoriteNumber (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSetFieldAndGetFieldBehaviorForProxy"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   collaborator    =    ReflectionTestUtils . getField ( entity ,     \" collaborator \"  )  ;", "assertNotNull ( collaborator )  ;", "}", "METHOD_END"], "methodName": ["getFieldOnLegacyEntityWithSideEffectsInToString"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Either   targetObject   or   targetClass \"  )  )  ;", ". getField (  (  ( Class <  ?  >  )     ( null )  )  ,     \" id \"  )  ;", "}", "METHOD_END"], "methodName": ["getFieldWithNullTargetClass"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Either   targetObject   or   targetClass \"  )  )  ;", ". getField (  (  ( Object )     ( null )  )  ,     \" id \"  )  ;", "}", "METHOD_END"], "methodName": ["getFieldWithNullTargetObject"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" public   static   field \"  ,     \" public \"  ,    ReflectionTestUtils . getField ( StaticFields . class ,     \" publicField \"  )  )  ;", "assertEquals (  \" private   static   field \"  ,     \" private \"  ,    ReflectionTestUtils . getField ( StaticFields . class ,     \" privateField \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getStaticFieldViaClass"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StaticFields   staticFields    =    new   StaticFields (  )  ;", "assertEquals (  \" public   static   field \"  ,     \" public \"  ,     . getField ( staticFields ,     \" publicField \"  )  )  ;", "assertEquals (  \" private   static   field \"  ,     \" private \"  ,     . getField ( staticFields ,     \" privateField \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getStaticFieldViaInstance"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   collaborator    =    ReflectionTestUtils . invokeGetterMethod ( entity ,     \" collaborator \"  )  ;", "assertNotNull ( collaborator )  ;", "}", "METHOD_END"], "methodName": ["invokeGetterMethodOnLegacyEntityWithSideEffectsInToString"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( equalTo (  \" number   must   not   be   null \"  )  )  ;", ". invokeMethod ( component ,     \" init \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeInitMethodBeforeAutowiring"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . invokeMethod ( entity ,     \" configure \"  ,    Integer . valueOf (  4  2  )  ,     \" enigma \"  )  ;", "assertEquals (  \" number   should   have   been   configured \"  ,    Integer . valueOf (  4  2  )  ,    entity . getNumber (  )  )  ;", "assertEquals (  \" text   should   have   been   configured \"  ,     \" enigma \"  ,    entity . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodOnLegacyEntityWithSideEffectsInToString"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNull (  \" number \"  ,    component . getNumber (  )  )  ;", "assertNull (  \" text \"  ,    component . getText (  )  )  ;", ". invokeMethod ( component ,     \" configure \"  ,    Integer . valueOf (  4  2  )  ,     \" enigma \"  )  ;", "assertEquals (  \" number   should   have   been   configured \"  ,    Integer . valueOf (  4  2  )  ,    component . getNumber (  )  )  ;", "assertEquals (  \" text   should   have   been   configured \"  ,     \" enigma \"  ,    component . getText (  )  )  ;", ". invokeMethod ( component ,     \" init \"  )  ;", ". invokeMethod ( component ,     \" destroy \"  )  ;", "assertNull (  \" number \"  ,    component . getNumber (  )  )  ;", "assertNull (  \" text \"  ,    component . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodSimulatingLifecycleEvents"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Integer   difference    =    ReflectionTestUtils . invokeMethod ( component ,     \" subtract \"  ,     5  ,     2  )  ;", "assertEquals (  \" subtract (  5  ,     2  )  \"  ,     3  ,    difference . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithAutoboxingAndUnboxing"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( startsWith (  \" Method   not   found \"  )  )  ;", ". invokeMethod ( component ,     \" subtract \"  ,     \" foo \"  ,     2  .  0  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithIncompatibleArgumentTypes"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Integer   sum    =    ReflectionTestUtils . invokeMethod ( component ,     \" add \"  ,     1  ,     2  ,     3  ,     4  )  ;", "assertEquals (  \" add (  1  ,  2  ,  3  ,  4  )  \"  ,     1  0  ,    sum . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithPrimitiveVarArgs"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Integer   sum    =    ReflectionTestUtils . invokeMethod ( component ,     \" add \"  ,    new   int [  ]  {     1  ,     2  ,     3  ,     4     }  )  ;", "assertEquals (  \" add (  1  ,  2  ,  3  ,  4  )  \"  ,     1  0  ,    sum . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithPrimitiveVarArgsAsSingleArgument"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( startsWith (  \" Method   not   found \"  )  )  ;", ". invokeMethod ( component ,     \" configure \"  ,    Integer . valueOf (  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithTooFewArguments"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( startsWith (  \" Method   not   found \"  )  )  ;", ". invokeMethod ( component ,     \" configure \"  ,    Integer . valueOf (  4  2  )  ,     \" enigma \"  ,     \" baz \"  ,     \" quux \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithTooManyArguments"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" setId \"  ,    Long . valueOf (  1  )  ,    long . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" setName \"  ,     \" Jerry \"  ,    String . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" setAge \"  ,    Integer . valueOf (  3  3  )  ,    int . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" setEyeColor \"  ,     \" green \"  ,    String . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" setLikesPets \"  ,    Boolean . FALSE ,    boolean . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" setFavoriteNumber \"  ,    Integer . valueOf (  4  2  )  ,    Number . class )  ;", "assertEquals (  \" ID    ( protected   method   in   a   superclass )  \"  ,     1  ,    person . getId (  )  )  ;", "assertEquals (  \" name    ( private   method )  \"  ,     \" Jerry \"  ,    person . getName (  )  )  ;", "assertEquals (  \" age    ( protected   method )  \"  ,     3  3  ,    person . getAge (  )  )  ;", "assertEquals (  \" eye   color    ( package   private   method )  \"  ,     \" green \"  ,    person . getEyeColor (  )  )  ;", "assertEquals (  \"  ' likes   pets '    flag    ( protected   method   for   a   boolean )  \"  ,    false ,    person . likesPets (  )  )  ;", "assertEquals (  \"  ' favorite   number '     ( protected   method   for   a   Number )  \"  ,    Integer . valueOf (  4  2  )  ,    person . getFavoriteNumber (  )  )  ;", "assertEquals ( Long . valueOf (  1  )  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" getId \"  )  )  ;", "assertEquals (  \" Jerry \"  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" getName \"  )  )  ;", "assertEquals ( Integer . valueOf (  3  3  )  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" getAge \"  )  )  ;", "assertEquals (  \" green \"  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" getEyeColor \"  )  )  ;", "assertEquals ( Boolean . FALSE ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" likesPets \"  )  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" getFavoriteNumber \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethodAndInvokeGetterMethodWithExplicitMethodNames"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" id \"  ,    Long . valueOf (  9  9  )  ,    long . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" name \"  ,     \" Tom \"  )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" age \"  ,    Integer . valueOf (  4  2  )  )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" eyeColor \"  ,     \" blue \"  ,    String . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" likesPets \"  ,    Boolean . TRUE )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" favoriteNumber \"  ,     . PI ,    Number . class )  ;", "assertEquals (  \" ID    ( protected   method   in   a   superclass )  \"  ,     9  9  ,    person . getId (  )  )  ;", "assertEquals (  \" name    ( private   method )  \"  ,     \" Tom \"  ,    person . getName (  )  )  ;", "assertEquals (  \" age    ( protected   method )  \"  ,     4  2  ,    person . getAge (  )  )  ;", "assertEquals (  \" eye   color    ( package   private   method )  \"  ,     \" blue \"  ,    person . getEyeColor (  )  )  ;", "assertEquals (  \"  ' likes   pets '    flag    ( protected   method   for   a   boolean )  \"  ,    true ,    person . likesPets (  )  )  ;", "assertEquals (  \"  ' favorite   number '     ( protected   method   for   a   Number )  \"  ,     . PI ,    person . getFavoriteNumber (  )  )  ;", "assertEquals ( Long . valueOf (  9  9  )  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" id \"  )  )  ;", "assertEquals (  \" Tom \"  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" name \"  )  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" age \"  )  )  ;", "assertEquals (  \" blue \"  ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" eyeColor \"  )  )  ;", "assertEquals ( Boolean . TRUE ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" likesPets \"  )  )  ;", "assertEquals (  . PI ,    ReflectionTestUtils . invokeGetterMethod ( person ,     \" favoriteNumber \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethodAndInvokeGetterMethodWithJavaBeanPropertyNames"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   testCollaborator    =     \" test   collaborator \"  ;", ". invokeSetterMethod ( entity ,     \" collaborator \"  ,    testCollaborator )  ;", "assertTrue ( entity . toString (  )  . contains ( testCollaborator )  )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethodOnLegacyEntityWithSideEffectsInToString"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" likesPets \"  ,    null ,    boolean . class )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethodWithNullValueForPrimitiveBoolean"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" age \"  ,    null ,    int . class )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethodWithNullValueForPrimitiveInt"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" id \"  ,    null ,    long . class )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethodWithNullValueForPrimitiveLong"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" name \"  ,    null ,    String . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" eyeColor \"  ,    null ,    String . class )  ;", "ReflectionTestUtils . invokeSetterMethod ( person ,     \" favoriteNumber \"  ,    null ,    Number . class )  ;", "assertNull (  \" name    ( private   method )  \"  ,    person . getName (  )  )  ;", "assertNull (  \" eye   color    ( package   private   method )  \"  ,    person . getEyeColor (  )  )  ;", "assertNull (  \"  ' favorite   number '     ( protected   method   for   a   Number )  \"  ,    person . getFavoriteNumber (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeSetterMethodWithNullValuesForNonPrimitives"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StaticFields . reset (  )  ;", "}", "METHOD_END"], "methodName": ["resetStaticFields"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtilsTests . assertSetFieldAndGetFieldBehavior ( this . person )  ;", "}", "METHOD_END"], "methodName": ["setFieldAndGetFieldForStandardUseCases"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory ( this . person )  ;", "pf . setProxyTargetClass ( true )  ;", "Person   proxy    =     (  ( Person )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  \" Proxy   is   a   CGLIB   proxy \"  ,    AopUtils . isCglibProxy ( proxy )  )  ;", ". assertSetFieldAndGetFieldBehaviorForProxy ( proxy ,    this . person )  ;", "}", "METHOD_END"], "methodName": ["setFieldAndGetFieldViaCglibProxy"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory ( this . person )  ;", "pf . addInterface ( Person . class )  ;", "Person   proxy    =     (  ( Person )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  \" Proxy   is   a   JDK   dynamic   proxy \"  ,    AopUtils . isJdkDynamicProxy ( proxy )  )  ;", ". assertSetFieldAndGetFieldBehaviorForProxy ( proxy ,    this . person )  ;", "}", "METHOD_END"], "methodName": ["setFieldAndGetFieldViaJdkDynamicProxy"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   testCollaborator    =     \" test   collaborator \"  ;", ". setField ( entity ,     \" collaborator \"  ,    testCollaborator ,    Object . class )  ;", "assertTrue ( entity . toString (  )  . contains ( testCollaborator )  )  ;", "}", "METHOD_END"], "methodName": ["setFieldOnLegacyEntityWithSideEffectsInToString"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Could   not   find   field    ' bogus '  \"  )  )  ;", ". setField ( person ,     \" bogus \"  ,    Long . valueOf (  9  9  )  ,    long . class )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithBogusName"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Either   name   or   type \"  )  )  ;", ". setField ( person ,    null ,    Long . valueOf (  9  9  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithNullNameAndNullType"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Either   targetObject   or   targetClass \"  )  )  ;", ". setField (  (  ( Class <  ?  >  )     ( null )  )  ,     \" id \"  ,    Long . valueOf (  9  9  )  )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithNullTargetClass"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Either   targetObject   or   targetClass \"  )  )  ;", ". setField (  (  ( Object )     ( null )  )  ,     \" id \"  ,    Long . valueOf (  9  9  )  )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithNullTargetObject"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( person ,     \" likesPets \"  ,    null ,    boolean . class )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithNullValueForPrimitiveBoolean"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( person ,     \" age \"  ,    null ,    int . class )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithNullValueForPrimitiveInt"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( person ,     \" id \"  ,    null ,    long . class )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithNullValueForPrimitiveLong"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( person ,     \" name \"  ,     \" Tom \"  )  ;", "ReflectionTestUtils . setField ( person ,     \" eyeColor \"  ,     \" blue \"  ,    String . class )  ;", "ReflectionTestUtils . setField ( person ,     \" favoriteNumber \"  ,     . PI ,    Number . class )  ;", "assertNotNull ( person . getName (  )  )  ;", "assertNotNull ( person . getEyeColor (  )  )  ;", "assertNotNull ( person . getFavoriteNumber (  )  )  ;", "ReflectionTestUtils . setField ( person ,     \" name \"  ,    null ,    String . class )  ;", "ReflectionTestUtils . setField ( person ,     \" eyeColor \"  ,    null ,    String . class )  ;", "ReflectionTestUtils . setField ( person ,     \" favoriteNumber \"  ,    null ,    Number . class )  ;", "assertNull (  \" name    ( protected   field )  \"  ,    person . getName (  )  )  ;", "assertNull (  \" eye   color    ( package   private   field )  \"  ,    person . getEyeColor (  )  )  ;", "assertNull (  \"  ' favorite   number '     ( package   field )  \"  ,    person . getFavoriteNumber (  )  )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithNullValuesForNonPrimitives"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Could   not   find   field \"  )  )  ;", ". setField ( person ,     \" id \"  ,    Long . valueOf (  9  9  )  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["setFieldWithWrongType"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( StaticFields . class ,     \" publicField \"  ,     \" xxx \"  )  ;", "ReflectionTestUtils . setField ( StaticFields . class ,     \" privateField \"  ,     \" yyy \"  )  ;", "assertEquals (  \" public   static   field \"  ,     \" xxx \"  ,    StaticFields . publicField )  ;", "assertEquals (  \" private   static   field \"  ,     \" yyy \"  ,    StaticFields . getPrivateField (  )  )  ;", "}", "METHOD_END"], "methodName": ["setStaticFieldViaClass"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionTestUtils . setField ( StaticFields . class ,     \" publicField \"  ,     \" xxx \"  ,    String . class )  ;", "ReflectionTestUtils . setField ( StaticFields . class ,     \" privateField \"  ,     \" yyy \"  ,    String . class )  ;", "assertEquals (  \" public   static   field \"  ,     \" xxx \"  ,    StaticFields . publicField )  ;", "assertEquals (  \" private   static   field \"  ,     \" yyy \"  ,    StaticFields . getPrivateField (  )  )  ;", "}", "METHOD_END"], "methodName": ["setStaticFieldViaClassWithExplicitType"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StaticFields   staticFields    =    new   StaticFields (  )  ;", ". setField ( staticFields ,    null ,     \" publicField \"  ,     \" xxx \"  ,    null )  ;", ". setField ( staticFields ,    null ,     \" privateField \"  ,     \" yyy \"  ,    null )  ;", "assertEquals (  \" public   static   field \"  ,     \" xxx \"  ,    StaticFields . publicField )  ;", "assertEquals (  \" private   static   field \"  ,     \" yyy \"  ,    StaticFields . getPrivateField (  )  )  ;", "}", "METHOD_END"], "methodName": ["setStaticFieldViaInstance"], "fileName": "org.springframework.test.util.ReflectionTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlString ( content )  ;", "assertThat (  \" Body   content \"  ,    document ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertNode"], "fileName": "org.springframework.test.util.XmlExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlString ( content )  ;", "assertThat (  \" Body   content \"  ,    new   DOMSource ( document )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertSource"], "fileName": "org.springframework.test.util.XmlExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "XmlExpectationsHelper . XmlUnitDiff   diff    =    new   XmlExpectationsHelper . XmlUnitDiff ( expected ,    actual )  ;", "if    ( diff . hasDifferences (  )  )     {", "AssertionErrors . fail (  (  \" Body   content    \"     +     ( diff . toString (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertXmlEqual"], "fileName": "org.springframework.test.util.XmlExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "DocumentBuilderFactory   factory    =    DocumentBuilderFactory . newInstance (  )  ;", "factory . setNamespaceAware ( true )  ;", "DocumentBuilder   documentBuilder    =    factory . newDocumentBuilder (  )  ;", "InputSource   inputSource    =    new   InputSource ( new   StReader ( xml )  )  ;", "return   documentBuilder . parse ( inputSource )  ;", "}", "METHOD_END"], "methodName": ["parseXmlString"], "fileName": "org.springframework.test.util.XmlExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "final   String   control    =     \"  < root >  < field 1  > f 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  <  / root >  \"  ;", "final   String   test    =     \"  < root >  < field 1  > notf 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  <  / root >  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage ( Matchers . startsWith (  \" Body   content   Expected   child    ' field 1  '  \"  )  )  ;", "final      xmlHelper    =    new    (  )  ;", "xmlHelper . assertXmlEqual ( control ,    test )  ;", "}", "METHOD_END"], "methodName": ["assertXmlEqualExceptionForIncorrectValue"], "fileName": "org.springframework.test.util.XmlExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "final   String   control    =     \"  < root >  < field 1  > f 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  < field 3  > f 3  <  / field 3  >  <  / root >  \"  ;", "final   String   test    =     \"  < root >  < field 1  > f 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  <  / root >  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage ( Matchers . containsString (  \" Expected   child   nodelist   length    '  3  '    but   was    '  2  '  \"  )  )  ;", "final      xmlHelper    =    new    (  )  ;", "xmlHelper . assertXmlEqual ( control ,    test )  ;", "}", "METHOD_END"], "methodName": ["assertXmlEqualExceptionForLessEntries"], "fileName": "org.springframework.test.util.XmlExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "final   String   control    =     \"  < root >  < field 1  > f 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  <  / root >  \"  ;", "final   String   test    =     \"  < root >  < field 1  > f 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  < field 3  > f 3  <  / field 3  >  <  / root >  \"  ;", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage ( Matchers . containsString (  \" Expected   child   nodelist   length    '  2  '    but   was    '  3  '  \"  )  )  ;", "final      xmlHelper    =    new    (  )  ;", "xmlHelper . assertXmlEqual ( control ,    test )  ;", "}", "METHOD_END"], "methodName": ["assertXmlEqualExceptionForMoreEntries"], "fileName": "org.springframework.test.util.XmlExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "final   String   control    =     \"  < root >  < field 1  > f 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  <  / root >  \"  ;", "final   String   test    =     \"  < root >  < field 1  > f 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  <  / root >  \"  ;", "final      xmlHelper    =    new    (  )  ;", "xmlHelper . assertXmlEqual ( control ,    test )  ;", "}", "METHOD_END"], "methodName": ["assertXmlEqualForEqual"], "fileName": "org.springframework.test.util.XmlExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "final   String   control    =     \"  < root >  < field 1  > f 1  <  / field 1  >  < field 2  > f 2  <  / field 2  >  <  / root >  \"  ;", "final   String   test    =     \"  < root >  < field 2  > f 2  <  / field 2  >  < field 1  > f 1  <  / field 1  >  <  / root >  \"  ;", "final      xmlHelper    =    new    (  )  ;", "xmlHelper . assertXmlEqual ( control ,    test )  ;", "}", "METHOD_END"], "methodName": ["assertXmlEqualForOutOfOrder"], "fileName": "org.springframework.test.util.XmlExpectationsHelperTests"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "String   actual    =    evaluate ( document ,    XPathConstants . STRING ,    String . class )  ;", "AssertionErrors . assertEquals (  (  \" XPath    \"     +     ( this . expression )  )  ,    expectedValue ,    Boolean . parseBoolean ( actual )  )  ;", "}", "METHOD_END"], "methodName": ["assertBoolean"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "Node   node    =    evaluate ( document ,    XPathConstants . NODE ,    Node . class )  ;", "assertThat (  (  \" XPath    \"     +     ( this . expression )  )  ,    node ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertNode"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "NodeList   nodeList    =    evaluate ( document ,    XPathConstants . NODESET ,    NodeList . class )  ;", "AssertionErrors . assertEquals (  (  \" nodeCount   for   XPath    \"     +     ( this . expression )  )  ,    expectedCount ,     ( nodeList    !  =    null    ?    nodeList . getLength (  )     :     0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNodeCount"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "NodeList   nodeList    =    evaluate ( document ,    XPathConstants . NODESET ,    NodeList . class )  ;", "assertThat (  (  \" nodeCount   for   XPath    \"     +     ( this . expression )  )  ,     ( nodeList    !  =    null    ?    nodeList . getLength (  )     :     0  )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertNodeCount"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "Double   actual    =    evaluate ( document ,    XPathConstants . NUMBER ,    Double . class )  ;", "AssertionErrors . assertEquals (  (  \" XPath    \"     +     ( this . expression )  )  ,    expectedValue ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertNumber"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "Double   result    =    evaluate ( document ,    XPathConstants . NUMBER ,    Double . class )  ;", "assertThat (  (  \" XPath    \"     +     ( this . expression )  )  ,    result ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertNumber"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "String   actual    =    evaluate ( document ,    XPathConstants . STRING ,    String . class )  ;", "AssertionErrors . assertEquals (  (  \" XPath    \"     +     ( this . expression )  )  ,    expectedValue ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertString"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "String   result    =    evaluate ( document ,    XPathConstants . STRING ,    String . class )  ;", "assertThat (  (  \" XPath    \"     +     ( this . expression )  )  ,    result ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["assertString"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "SimpleNamespaceContext   namespaceContext    =    new   SimpleNamespaceContext (  )  ;", "namespaceContext . setBindings (  ( namespaces    !  =    null    ?    namespaces    :    Collec . emptyMap (  )  )  )  ;", "XPath   xpath    =    XPathFactory . newInstance (  )  . newXPath (  )  ;", "xpath . setNamespaceContext ( namespaceContext )  ;", "return   xpath . compile ( expression )  ;", "}", "METHOD_END"], "methodName": ["compileXpathExpression"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "Node   node    =    evaluate ( document ,    XPathConstants . NODE ,    Node . class )  ;", "AssertionErrors . assertTrue (  (  (  \" XPath    \"     +     ( this . expression )  )     +     \"    exists \"  )  ,     ( node    =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( getXpathExpression (  )  . evaluate ( document ,    evaluationType )  )  )  ;", "}", "METHOD_END"], "methodName": ["evaluateXpath"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "Document   document    =    parseXmlByteArray ( content ,    encoding )  ;", "Node   node    =    evaluate ( document ,    XPathConstants . NODE ,    Node . class )  ;", "AssertionErrors . assertTrue (  (  (  \" XPath    \"     +     ( this . expression )  )     +     \"    does   not   exist \"  )  ,     ( node    !  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . xpathExpression ;", "}", "METHOD_END"], "methodName": ["getXpathExpression"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "DocumentBuilderFactory   factory    =    DocumentBuilderFactory . newInstance (  )  ;", "factory . setNamespaceAware ( this . hasNamespaces )  ;", "DocumentBuilder   documentBuilder    =    factory . newDocumentBuilder (  )  ;", "InputSource   inputSource    =    new   InputSource ( new   ByteArrayInputStream ( xml )  )  ;", "if    ( StUtils . hasText ( encoding )  )     {", "inputSource . setEncoding ( encoding )  ;", "}", "return   documentBuilder . parse ( inputSource )  ;", "}", "METHOD_END"], "methodName": ["parseXmlByteArray"], "fileName": "org.springframework.test.util.XpathExpectationsHelper"}, {"methodBody": ["METHOD_START", "{", "int   sum    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( args . length )  ;    i +  +  )     {", "sum    +  =    args [ i ]  ;", "}", "return   sum ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.springframework.test.util.subpackage.Component"}, {"methodBody": ["METHOD_START", "{", "this . number    =    number ;", "thisxt    = xt ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.springframework.test.util.subpackage.Component"}, {"methodBody": ["METHOD_START", "{", "this . number    =    null ;", "thisxt    =    null ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.test.util.subpackage.Component"}, {"methodBody": ["METHOD_START", "{", "return   this . number ;", "}", "METHOD_END"], "methodName": ["getNumber"], "fileName": "org.springframework.test.util.subpackage.Component"}, {"methodBody": ["METHOD_START", "{", "return   this . text ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "org.springframework.test.util.subpackage.Component"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( number )     !  =    null )  ,     \" number   must   not   be   null \"  )  ;", "Assert . state ( StUtils . hasText ( text )  ,     \" text   must   not   be   empty \"  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.test.util.subpackage.Component"}, {"methodBody": ["METHOD_START", "{", "int   product    =     1  ;", "for    ( int   i    =     0  ;    i    <     ( args . length )  ;    i +  +  )     {", "product    *  =    args [ i ]  ;", "}", "return   product ;", "}", "METHOD_END"], "methodName": ["multiply"], "fileName": "org.springframework.test.util.subpackage.Component"}, {"methodBody": ["METHOD_START", "{", "return   a    -    b ;", "}", "METHOD_END"], "methodName": ["subtract"], "fileName": "org.springframework.test.util.subpackage.Component"}, {"methodBody": ["METHOD_START", "{", "this . number    =    number ;", "thisxt    = xt ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.springframework.test.util.subpackage.LegacyEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . collaborator ;", "}", "METHOD_END"], "methodName": ["getCollaborator"], "fileName": "org.springframework.test.util.subpackage.LegacyEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . number ;", "}", "METHOD_END"], "methodName": ["getNumber"], "fileName": "org.springframework.test.util.subpackage.LegacyEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . text ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "org.springframework.test.util.subpackage.LegacyEntity"}, {"methodBody": ["METHOD_START", "{", "this . collaborator    =    collaborator ;", "}", "METHOD_END"], "methodName": ["setCollaborator"], "fileName": "org.springframework.test.util.subpackage.LegacyEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.test.util.subpackage.PersistentEntity"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.test.util.subpackage.PersistentEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . eyeColor ;", "}", "METHOD_END"], "methodName": ["getEyeColor"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . favoriteNumber ;", "}", "METHOD_END"], "methodName": ["getFavoriteNumber"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . likesPets ;", "}", "METHOD_END"], "methodName": ["likesPets"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "this . eyeColor    =    eyeColor ;", "}", "METHOD_END"], "methodName": ["setEyeColor"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "this . favoriteNumber    =    favoriteNumber ;", "}", "METHOD_END"], "methodName": ["setFavoriteNumber"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "this . likesPets    =    likesPets ;", "}", "METHOD_END"], "methodName": ["setLikesPets"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.test.util.subpackage.PersonEntity"}, {"methodBody": ["METHOD_START", "{", "return   StaticFields . privateField ;", "}", "METHOD_END"], "methodName": ["getPrivateField"], "fileName": "org.springframework.test.util.subpackage.StaticFields"}, {"methodBody": ["METHOD_START", "{", "StaticFields . publicField    =     \" public \"  ;", "StaticFields . privateField    =     \" private \"  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.test.util.subpackage.StaticFields"}, {"methodBody": ["METHOD_START", "{", "Set < String >    tempSet    =    new   HashSet <  >  ( incorrectSet )  ;", "tempSet . removeAll ( aionSet )  ;", "if    (  !  ( tempSet . isEmpty (  )  )  )     {", "sb . append (  \" Set   has   too   many   elements :  \\ n \"  )  ;", "for    ( Object   element    :    tempSet )     {", "sb . append (  '  -  '  )  ;", "sb . append ( element )  ;", "sb . append (  '  \\ n '  )  ;", "}", "}", "tempSet    =    new   HashSet <  >  ( aionSet )  ;", "tempSet . removeAll ( incorrectSet )  ;", "if    (  !  ( tempSet . isEmpty (  )  )  )     {", "sb . append (  \" Set   is   missing   elements :  \\ n \"  )  ;", "for    ( Object   element    :    tempSet )     {", "sb . append (  '  -  '  )  ;", "sb . append ( element )  ;", "sb . append (  '  \\ n '  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["appendNonMatchingSetsErrorMessage"], "fileName": "org.springframework.test.web.ModelAndViewAssert"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    mav . getModel (  )  ;", "Object   obj    =    model . get ( modelName )  ;", "if    ( obj    =  =    null )     {", "ionErrors . fail (  (  (  \" Model   attribute   with   name    '  \"     +    modelName )     +     \"  '    is   null \"  )  )  ;", "}", "ionErrors . assertTrue (  (  (  (  (  \" Model   attribute   is   not   of   expected   type    '  \"     +     ( expectedType . getName (  )  )  )     +     \"  '    but   rather   of   type    '  \"  )     +     ( obj . getClass (  )  . getName (  )  )  )     +     \"  '  \"  )  ,    expectedType . isAssignableFrom ( obj . getClass (  )  )  )  ;", "return    (  ( T )     ( obj )  )  ;", "}", "METHOD_END"], "methodName": ["assertAndReturnModelAttributeOfType"], "fileName": "org.springframework.test.web.ModelAndViewAssert"}, {"methodBody": ["METHOD_START", "{", "List   modelList    =    ModelAndViewAssert . assertAndReturnModelAttributeOfType ( mav ,    modelName ,    List . class )  ;", "AssertionErrors . assertTrue (  (  (  (  (  \" Size   of   model   list   is    '  \"     +     ( modelList . size (  )  )  )     +     \"  '    while   size   of   expected   list   is    '  \"  )     +     ( expectedList . size (  )  )  )     +     \"  '  \"  )  ,     (  ( expectedList . size (  )  )     =  =     ( modelList . size (  )  )  )  )  ;", "AssertionErrors . assertTrue (  (  (  \" List   in   model   under   name    '  \"     +    modelName )     +     \"  '    is   not   equal   to   the   expected   list .  \"  )  ,    expectedList . equals ( modelList )  )  ;", "}", "METHOD_END"], "methodName": ["assertCompareListModelAttribute"], "fileName": "org.springframework.test.web.ModelAndViewAssert"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    mav . getModel (  )  ;", "ionErrors . assertTrue (  (  (  \" Model   attribute   with   name    '  \"     +    modelName )     +     \"  '    is   not   available \"  )  ,    model . containsKey ( modelName )  )  ;", "}", "METHOD_END"], "methodName": ["assertModelAttributeAvailable"], "fileName": "org.springframework.test.web.ModelAndViewAssert"}, {"methodBody": ["METHOD_START", "{", "Object   modelValue    =    ModelAndViewAssert . assertAndReturnModelAttributeOfType ( mav ,    modelName ,    Object . class )  ;", "AssertionErrors . assertTrue (  (  (  (  (  \" Model   value   with   name    '  \"     +    modelName )     +     \"  '    is   not   the   same   as   the   expected   value   which   was    '  \"  )     +    expectedValue )     +     \"  '  \"  )  ,    modelValue . equals ( expectedValue )  )  ;", "}", "METHOD_END"], "methodName": ["assertModelAttributeValue"], "fileName": "org.springframework.test.web.ModelAndViewAssert"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    mav . getModel (  )  ;", "if    (  !  ( model . keySet (  )  . equals ( expectedModel . keySet (  )  )  )  )     {", "StringBuilder   sb    =    new   StringBuilder (  \" Keyset   of   expected   model   does   not   match .  \\ n \"  )  ;", ". appendNonMatchingSetsErrorMessage ( expectedModel . keySet (  )  ,    model . keySet (  )  ,    sb )  ;", "AssertionErrors . fail ( sb . toString (  )  )  ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "model . forEach (  (    modelName ,    mavValue )     -  >     {", "Object   assertionValue    =    expectedModel . get ( modelName )  ;", "if    (  !  ( assertionValue . equals ( mavValue )  )  )     {", "sb . append (  \" Value   under   name    '  \"  )  . append ( modelName )  . append (  \"  '    differs ,    should   have   been    '  \"  )  . append ( assertionValue )  . append (  \"  '    but   was    '  \"  )  . append ( mavValue )  . append (  \"  \\  '  \\ n \"  )  ;", "}", "}  )  ;", "if    (  ( sb . length (  )  )     !  =     0  )     {", "sb . insert (  0  ,     \" Values   of   expected   model   do   not   match .  \\ n \"  )  ;", "AssertionErrors . fail ( sb . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertModelAttributeValues"], "fileName": "org.springframework.test.web.ModelAndViewAssert"}, {"methodBody": ["METHOD_START", "{", "List   modelList    =    ModelAndViewAssert . assertAndReturnModelAttributeOfType ( mav ,    modelName ,    List . class )  ;", "AssertionErrors . assertTrue (  (  (  (  (  \" Size   of   model   list   is    '  \"     +     ( modelList . size (  )  )  )     +     \"  '    while   size   of   expected   list   is    '  \"  )     +     ( expectedList . size (  )  )  )     +     \"  '  \"  )  ,     (  ( expectedList . size (  )  )     =  =     ( modelList . size (  )  )  )  )  ;", "modelList . sort ( comparator )  ;", "expectedList . sort ( comparator )  ;", "AssertionErrors . assertTrue (  (  (  \" List   in   model   under   name    '  \"     +    modelName )     +     \"  '    is   not   equal   to   the   expected   list .  \"  )  ,    expectedList . equals ( modelList )  )  ;", "}", "METHOD_END"], "methodName": ["assertSortAndCompareListModelAttribute"], "fileName": "org.springframework.test.web.ModelAndViewAssert"}, {"methodBody": ["METHOD_START", "{", "AssertionErrors . assertTrue (  (  (  (  (  \" View   name   is   not   equal   to    '  \"     +    expectedName )     +     \"  '    but   was    '  \"  )     +     ( mav . getViewName (  )  )  )     +     \"  '  \"  )  ,    ObjectUtils . nullSafeEquals ( expectedName ,    mav . getViewName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertViewName"], "fileName": "org.springframework.test.web.ModelAndViewAssert"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.test.web.Person"}, {"methodBody": ["METHOD_START", "{", "return   someDouble ;", "}", "METHOD_END"], "methodName": ["getSomeDouble"], "fileName": "org.springframework.test.web.Person"}, {"methodBody": ["METHOD_START", "{", "return   someBoolean ;", "}", "METHOD_END"], "methodName": ["isSomeBoolean"], "fileName": "org.springframework.test.web.Person"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.test.web.Person"}, {"methodBody": ["METHOD_START", "{", "this . someBoolean    =    someBoolean ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSomeBoolean"], "fileName": "org.springframework.test.web.Person"}, {"methodBody": ["METHOD_START", "{", "this . someDouble    =    someDouble ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSomeDouble"], "fileName": "org.springframework.test.web.Person"}, {"methodBody": ["METHOD_START", "{", "HttpMethod   method    =    request . getMethod (  )  ;", "URI   uri    =    request . getURI (  )  ;", "String   message    =     (  (  (  \" No   further   requests   expected :    HTTP    \"     +    method )     +     \"     \"  )     +    uri )     +     \"  \\ n \"  ;", "return   new   AssertionError (  ( message    +     ( geDetails (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createUnexpectedRequestError"], "fileName": "org.springframework.test.web.client.AbstractRequestExpectationManager"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . expectations )  ;", "}", "METHOD_END"], "methodName": ["getExpectations"], "fileName": "org.springframework.test.web.client.AbstractRequestExpectationManager"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append ( this . requests . size (  )  )  . append (  \"    request ( s )    executed \"  )  ;", "if    (  !  ( this . requests . isEmpty (  )  )  )     {", "sb . append (  \"  :  \\ n \"  )  ;", "for    ( ClientHttp   request    :    this . requests )     {", "sb . append ( request . toString (  )  )  . append (  \"  \\ n \"  )  ;", "}", "} else    {", "sb . append (  \"  .  \\ n \"  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getRequestDetails"], "fileName": "org.springframework.test.web.client.AbstractRequestExpectationManager"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . requests )  ;", "}", "METHOD_END"], "methodName": ["getRequests"], "fileName": "org.springframework.test.web.client.AbstractRequestExpectationManager"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  (  \" It   looks   like   neither   the   deprecated    \\  \" validateRequestInternal \\  \"  \"     +     \" nor   its   replacement    ( this   method )    are   implemented .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["matchRequest"], "fileName": "org.springframework.test.web.client.AbstractRequestExpectationManager"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["validateRequestInternal"], "fileName": "org.springframework.test.web.client.AbstractRequestExpectationManager"}, {"methodBody": ["METHOD_START", "{", "return   this . requestCount ;", "}", "METHOD_END"], "methodName": ["getRequestCount"], "fileName": "org.springframework.test.web.client.DefaultRequestExpectation"}, {"methodBody": ["METHOD_START", "{", "return   this . requestMatchers ;", "}", "METHOD_END"], "methodName": ["getRequestMatchers"], "fileName": "org.springframework.test.web.client.DefaultRequestExpectation"}, {"methodBody": ["METHOD_START", "{", "return   this . responseCreator ;", "}", "METHOD_END"], "methodName": ["getResponseCreator"], "fileName": "org.springframework.test.web.client.DefaultRequestExpectation"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   MockAsyncClientHttp ( method ,    new   URI ( url )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createRequest"], "fileName": "org.springframework.test.web.client.DefaultRequestExpectationTests"}, {"methodBody": ["METHOD_START", "{", "RequestExpectation   expectation    =    new   DefaultRequestExpectation ( ExpectedCount . twice (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  ;", "expectation . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "expectation . incrementAndValidate (  )  ;", "Assert . assertTrue ( expectation . hasRemainingCount (  )  )  ;", "expectation . incrementAndValidate (  )  ;", "TestCase . assertFalse ( expectation . hasRemainingCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasRemainingCount"], "fileName": "org.springframework.test.web.client.DefaultRequestExpectationTests"}, {"methodBody": ["METHOD_START", "{", "RequestExpectation   expectation    =    new   DefaultRequestExpectation ( ExpectedCount . twice (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  ;", "expectation . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "expectation . incrementAndValidate (  )  ;", "TestCase . assertFalse ( expectation . isSatisfied (  )  )  ;", "expectation . incrementAndValidate (  )  ;", "Assert . assertTrue ( expectation . isSatisfied (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfied"], "fileName": "org.springframework.test.web.client.DefaultRequestExpectationTests"}, {"methodBody": ["METHOD_START", "{", "RequestExpectation   expectation    =    new   DefaultRequestExpectation ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  ;", "expectation . match ( createRequest ( HttpMethod . GET ,     \"  / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.test.web.client.DefaultRequestExpectationTests"}, {"methodBody": ["METHOD_START", "{", "RequestExpectation   expectation    =    new   DefaultRequestExpectation ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  ;", "expectation . andExpect ( MockRestRequestMatchers . method ( HttpMethod . POST )  )  ;", "this . thrown . expectMessage (  \" Unexpected   HttpMethod   expected :  < POST >    but   was :  < GET >  \"  )  ;", "expectation . match ( createRequest ( HttpMethod . GET ,     \"  / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["matchWithFailedExpectation"], "fileName": "org.springframework.test.web.client.DefaultRequestExpectationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectedCount ( min ,    max )  ;", "}", "METHOD_END"], "methodName": ["between"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "return   this . maxCount ;", "}", "METHOD_END"], "methodName": ["getMaxCount"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "return   this . minCount ;", "}", "METHOD_END"], "methodName": ["getMinCount"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectedCount (  1  ,    Integer . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["manyTimes"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( max    >  =     1  )  ,     \"  ' max '    must   be    >  =     1  \"  )  ;", "return   new    (  1  ,    max )  ;", "}", "METHOD_END"], "methodName": ["max"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( min    >  =     1  )  ,     \"  ' min '    must   be    >  =     1  \"  )  ;", "return   new    ( min ,    Integer . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["min"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectedCount (  0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["never"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectedCount (  1  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["once"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( count    >  =     1  )  ,     \"  ' count '    must   be    >  =     1  \"  )  ;", "return   new    ( count ,    count )  ;", "}", "METHOD_END"], "methodName": ["times"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectedCount (  2  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["twice"], "fileName": "org.springframework.test.web.client.ExpectedCount"}, {"methodBody": ["METHOD_START", "{", "try    {", "MockHttpServletResponse   servletResponse    =    mockMvc . perform ( MockMvcRequestBuilders . request ( httpMethod ,    uri )  . content ( requestBody )  . headers ( requestHeaders )  )  . andReturn (  )  . getResponse (  )  ;", "HttpStatus   status    =    HttpStatus . valueOf ( servletResponse . getStatus (  )  )  ;", "byte [  ]    body    =    servletResponse . getContentAsByteArray (  )  ;", "Mocksponse   clientResponse    =    new   Mocksponse ( body ,    status )  ;", "clientResponse . getHeaders (  )  . putAll ( getResponseHeaders ( servletResponse )  )  ;", "return   clientResponse ;", "}    catch    ( Exception   ex )     {", "byte [  ]    body    =    ex . toString (  )  . getBytes ( StandardCharsets . UTF _  8  )  ;", "return   new   Mocksponse ( body ,    HttpStatus . INTERNAL _ SERVER _ ERROR )  ;", "}", "}", "METHOD_END"], "methodName": ["getClientHttpResponse"], "fileName": "org.springframework.test.web.client.MockMvcClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "for    ( String   name    :    response . getHeaderNames (  )  )     {", "List < String >    values    =    response . getHeaders ( name )  ;", "for    ( String   value    :    values )     {", "headers . add ( name ,    value )  ;", "}", "}", "return   headers ;", "}", "METHOD_END"], "methodName": ["getResponseHeaders"], "fileName": "org.springframework.test.web.client.MockMvcClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   MockRestServiceServer . DefaultBuilder ( asyncRestTemplate )  ;", "}", "METHOD_END"], "methodName": ["bindTo"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "return   new   MockRestServiceServer . DefaultBuilder ( restTemplate )  ;", "}", "METHOD_END"], "methodName": ["bindTo"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( restGateway ,     \"  ' gatewaySupport '    must   not   be   null \"  )  ;", "return   new    . DefaultBuilder ( restGateway . getRestTemplate (  )  )  ;", "}", "METHOD_END"], "methodName": ["bindTo"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "return   MockRestServiceServer . bindTo ( asyncRestTemplate )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createServer"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "return   MockRestServiceServer . bindTo ( restTemplate )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createServer"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "return   MockRestServiceServer . bindTo ( restGateway )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createServer"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "return   this . expectationManager . expectRequest ( count ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["expect"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "return   expect ( ExpectedCount . once (  )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["expect"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "this . expectationManager . reset (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "this . expectationManager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["verify"], "fileName": "org.springframework.test.web.client.MockRestServiceServer"}, {"methodBody": ["METHOD_START", "{", "MockRestServiceServer . MockRestServiceServerBuilder   builder    =    MockRestServiceServer . bindTo ( this . restTemplate )  ;", "MockRestServiceServer   server    =    builder . build (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / foo \"  ,    Void . class )  ;", "server . verify (  )  ;", "server    =    builder . ignoreExpectOrder ( true )  . build (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / bar \"  ,    Void . class )  ;", "this . restTemplate . getForObject (  \"  / foo \"  ,    Void . class )  ;", "server . verify (  )  ;", "server    =    builder . build (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / bar \"  ,    Void . class )  ;", "server . verify (  )  ;", "}", "METHOD_END"], "methodName": ["buildMultipleTimes"], "fileName": "org.springframework.test.web.client.MockRestServiceServerTests"}, {"methodBody": ["METHOD_START", "{", "MockRestServiceServer   server    =    MockRestServiceServer . bindTo ( this . restTemplate )  . ignoreExpectOrder ( false )  . build (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / bar \"  ,    Void . class )  ;", "}", "METHOD_END"], "methodName": ["exactExpectOrder"], "fileName": "org.springframework.test.web.client.MockRestServiceServerTests"}, {"methodBody": ["METHOD_START", "{", "MockRestServiceServer   server    =    MockRestServiceServer . bindTo ( this . restTemplate )  . build (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / some - service / some - endpoint \"  )  )  . andRespond (  (    request )     -  >     {", "throw   new   SocketException (  \" pseudo   network   error \"  )  ;", "}  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / reporting - service / report - error \"  )  )  . andExpect ( MockRestRequestMatchers . method ( POST )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "try    {", "this . restTemplate . getForEntity (  \"  / some - service / some - endpoint \"  ,    String . class )  ;", "}    catch    ( Exception   ex )     {", "this . restTemplate . postForEntity (  \"  / reporting - service / report - error \"  ,    ex . toString (  )  ,    String . class )  ;", "}", "server . verify (  )  ;", "}", "METHOD_END"], "methodName": ["followUpRequestAfterFailure"], "fileName": "org.springframework.test.web.client.MockRestServiceServerTests"}, {"methodBody": ["METHOD_START", "{", "MockRestServiceServer   server    =    MockRestServiceServer . bindTo ( this . restTemplate )  . ignoreExpectOrder ( true )  . build (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / bar \"  ,    Void . class )  ;", "this . restTemplate . getForObject (  \"  / foo \"  ,    Void . class )  ;", "server . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ignoreExpectOrder"], "fileName": "org.springframework.test.web.client.MockRestServiceServerTests"}, {"methodBody": ["METHOD_START", "{", "MockRestServiceServer   server    =    MockRestServiceServer . bindTo ( this . restTemplate )  . build (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / foo \"  ,    Void . class )  ;", "server . verify (  )  ;", "server . reset (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / bar \"  ,    Void . class )  ;", "server . verify (  )  ;", "}", "METHOD_END"], "methodName": ["resetAndReuseServer"], "fileName": "org.springframework.test.web.client.MockRestServiceServerTests"}, {"methodBody": ["METHOD_START", "{", "MockRestServiceServer   server    =    MockRestServiceServer . bindTo ( this . restTemplate )  . ignoreExpectOrder ( true )  . build (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / foo \"  ,    Void . class )  ;", "server . verify (  )  ;", "server . reset (  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "server . expect ( MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . restTemplate . getForObject (  \"  / bar \"  ,    Void . class )  ;", "this . restTemplate . getForObject (  \"  / foo \"  ,    Void . class )  ;", "server . verify (  )  ;", "}", "METHOD_END"], "methodName": ["resetAndReuseServerWithUnorderedExpectationManager"], "fileName": "org.springframework.test.web.client.MockRestServiceServerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   MockClientHttp ( method ,    new   URI ( url )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createRequest"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . times (  3  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . times (  3  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["repeatedRequests"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . times (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . times (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["repeatedRequestsInSequentialOrder"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . twice (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . twice (  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . twice (  )  ,    MockRestRequestMatchers . requestTo (  \"  / baz \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . thrown . expectMessage (  \" Unexpected   HttpMethod   expected :  < GET >    but   was :  < POST >  \"  )  ;", "this . manager . validat ( creat ( POST ,     \"  / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["repeatedRequestsNotInOrder"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . min (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . min (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . thrown . expectMessage (  (  \"  3    request ( s )    executed :  \\ n \"     +     (  (  \" GET    / foo \\ n \"     +     \" GET    / bar \\ n \"  )     +     \" GET    / foo \\ n \"  )  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["repeatedRequestsTooFew"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . max (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . max (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . thrown . expectMessage (  (  \" No   further   requests   expected :    HTTP   GET    / foo \\ n \"     +     (  (  (  (  \"  4    request ( s )    executed :  \\ n \"     +     \" GET    / foo \\ n \"  )     +     \" GET    / bar \\ n \"  )     +     \" GET    / foo \\ n \"  )     +     \" GET    / bar \\ n \"  )  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["repeatedRequestsTooMany"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["sequentialRequests"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . min (  1  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . min (  1  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . thrown . expectMessage (  (  \" Further   request ( s )    expected   leaving    1    unsatisfied   e ( s )  .  \\ n \"     +     \"  1    request ( s )    executed :  \\ nGET    / foo \\ n \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["sequentialRequestsTooFew"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . max (  1  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . max (  1  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . thrown . expectMessage (  (  \" No   further   requests   expected :    HTTP   GET    / baz \\ n \"     +     (  (  \"  2    request ( s )    executed :  \\ n \"     +     \" GET    / foo \\ n \"  )     +     \" GET    / bar \\ n \"  )  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sequentialRequestsTooMany"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . times (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validat ( creat ( GET ,     \"  / bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sequentialRequestsWithDifferentCount"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond (  (    request )     -  >     {", "throw   new   SocketException (  \" pseudo   network   error \"  )  ;", "}  )  ;", "this . manager . expectRequest ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / handle - error \"  )  )  . andExpect ( MockRestRequestMatchers . method ( POST )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "try    {", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "fail (  \" Expected   SocketException \"  )  ;", "}    catch    ( SocketException   ex )     {", "}", "this . manager . validat ( creat ( POST ,     \"  / handle - error \"  )  )  ;", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["sequentialRequestsWithFirstFailing"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . manager . validat ( creat ( GET ,     \"  / foo \"  )  )  ;", "}    catch    ( AssertionError   error )     {", "assertEquals (  (  \" No   further   requests   expected :    HTTP   GET    / foo \\ n \"     +     \"  0    request ( s )    executed .  \\ n \"  )  ,    error . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unexpectedRequest"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["zeroExpectedRequests"], "fileName": "org.springframework.test.web.client.SimpleRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   MockAsyncClientHttp ( method ,    new   URI ( url )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createRequest"], "fileName": "org.springframework.test.web.client.UnorderedRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["multipleRequests"], "fileName": "org.springframework.test.web.client.UnorderedRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . twice (  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . twice (  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / bar \"  )  )  ;", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["repeatedRequests"], "fileName": "org.springframework.test.web.client.UnorderedRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . min (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . min (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . thrown . expectMessage (  (  \"  3    request ( s )    executed :  \\ n \"     +     (  (  \" GET    / bar \\ n \"     +     \" GET    / foo \\ n \"  )     +     \" GET    / foo \\ n \"  )  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["repeatedRequestsTooFew"], "fileName": "org.springframework.test.web.client.UnorderedRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . expectRequest ( ExpectedCount . max (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / foo \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . manager . expectRequest ( ExpectedCount . max (  2  )  ,    MockRestRequestMatchers . requestTo (  \"  / bar \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "this . thrown . expectMessage (  (  \" No   further   requests   expected :    HTTP   GET    / foo \\ n \"     +     (  (  (  (  \"  4    request ( s )    executed :  \\ n \"     +     \" GET    / bar \\ n \"  )     +     \" GET    / foo \\ n \"  )     +     \" GET    / bar \\ n \"  )     +     \" GET    / foo \\ n \"  )  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / bar \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "this . manager . validateRequest ( createRequest ( GET ,     \"  / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["repeatedRequestsTooMany"], "fileName": "org.springframework.test.web.client.UnorderedRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . manager . validate ( create ( GET ,     \"  / foo \"  )  )  ;", "}    catch    ( AssertionError   error )     {", "assertEquals (  (  \" No   further   requests   expected :    HTTP   GET    / foo \\ n \"     +     \"  0    request ( s )    executed .  \\ n \"  )  ,    error . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unexpectedRequest"], "fileName": "org.springframework.test.web.client.UnorderedRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . manager . verify (  )  ;", "}", "METHOD_END"], "methodName": ["zeroExpectedRequests"], "fileName": "org.springframework.test.web.client.UnorderedRequestExpectationManagerTests"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "MockClientHttp   mock    =     (  ( MockClientHttp )     ( request )  )  ;", "AssertionErrors . assertEquals (  \"    content \"  ,    expectedContent ,    mock . getBodyAsBytes (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["bytes"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   contentType ( MediaType . parseMediaType ( expectedContentType )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "MediaType   actualType    =    request . getHeaders (  )  . getType (  )  ;", "AssertionErrors . assertTrue (  \"    type   not   set \"  ,     ( actualType    !  =    null )  )  ;", "AssertionErrors . assertEquals (  \"    type \"  ,    expectedType ,    actualType )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   contentTypeCompatibleWith ( MediaType . parseMediaType ( contentType )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeCompatibleWith"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "MediaType   actualType    =    request . getHeaders (  )  . getType (  )  ;", "AssertionErrors . assertTrue (  \"    type   not   set \"  ,     ( actualType    !  =    null )  )  ;", "if    ( actualType    !  =    null )     {", "AssertionErrors . assertTrue (  (  (  (  (  \"    type    [  \"     +    actualType )     +     \"  ]    is   not   compatible   with    [  \"  )     +    contentType )     +     \"  ]  \"  )  ,    actualType . isCompatibleWith ( contentType )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["contentTypeCompatibleWith"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "HttpInputMessage   inputMessage    =    new   HttpInputMessage (  )     {", "@ Override", "public   InputStream   getBody (  )    throws   IOException    {", "MockClientHttp   mock    =     (  ( MockClientHttp )     ( request )  )  ;", "return   new   ByteArrayInputStream ( mock . getBodyAsBytes (  )  )  ;", "}", "@ Override", "public   HttpHeaders   getHeaders (  )     {", "return   request . getHeaders (  )  ;", "}", "}  ;", "FormHttpMessageConverter   converter    =    new   FormHttpMessageConverter (  )  ;", "AssertionErrors . assertEquals (  \"    content \"  ,    expectedContent ,    converter . read ( null ,    inputMessage )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["formData"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   json ( expectedJsonContent ,    false )  ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "try    {", "MockClientHttp   mock    =     (  ( MockClientHttp )     ( request )  )  ;", "jsonHelper . assertJsonEqual ( expectedJsonContent ,    mock . getBodyAsString (  )  ,    strict )  ;", "}    catch    ( Exception   ex )     {", "throw   new   AssertionError (  \" Failed   to   parse   expected   or   actual   JSON   request   content \"  ,    ex )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   ContentRequestMatchers . AbstractXmlRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xmlHelper . assertNode ( request . getBodyAsString (  )  ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   ContentRequestMatchers . AbstractXmlRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xmlHelper . assertSource ( request . getBodyAsString (  )  ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "MockClientHttp   mock    =     (  ( MockClientHttp )     ( request )  )  ;", "AssertionErrors . assertEquals (  \"    content \"  ,    expectedContent ,    mock . getBodyAsString (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "MockClientHttp   mock    =     (  ( MockClientHttp )     ( request )  )  ;", "assertThat (  \"    content \"  ,    mock . getBodyAsString (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   ContentRequestMatchers . AbstractXmlRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xmlHelper . assertXmlEqual ( expectedXmlContent ,    request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["xml"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "this . request    =    new   MockClientHttpRequest (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    content    =     \" test \"  . getBytes (  )  ;", "this . request . getBody (  )  . write ( content )  ;", "MockRes . content (  )  . bytes ( content )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testBytes"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getBody (  )  . write (  \" test \"  . getBytes (  )  )  ;", "MockRes . content (  )  . bytes (  \" Test \"  . getBytes (  )  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testBytesNoMatch"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . setContentType ( APPLICATION _ JSON )  ;", "MockRes . content (  )  . contentType (  \" application / json \"  )  . match ( this . request )  ;", "MockRes . content (  )  . contentType ( APPLICATION _ JSON )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testContentType"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . setContentType ( APPLICATION _ JSON )  ;", "MockRes . content (  )  . contentType (  \" application / xml \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testContentTypeNoMatch1"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . setContentType ( APPLICATION _ JSON )  ;", "MockRes . content (  )  . contentType ( APPLICATION _ ATOM _ XML )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testContentTypeNoMatch2"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" application / x - www - form - urlencoded ; charset = UTF -  8  \"  ;", "String   body    =     \" name +  1  = value +  1  & name +  2  = value + A & name +  2  = value + B & name +  3  \"  ;", "this . request . getHeaders (  )  . setContentType ( MediaType . parseMediaType ( contentType )  )  ;", "this . request . getBody (  )  . write ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "MultiValueMap < String ,    String >    map    =    new   util . LinkedMultiValueMap (  )  ;", "map . add (  \" name    1  \"  ,     \" value    1  \"  )  ;", "map . add (  \" name    2  \"  ,     \" value   A \"  )  ;", "map . add (  \" name    2  \"  ,     \" value   B \"  )  ;", "map . add (  \" name    3  \"  ,    null )  ;", "MockRestRequestMatchers . content (  )  . formData ( map )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testFormData"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  {  \\ n    \\  \" foo   array \\  \"  :  [  \\  \" first \\  \"  ,  \\  \" second \\  \"  ]     ,     \\  \" someExtraProperty \\  \"  :     \\  \" which   is   allowed \\  \"     \\ n }  \"  ;", "this . request . getBody (  )  . write ( content . getBytes (  )  )  ;", "MockRes . content (  )  . json (  \"  {  \\ n    \\  \" foo   array \\  \"  :  [  \\  \" second \\  \"  ,  \\  \" first \\  \"  ]     \\ n }  \"  )  . match ( this . request )  ;", "MockRes . content (  )  . json (  \"  {  \\ n    \\  \" foo   array \\  \"  :  [  \\  \" second \\  \"  ,  \\  \" first \\  \"  ]     \\ n }  \"  ,    false )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testJsonLenientMatch"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  {  \\ n    \\  \" bar \\  \"     :     \\  \" foo \\  \"        \\ n }  \"  ;", "this . request . getBody (  )  . write ( content . getBytes (  )  )  ;", "MockRes . content (  )  . json (  \"  {  \\ n    \\  \" foo \\  \"     :     \\  \" bar \\  \"        \\ n }  \"  )  . match ( this . request )  ;", "MockRes . content (  )  . json (  \"  {  \\ n    \\  \" foo \\  \"     :     \\  \" bar \\  \"        \\ n }  \"  ,    false )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testJsonLenientNoMatch"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  {  \\ n    \\  \" foo \\  \"  :     \\  \" bar \\  \"  ,     \\  \" foo   array \\  \"  :  [  \\  \" first \\  \"  ,  \\  \" second \\  \"  ]     \\ n }  \"  ;", "this . request . getBody (  )  . write ( content . getBytes (  )  )  ;", "MockRes . content (  )  . json (  \"  {  \\ n    \\  \" foo   array \\  \"  :  [  \\  \" first \\  \"  ,  \\  \" second \\  \"  ]     ,     \\  \" foo \\  \"  :     \\  \" bar \\  \"     \\ n }  \"  ,    true )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testJsonStrictMatch"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  {  \\ n    \\  \" foo   array \\  \"  :  [  \\  \" first \\  \"  ,  \\  \" second \\  \"  ]     ,     \\  \" someExtraProperty \\  \"  :     \\  \" which   is   NOT   allowed \\  \"     \\ n }  \"  ;", "this . request . getBody (  )  . write ( content . getBytes (  )  )  ;", "MockRes . content (  )  . json (  \"  {  \\ n    \\  \" foo   array \\  \"  :  [  \\  \" second \\  \"  ,  \\  \" first \\  \"  ]     \\ n }  \"  ,    true )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testJsonStrictNoMatch"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  < foo >  < bar > baz <  / bar >  <  / foo >  \"  ;", "this . request . getBody (  )  . write ( content . getBytes (  )  )  ;", "MockRes . content (  )  . node ( hasXPath (  \"  / foo / bar \"  )  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testNodeMatcher"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  < foo >  < bar > baz <  / bar >  <  / foo >  \"  ;", "this . request . getBody (  )  . write ( content . getBytes (  )  )  ;", "MockRes . content (  )  . node ( hasXPath (  \"  / foo / bar / bar \"  )  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testNodeMatcherNoMatch"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getBody (  )  . write (  \" test \"  . getBytes (  )  )  ;", "MockRes . content (  )  . string (  \" test \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testString"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getBody (  )  . write (  \" test \"  . getBytes (  )  )  ;", "MockRes . content (  )  . string (  \" Test \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testStringNoMatch"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  < foo >  < bar > baz <  / bar >  < bar > bazz <  / bar >  <  / foo >  \"  ;", "this . request . getBody (  )  . write ( content . getBytes (  )  )  ;", "MockRes . content (  )  . xml ( content )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testXml"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getBody (  )  . write (  \"  < foo >  1  1  <  / foo >  \"  . getBytes (  )  )  ;", "MockRes . content (  )  . xml (  \"  < foo >  2  2  <  / foo >  \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testXmlNoMatch"], "fileName": "org.springframework.test.web.client.match.ContentRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . doesNotExist ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )     {", "JsonPathRequestMatchers . this . jsonPathHelper . doesNotHaveJsonPath ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["doesNotHaveJsonPath"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . exists ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )     {", "JsonPathRequestMatchers . this . jsonPathHelper . hasJsonPath ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["hasJsonPath"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValueIsArray ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "public   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValueIsBoolean ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["isBoolean"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "public   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValueIsEmpty ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "public   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValueIsMap ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["isMap"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "public   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValueIsNotEmpty ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["isNotEmpty"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "public   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValueIsNumber ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["isNumber"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "public   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValueIsString ( request . getBodyAsString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["isString"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValue ( request . getBodyAsString (  )  ,    expectedValue )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "JsonPathRequestMatchers . this . jsonPathHelper . assertValue ( request . getBodyAsString (  )  ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers . AbstractJsonPathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   IOException ,    ParseException    {", "String   body    =    request . getBodyAsString (  )  ;", "JsonPathRequestMatchers . this . jsonPathHelper . assertValue ( body ,    matcher ,    targetType )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . bogus \"  )  . doesNotExist (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyArray \"  )  . doesNotExist (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistForAnEmptyArray"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyMap \"  )  . doesNotExist (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistForAnEmptyMap"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . doesNotExist (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistNoMatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . exists (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyArray \"  )  . exists (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["existsForAnEmptyArray"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyMap \"  )  . exists (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["existsForAnEmptyMap"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . bogus \"  )  . exists (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["existsNoMatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . arr \"  )  . isArray (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyArray \"  )  . isArray (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isArrayForAnEmptyArray"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . isArray (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isArrayNoMatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . bool \"  )  . isBoolean (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isBoolean"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . isBoolean (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isBooleanNoMatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyArray \"  )  . isEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isEmptyForAnEmptyArray"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyMap \"  )  . isEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isEmptyForAnEmptyMap"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyString \"  )  . isEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isEmptyForAnEmptyString"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . colorMap \"  )  . isMap (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isMap"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyMap \"  )  . isMap (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isMapForAnEmptyMap"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . isMap (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isMapNoMatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyArray \"  )  . isNotEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForAnEmptyArray"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyMap \"  )  . isNotEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForAnEmptyMap"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . emptyString \"  )  . isNotEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForAnEmptyString"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . arr \"  )  . isNotEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForArray"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . bool \"  )  . isNotEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForBoolean"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . colorMap \"  )  . isNotEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForMap"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . num \"  )  . isNotEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForNumber"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . isNotEmpty (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForString"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . num \"  )  . isNumber (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNumber"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . isNumber (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isNumberNoMatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . isString (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isString"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . arr \"  )  . isString (  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["isStringNoMatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . value (  \" foo \"  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["valueWithDirectMatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . value ( equalTo (  \" foo \"  )  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["valueWithMatcher"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . value ( equalTo (  \" bogus \"  )  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["valueWithMatcherAndMismatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . num \"  )  . value ( equalTo (  5  .  0 F )  ,    Float . class )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["valueWithMatcherAndNumberConversion"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . str \"  )  . value (  \" bogus \"  )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["valueWithMismatch"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathRequestMatchers (  \"  $  . num \"  )  . value (  5  .  0 F )  . match ( JsonPathRequestMatchersTests . request )  ;", "}", "METHOD_END"], "methodName": ["valueWithNumberConversion"], "fileName": "org.springframework.test.web.client.match.JsonPathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "}  ;", "}", "METHOD_END"], "methodName": ["anything"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "List < String >    values    =    map . get ( name )  ;", "String   message    =     (  (  (  \" Expected    \"     +    valueType )     +     \"     <  \"  )     +    name )     +     \"  >  \"  ;", "if    ( values    =  =    null )     {", "AssertionErrors . fail (  ( message    +     \"    to   exist   but   was   null \"  )  )  ;", "}", "if    ( count    >     ( values . size (  )  )  )     {", "AssertionErrors . fail (  (  (  (  ( message    +     \"    to   have   at   least    <  \"  )     +    count )     +     \"  >    values   but   found    \"  )     +    values )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValueCount"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   ContentRequestMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["content"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   UriComponentsBuilder . fromUri ( request . getURI (  )  )  . build (  )  . getQueryParams (  )  ;", "}", "METHOD_END"], "methodName": ["getQueryParams"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", ". assertValueCount (  \" header \"  ,    name ,    request . getHeaders (  )  ,    expectedValues . length )  ;", "List < String >    headerValues    =    request . getHeaders (  )  . get ( name )  ;", "Assert . state (  ( headerValues    !  =    null )  ,     \" No   header   values \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( expectedValues . length )  ;    i +  +  )     {", "AssertionErrors . assertEquals (  (  (  \" Request   header    [  \"     +    name )     +     \"  ]  \"  )  ,    expectedValues [ i ]  ,    headerValues . get ( i )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", ". assertValueCount (  \" header \"  ,    name ,    request . getHeaders (  )  ,    matchers . length )  ;", "List < String >    headerValues    =    request . getHeaders (  )  . get ( name )  ;", "Assert . state (  ( headerValues    !  =    null )  ,     \" No   header   values \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( matchers . length )  ;    i +  +  )     {", "assertThat (  (  (  \" Request   header    [  \"     +    name )     +     \"  ]  \"  )  ,    headerValues . get ( i )  ,    matchers [ i ]  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers ( expression ,    args )  ;", "}", "METHOD_END"], "methodName": ["jsonPath"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathRequestMatchers ( expression )  . value ( matcher )  ;", "}", "METHOD_END"], "methodName": ["jsonPath"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \"  ' method '    must   not   be   null \"  )  ;", "return    (    r )     -  >    AssertionErrors . assertEquals (  \" Unexpected   HttpMethod \"  ,    method ,    r . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "MultiValueMap < String ,    String >    params    =     . getQueryParams ( request )  ;", ". assertValueCount (  \" query   param \"  ,    name ,    params ,    expectedValues . length )  ;", "for    ( int   i    =     0  ;    i    <     ( expectedValues . length )  ;    i +  +  )     {", "AssertionErrors . assertEquals (  (  (  \" Query   param    [  \"     +    name )     +     \"  ]  \"  )  ,    expectedValues [ i ]  ,    params . get ( name )  . get ( i )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["queryParam"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "MultiValueMap < String ,    String >    params    =     . getQueryParams ( request )  ;", ". assertValueCount (  \" query   param \"  ,    name ,    params ,    matchers . length )  ;", "for    ( int   i    =     0  ;    i    <     ( matchers . length )  ;    i +  +  )     {", "assertThat (  \" Query   param \"  ,    params . get ( name )  . get ( i )  ,    matchers [ i ]  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["queryParam"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( expectedUri ,     \"  ' uri '    must   not   be   null \"  )  ;", "return    (    request )     -  >    AssertionErrors . assertEquals (  \"    URI \"  ,    expectedUri ,    request . getURI (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestTo"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uri ,     \"  ' uri '    must   not   be   null \"  )  ;", "return    (    r )     -  >    AssertionErrors . assertEquals (  \" Unexpected   r \"  ,    uri ,    r . getURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestTo"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( matcher ,     \"  ' matcher '    must   not   be   null \"  )  ;", "return    (    request )     -  >    assertThat (  \"    URI \"  ,    request . getURI (  )  . toString (  )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["requestTo"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( expectedUri ,     \"  ' uri '    must   not   be   null \"  )  ;", "URI   uri    =    UriComponentsBuilder . fromUriString ( expectedUri )  . buildAndExpand ( uriVars )  . encode (  )  . toUri (  )  ;", "return    . requestTo ( uri )  ;", "}", "METHOD_END"], "methodName": ["requestToUriTemplate"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers ( expression ,    null ,    args )  ;", "}", "METHOD_END"], "methodName": ["xpath"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers ( expression ,    namespaces ,    args )  ;", "}", "METHOD_END"], "methodName": ["xpath"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . put (  \" foo \"  ,    Arrays . asList (  \" bar \"  ,     \" baz \"  )  )  ;", ". header (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . put (  \" foo \"  ,    Arrays . asList (  \" bar \"  ,     \" baz \"  )  )  ;", ". header (  \" foo \"  ,    Matchers . containsString (  \" ba \"  )  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["headerContains"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >    MockRestRequestMatchers . header (  \" foo \"  ,    containsString (  \" baz \"  )  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" but   was   null \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headerContainsWithMissingHeader"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . put (  \" foo \"  ,    Arrays . asList (  \" bar \"  ,     \" baz \"  )  )  ;", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >     . header (  \" foo \"  ,    containsString (  \" bx \"  )  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" was    \\  \" bar \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headerContainsWithMissingValue"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >    MockRestRequestMatchers . header (  \" foo \"  ,     \" bar \"  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" was   null \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headerMissing"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . put (  \" foo \"  ,    Arrays . asList (  \" bar \"  ,     \" baz \"  )  )  ;", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >     . header (  \" foo \"  ,     \" bad \"  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" expected :  < bad >    but   was :  < bar >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headerMissingValue"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . put (  \" foo \"  ,    Arrays . asList (  \" bar \"  ,     \" baz \"  )  )  ;", ". header (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >    MockRestRequestMatchers . header (  \" foo \"  ,     \" bar \"  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" but   was   null \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headersWithMissingHeader"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . getHeaders (  )  . put (  \" foo \"  ,    Collections . singletonList (  \" bar \"  )  )  ;", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >     . header (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" to   have   at   least    <  2  >    values \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headersWithMissingValue"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( GET )  ;", ". method ( GET )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( POST )  ;", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >     . method ( HttpMethod . GET )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" expected :  < GET >    but   was :  < POST >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["methodNoMatch"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / a ? foo = bar & foo = baz \"  )  )  ;", ". queryParam (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["queryParam"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / a ? foo = bar & foo = baz \"  )  )  ;", ". queryParam (  \" foo \"  ,    Matchers . containsString (  \" ba \"  )  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["queryParamContains"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / a ? foo = bar & foo = baz \"  )  )  ;", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >     . queryParam (  \" foo \"  ,    containsString (  \" bx \"  )  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" was    \\  \" bar \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamContainsWithMissingValue"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / a \"  )  )  ;", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >     . queryParam (  \" foo \"  ,     \" bar \"  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" but   was   null \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamMissing"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / a ? foo = bar & foo = baz \"  )  )  ;", "AssertionError   error    =    Assertions . assertThrows ( AssertionError . class ,     (  )     -  >     . queryParam (  \" foo \"  ,     \" bad \"  )  . match ( this . request )  )  ;", "MatcherAssert . assertThat ( error . getMessage (  )  ,    Matchers . containsString (  \" expected :  < bad >    but   was :  < bar >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamMissingValue"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / bar \"  )  )  ;", ". requestTo (  \" http :  /  / foo . com / bar \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["requestTo"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / bar \"  )  )  ;", ". requestTo ( Matchers . containsString (  \" bar \"  )  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["requestToContains"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / bar \"  )  )  ;", "Assertions . assertThrows ( AssertionError . class ,     (  )     -  >     . requestTo (  \" http :  /  / foo . com / wrong \"  )  . match ( this . request )  )  ;", "}", "METHOD_END"], "methodName": ["requestToNoMatch"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setURI ( new   URI (  \" http :  /  / foo . com / bar \"  )  )  ;", ". requestToUriTemplate (  \" http :  /  / foo . com /  { bar }  \"  ,     \" bar \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["requestToUriTemplate"], "fileName": "org.springframework.test.web.client.match.MockRestRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . assertBoolean ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING ,    value )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["booleanValue"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . doesNotExist ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . exists ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . assertNode ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . assertNodeCount ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING ,    expectedCount )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["nodeCount"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . assertNodeCount ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["nodeCount"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . assertNumber ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING ,    value )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["number"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . assertNumber ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["number"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . assertString ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING ,    value )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathRequestMatchers . AbstractXpathRequestMatcher (  )     {", "@ Override", "protected   void   matchInternal ( MockClientHttpRequest   request )    throws   Exception    {", "xpathHelper . assertString ( request . getBodyAsBytes (  )  ,    XpathRequestMatchers . DEFAULT _ ENCODING ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchers"}, {"methodBody": ["METHOD_START", "{", "this . request    =    new   MockClientHttpRequest (  )  ;", "this . request . getBody (  )  . write (  . RESPONSE _ CONTENT . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar [  2  ]  \"  ,    null )  . booleanValue ( true )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testBoolean"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar [  2  ]  \"  ,    null )  . booleanValue ( false )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testBooleanNoMatch"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / Bar \"  ,    null )  . doesNotExist (  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotExist"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar \"  ,    null )  . doesNotExist (  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotExistNoMatch"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar \"  ,    null )  . exists (  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / Bar \"  ,    null )  . exists (  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testExistsNoMatch"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar \"  ,    null )  . nodeCount (  2  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testNodeCount"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar \"  ,    null )  . nodeCount (  1  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testNodeCountNoMatch"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar \"  ,    null )  . node ( Matchers . notNullValue (  )  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testNodeMatcher"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar \"  ,    null )  . node ( Matchers . nullValue (  )  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testNodeMatcherNoMatch"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar [  1  ]  \"  ,    null )  . number (  1  1  1  .  0  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testNumber"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar [  1  ]  \"  ,    null )  . number (  1  1  1  .  1  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testNumberNoMatch"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar [  1  ]  \"  ,    null )  . string (  \"  1  1  1  \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testString"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathRequestMatchers (  \"  / foo / bar [  1  ]  \"  ,    null )  . string (  \"  1  1  2  \"  )  . match ( this . request )  ;", "}", "METHOD_END"], "methodName": ["testStringNoMatch"], "fileName": "org.springframework.test.web.client.match.XpathRequestMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . content    =    content ;", "return   this ;", "}", "METHOD_END"], "methodName": ["body"], "fileName": "org.springframework.test.web.client.response.DefaultResponseCreator"}, {"methodBody": ["METHOD_START", "{", "this . content    =    content . getBytes ( StandardCharsets . UTF _  8  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["body"], "fileName": "org.springframework.test.web.client.response.DefaultResponseCreator"}, {"methodBody": ["METHOD_START", "{", "this . contentResource    =    resource ;", "return   this ;", "}", "METHOD_END"], "methodName": ["body"], "fileName": "org.springframework.test.web.client.response.DefaultResponseCreator"}, {"methodBody": ["METHOD_START", "{", "this . headers . setContentType ( mediaType )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.client.response.DefaultResponseCreator"}, {"methodBody": ["METHOD_START", "{", "this . headers . putAll ( headers )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.test.web.client.response.DefaultResponseCreator"}, {"methodBody": ["METHOD_START", "{", "this . headers . setLocation ( location )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["location"], "fileName": "org.springframework.test.web.client.response.DefaultResponseCreator"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResponseCreator ( HttpStatus . BAD _ REQUEST )  ;", "}", "METHOD_END"], "methodName": ["withBadRequest"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResponseCreator ( HttpStatus . CREATED )  . location ( location )  ;", "}", "METHOD_END"], "methodName": ["withCreatedEntity"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResponseCreator ( HttpStatus . NO _ CONTENT )  ;", "}", "METHOD_END"], "methodName": ["withNoContent"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResponseCreator ( HttpStatus . INTERNAL _ SERVER _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["withServerError"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResponseCreator ( status )  ;", "}", "METHOD_END"], "methodName": ["withStatus"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResponseCreator ( HttpStatus . OK )  ;", "}", "METHOD_END"], "methodName": ["withSuccess"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   creator    =    new   DefaultResponseCreator ( HttpStatus . OK )  . body ( body )  ;", "return   contentType    !  =    null    ?    creator . contentType ( contentType )     :    creator ;", "}", "METHOD_END"], "methodName": ["withSuccess"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   creator    =    new   DefaultResponseCreator ( HttpStatus . OK )  . body ( body )  ;", "return   contentType    !  =    null    ?    creator . contentType ( contentType )     :    creator ;", "}", "METHOD_END"], "methodName": ["withSuccess"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   creator    =    new   DefaultResponseCreator ( HttpStatus . OK )  . body ( body )  ;", "return   contentType    !  =    null    ?    creator . contentType ( contentType )     :    creator ;", "}", "METHOD_END"], "methodName": ["withSuccess"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResponseCreator ( HttpStatus . UNAUTHORIZED )  ;", "}", "METHOD_END"], "methodName": ["withUnauthorizedRequest"], "fileName": "org.springframework.test.web.client.response.MockRestResponseCreators"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   responseCreator    =    MockRestResponseCreators . withBadRequest (  )  ;", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( responseCreator . createResponse ( null )  )  )  ;", "assertEquals ( BAD _ REQUEST ,    response . getStatusCode (  )  )  ;", "assertTrue ( response . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  0  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["badRequest"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    new   URI (  \"  / foo \"  )  ;", "DefaultResponseCreator   responseCreator    =    MockRest . withCreatedEntity ( location )  ;", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( responseCreator . createResponse ( null )  )  )  ;", "assertEquals ( CREATED ,    response . getStatusCode (  )  )  ;", "assertEquals ( location ,    response . getHeaders (  )  . getLocation (  )  )  ;", "assertEquals (  0  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["created"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   responseCreator    =    MockRestResponseCreators . withNoContent (  )  ;", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( responseCreator . createResponse ( null )  )  )  ;", "assertEquals ( NO _ CONTENT ,    response . getStatusCode (  )  )  ;", "assertTrue ( response . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  0  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["noContent"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   responseCreator    =    MockRestResponseCreators . withServerError (  )  ;", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( responseCreator . createResponse ( null )  )  )  ;", "assertEquals ( INTERNAL _ SERVER _ ERROR ,    response . getStatusCode (  )  )  ;", "assertTrue ( response . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  0  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["serverError"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( MockRestResponseCreators . withSuccess (  )  . createResponse ( null )  )  )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertTrue ( response . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  0  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["success"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   responseCreator    =    MockRestResponseCreators . withSuccess (  \" foo \"  ,    TEXT _ PLAIN )  ;", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( responseCreator . createResponse ( null )  )  )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    response . getHeaders (  )  . getContentType (  )  )  ;", "assertArrayEquals (  \" foo \"  . getBytes (  )  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["successWithContent"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   responseCreator    =    MockRestResponseCreators . withSuccess (  \" foo \"  ,    null )  ;", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( responseCreator . createResponse ( null )  )  )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertNull ( response . getHeaders (  )  . getContentType (  )  )  ;", "assertArrayEquals (  \" foo \"  . getBytes (  )  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["successWithContentWithoutContentType"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   responseCreator    =    MockRestResponseCreators . withUnauthorizedRequest (  )  ;", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( responseCreator . createResponse ( null )  )  )  ;", "assertEquals ( UNAUTHORIZED ,    response . getStatusCode (  )  )  ;", "assertTrue ( response . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  0  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["unauthorized"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultResponseCreator   responseCreator    =    MockRestResponseCreators . withStatus ( FORBIDDEN )  ;", "MockClientHttpResponse   response    =     (  ( MockClientHttpResponse )     ( responseCreator . createResponse ( null )  )  )  ;", "assertEquals ( FORBIDDEN ,    response . getStatusCode (  )  )  ;", "assertTrue ( response . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  0  ,    StreamUtils . copyToByteArray ( response . getBody (  )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["withStatus"], "fileName": "org.springframework.test.web.client.response.ResponseCreatorsTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.client.samples.MockMvcClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "RestTemplate   template    =    new   RestTemplate ( new   MockMvcClientHttpRequestFactory ( this . mockMvc )  )  ;", "String   result    =    template . getForObject (  \"  / foo \"  ,    String . class )  ;", "Assert . assertEquals (  \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.web.client.samples.MockMvcClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AsyncRestTemplate   template    =    new   AsyncRestTemplate ( new   MockMvcClientHttpRequestFactory ( this . mockMvc )  )  ;", "ListenableFuture < ResponseEntity < String >  >    entity    =    template . getForEntity (  \"  / foo \"  ,    String . class )  ;", "Assert . assertEquals (  \" bar \"  ,    entity . get (  )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAsyncTemplate"], "fileName": "org.springframework.test.web.client.samples.MockMvcClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   responseBody    =     \"  {  \\  \" name \\  \"     :     \\  \" Ludwig   van   Beethoven \\  \"  ,     \\  \" someDouble \\  \"     :     \\  \"  1  .  6  0  3  5  \\  \"  }  \"  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "ListenableFuture < ResponseEntity < Person >  >    ludwig    =    this . restTemplate . getForEntity (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["performGet"], "fileName": "org.springframework.test.web.client.samples.SampleAsyncTests"}, {"methodBody": ["METHOD_START", "{", "String   responseBody    =     \"  {  \\  \" name \\  \"     :     \\  \" Ludwig   van   Beethoven \\  \"  ,     \\  \" someDouble \\  \"     :     \\  \"  1  .  6  0  3  5  \\  \"  }  \"  ;", "this . mockServer . expect ( ExpectedCount . manyTimes (  )  ,    MockRestRequestMatchers . requestTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "ListenableFuture < ResponseEntity < Person >  >    ludwig    =    this . restTemplate . getForEntity (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . restTemplate . getForEntity (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . restTemplate . getForEntity (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . restTemplate . getForEntity (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . restTemplate . getForEntity (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["performGetManyTimes"], "fileName": "org.springframework.test.web.client.samples.SampleAsyncTests"}, {"methodBody": ["METHOD_START", "{", "Resource   responseBody    =    new   ClassPathResource (  \" ludwig . json \"  ,    this . getClass (  )  )  ;", "this . mockServer . expect ( MockRRequMatchers . requTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRRequMatchers . method ( GET )  )  . andRespond ( MockRResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "ListenableFuture < ResponseEntity < Person >  >    ludwig    =    this . rTemplate . getForEntity (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["performGetWithResponseBodyFromFile"], "fileName": "org.springframework.test.web.client.samples.SampleAsyncTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / number \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  \"  1  \"  ,    TEXT _ PLAIN )  )  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / number \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  \"  2  \"  ,    TEXT _ PLAIN )  )  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / number \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  \"  4  \"  ,    TEXT _ PLAIN )  )  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / number \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  \"  8  \"  ,    TEXT _ PLAIN )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "ListenableFuture < ResponseEntity < St >  >    result    =    this . restTemplate . getForEntity (  \"  / number \"  ,    St . class )  ;", "result    =    this . restTemplate . getForEntity (  \"  / number \"  ,    St . class )  ;", "try    {", "this . mockServer . verify (  )  ;", "}    catch    ( AssertionError   error )     {", "assertTrue ( error . getMessage (  )  ,    error . getMessage (  )  . contains (  \"  2    unsatisfied   expectation ( s )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["verify"], "fileName": "org.springframework.test.web.client.samples.SampleAsyncTests"}, {"methodBody": ["METHOD_START", "{", "String   responseBody    =     \"  {  \\  \" name \\  \"     :     \\  \" Ludwig   van   Beethoven \\  \"  ,     \\  \" someDouble \\  \"     :     \\  \"  1  .  6  0  3  5  \\  \"  }  \"  ;", "this . mockServer . expect ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "this . mockServer . expect ( ExpectedCount . never (  )  ,    MockRestRequestMatchers . requestTo (  \"  / composers /  4  3  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "this . restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["expectNever"], "fileName": "org.springframework.test.web.client.samples.SampleTests"}, {"methodBody": ["METHOD_START", "{", "String   responseBody    =     \"  {  \\  \" name \\  \"     :     \\  \" Ludwig   van   Beethoven \\  \"  ,     \\  \" someDouble \\  \"     :     \\  \"  1  .  6  0  3  5  \\  \"  }  \"  ;", "this . mockServer . expect ( ExpectedCount . once (  )  ,    MockRestRequestMatchers . requestTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "this . mockServer . expect ( ExpectedCount . never (  )  ,    MockRestRequestMatchers . requestTo (  \"  / composers /  4  3  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "this . restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  3  )  ;", "}", "METHOD_END"], "methodName": ["expectNeverViolated"], "fileName": "org.springframework.test.web.client.samples.SampleTests"}, {"methodBody": ["METHOD_START", "{", "String   responseBody    =     \"  {  \\  \" name \\  \"     :     \\  \" Ludwig   van   Beethoven \\  \"  ,     \\  \" someDouble \\  \"     :     \\  \"  1  .  6  0  3  5  \\  \"  }  \"  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "Person   ludwig    =    this . restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["performGet"], "fileName": "org.springframework.test.web.client.samples.SampleTests"}, {"methodBody": ["METHOD_START", "{", "String   responseBody    =     \"  {  \\  \" name \\  \"     :     \\  \" Ludwig   van   Beethoven \\  \"  ,     \\  \" someDouble \\  \"     :     \\  \"  1  .  6  0  3  5  \\  \"  }  \"  ;", "this . mockServer . expect ( ExpectedCount . manyTimes (  )  ,    MockRestRequestMatchers . requestTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "Person   ludwig    =    this . restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["performGetManyTimes"], "fileName": "org.springframework.test.web.client.samples.SampleTests"}, {"methodBody": ["METHOD_START", "{", "Resource   responseBody    =    new   ClassPathResource (  \" ludwig . json \"  ,    this . getClass (  )  )  ;", "this . mockServer . expect ( MockRRequMatchers . requTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRRequMatchers . method ( GET )  )  . andRespond ( MockRResponseCreators . withSuccess ( responseBody ,    APPLICATION _ JSON )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "Person   ludwig    =    this . rTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["performGetWithResponseBodyFromFile"], "fileName": "org.springframework.test.web.client.samples.SampleTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" ludwig . json \"  ,    this . getClass (  )  )  ;", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "restTemplate . setInterceptors ( Collections . singletonList ( new    . ContentInterceptor ( resource )  )  )  ;", "MockRestServiceServer   mockServer    =    MockRestServiceServer . bindTo ( restTemplate )  . ignoreExpectOrder ( true )  . bufferContent (  )  . build (  )  ;", "mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers /  4  2  \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess ( resource ,    APPLICATION _ JSON )  )  ;", "restTemplate . getForObject (  \"  / composers /  { id }  \"  ,    Person . class ,     4  2  )  ;", "mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["repeatedAccessToResponseViaResource"], "fileName": "org.springframework.test.web.client.samples.SampleTests"}, {"methodBody": ["METHOD_START", "{", "this . restTemplate    =    new   RestTemplate (  )  ;", "this . mockServer    =    MockRestServiceServer . bindTo ( this . restTemplate )  . ignoreExpectOrder ( true )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.client.samples.SampleTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / number \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  \"  1  \"  ,    TEXT _ PLAIN )  )  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / number \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  \"  2  \"  ,    TEXT _ PLAIN )  )  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / number \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  \"  4  \"  ,    TEXT _ PLAIN )  )  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / number \"  )  )  . andExpect ( MockRestRequestMatchers . method ( GET )  )  . andRespond ( MockRestResponseCreators . withSuccess (  \"  8  \"  ,    TEXT _ PLAIN )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "St   result 1     =    this . restTemplate . getForObject (  \"  / number \"  ,    St . class )  ;", "@ SuppressWarnings (  \" unused \"  )", "St   result 2     =    this . restTemplate . getForObject (  \"  / number \"  ,    St . class )  ;", "try    {", "this . mockServer . verify (  )  ;", "}    catch    ( AssertionError   error )     {", "assertTrue ( error . getMessage (  )  ,    error . getMessage (  )  . contains (  \"  2    unsatisfied   expectation ( s )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["verify"], "fileName": "org.springframework.test.web.client.samples.SampleTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . content (  )  . bytes (  \" foo \"  . getBytes (  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["contentAsBytes"], "fileName": "org.springframework.test.web.client.samples.matchers.ContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . content (  )  . string (  \" foo \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["contentAsString"], "fileName": "org.springframework.test.web.client.samples.matchers.ContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . content (  )  . string ( startsWith (  \" foo \"  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  \" foo 1  2  3  \"  )  ;", "}", "METHOD_END"], "methodName": ["contentStringStartsWith"], "fileName": "org.springframework.test.web.client.samples.matchers.ContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify ( new   Person (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.client.samples.matchers.ContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "try    {", "executeAndVerify (  \" foo \"  )  ;", "}    catch    ( AssertionError   error )     {", "String   message    =    error . getMessage (  )  ;", "assertTrue ( message ,    message . startsWith (  \" Content   type   expected :  < application / json ; charset = UTF -  8  >  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["contentTypeNoMatch"], "fileName": "org.springframework.test.web.client.samples.matchers.ContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . restTemplate . put ( new   URI (  \"  / foo \"  )  ,    body )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["executeAndVerify"], "fileName": "org.springframework.test.web.client.samples.matchers.ContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageConverter <  ?  >  >    convert =    new   ArrayList <  >  (  )  ;", "convertadd ( new   StringHttpMessageConverter (  )  )  ;", "convertadd ( new   MappingJackson 2 HttpMessageConverter (  )  )  ;", "this . restTemplate    =    new   RestTemplate (  )  ;", "this . restTemplate . setMessageConvertconvert ;", "this . mockServer    =    MockRestServiceServer . createServer ( this . restTemplate )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.client.samples.matchers.ContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . restTemplate . getForObject ( new   URI (  \"  / person /  1  \"  )  ,    Person . class )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["executeAndVerify"], "fileName": "org.springframework.test.web.client.samples.matchers.HeaderRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageConverter <  ?  >  >    convert =    new   ArrayList <  >  (  )  ;", "convertadd ( new   StringHttpMessageConverter (  )  )  ;", "convertadd ( new   MappingJackson 2 HttpMessageConverter (  )  )  ;", "this . restTemplate    =    new   RestTemplate (  )  ;", "this . restTemplate . setMessageConvertconvert ;", "this . mockServer    =    MockRestServiceServer . createServer ( this . restTemplate )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.client.samples.matchers.HeaderRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / person /  1  \"  )  )  . andExpect ( MockRestRequestMatchers . header (  \" Accept \"  ,     \" application / json ,    application /  *  + json \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess ( HeaderRequestMatchersIntegrationTests . RESPONSE _ BODY ,    APPLICATION _ JSON )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testString"], "fileName": "org.springframework.test.web.client.samples.matchers.HeaderRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / person /  1  \"  )  )  . andExpect ( MockRestRequestMatchers . header (  \" Accept \"  ,    containsString (  \" json \"  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess ( HeaderRequestMatchersIntegrationTests . RESPONSE _ BODY ,    APPLICATION _ JSON )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testStringContains"], "fileName": "org.springframework.test.web.client.samples.matchers.HeaderRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  ?  (  @  . name    =  =     ' Edvard   Grieeeeeeg '  )  ]  \"  )  . doesNotExist (  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  ?  (  @  . name    =  =     ' Robert   Schuuuuuuman '  )  ]  \"  )  . doesNotExist (  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  4  ]  \"  )  . doesNotExist (  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . restTemplate . put ( new   URI (  \"  / composers \"  )  ,    JsonPathRequestMatchersIntegrationTests . people )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["executeAndVerify"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  0  ]  \"  )  . exists (  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  1  ]  \"  )  . exists (  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  2  ]  \"  )  . exists (  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  3  ]  \"  )  . exists (  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  0  ]  . name \"  )  . value ( equalTo (  \" Johann   Sebastian   Bach \"  )  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . performers [  1  ]  . name \"  )  . value ( equalTo (  \" Yehudi   Menuhin \"  )  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  0  ]  . name \"  ,    startsWith (  \" Johann \"  )  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . performers [  0  ]  . name \"  ,    endsWith (  \" Ashkenazy \"  )  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . performers [  1  ]  . name \"  ,    containsString (  \" di   Me \"  )  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  1  ]  . name \"  ,    isIn ( Arrays . asList (  \" Johann   Sebastian   Bach \"  ,     \" Johannes   Brahms \"  )  )  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  :  3  ]  . name \"  ,    hasItem (  \" Johannes   Brahms \"  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["hamcrestMatchers"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   composerName    =     \"  $  . composers [  % s ]  . name \"  ;", "String   performerName    =     \"  $  . performers [  % s ]  . name \"  ;", "this . mockServer . expect ( MockRest . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRest . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRest . jsonPath ( composerName ,     0  )  . value ( startsWith (  \" Johann \"  )  )  )  . andExpect ( MockRest . jsonPath ( performerName ,     0  )  . value ( endsWith (  \" Ashkenazy \"  )  )  )  . andExpect ( MockRest . jsonPath ( performerName ,     1  )  . value ( containsString (  \" di   Me \"  )  )  )  . andExpect ( MockRest . jsonPath ( composerName ,     1  )  . value ( isIn ( Arrays . asList (  \" Johann   Sebastian   Bach \"  ,     \" Johannes   Brahms \"  )  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["hamcrestMatchersWithParameterizedJsonPaths"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers \"  )  . isArray (  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  0  ]  . someBoolean \"  )  . isBoolean (  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["isBoolean"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  0  ]  . someDouble \"  )  . isNumber (  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["isNumber"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  0  ]  . name \"  )  . isString (  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["isString"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . composers [  0  ]  . name \"  )  . value (  \" Johann   Sebastian   Bach \"  )  )  . andExpect ( MockRestRequestMatchers . jsonPath (  \"  $  . performers [  1  ]  . name \"  )  . value (  \" Yehudi   Menuhin \"  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.client.samples.matchers.JsonPathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . restTemplate . put ( new   URI (  \"  / composers \"  )  ,    this . people )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["executeAndVerify"], "fileName": "org.springframework.test.web.client.samples.matchers.XmlContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < Person >    composers    =    Arrays . asList ( new   Person (  \" Johann   Sebastian   Bach \"  )  . setSomeDouble (  2  1  )  ,    new   Person (  \" Johannes   Brahms \"  )  . setSomeDouble (  0  .  0  0  2  5  )  ,    new   Person (  \" Edvard   Grieg \"  )  . setSomeDouble (  1  .  6  0  3  5  )  ,    new   Person (  \" Robert   Schumann \"  )  . setSomeDouble ( Double . NaN )  )  ;", "this . people    =    new    . PeopleWrapper ( composers )  ;", "List < HttpMessageConverter <  ?  >  >    converters    =    new   ArrayList <  >  (  )  ;", "converters . add ( new   Jaxb 2 RootElementHttpMessageConverter (  )  )  ;", "this . restTemplate    =    new   RestTemplate (  )  ;", "this . restTemplate . setMessageConverters ( converters )  ;", "this . mockServer    =    MockRestServiceServer . createServer ( this . restTemplate )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.client.samples.matchers.XmlContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / xml \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . node ( hasXPath (  \"  / people / composers / composer [  1  ]  \"  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testHamcrestNodeMatcher"], "fileName": "org.springframework.test.web.client.samples.matchers.XmlContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / xml \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . xml ( XmlContentRequestMatchersIntegrationTests . PEOPLE _ XML )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testXmlEqualTo"], "fileName": "org.springframework.test.web.client.samples.matchers.XmlContentRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . restTemplate . put ( new   URI (  \"  / composers \"  )  ,    this . people )  ;", "this . mockServer . verify (  )  ;", "}", "METHOD_END"], "methodName": ["executeAndVerify"], "fileName": "org.springframework.test.web.client.samples.matchers.XpathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < Person >    composers    =    Arrays . asList ( new   Person (  \" Johann   Sebastian   Bach \"  )  . setSomeDouble (  2  1  )  ,    new   Person (  \" Johannes   Brahms \"  )  . setSomeDouble (  0  .  0  0  2  5  )  ,    new   Person (  \" Edvard   Grieg \"  )  . setSomeDouble (  1  .  6  0  3  5  )  ,    new   Person (  \" Robert   Schumann \"  )  . setSomeDouble ( Double . NaN )  )  ;", "List < Person >    performers    =    Arrays . asList ( new   Person (  \" Vladimir   Ashkenazy \"  )  . setSomeBoolean ( false )  ,    new   Person (  \" Yehudi   Menuhin \"  )  . setSomeBoolean ( true )  )  ;", "this . people    =    new    . PeopleWrapper ( composers ,    performers )  ;", "List < HttpMessageConverter <  ?  >  >    converters    =    new   ArrayList <  >  (  )  ;", "converters . add ( new   Jaxb 2 RootElementHttpMessageConverter (  )  )  ;", "this . restTemplate    =    new   RestTemplate (  )  ;", "this . restTemplate . setMessageConverters ( converters )  ;", "this . mockServer    =    MockRestServiceServer . createServer ( this . restTemplate )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.client.samples.matchers.XpathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   performerBooleanValue    =     \"  / ns : people / performers / performer [  % s ]  / someBoolean \"  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / xml \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( performerBooleanValue ,     . NS ,     1  )  . booleanValue ( false )  )  . andExpect ( MockRestRequestMatchers . xpath ( performerBooleanValue ,     . NS ,     2  )  . booleanValue ( true )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testBoolean"], "fileName": "org.springframework.test.web.client.samples.matchers.XpathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   composer    =     \"  / ns : people / composers / composer [  % s ]  \"  ;", "String   performer    =     \"  / ns : people / performers / performer [  % s ]  \"  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / xml \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composer ,     . NS ,     0  )  . doesNotExist (  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composer ,     . NS ,     5  )  . doesNotExist (  )  )  . andExpect ( MockRestRequestMatchers . xpath ( performer ,     . NS ,     0  )  . doesNotExist (  )  )  . andExpect ( MockRestRequestMatchers . xpath ( performer ,     . NS ,     3  )  . doesNotExist (  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotExist"], "fileName": "org.springframework.test.web.client.samples.matchers.XpathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   composer    =     \"  / ns : people / composers / composer [  % s ]  \"  ;", "String   performer    =     \"  / ns : people / performers / performer [  % s ]  \"  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / xml \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composer ,     . NS ,     1  )  . exists (  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composer ,     . NS ,     2  )  . exists (  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composer ,     . NS ,     3  )  . exists (  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composer ,     . NS ,     4  )  . exists (  )  )  . andExpect ( MockRestRequestMatchers . xpath ( performer ,     . NS ,     1  )  . exists (  )  )  . andExpect ( MockRestRequestMatchers . xpath ( performer ,     . NS ,     2  )  . exists (  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.springframework.test.web.client.samples.matchers.XpathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / xml \"  )  )  . andExpect ( MockRestRequestMatchers . xpath (  \"  / ns : people / composers / composer \"  ,    XpathRequestMatchersIntegrationTests . NS )  . nodeCount (  4  )  )  . andExpect ( MockRestRequestMatchers . xpath (  \"  / ns : people / performers / performer \"  ,    XpathRequestMatchersIntegrationTests . NS )  . nodeCount (  2  )  )  . andExpect ( MockRestRequestMatchers . xpath (  \"  / ns : people / composers / composer \"  ,    XpathRequestMatchersIntegrationTests . NS )  . nodeCount ( equalTo (  4  )  )  )  . andExpect ( MockRestRequestMatchers . xpath (  \"  / ns : people / performers / performer \"  ,    XpathRequestMatchersIntegrationTests . NS )  . nodeCount ( equalTo (  2  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testNodeCount"], "fileName": "org.springframework.test.web.client.samples.matchers.XpathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   composerDouble    =     \"  / ns : people / composers / composer [  % s ]  / someDouble \"  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / xml \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerDouble ,     . NS ,     1  )  . number (  2  1  .  0  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerDouble ,     . NS ,     2  )  . number (  0  .  0  0  2  5  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerDouble ,     . NS ,     3  )  . number (  1  .  6  0  3  5  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerDouble ,     . NS ,     4  )  . number ( Double . NaN )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerDouble ,     . NS ,     1  )  . number ( equalTo (  2  1  .  0  )  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerDouble ,     . NS ,     3  )  . number ( closeTo (  1  .  6  ,     0  .  0  1  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testNumber"], "fileName": "org.springframework.test.web.client.samples.matchers.XpathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   composerName    =     \"  / ns : people / composers / composer [  % s ]  / name \"  ;", "String   performerName    =     \"  / ns : people / performers / performer [  % s ]  / name \"  ;", "this . mockServer . expect ( MockRestRequestMatchers . requestTo (  \"  / composers \"  )  )  . andExpect ( MockRestRequestMatchers . content (  )  . contentType (  \" application / xml \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerName ,     . NS ,     1  )  . string (  \" Johann   Sebastian   Bach \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerName ,     . NS ,     2  )  . string (  \" Johannes   Brahms \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerName ,     . NS ,     3  )  . string (  \" Edvard   Grieg \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerName ,     . NS ,     4  )  . string (  \" Robert   Schumann \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( performerName ,     . NS ,     1  )  . string (  \" Vladimir   Ashkenazy \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( performerName ,     . NS ,     2  )  . string (  \" Yehudi   Menuhin \"  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerName ,     . NS ,     1  )  . string ( equalTo (  \" Johann   Sebastian   Bach \"  )  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerName ,     . NS ,     1  )  . string ( startsWith (  \" Johann \"  )  )  )  . andExpect ( MockRestRequestMatchers . xpath ( composerName ,     . NS ,     1  )  . string ( notNullValue (  )  )  )  . andRespond ( MockRestResponseCreators . withSuccess (  )  )  ;", "executeAndVerify (  )  ;", "}", "METHOD_END"], "methodName": ["testString"], "fileName": "org.springframework.test.web.client.samples.matchers.XpathRequestMatchersIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["self"], "fileName": "org.springframework.test.web.reactive.server.AbstractMockServerSpec"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "this . cs . forEach (  (    c )     -  >     {", "String   name    =    c . getClass (  )  . getName (  )  ;", "context . registerBean ( name ,    Object . class ,     (  )     -  >    c )  ;", "}  )  ;", "this . cAdvice . forEach (  (    advice )     -  >     {", "String   name    =    advice . getClass (  )  . getName (  )  ;", "context . registerBean ( name ,    Object . class ,     (  )     -  >    advice )  ;", "}  )  ;", "context . register ( DelegatingWebFluxConfiguration . class )  ;", "context . registerBean ( WebFluxConfigurer . class ,     (  )     -  >    this . configurer )  ;", "context . refresh (  )  ;", "return   context ;", "}", "METHOD_END"], "methodName": ["initApplicationContext"], "fileName": "org.springframework.test.web.reactive.server.DefaultControllerSpec"}, {"methodBody": ["METHOD_START", "{", "List < Object >    instances    =    new   ArrayList <  >  ( specified . length )  ;", "for    ( Object   obj    :    specified )     {", "instances . add (  ( obj   instanceof   Class    ?    BeanUtils . instantiateClass (  (  ( Class <  ?  >  )     ( obj )  )  )     :    obj )  )  ;", "}", "return   instances ;", "}", "METHOD_END"], "methodName": ["instantiateIfNecessary"], "fileName": "org.springframework.test.web.reactive.server.DefaultControllerSpec"}, {"methodBody": ["METHOD_START", "{", "DefaultControllerSpecTests . TestConsumer < ArgumentResolverConfigurer >    argumentResolverConsumer    =    new   DefaultControllerSpecTests . TestConsumer <  >  (  )  ;", "DefaultControllerSpecTests . TestConsumer < RequestedContentTypeResolverBuilder >    contenTypeResolverConsumer    =    new   DefaultControllerSpecTests . TestConsumer <  >  (  )  ;", "DefaultControllerSpecTests . TestConsumer < CorsRegistry >    corsRegistryConsumer    =    new   DefaultControllerSpecTests . TestConsumer <  >  (  )  ;", "DefaultControllerSpecTests . TestConsumer < FormatterRegistry >    formatterConsumer    =    new   DefaultControllerSpecTests . TestConsumer <  >  (  )  ;", "DefaultControllerSpecTests . TestConsumer < ServerCodecConfigurer >    codecsConsumer    =    new   DefaultControllerSpecTests . TestConsumer <  >  (  )  ;", "DefaultControllerSpecTests . TestConsumer < PathMatchConfigurer >    pathMatchingConsumer    =    new   DefaultControllerSpecTests . TestConsumer <  >  (  )  ;", "DefaultControllerSpecTests . TestConsumer < ViewResolverRegistry >    viewResolverConsumer    =    new   DefaultControllerSpecTests . TestConsumer <  >  (  )  ;", "new   DefaultControllerSpec ( new   DefaultControllerSpecTests . MyController (  )  )  . argumentResolvers ( argumentResolverConsumer )  . contentTypeResolver ( contenTypeResolverConsumer )  . corsMappings ( corsRegistryConsumer )  . formatters ( formatterConsumer )  . httpMessageCodecs ( codecsConsumer )  . pathMatching ( pathMatchingConsumer )  . viewResolvers ( viewResolverConsumer )  . build (  )  ;", "assertNotNull ( argumentResolverConsumer . getValue (  )  )  ;", "assertNotNull ( contenTypeResolverConsumer . getValue (  )  )  ;", "assertNotNull ( corsRegistryConsumer . getValue (  )  )  ;", "assertNotNull ( formatterConsumer . getValue (  )  )  ;", "assertNotNull ( codecsConsumer . getValue (  )  )  ;", "assertNotNull ( pathMatchingConsumer . getValue (  )  )  ;", "assertNotNull ( viewResolverConsumer . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["configurerConsumers"], "fileName": "org.springframework.test.web.reactive.server.DefaultControllerSpecTests"}, {"methodBody": ["METHOD_START", "{", "new   DefaultControllerSpec ( new   DefaultControllerSpecTests . MyController (  )  )  . build (  )  . get (  )  . uri (  \"  /  \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( String . class )  . isEqualTo (  \" Success \"  )  ;", "}", "METHOD_END"], "methodName": ["controller"], "fileName": "org.springframework.test.web.reactive.server.DefaultControllerSpecTests"}, {"methodBody": ["METHOD_START", "{", "new   DefaultControllerSpec ( new   DefaultControllerSpecTests . MyController (  )  )  . controllerAdvice ( new   DefaultControllerSpecTests . MyControllerAdvice (  )  )  . build (  )  . get (  )  . uri (  \"  / exception \"  )  . exchange (  )  . expectStatus (  )  . isBadRequest (  )  . expectBody ( String . class )  . isEqualTo (  \" Handled   exception \"  )  ;", "}", "METHOD_END"], "methodName": ["controllerAdvice"], "fileName": "org.springframework.test.web.reactive.server.DefaultControllerSpecTests"}, {"methodBody": ["METHOD_START", "{", "new   DefaultControllerSpec ( DefaultControllerSpecTests . MyController . class )  . controllerAdvice ( DefaultControllerSpecTests . MyControllerAdvice . class )  . build (  )  . get (  )  . uri (  \"  / exception \"  )  . exchange (  )  . expectStatus (  )  . isBadRequest (  )  . expectBody ( String . class )  . isEqualTo (  \" Handled   exception \"  )  ;", "}", "METHOD_END"], "methodName": ["controllerAdviceWithClassArgument"], "fileName": "org.springframework.test.web.reactive.server.DefaultControllerSpecTests"}, {"methodBody": ["METHOD_START", "{", "return   this . timeout ;", "}", "METHOD_END"], "methodName": ["getTimeout"], "fileName": "org.springframework.test.web.reactive.server.DefaultWebTestClient"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultWebTestClient . DefaultRequestBodyUriSpec ( this . webClient . method ( method )  )  ;", "}", "METHOD_END"], "methodName": ["methodInternal"], "fileName": "org.springframework.test.web.reactive.server.DefaultWebTestClient"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["getResponseBody"], "fileName": "org.springframework.test.web.reactive.server.EntityExchangeResult"}, {"methodBody": ["METHOD_START", "{", "try    {", "astion . run (  )  ;", "}    catch    ( AstionError   ex )     {", "throw   new   AstionError (  (  (  ( ex . getMessage (  )  )     +     \"  \\ n \"  )     +     ( this )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["assertWithDiagnostics"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "if    ( body . isSuccess (  )  )     {", "byte [  ]    bytes    =    body . block ( Duration . ZERO )  ;", "if    ( ObjectUtils . isEmpty ( bytes )  )     {", "return    \" No   content \"  ;", "}", "if    ( contentType    =  =    null )     {", "return    (  \" Unknown   content   type    (  \"     +     ( bytes . length )  )     +     \"    bytes )  \"  ;", "}", "Charset   charset    =    contentType . getCharset (  )  ;", "if    ( charset    !  =    null )     {", "return   new   String ( bytes ,    charset )  ;", "}", "if    (  . PRINTABLE _ MEDIA _ TYPES . stream (  )  . anyMatch ( contentType :  : isCompatibleWith )  )     {", "return   new   String ( bytes ,    StandardCharsets . UTF _  8  )  ;", "}", "return    (  \" Unknown   charset    (  \"     +     ( bytes . length )  )     +     \"    bytes )  \"  ;", "} else", "if    ( body . isError (  )  )     {", "return    \" I / O   failure :     \"     +     ( body . getError (  )  )  ;", "} else    {", "return    \" Content   not   available   yet \"  ;", "}", "}", "METHOD_END"], "methodName": ["formatBody"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   headers . entrySet (  )  . stream (  )  . map (  (    entry )     -  >     (  ( entry . getKey (  )  )     +     \"  :     \"  )     +     ( entry . getValue (  )  )  )  . collect ( Collectors . joining ( delimiter )  )  ;", "}", "METHOD_END"], "methodName": ["formatHeaders"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   this . request . getMethod (  )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "MonoProcessor < byte [  ]  >    body    =    this . requestBody ;", "Assert . isTrue ( body . isTerminated (  )  ,     \" Request   body   incomplete .  \"  )  ;", "return   body . block ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["getRequestBodyContent"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   this . request . getHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["getRequestHeaders"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "MonoProcessor < byte [  ]  >    body    =    this . responseBody ;", "Assert . state ( body . isTerminated (  )  ,     \" Response   body   incomplete \"  )  ;", "return   body . block ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["getResponseBodyContent"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   this . response . getCookies (  )  ;", "}", "METHOD_END"], "methodName": ["getResponseCookies"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   this . response . getHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["getResponseHeaders"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   this . response . getStatusCode (  )  ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   getStatus (  )  . getReasonPhrase (  )  ;", "}", "METHOD_END"], "methodName": ["getStatusReason"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   this . uriTemplate ;", "}", "METHOD_END"], "methodName": ["getUriTemplate"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   this . request . getURI (  )  ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.springframework.test.web.reactive.server.ExchangeResult"}, {"methodBody": ["METHOD_START", "{", "assertWithDiagnostics (  (  )     -  >    consumer . accept ( this )  )  ;", "}", "METHOD_END"], "methodName": ["consumeWith"], "fileName": "org.springframework.test.web.reactive.server.FluxExchangeResult"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["getResponseBody"], "fileName": "org.springframework.test.web.reactive.server.FluxExchangeResult"}, {"methodBody": ["METHOD_START", "{", "CacheControl   control    =    CacheControl . maxAge (  1  ,    TimeUnit . HOURS )  . noTransform (  )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setCacheControl ( control . getHeaderValue (  )  )  ;", "s   assertions    =    headerAssertions ( headers )  ;", "assertions . cacheControl ( control )  ;", "try    {", "assertions . cacheControl ( CacheControl . noStore (  )  )  ;", "fail (  \" Wrong   value   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["cacheControl"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( APPLICATION _ XML )  ;", "s   assertions    =    headerAssertions ( headers )  ;", "assertions . contentTypeCompatibleWith ( MediaType . parseMediaType (  \" application /  *  \"  )  )  ;", "try    {", "assertions . contentTypeCompatibleWith ( TEXT _ XML )  ;", "fail (  \" MediaTypes   not   compatible   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "Throwable   cause    =    error . getCause (  )  ;", "assertNotNull ( cause )  ;", "assertEquals (  (  \" Response   header    ' Content - Type '  =  [ application / xml ]     \"     +     \" is   not   compatible   with    [ text / xml ]  \"  )  ,    cause . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["contentTypeCompatibleWith"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( APPLICATION _ JSON _ UTF 8  )  ;", "s   assertions    =    headerAssertions ( headers )  ;", "assertions . doesNotExist (  \" Framework \"  )  ;", "try    {", "assertions . doesNotExist (  \" Content - Type \"  )  ;", "fail (  \" Existing   header   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "Throwable   cause    =    error . getCause (  )  ;", "assertNotNull ( cause )  ;", "assertEquals (  (  \" Response   header    ' Content - Type '    exists   with    \"     +     \" value =  [ application / json ; charset = UTF -  8  ]  \"  )  ,    cause . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( APPLICATION _ JSON _ UTF 8  )  ;", "s   assertions    =    headerAssertions ( headers )  ;", "assertions . exists (  \" Content - Type \"  )  ;", "try    {", "assertions . exists (  \" Framework \"  )  ;", "fail (  \" Header   should   not   exist \"  )  ;", "}    catch    ( AssertionError   error )     {", "Throwable   cause    =    error . getCause (  )  ;", "assertNotNull ( cause )  ;", "assertEquals (  \" Response   header    ' Framework '    does   not   exist \"  ,    cause . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,    URI . create (  \"  /  \"  )  )  ;", "MockClientHttpResponse   response    =    new   MockClientHttpResponse ( HttpStatus . OK )  ;", "response . getHeaders (  )  . putAll ( responseHeaders )  ;", "MonoProcessor < byte [  ]  >    emptyContent    =    MonoProcessor . create (  )  ;", "emptyContent . onComplete (  )  ;", "ExchangeResult   result    =    new   ExchangeResult ( request ,    response ,    emptyContent ,    emptyContent ,    null )  ;", "return   new   s ( result ,    mock ( WebTestClient . ResponseSpec . class )  )  ;", "}", "METHOD_END"], "methodName": ["headerAssertions"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . add (  \" foo \"  ,     \" bar \"  )  ;", "s   assertions    =    headerAssertions ( headers )  ;", "assertions . valueEquals (  \" foo \"  ,     \" bar \"  )  ;", "try    {", "assertions . valueEquals (  \" what ?  !  \"  ,     \" bar \"  )  ;", "fail (  \" Missing   header   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "try    {", "assertions . valueEquals (  \" foo \"  ,     \" what ?  !  \"  )  ;", "fail (  \" Wrong   value   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "try    {", "assertions . valueEquals (  \" foo \"  ,     \" bar \"  ,     \" what ?  !  \"  )  ;", "fail (  \" Wrong    #    of   values   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["valueEquals"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . add (  \" foo \"  ,     \" bar \"  )  ;", "headers . add (  \" foo \"  ,     \" baz \"  )  ;", "s   assertions    =    headerAssertions ( headers )  ;", "assertions . valueEquals (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "try    {", "assertions . valueEquals (  \" foo \"  ,     \" bar \"  ,     \" what ?  !  \"  )  ;", "fail (  \" Wrong   value   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "try    {", "assertions . valueEquals (  \" foo \"  ,     \" bar \"  )  ;", "fail (  \" Too   few   values   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["valueEqualsWithMultipeValues"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( APPLICATION _ JSON _ UTF 8  )  ;", "s   assertions    =    headerAssertions ( headers )  ;", "assertions . valueMatches (  \" Content - Type \"  ,     \"  .  * UTF -  8  .  *  \"  )  ;", "try    {", "assertions . valueMatches (  \" Content - Type \"  ,     \"  .  * ISO -  8  8  5  9  -  1  .  *  \"  )  ;", "fail (  \" Wrong   pattern   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "Throwable   cause    =    error . getCause (  )  ;", "assertNotNull ( cause )  ;", "assertEquals (  (  \" Response   header    ' Content - Type '  =  [ application / json ; charset = UTF -  8  ]     \"     +     \" does   not   match    [  .  * ISO -  8  8  5  9  -  1  .  *  ]  \"  )  ,    cause . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["valueMatches"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    AssertionErrors . assertEquals ( getMessage ( name )  ,    expected ,    actual )  )  ;", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["assertHeader"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertHeader (  \" Cache - Control \"  ,    cacheControl . getHeaderValue (  )  ,    getHeaders (  )  . getCacheControl (  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheControl"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertHeader (  \" Content - Disposition \"  ,    contentDisposition ,    getHeaders (  )  . getContentDisposition (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentDisposition"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertHeader (  \" Content - Length \"  ,    contentLength ,    getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   contentType ( MediaType . parseMediaType ( mediaType )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertHeader (  \" Content - Type \"  ,    mediaType ,    getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   contentTypeCompatibleWith ( MediaType . parseMediaType ( mediaType )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeCompatibleWith"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "MediaType   actual    =    getHeaders (  )  . getContentType (  )  ;", "String   message    =     (  (  (  (  ( getMessage (  \" Content - Type \"  )  )     +     \"  =  [  \"  )     +    actual )     +     \"  ]    is   not   compatible   with    [  \"  )     +    mediaType )     +     \"  ]  \"  ;", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    Errors . assertTrue ( message ,     (  ( actual    !  =    null )     &  &     ( actual . isCompatibleWith ( mediaType )  )  )  )  )  ;", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["contentTypeCompatibleWith"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "if    ( getHeaders (  )  . containsKey ( name )  )     {", "String   message    =     (  (  ( getMessage ( name )  )     +     \"    exists   with   value =  [  \"  )     +     ( getHeaders (  )  . getFirst ( name )  )  )     +     \"  ]  \"  ;", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    Errors . fail ( message )  )  ;", "}", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( getHeaders (  )  . containsKey ( name )  )  )     {", "String   message    =     ( getMessage ( name )  )     +     \"    does   not   exist \"  ;", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    Errors . fail ( message )  )  ;", "}", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertHeader (  \" Expires \"  ,    expires ,    getHeaders (  )  . getExpires (  )  )  ;", "}", "METHOD_END"], "methodName": ["expires"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   this . exchangeResult . getResponseHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Response   header    '  \"     +    headerName )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertHeader (  \" Last - Modified \"  ,    lastModified ,    getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertHeader ( headerName ,    Arrays . asList ( values )  ,    getHeaders (  )  . get ( headerName )  )  ;", "}", "METHOD_END"], "methodName": ["valueEquals"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getHeaders (  )  . getFirst ( name )  ;", "if    ( value    =  =    null )     {", "Errors . fail (  (  ( getMessage ( name )  )     +     \"    not   found \"  )  )  ;", "}", "boolean   match    =    Pattern . compile ( pattern )  . matcher ( value )  . matches (  )  ;", "String   message    =     (  (  (  (  ( getMessage ( name )  )     +     \"  =  [  \"  )     +    value )     +     \"  ]    does   not   match    [  \"  )     +    pattern )     +     \"  ]  \"  ;", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    Errors . assertTrue ( message ,    match )  )  ;", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["valueMatches"], "fileName": "org.springframework.test.web.reactive.server.HeaderAssertions"}, {"methodBody": ["METHOD_START", "{", "HttpMethod   method    =    request . getMethod (  )  ;", "URI   uri    =    request . getURI (  )  ;", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "MultiValueMap < String ,    HttpCookie >    cookies    =    request . getCookies (  )  ;", "return   mock . http . server . reactive . MockServerHttpRequest . method ( method ,    uri )  . headers ( headers )  . cookies ( cookies )  . body ( body )  ;", "}", "METHOD_END"], "methodName": ["adaptRequest"], "fileName": "org.springframework.test.web.reactive.server.HttpHandlerConnector"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   status    =    Optional . ofNullable ( response . getStatusCode (  )  )  . orElse ( OK )  ;", "MockClientHttpResponse   clientResponse    =    new   MockClientHttpResponse ( status )  ;", "clientResponse . getHeaders (  )  . putAll ( response . getHeaders (  )  )  ;", "clientResponse . getCookies (  )  . putAll ( response . getCookies (  )  )  ;", "clientResponse . setBody ( body )  ;", "return   clientResponse ;", "}", "METHOD_END"], "methodName": ["adaptResponse"], "fileName": "org.springframework.test.web.reactive.server.HttpHandlerConnector"}, {"methodBody": ["METHOD_START", "{", "if    ( HttpHandlerConnector . logger . isDebugEnabled (  )  )     {", "HttpHandlerConnector . logger . debug ( String . format (  \"  % s    % s    \\  \"  % s \\  \"  \"  ,    message ,    httpMethod ,    uri )  )  ;", "}", "}", "METHOD_END"], "methodName": ["log"], "fileName": "org.springframework.test.web.reactive.server.HttpHandlerConnector"}, {"methodBody": ["METHOD_START", "{", "return    ( request . getMethod (  )  )     =  =     ( HttpMethod . HEAD )     ?    new   HttpHeadResponseDecorator ( response )     :    response ;", "}", "METHOD_END"], "methodName": ["prepareResponse"], "fileName": "org.springframework.test.web.reactive.server.HttpHandlerConnector"}, {"methodBody": ["METHOD_START", "{", "HttpHandlerConnectorTests . TestHttpHandler   handler    =    new   HttpHandlerConnectorTests . TestHttpHandler (  (    response )     -  >     {", "response . setStatusCode ( OK )  ;", "return   response . setComplete (  )  ;", "}  )  ;", "new   HttpHandlerConnector ( handler )  . connect ( POST ,    URI . create (  \"  / custom - path \"  )  ,     (    request )     -  >     {", "request . getHeaders (  )  . put (  \" custom - header \"  ,    Arrays . asList (  \" h 0  \"  ,     \" h 1  \"  )  )  ;", "request . getCookies (  )  . add (  \" custom - cookie \"  ,    new   HttpCookie (  \" custom - cookie \"  ,     \" c 0  \"  )  )  ;", "return   request . writeWith ( Mono . just ( toDataBuffer (  \" Custom   body \"  )  )  )  ;", "}  )  . block ( Duration . ofSeconds (  5  )  )  ;", "MockServerHttpRequest   request    =     (  ( MockServerHttpRequest )     ( handler . getSavedRequest (  )  )  )  ;", "Assert . assertEquals ( POST ,    request . getMethod (  )  )  ;", "Assert . assertEquals (  \"  / custom - path \"  ,    request . getURI (  )  . toString (  )  )  ;", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "Assert . assertEquals ( Arrays . asList (  \" h 0  \"  ,     \" h 1  \"  )  ,    headers . get (  \" custom - header \"  )  )  ;", "Assert . assertEquals ( new   HttpCookie (  \" custom - cookie \"  ,     \" c 0  \"  )  ,    request . getCookies (  )  . getFirst (  \" custom - cookie \"  )  )  ;", "Assert . assertEquals ( Collections . singletonList (  \" custom - cookie = c 0  \"  )  ,    headers . get ( COOKIE )  )  ;", "DataBuffer   buffer    =    request . getBody (  )  . blockFirst ( Duration . ZERO )  ;", "Assert . assertEquals (  \" Custom   body \"  ,    DataBufferTestUtils . dumpString ( buffer ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["adaptRequest"], "fileName": "org.springframework.test.web.reactive.server.HttpHandlerConnectorTests"}, {"methodBody": ["METHOD_START", "{", "ResponseCookie   cookie    =    ResponseCookie . from (  \" custom - cookie \"  ,     \" c 0  \"  )  . build (  )  ;", ". TestHttpHandler   handler    =    new    . TestHttpHandler (  (    response )     -  >     {", "response . setStatusCode ( OK )  ;", "response . getHeaders (  )  . put (  \" custom - header \"  ,    Arrays . asList (  \" h 0  \"  ,     \" h 1  \"  )  )  ;", "response . addCookie ( cookie )  ;", "return   response . writeWith ( Mono . just ( toDataBuffer (  \" Custom   body \"  )  )  )  ;", "}  )  ;", "ClientHttpResponse   response    =    new   HttpHandlerConnector ( handler )  . connect ( GET ,    URI . create (  \"  / custom - path \"  )  ,    ReactiveHttpOutputMessage :  : setComplete )  . block ( Duration . ofSeconds (  5  )  )  ;", "Assert . assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "HttpHeaders   headers    =    response . getHeaders (  )  ;", "Assert . assertEquals ( Arrays . asList (  \" h 0  \"  ,     \" h 1  \"  )  ,    headers . get (  \" custom - header \"  )  )  ;", "Assert . assertEquals ( cookie ,    response . getCookies (  )  . getFirst (  \" custom - cookie \"  )  )  ;", "Assert . assertEquals ( Collections . singletonList (  \" custom - cookie = c 0  \"  )  ,    headers . get ( SET _ COOKIE )  )  ;", "DataBuffer   buffer    =    response . getBody (  )  . blockFirst ( Duration . ZERO )  ;", "Assert . assertEquals (  \" Custom   body \"  ,    DataBufferTestUtils . dumpString ( buffer ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["adaptResponse"], "fileName": "org.springframework.test.web.reactive.server.HttpHandlerConnectorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDataBufferFactory (  )  . wrap ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["toDataBuffer"], "fileName": "org.springframework.test.web.reactive.server.HttpHandlerConnectorTests"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . doesNotExist ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . doesNotHaveJsonPath ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["doesNotHaveJsonPath"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . exists ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . hasJsonPath ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["hasJsonPath"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . assertValueIsArray ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . assertValueIsBoolean ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["isBoolean"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . assertValueIsEmpty ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . assertValue ( this . content ,    expectedValue )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["isEqualTo"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . assertValueIsMap ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["isMap"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . assertValueIsNotEmpty ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["isNotEmpty"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . pathHelper . assertValueIsNumber ( this . content )  ;", "return   this . bodySpec ;", "}", "METHOD_END"], "methodName": ["isNumber"], "fileName": "org.springframework.test.web.reactive.server.JsonPathAssertions"}, {"methodBody": ["METHOD_START", "{", "this . serverSpec . webFilter ( new   MockServerSpecTests . TestWebFilter (  \" A \"  )  )  ;", "this . serverSpec . apply ( new   MockServerConfigurer (  )     {", "@ Override", "public   void   afterConfigureAdded ( WebTestClient . MockServerSpec <  ?  >    spec )     {", "spec . webFilter ( new   MockServerSpecTests . TestWebFilter (  \" B \"  )  )  ;", "}", "}  )  ;", "this . serverSpec . build (  )  . get (  )  . uri (  \"  /  \"  )  . exchange (  )  . expectBody ( String . class )  . isEqualTo (  \"  { test - attribute =  : A : B }  \"  )  ;", "}", "METHOD_END"], "methodName": ["applyFiltersAfterConfigurerAdded"], "fileName": "org.springframework.test.web.reactive.server.MockServerSpecTests"}, {"methodBody": ["METHOD_START", "{", "this . serverSpec . webFilter ( new   MockServerSpecTests . TestWebFilter (  \" App - A \"  )  )  ;", "this . serverSpec . webFilter ( new   MockServerSpecTests . TestWebFilter (  \" App - B \"  )  )  ;", "this . serverSpec . apply ( new   MockServerConfigurer (  )     {", "@ Override", "public   void   beforeServerCreated ( WebHttpHandlerBuilder   builder )     {", "builder . filters (  (    filters )     -  >     {", "filters . add (  0  ,    new   TestWebFilter (  \" Fwk - A \"  )  )  ;", "filters . add (  1  ,    new   TestWebFilter (  \" Fwk - B \"  )  )  ;", "}  )  ;", "}", "}  )  ;", "this . serverSpec . build (  )  . get (  )  . uri (  \"  /  \"  )  . exchange (  )  . expectBody ( String . class )  . isEqualTo (  \"  { test - attribute =  : Fwk - A : Fwk - B : App - A : App - B }  \"  )  ;", "}", "METHOD_END"], "methodName": ["applyFiltersBeforeServerCreated"], "fileName": "org.springframework.test.web.reactive.server.MockServerSpecTests"}, {"methodBody": ["METHOD_START", "{", "ExchangeResult   result    =    WebTestClient . bindToWebHandler (  (    exchange )     -  >     {", "HttpResponse   response    =    exchange . getResponse (  )  ;", "if    ( exchange . getRequest (  )  . getURI (  )  . getPath (  )  . equals (  \"  / cookie \"  )  )     {", "response . addCookie ( ResponseCookie . from (  \" a \"  ,     \" alpha \"  )  . path (  \"  / pathA \"  )  . build (  )  )  ;", "response . addCookie ( ResponseCookie . from (  \" b \"  ,     \" beta \"  )  . path (  \"  / pathB \"  )  . build (  )  )  ;", "} else    {", "response . setStatusCode ( HttpStatus . NOT _ FOUND )  ;", "}", "return   response . setComplete (  )  ;", "}  )  . build (  )  . get (  )  . uri (  \"  / cookie \"  )  . cookie (  \" a \"  ,     \" alpha \"  )  . cookie (  \" b \"  ,     \" beta \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectHeader (  )  . valueEquals ( SET _ COOKIE ,     \" a = alpha ;    Path =  / pathA \"  ,     \" b = beta ;    Path =  / pathB \"  )  . expectBody (  )  . isEmpty (  )  ;", "Assert . assertEquals ( Arrays . asList (  \" a = alpha \"  ,     \" b = beta \"  )  ,    result . getRequestHeaders (  )  . get ( COOKIE )  )  ;", "}", "METHOD_END"], "methodName": ["exchangeResultHasCookieHeaders"], "fileName": "org.springframework.test.web.reactive.server.MockServerTests"}, {"methodBody": ["METHOD_START", "{", "WebTestClient . Builder   builder    =    WebTestClient . bindToWebHandler (  (    exchange )     -  >    exchange . getResponse (  )  . setComplete (  )  )  . configureClient (  )  ;", "builder . filter (  (    request ,    next )     -  >    next . exchange ( request )  )  ;", "builder . defaultHeader (  \" foo \"  ,     \" bar \"  )  ;", "builder . defaultCookie (  \" foo \"  ,     \" bar \"  )  ;", "WebTestClient   client 1     =    builder . build (  )  ;", "builder . filter (  (    request ,    next )     -  >    next . exchange ( request )  )  ;", "builder . defaultHeader (  \" baz \"  ,     \" qux \"  )  ;", "builder . defaultCookie (  \" baz \"  ,     \" qux \"  )  ;", "WebTestClient   client 2     =    builder . build (  )  ;", "WebTestClient . Builder   mutatedBuilder    =    client 1  . mutate (  )  ;", "mutatedBuilder . filter (  (    request ,    next )     -  >    next . exchange ( request )  )  ;", "mutatedBuilder . defaultHeader (  \" baz \"  ,     \" qux \"  )  ;", "mutatedBuilder . defaultCookie (  \" baz \"  ,     \" qux \"  )  ;", "WebTestClient   clientFromMutatedBuilder    =    mutatedBuilder . build (  )  ;", "client 1  . mutate (  )  . filters (  (    filters )     -  >    Assert . assertEquals (  1  ,    filters . size (  )  )  )  ;", "client 1  . mutate (  )  . defaultHeaders (  (    headers )     -  >    Assert . assertEquals (  1  ,    headers . size (  )  )  )  ;", "client 1  . mutate (  )  . defaultCookies (  (    cookies )     -  >    Assert . assertEquals (  1  ,    cookies . size (  )  )  )  ;", "client 2  . mutate (  )  . filters (  (    filters )     -  >    Assert . assertEquals (  2  ,    filters . size (  )  )  )  ;", "client 2  . mutate (  )  . defaultHeaders (  (    headers )     -  >    Assert . assertEquals (  2  ,    headers . size (  )  )  )  ;", "client 2  . mutate (  )  . defaultCookies (  (    cookies )     -  >    Assert . assertEquals (  2  ,    cookies . size (  )  )  )  ;", "clientFromMutatedBuilder . mutate (  )  . filters (  (    filters )     -  >    Assert . assertEquals (  2  ,    filters . size (  )  )  )  ;", "clientFromMutatedBuilder . mutate (  )  . defaultHeaders (  (    headers )     -  >    Assert . assertEquals (  2  ,    headers . size (  )  )  )  ;", "clientFromMutatedBuilder . mutate (  )  . defaultCookies (  (    cookies )     -  >    Assert . assertEquals (  2  ,    cookies . size (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mutateDoesCopy"], "fileName": "org.springframework.test.web.reactive.server.MockServerTests"}, {"methodBody": ["METHOD_START", "{", "WebTestClient   client    =    WebTestClient . bindToWebHandler (  (    exchange )     -  >     {", "if    ( exchange . getRequest (  )  . getURI (  )  . getPath (  )  . equals (  \"  / set \"  )  )     {", "return   exchange . getSession (  )  . doOnNext (  (    session )     -  >    session . getAttributes (  )  . put (  \" foo \"  ,     \" bar \"  )  )  . then (  )  ;", "} else    {", "return   exchange . getSession (  )  . map (  (    session )     -  >    session . getAttributeOrDefault (  \" foo \"  ,     \" none \"  )  )  . flatMap (  (    value )     -  >     {", "byte [  ]    bytes    =    value . getBytes ( StandardCharsets . UTF _  8  )  ;", "DataBuffer   buffer    =    new   DefaultDataBufferFactory (  )  . wrap ( bytes )  ;", "return   exchange . getResponse (  )  . writeWith ( Mono . just ( buffer )  )  ;", "}  )  ;", "}", "}  )  . build (  )  ;", "EntityExchangeResult < Void >    result    =    client . get (  )  . uri (  \"  / set \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody (  )  . isEmpty (  )  ;", "ResponseCookie   session    =    result . getResponseCookies (  )  . getFirst (  \" SESSION \"  )  ;", "client . mutate (  )  . build (  )  . get (  )  . uri (  \"  / get \"  )  . cookie ( session . getName (  )  ,    session . getValue (  )  )  . exchange (  )  . expectBody ( String . class )  . isEqualTo (  \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["mutateDoesNotCreateNewSession"], "fileName": "org.springframework.test.web.reactive.server.MockServerTests"}, {"methodBody": ["METHOD_START", "{", "StatusAssertions   assertions    =    statusAssertions ( CONFLICT )  ;", "assertions . isEqualTo ( CONFLICT )  ;", "assertions . isEqualTo (  4  0  9  )  ;", "try    {", "assertions . isEqualTo ( REQUEST _ TIMEOUT )  ;", "fail (  \" Wrong   status   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "try    {", "assertions . isEqualTo (  4  0  8  )  ;", "fail (  \" Wrong   status   value   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["isEqualTo"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "StatusAssertions   assertions    =    statusAssertions ( CONFLICT )  ;", "assertions . reasonEquals (  \" Conflict \"  )  ;", "try    {", "assertions . reasonEquals (  \" Request   Timeout \"  )  ;", "fail (  \" Wrong   reason   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["reasonEquals"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,    URI . create (  \"  /  \"  )  )  ;", "MockClientHttpResponse   response    =    new   MockClientHttpResponse ( status )  ;", "MonoProcessor < byte [  ]  >    emptyContent    =    MonoProcessor . create (  )  ;", "emptyContent . onComplete (  )  ;", "ExchangeResult   result    =    new   ExchangeResult ( request ,    response ,    emptyContent ,    emptyContent ,    null )  ;", "return   new   s ( result ,    mock ( WebTestClient . ResponseSpec . class )  )  ;", "}", "METHOD_END"], "methodName": ["statusAssertions"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "StatusAssertions   assertions    =    statusAssertions ( CONTINUE )  ;", "assertions . is 1 xxInformational (  )  ;", "try    {", "assertions . is 2 xxSuccessful (  )  ;", "fail (  \" Wrong   series   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["statusSerius1xx"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "StatusAssertions   assertions    =    statusAssertions ( OK )  ;", "assertions . is 2 xxSuccessful (  )  ;", "try    {", "assertions . is 5 xxServerError (  )  ;", "fail (  \" Wrong   series   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["statusSerius2xx"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "StatusAssertions   assertions    =    statusAssertions ( PERMANENT _ REDIRECT )  ;", "assertions . is 3 xxRedirection (  )  ;", "try    {", "assertions . is 2 xxSuccessful (  )  ;", "fail (  \" Wrong   series   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["statusSerius3xx"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "StatusAssertions   assertions    =    statusAssertions ( BAD _ REQUEST )  ;", "assertions . is 4 xxClientError (  )  ;", "try    {", "assertions . is 2 xxSuccessful (  )  ;", "fail (  \" Wrong   series   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["statusSerius4xx"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "StatusAssertions   assertions    =    statusAssertions ( INTERNAL _ SERVER _ ERROR )  ;", "assertions . is 5 xxServerError (  )  ;", "try    {", "assertions . is 2 xxSuccessful (  )  ;", "fail (  \" Wrong   series   expected \"  )  ;", "}    catch    ( AssertionError   error )     {", "}", "}", "METHOD_END"], "methodName": ["statusSerius5xx"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   status    =    this . exchangeResult . getStatus (  )  ;", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    Errors . assertEquals (  (  \" Range   for   response   status   value    \"     +    status )  ,    expected ,    status . series (  )  )  )  ;", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["assertSeriesAndReturn"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   actual    =    this . exchangeResult . getStatus (  )  ;", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    Errors . assertEquals (  \" Status \"  ,    expected ,    actual )  )  ;", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["assertStatusAndReturn"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertSeriesAndReturn ( INFORMATIONAL )  ;", "}", "METHOD_END"], "methodName": ["is1xxInformational"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertSeriesAndReturn ( SUCCESSFUL )  ;", "}", "METHOD_END"], "methodName": ["is2xxSuccessful"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertSeriesAndReturn ( REDIRECTION )  ;", "}", "METHOD_END"], "methodName": ["is3xxRedirection"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertSeriesAndReturn ( CLIENT _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["is4xxClientError"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "HttpStatus . Series   expected    =    Series . SERVER _ ERROR ;", "return   assertSeriesAndReturn ( expected )  ;", "}", "METHOD_END"], "methodName": ["is5xxServerError"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( ACCEPTED )  ;", "}", "METHOD_END"], "methodName": ["isAccepted"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( BAD _ REQUEST )  ;", "}", "METHOD_END"], "methodName": ["isBadRequest"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   expected    =    HttpStatus . CREATED ;", "return   assertndReturn ( expected )  ;", "}", "METHOD_END"], "methodName": ["isCreated"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "int   actual    =    this . exchangeResult . getStatus (  )  . value (  )  ;", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    Errors . assertEquals (  \" Status \"  ,    status ,    actual )  )  ;", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["isEqualTo"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   isEqualTo ( status . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEqualTo"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( FORBIDDEN )  ;", "}", "METHOD_END"], "methodName": ["isForbidden"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( FOUND )  ;", "}", "METHOD_END"], "methodName": ["isFound"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( NO _ CONTENT )  ;", "}", "METHOD_END"], "methodName": ["isNoContent"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( NOT _ FOUND )  ;", "}", "METHOD_END"], "methodName": ["isNotFound"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( NOT _ MODIFIED )  ;", "}", "METHOD_END"], "methodName": ["isNotModified"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( OK )  ;", "}", "METHOD_END"], "methodName": ["isOk"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( PERMANENT _ REDIRECT )  ;", "}", "METHOD_END"], "methodName": ["isPermanentRedirect"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( SEE _ OTHER )  ;", "}", "METHOD_END"], "methodName": ["isSeeOther"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( TEMPORARY _ REDIRECT )  ;", "}", "METHOD_END"], "methodName": ["isTemporaryRedirect"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   assertStatusAndReturn ( UNAUTHORIZED )  ;", "}", "METHOD_END"], "methodName": ["isUnauthorized"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "String   actual    =    this . exchangeResult . getStatus (  )  . getReasonPhrase (  )  ;", "String   message    =     \" Response   status   reason \"  ;", "this . exchangeResult . assertWithDiagnostics (  (  )     -  >    Errors . assertEquals ( message ,    reason ,    actual )  )  ;", "return   this . responseSpec ;", "}", "METHOD_END"], "methodName": ["reasonEquals"], "fileName": "org.springframework.test.web.reactive.server.StatusAssertions"}, {"methodBody": ["METHOD_START", "{", "return   new   ApplicationContextSpec ( applicationContext )  ;", "}", "METHOD_END"], "methodName": ["bindToApplicationContext"], "fileName": "org.springframework.test.web.reactive.server.WebTestClient"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultControllerSpec ( controllers )  ;", "}", "METHOD_END"], "methodName": ["bindToController"], "fileName": "org.springframework.test.web.reactive.server.WebTestClient"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultRouterFunctionSpec ( routerFunction )  ;", "}", "METHOD_END"], "methodName": ["bindToRouterFunction"], "fileName": "org.springframework.test.web.reactive.server.WebTestClient"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultWebTestClientBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["bindToServer"], "fileName": "org.springframework.test.web.reactive.server.WebTestClient"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultWebTestClientBuilder ( connector )  ;", "}", "METHOD_END"], "methodName": ["bindToServer"], "fileName": "org.springframework.test.web.reactive.server.WebTestClient"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultMockServerSpec ( webHandler )  ;", "}", "METHOD_END"], "methodName": ["bindToWebHandler"], "fileName": "org.springframework.test.web.reactive.server.WebTestClient"}, {"methodBody": ["METHOD_START", "{", "ClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,     \"  / test \"  )  ;", "ClientHttpResponse   response    =    new   MockClientHttpResponse ( HttpStatus . OK )  ;", "ClientHttpConnector   connector    =     (    method ,    uri ,    fn )     -  >    fn . apply ( request )  . then ( Mono . just ( response )  )  ;", "ClientRequest   clientRequest    =    ClientRequest . create ( GET ,    URI . create (  \"  / test \"  )  )  . header (  . WEBTESTCLIENT _ REQUEST _ ID ,     \"  1  \"  )  . build (  )  ;", "WiretapConnector   wiretapConnector    =    new   WiretapConnector ( connector )  ;", "ExchangeFunction   function    =    ExchangeFunctions . create ( wiretapConnector )  ;", "function . exchange ( clientRequest )  . block ( Duration . ofMillis (  0  )  )  ;", "WiretapConnector . Info   actual    =    wiretapConnector . claimRequest (  \"  1  \"  )  ;", "ExchangeResult   result    =    actual . createExchangeResult ( null )  ;", "assertEquals ( GET ,    result . getMethod (  )  )  ;", "assertEquals (  \"  / test \"  ,    result . getUrl (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["captureAndClaim"], "fileName": "org.springframework.test.web.reactive.server.WebTestClientConnectorTests"}, {"methodBody": ["METHOD_START", "{", "WiretapConnector . Info   info    =    this . exchanges . remove ( requestId )  ;", "Assert . state (  ( info    !  =    null )  ,     (  )     -  >     {", "String   header    =    WebTestClient . WEBTESTCLIENT _ REQUEST _ ID ;", "return    (  (  \" No   match   for    \"     +    header )     +     \"  =  \"  )     +    requestId ;", "}  )  ;", "return   info ;", "}", "METHOD_END"], "methodName": ["claimRequest"], "fileName": "org.springframework.test.web.reactive.server.WiretapConnector"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / invalid \"  )  . exchange (  )  . expectStatus (  )  . isNotFound (  )  . expectBody ( Void . class )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.test.web.reactive.server.samples.ErrorTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / server - error \"  )  . exchange (  )  . expectStatus (  )  . isEqualTo ( INTERNAL _ SERVER _ ERROR )  . expectBody ( Void . class )  ;", "}", "METHOD_END"], "methodName": ["serverException"], "fileName": "org.springframework.test.web.reactive.server.samples.ErrorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ExchangeMutatorTests . IdentityConfigurer ( userName )  ;", "}", "METHOD_END"], "methodName": ["identity"], "fileName": "org.springframework.test.web.reactive.server.samples.ExchangeMutatorTests"}, {"methodBody": ["METHOD_START", "{", "this . webTestClient    =    WebTestClient . bindToController ( new   ExchangeMutatorTests . TestController (  )  )  . apply ( ExchangeMutatorTests . identity (  \" Pablo \"  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.reactive.server.samples.ExchangeMutatorTests"}, {"methodBody": ["METHOD_START", "{", "this . webTestClient . get (  )  . uri (  \"  / userIdentity \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( String . class )  . isEqualTo (  \" Hello   Pablo !  \"  )  ;", "}", "METHOD_END"], "methodName": ["useGloballyConfiguredIdentity"], "fileName": "org.springframework.test.web.reactive.server.samples.ExchangeMutatorTests"}, {"methodBody": ["METHOD_START", "{", "this . webTestClient . mutateWith ( ExchangeMutatorTests . identity (  \" Giovanni \"  )  )  . get (  )  . uri (  \"  / userIdentity \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( String . class )  . isEqualTo (  \" Hello   Giovanni !  \"  )  ;", "}", "METHOD_END"], "methodName": ["useLocallyConfiguredIdentity"], "fileName": "org.springframework.test.web.reactive.server.samples.ExchangeMutatorTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \" header - multi - value \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectHeader (  )  . valueEquals (  \" h 1  \"  ,     \" v 1  \"  ,     \" v 2  \"  ,     \" v 3  \"  )  ;", "}", "METHOD_END"], "methodName": ["headerMultipleValues"], "fileName": "org.springframework.test.web.reactive.server.samples.HeaderAndCookieTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / header - echo \"  )  . header (  \" h 1  \"  ,     \" in \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectHeader (  )  . valueEquals (  \" h 1  \"  ,     \" in - out \"  )  ;", "}", "METHOD_END"], "methodName": ["requestResponseHeaderPair"], "fileName": "org.springframework.test.web.reactive.server.samples.HeaderAndCookieTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / cookie - echo \"  )  . cookies (  (    cookies )     -  >    cookies . add (  \" k 1  \"  ,     \" v 1  \"  )  )  . exchange (  )  . expectHeader (  )  . valueMatches (  \" Set - Cookie \"  ,     \" k 1  = v 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["setCookies"], "fileName": "org.springframework.test.web.reactive.server.samples.HeaderAndCookieTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / persons \"  )  . accept ( APPLICATION _ JSON _ UTF 8  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody (  )  . json (  \"  [  {  \\  \" name \\  \"  :  \\  \" Jane \\  \"  }  ,  {  \\  \" name \\  \"  :  \\  \" Jason \\  \"  }  ,  {  \\  \" name \\  \"  :  \\  \" John \\  \"  }  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["jsonContent"], "fileName": "org.springframework.test.web.reactive.server.samples.JsonContentTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / persons / John \"  )  . accept ( APPLICATION _ JSON _ UTF 8  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody (  )  . jsonPath (  \"  $  [  ?  (  @  . name    =  ~     /  .  * oh .  *  /  )  ]  . name \"  )  . hasJsonPath (  )  ;", "}", "METHOD_END"], "methodName": ["jsonPathContainsSubstringViaRegex"], "fileName": "org.springframework.test.web.reactive.server.samples.JsonContentTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / persons \"  )  . accept ( APPLICATION _ JSON _ UTF 8  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody (  )  . jsonPath (  \"  $  [  0  ]  . name \"  )  . isEqualTo (  \" Jane \"  )  . jsonPath (  \"  $  [  1  ]  . name \"  )  . isEqualTo (  \" Jason \"  )  . jsonPath (  \"  $  [  2  ]  . name \"  )  . isEqualTo (  \" John \"  )  ;", "}", "METHOD_END"], "methodName": ["jsonPathIsEqualTo"], "fileName": "org.springframework.test.web.reactive.server.samples.JsonContentTests"}, {"methodBody": ["METHOD_START", "{", "this . client . post (  )  . uri (  \"  / persons \"  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  . syncBody (  \"  {  \\  \" name \\  \"  :  \\  \" John \\  \"  }  \"  )  . exchange (  )  . expectStatus (  )  . isCreated (  )  . expectBody (  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["postJsonContent"], "fileName": "org.springframework.test.web.reactive.server.samples.JsonContentTests"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.test.web.reactive.server.samples.Person"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / John \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectHeader (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  . expectBody ( Person . class )  . isEqualTo ( new   Person (  \" John \"  )  )  ;", "}", "METHOD_END"], "methodName": ["entity"], "fileName": "org.springframework.test.web.reactive.server.samples.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "List < Person >    expected    =    Arrays . asList ( new   Person (  \" Jane \"  )  ,    new   Person (  \" Jason \"  )  ,    new   Person (  \" John \"  )  )  ;", "this . client . get (  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectHeader (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  . expectBodyList ( Person . class )  . isEqualTo ( expected )  ;", "}", "METHOD_END"], "methodName": ["entityList"], "fileName": "org.springframework.test.web.reactive.server.samples.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Person >    map    =    new   LinkedHashMap <  >  (  )  ;", "map . put (  \" Jane \"  ,    new   Person (  \" Jane \"  )  )  ;", "map . put (  \" Jason \"  ,    new   Person (  \" Jason \"  )  )  ;", "map . put (  \" John \"  ,    new   Person (  \" John \"  )  )  ;", "this . client . get (  )  . uri (  \"  ? map = true \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( new   core . ParameterizedTypeReference < Map < String ,    Person >  >  (  )     {  }  )  . isEqualTo ( map )  ;", "}", "METHOD_END"], "methodName": ["entityMap"], "fileName": "org.springframework.test.web.reactive.server.samples.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "FluxExchangeResult < Person >    result    =    this . client . get (  )  . accept ( MediaType . TEXT _ EVENT _ STREAM )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectHeader (  )  . contentTypeCompatibleWith ( MediaType . TEXT _ EVENT _ STREAM )  . returnResult ( Person . class )  ;", "StepVerifier . create ( result . getBody (  )  )  . expectNext ( new   Person (  \" N 0  \"  )  ,    new   Person (  \" N 1  \"  )  ,    new   Person (  \" N 2  \"  )  )  . expectNextCount (  4  )  . consumeNextWith (  (    person )     -  >    assertThat ( person . getName (  )  ,    endsWith (  \"  7  \"  )  )  )  . thenCancel (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["entityStream"], "fileName": "org.springframework.test.web.reactive.server.samples.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / John \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectHeader (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  . expectBody ( Person . class )  . consumeWith (  (    result )     -  >    assertEquals ( new   Person (  \" John \"  )  ,    result . getResponseBody (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["entityWithConsumer"], "fileName": "org.springframework.test.web.reactive.server.samples.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "this . client . post (  )  . syncBody ( new   Person (  \" John \"  )  )  . exchange (  )  . expectStatus (  )  . isCreated (  )  . expectHeader (  )  . valueEquals (  \" location \"  ,     \"  / persons / John \"  )  . expectBody (  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["postEntity"], "fileName": "org.springframework.test.web.reactive.server.samples.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . WebConfig . class )  ;", "context . refresh (  )  ;", "this . client    =    WebTestClient . bindToApplicationContext ( context )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.ApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / test \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( String . class )  . isEqualTo (  \" It   works !  \"  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.ApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "this . client    =    WebTestClient . bindToController ( new   ControllerTests . TestController (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.ControllerTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / test \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( String . class )  . isEqualTo (  \" It   works !  \"  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.ControllerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHandler   httpHandler    =    RouterFunctions . toHttpHandler ( RouterFunctions . route ( RequestPredicates . GET (  \"  / test \"  )  ,     (    request )     -  >    ServerResponse . ok (  )  . syncBody (  \" It   works !  \"  )  )  )  ;", "this . server    =    new   Reactor (  )  ;", "this . server . setHandler ( httpHandler )  ;", "this . server . afterPropertiesSet (  )  ;", "this . server . start (  )  ;", "this . client    =    WebTestClient . bindToServer (  )  . baseUrl (  (  \" http :  /  / localhost :  \"     +     ( this . server . getPort (  )  )  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.HttpServerTests"}, {"methodBody": ["METHOD_START", "{", "this . server . stop (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.HttpServerTests"}, {"methodBody": ["METHOD_START", "{", "this . client . get (  )  . uri (  \"  / test \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( String . class )  . isEqualTo (  \" It   works !  \"  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.HttpServerTests"}, {"methodBody": ["METHOD_START", "{", "RouterFunction <  ?  >    route    =    RouterFunctions . route ( RequestPredicates . GET (  \"  / test \"  )  ,     (    request )     -  >    ServerResponse . ok (  )  . syncBody (  \" It   works !  \"  )  )  ;", "this . testClient    =    WebTestClient . bindToRouterFunction ( route )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.RouterFunctionTests"}, {"methodBody": ["METHOD_START", "{", "this . testClient . get (  )  . uri (  \"  / test \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( String . class )  . isEqualTo (  \" It   works !  \"  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.RouterFunctionTests"}, {"methodBody": ["METHOD_START", "{", "WebFilter   filter    =     (    exchange ,    chain )     -  >     {", "DataBuffer   buffer    =    new   DefaultDataBufferFactory (  )  . allocateBuffer (  )  ;", "buffer . write (  \" It   works !  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "return   exchange . getResponse (  )  . writeWith ( Mono . just ( buffer )  )  ;", "}  ;", "WebTestClient   client    =    WebTestClient . bindToWebHandler (  (    exchange )     -  >    Mono . empty (  )  )  . webFilter ( filter )  . build (  )  ;", "client . get (  )  . uri (  \"  /  \"  )  . exchange (  )  . expectStatus (  )  . isOk (  )  . expectBody ( String . class )  . isEqualTo (  \" It   works !  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWebFilter"], "fileName": "org.springframework.test.web.reactive.server.samples.bind.WebFilterTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . asyncDispatchLatch )     !  =    null )  ,     \" The   asyncDispatch   CountDownLatch   was   not   set   by   the   TestDispatcherServlet .  \\ n \"  )  ;", "try    {", "return   this . asyncDispatchLatch . await ( timeout ,    TimeUnit . MILLISECONDS )  ;", "}    catch    ( InterruptedException   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["awaitAsyncDispatch"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . asyncDispatchLatch    =    asyncDispatchLatch ;", "}", "METHOD_END"], "methodName": ["setAsyncDispatchLatch"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . asyncResult . set ( asyncResult )  ;", "}", "METHOD_END"], "methodName": ["setAsyncResult"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . handler    =    handler ;", "}", "METHOD_END"], "methodName": ["setHandler"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . interceptors    =    interceptors ;", "}", "METHOD_END"], "methodName": ["setInterceptors"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . modelAndView    =    mav ;", "}", "METHOD_END"], "methodName": ["setModelAndView"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . resolvedException    =    resolvedException ;", "}", "METHOD_END"], "methodName": ["setResolvedException"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . mvcResult . getAsyncResult (  0  )  ;", "}", "METHOD_END"], "methodName": ["getAsyncResultFailure"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResultTests"}, {"methodBody": ["METHOD_START", "{", "this . mvcResult . setAsyncResult (  \" Foo \"  )  ;", "this . mvcResult . setAsyncDispatchLatch ( new   CountDownLatch (  0  )  )  ;", "this . mvcResult . getAsyncResult (  )  ;", "}", "METHOD_END"], "methodName": ["getAsyncResultSuccess"], "fileName": "org.springframework.test.web.servlet.DefaultMvcResultTests"}, {"methodBody": ["METHOD_START", "{", "for    ( ResultMatcher   matcher    :    this . defaultResultMatchers )     {", "matcher . match ( mvcResult )  ;", "}", "for    ( ResultHandler   handler    :    this . defaultResultHandlers )     {", "handler . handle ( mvcResult )  ;", "}", "}", "METHOD_END"], "methodName": ["applyDefaultResultActions"], "fileName": "org.springframework.test.web.servlet.MockMvc"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . defaultRequestBuilder )     !  =    null )     &  &     ( requestBuilder   instanceof   Mergeable )  )     {", "requestBuilder    =     (  ( RequestBuilder )     (  (  ( Mergeable )     ( requestBuilder )  )  . merge ( this . defaultRequestBuilder )  )  )  ;", "}", "MockHttpServletRequest   request    =    requestBuilder . buildRequest ( this . servletContext )  ;", "AsyncContext   asyncContext    =    request . getAsyncContext (  )  ;", "MockHttpServletResponse   mockResponse ;", "HttpServletResponse   servletResponse ;", "if    ( asyncContext    !  =    null )     {", "servletResponse    =     (  ( HttpServletResponse )     ( asyncContext . getResponse (  )  )  )  ;", "mockResponse    =    unwrapResponseIfNecessary ( servletResponse )  ;", "} else    {", "mockResponse    =    new   MockHttpServletResponse (  )  ;", "servletResponse    =    mockResponse ;", "}", "if    ( requestBuilder   instanceof   SmartRequestBuilder )     {", "request    =     (  ( SmartRequestBuilder )     ( requestBuilder )  )  . postProcessRequest ( request )  ;", "}", "final   MvcResult   mvcResult    =    new   DefaultMvcResult ( request ,    mockResponse )  ;", "request . setAttribute ( MockMvc . MVC _ RESULT _ ATTRIBUTE ,    mvcResult )  ;", "RequestAttributes   previousAttributes    =    RequestContextHolder . getRequestAttributes (  )  ;", "RequestContextHolder . setRequestAttributes ( new   web . context . request . ServletRequestAttributes ( request ,    servletResponse )  )  ;", "MockFilterChain   filterChain    =    new   MockFilterChain ( this . servlet ,    this . filters )  ;", "filterChain . doFilter ( request ,    servletResponse )  ;", "if    (  (  ( ASYNC . equals ( request . getDispatcherType (  )  )  )     &  &     ( asyncContext    !  =    null )  )     &  &     (  !  ( request . isAsyncStarted (  )  )  )  )     {", "asyncContext . complete (  )  ;", "}", "applyDefaultResultActions ( mvcResult )  ;", "RequestContextHolder . setRequestAttributes ( previousAttributes )  ;", "return   new   ResultActions (  )     {", "@ Override", "public   ResultActions   andExpect ( ResultMatcher   matcher )    throws   Exception    {", "matcher . match ( mvcResult )  ;", "return   this ;", "}", "@ Override", "public   ResultActions   andDo ( ResultHandler   handler )    throws   Exception    {", "handler . handle ( mvcResult )  ;", "return   this ;", "}", "@ Override", "public   MvcResult   andReturn (  )     {", "return   mvcResult ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["perform"], "fileName": "org.springframework.test.web.servlet.MockMvc"}, {"methodBody": ["METHOD_START", "{", "this . defaultRequestBuilder    =    requestBuilder ;", "}", "METHOD_END"], "methodName": ["setDefaultRequest"], "fileName": "org.springframework.test.web.servlet.MockMvc"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resultHandlers ,     \" ResultHandler   List   is   required \"  )  ;", "this . defaultResultHandlers    =    resultHandlers ;", "}", "METHOD_END"], "methodName": ["setGlobalResultHandlers"], "fileName": "org.springframework.test.web.servlet.MockMvc"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resultMatchers ,     \" ResultMatcher   List   is   required \"  )  ;", "this . defaultResultMatchers    =    resultMatchers ;", "}", "METHOD_END"], "methodName": ["setGlobalResultMatchers"], "fileName": "org.springframework.test.web.servlet.MockMvc"}, {"methodBody": ["METHOD_START", "{", "while    ( servletResponse   instanceof   HttpServletResponseWrapper )     {", "servletResponse    =     (  ( HttpServletResponseWrapper )     ( servletResponse )  )  . getResponse (  )  ;", "}", "Assert . isInstanceOf ( MockHttpServletResponse . class ,    servletResponse )  ;", "return    (  ( MockHttpServletResponse )     ( servletResponse )  )  ;", "}", "METHOD_END"], "methodName": ["unwrapResponseIfNecessary"], "fileName": "org.springframework.test.web.servlet.MockMvc"}, {"methodBody": ["METHOD_START", "{", "TestDispatcherServlet   dispatcherServlet    =    new   TestDispatcherServlet ( webAppContext )  ;", "if    ( dispatcherServletCustomizers    !  =    null )     {", "for    ( DispatcherServletCustomizer   customizers    :    dispatcherServletCustomizers )     {", "customizers . customize ( dispatcherServlet )  ;", "}", "}", "try    {", "dispatcherServlet . init ( servletConfig )  ;", "}    catch    ( ServletException   ex )     {", "throw   new    . MockMvcBuildException (  \" Failed   to   initialize   TestDispatcherServlet \"  ,    ex )  ;", "}", "MockMvc   mockMvc    =    new   MockMvc ( dispatcherServlet ,    filters )  ;", "mockMvc . setDefaultRequest ( defaultRequestBuilder )  ;", "mockMvc . setGlobalResultMatchers ( globalResultMatchers )  ;", "mockMvc . setGlobalResultHandlers ( globalResultHandlers )  ;", "return   mockMvc ;", "}", "METHOD_END"], "methodName": ["createMockMvc"], "fileName": "org.springframework.test.web.servlet.MockMvcBuilderSupport"}, {"methodBody": ["METHOD_START", "{", "this . mvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( MockMvcReuseTests . HELLO )  )  ;", "this . mvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  . param ( MockMvcReuseTests . ENIGMA ,     \"  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( MockMvcReuseTests . ENIGMA )  )  ;", "this . mvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( MockMvcReuseTests . HELLO )  )  ;", "}", "METHOD_END"], "methodName": ["requestParametersAreClearedBetweenInvocations"], "fileName": "org.springframework.test.web.servlet.MockMvcReuseTests"}, {"methodBody": ["METHOD_START", "{", "this . mvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( MockMvcReuseTests . HELLO )  )  . andExpect ( MockMvcResultMatchers . request (  )  . sessionAttribute ( MockMvcReuseTests . FOO ,    nullValue (  )  )  )  ;", "this . mvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  . sessionAttr ( MockMvcReuseTests . FOO ,    MockMvcReuseTests . BAR )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( MockMvcReuseTests . HELLO )  )  . andExpect ( MockMvcResultMatchers . request (  )  . sessionAttribute ( MockMvcReuseTests . FOO ,    MockMvcReuseTests . BAR )  )  ;", "this . mvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( MockMvcReuseTests . HELLO )  )  . andExpect ( MockMvcResultMatchers . request (  )  . sessionAttribute ( MockMvcReuseTests . FOO ,    nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["sessionAttributesAreClearedBetweenInvocations"], "fileName": "org.springframework.test.web.servlet.MockMvcReuseTests"}, {"methodBody": ["METHOD_START", "{", "this . mvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.servlet.MockMvcReuseTests"}, {"methodBody": ["METHOD_START", "{", "return   mav ;", "}", "METHOD_END"], "methodName": ["getMav"], "fileName": "org.springframework.test.web.servlet.StubMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . flashMap    =    flashMap ;", "}", "METHOD_END"], "methodName": ["setFlashMap"], "fileName": "org.springframework.test.web.servlet.StubMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . handler    =    handler ;", "}", "METHOD_END"], "methodName": ["setHandler"], "fileName": "org.springframework.test.web.servlet.StubMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . interceptors    =    interceptors ;", "}", "METHOD_END"], "methodName": ["setInterceptors"], "fileName": "org.springframework.test.web.servlet.StubMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . mav    =    mav ;", "}", "METHOD_END"], "methodName": ["setMav"], "fileName": "org.springframework.test.web.servlet.StubMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . request    =    request ;", "}", "METHOD_END"], "methodName": ["setRequest"], "fileName": "org.springframework.test.web.servlet.StubMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . resolvedException    =    resolvedException ;", "}", "METHOD_END"], "methodName": ["setResolvedException"], "fileName": "org.springframework.test.web.servlet.StubMvcResult"}, {"methodBody": ["METHOD_START", "{", "this . response    =    response ;", "}", "METHOD_END"], "methodName": ["setResponse"], "fileName": "org.springframework.test.web.servlet.StubMvcResult"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DefaultMvcResult )     ( request . getAttribute ( MockMvc . MVC _ RESULT _ ATTRIBUTE )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMvcResult"], "fileName": "org.springframework.test.web.servlet.TestDispatcherServlet"}, {"methodBody": ["METHOD_START", "{", "WebAsyncUtils . getAsyncManager ( request )  . registerCallableInterceptor ( TestDispatcherServlet . KEY ,    new   CallableProcessingInterceptor (  )     {", "@ Override", "public    < T >    void   postProcess ( NativeWebRequest   r ,    Callable < T >    task ,    Object   value )     {", "getMvcResult ( request )  . setAsyncResult ( value )  ;", "}", "}  )  ;", "WebAsyncUtils . getAsyncManager ( request )  . registerDeferredResultInterceptor ( TestDispatcherServlet . KEY ,    new   DeferredResultProcessingInterceptor (  )     {", "@ Override", "public    < T >    void   postProcess ( NativeWebRequest   r ,    DeferredResult < T >    result ,    Object   value )     {", "getMvcResult ( request )  . setAsyncResult ( value )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerAsyncResultInterceptors"], "fileName": "org.springframework.test.web.servlet.TestDispatcherServlet"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( matcher . matches ( new   WebRequest ( new   URL ( url )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDoesNotMatch"], "fileName": "org.springframework.test.web.servlet.htmlunit.AbstractWebRequestMatcherTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( matcher . matches ( new   WebRequest ( new   URL ( url )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMatches"], "fileName": "org.springframework.test.web.servlet.htmlunit.AbstractWebRequestMatcherTests"}, {"methodBody": ["METHOD_START", "{", "when ( matcher 1  . matches ( request )  )  . thenReturn ( true )  ;", "when ( connection 1  . getResponse ( request )  )  . thenReturn ( expectedResponse )  ;", "WebResponse   response    =    w . getResponse ( request )  ;", "assertThat ( response ,    CoreMatchers . sameInstance ( expectedResponse )  )  ;", "verify ( matcher 1  )  . matches ( request )  ;", "verifyNoMoreInteractions ( matcher 2  ,    connection 2  ,    defaultConnection )  ;", "verify ( connection 1  )  . getResponse ( request )  ;", "}", "METHOD_END"], "methodName": ["getResponseAllMatches"], "fileName": "org.springframework.test.web.servlet.htmlunit.DelegatingWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "when ( defaultConnection . getResponse ( request )  )  . thenReturn ( expectedResponse )  ;", "WebResponse   response    =    w . getResponse ( request )  ;", "assertThat ( response ,    CoreMatchers . sameInstance ( expectedResponse )  )  ;", "verify ( matcher 1  )  . matches ( request )  ;", "verify ( matcher 2  )  . matches ( request )  ;", "verifyNoMoreInteractions ( connection 1  ,    connection 2  )  ;", "verify ( defaultConnection )  . getResponse ( request )  ;", "}", "METHOD_END"], "methodName": ["getResponseDefault"], "fileName": "org.springframework.test.web.servlet.htmlunit.DelegatingWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "when ( matcher 2  . matches ( request )  )  . thenReturn ( true )  ;", "when ( connection 2  . getResponse ( request )  )  . thenReturn ( expectedResponse )  ;", "WebResponse   response    =    w . getResponse ( request )  ;", "assertThat ( response ,    CoreMatchers . sameInstance ( expectedResponse )  )  ;", "verify ( matcher 1  )  . matches ( request )  ;", "verify ( matcher 2  )  . matches ( request )  ;", "verifyNoMoreInteractions ( connection 1  ,    defaultConnection )  ;", "verify ( connection 2  )  . getResponse ( request )  ;", "}", "METHOD_END"], "methodName": ["getResponseSecondMatches"], "fileName": "org.springframework.test.web.servlet.htmlunit.DelegatingWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "request    =    new   WebRequest ( new   URL (  \" http :  /  / localhost /  \"  )  )  ;", "WebResponseData   data    =    new   WebResponseData (  \"  \"  . getBytes (  \" UTF -  8  \"  )  ,     2  0  0  ,     \"  \"  ,    Collections . emptyList (  )  )  ;", "expectedResponse    =    new   com . gargoylesoftware . htmlunit . WebResponse ( data ,    request ,     1  0  0 L )  ;", "webConnection    =    new    ( defaultConnection ,    new    . DelegateWebConnection ( matcher 1  ,    connection 1  )  ,    new    . DelegateWebConnection ( matcher 2  ,    connection 2  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.htmlunit.DelegatingWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "WebClient   webClient    =    new   WebClient (  )  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup (  )  . build (  )  ;", "MockMvcWebConnection   mockConnection    =    new   MockMvcWebConnection ( mockMvc ,    webClient )  ;", "WebRequestMatcher   cdnMatcher    =    new   UrlRegexRequestMatcher (  \"  .  *  ?  /  / code . jquery . com /  .  *  \"  )  ;", "WebConnection   httpConnection    =    new   com . gargoylesoftware . htmlunit . HttpWebConnection ( webClient )  ;", "webClient . setWebConnection ( new    ( mockConnection ,    new    . DelegateWebConnection ( cdnMatcher ,    httpConnection )  )  )  ;", "Page   page    =    webClient . getPage (  \" http :  /  / code . jquery . com / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertThat ( page . getWebResponse (  )  . getStatusCode (  )  ,    CoreMatchers . equalTo (  2  0  0  )  )  ;", "assertThat ( page . getWebResponse (  )  . getContentAsString (  )  ,    IsNot . not ( isEmptyString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyExampleInClassLevelJavadoc"], "fileName": "org.springframework.test.web.servlet.htmlunit.DelegatingWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "return    \" forward :  /  \"  ;", "}", "METHOD_END"], "methodName": ["forward"], "fileName": "org.springframework.test.web.servlet.htmlunit.ForwardController"}, {"methodBody": ["METHOD_START", "{", "return    \" hello \"  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.test.web.servlet.htmlunit.HelloController"}, {"methodBody": ["METHOD_START", "{", "WebRequestMatcher   matcher    =    new   HostRequestMatcher (  \" localhost :  8  0  \"  )  ;", "assertMatches ( matcher ,     \" http :  /  / localhost :  8  0  / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertMatches ( matcher ,     \" http :  /  / localhost / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertDoesNotMatch ( matcher ,     \" https :  /  / localhost / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertDoesNotMatch ( matcher ,     \" http :  /  / localhost :  9  0  9  0  / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "}", "METHOD_END"], "methodName": ["defaultHttpPort"], "fileName": "org.springframework.test.web.servlet.htmlunit.HostRequestMatcherTests"}, {"methodBody": ["METHOD_START", "{", "WebRequestMatcher   matcher    =    new   HostRequestMatcher (  \" localhost :  4  4  3  \"  )  ;", "assertMatches ( matcher ,     \" https :  /  / localhost :  4  4  3  / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertMatches ( matcher ,     \" https :  /  / localhost / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertDoesNotMatch ( matcher ,     \" http :  /  / localhost / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertDoesNotMatch ( matcher ,     \" https :  /  / localhost :  9  0  9  0  / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "}", "METHOD_END"], "methodName": ["defaultHttpsPort"], "fileName": "org.springframework.test.web.servlet.htmlunit.HostRequestMatcherTests"}, {"methodBody": ["METHOD_START", "{", "WebRequestMatcher   matcher    =    new   HostRequestMatcher (  \" localhost \"  )  ;", "assertMatches ( matcher ,     \" http :  /  / localhost / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertDoesNotMatch ( matcher ,     \" http :  /  / example . com / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "}", "METHOD_END"], "methodName": ["localhost"], "fileName": "org.springframework.test.web.servlet.htmlunit.HostRequestMatcherTests"}, {"methodBody": ["METHOD_START", "{", "WebRequestMatcher   matcher    =    new   HostRequestMatcher (  \" localhost \"  ,     \" example . com \"  )  ;", "assertMatches ( matcher ,     \" http :  /  / localhost / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertMatches ( matcher ,     \" http :  /  / example . com / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "}", "METHOD_END"], "methodName": ["multipleHosts"], "fileName": "org.springframework.test.web.servlet.htmlunit.HostRequestMatcherTests"}, {"methodBody": ["METHOD_START", "{", "WebRequestMatcher   matcher    =    new   HostRequestMatcher (  \" localhost :  8  0  8  0  \"  )  ;", "assertMatches ( matcher ,     \" http :  /  / localhost :  8  0  8  0  / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertDoesNotMatch ( matcher ,     \" http :  /  / localhost :  9  0  9  0  / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "}", "METHOD_END"], "methodName": ["specificPort"], "fileName": "org.springframework.test.web.servlet.htmlunit.HostRequestMatcherTests"}, {"methodBody": ["METHOD_START", "{", "getCookieManager (  )  . addCookie ( createCookie ( request ,    sessionid )  )  ;", "}", "METHOD_END"], "methodName": ["addSessionCookie"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "String   authorization    =    header (  \" Authorization \"  )  ;", "String [  ]    authSplit    =    StringUtils . split ( authorization ,     \"  :     \"  )  ;", "if    ( authSplit    !  =    null )     {", "r . setAuthType ( authSplit [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["authType"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    getCharset (  )  ;", "String   httpMethod    =    this . webRequest . getHttpMethod (  )  . name (  )  ;", "UriComponents   uriComponents    =    uriComponents (  )  ;", "String   path    =    uriComponents . getPath (  )  ;", "MockHttpServletRequest   request    =    new    . HtmlUnitMockHttpServletRequest ( servletContext ,    httpMethod ,     ( path    !  =    null    ?    path    :     \"  \"  )  )  ;", "parent ( request ,    this . parentBuilder )  ;", "String   host    =    uriComponents . getHost (  )  ;", "request . setServerName (  ( host    !  =    null    ?    host    :     \"  \"  )  )  ;", "authType ( request )  ;", "request . setCharacterEncoding ( charset . name (  )  )  ;", "content ( request ,    charset )  ;", "contextPath ( request ,    uriComponents )  ;", "contentType ( request )  ;", "cookies ( request )  ;", "headers ( request )  ;", "locales ( request )  ;", "servletPath ( uriComponents ,    request )  ;", "params ( request ,    uriComponents )  ;", "ports ( uriComponents ,    request )  ;", "request . setProtocol (  \" HTTP /  1  .  1  \"  )  ;", "request . setQueryString ( uriComponents . getQuery (  )  )  ;", "String   scheme    =    uriComponents . getScheme (  )  ;", "request . setScheme (  ( scheme    !  =    null    ?    scheme    :     \"  \"  )  )  ;", "request . setPathInfo ( null )  ;", "return   postProcess ( request )  ;", "}", "METHOD_END"], "methodName": ["buildRequest"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "String   requestBody    =    this . webRequest . getRequestBody (  )  ;", "if    ( requestBody    =  =    null )     {", "return ;", "}", "request . setContent ( requestBody . getBytes ( charset )  )  ;", "}", "METHOD_END"], "methodName": ["content"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =    header (  \" Content - Type \"  )  ;", "if    ( contentType    =  =    null )     {", "FormEncodingType   encodingType    =    this . web . getEncodingType (  )  ;", "if    ( encodingType    !  =    null )     {", "contentType    =    encodingType . getName (  )  ;", "}", "}", "request . setContentType (  ( contentType    !  =    null    ?    contentType    :    MediaType . ALL _ VALUE )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . contextPath )     =  =    null )     {", "List < String >    pathSegments    =    uriComponents . getPathSegments (  )  ;", "if    ( pathSegments . isEmpty (  )  )     {", "r . setContextPath (  \"  \"  )  ;", "} else    {", "r . setContextPath (  (  \"  /  \"     +     ( pathSegments . get (  0  )  )  )  )  ;", "}", "} else    {", "String   path    =    uriComponents . getPath (  )  ;", "Assert . isTrue (  (  ( path    !  =    null )     &  &     ( path . startsWith ( this . contextPath )  )  )  ,     (  )     -  >     (  (  (  \"  \\  \"  \"     +     ( uriComponents . getPath (  )  )  )     +     \"  \\  \"    should   start   with   context   path    \\  \"  \"  )     +     ( this . contextPath )  )     +     \"  \\  \"  \"  )  ;", "r . setContextPath ( this . contextPath )  ;", "}", "}", "METHOD_END"], "methodName": ["contextPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "List < Cookie >    cookies    =    new   ArrayList <  >  (  )  ;", "String   cookieHeaderValue    =    header (  \" Cookie \"  )  ;", "if    ( cookieHeaderValue    !  =    null )     {", "StringTokenizer   tokens    =    new   StringTokenizer ( cookieHeaderValue ,     \"  =  ;  \"  )  ;", "while    ( tokens . hasMoreTokens (  )  )     {", "String   cookieName    =    tokens . nextToken (  )  . trim (  )  ;", "Assert . isTrue ( tokens . hasMoreTokens (  )  ,     (  )     -  >     (  (  (  \" Expected   value   for   cookie   name    '  \"     +    cookieName )     +     \"  '  :    full   cookie   header   was    [  \"  )     +    cookieHeaderValue )     +     \"  ]  \"  )  ;", "String   cookieValue    =    tokens . nextToken (  )  . trim (  )  ;", "processCookie ( request ,    cookies ,    new   Cookie ( cookieName ,    cookieValue )  )  ;", "}", "}", "Set < com . gargoylesoftwareutil . Cookie >    managedCookies    =    this . webClient . getCookies ( this . webRequest . getUrl (  )  )  ;", "for    ( com . gargoylesoftwareutil . Cookie   cookie    :    managedCookies )     {", "processCookie ( request ,    cookies ,    new   Cookie ( cookie . getName (  )  ,    cookie . getValue (  )  )  )  ;", "}", "Cookie [  ]    parentCookies    =    request . getCookies (  )  ;", "if    ( parentCookies    !  =    null )     {", "for    ( Cookie   cookie    :    parentCookies )     {", "cookies . add ( cookie )  ;", "}", "}", "if    (  !  ( ObjectUtils . isEmpty ( cookies )  )  )     {", "request . setCookies ( cookies . toArray ( new   Cookie [  0  ]  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   Cookie ( request . getServerName (  )  ,     \" JSESSIONID \"  ,    sessionid ,     (  ( request . getContextPath (  )  )     +     \"  /  \"  )  ,    null ,    request . isSecure (  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["createCookie"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    this . webRequest . getCharset (  )  ;", "return   charset    !  =    null    ?    charset    :    StandardCharsets . ISO _  8  8  5  9  _  1  ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this . webClient . getCookieManager (  )  ;", "}", "METHOD_END"], "methodName": ["getCookieManager"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this . webRequest . getAdditionalHeaders (  )  . get ( headerName )  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . webRequest . getAdditionalHeaders (  )  . forEach ( request :  : addHeader )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "MockHttpSession   session ;", "synchronized ( this . sessions )     {", "session    =    this . sessions . get ( sessionid )  ;", "if    ( session    =  =    null )     {", "session    =    new    . HtmlUnitMockHttpSession ( request ,    sessionid )  ;", "session . setNew ( true )  ;", "synchronized ( this . sessions )     {", "this . sessions . put ( sessionid ,    session )  ;", "}", "addSessionCookie ( request ,    sessionid )  ;", "} else    {", "session . setNew ( false )  ;", "}", "}", "return   session ;", "}", "METHOD_END"], "methodName": ["httpSession"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "String   locale    =    header (  \" Accept - Language \"  )  ;", "if    ( locale    =  =    null )     {", "r . addPreferredLocale ( Locale . getDefault (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["locales"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "uriComponents . getQueryParams (  )  . forEach (  (    name ,    values )     -  >     {", "String   urlDecodedName    =    urlDecode ( name )  ;", "values . forEach (  (    value )     -  >     {", "value    =     ( value    !  =    null )     ?    urlDecode ( value )     :     \"  \"  ;", "request . addParameter ( urlDecodedName ,    value )  ;", "}  )  ;", "}  )  ;", "for    ( NameValuePair   param    :    this . webRequest . geParameters (  )  )     {", "request . addParameter ( param . getName (  )  ,    param . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["params"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( parent    =  =    null )     {", "return ;", "}", "MockHttpServle   paren    =    parent . buildRequest ( request . getServletContext (  )  )  ;", "HttpSession   parentSession    =    paren . getSession ( false )  ;", "if    ( parentSession    !  =    null )     {", "HttpSession   localSession    =    request . getSession (  )  ;", "Assert . state (  ( localSession    !  =    null )  ,     \" No   local   HttpSession \"  )  ;", "Enumeration < String >    attrNames    =    parentSession . getAttributeNames (  )  ;", "while    ( attrNames . hasMoreElements (  )  )     {", "String   attrName    =    attrNames . nextElement (  )  ;", "Object   attrValue    =    parentSession . getAttribute ( attrName )  ;", "localSession . setAttribute ( attrName ,    attrValue )  ;", "}", "}", "Enumeration < String >    headerNames    =    paren . getHeaderNames (  )  ;", "while    ( headerNames . hasMoreElements (  )  )     {", "String   attrName    =    headerNames . nextElement (  )  ;", "Enumeration < String >    attrValues    =    paren . getHeaders ( attrName )  ;", "while    ( attrValues . hasMoreElements (  )  )     {", "String   attrValue    =    attrValues . nextElement (  )  ;", "request . addHeader ( attrName ,    attrValue )  ;", "}", "}", "Map < String ,    String [  ]  >    parentParams    =    paren . getParameterMap (  )  ;", "parentParams . forEach ( request :  : addParameter )  ;", "Cookie [  ]    parentCookies    =    paren . getCookies (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( parentCookies )  )  )     {", "request . setCookies ( parentCookies )  ;", "}", "Enumeration < String >    parentAttrNames    =    paren . getAttributeNames (  )  ;", "while    ( parentAttrNames . hasMoreElements (  )  )     {", "String   parentAttrName    =    parentAttrNames . nextElement (  )  ;", "request . setAttribute ( parentAttrName ,    paren . getAttribute ( parentAttrName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "int   serverPort    =    uriComponents . getPort (  )  ;", "request . setServerPort ( serverPort )  ;", "if    ( serverPort    =  =     (  -  1  )  )     {", "int   portConnection    =    this . web . getUrl (  )  . getDefaultPort (  )  ;", "request . setLocalPort ( serverPort )  ;", "request . setRemotePort ( portConnection )  ;", "} else    {", "request . setRemotePort ( serverPort )  ;", "}", "}", "METHOD_END"], "methodName": ["ports"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . parentPostProcessor )     !  =    null )     {", "request    =    this . parentPostProcessor . postProcess ( request )  ;", "}", "if    (  ( this . forwardPostProcessor )     !  =    null )     {", "request    =    this . forwardPostProcessor . postProcess ( request )  ;", "}", "return   request ;", "}", "METHOD_END"], "methodName": ["postProcess"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "cookies . add ( cookie )  ;", "if    (  \" JSESSIONID \"  . equals ( cookie . getName (  )  )  )     {", "request . seedSessionId ( cookie . getValue (  )  )  ;", "request . setSession ( httpSession ( request ,    cookie . getValue (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processCookie"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "getCookieManager (  )  . removeCookie ( createCookie ( request ,    sessionid )  )  ;", "}", "METHOD_END"], "methodName": ["removeSessionCookie"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "String   servletPath    =    requestPath . substring ( request . getContextPath (  )  . length (  )  )  ;", "request . setServletPath ( servletPath )  ;", "}", "METHOD_END"], "methodName": ["servletPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  \"  \"  . equals ( request . getPathInfo (  )  )  )     {", "request . setPathInfo ( null )  ;", "}", "String   path    =    uriComponents . getPath (  )  ;", "Path ( request ,     ( path    !  =    null    ?    path    :     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["servletPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "MockMvcWebConnection . validateContextPath ( contextPath )  ;", "this . contextPath    =    contextPath ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . forwardPostProcessor    =    forwardPostProcessor ;", "}", "METHOD_END"], "methodName": ["setForwardPostProcessor"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "URL   url    =    this . webRequest . getUrl (  )  ;", "return   UriComponentsBuilder . fromUriString ( url . toExternalForm (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["uriComponents"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   URLDeco . decode ( value ,     \" UTF -  8  \"  )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["urlDecode"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Cookie   jsessionidCookie    =    webClient . getCookieManager (  )  . getCookie (  \" JSESSIONID \"  )  ;", "if    (  ( expected    =  =    null )     |  |     ( expected . contains (  \" Expires = Thu ,     0  1  - Jan -  1  9  7  0     0  0  :  0  0  :  0  1    GMT \"  )  )  )     {", "Assert . assertThat ( jsessionidCookie ,    Matchers . nullValue (  )  )  ;", "return ;", "}", "St   actual    =    jsessionidCookie . getValue (  )  ;", "Assert . assertThat (  (  (  \" JSESSIONID =  \"     +    actual )     +     \"  ;    Path =  / test ;    Domain = example . com \"  )  ,    Matchers . equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["assertSingleSessionCookie"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / app / login / authenticate \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getPathInfo (  )  ,    Matchers . nullValue (  )  )  ;", "Assert . assertThat ( actualRequest . getServletPath (  )  ,    Matchers . equalTo (  \"  / login / authenticate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestAndAntPathRequestMatcher"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   base 6  4 Credentials    =     \" dXNlcm 5 hbWU 6 cGFzc 3 dvcmQ =  \"  ;", "String   authzHeaderValue    =     \" Basic :     \"     +    base 6  4 Credentials ;", "UsernamePasswordCredentials   credentials    =    new   UsernamePasswordCredentials ( base 6  4 Credentials )  ;", "webRequest . setCredentials ( credentials )  ;", "webRequest . setAdditionalHeader (  \" Authorization \"  ,    authzHeaderValue )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getAuthType (  )  ,    Matchers . equalTo (  \" Basic \"  )  )  ;", "Assert . assertThat ( actualRequest . getHeader (  \" Authorization \"  )  ,    Matchers . equalTo ( authzHeaderValue )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestBasicAuth"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setCharset ( StandardCharsets . UTF _  8  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getCharacterEncoding (  )  ,    Matchers . equalTo (  \" UTF -  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestCharacterEncoding"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \" some   content   that   has   length \"  ;", "webRequest . setHttpMethod ( POST )  ;", "webRequest . setRequestBody ( content )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getContentLength (  )  ,    Matchers . equalTo ( content . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContentLength"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" text / html ; charset = UTF -  8  \"  ;", "webRequest . setAdditionalHeader (  \" Content - Type \"  ,    contentType )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getContentType (  )  ,    Matchers . equalTo ( contentType )  )  ;", "Assert . assertThat ( actualRequest . getHeader (  \" Content - Type \"  )  ,    Matchers . equalTo ( contentType )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContentType"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setEncodingType ( URL _ ENCODED )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getContentType (  )  ,    Matchers . equalTo (  \" application / x - www - form - urlencoded \"  )  )  ;", "Assert . assertThat ( actualRequest . getHeader (  \" Content - Type \"  )  ,    Matchers . equalTo (  \" application / x - www - form - urlencoded ; charset = ISO -  8  8  5  9  -  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContentTypeWithFormSubmission"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  \"  ;", "r . setContextPath ( expected )  ;", "String   contextPath    =    r . buildRequest ( servletContext )  . getContextPath (  )  ;", "Assert . assertThat ( contextPath ,    Matchers . equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContextPathEmpty"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  / test \"  ;", "r . setContextPath ( expected )  ;", "String   contextPath    =    r . buildRequest ( servletContext )  . getContextPath (  )  ;", "Assert . assertThat ( contextPath ,    Matchers . equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContextPathExplicit"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "requestBuilder . setContextPath (  \"  / invalid \"  )  ;", "requestBuilder . buildRequest ( servletContext )  . getContextPath (  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContextPathInvalid"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  / test / this \"  ;", "r . setContextPath ( expected )  ;", "String   contextPath    =    r . buildRequest ( servletContext )  . getContextPath (  )  ;", "Assert . assertThat ( contextPath ,    Matchers . equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContextPathMulti"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   contextPath    =    requestBuilder . buildRequest ( servletContext )  . getContextPath (  )  ;", "Assert . assertThat ( contextPath ,    Matchers . equalTo (  \"  / test \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContextPathUsesFirstSegmentByDefault"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com /  \"  )  )  ;", "String   contextPath    =    r . buildRequest ( servletContext )  . getContextPath (  )  ;", "Assert . assertThat ( contextPath ,    Matchers . equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestContextPathUsesNoFirstSegmentWithDefault"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     \" name = value ;    name 2  = value 2  \"  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Cookie [  ]    cookies    =    actualRequest . getCookies (  )  ;", "Assert . assertThat ( cookies . length ,    Matchers . equalTo (  2  )  )  ;", "Cookie   cookie    =    cookies [  0  ]  ;", "Assert . assertThat ( cookie . getName (  )  ,    Matchers . equalTo (  \" name \"  )  )  ;", "Assert . assertThat ( cookie . getValue (  )  ,    Matchers . equalTo (  \" value \"  )  )  ;", "cookie    =    cookies [  1  ]  ;", "Assert . assertThat ( cookie . getName (  )  ,    Matchers . equalTo (  \" name 2  \"  )  )  ;", "Assert . assertThat ( cookie . getValue (  )  ,    Matchers . equalTo (  \" value 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestCookiesMulti"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getCookies (  )  ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestCookiesNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     \" name = value \"  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Cookie [  ]    cookies    =    actualRequest . getCookies (  )  ;", "Assert . assertThat ( cookies . length ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( cookies [  0  ]  . getName (  )  ,    Matchers . equalTo (  \" name \"  )  )  ;", "Assert . assertThat ( cookies [  0  ]  . getValue (  )  ,    Matchers . equalTo (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestCookiesSingle"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getCharacterEncoding (  )  ,    Matchers . equalTo (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestDefaultCharacterEncoding"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \" some   content   that   has   length \"  ;", "webRequest . setHttpMethod ( POST )  ;", "webRequest . setRequestBody ( content )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( IOUtils . toString ( actualRequest . getInputStream (  )  )  ,    Matchers . equalTo ( content )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestInputStream"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocalAddr (  )  ,    Matchers . equalTo (  \"  1  2  7  .  0  .  0  .  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocalAddr"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / localhost / test / this \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocalPort (  )  ,    Matchers . equalTo (  (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocalMissing"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocalName (  )  ,    Matchers . equalTo (  \" localhost \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocalName"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocalPort (  )  ,    Matchers . equalTo (  8  0  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocalPort"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setAdditionalHeader (  \" Accept - Language \"  ,     \" da \"  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocale (  )  ,    Matchers . equalTo ( new   Locale (  \" da \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocaleDa"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocale (  )  ,    Matchers . equalTo ( Locale . getDefault (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocaleDefault"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setAdditionalHeader (  \" Accept - Language \"  ,     \" en - gb ; q =  0  .  8  \"  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocale (  )  ,    Matchers . equalTo ( new   Locale (  \" en \"  ,     \" gb \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocaleEnGbQ08"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setAdditionalHeader (  \" Accept - Language \"  ,     \" en \"  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocale (  )  ,    Matchers . equalTo ( new   Locale (  \" en \"  ,     \"  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocaleEnQ07"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setAdditionalHeader (  \" Accept - Language \"  ,     \" en - US \"  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocale (  )  ,    Matchers . equalTo ( Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocaleEnUs"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setAdditionalHeader (  \" Accept - Language \"  ,     \" fr \"  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getLocale (  )  ,    Matchers . equalTo ( Locale . FRENCH )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocaleFr"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setAdditionalHeader (  \" Accept - Language \"  ,     \" en - gb ; q =  0  .  8  ,    da ,    en ; q =  0  .  7  \"  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "List < Locale >    expected    =    Arrays . asList ( new   Locale (  \" da \"  )  ,    new   Locale (  \" en \"  ,     \" gb \"  )  ,    new   Locale (  \" en \"  ,     \"  \"  )  )  ;", "Assert . assertThat ( Collections . list ( actualRequest . getLocales (  )  )  ,    Matchers . equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestLocaleMulti"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "for    ( HttpMethod   expectedMethod    :    HttpMethod . values (  )  )     {", "webRequest . setHttpMethod ( expectedMethod )  ;", "String   actualMethod    =    r . buildRequest ( servletContext )  . getMethod (  )  ;", "Assert . assertThat ( actualMethod ,    Matchers . equalTo ( expectedMethod . name (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildRequestMethods"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / example /  ? row %  5 B 0  %  5 D = value \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" row [  0  ]  \"  )  ,    Matchers . equalTo (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapDecodesParameterName"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / example /  ? name = row %  5 B 0  %  5 D \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \" row [  0  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapDecodesParameterValue"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / example /  ? name = value & param 2  = value +  2  \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  2  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \" value \"  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" param 2  \"  )  ,    Matchers . equalTo (  \" value    2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapFromMultipleQueryParams"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / example /  ? name = value \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapFromSingleQueryParam"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / example /  ? name =  %  2  0  \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \"     \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapFromSingleQueryParamWithValueSetToEncodedSpace"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / example /  ? name \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapFromSingleQueryParamWithoutValueAndWithoutEqualsSign"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / example /  ? name =  \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapFromSingleQueryParamWithoutValueButWithEqualsSign"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setRequestParameters ( Arrays . asList ( new   NameValuePair (  \" name 1  \"  ,     \" value 1  \"  )  ,    new   NameValuePair (  \" name 2  \"  ,     \" value 2  \"  )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  2  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name 1  \"  )  ,    Matchers . equalTo (  \" value 1  \"  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name 2  \"  )  ,    Matchers . equalTo (  \" value 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapViaWebRequestDotSetRequestParametersWithMultipleRequestParams"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setRequestParameters ( Arrays . asList ( new   NameValuePair (  \" name \"  ,     \" value \"  )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapViaWebRequestDotSetRequestParametersWithSingleRequestParam"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setRequestParameters ( Arrays . asList ( new   NameValuePair (  \" name \"  ,     \"  \"  )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapViaWebRequestDotSetRequestParametersWithSingleRequestParamWithEmptyValue"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setRequestParameters ( Arrays . asList ( new   NameValuePair (  \" name \"  ,    null )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapViaWebRequestDotSetRequestParametersWithSingleRequestParamWithNullValue"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setRequestParameters ( Arrays . asList ( new   NameValuePair (  \" name \"  ,     \"     \"  )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getParameterMap (  )  . size (  )  ,    Matchers . equalTo (  1  )  )  ;", "Assert . assertThat ( actualRequest . getParameter (  \" name \"  )  ,    Matchers . equalTo (  \"     \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestParameterMapViaWebRequestDotSetRequestParametersWithSingleRequestParamWithValueSetToSpace"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getPathInfo (  )  ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestPathInfo"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com / example \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getPathInfo (  )  ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestPathInfoNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getProtocol (  )  ,    Matchers . equalTo (  \" HTTP /  1  .  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestProtocol"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedQuery    =     \" param 1  = value 1  & param 2  = value 2  \"  ;", "webRequest . setUrl ( new   URL (  (  \" http :  /  / example . com / example ?  \"     +    expectedQuery )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getQueryString (  )  ,    Matchers . equalTo ( expectedQuery )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestQueryWithMultipleQueryParams"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedQuery    =     \" param = value \"  ;", "webRequest . setUrl ( new   URL (  (  \" http :  /  / example . com / example ?  \"     +    expectedQuery )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getQueryString (  )  ,    Matchers . equalTo ( expectedQuery )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestQueryWithSingleQueryParam"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedQuery    =     \" param =  %  2  0  \"  ;", "webRequest . setUrl ( new   URL (  (  \" http :  /  / example . com / example ?  \"     +    expectedQuery )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getQueryString (  )  ,    Matchers . equalTo ( expectedQuery )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestQueryWithSingleQueryParamWithValueSetToEncodedSpace"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedQuery    =     \" param \"  ;", "webRequest . setUrl ( new   URL (  (  \" http :  /  / example . com / example ?  \"     +    expectedQuery )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getQueryString (  )  ,    Matchers . equalTo ( expectedQuery )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestQueryWithSingleQueryParamWithoutValueAndWithoutEqualsSign"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedQuery    =     \" param =  \"  ;", "webRequest . setUrl ( new   URL (  (  \" http :  /  / example . com / example ?  \"     +    expectedQuery )  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getQueryString (  )  ,    Matchers . equalTo ( expectedQuery )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestQueryWithSingleQueryParamWithoutValueButWithEqualsSign"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedBody    =     \" request   body \"  ;", "webRequest . setHttpMethod ( POST )  ;", "webRequest . setRequestBody ( expectedBody )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( IOUtils . toString ( actualRequest . getReader (  )  )  ,    Matchers . equalTo ( expectedBody )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestReader"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getRemoteAddr (  )  ,    Matchers . equalTo (  \"  1  2  7  .  0  .  0  .  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestRemoteAddr"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getRemoteAddr (  )  ,    Matchers . equalTo (  \"  1  2  7  .  0  .  0  .  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestRemoteHost"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getRemotePort (  )  ,    Matchers . equalTo (  8  0  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestRemotePort"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com :  8  0  8  0  /  \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getRemotePort (  )  ,    Matchers . equalTo (  8  0  8  0  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestRemotePort8080"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" http :  /  / example . com /  \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getRemotePort (  )  ,    Matchers . equalTo (  8  0  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestRemotePort80WithDefault"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" session - id \"  ;", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     (  \" JSESSIONID =  \"     +    sessionId )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getRequestedSessionId (  )  ,    Matchers . equalTo ( sessionId )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestRequestedSessionId"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getRequestedSessionId (  )  ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestRequestedSessionIdNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getScheme (  )  ,    Matchers . equalTo (  \" http \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSchemeHttp"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" https :  /  / example . com /  \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getScheme (  )  ,    Matchers . equalTo (  \" https \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSchemeHttps"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getServerName (  )  ,    Matchers . equalTo (  \" example . com \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestServerName"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getServerPort (  )  ,    Matchers . equalTo (  8  0  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestServerPort"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . setUrl ( new   URL (  \" https :  /  / example . com /  \"  )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getServerPort (  )  ,    Matchers . equalTo (  (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestServerPortDefault"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getServletContext (  )  ,    Matchers . equalTo ( servletContext )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestServletContext"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getServletPath (  )  ,    Matchers . equalTo (  \"  / this / here \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestServletPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "HttpSession   newSession    =    actualRequest . getSession (  )  ;", "Assert . assertThat ( newSession ,    Matchers . notNullValue (  )  )  ;", "assertSingleSessionCookie (  (  (  \" JSESSIONID =  \"     +     ( newSession . getId (  )  )  )     +     \"  ;    Path =  / test ;    Domain = example . com \"  )  )  ;", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     (  \" JSESSIONID =  \"     +     ( newSession . getId (  )  )  )  )  ;", "requestBuilder    =    new    ( sessions ,    webClient ,    webRequest )  ;", "actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getSession (  )  ,    Matchers . sameInstance ( newSession )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSession"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "HttpSession   session    =    actualRequest . getSession ( false )  ;", "Assert . assertThat ( session ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSessionFalseIsNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" session - id \"  ;", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     (  \" JSESSIONID =  \"     +    sessionId )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "HttpSession   session    =    actualRequest . getSession ( false )  ;", "Assert . assertThat ( session ,    Matchers . notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSessionFalseWithExistingSession"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" session - id \"  ;", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     (  \" JSESSIONID =  \"     +    sessionId )  )  ;", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "HttpSession   sessionToRemove    =    actualRequest . getSession (  )  ;", "sessionToRemove . invalidate (  )  ;", "Assert . assertThat ( sessions . containsKey ( sessionToRemove . getId (  )  )  ,    Matchers . equalTo ( false )  )  ;", "assertSingleSessionCookie (  (  (  \" JSESSIONID =  \"     +     ( sessionToRemove . getId (  )  )  )     +     \"  ;    Expires = Thu ,     0  1  - Jan -  1  9  7  0     0  0  :  0  0  :  0  1    GMT ;    Path =  / test ;    Domain = example . com \"  )  )  ;", "webRequest . removeAdditionalHeader (  \" Cookie \"  )  ;", "requestBuilder    =    new    ( sessions ,    webClient ,    webRequest )  ;", "actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getSession (  )  . isNew (  )  ,    Matchers . equalTo ( true )  )  ;", "Assert . assertThat ( sessions . containsKey ( sessionToRemove . getId (  )  )  ,    Matchers . equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSessionInvalidate"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getSession (  )  . isNew (  )  ,    Matchers . equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSessionIsNew"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" session - id \"  ;", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     (  \" JSESSIONID =  \"     +    sessionId )  )  ;", "MockHttpServletRequest   actualRequest    =    r . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getSession (  )  . isNew (  )  ,    Matchers . equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSessionIsNewFalse"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "HttpSession   session    =    actualRequest . getSession ( true )  ;", "Assert . assertThat ( session ,    Matchers . notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSessionTrue"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" session - id \"  ;", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     (  \" JSESSIONID =  \"     +    sessionId )  )  ;", "MockHttpServletRequest   actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "HttpSession   session    =    actualRequest . getSession (  )  ;", "Assert . assertThat ( session . getId (  )  ,    Matchers . equalTo ( sessionId )  )  ;", "assertSingleSessionCookie (  (  (  \" JSESSIONID =  \"     +     ( session . getId (  )  )  )     +     \"  ;    Path =  / test ;    Domain = example . com \"  )  )  ;", "requestBuilder    =    new    ( sessions ,    webClient ,    webRequest )  ;", "actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getSession (  )  ,    Matchers . equalTo ( session )  )  ;", "webRequest . setAdditionalHeader (  \" Cookie \"  ,     (  (  \" JSESSIONID =  \"     +    sessionId )     +     \" NEW \"  )  )  ;", "actualRequest    =    requestBuilder . buildRequest ( servletContext )  ;", "Assert . assertThat ( actualRequest . getSession (  )  ,    Matchers . not ( Matchers . equalTo ( session )  )  )  ;", "assertSingleSessionCookie (  (  (  \" JSESSIONID =  \"     +     ( actualRequest . getSession (  )  . getId (  )  )  )     +     \"  ;    Path =  / test ;    Domain = example . com \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestSessionWithExistingSession"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   uri    =    requestBuilder . buildRequest ( servletContext )  . getRequestURI (  )  ;", "Assert . assertThat ( uri ,    Matchers . equalTo (  \"  / test / this / here \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestUri"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   uri    =    requestBuilder . buildRequest ( servletContext )  . getRequestURL (  )  . toString (  )  ;", "Assert . assertThat ( uri ,    Matchers . equalTo (  \" http :  /  / example . com / test / this / here \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildRequestUrl"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "new   HtmlUnitRequestBuilder ( null ,    webClient ,    webRequest )  ;", "}", "METHOD_END"], "methodName": ["constructorNullSessions"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "new   HtmlUnitRequestBuilder ( sessions ,    null ,    webRequest )  ;", "}", "METHOD_END"], "methodName": ["constructorNullWebClient"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "new   HtmlUnitRequestBuilder ( sessions ,    webClient ,    null )  ;", "}", "METHOD_END"], "methodName": ["constructorNullWebRequest"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( ReflectionTestUtils . getField ( requestBuilder ,     \" contextPath \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getContextPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   cookieName    =     \" PARENT \"  ;", "String   cookieValue    =     \" VALUE \"  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   HelloController (  )  )  . defaultRequest ( MockMvcs . get (  \"  /  \"  )  . cookie ( new   Cookie ( cookieName ,    cookieValue )  )  )  . build (  )  ;", "Cookie [  ]    cookies    =    mockMvc . perform ( requestBuilder )  . andReturn (  )  . getRequest (  )  . getCookies (  )  ;", "Assert . assertThat ( cookies ,    Matchers . notNullValue (  )  )  ;", "Assert . assertThat ( cookies . length ,    Matchers . equalTo (  1  )  )  ;", "Cookie   cookie    =    cookies [  0  ]  ;", "Assert . assertThat ( cookie . getName (  )  ,    Matchers . equalTo ( cookieName )  )  ;", "Assert . assertThat ( cookie . getValue (  )  ,    Matchers . equalTo ( cookieValue )  )  ;", "}", "METHOD_END"], "methodName": ["mergeCookie"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   pathInfo    =     \"  / foo / bar \"  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   HelloController (  )  )  . defaultRequest ( MockMvcs . get (  \"  /  \"  )  )  . build (  )  ;", "Assert . assertThat ( mockMvc . perform ( MockMvcs . get ( pathInfo )  )  . andReturn (  )  . getRequest (  )  . getPathInfo (  )  ,    Matchers . equalTo ( pathInfo )  )  ;", "mockMvc . perform ( requestBuilder )  ;", "Assert . assertThat ( mockMvc . perform ( MockMvcs . get ( pathInfo )  )  . andReturn (  )  . getRequest (  )  . getPathInfo (  )  ,    Matchers . equalTo ( pathInfo )  )  ;", "}", "METHOD_END"], "methodName": ["mergeDoesNotCorruptPathInfoOnParent"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =     \" PARENT \"  ;", "String   headerValue    =     \" VALUE \"  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   HelloController (  )  )  . defaultRequest ( MockMvcs . get (  \"  /  \"  )  . header ( headerName ,    headerValue )  )  . build (  )  ;", "Assert . assertThat ( mockMvc . perform ( requestBuilder )  . andReturn (  )  . getRequest (  )  . getHeader ( headerName )  ,    Matchers . equalTo ( headerValue )  )  ;", "}", "METHOD_END"], "methodName": ["mergeHeader"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   paramName    =     \" PARENT \"  ;", "String   paramValue    =     \" VALUE \"  ;", "String   paramValue 2     =     \" VALUE 2  \"  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   HelloController (  )  )  . defaultRequest ( MockMvcs . get (  \"  /  \"  )  . param ( paramName ,    paramValue ,    paramValue 2  )  )  . build (  )  ;", "MockHttpServletRequest   performedRequest    =    mockMvc . perform ( requestBuilder )  . andReturn (  )  . getRequest (  )  ;", "Assert . assertThat ( Arrays . asList ( performedRequest . getParameterValues ( paramName )  )  ,    Matchers . contains ( paramValue ,    paramValue 2  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeParameter"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   attrName    =     \" PARENT \"  ;", "String   attrValue    =     \" VALUE \"  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   HelloController (  )  )  . defaultRequest ( MockMvcs . get (  \"  /  \"  )  . requestAttr ( attrName ,    attrValue )  )  . build (  )  ;", "Assert . assertThat ( mockMvc . perform ( requestBuilder )  . andReturn (  )  . getRequest (  )  . getAttribute ( attrName )  ,    Matchers . equalTo ( attrValue )  )  ;", "}", "METHOD_END"], "methodName": ["mergeRequestAttribute"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   attrName    =     \" PARENT \"  ;", "String   attrValue    =     \" VALUE \"  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   HelloController (  )  )  . defaultRequest ( MockMvcs . get (  \"  /  \"  )  . sessionAttr ( attrName ,    attrValue )  )  . build (  )  ;", "Assert . assertThat ( mockMvc . perform ( requestBuilder )  . andReturn (  )  . getRequest (  )  . getSession (  )  . getAttribute ( attrName )  ,    Matchers . equalTo ( attrValue )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSession"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   HelloController (  )  )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . build (  )  ;", "Assert . assertThat ( mockMvc . perform ( requestBuilder )  . andReturn (  )  . getRequest (  )  . getSession ( false )  ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSessionNotInitialized"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedContextPath    =     \"  / abc / def \"  ;", "r . setContextPath ( expectedContextPath )  ;", "Assert . assertThat ( getContextPath (  )  ,    Matchers . equalTo ( expectedContextPath )  )  ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "requestBuilder . setContextPath (  \" abc / def \"  )  ;", "}", "METHOD_END"], "methodName": ["setContextPathDoesNotStartWithSlash"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "requestBuilder . setContextPath (  \"  \"  )  ;", "Assert . assertThat ( getContextPath (  )  ,    Matchers . isEmptyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContextPathEmptyString"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "requestBuilder . setContextPath (  \"  / abc / def /  \"  )  ;", "}", "METHOD_END"], "methodName": ["setContextPathEndsWithSlash"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "requestBuilder . setContextPath ( null )  ;", "Assert . assertThat ( getContextPath (  )  ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContextPathNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "webRequest    =    new   WebRequest ( new   URL (  \" http :  /  / example . com :  8  0  / test / this / here \"  )  )  ;", "webRequest . setHttpMethod ( GET )  ;", "requestBuilder    =    new    ( sessions ,    webClient ,    webRequest )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertThat ( getResponse ( connection ,    url )  ,    CoreMatchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMockMvcNotUsed"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertThat ( getResponse ( connection ,    url )  ,    Matchers . notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMockMvcUsed"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "new   MockMvcWebConnectionBuilderSupport (  (  ( WebApplicationContext )     ( null )  )  )     {  }  ;", "}", "METHOD_END"], "methodName": ["constructorContextNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "new   MockMvcWebConnectionBuilderSupport (  (  ( MockMvc )     ( null )  )  )     {  }  ;", "}", "METHOD_END"], "methodName": ["constructorMockMvcNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "WebConnection   conn    =    this . builder . createConnection ( this . client )  ;", "assertMockMvcUsed ( conn ,     \" http :  /  / localhost /  \"  )  ;", "assertMockMvcNotUsed ( conn ,     \" http :  /  / example . com /  \"  )  ;", "}", "METHOD_END"], "methodName": ["context"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "WebConnection   conn    =    this . builder . contextPath (  \"  / abc \"  )  . createConnection ( this . client )  ;", "Assert . assertThat ( getResponse ( conn ,     \" http :  /  / localhost / abc / def \"  )  . getContentAsString (  )  ,    CoreMatchers . equalTo (  \"  / abc \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultContextPathCustom"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "WebConnection   conn    =    this . builder . createConnection ( this . client )  ;", "Assert . assertThat ( getResponse ( conn ,     \" http :  /  / localhost / abc \"  )  . getContentAsString (  )  ,    CoreMatchers . equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultContextPathEmpty"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "return   connection . getResponse ( new   WebRequest ( new   URL ( url )  )  )  ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "MockMvc   mockMvc    =    MockMvcBuilders . webAppContextSetup ( wac )  . build (  )  ;", "WebConnection   conn    =    new   MockMvcWeb ( mockMvc )     {  }  . createConnection ( this . client )  ;", "assertMockMvcUsed ( conn ,     \" http :  /  / localhost /  \"  )  ;", "assertMockMvcNotUsed ( conn ,     \" http :  /  / example . com /  \"  )  ;", "}", "METHOD_END"], "methodName": ["mockMvc"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "WebConnection   conn    =    this . builder . alwaysUseMockMvc (  )  . createConnection ( this . client )  ;", "assertMockMvcUsed ( conn ,     \" http :  /  / other . com /  \"  )  ;", "}", "METHOD_END"], "methodName": ["mockMvcAlwaysUseMockMvc"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "WebConnection   conn    =    this . builder . useMockMvcForHosts (  \" example . com \"  )  . createConnection ( this . client )  ;", "assertMockMvcUsed ( conn ,     \" http :  /  / localhost /  \"  )  ;", "assertMockMvcUsed ( conn ,     \" http :  /  / example . com /  \"  )  ;", "assertMockMvcNotUsed ( conn ,     \" http :  /  / other . com /  \"  )  ;", "}", "METHOD_END"], "methodName": ["mockMvcExampleDotCom"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "when ( this . client . getWebConnection (  )  )  . thenReturn ( mock ( WebConnection . class )  )  ;", "this . builder    =    new   MockMvcWeb ( this . wac )     {  }  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcConnectionBuilderSupportTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this . webClient )     !  =    null    ?    this . webClient    :    withDelegate ( new   WebClient (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mockMvc ,     \" MockMvc   must   not   be   null \"  )  ;", "return   new    ( mockMvc )  ;", "}", "METHOD_END"], "methodName": ["mockMvcSetup"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( context ,     \" WebApplicationContext   must   not   be   null \"  )  ;", "return   new    ( context )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetup"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( context ,     \" WebApplicationContext   must   not   be   null \"  )  ;", "Assert . notNull ( configurer ,     \" MockMvcConfigurer   must   not   be   null \"  )  ;", "return   new    ( context ,    configurer )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetup"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( webClient ,     \" WebClient   must   not   be   null \"  )  ;", "webClient . setWebConnection ( createConnection ( webClient )  )  ;", "this . webClient    =    webClient ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withDelegate"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "assertThat ( getResponse ( client ,    url )  . getContentAsString (  )  ,    not ( equalTo (  \" mvc \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMockMvcNotUsed"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( getResponse ( client ,    url )  . getContentAsString (  )  ,    equalTo (  \" mvc \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMockMvcUsed"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   MockMvcWebClientBuilderTests . CookieController (  )  )  . build (  )  ;", "WebClient   client    =    MockMvcWebClientBuilder . mockMvcSetup ( this . mockMvc )  . build (  )  ;", "assertThat ( getResponse ( client ,     \" http :  /  / localhost /  \"  )  . getContentAsString (  )  ,    equalTo (  \" NA \"  )  )  ;", "client . getCookieManager (  )  . addCookie ( new   Cookie (  \" localhost \"  ,     \" cookie \"  ,     \" cookieManagerShared \"  )  )  ;", "assertThat ( getResponse ( client ,     \" http :  /  / localhost /  \"  )  . getContentAsString (  )  ,    equalTo (  \" cookieManagerShared \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cookieManagerShared"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   MockMvcWebClientBuilderTests . CookieController (  )  )  . build (  )  ;", "WebClient   client    =    MockMvcWebClientBuilder . mockMvcSetup ( this . mockMvc )  . build (  )  ;", "assertThat ( getResponse ( client ,     \" http :  /  / localhost /  \"  )  . getContentAsString (  )  ,    equalTo (  \" NA \"  )  )  ;", "assertThat ( postResponse ( client ,     \" http :  /  / localhost /  ? cookie = foo \"  )  . getContentAsString (  )  ,    equalTo (  \" Set \"  )  )  ;", "assertThat ( getResponse ( client ,     \" http :  /  / localhost /  \"  )  . getContentAsString (  )  ,    equalTo (  \" foo \"  )  )  ;", "assertThat ( deleteResponse ( client ,     \" http :  /  / localhost /  \"  )  . getContentAsString (  )  ,    equalTo (  \" Delete \"  )  )  ;", "assertThat ( getResponse ( client ,     \" http :  /  / localhost /  \"  )  . getContentAsString (  )  ,    equalTo (  \" NA \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cookiesAreManaged"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   client . getWebConnection (  )  . getResponse ( request )  ;", "}", "METHOD_END"], "methodName": ["createResponse"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   createResponse ( client ,    new   com . gargoylesoftware . htmlunit . WebRequest ( new   URL ( url )  ,    HttpMethod . DELETE )  )  ;", "}", "METHOD_END"], "methodName": ["deleteResponse"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   createResponse ( client ,    new   WebRequest ( new   URL ( url )  )  )  ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcWebClientBuilder . mockMvcSetup ( null )  ;", "}", "METHOD_END"], "methodName": ["mockMvcSetupNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "WebClient   otherClient    =    new   WebClient (  )  ;", "WebClient   client    =     . mockMvcSetup ( this . mockMvc )  . withDelegate ( otherClient )  . build (  )  ;", "assertMockMvcUsed ( client ,     \" http :  /  / localhost / test \"  )  ;", "Assume . group ( PERFORMANCE ,     (  )     -  >    assertMockMvcNotUsed ( client ,     \" http :  /  / example . com /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mockMvcSetupWithCustomWebClientDelegate"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "WebClient   client    =    MockMvcWebClientBuilder . mockMvcSetup ( this . mockMvc )  . build (  )  ;", "assertMockMvcUsed ( client ,     \" http :  /  / localhost / test \"  )  ;", "Assume . group ( PERFORMANCE ,     (  )     -  >    assertMockMvcNotUsed ( client ,     \" http :  /  / example . com /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mockMvcSetupWithDefaultWebClientDelegate"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   createResponse ( client ,    new   com . gargoylesoftware . htmlunit . WebRequest ( new   URL ( url )  ,    HttpMethod . POST )  )  ;", "}", "METHOD_END"], "methodName": ["postResponse"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcWebClientBuilder . webAppContextSetup ( null )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetupNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Date   expires    =    null ;", "if    (  ( cookie . getMaxAge (  )  )     >     (  -  1  )  )     {", "expires    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +     (  ( cookie . getMaxAge (  )  )     *     1  0  0  0  )  )  )  ;", "}", "BasicClientCookie   result    =    new   BasicClientCookie ( cookie . getN (  )  ,    cookie . getValue (  )  )  ;", "result . setDomain ( cookie . getDomain (  )  )  ;", "result . setComment ( cookie . getComment (  )  )  ;", "result . setExpiryDate ( expires )  ;", "result . setPath ( cookie . getPath (  )  )  ;", "result . setSecure ( cookie . getSecure (  )  )  ;", "if    ( cookie . isHttpOnly (  )  )     {", "result . setAttribute (  \" httponly \"  ,     \" true \"  )  ;", "}", "return   new   Cookie ( result )  ;", "}", "METHOD_END"], "methodName": ["createCookie"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection"}, {"methodBody": ["METHOD_START", "{", "long   startTime    =    System . currentTimeMillis (  )  ;", "HtmlUnitRequestBuilder   requestBuilder    =    new   HtmlUnitRequestBuilder ( this . sessions ,    this . webClient ,    webRequest )  ;", "requestBuilder . setContextPath ( this . contextPath )  ;", "MockHttpSResponse   httpSResponse    =    getResponse ( requestBuilder )  ;", "String   forwardedUrl    =    httpSResponse . getForwardedUrl (  )  ;", "while    ( forwardedUrl    !  =    null )     {", "requestBuilder . setForwardPostProcessor ( new   ForwardRequestPostProcessor ( forwardedUrl )  )  ;", "httpSResponse    =    getResponse ( requestBuilder )  ;", "forwardedUrl    =    httpSResponse . getForwardedUrl (  )  ;", "}", "storeCookies ( webRequest ,    httpSResponse . getCookies (  )  )  ;", "return   new   MockWebResponseBuilder ( startTime ,    webRequest ,    httpSResponse )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection"}, {"methodBody": ["METHOD_START", "{", "ResultActions   resultActions ;", "try    {", "resultActions    =    this . m . perform ( requestBuilder )  ;", "}    catch    ( Exception   ex )     {", "throw   new   IOException ( ex )  ;", "}", "return   resultActions . andReturn (  )  . getResponse (  )  ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( webClient ,     \" WebClient   must   not   be   null \"  )  ;", "this . webClient    =    webClient ;", "}", "METHOD_END"], "methodName": ["setWebClient"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "CookieManager   cookieManager    =    this . webClient . getCookieManager (  )  ;", "for    ( Cookie   cookie    :    cookies )     {", "if    (  ( cookie . getDomain (  )  )     =  =    null )     {", "cookie . setDomain ( webRequest . getUrl (  )  . getHost (  )  )  ;", "}", "com . gargoylesoftware . htmlunit . util . Cookie   toManage    =     . createCookie ( cookie )  ;", "Date   expires    =    toManage . getExpires (  )  ;", "if    (  ( expires    =  =    null )     |  |     ( expires . after ( now )  )  )     {", "cookieManager . addCookie ( toManage )  ;", "} else    {", "cookieManager . removeCookie ( toManage )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["storeCookies"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contextPath    =  =    null )     |  |     (  \"  \"  . equals ( contextPath )  )  )     {", "return ;", "}", "Ast . isTrue ( contextPath . startsWith (  \"  /  \"  )  ,     (  )     -  >     (  \" contextPath    '  \"     +    contextPath )     +     \"  '    must   start   with    '  /  '  .  \"  )  ;", "Ast . isTrue (  (  !  ( contextPath . endsWith (  \"  /  \"  )  )  )  ,     (  )     -  >     (  \" contextPath    '  \"     +    contextPath )     +     \"  '    must   not   end   with    '  /  '  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["validateContextPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnection"}, {"methodBody": ["METHOD_START", "{", "this . alwaysUseMockMvc    =    true ;", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["alwaysUseMockMvc"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionBuilderSupport"}, {"methodBody": ["METHOD_START", "{", "this . contextPath    =    contextPath ;", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["contextPath"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionBuilderSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( webClient ,     \" WebClient   must   not   be   null \"  )  ;", "return   createConnection ( webClient ,    webClient . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["createConnection"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionBuilderSupport"}, {"methodBody": ["METHOD_START", "{", "WebConnection   connection    =    new   MockMvcWebConnection ( this . mockMvc ,    webClient ,    this . contextPath )  ;", "if    ( this . alwaysUseMockMvc )     {", "return   connection ;", "}", "List < DelegatingWebConnection . DelegateWebConnection >    delegates    =    new   ArrayList <  >  ( this . requestMatchers . size (  )  )  ;", "for    ( WebRequestMatcher   matcher    :    this . requestMatchers )     {", "delegates . add ( new   DelegatingWebConnection . DelegateWebConnection ( matcher ,    connection )  )  ;", "}", "return   new   DelegatingWebConnection ( defaultConnection ,    delegates )  ;", "}", "METHOD_END"], "methodName": ["createConnection"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionBuilderSupport"}, {"methodBody": ["METHOD_START", "{", "for    ( WebRequestMatcher   matcher    :    matchers )     {", "this . requestMatchers . add ( matcher )  ;", "}", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["useMockMvc"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionBuilderSupport"}, {"methodBody": ["METHOD_START", "{", "this . requestMatchers . add ( new   HostRequestMatcher ( hosts )  )  ;", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["useMockMvcForHosts"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionBuilderSupport"}, {"methodBody": ["METHOD_START", "{", "new   MockMvcWebConnection ( this . mockMvc ,    this . webClient ,     \" context \"  )  ;", "}", "METHOD_END"], "methodName": ["contextPathDoesNotStartWithSlash"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "this . webClient . setWebConnection ( new   MockMvcWebConnection ( this . mockMvc ,    this . webClient ,     \"  \"  )  )  ;", "Page   page    =    this . webClient . getPage (  \" http :  /  / localhost / context / a \"  )  ;", "assertThat ( page . getWebResponse (  )  . getStatusCode (  )  ,    equalTo (  2  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathEmpty"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "new   MockMvcWebConnection ( this . mockMvc ,    this . webClient ,     \"  / context /  \"  )  ;", "}", "METHOD_END"], "methodName": ["contextPathEndsWithSlash"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "this . webClient . setWebConnection ( new   MockMvcWebConnection ( this . mockMvc ,    this . webClient ,     \"  / context \"  )  )  ;", "Page   page    =    this . webClient . getPage (  \" http :  /  / localhost / context / a \"  )  ;", "assertThat ( page . getWebResponse (  )  . getStatusCode (  )  ,    equalTo (  2  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathExplicit"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "this . webClient . setWebConnection ( new   MockMvcWebConnection ( this . mockMvc ,    this . webClient )  )  ;", "Page   page    =    this . webClient . getPage (  \" http :  /  / localhost / context / a \"  )  ;", "assertThat ( page . getWebResponse (  )  . getStatusCode (  )  ,    equalTo (  2  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "this . webClient . setWebConnection ( new   MockMvcWebConnection ( this . mockMvc ,    this . webClient ,     \"  \"  )  )  ;", "Page   page    =    this . webClient . getPage (  \" http :  /  / localhost / forward \"  )  ;", "assertThat ( page . getWebResponse (  )  . getContentAsString (  )  ,    equalTo (  \" hello \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forward"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockMvcWebConnectionTests"}, {"methodBody": ["METHOD_START", "{", "WebResponseData   webResponseData    =    webResponseData (  )  ;", "long   endTime    =    System . currentTimeMillis (  )  ;", "return   new   com . gargoylesoftware . htmlunit . WebResponse ( webResponseData ,    webRequest ,     ( endTime    -     ( startTime )  )  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilder"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    headerNames    =    this . response . getHeaderNames (  )  ;", "List < NameValuePair >    responseHeaders    =    new   ArrayList <  >  ( headerNames . size (  )  )  ;", "for    ( String   headerName    :    headerNames )     {", "List < Object >    headerValues    =    this . response . getHeaderValues ( headerName )  ;", "for    ( Object   value    :    headerValues )     {", "responseHeaders . add ( new   NameValuePair ( headerName ,    String . valueOf ( value )  )  )  ;", "}", "}", "String   location    =    this . response . getRedirectedUrl (  )  ;", "if    ( location    !  =    null )     {", "responseHeaders . add ( new   NameValuePair (  \" Location \"  ,    location )  )  ;", "}", "return   responseHeaders ;", "}", "METHOD_END"], "methodName": ["responseHeaders"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilder"}, {"methodBody": ["METHOD_START", "{", "String   errorMessage    =    this . response . getErrorMessage (  )  ;", "if    ( StringUtils . hasText ( errorMessage )  )     {", "return   errorMessage ;", "}", "try    {", "return   HttpStatus . valueOf ( statusCode )  . getReasonPhrase (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "return    . DEFAULT _ STATUS _ MESSAGE ;", "}", "METHOD_END"], "methodName": ["statusMessage"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilder"}, {"methodBody": ["METHOD_START", "{", "List < NameValuePair >    responseHeaders    =    responseHeaders (  )  ;", "int   statusCode    =     (  ( this . response . getRedirectedUrl (  )  )     !  =    null )     ?    MOVED _ PERMANENTLY . value (  )     :    this . response . getStatus (  )  ;", "String   statusMessage    =    statusMessage ( statusCode )  ;", "return   new   com . gargoylesoftware . htmlunit . Data ( this . response . getContentAsByteArray (  )  ,    statusCode ,    statusMessage ,    responseHeaders )  ;", "}", "METHOD_END"], "methodName": ["webResponseData"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . response . getWriter (  )  . write (  \" expected   content \"  )  ;", "WebResponse   webResponse    =    this . r . build (  )  ;", "assertThat ( webResponse . getContentAsString (  )  ,    equalTo (  \" expected   content \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildContent"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . response . addHeader (  \" Content - Type \"  ,     \" text / html ;    charset = UTF -  8  \"  )  ;", "WebResponse   webResponse    =    this . r . build (  )  ;", "assertThat ( webResponse . getContentCharset (  )  ,    equalTo ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["buildContentCharset"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . response . addHeader (  \" Content - Type \"  ,     \" text / html ;    charset - UTF -  8  \"  )  ;", "WebResponse   webResponse    =    this . r . build (  )  ;", "assertThat ( webResponse . getContentType (  )  ,    equalTo (  \" text / html \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildContentType"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . response . addHeader (  \" Content - Type \"  ,     \" text / html \"  )  ;", "this . response . addHeader (  \" X - Test \"  ,     \" value \"  )  ;", "Cookie   cookie    =    new   Cookie (  \" cookieA \"  ,     \" valueA \"  )  ;", "cookie . setDomain (  \" domain \"  )  ;", "cookie . setPath (  \"  / path \"  )  ;", "cookie . setMaxAge (  1  8  0  0  )  ;", "cookie . setSecure ( true )  ;", "cookie . setHttpOnly ( true )  ;", "this . response . addCookie ( cookie )  ;", "WebResponse   webResponse    =    this . r . build (  )  ;", "List < NameValuePair >    responseHeaders    =    webResponse . getResponseHeaders (  )  ;", "assertThat ( responseHeaders . size (  )  ,    equalTo (  3  )  )  ;", "NameValuePair   header    =    responseHeaders . get (  0  )  ;", "assertThat ( header . getName (  )  ,    equalTo (  \" Content - Type \"  )  )  ;", "assertThat ( header . getValue (  )  ,    equalTo (  \" text / html \"  )  )  ;", "header    =    responseHeaders . get (  1  )  ;", "assertThat ( header . getName (  )  ,    equalTo (  \" X - Test \"  )  )  ;", "assertThat ( header . getValue (  )  ,    equalTo (  \" value \"  )  )  ;", "header    =    responseHeaders . get (  2  )  ;", "assertThat ( header . getName (  )  ,    equalTo (  \" Set - Cookie \"  )  )  ;", "assertThat ( header . getValue (  )  ,    startsWith (  \" cookieA = valueA ;    Path =  / path ;    Domain = domain ;    Max - Age =  1  8  0  0  ;    Expires =  \"  )  )  ;", "assertThat ( header . getValue (  )  ,    endsWith (  \"  ;    Secure ;    HttpOnly \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildResponseHeaders"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Cookie   cookie    =    new   Cookie (  \" cookieA \"  ,     \" valueA \"  )  ;", "this . response . addCookie ( cookie )  ;", "WebResponse   webResponse    =    this . r . build (  )  ;", "List < NameValuePair >    responseHeaders    =    webResponse . getResponseHeaders (  )  ;", "assertThat ( responseHeaders . size (  )  ,    equalTo (  1  )  )  ;", "NameValuePair   header    =    responseHeaders . get (  0  )  ;", "assertThat ( header . getName (  )  ,    equalTo (  \" Set - Cookie \"  )  )  ;", "assertThat ( header . getValue (  )  ,    equalTo (  \" cookieA = valueA \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildResponseHeadersNullDomainDefaulted"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "WebResponse   webResponse    =    this . responseBuilder . build (  )  ;", "assertThat ( webResponse . getStatusCode (  )  ,    equalTo (  2  0  0  )  )  ;", "assertThat ( webResponse . getStatusMessage (  )  ,    equalTo (  \" OK \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildStatus"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . response . setStatus (  4  0  1  )  ;", "WebResponse   webResponse    =    this . r . build (  )  ;", "assertThat ( webResponse . getStatusCode (  )  ,    equalTo (  4  0  1  )  )  ;", "assertThat ( webResponse . getStatusMessage (  )  ,    equalTo (  \" Unauthorized \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildStatusNotOk"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . response . sendError (  4  0  1  ,     \" Custom \"  )  ;", "WebResponse   webResponse    =    this . r . build (  )  ;", "assertThat ( webResponse . getStatusCode (  )  ,    equalTo (  4  0  1  )  )  ;", "assertThat ( webResponse . getStatusMessage (  )  ,    equalTo (  \" Custom \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildStatusWithCustomMessage"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "WebResponse   webResponse    =    this . responseBuilder . build (  )  ;", "assertThat ( webResponse . getWebRequest (  )  ,    equalTo ( this . webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["buildWebRequest"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "new   MockWebResponseBuilder (  0 L ,    new   WebRequest ( new   URL (  \" http :  /  / example . com :  8  0  / test / this / here \"  )  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["constructorWithNullResponse"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "new   MockWebResponseBuilder (  0 L ,    null ,    this . response )  ;", "}", "METHOD_END"], "methodName": ["constructorWithNullWebRequest"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . webRequest    =    new   WebRequest ( new   URL (  \" http :  /  / example . com :  8  0  / test / this / here \"  )  )  ;", "this . responseBuilder    =    new    ( System . currentTimeMillis (  )  ,    this . webRequest ,    this . response )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.htmlunit.MockWebResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "WebRequestMatcher   cdnMatcher    =    new   UrlRegexRequestMatcher (  \"  .  *  ?  /  / code . jquery . com /  .  *  \"  )  ;", "assertMatches ( cdnMatcher ,     \" http :  /  / code . jquery . com / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "assertDoesNotMatch ( cdnMatcher ,     \" http :  /  / localhost / jquery -  1  .  1  1  .  0  . min . js \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyExampleInClassLevelJavadoc"], "fileName": "org.springframework.test.web.servlet.htmlunit.UrlRegexRequestMatcherTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this . driver )     !  =    null    ?    this . driver    :    withDelegate ( new   WebConnectionHtmlUnitDriver ( BrowserVersion . CHROME )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilder"}, {"methodBody": ["METHOD_START", "{", "this . javascriptEnabled    =    javascriptEnabled ;", "return   this ;", "}", "METHOD_END"], "methodName": ["javascriptEnabled"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mockMvc ,     \" MockMvc   must   not   be   null \"  )  ;", "return   new    ( mockMvc )  ;", "}", "METHOD_END"], "methodName": ["mockMvcSetup"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( context ,     \" WebApplicationContext   must   not   be   null \"  )  ;", "return   new    ( context )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetup"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( context ,     \" WebApplicationContext   must   not   be   null \"  )  ;", "Assert . notNull ( configurer ,     \" MockMvcConfigurer   must   not   be   null \"  )  ;", "return   new    ( context ,    configurer )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetup"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( driver ,     \" HtmlUnitDriver   must   not   be   null \"  )  ;", "driver . setJavascriptEnabled ( this . javascriptEnabled )  ;", "driver . setWebConnection ( createConnection ( driver . getWebClient (  )  )  )  ;", "this . driver    =    driver ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withDelegate"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilder"}, {"methodBody": ["METHOD_START", "{", "assertThat ( get ( url )  ,    not ( containsString ( MockMvcHtmlUnitDriverBuilderTests . EXPECTED _ BODY )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMockMvcNotUsed"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( get ( url )  ,    containsString ( MockMvcHtmlUnitDriverBuilderTests . EXPECTED _ BODY )  )  ;", "}", "METHOD_END"], "methodName": ["assertMockMvcUsed"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "WebConnectionHtmlUnitDriver   otherDriver    =    new   WebConnectionHtmlUnitDriver (  )  ;", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new    . CookieController (  )  )  . build (  )  ;", "this . driver    =    MockMvcHtmlUnitDriverBuilder . mockMvcSetup ( this . mockMvc )  . withDelegate ( otherDriver )  . build (  )  ;", "assertThat ( get (  \" http :  /  / localhost /  \"  )  ,    equalTo (  \"  \"  )  )  ;", "Cookie   cookie    =    new   Cookie (  \" localhost \"  ,     \" cookie \"  ,     \" cookieManagerShared \"  )  ;", "otherDriver . getWebClient (  )  . getCookieManager (  )  . addCookie ( cookie )  ;", "assertThat ( get (  \" http :  /  / localhost /  \"  )  ,    equalTo (  \" cookieManagerShared \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cookieManagerShared"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . driver . get ( url )  ;", "return   this . driver . getPageSource (  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . driver    =    MockMvcHtmlUnitDriverBuilder . mockMvcSetup ( this . mockMvc )  . javascriptEnabled ( false )  . build (  )  ;", "assertFalse ( this . driver . isJavascriptEnabled (  )  )  ;", "}", "METHOD_END"], "methodName": ["javaScriptDisabled"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . driver    =    MockMvcHtmlUnitDriverBuilder . mockMvcSetup ( this . mockMvc )  . build (  )  ;", "assertTrue ( this . driver . isJavascriptEnabled (  )  )  ;", "}", "METHOD_END"], "methodName": ["javaScriptEnabledByDefault"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcHtmlUnitDriverBuilder . mockMvcSetup ( null )  ;", "}", "METHOD_END"], "methodName": ["mockMvcSetupNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "WebConnectionHtmlUnitDriver   otherDriver    =    new   WebConnectionHtmlUnitDriver (  )  ;", "this . driver    =     . mockMvcSetup ( this . mockMvc )  . withDelegate ( otherDriver )  . build (  )  ;", "assertMockMvcUsed (  \" http :  /  / localhost / test \"  )  ;", "Assume . group ( PERFORMANCE ,     (  )     -  >    assertMockMvcNotUsed (  \" http :  /  / example . com /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mockMvcSetupWithCustomDriverDelegate"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . driver    =    MockMvcHtmlUnitDriverBuilder . mockMvcSetup ( this . mockMvc )  . build (  )  ;", "assertMockMvcUsed (  \" http :  /  / localhost / test \"  )  ;", "Assume . group ( PERFORMANCE ,     (  )     -  >    assertMockMvcNotUsed (  \" http :  /  / example . com /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mockMvcSetupWithDefaultDriverDelegate"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcHtmlUnitDriverBuilder . webAppContextSetup ( null )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetupNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.MockMvcHtmlUnitDriverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   getWebClient (  )  . getWebConnection (  )  ;", "}", "METHOD_END"], "methodName": ["getWebConnection"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.WebConnectionHtmlUnitDriver"}, {"methodBody": ["METHOD_START", "{", "return   webClient ;", "}", "METHOD_END"], "methodName": ["modifyWebClientInternal"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.WebConnectionHtmlUnitDriver"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( webConnection ,     \" WebConnection   must   not   be   null \"  )  ;", "getWebClient (  )  . setWebConnection ( webConnection )  ;", "}", "METHOD_END"], "methodName": ["setWebConnection"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.WebConnectionHtmlUnitDriver"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . driver . getWebConnection (  )  ,    Matchers . notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getWebConnectionDefaultNotNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.WebConnectionHtmlUnitDriverTests"}, {"methodBody": ["METHOD_START", "{", "this . driver . setWebConnection ( this . connection )  ;", "assertThat ( this . driver . getWebConnection (  )  ,    CoreMatchers . equalTo ( this . connection )  )  ;", "this . exception . expect ( WebDriverException . class )  ;", "this . driver . get (  \" https :  /  / example . com \"  )  ;", "}", "METHOD_END"], "methodName": ["setWebConnection"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.WebConnectionHtmlUnitDriverTests"}, {"methodBody": ["METHOD_START", "{", "this . exception . expect ( IllegalArgumentException . class )  ;", "this . driver . set ( null )  ;", "}", "METHOD_END"], "methodName": ["setWebConnectionToNull"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.WebConnectionHtmlUnitDriverTests"}, {"methodBody": ["METHOD_START", "{", "when ( this . connection . getResponse ( any ( WebRequest . class )  )  )  . thenThrow ( new   IOException (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.htmlunit.webdriver.WebConnectionHtmlUnitDriverTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( mediaTypes ,     \"  ' mediaTypes '    must   not   be   empty \"  )  ;", "List < MediaType >    result    =    new   ArrayList <  >  ( mediaTypes . length )  ;", "for    ( St   mediaType    :    mediaTypes )     {", "result . add ( MediaType . parseMediaType ( mediaType )  )  ;", "}", "this . headers . set (  \" Accept \"  ,    MediaType . toSt ( result )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( mediaTypes ,     \"  ' mediaTypes '    must   not   be   empty \"  )  ;", "this . headers . set (  \" Accept \"  ,    MediaType . toSt ( Arrays . asList ( mediaTypes )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "map . forEach (  (    key ,    values )     -  >    values . forEach (  (    value )     -  >     {", "value    =     ( value    !  =    null )     ?    UriUtils . decode ( value ,    StandardCharsets . UTF _  8  )     :    null ;", "addParameter ( UriUtils . decode ( key ,    StandardCharsets . UTF _  8  )  ,    value )  ;", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["addRequestParams"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( name ,     \"  ' name '    must   not   be   empty \"  )  ;", "Assert . notNull ( value ,     \"  ' value '    must   not   be   null \"  )  ;", "map . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addToMap"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( name ,     \"  ' name '    must   not   be   empty \"  )  ;", "Assert . notEmpty ( values ,     \"  ' values '    must   not   be   empty \"  )  ;", "for    ( T   value    :    values )     {", "map . add ( name ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["addToMultiValueMap"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . characterEncoding    =    encoding ;", "return   this ;", "}", "METHOD_END"], "methodName": ["characterEncoding"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( Cookie   cookieToCheck    :    this . cookies )     {", "if    ( ObjectUtils . nullSafeEquals ( cookieToCheck . getN (  )  ,    cookie . getN (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsCookie"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . content    =    content ;", "return   this ;", "}", "METHOD_END"], "methodName": ["content"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . content    =    content . getBytes ( StandardCharsets . UTF _  8  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["content"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . contentType    =    MediaType . parseMediaType ( contentType )  . toString (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( contentType ,     \"  ' contentType '    must   not   be   null \"  )  ;", "this . contentType    =    contentType . toSt (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( contextPath )  )     {", "Assert . isTrue ( contextPath . startsWith (  \"  /  \"  )  ,     \" Context   path   must   start   with   a    '  /  '  \"  )  ;", "Assert . isTrue (  (  !  ( contextPath . endsWith (  \"  /  \"  )  )  )  ,     \" Context   path   must   not   end   with   a    '  /  '  \"  )  ;", "}", "this . contextPath    =    contextPath ;", "return   this ;", "}", "METHOD_END"], "methodName": ["contextPath"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( cookies ,     \"  ' cookies '    must   not   be   empty \"  )  ;", "this . cookies . addAll ( Arrays . asList ( cookies )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["cookie"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequest ( servletContext )  ;", "}", "METHOD_END"], "methodName": ["createServletRequest"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequestBuilder . addToMap ( this . flashAttributes ,    name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["flashAttr"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( flashAttributes ,     \"  ' flashAttributes '    must   not   be   empty \"  )  ;", "flashAttributes . forEach ( this :  : flashAttr )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["flashAttrs"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "FlashMapManager   flashMapManager    =    null ;", "try    {", "ServletContext   servletContext    =    getServletContext (  )  ;", "WebApplicationContext   wac    =    WebApplicationContextUtils . getRequiredWebApplicationContext ( servletContext )  ;", "flashMapManager    =    wac . getBean ( FLASH _ MAP _ MANAGER _ BEAN _ NAME ,    FlashMapManager . class )  ;", "}    catch    ( IllegalStateException    |    NoSuchBeanDefinitionException   ex )     {", "}", "return   flashMapManager    !  =    null    ?    flashMapManager    :    new   SessionFlashMapManager (  )  ;", "}", "METHOD_END"], "methodName": ["getFlashMapManager"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequestBuilder . addToMultiValueMap ( this . headers ,    name ,    values )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "httpHeaders . forEach ( this . headers :  : addAll )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . locales . clear (  )  ;", "if    ( locale    !  =    null )     {", "this . locales . add ( locale )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["locale"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( locales ,     \"  ' locales '    must   not   be   empty \"  )  ;", "this . locales . addAll ( Arrays . asList ( locales )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["locale"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequestBuilder . addToMultiValueMap ( this . parameters ,    name ,    values )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["param"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "params . forEach (  (    name ,    values )     -  >     {", "for    ( St   value    :    values )     {", "this . parameters . add ( name ,    value )  ;", "}", "}  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["params"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "HttpInputMessage   message    =    new   HttpInputMessage (  )     {", "@ Override", "public   InputStream   getBody (  )     {", "return    ( content )     !  =    null    ?    new   ByteArrayInputStream ( content )     :    StreamUtils . emptyInput (  )  ;", "}", "@ Override", "public   HttpHeaders   getHeaders (  )     {", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( mediaType )  ;", "return   headers ;", "}", "}  ;", "try    {", "return   new   FormHttpMessageConverter (  )  . read ( null ,    message )  ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   parse   form   data   in      body \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["parseFormData"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( pathInfo )  )     {", "Assert . isTrue ( pathInfo . startsWith (  \"  /  \"  )  ,     \" Path   info   must   start   with   a    '  /  '  \"  )  ;", "}", "this . pathInfo    =    pathInfo ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pathInfo"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( principal ,     \"  ' principal '    must   not   be   null \"  )  ;", "this . principal    =    principal ;", "return   this ;", "}", "METHOD_END"], "methodName": ["principal"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequestBuilder . addToMap ( this . requestAttributes ,    name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["requestAttr"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . secure    =    secure ;", "return   this ;", "}", "METHOD_END"], "methodName": ["secure"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasTextPath )  )     {", "Assert . isTruePath . startsWith (  \"  /  \"  )  ,     \" Servlet   path   must   start   with   a    '  /  '  \"  )  ;", "Assert . isTrue (  (  ! Path . endsWith (  \"  /  \"  )  )  )  ,     \" Servlet   path   must   not   end   with   a    '  /  '  \"  )  ;", "}", "thisPath    = Path ;", "return   this ;", "}", "METHOD_END"], "methodName": ["servletPath"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( session ,     \"  ' session '    must   not   be   null \"  )  ;", "this . session    =    session ;", "return   this ;", "}", "METHOD_END"], "methodName": ["session"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequestBuilder . addToMap ( this . sessionAttributes ,    name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sessionAttr"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( sessionAttributes ,     \"  ' sessionAttributes '    must   not   be   empty \"  )  ;", "sessionAttributes . forEach ( this :  : sessionAttr )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sessionAttrs"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( requestUri . startsWith ( this . contextPath )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Request   URI    [  \"     +    requestUri )     +     \"  ]    does   not   start   with   context   path    [  \"  )     +     ( this . contextPath )  )     +     \"  ]  \"  )  )  ;", "}", "request . setContextPath ( this . contextPath )  ;", "request . setServletPath ( this . servletPath )  ;", "if    (  \"  \"  . equals ( this . pathInfo )  )     {", "if    (  !  ( requestUri . startsWith (  (  ( this . contextPath )     +     ( this . servletPath )  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Invalid   servlet   path    [  \"     +     ( this . servletPath )  )     +     \"  ]    for   request   URI    [  \"  )     +    requestUri )     +     \"  ]  \"  )  )  ;", "}", "String   extraPath    =    requestUri . substring (  (  ( this . contextPath . length (  )  )     +     ( this . servletPath . length (  )  )  )  )  ;", "this . pathInfo    =     ( StringUtils . hasText ( extraPath )  )     ?     . urlPathHelper . decodeRequestString ( request ,    extraPath )     :    null ;", "}", "request . setPathInfo ( this . pathInfo )  ;", "}", "METHOD_END"], "methodName": ["updatePathRequestProperties"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . builder . accept ( TEXT _ HTML ,    APPLICATION _ XML )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "List < String >    accept    =    Collections . list ( request . getHeaders (  \" Accept \"  )  )  ;", "List < MediaType >    result    =    MediaType . parseMediaTypes ( accept . get (  0  )  )  ;", "assertEquals (  1  ,    accept . size (  )  )  ;", "assertEquals (  \" text / html \"  ,    result . get (  0  )  . toString (  )  )  ;", "assertEquals (  \" application / xml \"  ,    result . get (  1  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptHeader"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   httpMethod    =     \" REPort \"  ;", "URI   url    =    UriComponentsBuilder . fromPath (  \"  / foo /  { bar }  \"  )  . buildAndExpand (  4  2  )  . toUri (  )  ;", "this . builder    =    new    ( httpMethod ,    url )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals ( httpMethod ,    request . getMethod (  )  )  ;", "assertEquals (  \"  / foo /  4  2  \"  ,    request . getPathInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["arbitraryMethod"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "this . builder . content ( body )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( request . getInputStream (  )  )  ;", "assertArrayEquals ( body ,    result )  ;", "}", "METHOD_END"], "methodName": ["body"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   encoding    =     \" UTF -  8  \"  ;", "this . builder . characterEncoding ( encoding )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals ( encoding ,    request . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["characterEncoding"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . contentType ( TEXT _ HTML )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "String   contentType    =    request . getContentType (  )  ;", "List < String >    contentTypes    =    Collections . list ( request . getHeaders (  \" Content - Type \"  )  )  ;", "assertEquals (  \" text / html \"  ,    contentType )  ;", "assertEquals (  1  ,    contentTypes . size (  )  )  ;", "assertEquals (  \" text / html \"  ,    contentTypes . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . header (  \" Content - Type \"  ,    TEXT _ HTML _ VALUE )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "String   contentType    =    request . getContentType (  )  ;", "assertEquals (  \" text / html \"  ,    contentType )  ;", "}", "METHOD_END"], "methodName": ["contentTypeViaHeader"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . header (  \" Content - Type \"  ,    TEXT _ HTML _ VALUE ,    ALL _ VALUE )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \" text / html \"  ,    request . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeViaMultipleHeaderValues"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . contentType (  \" text / html \"  )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "String   contentType    =    request . getContentType (  )  ;", "List < String >    contentTypes    =    Collections . list ( request . getHeaders (  \" Content - Type \"  )  )  ;", "assertEquals (  \" text / html \"  ,    contentType )  ;", "assertEquals (  1  ,    contentTypes . size (  )  )  ;", "assertEquals (  \" text / html \"  ,    contentTypes . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeViaString"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / foo \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  \"  ,    request . getContextPath (  )  )  ;", "assertEquals (  \"  \"  ,    request . getServletPath (  )  )  ;", "assertEquals (  \"  / foo \"  ,    request . getPathInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathEmpty"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / travel / main / hotels /  4  2  \"  )  ;", "this . builder . contextPath (  \"  / travel \"  )  ;", "this . builder . servletPath (  \"  / main \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  / travel \"  ,    request . getContextPath (  )  )  ;", "assertEquals (  \"  / main \"  ,    request . getServletPath (  )  )  ;", "assertEquals (  \"  / hotels /  4  2  \"  ,    request . getPathInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathServletPath"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / travel / hotels /  4  2  \"  )  ;", "this . builder . contextPath (  \"  / travel \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  / travel \"  ,    request . getContextPath (  )  )  ;", "assertEquals (  \"  \"  ,    request . getServletPath (  )  )  ;", "assertEquals (  \"  / hotels /  4  2  \"  ,    request . getPathInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathServletPathEmpty"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  /  \"  )  ;", "this . builder . servletPath (  \"  / index . html \"  )  ;", "this . builder . pathInfo ( null )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  \"  ,    request . getContextPath (  )  )  ;", "assertEquals (  \"  / index . html \"  ,    request . getServletPath (  )  )  ;", "assertNull ( request . getPathInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathServletPathInfo"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / travel / hotels /  4  2  \"  )  ;", "this . builder . contextPath (  \"  / travel \"  )  ;", "this . builder . servletPath (  \"  / hotels /  4  2  \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  / travel \"  ,    request . getContextPath (  )  )  ;", "assertEquals (  \"  / hotels /  4  2  \"  ,    request . getServletPath (  )  )  ;", "assertNull ( request . getPathInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathServletPathInfoEmpty"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "testContextPathServletPathInvalid (  \"  / Foo \"  ,     \"  \"  ,     \" Request   URI    [  / foo / bar ]    does   not   start   with   context   path    [  / Foo ]  \"  )  ;", "testContextPathServletPathInvalid (  \" foo \"  ,     \"  \"  ,     \" Context   path   must   start   with   a    '  /  '  \"  )  ;", "testContextPathServletPathInvalid (  \"  / foo /  \"  ,     \"  \"  ,     \" Context   path   must   not   end   with   a    '  /  '  \"  )  ;", "testContextPathServletPathInvalid (  \"  / foo \"  ,     \"  / Bar \"  ,     \" Invalid   servlet   path    [  / Bar ]    for   request   URI    [  / foo / bar ]  \"  )  ;", "testContextPathServletPathInvalid (  \"  / foo \"  ,     \" bar \"  ,     \" Servlet   path   must   start   with   a    '  /  '  \"  )  ;", "testContextPathServletPathInvalid (  \"  / foo \"  ,     \"  / bar /  \"  ,     \" Servlet   path   must   not   end   with   a    '  /  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["contextPathServletPathInvalid"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Cookie   cookie 1     =    new   Cookie (  \" foo \"  ,     \" bar \"  )  ;", "Cookie   cookie 2     =    new   Cookie (  \" baz \"  ,     \" qux \"  )  ;", "this . builder . cookie ( cookie 1  ,    cookie 2  )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "Cookie [  ]    cookies    =    request . getCookies (  )  ;", "assertEquals (  2  ,    cookies . length )  ;", "assertEquals (  \" foo \"  ,    cookies [  0  ]  . getName (  )  )  ;", "assertEquals (  \" bar \"  ,    cookies [  0  ]  . getValue (  )  )  ;", "assertEquals (  \" baz \"  ,    cookies [  1  ]  . getName (  )  )  ;", "assertEquals (  \" qux \"  ,    cookies [  1  ]  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["cookie"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . flashAttr (  \" foo \"  ,     \" bar \"  )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "FlashMap   flashMap    =    new   SessionFlashMapManager (  )  . retrieveAndUpdate ( request ,    null )  ;", "assertNotNull ( flashMap )  ;", "assertEquals (  \" bar \"  ,    flashMap . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["flashAttribute"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . header (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "List < String >    headers    =    Collections . list ( request . getHeaders (  \" foo \"  )  )  ;", "assertEquals (  2  ,    headers . size (  )  )  ;", "assertEquals (  \" bar \"  ,    headers . get (  0  )  )  ;", "assertEquals (  \" baz \"  ,    headers . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( APPLICATION _ JSON )  ;", "httpHeaders . put (  \" foo \"  ,    Arrays . asList (  \" bar \"  ,     \" baz \"  )  )  ;", "this . builder . headers ( httpHeaders )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "List < String >    headers    =    Collections . list ( request . getHeaders (  \" foo \"  )  )  ;", "assertEquals (  2  ,    headers . size (  )  )  ;", "assertEquals (  \" bar \"  ,    headers . get (  0  )  )  ;", "assertEquals (  \" baz \"  ,    headers . get (  1  )  )  ;", "assertEquals ( APPLICATION _ JSON . toString (  )  ,    request . getHeader (  \" Content - Type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Locale   locale    =    new   Locale (  \" nl \"  ,     \" nl \"  )  ;", "this . builder . locale ( locale )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals ( locale ,    request . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["locale"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "final   String   ATTR    =     \" ATTR \"  ;", "final   String   EXPECTED    =     \" override \"  ;", "MockHttpServletRequestBuilder   defaultBuilder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / foo / bar \"  )  . with (  . requestAttr ( ATTR )  . value (  \" default \"  )  )  . with (  . requestAttr ( ATTR )  . value ( EXPECTED )  )  ;", "builder . merge ( defaultBuilder )  ;", "MockHttpServletRequest   request    =    builder . buildRequest ( servletContext )  ;", "request    =    builder . postProcessRequest ( request )  ;", "assertEquals ( EXPECTED ,    request . getAttribute ( ATTR )  )  ;", "}", "METHOD_END"], "methodName": ["mergeInvokesDefaultRequestPostProcessorFirst"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \" GET \"  ,    request . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertNull ( request . getCookies (  )  )  ;", "}", "METHOD_END"], "methodName": ["noCookies"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / travel / hotels    4  2  \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  / travel / hotels    4  2  \"  ,    request . getPathInfo (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathInfoIsDecoded"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequestBuilderTests . User   user    =    new   MockHttpServletRequestBuilderTests . User (  )  ;", "this . builder . principal ( user )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals ( user ,    request . getUserPrincipal (  )  )  ;", "}", "METHOD_END"], "methodName": ["principal"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilderTests . RequestAttributePostProcessor (  )  . attr ( attrName )  ;", "}", "METHOD_END"], "methodName": ["requestAttr"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . requestAttr (  \" foo \"  ,     \" bar \"  )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \" bar \"  ,    request . getAttribute (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["requestAttribute"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . param (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "Map < String ,    String [  ]  >    parameterMap    =    request . getParameterMap (  )  ;", "assertArrayEquals ( new   String [  ]  {     \" bar \"  ,     \" baz \"     }  ,    parameterMap . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["requestParameter"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    new   LinkedMultiValueMap (  )  ;", "params . add (  \" foo \"  ,     \" bar \"  )  ;", "params . add (  \" foo \"  ,     \" baz \"  )  ;", "this . builder    =    new    ( HttpMethod . POST ,     \"  / foo \"  )  ;", "this . builder . params ( params )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertArrayEquals ( new   String [  ]  {     \" bar \"  ,     \" baz \"     }  ,    request . getParameterMap (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["requestParameterFromMultiValueMap"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  /  ? foo = bar & foo = baz \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "Map < String ,    String [  ]  >    parameterMap    =    request . getParameterMap (  )  ;", "assertArrayEquals ( new   String [  ]  {     \" bar \"  ,     \" baz \"     }  ,    parameterMap . get (  \" foo \"  )  )  ;", "assertEquals (  \" foo = bar & foo = baz \"  ,    request . getQueryString (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestParameterFromQuery"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  /  ? foo [  0  ]  = bar & foo [  1  ]  = baz \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \" foo %  5 B 0  %  5 D = bar & foo %  5 B 1  %  5 D = baz \"  ,    request . getQueryString (  )  )  ;", "assertEquals (  \" bar \"  ,    request . getParameter (  \" foo [  0  ]  \"  )  )  ;", "assertEquals (  \" baz \"  ,    request . getParameter (  \" foo [  1  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["requestParameterFromQueryList"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  /  ? foo \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "Map < String ,    String [  ]  >    parameterMap    =    request . getParameterMap (  )  ;", "assertArrayEquals ( new   String [  ]  {    null    }  ,    parameterMap . get (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    request . getQueryString (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestParameterFromQueryNull"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  /  ? foo =  { value }  \"  ,     \" bar = baz \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \" foo = bar %  3 Dbaz \"  ,    request . getQueryString (  )  )  ;", "assertEquals (  \" bar = baz \"  ,    request . getParameter (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["requestParameterFromQueryWithEncoding"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =     \" application / x - www - form - urlencoded ; charset = UTF -  8  \"  ;", "String   body    =     \" name +  1  = value +  1  & name +  2  = value + A & name +  2  = value + B & name +  3  \"  ;", "MockHttpServletRequest   request    =    new    ( HttpMethod . POST ,     \"  / foo \"  )  . contentType ( contentType )  . content ( body . getBytes ( StandardCharsets . UTF _  8  )  )  . buildRequest ( this . servletContext )  ;", "assertArrayEquals ( new   String [  ]  {     \" value    1  \"     }  ,    request . getParameterMap (  )  . get (  \" name    1  \"  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" value   A \"  ,     \" value   B \"     }  ,    request . getParameterMap (  )  . get (  \" name    2  \"  )  )  ;", "assertArrayEquals ( new   String [  ]  {    null    }  ,    request . getParameterMap (  )  . get (  \" name    3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["requestParameterFromRequestBodyFormData"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / foo # bar \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  / foo \"  ,    request . getRequestURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriAndFragment"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,    new   URI (  \"  / test /  / currentlyValid /  0  \"  )  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  / test /  / currentlyValid /  0  \"  ,    request . getRequestURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriWithDoubleSlashes"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / foo   bar \"  )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \"  / foo %  2  0 bar \"  ,    request . getRequestURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriWithEncoding"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpSession   session    =    new   MockHttpSession ( this . servletContext )  ;", "session . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "this . builder . session ( session )  ;", "this . builder . sessionAttr (  \" baz \"  ,     \" qux \"  )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals ( session ,    request . getSession (  )  )  ;", "assertEquals (  \" bar \"  ,    request . getSession (  )  . getAttribute (  \" foo \"  )  )  ;", "assertEquals (  \" qux \"  ,    request . getSession (  )  . getAttribute (  \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["session"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . sessionAttr (  \" foo \"  ,     \" bar \"  )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \" bar \"  ,    request . getSession (  )  . getAttribute (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sessionAttribute"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "this . builder . sessionAttrs ( map )  ;", "request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \" bar \"  ,    request . getSession (  )  . getAttribute (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sessionAttributes"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  / foo / bar \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . builder . contextPath ( contextPath )  ;", "this . builderPathPath )  ;", "this . builder . buildRequest ( thisContext )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertEquals ( message ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testContextPathServletPathInvalid"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   uri    =     \" https :  /  / com :  8  0  8  0  / javase /  6  / docs / api / java / util / BitSet . html ? foo = bar # and ( BitSet )  \"  ;", "this . builder    =    new    ( HttpMethod . GET ,    uri )  ;", "MockHttpServletRequest   request    =    this . builder . buildRequest ( this . servletContext )  ;", "assertEquals (  \" https \"  ,    request . getScheme (  )  )  ;", "assertEquals (  \" foo = bar \"  ,    request . getQueryString (  )  )  ;", "assertEquals (  \" com \"  ,    request . getServerName (  )  )  ;", "assertEquals (  8  0  8  0  ,    request . getServerPort (  )  )  ;", "assertEquals (  \"  / javase /  6  / docs / api / java / util / BitSet . html \"  ,    request . getRequestURI (  )  )  ;", "assertEquals (  \" https :  /  / com :  8  0  8  0  / javase /  6  / docs / api / java / util / BitSet . html \"  ,    request . getRequestURL (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["uri"], "fileName": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . files . add ( new   MockMultipartFile ( name ,    content )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "this . files . add ( file )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( parts ,     \"  ' parts '    must   not   be   empty \"  )  ;", "for    ( Part   part    :    parts )     {", "this . parts . add ( part . getName (  )  ,    part )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequestBuilder   parent    =    new   MockHttpServletRequestBuilder ( HttpMethod . GET ,     \"  /  \"  )  ;", "parent . characterEncoding (  \" UTF -  8  \"  )  ;", "Object   result    =    new    (  \"  / fileUpload \"  )  . merge ( parent )  ;", "assertNotNull ( result )  ;", "assertEquals (  . class ,    result . getClass (  )  )  ;", "builder    =     (  (  )     ( result )  )  ;", "MockHttpServletRequest   request    =    builder . buildRequest ( new   MockServletContext (  )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    request . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.web.servlet.request.MockMultipartHttpServletRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "mvcResult . getAsyncResult (  )  ;", "return    (    servletContext )     -  >     {", "MockHttpServletRequest    =    mvcResult . getRequest (  )  ;", "setDispatcherType ( ASYNC )  ;", "setAsyncStarted ( false )  ;", "return", "}  ;", "}", "METHOD_END"], "methodName": ["asyncDispatch"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . DELETE ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . DELETE ,    uri )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockMultipartHttpServletRequestBuilder ( urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["fileUpload"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockMultipartHttpServletRequestBuilder ( uri )  ;", "}", "METHOD_END"], "methodName": ["fileUpload"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . GET ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . GET ,    uri )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . HEAD ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["head"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . HEAD ,    uri )  ;", "}", "METHOD_END"], "methodName": ["head"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockMultipartHttpServletRequestBuilder ( urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["multipart"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockMultipartHttpServletRequestBuilder ( uri )  ;", "}", "METHOD_END"], "methodName": ["multipart"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . OPTIONS ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["options"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . OPTIONS ,    uri )  ;", "}", "METHOD_END"], "methodName": ["options"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . PATCH ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["patch"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . PATCH ,    uri )  ;", "}", "METHOD_END"], "methodName": ["patch"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . POST ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["post"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . POST ,    uri )  ;", "}", "METHOD_END"], "methodName": ["post"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . PUT ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( HttpMethod . PUT ,    uri )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( httpMethod ,    uri )  ;", "}", "METHOD_END"], "methodName": ["request"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( method ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["request"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequestBuilder ( httpMethod ,    uri )  ;", "}", "METHOD_END"], "methodName": ["request"], "fileName": "org.springframework.test.web.servlet.request.MockMvcRequestBuilders"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  \" Response   content \"  ,    expectedContent ,    result . getResponse (  )  . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["bytes"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   contentType ( MediaType . parseMediaType ( contentType )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "String   actual    =    getResponse (  )  . getContentType (  )  ;", "AssertionErrors . assertTrue (  \" Content   type   not   set \"  ,     ( actual    !  =    null )  )  ;", "if    ( actual    !  =    null )     {", "AssertionErrors . assertEquals (  \" Content   type \"  ,    contentType ,    MediaType . parseMediaType ( actual )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   contentTypeCompatibleWith ( MediaType . parseMediaType ( contentType )  )  ;", "}", "METHOD_END"], "methodName": ["contentTypeCompatibleWith"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "String   actual    =    getResponse (  )  . getContentType (  )  ;", "AssertionErrors . assertTrue (  \" Content   type   not   set \"  ,     ( actual    !  =    null )  )  ;", "if    ( actual    !  =    null )     {", "MediaType   actualContentType    =    MediaType . parseMediaType ( actual )  ;", "AssertionErrors . assertTrue (  (  (  (  (  \" Content   type    [  \"     +    actual )     +     \"  ]    is   not   compatible   with    [  \"  )     +    contentType )     +     \"  ]  \"  )  ,    actualContentType . isCompatibleWith ( contentType )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["contentTypeCompatibleWith"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "String   actual    =    getResponse (  )  . getCharacterEncoding (  )  ;", "AssertionErrors . assertEquals (  \" Character   encoding \"  ,    characterEncoding ,    actual )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["encoding"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   json ( jsonContent ,    false )  ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "String   content    =    getResponse (  )  . getContentAsString (  )  ;", "jsonHelper . assertJsonEqual ( jsonContent ,    content ,    strict )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "String   content    =    getResponse (  )  . getContentAsString (  )  ;", "xmlHelper . assertNode ( content ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "String   content    =    getResponse (  )  . getContentAsString (  )  ;", "xmlHelper . assertSource ( content ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  \" Response   content \"  ,    expectedContent ,    result . getResponse (  )  . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    assertThat (  \" Response   content \"  ,    result . getResponse (  )  . getContentAsString (  )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "String   content    =    getResponse (  )  . getContentAsString (  )  ;", "xmlHelper . assertXmlEqual ( xmlContent ,    content )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["xml"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchers"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . bytes ( ContentResultMatchersTests . CONTENT . getBytes (  \" UTF -  8  \"  )  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["bytes"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . bytes (  \" bogus \"  . getBytes (  )  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["bytesNoMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . encoding (  \" UTF -  8  \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["encoding"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . encoding (  \" ISO -  8  8  5  9  -  1  \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["encodingNoMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . addHeader (  \" Content - Type \"  ,     \" application / json ;    charset = UTF -  8  \"  )  ;", "response . getWriter (  )  . print ( new   String (  . CONTENT . getBytes (  \" UTF -  8  \"  )  )  )  ;", "return   new   StubMvcResult ( null ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "}", "METHOD_END"], "methodName": ["getStubMvcResult"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . json (  \"  {  \\ n    \\  \" foo \\  \"     :     \\  \" bar \\  \"        \\ n }  \"  )  . match ( getStubMvcResult (  )  )  ;", "new   ContentResultMatchers (  )  . json (  \"  {  \\ n    \\  \" foo \\  \"     :     \\  \" bar \\  \"        \\ n }  \"  ,    false )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonLenientMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . json (  \"  {  \\ n \\  \" fooo \\  \"  :  \\  \" bar \\  \"  \\ n }  \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonLenientNoMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . json (  \"  {  \\ n    \\  \" foo \\  \"  :  \\  \" bar \\  \"  ,           \\  \" foo   array \\  \"  :  [  \\  \" foo \\  \"  ,  \\  \" bar \\  \"  ]     \\ n }  \"  ,    true )  . match ( getStubMvcResult (  )  )  ;", "new   ContentResultMatchers (  )  . json (  \"  {  \\ n    \\  \" foo   array \\  \"  :  [  \\  \" foo \\  \"  ,  \\  \" bar \\  \"  ]  ,     \\  \" foo \\  \"  :  \\  \" bar \\  \"     \\ n }  \"  ,    true )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonStrictMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . json (  \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  ,           \\  \" foo   array \\  \"  :  [  \\  \" bar \\  \"  ,  \\  \" foo \\  \"  ]  }  \"  ,    true )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonStrictNoMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . string ( new   String ( ContentResultMatchersTests . CONTENT . getBytes (  \" UTF -  8  \"  )  )  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =    new   String ( ContentResultMatchersTests . CONTENT . getBytes (  \" UTF -  8  \"  )  )  ;", "new   ContentResultMatchers (  )  . string ( Matchers . equalTo ( content )  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["stringMatcher"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . string ( Matchers . equalTo (  \" bogus \"  )  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["stringMatcherNoMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . encoding (  \" bogus \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["stringNoMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["typeMatches"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   ContentResultMatchers (  )  . contentType (  \" text / plain \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["typeNoMatch"], "fileName": "org.springframework.test.web.servlet.result.ContentResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    comment \"  )  ,    comment ,    cookie . getComment (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["comment"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "assertThat (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    comment \"  )  ,    cookie . getComment (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["comment"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "Cookie   cookie    =    getResponse (  )  . getCookie ( name )  ;", "AssertionErrors . assertTrue (  (  (  \" Unexpected   cookie   with   name    '  \"     +    name )     +     \"  '  \"  )  ,     ( cookie    =  =    null )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    domain \"  )  ,    domain ,    cookie . getDomain (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["domain"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "assertThat (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    domain \"  )  ,    cookie . getDomain (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["domain"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    CookieResultMatchers . getCookie ( result ,    name )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "Cookie   cookie    =    result . getResponse (  )  . getCookie ( name )  ;", "if    ( cookie    =  =    null )     {", "AssertionErrors . fail (  (  (  \" No   cookie   with   name    '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "return   cookie ;", "}", "METHOD_END"], "methodName": ["getCookie"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    httpOnly \"  )  ,    httpOnly ,    cookie . isHttpOnly (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["httpOnly"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    maxAge \"  )  ,    maxAge ,    cookie . getMaxAge (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["maxAge"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "assertThat (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    maxAge \"  )  ,    cookie . getMaxAge (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["maxAge"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    path \"  )  ,    path ,    cookie . getPath (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "assertThat (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    path \"  )  ,    cookie . getPath (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    secure \"  )  ,    secure ,    cookie . getSecure (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["secure"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "AssertionErrors . assertEquals (  \" Response   cookie \"  ,    expectedValue ,    cookie . getValue (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "assertThat (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '  \"  )  ,    cookie . getValue (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    version \"  )  ,    version ,    cookie . getVersion (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["version"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "Cookie   cookie    =     . getCookie ( result ,    name )  ;", "assertThat (  (  (  \" Response   cookie    '  \"     +    name )     +     \"  '    version \"  )  ,    cookie . getVersion (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["version"], "fileName": "org.springframework.test.web.servlet.result.CookieResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  (  \" Flash   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    value ,    result . getFlashMap (  )  . get ( name )  )  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    assertThat (  (  (  \" Flash   attribute    '  \"     +    name )     +     \"  '  \"  )  ,     (  ( T )     ( result . getFlashMap (  )  . get ( name )  )  )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  \" FlashMap   size   must   be    \"     +    count )  ,    count ,    result . getFlashMap (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["attributeCount"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "for    ( String   name    :    names )     {", "AssertionErrors . assertTrue (  (  (  \" Flash   a    '  \"     +    name )     +     \"  '    does   not   exist \"  )  ,     (  ( result . getFlashMap (  )  . get ( name )  )     !  =    null )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["attributeExists"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchers"}, {"methodBody": ["METHOD_START", "{", "new   FlashAttributeResultMatchers (  )  . attribute (  \" good \"  ,     \" good \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   FlashAttributeResultMatchers (  )  . attributeExists (  \" good \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["attributeExists"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   FlashAttributeResultMatchers (  )  . attributeExists (  \" bad \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["attributeExists_doesntExist"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   FlashAttributeResultMatchers (  )  . attribute (  \" good \"  ,     \" not   good \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["attribute_incorrectValue"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "FlashMap   flashMap    =    new   FlashMap (  )  ;", "flashMap . put (  \" good \"  ,     \" good \"  )  ;", "StubMvc   mvc    =    new   StubMvc ( null ,    null ,    null ,    null ,    null ,    flashMap ,    null )  ;", "return   mvc ;", "}", "METHOD_END"], "methodName": ["getStubMvcResult"], "fileName": "org.springframework.test.web.servlet.result.FlashAttributeResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "Object   handler    =    result . getHandler (  )  ;", "AssertionErrors . assertTrue (  \" No   handler \"  ,     ( handler    !  =    null )  )  ;", "if    (  !  ( handler   instanceof   HandlerMethod )  )     {", "AssertionErrors . fail (  (  \" Not   a   HandlerMethod :     \"     +    handler )  )  ;", "}", "return    (  ( HandlerMethod )     ( handler )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerMethod"], "fileName": "org.springframework.test.web.servlet.result.HandlerResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "Object   handler    =    getHandler (  )  ;", "AssertionErrors . assertTrue (  \" No   handler \"  ,     ( handler    !  =    null )  )  ;", "if    ( handler    !  =    null )     {", "Class <  ?  >    actual    =    handler . getClass (  )  ;", "if    ( HandlerMethod . class . isInstance ( handler )  )     {", "actual    =     (  ( HandlerMethod )     ( handler )  )  . getBeanType (  )  ;", "}", "AssertionErrors . assertEquals (  \" Handler   type \"  ,    type ,    ClassUtils . getUserClass ( actual )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["handlerType"], "fileName": "org.springframework.test.web.servlet.result.HandlerResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "HandlerMethod   handlerMethod    =     . getHandlerMethod ( result )  ;", "AssertionErrors . assertEquals (  \" Handler   method \"  ,    method ,    handlerMethod . getMethod (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.test.web.servlet.result.HandlerResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "if    (  !  ( obj   instanceof   MethodInvocationInfo )  )     {", "AssertionErrors . fail ( String . format (  (  \" The   supplied   object    [  % s ]    is   not   an   instance   of    % s .     \"     +     \" Ensure   that   you   invoke   the   handler   method   via   MvcUriComponentsBuilder . on (  )  .  \"  )  ,    obj ,    MethodInvocationInfo . class . getName (  )  )  )  ;", "}", "MethodInvocationInfo   invocationInfo    =     (  ( MethodInvocationInfo )     ( obj )  )  ;", "Method   expected    =    invocationInfo . getControllerMethod (  )  ;", "Method   actual    =     . getHandlerMethod ( result )  . getMethod (  )  ;", "AssertionErrors . assertEquals (  \" Handler   method \"  ,    expected ,    actual )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["methodCall"], "fileName": "org.springframework.test.web.servlet.result.HandlerResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "HandlerMethod   handlerMethod    =     . getHandlerMethod ( result )  ;", "AssertionErrors . assertEquals (  \" Handler   method \"  ,    name ,    handlerMethod . getMethod (  )  . getName (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["methodName"], "fileName": "org.springframework.test.web.servlet.result.HandlerResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "HandlerMethod   handlerMethod    =     . getHandlerMethod ( result )  ;", "assertThat (  \" Handler   method \"  ,    handlerMethod . getMethod (  )  . getName (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["methodName"], "fileName": "org.springframework.test.web.servlet.result.HandlerResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "SimpleDateFormat   format    =    new   SimpleDateFormat (  \" EEE ,    dd   MMM   yyyy   HH : mm : ss   zzz \"  ,    Locale . US )  ;", "format . setTimeZone ( TimeZone . getTimeZone (  \" GMT \"  )  )  ;", "String   formatted    =    format . format ( new   Date ( value )  )  ;", "MockHttpServletResponse   response    =    getResponse (  )  ;", "AssertionErrors . assertTrue (  (  (  \" Response   does   not   contain   header    '  \"     +    name )     +     \"  '  \"  )  ,    response . containsHeader ( name )  )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   header    '  \"     +    name )     +     \"  '  \"  )  ,    formatted ,    response . getHeader ( name )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["dateValue"], "fileName": "org.springframework.test.web.servlet.result.HeaderResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertTrue (  (  (  \" Response   should   not   contain   header    '  \"     +    name )     +     \"  '  \"  )  ,     (  !  ( result . getResponse (  )  . containsHeader ( name )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.servlet.result.HeaderResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertTrue (  (  (  \" Response   should   contain   header    '  \"     +    name )     +     \"  '  \"  )  ,    result . getResponse (  )  . containsHeader ( name )  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.servlet.result.HeaderResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "AssertionErrors . assertTrue (  (  (  \" Response   does   not   contain   header    '  \"     +    name )     +     \"  '  \"  )  ,    response . containsHeader ( name )  )  ;", "String   headerValue    =    response . getHeader ( name )  ;", "if    ( headerValue    !  =    null )     {", "AssertionErrors . assertEquals (  (  (  \" Response   header    '  \"     +    name )     +     \"  '  \"  )  ,    value ,    Long . parseLong ( headerValue )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["longValue"], "fileName": "org.springframework.test.web.servlet.result.HeaderResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  (  \" Response   header    '  \"     +    name )     +     \"  '  \"  )  ,    value ,    result . getResponse (  )  . getHeader ( name )  )  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.servlet.result.HeaderResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    assertThat (  (  (  \" Response   header    '  \"     +    name )     +     \"  '  \"  )  ,    result . getResponse (  )  . getHeader ( name )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.servlet.result.HeaderResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "List < Object >    actual    =    getResponse (  )  . getHeaderValues ( name )  ;", "AssertionErrors . assertEquals (  (  (  \" Response   header    '  \"     +    name )     +     \"  '  \"  )  ,    Arrays . asList ( values )  ,    actual )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["stringValues"], "fileName": "org.springframework.test.web.servlet.result.HeaderResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "List < String >    values    =    getResponse (  )  . getHeaders ( name )  ;", "assertThat (  (  (  \" Response   header    '  \"     +    name )     +     \"  '  \"  )  ,    values ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["stringValues"], "fileName": "org.springframework.test.web.servlet.result.HeaderResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . doesNotExist ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . doesNotHaveJsonPath ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotHaveJsonPath"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . exists ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "String   content    =    result . getResponse (  )  . getContentAsString (  )  ;", "if    ( StringUtils . hasLength ( this . prefix )  )     {", "try    {", "String   reason    =    String . format (  \" Expected   a   JSON   payload   prefixed   with    \\  \"  % s \\  \"    but   found :     % s \"  ,    this . prefix ,    StringUtils . quote ( content . substring (  0  ,    this . prefix . length (  )  )  )  )  ;", "MatcherAssert . assertThat ( reason ,    content ,    StringStartsWith . startsWith ( this . prefix )  )  ;", "return   content . substring ( this . prefix . length (  )  )  ;", "}    catch    ( StringIndexOutOfBoundsException   ex )     {", "throw   new   AssertionError (  (  (  \" JSON   prefix    \\  \"  \"     +     ( this . prefix )  )     +     \"  \\  \"    not   found \"  )  ,    ex )  ;", "}", "} else    {", "return   content ;", "}", "}", "METHOD_END"], "methodName": ["getContent"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . hasJsonPath ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["hasJsonPath"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValueIsArray ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValueIsBoolean ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isBoolean"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValueIsEmpty ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValueIsMap ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isMap"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValueIsNotEmpty ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isNotEmpty"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValueIsNumber ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isNumber"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValueIsString ( getContent ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isString"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "this . prefix    =    prefix ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefix"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValue ( getContent ( result )  ,    expectedValue )  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValue ( getContent ( result )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    jsonPathHelper . assertValue ( getContent ( result )  ,    matcher ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . addHeader (  \" Content - Type \"  ,     \" application / json \"  )  ;", "response . getWriter (  )  . print (  ( jsonPrefix    +     ( new   String (  . RESPONSE _ CONTENT . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  )  )  )  ;", "return   new   StubMvcResult ( null ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "}", "METHOD_END"], "methodName": ["createPrefixedStubMvcResult"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . bogus \"  )  . doesNotExist (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyArray \"  )  . doesNotExist (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistForAnEmptyArray"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyMap \"  )  . doesNotExist (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistForAnEmptyMap"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . doesNotExist (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistNoMatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . exists (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyArray \"  )  . exists (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["existsForAnEmptyArray"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyMap \"  )  . exists (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["existsForAnEmptyMap"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . bogus \"  )  . exists (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["existsNoMatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . arr \"  )  . isArray (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyArray \"  )  . isArray (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isArrayForAnEmptyArray"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . bar \"  )  . isArray (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isArrayNoMatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . bool \"  )  . isBoolean (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isBoolean"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . isBoolean (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isBooleanNoMatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyArray \"  )  . isEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isEmptyForAnEmptyArray"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyMap \"  )  . isEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isEmptyForAnEmptyMap"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyString \"  )  . isEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isEmptyForAnEmptyString"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . colorMap \"  )  . isMap (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isMap"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyMap \"  )  . isMap (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isMapForAnEmptyMap"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . isMap (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isMapNoMatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyArray \"  )  . isNotEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForAnEmptyArray"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyMap \"  )  . isNotEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForAnEmptyMap"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . emptyString \"  )  . isNotEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForAnEmptyString"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . arr \"  )  . isNotEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForArray"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . bool \"  )  . isNotEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForBoolean"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . colorMap \"  )  . isNotEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForMap"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . num \"  )  . isNotEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForNumber"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . isNotEmpty (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNotEmptyForString"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . num \"  )  . isNumber (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNumber"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . isNumber (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isNumberNoMatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . isString (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isString"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . arr \"  )  . isString (  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["isStringNoMatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . addHeader (  \" Content - Type \"  ,     \" application / json \"  )  ;", "response . getWriter (  )  . print ( new   String (  \" test \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  )  ;", "StubMvcResult   result    =    new   StubMvcResult ( null ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "new    (  \"  $  . str \"  )  . prefix (  \" prefix \"  )  . value (  \" foo \"  )  . match ( result )  ;", "}", "METHOD_END"], "methodName": ["prefixWithPayloadNotLongEnough"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . value (  \" foo \"  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["valueWithDirectMatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   jsonPrefix    =     \" prefix \"  ;", "StubMvcResult   result    =    createPrefixedStubMvcResult ( jsonPrefix )  ;", "new    (  \"  $  . str \"  )  . prefix ( jsonPrefix )  . value (  \" foo \"  )  . match ( result )  ;", "}", "METHOD_END"], "methodName": ["valueWithJsonPrefix"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   jsonPrefix    =     \" prefix \"  ;", "StubMvcResult   result    =    createPrefixedStubMvcResult ( jsonPrefix )  ;", "new    (  \"  $  . str \"  )  . value (  \" foo \"  )  . match ( result )  ;", "}", "METHOD_END"], "methodName": ["valueWithJsonPrefixNotConfigured"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   jsonPrefix    =     \" prefix \"  ;", "StubMvcResult   result    =    createPrefixedStubMvcResult ( jsonPrefix )  ;", "new    (  \"  $  . str \"  )  . prefix (  \" wrong \"  )  . value (  \" foo \"  )  . match ( result )  ;", "}", "METHOD_END"], "methodName": ["valueWithJsonWrongPrefix"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . value ( Matchers . equalTo (  \" foo \"  )  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["valueWithMatcher"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . value ( Matchers . equalTo (  \" bogus \"  )  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["valueWithMatcherAndMismatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . num \"  )  . value ( Matchers . equalTo (  5  .  0 F )  ,    Float . class )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["valueWithMatcherAndNumberConversion"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . str \"  )  . value (  \" bogus \"  )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["valueWithMismatch"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   JsonPathResultMatchers (  \"  $  . num \"  )  . value (  5  .  0 F )  . match ( JsonPathResultMatchersTests . stubMvcResult )  ;", "}", "METHOD_END"], "methodName": ["valueWithNumberConversion"], "fileName": "org.springframework.test.web.servlet.result.JsonPathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MockMvcResultHandlers . LoggingResultHandler (  )  ;", "}", "METHOD_END"], "methodName": ["log"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultHandlers"}, {"methodBody": ["METHOD_START", "{", "return   MockMvcResultHandlers . print ( System . out )  ;", "}", "METHOD_END"], "methodName": ["print"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultHandlers"}, {"methodBody": ["METHOD_START", "{", "return   new   MockMvcResultHandlers . PrintWriterPrintingResultHandler ( new   PrintWriter ( stream ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["print"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultHandlers"}, {"methodBody": ["METHOD_START", "{", "return   new   MockMvcResultHandlers . PrintWriterPrintingResultHandler ( new   PrintWriter ( writer ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["print"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultHandlers"}, {"methodBody": ["METHOD_START", "{", "return   new   ContentResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["content"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   CookieResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["cookie"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   FlashAttributeResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["flash"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  \" Forwarded   URL \"  ,    expectedUrl ,    result . getResponse (  )  . getForwardedUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["forwardedUrl"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "AssertionErrors . assertTrue (  \" AntPath   pattern \"  ,     . pathMatcher . isPattern ( urlPattern )  )  ;", "String   url    =    result . getResponse (  )  . getForwardedUrl (  )  ;", "AssertionErrors . assertTrue (  \" Forwarded   URL   does   not   match   the   expected   URL   pattern \"  ,     (  ( url    !  =    null )     &  &     (  . pathMatcher . match ( urlPattern ,    url )  )  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["forwardedUrlPattern"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "String   uri    =    UriComponentsBuilder . fromUriString ( urlTemplate )  . buildAndExpand ( uriVars )  . encode (  )  . toUriString (  )  ;", "return    . forwardedUrl ( uri )  ;", "}", "METHOD_END"], "methodName": ["forwardedUrlTemplate"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["handler"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   HeaderResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathResultMatchers ( expression ,    args )  ;", "}", "METHOD_END"], "methodName": ["jsonPath"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   JsonPathResultMatchers ( expression )  . value ( matcher )  ;", "}", "METHOD_END"], "methodName": ["jsonPath"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["model"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  \" Redirected   URL \"  ,    expectedUrl ,    result . getResponse (  )  . getRedirectedUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectedUrl"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "AssertionErrors . assertTrue (  \" No   Ant - style   path   pattern \"  ,     . pathMatcher . isPattern ( urlPattern )  )  ;", "String   url    =    result . getResponse (  )  . getRedirectedUrl (  )  ;", "AssertionErrors . assertTrue (  \" Redirected   URL   does   not   match   the   expected   URL   pattern \"  ,     (  ( url    !  =    null )     &  &     (  . pathMatcher . match ( urlPattern ,    url )  )  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["redirectedUrlPattern"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "String   uri    =    UriComponentsBuilder . fromUriString ( urlTemplate )  . buildAndExpand ( uriVars )  . encode (  )  . toUriString (  )  ;", "return    . redirectedUrl ( uri )  ;", "}", "METHOD_END"], "methodName": ["redirectedUrlTemplate"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["request"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   StatusResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   ViewResultMatchers (  )  ;", "}", "METHOD_END"], "methodName": ["view"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathResultMatchers ( expression ,    null ,    args )  ;", "}", "METHOD_END"], "methodName": ["xpath"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   XpathResultMatchers ( expression ,    namespaces ,    args )  ;", "}", "METHOD_END"], "methodName": ["xpath"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchers"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . forwardedUrl (  \"  / api / resource /  1  \"  )  . match ( getForwardedUrlStubMvcResult (  \"  / api / resource /  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forward"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . forwardedUrlPattern (  \"  / api /  *  *  /  ?  \"  )  . match ( getForwardedUrlStubMvcResult (  \"  / api / resource /  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forwardWithMatchingPattern"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . forwardedUrlPattern (  \"  / resource /  \"  )  . match ( getForwardedUrlStubMvcResult (  \"  / resource /  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forwardWithNonMatchingPattern"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . forwardedUrl (  \"  / api / resource /  1  ? arg = value \"  )  . match ( getForwardedUrlStubMvcResult (  \"  / api / resource /  1  ? arg = value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forwardWithQueryString"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . forwardedUrlTemplate (  \"  / orders /  { orderId }  / items /  { itemId }  \"  ,     1  ,     2  )  . match ( getForwardedUrlStubMvcResult (  \"  / orders /  1  / items /  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forwardWithUrlTemplate"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . setForwardedUrl ( forwardedUrl )  ;", "Stub   mvcResult    =    new   Stub ( null ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "return   mvcResult ;", "}", "METHOD_END"], "methodName": ["getForwardedUrlStubMvcResult"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . sendRedirect ( redirectUrl )  ;", "Stub   mvcResult    =    new   Stub ( null ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "return   mvcResult ;", "}", "METHOD_END"], "methodName": ["getRedirectedUrlStubMvcResult"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . redirectedUrl (  \"  / resource /  1  \"  )  . match ( getRedirectedUrlStubMvcResult (  \"  / resource /  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["redirect"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . redirectedUrlPattern (  \"  / resource /  *  \"  )  . match ( getRedirectedUrlStubMvcResult (  \"  / resource /  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectWithMatchingPattern"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . redirectedUrlPattern (  \"  / resource /  \"  )  . match ( getRedirectedUrlStubMvcResult (  \"  / resource /  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectWithNonMatchingPattern"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcResultMatchers . redirectedUrlTemplate (  \"  / orders /  { orderId }  / items /  { itemId }  \"  ,     1  ,     2  )  . match ( getRedirectedUrlStubMvcResult (  \"  / orders /  1  / items /  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectWithUrlTemplate"], "fileName": "org.springframework.test.web.servlet.result.MockMvcResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "ModelAndView   mav    =    getModelAndView ( result )  ;", "AssertionErrors . assertEquals (  (  (  \" Model   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    value ,    mav . getModel (  )  . get ( name )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "ModelAndView   mav    =    getModelAndView ( result )  ;", "assertThat (  (  (  \" Model   attribute    '  \"     +    name )     +     \"  '  \"  )  ,     (  ( T )     ( mav . getModel (  )  . get ( name )  )  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "ModelAndView   mav    =    getModelAndView ( result )  ;", "for    ( String   name    :    names )     {", "AssertionErrors . assertTrue (  (  (  \" Model   attribute    '  \"     +    name )     +     \"  '    exists \"  )  ,     (  ( mav . getModel (  )  . get ( name )  )     =  =    null )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["attributeDoesNotExist"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "ModelAndView   mav    =    getModelAndView ( result )  ;", "Errors   errors    =    getBindingResult ( mav ,    name )  ;", "AssertionErrors . assertEquals (  (  (  \" Binding / validation   error   count   for   attribute    '  \"     +    name )     +     \"  '  ,     \"  )  ,    expectedCount ,    errors . getErrorCount (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["attributeErrorCount"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "ModelAndView   mav    =    getModelAndView ( result )  ;", "for    ( String   name    :    names )     {", "AssertionErrors . assertTrue (  (  (  \" Model   attribute    '  \"     +    name )     +     \"  '    does   not   exist \"  )  ,     (  ( mav . getModel (  )  . get ( name )  )     !  =    null )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["attributeExists"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    mvcResult )     -  >     {", "ModelAndView   mav    =    getModelAndView ( mvcResult )  ;", "for    ( String   name    :    names )     {", "BindingResult    =    getBindingResult ( mav ,    name )  ;", "AssertionErrors . assertTrue (  (  (  \" No   errors   for   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    hasErrors (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["attributeHasErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    mvcResult )     -  >     {", "ModelAndView   mav    =    getModelAndView ( mvcResult )  ;", "BindingResult    =    getBindingResult ( mav ,    name )  ;", "AssertionErrors . assertTrue (  (  (  \" No   errors   for   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    hasErrors (  )  )  ;", "FieldError   fieldError    =    getFieldError ( fieldName )  ;", "if    ( fieldError    =  =    null )     {", "AssertionErrors . fail (  (  (  (  (  \" No   errors   for   field    '  \"     +    fieldName )     +     \"  '    of   attribute    '  \"  )     +    name )     +     \"  '  \"  )  )  ;", "}", "String   code    =    fieldError . getCode (  )  ;", "AssertionErrors . assertTrue (  (  (  (  (  \" Expected   error   code    '  \"     +    error )     +     \"  '    but   got    '  \"  )     +    code )     +     \"  '  \"  )  ,    error . equals ( code )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrorCode"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    mvcResult )     -  >     {", "ModelAndView   mav    =    getModelAndView ( mvcResult )  ;", "BindingResult    =    getBindingResult ( mav ,    name )  ;", "AssertionErrors . assertTrue (  (  (  \" No   errors   for   attribute :     [  \"     +    name )     +     \"  ]  \"  )  ,    hasErrors (  )  )  ;", "FieldError   fieldError    =    getFieldError ( fieldName )  ;", "if    ( fieldError    =  =    null )     {", "AssertionErrors . fail (  (  (  (  (  \" No   errors   for   field    '  \"     +    fieldName )     +     \"  '    of   attribute    '  \"  )     +    name )     +     \"  '  \"  )  )  ;", "}", "String   code    =    fieldError . getCode (  )  ;", "assertThat (  (  (  (  (  \" Field   name    '  \"     +    fieldName )     +     \"  '    of   attribute    '  \"  )     +    name )     +     \"  '  \"  )  ,    code ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrorCode"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    mvcResult )     -  >     {", "ModelAndView   mav    =    getModelAndView ( mvcResult )  ;", "BindingResult    =    getBindingResult ( mav ,    name )  ;", "AssertionErrors . assertTrue (  (  (  \" No   errors   for   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    hasErrors (  )  )  ;", "for    ( final   String   fieldName    :    fieldNames )     {", "boolean   hasFieldErrors    =    hasFieldErrors ( fieldName )  ;", "AssertionErrors . assertTrue (  (  (  (  (  \" No   errors   for   field    '  \"     +    fieldName )     +     \"  '    of   attribute    '  \"  )     +    name )     +     \"  '  \"  )  ,    hasFieldErrors )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    mvcResult )     -  >     {", "ModelAndView   mav    =    getModelAndView ( mvcResult )  ;", "for    ( String   name    :    names )     {", "BindingResult    =    getBindingResult ( mav ,    name )  ;", "AssertionErrors . assertTrue (  (  (  (  \" Unexpected   errors   for   attribute    '  \"     +    name )     +     \"  '  :     \"  )     +     ( getAllErrors (  )  )  )  ,     (  !  ( hasErrors (  )  )  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["attributeHasNoErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "int   actualCount    =    getErrorCount ( getModelAndView ( result )  . getModelMap (  )  )  ;", "AssertionErrors . assertEquals (  \" Binding / validation   error   count \"  ,    expectedCount ,    actualCount )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["errorCount"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "BindingResult   result    =     (  ( BindingResult )     ( mav . getModel (  )  . get (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +    name )  )  )  )  ;", "if    ( result    =  =    null )     {", "AssertionErrors . fail (  (  \" No   BindingResult   for   attribute :     \"     +    name )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getBindingResult"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    ( Object   value    :    m . values (  )  )     {", "if    ( value   instanceof   Errors )     {", "count    +  =     (  ( Errors )     ( value )  )  . getErrorCount (  )  ;", "}", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["getErrorCount"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "ModelAndView   mav    =    mvcResult . getModelAndView (  )  ;", "if    ( mav    =  =    null )     {", "AssertionErrors . fail (  \" No   ModelAndView   found \"  )  ;", "}", "return   mav ;", "}", "METHOD_END"], "methodName": ["getModelAndView"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "int   count    =    getErrorCount ( getModelAndView ( result )  . getModelMap (  )  )  ;", "AssertionErrors . assertTrue (  \" Expected   binding / validation   errors \"  ,     ( count    !  =     0  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["hasErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "ModelAndView   mav    =    getModelAndView ( result )  ;", "for    ( Object   value    :    mav . getModel (  )  . values (  )  )     {", "if    ( value   instanceof   Errors )     {", "AssertionErrors . assertTrue (  (  \" Unexpected   binding / validation   errors :     \"     +    value )  ,     (  !  (  (  ( Errors )     ( value )  )  . hasErrors (  )  )  )  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["hasNoErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "ModelAndView   mav    =    getModelAndView ( result )  ;", "int   actual    =     0  ;", "for    ( String   key    :    mav . getModel (  )  . keySet (  )  )     {", "if    (  !  ( key . startsWith ( MODEL _ KEY _ PREFIX )  )  )     {", "actual +  +  ;", "}", "}", "AssertionErrors . assertEquals (  \" Model   size \"  ,    size ,    actual )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchers"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeDoesNotExist (  \" bad \"  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["attributeDoesNotExist"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeDoesNotExist (  \" good \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeDoesNotExist_doesExist"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeExists (  \" good \"  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["attributeExists"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeExists (  \" bad \"  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["attributeExists_doesNotExist"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasErrors (  \" date \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasErrors (  \" good \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasErrors_withoutErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasFieldErrorCode (  \" date \"  ,     \" time \"  ,     \" error \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrorCode"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasFieldErrorCode (  \" date \"  ,     \" time \"  ,    startsWith (  \" err \"  )  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrorCode_startsWith"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasFieldErrorCode (  \" date \"  ,     \" time \"  ,    startsWith (  \" inc \"  )  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrorCode_startsWith_withoutErrorOnField"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasFieldErrorCode (  \" date \"  ,     \" time \"  ,     \" incorrectError \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrorCode_withoutErrorOnField"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasFieldErrors (  \" date \"  ,     \" time \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasFieldErrors (  \" missing \"  ,     \" bad \"  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrors_withoutAttribute"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasFieldErrors (  \" date \"  ,     \" time \"  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrors_withoutErrorsForAttribute"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasFieldErrors (  \" date \"  ,     \" good \"  ,     \" time \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasFieldErrors_withoutErrorsForField"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasNoErrors (  \" good \"  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["attributeHasNoErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasNoErrors (  \" date \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasNoErrors_withErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attributeHasNoErrors (  \" missing \"  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["attributeHasNoErrors_withoutAttribute"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attribute (  \" good \"  ,    is (  \" good \"  )  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["attribute_equal"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . attribute (  \" good \"  ,    is (  \" bad \"  )  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["attribute_notEqual"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "return   new   StubMvcResult ( null ,    null ,    null ,    null ,    modelAndView ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["getMvcResult"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . hasNoErrors (  )  . match ( this . mvcResult )  ;", "}", "METHOD_END"], "methodName": ["hasNoErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers . hasNoErrors (  )  . match ( this . mvcResultWithError )  ;", "}", "METHOD_END"], "methodName": ["hasNoErrors_withErrors"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers    =    new   ModelResultMatchers (  )  ;", "ModelAndView   mav    =    new   ModelAndView (  \" view \"  ,     \" good \"  ,     \" good \"  )  ;", "BindingResult   bindingResult    =    new   BeanPropertyBindingResult (  \" good \"  ,     \" good \"  )  ;", "mav . addObject (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +     \" good \"  )  ,    bindingResult )  ;", "this . mvcResult    =    getMvcResult ( mav )  ;", "Date   date    =    new   Date (  )  ;", "BindingResult   bindingResultWithError    =    new   BeanPropertyBindingResult ( date ,     \" date \"  )  ;", "bindingResultWithError . rejectValue (  \" time \"  ,     \" error \"  )  ;", "ModelAndView   mavWithError    =    new   ModelAndView (  \" view \"  ,     \" good \"  ,     \" good \"  )  ;", "mavWithError . addObject (  \" date \"  ,    date )  ;", "mavWithError . addObject (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +     \" date \"  )  ,    bindingResultWithError )  ;", "this . mvcResultWithError    =    getMvcResult ( mavWithError )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.servlet.result.ModelResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String [  ]  >    params    =    request . getParameterMap (  )  ;", "MultiValueMap < String ,    String >    multiValueMap    =    new   util . LinkedMultiValueMap (  )  ;", "params . forEach (  (    name ,    values )     -  >     {", "if    (  ( params . get ( name )  )     !  =    null )     {", "for    ( String   value    :    values )     {", "multiValueMap . add ( name ,    value )  ;", "}", "}", "}  )  ;", "return   multiValueMap ;", "}", "METHOD_END"], "methodName": ["getParamsMultiValueMap"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . printer ;", "}", "METHOD_END"], "methodName": ["getPrinter"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "Enumeration <  ?  >    names    =    requgetHeaderNames (  )  ;", "while    ( names . hasMoreElements (  )  )     {", "String   name    =     (  ( String )     ( names . nextElement (  )  )  )  ;", "Enumeration < String >    values    =    requgetHeaders ( name )  ;", "while    ( values . hasMoreElements (  )  )     {", "headers . add ( name ,    values . nextElement (  )  )  ;", "}", "}", "return   headers ;", "}", "METHOD_END"], "methodName": ["getRequestHeaders"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "for    ( St   name    :    response . getHeaderNames (  )  )     {", "headers . put ( name ,    response . getHeaders ( name )  )  ;", "}", "return   headers ;", "}", "METHOD_END"], "methodName": ["getResponseHeaders"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "HttpSession   session    =    request . getSession ( false )  ;", "if    ( session    !  =    null )     {", "Enumeration < String >    attrNames    =    session . getAttributeNames (  )  ;", "if    ( attrNames    !  =    null )     {", "return   Collections . list ( attrNames )  . stream (  )  . collect ( Collectors . toMap (  (    n )     -  >    n ,    session :  : getAttribute )  )  ;", "}", "}", "return   Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getSessionAttributes"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    result . getRequest (  )  ;", "this . printer . printValue (  \" Async   started \"  ,    request . isAsyncStarted (  )  )  ;", "Object   asyncResult    =    null ;", "try    {", "asyncResult    =    result . getAsyncResult (  0  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "this . printer . printValue (  \" Async   result \"  ,    asyncResult )  ;", "}", "METHOD_END"], "methodName": ["printAsyncResult"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "String [  ]    cookieStrings    =    new   String [ cookies . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( cookies . length )  ;    i +  +  )     {", "Cookie   cookie    =    cookies [ i ]  ;", "cookieStrings [ i ]     =    new   core . style . ToStringCreator ( cookie )  . append (  \" name \"  ,    cookie . getName (  )  )  . append (  \" value \"  ,    cookie . getValue (  )  )  . append (  \" comment \"  ,    cookie . getComment (  )  )  . append (  \" domain \"  ,    cookie . getDomain (  )  )  . append (  \" maxAge \"  ,    cookie . getMaxAge (  )  )  . append (  \" path \"  ,    cookie . getPath (  )  )  . append (  \" secure \"  ,    cookie . getSecure (  )  )  . append (  \" version \"  ,    cookie . getVersion (  )  )  . append (  \" httpOnly \"  ,    cookie . isHttpOnly (  )  )  . toString (  )  ;", "}", "this . printer . printValue (  \" Cookies \"  ,    cookieStrings )  ;", "}", "METHOD_END"], "methodName": ["printCookies"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( flashMap )  )     {", "this . ter . tValue (  \" Attributes \"  ,    null )  ;", "} else    {", "flashMap . forEach (  (    name ,    value )     -  >     {", "this . ter . tValue (  \" Attribute \"  ,    name )  ;", "this . ter . tValue (  \" value \"  ,    value )  ;", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["printFlashMap"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( handler    =  =    null )     {", "this . printer . printValue (  \" Type \"  ,    null )  ;", "} else    {", "if    ( handler   instanceof   Method )     {", "Method   handlerMethod    =     (  ( Method )     ( handler )  )  ;", "this . printer . printValue (  \" Type \"  ,    handlerMethod . getBeanType (  )  . getName (  )  )  ;", "this . printer . printValue (  \" Method \"  ,    handlerMethod )  ;", "} else    {", "this . printer . printValue (  \" Type \"  ,    handler . getClass (  )  . getName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printHandler"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "this . printer . printValue (  \" View   name \"  ,     ( mav    !  =    null    ?    mav . getViewName (  )     :    null )  )  ;", "this . printer . printValue (  \" View \"  ,     ( mav    !  =    null    ?    mav . getView (  )     :    null )  )  ;", "if    (  ( mav    =  =    null )     |  |     (  ( mav . getModel (  )  . size (  )  )     =  =     0  )  )     {", "this . printer . printValue (  \" Model \"  ,    null )  ;", "} else    {", "for    ( String   name    :    mav . getModel (  )  . keySet (  )  )     {", "if    (  !  ( name . startsWith ( MODEL _ KEY _ PREFIX )  )  )     {", "Object   value    =    mav . getModel (  )  . get ( name )  ;", "this . printer . printValue (  \" Attribute \"  ,    name )  ;", "this . printer . printValue (  \" value \"  ,    value )  ;", "Errors   errors    =     (  ( Errors )     ( mav . getModel (  )  . get (  (  ( Bind . MODEL _ KEY _ PREFIX )     +    name )  )  )  )  ;", "if    ( errors    !  =    null )     {", "this . printer . printValue (  \" errors \"  ,    errors . getAllErrors (  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["printModelAndView"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "String   body    =     (  ( request . getCharacterEncoding (  )  )     !  =    null )     ?    request . getContentAsString (  )     :    PrintingResultHandler . MISSING _ CHARACTER _ ENCODING ;", "this . printer . printValue (  \" HTTP   Method \"  ,    request . getMethod (  )  )  ;", "this . printer . printValue (  \" Request   URI \"  ,    request . getRequestURI (  )  )  ;", "this . printer . printValue (  \" Parameters \"  ,    getParamsMultiValueMap ( request )  )  ;", "this . printer . printValue (  \" Headers \"  ,    getRequestHeaders ( request )  )  ;", "this . printer . printValue (  \" Body \"  ,    body )  ;", "this . printer . printValue (  \" Session   Attrs \"  ,    getSessionAttributes ( request )  )  ;", "}", "METHOD_END"], "methodName": ["printRequest"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( resolvedException    =  =    null )     {", "this . ter . tValue (  \" Type \"  ,    null )  ;", "} else    {", "this . ter . tValue (  \" Type \"  ,    resolvedException . getClass (  )  . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["printResolvedException"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "String   body    =     (  ( response . getCharacterEncoding (  )  )     !  =    null )     ?    response . getContentAsString (  )     :    PrintingResultHandler . MISSING _ CHARACTER _ ENCODING ;", "this . printer . printValue (  \" Status \"  ,    response . getStatus (  )  )  ;", "this . printer . printValue (  \" Error   message \"  ,    response . getErrorMessage (  )  )  ;", "this . printer . printValue (  \" Headers \"  ,    getResponseHeaders ( response )  )  ;", "this . printer . printValue (  \" Content   type \"  ,    response . getContentType (  )  )  ;", "this . printer . printValue (  \" Body \"  ,    body )  ;", "this . printer . printValue (  \" Forwarded   URL \"  ,    response . getForwardedUrl (  )  )  ;", "this . printer . printValue (  \" Redirected   URL \"  ,    response . getRedirectedUrl (  )  )  ;", "printCookies ( response . getCookies (  )  )  ;", "}", "METHOD_END"], "methodName": ["printResponse"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandler"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Map < String ,    Object >  >    printedValues    =    this . handler . getPrinter (  )  . printedValues ;", "assertTrue (  (  (  \" Heading    '  \"     +    heading )     +     \"  '    not   printed \"  )  ,    printedValues . containsKey ( heading )  )  ;", "assertEquals (  (  (  (  (  \" For   label    '  \"     +    label )     +     \"  '    under   heading    '  \"  )     +    heading )     +     \"  '     =  >  \"  )  ,    value ,    printedValues . get ( heading )  . get ( label )  )  ;", "}", "METHOD_END"], "methodName": ["assertValue"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "FlashMap   flashMap    =    new   FlashMap (  )  ;", "flashMap . put (  \" attrName \"  ,     \" attrValue \"  )  ;", "this . request . setAttribute (  (  ( DispatcherSclass . getName (  )  )     +     \"  . OUTPUT _ FLASH _ MAP \"  )  ,    flashMap )  ;", "this . handler . handle ( this . mvcResult )  ;", "assertValue (  \" FlashMap \"  ,     \" Attribute \"  ,     \" attrName \"  )  ;", "assertValue (  \" FlashMap \"  ,     \" value \"  ,     \" attrValue \"  )  ;", "}", "METHOD_END"], "methodName": ["flashMap"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . handle ( mvcResult )  ;", "assertValue (  \" FlashMap \"  ,     \" Type \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["flashMapNull"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BindException   bindException    =    new   BindException ( new   Object (  )  ,     \" target \"  )  ;", "bindException . reject (  \" errorCode \"  )  ;", "ModelAndView   mav    =    new   ModelAndView (  \" viewName \"  )  ;", "mav . addObject (  \" attrName \"  ,     \" attrValue \"  )  ;", "mav . addObject (  (  ( Bind . MODEL _ KEY _ PREFIX )     +     \" attrName \"  )  ,    bindException )  ;", "this . mvcResult . setMav ( mav )  ;", "this . handler . handle ( this . mvcResult )  ;", "assertValue (  \" ModelAndView \"  ,     \" View   name \"  ,     \" viewName \"  )  ;", "assertValue (  \" ModelAndView \"  ,     \" View \"  ,    null )  ;", "assertValue (  \" ModelAndView \"  ,     \" Attribute \"  ,     \" attrName \"  )  ;", "assertValue (  \" ModelAndView \"  ,     \" value \"  ,     \" attrValue \"  )  ;", "assertValue (  \" ModelAndView \"  ,     \" errors \"  ,    bindException . getAllErrors (  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAndView"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . handle ( this . mvcResult )  ;", "assertValue (  \" ModelAndView \"  ,     \" View   name \"  ,    null )  ;", "assertValue (  \" ModelAndView \"  ,     \" View \"  ,    null )  ;", "assertValue (  \" ModelAndView \"  ,     \" Model \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["modelAndViewNull"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . mvcResult . setHandler ( new   Object (  )  )  ;", "this . handler . handle ( this . mvcResult )  ;", "assertValue (  \" Handler \"  ,     \" Type \"  ,    Object . class . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["printHandler"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( this ,     \" handle \"  )  ;", "this . mvcResult . se ( handlerMethod )  ;", "this . handler . handle ( mvcResult )  ;", "assertValue (  \" Handler \"  ,     \" Type \"  ,    this . getClass (  )  . getName (  )  )  ;", "assertValue (  \" Handler \"  ,     \" Method \"  ,    handlerMethod )  ;", "}", "METHOD_END"], "methodName": ["printHandlerMethod"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StubMvcResult   mvcResult    =    new   StubMvcResult ( this . request ,    null ,    null ,    null ,    null ,    null ,    this . response )  ;", "this . handler . handle ( mvcResult )  ;", "assertValue (  \"  \"  ,     \" Type \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["printHandlerNull"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addParameter (  \" param \"  ,     \" paramValue \"  )  ;", "this . request . addHeader (  \" header \"  ,     \" headerValue \"  )  ;", "this . request . setCharacterEncoding (  \" UTF -  1  6  \"  )  ;", "String   palindrome    =     \" ablE   was   I   ere   I   saw   Elba \"  ;", "byte [  ]    bytes    =    palindrome . getBytes (  \" UTF -  1  6  \"  )  ;", "this . request . setContent ( bytes )  ;", "this . request . getSession (  )  . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "this . handler . handle ( this . mvcResult )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . set (  \" header \"  ,     \" headerValue \"  )  ;", "MultiValueMap < String ,    String >    params    =    new   util . LinkedMultiValueMap (  )  ;", "params . add (  \" param \"  ,     \" paramValue \"  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" HTTP   Method \"  ,    this . request . getMethod (  )  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Request   URI \"  ,    this . request . getRequestURI (  )  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Parameters \"  ,    params )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Headers \"  ,    headers )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Body \"  ,    palindrome )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Session   Attrs \"  ,    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["printRequest"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setCharacterEncoding (  \" UTF -  8  \"  )  ;", "this . request . setContent (  \" text \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "this . h . handle ( this . mvcResult )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Body \"  ,     \" text \"  )  ;", "}", "METHOD_END"], "methodName": ["printRequestWithCharacterEncoding"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addParameter (  \" param \"  ,     \" paramValue \"  )  ;", "this . request . addHeader (  \" header \"  ,     \" headerValue \"  )  ;", "this . request . setCharacterEncoding (  \" UTF -  1  6  \"  )  ;", "String   palindrome    =     \" ablE   was   I   ere   I   saw   Elba \"  ;", "byte [  ]    bytes    =    palindrome . getBytes (  \" UTF -  1  6  \"  )  ;", "this . request . setContent ( bytes )  ;", "this . request . setSession ( Mockito . mock ( HttpSession . class )  )  ;", "this . handler . handle ( this . mvcResult )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . set (  \" header \"  ,     \" headerValue \"  )  ;", "MultiValueMap < String ,    String >    params    =    new   util . LinkedMultiValueMap (  )  ;", "params . add (  \" param \"  ,     \" paramValue \"  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" HTTP   Method \"  ,    this . request . getMethod (  )  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Request   URI \"  ,    this . request . getRequestURI (  )  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Parameters \"  ,    params )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Headers \"  ,    headers )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Body \"  ,    palindrome )  ;", "}", "METHOD_END"], "methodName": ["printRequestWithEmptySessionMock"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . handle ( this . mvcResult )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Body \"  ,     \"  < no   character   encoding   set >  \"  )  ;", "}", "METHOD_END"], "methodName": ["printRequestWithoutCharacterEncoding"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addParameter (  \" param \"  ,     \" paramValue \"  )  ;", "this . request . addHeader (  \" header \"  ,     \" headerValue \"  )  ;", "this . request . setCharacterEncoding (  \" UTF -  1  6  \"  )  ;", "String   palindrome    =     \" ablE   was   I   ere   I   saw   Elba \"  ;", "byte [  ]    bytes    =    palindrome . getBytes (  \" UTF -  1  6  \"  )  ;", "this . request . setContent ( bytes )  ;", "this . handler . handle ( this . mvcResult )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . set (  \" header \"  ,     \" headerValue \"  )  ;", "MultiValueMap < String ,    String >    params    =    new   util . LinkedMultiValueMap (  )  ;", "params . add (  \" param \"  ,     \" paramValue \"  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" HTTP   Method \"  ,    this . request . getMethod (  )  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Request   URI \"  ,    this . request . getRequestURI (  )  )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Parameters \"  ,    params )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Headers \"  ,    headers )  ;", "assertValue (  \" MockHttpServletRequest \"  ,     \" Body \"  ,    palindrome )  ;", "}", "METHOD_END"], "methodName": ["printRequestWithoutSession"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Cookie   enigmaCookie    =    new   Cookie (  \" enigma \"  ,     \"  4  2  \"  )  ;", "enigmaCookie . setComment (  \" This   is   a   comment \"  )  ;", "enigmaCookie . setHttpOnly ( true )  ;", "enigmaCookie . setMaxAge (  1  2  3  4  )  ;", "enigmaCookie . setDomain (  \"  . example . com \"  )  ;", "enigmaCookie . setPath (  \"  / crumbs \"  )  ;", "enigmaCookie . setSecure ( true )  ;", "this . response . setStatus (  4  0  0  ,     \" error \"  )  ;", "this . response . addHeader (  \" header \"  ,     \" headerValue \"  )  ;", "this . response . setContentType (  \" text / plain \"  )  ;", "this . response . getWriter (  )  . print (  \" content \"  )  ;", "this . response . setForwardedUrl (  \" redirectFoo \"  )  ;", "this . response . sendRedirect (  \"  / redirectFoo \"  )  ;", "this . response . addCookie ( new   Cookie (  \" cookie \"  ,     \" cookieValue \"  )  )  ;", "this . response . addCookie ( enigmaCookie )  ;", "this . h . handle ( this . mvcResult )  ;", "List < String >    cookieValues    =    this . response . getHeaders (  \" Set - Cookie \"  )  ;", "assertEquals (  2  ,    cookieValues . size (  )  )  ;", "assertEquals (  \" cookie = cookieValue \"  ,    cookieValues . get (  0  )  )  ;", "assertTrue (  (  \" Actual :     \"     +     ( cookieValues . get (  1  )  )  )  ,    cookieValues . get (  1  )  . startsWith (  \" enigma =  4  2  ;    Path =  / crumbs ;    Domain =  . example . com ;    Max - Age =  1  2  3  4  ;    Expires =  \"  )  )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . set (  \" header \"  ,     \" headerValue \"  )  ;", "headers . setContentType ( TEXT _ PLAIN )  ;", "headers . setLocation ( new   URI (  \"  / redirectFoo \"  )  )  ;", "headers . put (  \" Set - Cookie \"  ,    cookieValues )  ;", "String   heading    =     \" MockHttpServletResponse \"  ;", "assertValue ( heading ,     \" Status \"  ,    this . response . getStatus (  )  )  ;", "assertValue ( heading ,     \" Error   message \"  ,    response . getErrorMessage (  )  )  ;", "assertValue ( heading ,     \" Headers \"  ,    headers )  ;", "assertValue ( heading ,     \" Content   type \"  ,    this . response . getContentType (  )  )  ;", "assertValue ( heading ,     \" Body \"  ,    this . response . getContentAsString (  )  )  ;", "assertValue ( heading ,     \" Forwarded   URL \"  ,    this . response . getForwardedUrl (  )  )  ;", "assertValue ( heading ,     \" Redirected   URL \"  ,    this . response . getRedirectedUrl (  )  )  ;", "Map < String ,    Map < String ,    Object >  >    printedValues    =    this . h . getPrinter (  )  . printedValues ;", "String [  ]    cookies    =     (  ( String [  ]  )     ( printedValues . get ( heading )  . get (  \" Cookies \"  )  )  )  ;", "assertEquals (  2  ,    cookies . length )  ;", "String   cookie 1     =    cookies [  0  ]  ;", "String   cookie 2     =    cookies [  1  ]  ;", "assertTrue ( cookie 1  . startsWith (  (  \"  [  \"     +     ( Cookie . class . getSimpleName (  )  )  )  )  )  ;", "assertTrue ( cookie 1  . contains (  \" name    =     ' cookie '  ,    value    =     ' cookieValue '  \"  )  )  ;", "assertTrue ( cookie 1  . endsWith (  \"  ]  \"  )  )  ;", "assertTrue ( cookie 2  . startsWith (  (  \"  [  \"     +     ( Cookie . class . getSimpleName (  )  )  )  )  )  ;", "assertTrue ( cookie 2  . contains (  (  \" name    =     ' enigma '  ,    value    =     '  4  2  '  ,     \"     +     (  \" comment    =     ' This   is   a   comment '  ,    domain    =     '  . example . com '  ,    maxAge    =     1  2  3  4  ,     \"     +     \" path    =     '  / crumbs '  ,    secure    =    true ,    version    =     0  ,    httpOnly    =    true \"  )  )  )  )  ;", "assertTrue ( cookie 2  . endsWith (  \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["printResponse"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . response . setCharacterEncoding (  \" UTF -  8  \"  )  ;", "this . response . getWriter (  )  . print (  \" text \"  )  ;", "this . h . handle ( this . mvcResult )  ;", "assertValue (  \" MockHttpServletResponse \"  ,     \" Body \"  ,     \" text \"  )  ;", "}", "METHOD_END"], "methodName": ["printResponseWithCharacterEncoding"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . response . getWriter (  )  . print (  \" text \"  )  ;", "this . h . handle ( this . mvcResult )  ;", "assertValue (  \" MockHttpServletResponse \"  ,     \" Body \"  ,     \" text \"  )  ;", "}", "METHOD_END"], "methodName": ["printResponseWithDefaultCharacterEncoding"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . response . setCharacterEncoding ( null )  ;", "this . response . getWriter (  )  . print (  \" text \"  )  ;", "this . h . handle ( this . mvcResult )  ;", "assertValue (  \" MockHttpServletResponse \"  ,     \" Body \"  ,     \"  < no   character   encoding   set >  \"  )  ;", "}", "METHOD_END"], "methodName": ["printResponseWithoutCharacterEncoding"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . mvcResult . setResolvedException ( new   Exception (  )  )  ;", "this . handler . handle ( this . mvcResult )  ;", "assertValue (  \" Resolved   Exception \"  ,     \" Type \"  ,    Exception . class . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvedException"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . handle ( this . mvcResult )  ;", "assertValue (  \" Resolved   Exception \"  ,     \" Type \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["resolvedExceptionNull"], "fileName": "org.springframework.test.web.servlet.result.PrintingResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AssertionErrors . assertEquals (  \" Async   started \"  ,    true ,    request . isAsyncStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAsyncStarted"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "HttpServlet   request    =    result . get (  )  ;", "AssertionErrors . assertEquals (  \" Async   started \"  ,    false ,    request . isAsyncStarted (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["asyncNotStarted"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "HttpServletRequest   request    =    result . getRequest (  )  ;", ". assertAsyncStarted ( request )  ;", "AssertionErrors . assertEquals (  \" Async   result \"  ,    expectedResult ,    result . getAsyncResult (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["asyncResult"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "HttpServletRequest   request    =    result . getRequest (  )  ;", ". assertAsyncStarted ( request )  ;", "assertThat (  \" Async   result \"  ,     (  ( T )     ( result . getAsyncResult (  )  )  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["asyncResult"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >     {", "HttpServletRequest   request    =    result . getRequest (  )  ;", ". assertAsyncStarted ( request )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["asyncStarted"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  (  \" Request   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    expectedValue ,    result . getRequest (  )  . getAttribute ( name )  )  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "T   value    =     (  ( T )     ( getRequest (  )  . getAttribute ( name )  )  )  ;", "assertThat (  (  (  \" Request   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    value ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "HttpSession   session    =    getRequest (  )  . getSession (  )  ;", "Assert . state (  ( session    !  =    null )  ,     \" No   HttpSession \"  )  ;", "AssertionErrors . assertEquals (  (  (  \" Session   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    value ,    session . getAttribute ( name )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["sessionAttribute"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "HttpSession   session    =    getRequest (  )  . getSession (  )  ;", "Assert . state (  ( session    !  =    null )  ,     \" No   HttpSession \"  )  ;", "T   value    =     (  ( T )     ( session . getAttribute ( name )  )  )  ;", "assertThat (  (  (  \" Session   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    value ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["sessionAttribute"], "fileName": "org.springframework.test.web.servlet.result.RequestResultMatchers"}, {"methodBody": ["METHOD_START", "{", "int   statusValue    =    result . getResponse (  )  . getStatus (  )  ;", "HttpStatus   status    =    HttpStatus . valueOf ( statusValue )  ;", "return   status . series (  )  ;", "}", "METHOD_END"], "methodName": ["getHttpStatusSeries"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  \" Response   status \"  ,    status ,    result . getResponse (  )  . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    assertThat (  \" Response   status \"  ,    result . getResponse (  )  . getStatus (  )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  \" Range   for   response   status   value    \"     +     ( result . getResponse (  )  . getStatus (  )  )  )  ,    INFORMATIONAL ,    getHttpStatusSeries ( result )  )  ;", "}", "METHOD_END"], "methodName": ["is1xxInformational"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  \" Range   for   response   status   value    \"     +     ( result . getResponse (  )  . getStatus (  )  )  )  ,    SUCCESSFUL ,    getHttpStatusSeries ( result )  )  ;", "}", "METHOD_END"], "methodName": ["is2xxSuccessful"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  \" Range   for   response   status   value    \"     +     ( result . getResponse (  )  . getStatus (  )  )  )  ,    REDIRECTION ,    getHttpStatusSeries ( result )  )  ;", "}", "METHOD_END"], "methodName": ["is3xxRedirection"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  \" Range   for   response   status   value    \"     +     ( result . getResponse (  )  . getStatus (  )  )  )  ,    CLIENT _ ERROR ,    getHttpStatusSeries ( result )  )  ;", "}", "METHOD_END"], "methodName": ["is4xxClientError"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  (  \" Range   for   response   status   value    \"     +     ( result . getResponse (  )  . getStatus (  )  )  )  ,    SERVER _ ERROR ,    getHttpStatusSeries ( result )  )  ;", "}", "METHOD_END"], "methodName": ["is5xxServerError"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( ACCEPTED )  ;", "}", "METHOD_END"], "methodName": ["isAccepted"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( ALREADY _ REPORTED )  ;", "}", "METHOD_END"], "methodName": ["isAlreadyReported"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( BAD _ GATEWAY )  ;", "}", "METHOD_END"], "methodName": ["isBadGateway"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( BAD _ REQUEST )  ;", "}", "METHOD_END"], "methodName": ["isBadRequest"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  5  0  9  )  )  ;", "}", "METHOD_END"], "methodName": ["isBandwidthLimitExceeded"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  1  0  3  )  )  ;", "}", "METHOD_END"], "methodName": ["isCheckpoint"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( CONFLICT )  ;", "}", "METHOD_END"], "methodName": ["isConflict"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( CONTINUE )  ;", "}", "METHOD_END"], "methodName": ["isContinue"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( CREATED )  ;", "}", "METHOD_END"], "methodName": ["isCreated"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( DESTINATION _ LOCKED )  ;", "}", "METHOD_END"], "methodName": ["isDestinationLocked"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( EXPECTATION _ FAILED )  ;", "}", "METHOD_END"], "methodName": ["isExpectationFailed"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( FAILED _ DEPENDENCY )  ;", "}", "METHOD_END"], "methodName": ["isFailedDependency"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( FORBIDDEN )  ;", "}", "METHOD_END"], "methodName": ["isForbidden"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( FOUND )  ;", "}", "METHOD_END"], "methodName": ["isFound"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( GATEWAY _ TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["isGatewayTimeout"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( GONE )  ;", "}", "METHOD_END"], "methodName": ["isGone"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HTTP _ VERSION _ NOT _ SUPPORTED )  ;", "}", "METHOD_END"], "methodName": ["isHttpVersionNotSupported"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  4  1  8  )  )  ;", "}", "METHOD_END"], "methodName": ["isIAmATeapot"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( IM _ USED )  ;", "}", "METHOD_END"], "methodName": ["isImUsed"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( INSUFFICIENT _ SPACE _ ON _ RESOURCE )  ;", "}", "METHOD_END"], "methodName": ["isInsufficientSpaceOnResource"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( INSUFFICIENT _ STORAGE )  ;", "}", "METHOD_END"], "methodName": ["isInsufficientStorage"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( INTERNAL _ SERVER _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["isInternalServerError"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( LENGTH _ REQUIRED )  ;", "}", "METHOD_END"], "methodName": ["isLengthRequired"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( LOCKED )  ;", "}", "METHOD_END"], "methodName": ["isLocked"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( LOOP _ DETECTED )  ;", "}", "METHOD_END"], "methodName": ["isLoopDetected"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( METHOD _ FAILURE )  ;", "}", "METHOD_END"], "methodName": ["isMethodFailure"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( METHOD _ NOT _ ALLOWED )  ;", "}", "METHOD_END"], "methodName": ["isMethodNotAllowed"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( MOVED _ PERMANENTLY )  ;", "}", "METHOD_END"], "methodName": ["isMovedPermanently"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( MOVED _ TEMPORARILY )  ;", "}", "METHOD_END"], "methodName": ["isMovedTemporarily"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( MULTI _ STATUS )  ;", "}", "METHOD_END"], "methodName": ["isMultiStatus"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( MULTIPLE _ CHOICES )  ;", "}", "METHOD_END"], "methodName": ["isMultipleChoices"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  5  1  1  )  )  ;", "}", "METHOD_END"], "methodName": ["isNetworkAuthenticationRequired"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( NO _ CONTENT )  ;", "}", "METHOD_END"], "methodName": ["isNoContent"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( NON _ AUTHORITATIVE _ INFORMATION )  ;", "}", "METHOD_END"], "methodName": ["isNonAuthoritativeInformation"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( NOT _ ACCEPTABLE )  ;", "}", "METHOD_END"], "methodName": ["isNotAcceptable"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( NOT _ EXTENDED )  ;", "}", "METHOD_END"], "methodName": ["isNotExtended"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( NOT _ FOUND )  ;", "}", "METHOD_END"], "methodName": ["isNotFound"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( NOT _ IMPLEMENTED )  ;", "}", "METHOD_END"], "methodName": ["isNotImplemented"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( NOT _ MODIFIED )  ;", "}", "METHOD_END"], "methodName": ["isNotModified"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( OK )  ;", "}", "METHOD_END"], "methodName": ["isOk"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( PARTIAL _ CONTENT )  ;", "}", "METHOD_END"], "methodName": ["isPartialContent"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( PAYLOAD _ TOO _ LARGE )  ;", "}", "METHOD_END"], "methodName": ["isPayloadTooLarge"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( PAYMENT _ REQUIRED )  ;", "}", "METHOD_END"], "methodName": ["isPaymentRequired"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  3  0  8  )  )  ;", "}", "METHOD_END"], "methodName": ["isPermanentRedirect"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( PRECONDITION _ FAILED )  ;", "}", "METHOD_END"], "methodName": ["isPreconditionFailed"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  4  2  8  )  )  ;", "}", "METHOD_END"], "methodName": ["isPreconditionRequired"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( PROCESSING )  ;", "}", "METHOD_END"], "methodName": ["isProcessing"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( PROXY _ AUTHENTICATION _ REQUIRED )  ;", "}", "METHOD_END"], "methodName": ["isProxyAuthenticationRequired"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( REQUEST _ ENTITY _ TOO _ LARGE )  ;", "}", "METHOD_END"], "methodName": ["isRequestEntityTooLarge"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  4  3  1  )  )  ;", "}", "METHOD_END"], "methodName": ["isRequestHeaderFieldsTooLarge"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( REQUEST _ TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["isRequestTimeout"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( REQUEST _ URI _ TOO _ LONG )  ;", "}", "METHOD_END"], "methodName": ["isRequestUriTooLong"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( REQUESTED _ RANGE _ NOT _ SATISFIABLE )  ;", "}", "METHOD_END"], "methodName": ["isRequestedRangeNotSatisfiable"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( RESET _ CONTENT )  ;", "}", "METHOD_END"], "methodName": ["isResetContent"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( SEE _ OTHER )  ;", "}", "METHOD_END"], "methodName": ["isSeeOther"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( SERVICE _ UNAVAILABLE )  ;", "}", "METHOD_END"], "methodName": ["isServiceUnavailable"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( SWITCHING _ PROTOCOLS )  ;", "}", "METHOD_END"], "methodName": ["isSwitchingProtocols"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( TEMPORARY _ REDIRECT )  ;", "}", "METHOD_END"], "methodName": ["isTemporaryRedirect"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  4  2  9  )  )  ;", "}", "METHOD_END"], "methodName": ["isTooManyRequests"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( UNAUTHORIZED )  ;", "}", "METHOD_END"], "methodName": ["isUnauthorized"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( HttpStatus . valueOf (  4  5  1  )  )  ;", "}", "METHOD_END"], "methodName": ["isUnavailableForLegalReasons"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( UNPROCESSABLE _ ENTITY )  ;", "}", "METHOD_END"], "methodName": ["isUnprocessableEntity"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( UNSUPPORTED _ MEDIA _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["isUnsupportedMediaType"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( UPGRADE _ REQUIRED )  ;", "}", "METHOD_END"], "methodName": ["isUpgradeRequired"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( URI _ TOO _ LONG )  ;", "}", "METHOD_END"], "methodName": ["isUriTooLong"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( USE _ PROXY )  ;", "}", "METHOD_END"], "methodName": ["isUseProxy"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( VARIANT _ ALSO _ NEGOTIATES )  ;", "}", "METHOD_END"], "methodName": ["isVariantAlsoNegotiates"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  \" Status \"  ,    status . value (  )  ,    result . getResponse (  )  . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["matcher"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    AssertionErrors . assertEquals (  \" Response   status   reason \"  ,    reason ,    result . getResponse (  )  . getErrorMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["reason"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (    result )     -  >    assertThat (  \" Response   status   reason \"  ,    result . getResponse (  )  . getErrorMessage (  )  ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["reason"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchers"}, {"methodBody": ["METHOD_START", "{", "String   name    =    status . name (  )  . toLowerCase (  )  . replace (  \"  _  \"  ,     \"  -  \"  )  ;", "name    =     \" is \"     +     ( StringUtils . capitalize ( Conventions . attributeNameToPropertyName ( name )  )  )  ;", "return    . class . getMethod ( name )  ;", "}", "METHOD_END"], "methodName": ["getMethodForHttpStatus"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . matchers    =    new   StatusResultMatchers (  )  ;", "this . request    =    new   MockHttpServletRequest (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "for    ( HttpStatus   status    :    HttpStatus . values (  )  )     {", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . setStatus ( status . value (  )  )  ;", "MvcResult   mvcResult    =    new   StubMvcResult ( request ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "switch    ( status . series (  )  . value (  )  )     {", "case    1     :", "this . m . is 1 xxInformational (  )  . match ( mvcResult )  ;", "break ;", "case    2     :", "this . m . is 2 xxSuccessful (  )  . match ( mvcResult )  ;", "break ;", "case    3     :", "this . m . is 3 xxRedirection (  )  . match ( mvcResult )  ;", "break ;", "case    4     :", "this . m . is 4 xxClientError (  )  . match ( mvcResult )  ;", "break ;", "case    5     :", "this . m . is 5 xxServerError (  )  . match ( mvcResult )  ;", "break ;", "default    :", "fail (  (  \" Unexpected   range   for   status   code   value    \"     +    status )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["statusRanges"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "List < AssertionError >    failures    =    new   ArrayList <  >  (  )  ;", "for    ( HttpStatus   status    :    HttpStatus . values (  )  )     {", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . setStatus ( status . value (  )  )  ;", "MvcResult   mvcResult    =    new   StubMvcResult ( request ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "try    {", "Method   method    =    getMethodForHttpStatus ( status )  ;", "matcher    =     (  (  )     ( ReflectionUtils . invokeMethod ( method ,    this . matchers )  )  )  ;", "try    {", "matcher . match ( mvcResult )  ;", "}    catch    ( AssertionError   error )     {", "failures . add ( error )  ;", "}", "}    catch    ( Exception   ex )     {", "throw   new   Exception (  (  \" Failed   to   obtain      for   status    \"     +    status )  ,    ex )  ;", "}", "}", "if    (  !  ( failures . isEmpty (  )  )  )     {", "fail (  (  \" Failed   status   codes :     \"     +    failures )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testHttpStatusCodeResultMatchers"], "fileName": "org.springframework.test.web.servlet.result.StatusResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "ModelAndView   mav    =    getModelAndView (  )  ;", "if    ( mav    =  =    null )     {", "AssertionErrors . fail (  \" No   ModelAndView   found \"  )  ;", "}", "AssertionErrors . assertEquals (  \" View   name \"  ,    expectedViewName ,    mav . getViewName (  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "org.springframework.test.web.servlet.result.ViewResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "ModelAndView   mav    =    getModelAndView (  )  ;", "if    ( mav    =  =    null )     {", "AssertionErrors . fail (  \" No   ModelAndView   found \"  )  ;", "}", "assertThat (  \" View   name \"  ,    mav . getViewName (  )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "org.springframework.test.web.servlet.result.ViewResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . assertBoolean ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  ,    value )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["booleanValue"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . doesNotExist ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . exists ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return   response . isCharset (  )     ?    response . getCharacterEncoding (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDefinedEncoding"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . assertNode ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . assertNodeCount ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  ,    expectedCount )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["nodeCount"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . assertNodeCount ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["nodeCount"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . assertNumber ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  ,    expectedValue )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["number"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . assertNumber ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["number"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . assertString ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  ,    expectedValue )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "return    (        -  >     {", "MockHttpServletResponse   response    =    getResponse (  )  ;", "xpathHelper . assertString ( response . getContentAsByteArray (  )  ,    getDefinedEncoding ( response )  ,    matcher )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchers"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar [  2  ]  \"  ,    null )  . booleanValue ( true )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["booleanValue"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar [  2  ]  \"  ,    null )  . booleanValue ( false )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["booleanValueNoMatch"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / Bar \"  ,    null )  . doesNotExist (  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar \"  ,    null )  . doesNotExist (  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistNoMatch"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar \"  ,    null )  . exists (  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / Bar \"  ,    null )  . exists (  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["existsNoMatch"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . addHeader (  \" Content - Type \"  ,     \" application / xml \"  )  ;", "response . getWriter (  )  . print ( new   String (  . RESPONSE _ CONTENT . getBytes ( StandardCharsets . ISO _  8  8  5  9  _  1  )  )  )  ;", "return   new   StubMvcResult ( null ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "}", "METHOD_END"], "methodName": ["getStubMvcResult"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar \"  ,    null )  . node ( Matchers . notNullValue (  )  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar \"  ,    null )  . nodeCount (  2  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["nodeCount"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar \"  ,    null )  . nodeCount (  1  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["nodeCountNoMatch"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar \"  ,    null )  . node ( Matchers . nullValue (  )  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["nodeNoMatch"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar [  1  ]  \"  ,    null )  . number (  1  1  1  .  0  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["number"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar [  1  ]  \"  ,    null )  . number (  1  1  1  .  1  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["numberNoMatch"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar [  1  ]  \"  ,    null )  . string (  \"  1  1  1  \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["string"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" UTF -  8  \\  \"    standalone =  \\  \" yes \\  \"  ?  >  \\ n \"     +     \"  < person >  < name > J \u00a8\u00b9 rgen <  / name >  <  / person >  \"  ;", "byte [  ]    bytes    =    content . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "response . addHeader (  \" Content - Type \"  ,     \" application / xml \"  )  ;", "StreamUtils . copy ( bytes ,    response . getOutputStream (  )  )  ;", "StubMvcResult   result    =    new   StubMvcResult ( null ,    null ,    null ,    null ,    null ,    null ,    response )  ;", "new    (  \"  / person / name \"  ,    null )  . string (  \" J \u00a8\u00b9 rgen \"  )  . match ( result )  ;", "}", "METHOD_END"], "methodName": ["stringEncodingDetection"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "new   XpathResultMatchers (  \"  / foo / bar [  1  ]  \"  ,    null )  . string (  \"  1  1  2  \"  )  . match ( getStubMvcResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["stringNoMatch"], "fileName": "org.springframework.test.web.servlet.result.XpathResultMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MvcResult   mvcResult    =    this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / callable \"  )  . accept ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncResult ( Collections . singletonMap (  \" key \"  ,     \" value \"  )  )  )  . andReturn (  )  ;", "Mockito . verify ( this . callableInterceptor )  . beforeConcurrentHandling ( any (  )  ,    any (  )  )  ;", "Mockito . verify ( this . callableInterceptor )  . preProcess ( any (  )  ,    any (  )  )  ;", "Mockito . verify ( this . callableInterceptor )  . postProcess ( any (  )  ,    any (  )  ,    any (  )  )  ;", "Mockito . verifyNoMoreInteractions ( this . callableInterceptor )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchernt (  )  . string (  \"  {  \\  \" key \\  \"  :  \\  \" value \\  \"  }  \"  )  )  ;", "Mockito . verify ( this . callableInterceptor )  . afterCompletion ( any (  )  ,    any (  )  )  ;", "Mockito . verifyNoMoreInteractions ( this . callableInterceptor )  ;", "}", "METHOD_END"], "methodName": ["callableInterceptor"], "fileName": "org.springframework.test.web.servlet.samples.context.AsyncControllerJavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.context.AsyncControllerJavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / person /  5  \"  )  . accept ( APPLICATION _ JSON )  )  . andDo ( MockMvcResultHandlers . print (  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["person"], "fileName": "org.springframework.test.web.servlet.samples.context.JavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . build (  )  ;", "verifyRootWacSupport (  )  ;", "given ( this . personDao . getPerson (  5 L )  )  . willReturn ( new   Person (  \" Joe \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.context.JavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \"  / WEB - INF / layouts / standardLayout . jsp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["tilesDefinitions"], "fileName": "org.springframework.test.web.servlet.samples.context.JavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertNotNull ( personDao )  ;", "Assert . assertNotNull ( personController )  ;", "ApplicationCparent    =    wac . getParent (  )  ;", "Assert . assertNotNull ( parent )  ;", "Assert . assertTrue (  ( parent   instanceof   WebApplicationC )  ;", "WebApplicationCroot    =     (  ( WebApplicationC    ( parent )  )  ;", "ServletCchildServletC =    wac . getServletC )  ;", "Assert . assertNotNull ( childServletC ;", "ServletCrootServletC =    root . getServletC )  ;", "Assert . assertNotNull ( rootServletC ;", "Assert . assertSame ( childServletC   rootServletC ;", "Assert . assertSame ( root ,    rootServletCgetAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ;", "Assert . assertSame ( root ,    childServletCgetAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )  ;", "}", "METHOD_END"], "methodName": ["verifyRootWacSupport"], "fileName": "org.springframework.test.web.servlet.samples.context.JavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "return   this . personDao . getPerson ( id )  ;", "}", "METHOD_END"], "methodName": ["getPerson"], "fileName": "org.springframework.test.web.servlet.samples.context.PersonController"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / resources / Spring . js \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType (  \" application / javascript \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( Matchers . containsString (  \" Spring =  {  }  ;  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resourceRequest"], "fileName": "org.springframework.test.web.servlet.samples.context.WebAppResourceTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / unknown / resource \"  )  )  . andExpect ( MockMvcResultMatchers . handler (  )  . handlerType ( DefaultServletHttpRequestHandler . class )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" default \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resourcesViaDefaultServlet"], "fileName": "org.springframework.test.web.servlet.samples.context.WebAppResourceTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.context.WebAppResourceTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \"  / WEB - INF / layouts / standardLayout . jsp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["tilesDefinitions"], "fileName": "org.springframework.test.web.servlet.samples.context.WebAppResourceTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / person /  5  \"  )  . accept ( APPLICATION _ JSON )  )  . andDo ( MockMvcResultHandlers . print (  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["person"], "fileName": "org.springframework.test.web.servlet.samples.context.XmlConfigTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . build (  )  ;", "given ( this . personDao . getPerson (  5 L )  )  . willReturn ( new   Person (  \" Joe \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.context.XmlConfigTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \"  / WEB - INF / layouts / standardLayout . jsp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["tilesDefinitions"], "fileName": "org.springframework.test.web.servlet.samples.context.XmlConfigTests"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   requestAttributes    =    RequestContextHolder . getRequestAttributes (  )  ;", "Assert . assertThat ( requestAttributes ,    CoreMatchers . instanceOf ( ServletRequestAttributes . class )  )  ;", ". assertRequestAttributes (  (  ( ServletRequestAttributes )     ( requestAttributes )  )  . getRequest (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertRequestAttributes"], "fileName": "org.springframework.test.web.servlet.samples.spr.CustomRequestAttributesRequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertThat ( request . getAttribute ( CustomRequestAttributesRequestContextHolderTests . FROM _ CUSTOM _ MOCK )  ,    CoreMatchers . is ( CoreMatchers . nullValue (  )  )  )  ;", "Assert . assertThat ( request . getAttribute ( CustomRequestAttributesRequestContextHolderTests . FROM _ MVC _ TEST _ DEFAULT )  ,    CoreMatchers . is ( CustomRequestAttributesRequestContextHolderTests . FROM _ MVC _ TEST _ DEFAULT )  )  ;", "Assert . assertThat ( request . getAttribute ( CustomRequestAttributesRequestContextHolderTests . FROM _ MVC _ TEST _ MOCK )  ,    CoreMatchers . is ( CustomRequestAttributesRequestContextHolderTests . FROM _ MVC _ TEST _ MOCK )  )  ;", "}", "METHOD_END"], "methodName": ["assertRequestAttributes"], "fileName": "org.springframework.test.web.servlet.samples.spr.CustomRequestAttributesRequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   servletContext    =    new   MockServletContext (  )  ;", "MockHttpServletRequest   mockRequest    =    new   MockHttpServletRequest ( servletContext )  ;", "mockRequest . setAttribute (  . FROM _ CUSTOM _ MOCK ,     . FROM _ CUSTOM _ MOCK )  ;", "RequestContextHolder . setRequestAttributes ( new   ServletWebRequest ( mockRequest ,    new   MockHttpServletResponse (  )  )  )  ;", "this . wac . setServletContext ( servletContext )  ;", "new   AnnotatedBeanDefinitionReader ( this . wac )  . register (  . WebConfig . class )  ;", "this . wac . refresh (  )  ;", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  . requestAttr (  . FROM _ MVC _ TEST _ DEFAULT ,     . FROM _ MVC _ TEST _ DEFAULT )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.test.web.servlet.samples.spr.CustomRequestAttributesRequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / singletonController \"  )  . requestAttr ( CustomRequestAttributesRequestContextHolderTests . FROM _ MVC _ TEST _ MOCK ,    CustomRequestAttributesRequestContextHolderTests . FROM _ MVC _ TEST _ MOCK )  )  ;", "}", "METHOD_END"], "methodName": ["singletonController"], "fileName": "org.springframework.test.web.servlet.samples.spr.CustomRequestAttributesRequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   requestAttributes    =    RequestContextHolder . getRequestAttributes (  )  ;", "Assert . assertThat ( requestAttributes ,    CoreMatchers . instanceOf ( ServletRequestAttributes . class )  )  ;", "HttpServletRequest   request    =     (  ( ServletRequestAttributes )     ( requestAttributes )  )  . getRequest (  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ CUSTOM _ MOCK )  ,    CoreMatchers . is (  . FROM _ CUSTOM _ MOCK )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ MVC _ TEST _ DEFAULT )  ,    CoreMatchers . is ( CoreMatchers . nullValue (  )  )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ MVC _ TEST _ MOCK )  ,    CoreMatchers . is ( CoreMatchers . nullValue (  )  )  )  ;", "RequestContextHolder . resetRequestAttributes (  )  ;", "this . wac . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyCustomRequestAttributesAreRestored"], "fileName": "org.springframework.test.web.servlet.samples.spr.CustomRequestAttributesRequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.spr.EncodedUriTests"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" a / b \"  ;", "URI   url    =    UriComponentsBuilder . fromUriString (  \"  / circuit \"  )  . pathSegment ( id )  . build (  )  . e (  )  . toUri (  )  ;", "ResultActions   result    =    mockMvc . perform ( MockMvcRequestBuilders . get ( url )  )  ;", "result . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" receivedId \"  ,    Is . is ( id )  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.web.servlet.samples.spr.EncodedUriTests"}, {"methodBody": ["METHOD_START", "{", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   FormContentTests . Spr 1  5  7  5  3 Controller (  )  )  . addFilter ( new   HttpPutFormContentFilter (  )  )  . build (  )  ;", "mockMvc . perform ( MockMvcRequestBuilders . put (  \"  /  \"  )  . content (  \" d 1  = a & d 2  = s \"  )  . contentType ( APPLICATION _ FORM _ URLENCODED )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \" d 1  : a ,    d 2  : s .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["formContentIsNotDuplicated"], "fileName": "org.springframework.test.web.servlet.samples.spr.FormContentTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . dispatchOptions ( true )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.spr.HttpOptionsTests"}, {"methodBody": ["METHOD_START", "{", "HttpOptionsTests . MyController   controller    =    this . wac . getBean ( HttpOptionsTests . MyController . class )  ;", "int   initialCount    =    controller . counter . get (  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . options (  \"  / myUrl \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  ;", "Assert . assertEquals (  ( initialCount    +     1  )  ,    controller . counter . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.test.web.servlet.samples.spr.HttpOptionsTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . webAppContextSetup ( wac )  . addFilter ( new   CharacterEncodingFilter (  )  )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  . contextPath (  \"  / mywebapp \"  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["chainMultiple"], "fileName": "org.springframework.test.web.servlet.samples.spr.MockMvcBuilderMethodChainTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolderTests . assertRequestAttributes ( true )  ;", "}", "METHOD_END"], "methodName": ["assertRequestAttributes"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   requestAttributes    =    RequestContextHolder . getRequestAttributes (  )  ;", "Assert . assertThat ( requestAttributes ,    CoreMatchers . instanceOf ( ServletRequestAttributes . class )  )  ;", ". assertRequestAttributes (  (  ( ServletRequestAttributes )     ( requestAttributes )  )  . getRequest (  )  ,    withinMockMvc )  ;", "}", "METHOD_END"], "methodName": ["assertRequestAttributes"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolderTests . assertRequestAttributes ( request ,    true )  ;", "}", "METHOD_END"], "methodName": ["assertRequestAttributes"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "if    ( withinMockMvc )     {", "Assert . assertThat ( request . getAttribute (  . FROM _ TCF _ MOCK )  ,    CoreMatchers . is ( CoreMatchers . nullValue (  )  )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ MVC _ TEST _ DEFAULT )  ,    CoreMatchers . is (  . FROM _ MVC _ TEST _ DEFAULT )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ MVC _ TEST _ MOCK )  ,    CoreMatchers . is (  . FROM _ MVC _ TEST _ MOCK )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ REQUEST _ FILTER )  ,    CoreMatchers . is (  . FROM _ REQUEST _ FILTER )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ REQUEST _ ATTRIBUTES _ FILTER )  ,    CoreMatchers . is (  . FROM _ REQUEST _ ATTRIBUTES _ FILTER )  )  ;", "} else    {", "Assert . assertThat ( request . getAttribute (  . FROM _ TCF _ MOCK )  ,    CoreMatchers . is (  . FROM _ TCF _ MOCK )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ MVC _ TEST _ DEFAULT )  ,    CoreMatchers . is ( CoreMatchers . nullValue (  )  )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ MVC _ TEST _ MOCK )  ,    CoreMatchers . is ( CoreMatchers . nullValue (  )  )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ REQUEST _ FILTER )  ,    CoreMatchers . is ( CoreMatchers . nullValue (  )  )  )  ;", "Assert . assertThat ( request . getAttribute (  . FROM _ REQUEST _ ATTRIBUTES _ FILTER )  ,    CoreMatchers . is ( CoreMatchers . nullValue (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertRequestAttributes"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue (  \" request - scoped   controller   must   be   a   CGLIB   proxy \"  ,    AopUtils . isCglibProxy ( this . requestScopedController )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / requestScopedController \"  )  . requestAttr (  . FROM _ MVC _ TEST _ MOCK ,     . FROM _ MVC _ TEST _ MOCK )  )  ;", "}", "METHOD_END"], "methodName": ["requestScopedController"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue (  \" request - scoped   service   must   be   a   CGLIB   proxy \"  ,    AopUtils . isCglibProxy ( this . requestScopedService )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / requestScopedService \"  )  . requestAttr (  . FROM _ MVC _ TEST _ MOCK ,     . FROM _ MVC _ TEST _ MOCK )  )  ;", "}", "METHOD_END"], "methodName": ["requestScopedService"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue (  \" session - scoped   service   must   be   a   CGLIB   proxy \"  ,    AopUtils . isCglibProxy ( this . sessionScopedService )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / sessionScopedService \"  )  . requestAttr (  . FROM _ MVC _ TEST _ MOCK ,     . FROM _ MVC _ TEST _ MOCK )  )  ;", "}", "METHOD_END"], "methodName": ["sessionScopedService"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "this . mockRequest . setAttribute ( RequestContextHolderTests . FROM _ TCF _ MOCK ,    RequestContextHolderTests . FROM _ TCF _ MOCK )  ;", "this . mockMvc    =    MockMvcBuilders . webAppContextSetup ( this . wac )  . addFilters ( new   RequestContextHolderTests . RequestFilter (  )  ,    new   RequestContextHolderTests . RequestAttributesFilter (  )  ,    this . filterWithSessionScopedService )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  . requestAttr ( RequestContextHolderTests . FROM _ MVC _ TEST _ DEFAULT ,    RequestContextHolderTests . FROM _ MVC _ TEST _ DEFAULT )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / singletonController \"  )  . requestAttr ( RequestContextHolderTests . FROM _ MVC _ TEST _ MOCK ,    RequestContextHolderTests . FROM _ MVC _ TEST _ MOCK )  )  ;", "}", "METHOD_END"], "methodName": ["singletonController"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolderTests . assertRequestAttributes ( false )  ;", "}", "METHOD_END"], "methodName": ["verifyRestoredRequestAttributes"], "fileName": "org.springframework.test.web.servlet.samples.spr.RequestContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "MvcResult   mvcResult    =    this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" callable \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncResult ( new   Person (  \" Joe \"  )  )  )  . andReturn (  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andExpect ( MockMvcResultMatchertus (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["callable"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "MvcResult   mvcResult    =    this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" completableFutureWithImmediateValue \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andReturn (  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andExpect ( MockMvcResultMatchertus (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["completableFutureWithImmediateValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "MvcResult   mvcResult    =    this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" deferredResult \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andReturn (  )  ;", "this . asyncController . onMessage (  \" Joe \"  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andExpect ( MockMvcResultMatchertus (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["deferredResult"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "MvcResult   mvcResult    =    this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" deferredResultWithDelayedError \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andReturn (  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andExpect ( MockMvcResultMatchertus (  )  . is 5 xxServerError (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \" Delayed   Error \"  )  )  ;", "}", "METHOD_END"], "methodName": ["deferredResultWithDelayedError"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "MvcResult   mvcResult    =    this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" deferredResultWithImmediateValue \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncResult ( new   Person (  \" Joe \"  )  )  )  . andReturn (  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andExpect ( MockMvcResultMatchertus (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["deferredResultWithImmediateValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "MvcResult   mvcResult    =    this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" listenableFuture \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andReturn (  )  ;", "this . asyncController . onMessage (  \" Joe \"  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andExpect ( MockMvcResultMatchertus (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["listenableFuture"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "StringWriter   writer    =    new   StringWriter (  )  ;", "MvcResult   mvcResult    =    this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" deferredResult \"  ,     \" true \"  )  )  . andDo ( MockMvcResultHandlers . print ( writer )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andReturn (  )  ;", "assertTrue ( writer . toString (  )  . contains (  \"    started    =    true \"  )  )  ;", "writer    =    new   StringWriter (  )  ;", "this . asyncController . onMessage (  \" Joe \"  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andDo ( MockMvcResultHandlers . print ( writer )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "assertTrue ( writer . toString (  )  . contains (  \"    started    =    false \"  )  )  ;", "}", "METHOD_END"], "methodName": ["printAsyncResult"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" streaming \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andDo ( MvcResult :  : getAsyncResult )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \" name = Joe \"  )  )  ;", "}", "METHOD_END"], "methodName": ["streaming"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" streamingJson \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andDo ( MvcResult :  : getAsyncResult )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON _ UTF 8  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Joe \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  5  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["streamingJson"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  . param (  \" streamingSlow \"  ,     \" true \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andDo ( MvcResult :  : getAsyncResult )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \" name = Joe & someBoolean = true \"  )  )  ;", "}", "METHOD_END"], "methodName": ["streamingSlow"], "fileName": "org.springframework.test.web.servlet.samples.standalone.AsyncTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   ExceptionHandlerTests . PersonController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person / Clyde \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" errorView \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testExceptionHandlerMethod"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   ExceptionHandlerTests . PersonController (  )  )  . setControllerAdvice ( new   ExceptionHandlerTests . GlobalExceptionHandler (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person / Bonnie \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" globalErrorView \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGlobalExceptionHandlerMethod"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( ExceptionHandlerTests . PersonController . class )  . setControllerAdvice ( ExceptionHandlerTests . GlobalExceptionHandler . class )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person / Bonnie \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" globalErrorView \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGlobalExceptionHandlerMethodUsingClassArgument"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   FilterTests . PersonController (  )  )  . addFilter ( new   FilterTests . RedirectFilter (  )  ,     \"  *  . html \"  )  . build (  )  . perform ( MockMvcRequestBuilders . post (  \"  / persons . html \"  )  . param (  \" name \"  ,     \" Andy \"  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrl (  \"  / login \"  )  )  ;", "}", "METHOD_END"], "methodName": ["filterMappedBySuffix"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FilterTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   FilterTests . PersonController (  )  )  . addFilter ( new   FilterTests . RedirectFilter (  )  ,     \"  / p \"  ,     \"  / person \"  )  . build (  )  . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  . param (  \" name \"  ,     \" Andy \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrl (  \"  / person /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  1  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" id \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attributeCount (  1  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" message \"  ,     \" success !  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["filterSkipped"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FilterTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   FilterTests . PersonController (  )  )  . addFilter ( new   FilterTests . RedirectFilter (  )  ,     \"  / p \"  ,     \"  / persons \"  )  . build (  )  . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  . param (  \" name \"  ,     \" Andy \"  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrl (  \"  / login \"  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWithExactMapping"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FilterTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   FilterTests . PersonController (  )  )  . addFilters ( new   FilterTests . WrappingRequestResponseFilter (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . post (  \"  / user \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" principal \"  ,    FilterTests . WrappingRequestResponseFilter . PRINCIPAL _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["filterWrapsRequestResponse"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FilterTests"}, {"methodBody": ["METHOD_START", "{", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   FilterTests . PersonController (  )  )  . addFilters ( new   FilterTests . WrappingRequestResponseFilter (  )  ,    new   ShallowEtagHeaderFilter (  )  )  . build (  )  ;", "MvcResult   mvcResult    =    mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  . accept ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncStarted (  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . asyncResult ( new   Person (  \" Lukas \"  )  )  )  . andReturn (  )  ;", "mockMvc . perform ( MockMvcRequestBuilders . asyncDispatch ( mvcResult )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . longValue (  \" Content - Length \"  ,     5  3  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . string (  \" ETag \"  ,     \"  \\  \"  0 e 3  7 becb 4 f 0 c 9  0  7  0  9 cb 2 e 1 efcc 6  1 eaa 0  0  \\  \"  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  {  \\  \" name \\  \"  :  \\  \" Lukas \\  \"  ,  \\  \" someDouble \\  \"  :  0  .  0  ,  \\  \" someBoolean \\  \"  : false }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWrapsRequestResponseAndPerformsAsyncDispatch"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FilterTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   FilterTests . PersonController (  )  )  . addFilters ( new   FilterTests . ContinueFilter (  )  ,    new   FilterTests . RedirectFilter (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  . param (  \" name \"  ,     \" Andy \"  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrl (  \"  / login \"  )  )  ;", "}", "METHOD_END"], "methodName": ["filtersProcessRequest"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FilterTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   FilterTests . PersonController (  )  )  . addFilters ( new   FilterTests . ContinueFilter (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  . param (  \" name \"  ,     \" Andy \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrl (  \"  / person /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  1  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" id \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attributeCount (  1  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" message \"  ,     \" success !  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["whenFiltersCompleteMvcProcessesRequest"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FilterTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  . with ( FrameworkExtensionTests . headers (  )  . bar (  \" a = b \"  )  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \" Bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["barHeader"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FrameworkExtensionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   FrameworkExtensionTests . TestMockMvcConfigurer (  )  ;", "}", "METHOD_END"], "methodName": ["defaultSetup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FrameworkExtensionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  . with ( FrameworkExtensionTests . headers (  )  . foo (  \" a = b \"  )  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \" Foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["fooHeader"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FrameworkExtensionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   FrameworkExtensionTests . TestRequestPostProcessor (  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FrameworkExtensionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   FrameworkExtensionTests . SampleController (  )  )  . apply ( FrameworkExtensionTests . defaultSetup (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.FrameworkExtensionTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fileContent    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   filePart 1     =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "MockMultipartFile   filePart 2     =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / multipartfilearray \"  )  . file ( filePart 1  )  . file ( filePart 2  )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" fileContent \"  ,    fileContent )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithFileArray"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   MultipartControllerTests . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . post (  \"  / multipartfilearray \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithFileArrayNoMultipart"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   MultipartControllerTests . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / multipartfilearray \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithFileArrayNotPresent"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fileContent    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   filePart 1     =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "MockMultipartFile   filePart 2     =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / multipartfilelist \"  )  . file ( filePart 1  )  . file ( filePart 2  )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" fileContent \"  ,    fileContent )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithFileList"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   MultipartControllerTests . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . post (  \"  / multipartfilelist \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithFileListNoMultipart"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   MultipartControllerTests . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / multipartfilelist \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithFileListNotPresent"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fileContent    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   filePart    =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / optionalfile \"  )  . file ( filePart )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" fileContent \"  ,    fileContent )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithOptionalFile"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fileContent    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   filePart 1     =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "MockMultipartFile   filePart 2     =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / optionalfilearray \"  )  . file ( filePart 1  )  . file ( filePart 2  )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" fileContent \"  ,    fileContent )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithOptionalFileArray"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / optionalfilearray \"  )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeDoesNotExist (  \" fileContent \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithOptionalFileArrayNotPresent"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fileContent    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   filePart 1     =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "MockMultipartFile   filePart 2     =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / optionalfilelist \"  )  . file ( filePart 1  )  . file ( filePart 2  )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" fileContent \"  ,    fileContent )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithOptionalFileList"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / optionalfilelist \"  )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeDoesNotExist (  \" fileContent \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithOptionalFileListNotPresent"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / optionalfile \"  )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeDoesNotExist (  \" fileContent \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithOptionalFileNotPresent"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fileContent    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockPart   filePart    =    new   MockPart (  \" file \"  ,     \" orig \"  ,    fileContent )  ;", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockPart   jsonPart    =    new   MockPart (  \" json \"  ,     \" json \"  ,    json )  ;", "jsonPart . getHeaders (  )  . setContentType ( APPLICATION _ JSON )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / multipartfile \"  )  . part ( filePart )  . part ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" fileContent \"  ,    fileContent )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithServletParts"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fileContent    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   filePart    =    new   MockMultipartFile (  \" file \"  ,     \" orig \"  ,    null ,    fileContent )  ;", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / multipartfile \"  )  . file ( filePart )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" fileContent \"  ,    fileContent )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" jsonContent \"  ,    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithSingleFile"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   MultipartControllerTests . MultipartController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . multipart (  \"  / multipartfile \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWithSingleFileNotPresent"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    json    =     \"  {  \\  \" name \\  \"  :  \\  \" yeeeah \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "MockMultipartFile   jsonPart    =    new   MockMultipartFile (  \" json \"  ,     \" json \"  ,     \" application / json \"  ,    json )  ;", "Filter   filter    =    new    . RequestWrappingFilter (  )  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new    . MultipartController (  )  )  . addFilter ( filter )  . build (  )  ;", "Map < String ,    String >    jsonMap    =    Collections . singletonMap (  \" name \"  ,     \" yeeeah \"  )  ;", "mockMvc . perform ( MockMvcRequestBuilders . multipart (  \"  / json \"  )  . file ( jsonPart )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" json \"  ,    jsonMap )  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequestWrapped"], "fileName": "org.springframework.test.web.servlet.samples.standalone.MultipartControllerTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons / Joe \"  )  . flashAttr (  \" message \"  ,     \" success !  \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" persons / index \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  2  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" person \"  ,    new   Person (  \" Joe \"  )  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" message \"  ,     \" success !  \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attributeCount (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getPerson"], "fileName": "org.springframework.test.web.servlet.samples.standalone.RedirectTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  . param (  \" name \"  ,     \" Andy \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrl (  \"  / persons / Joe \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  1  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" name \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attributeCount (  1  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" message \"  ,     \" success !  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["save"], "fileName": "org.springframework.test.web.servlet.samples.standalone.RedirectTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . post (  \"  / people \"  )  . param (  \" name \"  ,     \" Andy \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrl (  \"  / persons / Joe \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  1  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" name \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attributeCount (  1  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" message \"  ,     \" success !  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["saveSpecial"], "fileName": "org.springframework.test.web.servlet.samples.standalone.RedirectTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . post (  \"  / people \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" persons / add \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  1  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" person \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attributeCount (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["saveSpecialWithErrors"], "fileName": "org.springframework.test.web.servlet.samples.standalone.RedirectTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" persons / add \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  1  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" person \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attributeCount (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["saveWithErrors"], "fileName": "org.springframework.test.web.servlet.samples.standalone.RedirectTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   RedirectTests . PersonController (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.RedirectTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   RequestParameterTests . PersonController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / search ? name = George \"  )  . accept ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . name \"  )  . value (  \" George \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParameter"], "fileName": "org.springframework.test.web.servlet.samples.standalone.RequestParameterTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   ResponseBodyTests . PersonController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person / Lee \"  )  . accept ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . name \"  )  . value (  \" Lee \"  )  )  ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ResponseBodyTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   ViewResolutionTests . PersonController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person / Corea \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" person \"  ,    hasProperty (  \" name \"  ,    equalTo (  \" Corea \"  )  )  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" person / show \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultViewResolver"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ViewResolutionTests"}, {"methodBody": ["METHOD_START", "{", "Jaxb 2 Marshaller   marshaller    =    new   Jaxb 2 Marshaller (  )  ;", "marshaller . setClassesToBeBound ( Person . class )  ;", "List < View >    viewList    =    new   ArrayList <  >  (  )  ;", "viewList . add ( new   MappingJackson 2 JsonView (  )  )  ;", "viewList . add ( new   web . servlet . view . xml . MarshallingView ( marshaller )  )  ;", "ContentNegotiationManager   manager    =    new   ContentNegotiationManager ( new   HeaderContentNegotiationStrategy (  )  ,    new   web . accept . FixedContentNegotiationStrategy ( MediaType . TEXT _ HTML )  )  ;", "ContentNegotiatingViewResolver   cnViewResolver    =    new   ContentNegotiatingViewResolver (  )  ;", "cnViewResolver . setDefaultViews ( viewList )  ;", "cnViewResolver . setContentNegotiationManager ( manager )  ;", "cnViewResolver . afterPropertiesSet (  )  ;", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   ViewResolutionTests . PersonController (  )  )  . setViewResolvers ( cnViewResolver ,    new   InternalResourceViewResolver (  )  )  . build (  )  ;", "mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / person / Corea \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  1  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" person \"  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \" person / show \"  )  )  ;", "mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / person / Corea \"  )  . accept ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . person . name \"  )  . value (  \" Corea \"  )  )  ;", "mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / person / Corea \"  )  . accept ( APPLICATION _ XML )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ XML )  )  . andExpect ( MockMvcResultMatchers . xpath (  \"  / person / name / text (  )  \"  )  . string ( equalTo (  \" Corea \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testContentNegotiation"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ViewResolutionTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   ViewResolutionTests . PersonController (  )  )  . setSingleView ( new   MappingJackson 2 JsonView (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person / Corea \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ JSON )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . person . name \"  )  . value (  \" Corea \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testJsonOnly"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ViewResolutionTests"}, {"methodBody": ["METHOD_START", "{", "InternalResourceViewResolver   viewResolver    =    new   InternalResourceViewResolver (  \"  / WEB - INF /  \"  ,     \"  . jsp \"  )  ;", "MockMvcBuilders . standaloneSetup ( new    . PersonController (  )  )  . setViewResolvers ( viewResolver )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person / Corea \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . size (  1  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" person \"  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \"  / WEB - INF / person / show . jsp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testJspOnly"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ViewResolutionTests"}, {"methodBody": ["METHOD_START", "{", "Jaxb 2 Marshaller   marshaller    =    new   Jaxb 2 Marshaller (  )  ;", "marshaller . setClassesToBeBound ( Person . class )  ;", "MockMvcBuilders . standaloneSetup ( new   ViewResolutionTests . PersonController (  )  )  . setSingleView ( new   web . servlet . view . xml . MarshallingView ( marshaller )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / person / Corea \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( APPLICATION _ XML )  )  . andExpect ( MockMvcResultMatchers . xpath (  \"  / person / name / text (  )  \"  )  . string ( equalTo (  \" Corea \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlOnly"], "fileName": "org.springframework.test.web.servlet.samples.standalone.ViewResolutionTests"}, {"methodBody": ["METHOD_START", "{", "StringWriter   writer    =    new   StringWriter (  )  ;", "MockMvcBuilders . standaloneSetup ( new    . SimpleController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  . content (  \" Hello   Request \"  . getBytes (  )  )  )  . andDo ( MockMvcResultHandlers . log (  )  )  . andDo ( MockMvcResultHandlers . print (  )  )  . andDo ( MockMvcResultHandlers . print ( System . err )  )  . andDo ( MockMvcResultHandlers . print ( writer )  )  ;", "System . out . println (  )  ;", "System . out . println (  \"  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  \"  )  ;", "System . out . println ( writer . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrint"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resulthandlers.PrintingResultHandlerSmokeTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   ContentAssertionTests . SimpleController (  )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handle \"  )  . accept ( TEXT _ PLAIN )  )  . andExpect ( MockMvcResultMatchers . content (  )  . encoding (  \" ISO -  8  8  5  9  -  1  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( containsString (  \" world \"  )  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handleUtf 8  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . encoding (  \" UTF -  8  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . bytes (  \"  \\ u 3  0  5  3  \\ u 3  0  9  3  \\ u 3  0  6 b \\ u 3  0  6  1  \\ u 3  0  6 f \\ u 4 e 1  6  \\ u 7  5  4 c \\ uff 0  1  \"  . getBytes (  \" UTF -  8  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCharacterEncoding"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handle \"  )  . accept ( TEXT _ PLAIN )  )  . andExpect ( MockMvcResultMatchers . content (  )  . bytes (  \" Hello   world !  \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handleUtf 8  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . bytes (  \"  \\ u 3  0  5  3  \\ u 3  0  9  3  \\ u 3  0  6 b \\ u 3  0  6  1  \\ u 3  0  6 f \\ u 4 e 1  6  \\ u 7  5  4 c \\ uff 0  1  \"  . getBytes (  \" UTF -  8  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testContentAsBytes"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handle \"  )  . accept ( TEXT _ PLAIN )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \" Hello   world !  \"  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handleUtf 8  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string (  \"  \\ u 3  0  5  3  \\ u 3  0  9  3  \\ u 3  0  6 b \\ u 3  0  6  1  \\ u 3  0  6 f \\ u 4 e 1  6  \\ u 7  5  4 c \\ uff 0  1  \"  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handle \"  )  . accept ( TEXT _ PLAIN )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( equalTo (  \" Hello   world !  \"  )  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handleUtf 8  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( equalTo (  \"  \\ u 3  0  5  3  \\ u 3  0  9  3  \\ u 3  0  6 b \\ u 3  0  6  1  \\ u 3  0  6 f \\ u 4 e 1  6  \\ u 7  5  4 c \\ uff 0  1  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testContentAsString"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handle \"  )  . accept ( TEXT _ PLAIN )  )  . andExpect ( MockMvcResultMatchers . content (  )  . string ( containsString (  \" world \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testContentStringMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handle \"  )  . accept ( TEXT _ PLAIN )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( MediaType . valueOf (  \" text / plain ; charset = ISO -  8  8  5  9  -  1  \"  )  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType (  \" text / plain ; charset = ISO -  8  8  5  9  -  1  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentTypeCompatibleWith (  \" text / plain \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentTypeCompatibleWith ( TEXT _ PLAIN )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / handleUtf 8  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType ( MediaType . valueOf (  \" text / plain ; charset = UTF -  8  \"  )  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentType (  \" text / plain ; charset = UTF -  8  \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentTypeCompatibleWith (  \" text / plain \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentTypeCompatibleWith ( TEXT _ PLAIN )  )  ;", "}", "METHOD_END"], "methodName": ["testContentType"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "CookieLocaleResolver   localeResolver    =    new   CookieLocaleResolver (  )  ;", "localeResolver . setCookieDomain (  \" domain \"  )  ;", "localeResolver . setCookieHttpOnly ( true )  ;", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new    . SimpleController (  )  )  . addInterceptors ( new   LocaleChangeInterceptor (  )  )  . setLocaleResolver ( localeResolver )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  . param (  \" locale \"  ,     \" en _ US \"  )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . domain ( CookieAssertionTests . COOKIE _ NAME ,     \" domain \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDomain"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . value ( CookieAssertionTests . COOKIE _ NAME ,     \" en _ US \"  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . value ( CookieAssertionTests . COOKIE _ NAME ,    equalTo (  \" en _ US \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEqualTo"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . exists ( CookieAssertionTests . COOKIE _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . httpOnly ( CookieAssertionTests . COOKIE _ NAME ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testHttpOnly"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . value ( CookieAssertionTests . COOKIE _ NAME ,    startsWith (  \" en \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . maxAge ( CookieAssertionTests . COOKIE _ NAME ,     (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMaxAge"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . doesNotExist (  \" unknownCookie \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNotExists"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . path ( CookieAssertionTests . COOKIE _ NAME ,     \"  /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPath"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . secure ( CookieAssertionTests . COOKIE _ NAME ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["testSecured"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . cookie (  )  . version ( CookieAssertionTests . COOKIE _ NAME ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testVersion"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.CookieAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   FlashAttributeAssertionTests . PersonController (  )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isFound (  )  )  . alwaysExpect ( MockMvcResultMatchers . flash (  )  . attributeCount (  3  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.FlashAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" one \"  ,     \"  1  \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" two \"  ,     2  .  2  2  2  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" three \"  ,    new   URL (  \" http :  /  / example . com \"  )  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" one \"  ,    equalTo (  \"  1  \"  )  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" two \"  ,    equalTo (  2  .  2  2  2  )  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" three \"  ,    equalTo ( new   URL (  \" http :  /  / example . com \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEqualTo"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.FlashAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attributeExists (  \" one \"  ,     \" two \"  ,     \" three \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.FlashAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" one \"  ,    containsString (  \"  1  \"  )  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" two \"  ,    closeTo (  2  ,     0  .  5  )  )  )  . andExpect ( MockMvcResultMatchers . flash (  )  . attribute (  \" three \"  ,    notNullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchers"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.FlashAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . handler (  )  . handlerType ( HandlerAssertionTests . SimpleController . class )  )  ;", "}", "METHOD_END"], "methodName": ["handlerType"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HandlerAssertionTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    HandlerAssertionTests . SimpleController . class . getMethod (  \" handle \"  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . handler (  )  . method ( method )  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HandlerAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . handler (  )  . methodCall ( on ( HandlerAssertionTests . SimpleController . class )  . handle (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["methodCall"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HandlerAssertionTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( AssertionError . class )  ;", "exception . expectMessage (  \" The   supplied   object    [ bogus ]    is   not   an   instance   of \"  )  ;", "exception . expectMessage ( MethodInvocationInfo . class . getName (  )  )  ;", "exception . expectMessage (  \" Ensure   that   you   invoke   the   handler   method   via   MvcUriComponentsBuilder . on (  )  \"  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . handler (  )  . methodCall (  \" bogus \"  )  )  ;", "}", "METHOD_END"], "methodName": ["methodCallOnNonMock"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HandlerAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . handler (  )  . methodName (  \" handle \"  )  )  ;", "}", "METHOD_END"], "methodName": ["methodName"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HandlerAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . handler (  )  . methodName ( Matchers . equalTo (  \" handle \"  )  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . handler (  )  . methodName ( Matchers . is ( Matchers . not (  \" save \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["methodNameMatchers"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HandlerAssertionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  . header ( IF _ MODIFIED _ SINCE ,    minuteAgo )  )  . andExpect ( matcher )  ;", "fail (  . ERROR _ MESSAGE )  ;", "}    catch    ( AssertionError   err )     {", "if    (  . ERROR _ MESSAGE . equals ( err . getMessage (  )  )  )     {", "throw   err ;", "}", "assertMessageContains ( err ,     (  (  \" Response   header    '  \"     +     ( LAST _ MODIFIED )  )     +     \"  '  \"  )  )  ;", "assertMessageContains ( err ,    unexpected )  ;", "assertMessageContains ( err ,    now )  ;", "}", "}", "METHOD_END"], "methodName": ["assertIncorrectResponseHeader"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   message    =    error . getMessage (  )  ;", "aTrue (  (  \" Failure   message   should   contain :     \"     +    expected )  ,    message . contains ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["assertMessageContains"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  . header ( IF _ MODIFIED _ SINCE ,    minuteAgo )  )  . andExpect ( MockMvcResultMatchers . header (  )  . dateValue ( LAST _ MODIFIED ,    this . currentTime )  )  ;", "}", "METHOD_END"], "methodName": ["dateValueWithCorrectResponseHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "long   unexpected    =     ( this . currentTime )     +     1  0  0  0  ;", "assertIncorrectResponseHeader ( MockMvcResultMheader (  )  . dateValue ( LAST _ MODIFIED ,    unexpected )  ,    secondLater )  ;", "}", "METHOD_END"], "methodName": ["dateValueWithIncorrectResponseHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . doesNotExist (  \" X - Custom - Header \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . doesNotExist ( LAST _ MODIFIED )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistFail"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . exists ( LAST _ MODIFIED )  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . exists (  \" X - Custom - Header \"  )  )  ;", "}", "METHOD_END"], "methodName": ["existsFail"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . longValue (  \" X - Rate - Limiting \"  ,     4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["longValueWithCorrectResponseHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . longValue (  \" X - Rate - Limiting \"  ,     1  )  )  ;", "}", "METHOD_END"], "methodName": ["longValueWithIncorrectResponseHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  . header ( IF _ MODIFIED _ SINCE ,    now )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isNotModified (  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . longValue (  \" X - Custom - Header \"  ,     9  9 L )  )  ;", "fail (  . ERROR _ MESSAGE )  ;", "}    catch    ( AssertionError   err )     {", "if    (  . ERROR _ MESSAGE . equals ( err . getMessage (  )  )  )     {", "throw   err ;", "}", "assertEquals (  \" Response   does   not   contain   header    ' X - Custom - Header '  \"  ,    err . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["longValueWithMissingResponseHeader"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . stringValues ( VARY ,     \" foo \"  ,     \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["multiStringHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . stringValues ( VARY ,    hasItems ( containsString (  \" foo \"  )  ,    startsWith (  \" bar \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multiStringHeaderValueWithMatchers"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "SimpleDateFormat   dateFormat    =    new   SimpleDateFormat (  \" EEE ,    dd   MMM   yyyy   HH : mm : ss   zzz \"  ,    Locale . US )  ;", "dateFormat . setTimeZone ( TimeZone . getTimeZone (  \" GMT \"  )  )  ;", "this . now    =    dateFormat . format ( new   Date ( this . currentTime )  )  ;", "this . minuteAgo    =    dateFormat . format ( new   Date (  (  ( this . currentTime )     -     (  1  0  0  0     *     6  0  )  )  )  )  ;", "this . secondLater    =    dateFormat . format ( new   Date (  (  ( this . currentTime )     +     1  0  0  0  )  )  )  ;", ". PersonController   controller    =    new    . PersonController (  )  ;", "controller . setStubTimestamp ( this . currentTime )  ;", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( controller )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  . header ( IF _ MODIFIED _ SINCE ,    minuteAgo )  )  . andExpect ( MockMvcResultMatchers . header (  )  . string ( LAST _ MODIFIED ,    now )  )  ;", "}", "METHOD_END"], "methodName": ["stringWithCorrectResponseHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "assertIncorrectResponseHeader ( MockMvcResultMatchers . header (  )  . string ( LAST _ MODIFIED ,    secondLater )  ,    secondLater )  ;", "}", "METHOD_END"], "methodName": ["stringWithIncorrectResponseHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  . header ( IF _ MODIFIED _ SINCE ,    minuteAgo )  )  . andExpect ( MockMvcResultMatchers . header (  )  . string ( LAST _ MODIFIED ,    equalTo ( now )  )  )  ;", "}", "METHOD_END"], "methodName": ["stringWithMatcherAndCorrectResponseHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "assertIncorrectResponseHeader ( MockMvcResultMatchers . header (  )  . string ( LAST _ MODIFIED ,    equalTo ( secondLater )  )  ,    secondLater )  ;", "}", "METHOD_END"], "methodName": ["stringWithMatcherAndIncorrectResponseHeaderValue"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  . header ( IF _ MODIFIED _ SINCE ,    now )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isNotModified (  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . string (  \" X - Custom - Header \"  ,    nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["stringWithMatcherAndMissingResponseHeader"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons /  1  \"  )  . header ( IF _ MODIFIED _ SINCE ,    now )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isNotModified (  )  )  . andExpect ( MockMvcResultMatchers . header (  )  . stringValues (  \" X - Custom - Header \"  )  )  ;", "}", "METHOD_END"], "methodName": ["stringWithMissingResponseHeader"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.HeaderAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . composers [  ?  (  @  . name    =  =     ' Edvard   Grieeeeeeg '  )  ]  \"  )  . doesNotExist (  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . composers [  ?  (  @  . name    =  =     ' Robert   Schuuuuuuman '  )  ]  \"  )  . doesNotExist (  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . composers [  4  ]  \"  )  . doesNotExist (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExist"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.JsonPathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . composers [  0  ]  . name \"  )  . value (  \" Johann   Sebastian   Bach \"  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . performers [  1  ]  . name \"  )  . value (  \" Yehudi   Menuhin \"  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . composers [  0  ]  . name \"  )  . value ( equalTo (  \" Johann   Sebastian   Bach \"  )  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . performers [  1  ]  . name \"  )  . value ( equalTo (  \" Yehudi   Menuhin \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equality"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.JsonPathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   composerByName    =     \"  $  . composers [  ?  (  @  . name    =  =     '  % s '  )  ]  \"  ;", "String   performerByName    =     \"  $  . performers [  ?  (  @  . name    =  =     '  % s '  )  ]  \"  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMjsonPath ( composerByName ,     \" Johann   Sebastian   Bach \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath ( composerByName ,     \" Johannes   Brahms \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath ( composerByName ,     \" Edvard   Grieg \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath ( composerByName ,     \" Robert   Schumann \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath ( performerByName ,     \" Vladimir   Ashkenazy \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath ( performerByName ,     \" Yehudi   Menuhin \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath (  \"  $  . composers [  0  ]  \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath (  \"  $  . composers [  1  ]  \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath (  \"  $  . composers [  2  ]  \"  )  . exists (  )  )  . andExpect ( MockMvcResultMjsonPath (  \"  $  . composers [  3  ]  \"  )  . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.JsonPathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . composers [  0  ]  . name \"  ,    startsWith (  \" Johann \"  )  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . performers [  0  ]  . name \"  ,    endsWith (  \" Ashkenazy \"  )  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . performers [  1  ]  . name \"  ,    containsString (  \" di   Me \"  )  )  )  . andExpect ( MockMvcResultMatchers . jsonPath (  \"  $  . composers [  1  ]  . name \"  ,    isIn ( Arrays . asList (  \" Johann   Sebastian   Bach \"  ,     \" Johannes   Brahms \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hamcrestMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.JsonPathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   composerName    =     \"  $  . composers [  % s ]  . name \"  ;", "String   performerName    =     \"  $  . performers [  % s ]  . name \"  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMjsonPath ( composerName ,     0  )  . value ( startsWith (  \" Johann \"  )  )  )  . andExpect ( MockMvcResultMjsonPath ( performerName ,     0  )  . value ( endsWith (  \" Ashkenazy \"  )  )  )  . andExpect ( MockMvcResultMjsonPath ( performerName ,     1  )  . value ( containsString (  \" di   Me \"  )  )  )  . andExpect ( MockMvcResultMjsonPath ( composerName ,     1  )  . value ( isIn ( Arrays . asList (  \" Johann   Sebastian   Bach \"  ,     \" Johannes   Brahms \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hamcrestMatcherWithParameterizedJsonPath"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.JsonPathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   JsonPathAssertionTests . MusicController (  )  )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  . accept ( APPLICATION _ JSON )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . alwaysExpect ( MockMvcResultMatchers . content (  )  . contentType (  \" application / json ; charset = UTF -  8  \"  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.JsonPathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "ModelAssertionTests . SampleController   controller    =    new   ModelAssertionTests . SampleController (  \" a   string   value \"  ,     3  ,    new   Person (  \" a   name \"  )  )  ;", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( controller )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . setControllerAdvice ( new   ModelAssertionTests . ModelAttributeAdvice (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ModelAssertionTests"}, {"methodBody": ["METHOD_START", "{", "mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" integer \"  ,     3  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" string \"  ,     \" a   string   value \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" integer \"  ,    equalTo (  3  )  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" string \"  ,    equalTo (  \" a   string   value \"  )  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" globalAttrName \"  ,    equalTo (  \" Global   Attribute   Value \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeEqualTo"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ModelAssertionTests"}, {"methodBody": ["METHOD_START", "{", "mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeExists (  \" integer \"  ,     \" string \"  ,     \" person \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" integer \"  ,    notNullValue (  )  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" INTEGER \"  ,    nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeExists"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ModelAssertionTests"}, {"methodBody": ["METHOD_START", "{", "mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" integer \"  ,    equalTo (  3  )  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" string \"  ,    allOf ( startsWith (  \" a   string \"  )  ,    endsWith (  \" value \"  )  )  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attribute (  \" person \"  ,    hasProperty (  \" name \"  ,    equalTo (  \" a   name \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeHamcrestMatchers"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ModelAssertionTests"}, {"methodBody": ["METHOD_START", "{", "mockMvc . perform ( MockMvcRequestBuilders . post (  \"  / persons \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . attributeHasErrors (  \" person \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHasErrors"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ModelAssertionTests"}, {"methodBody": ["METHOD_START", "{", "mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . model (  )  . hasNoErrors (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHasNoErrors"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ModelAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   RequestAttributeAssertionTests . SimpleController (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.RequestAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / main /  1  \"  )  . servletPath (  \"  / main \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . attribute ( BEST _ MATCHING _ PATTERN _ ATTRIBUTE ,     \"  /  { id }  \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . attribute ( PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE ,     \"  /  1  \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . attribute ( BEST _ MATCHING _ PATTERN _ ATTRIBUTE ,    equalTo (  \"  /  { id }  \"  )  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . attribute ( PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE ,    equalTo (  \"  /  1  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRequestAttributeEqualTo"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.RequestAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   producibleMediaTypes    =    HandlerMapping . PRODUCIBLE _ MEDIA _ TYPES _ ATTRIBUTE ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  1  \"  )  )  . andExpect ( MockMvcResultMrequest (  )  . attribute ( producibleMediaTypes ,    hasItem ( APPLICATION _ JSON )  )  )  . andExpect ( MockMvcResultMrequest (  )  . attribute ( producibleMediaTypes ,    not ( hasItem ( APPLICATION _ XML )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRequestAttributeMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.RequestAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   SessionAttributeAssertionTests . SimpleController (  )  )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.SessionAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . sessionAttribute (  \" locale \"  ,    Locale . UK )  )  . andExpect ( MockMvcResultMatchers . request (  )  . sessionAttribute (  \" locale \"  ,    equalTo ( Locale . UK )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSessionAttributeEqualTo"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.SessionAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . request (  )  . sessionAttribute (  \" locale \"  ,    notNullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSessionAttributeMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.SessionAttributeAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / created \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isCreated (  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / createdWithComposedAnnotation \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isCreated (  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / badRequest \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isBadRequest (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHttpStatus"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / badRequest \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . is ( equalTo (  4  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / badRequest \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . reason (  \" Expired   token \"  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / badRequest \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . reason ( equalTo (  \" Expired   token \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testReasonEqualTo"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / badRequest \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . reason ( endsWith (  \" token \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testReasonMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / created \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . is (  2  0  1  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / createdWithComposedAnnotation \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . is (  2  0  1  )  )  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / badRequest \"  )  )  . andExpect ( MockMvcResultMatchers . status (  )  . is (  4  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testStatusInt"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.StatusAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   UrlAssertionTests . SimpleController (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.UrlAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrl (  \"  / home \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testForward"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.UrlAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . forwardedUrlPattern (  \"  / ho ? e \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testForwardPattern"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.UrlAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons \"  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrl (  \"  / persons /  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRedirect"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.UrlAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / persons \"  )  )  . andExpect ( MockMvcResultMatchers . redirectedUrlPattern (  \"  / persons /  *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRedirectPattern"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.UrlAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   ViewNameAssertionTests . SimpleController (  )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ViewNameAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . view (  )  . name (  \" mySpecialView \"  )  )  . andExpect ( MockMvcResultMatchers . view (  )  . name ( equalTo (  \" mySpecialView \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEqualTo"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ViewNameAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  /  \"  )  )  . andExpect ( MockMvcResultMatchers . view (  )  . name ( containsString (  \" Special \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testHamcrestMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.ViewNameAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   XmlContentAssertionTests . MusicController (  )  )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  . accept ( APPLICATION _ XML ,    MediaType . parseMediaType (  \" application / xml ; charset = UTF -  8  \"  )  )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . alwaysExpect ( MockMvcResultMatchers . content (  )  . contentType ( MediaType . parseMediaType (  \" application / xml ; charset = UTF -  8  \"  )  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XmlContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . node ( hasXPath (  \"  / people / composers / composer [  1  ]  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNodeHamcrestMatcher"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XmlContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . xml ( XmlContentAssertionTests . PEOPLE _ XML )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlEqualTo"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XmlContentAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc    =    MockMvcBuilders . standaloneSetup ( new   XpathAssertionTests . MusicController (  )  )  . defaultRequest ( MockMvcRequestBuilders . get (  \"  /  \"  )  . accept ( APPLICATION _ XML ,    MediaType . parseMediaType (  \" application / xml ; charset = UTF -  8  \"  )  )  )  . alwaysExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . alwaysExpect ( MockMvcResultMatchers . content (  )  . contentType ( MediaType . parseMediaType (  \" application / xml ; charset = UTF -  8  \"  )  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XpathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   performerBooleanValue    =     \"  / ns : people / performers / performer [  % s ]  / someBoolean \"  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( performerBooleanValue ,     . musicNamespace ,     1  )  . booleanValue ( false )  )  . andExpect ( MockMvcResultMatchers . xpath ( performerBooleanValue ,     . musicNamespace ,     2  )  . booleanValue ( true )  )  ;", "}", "METHOD_END"], "methodName": ["testBoolean"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XpathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   composer    =     \"  / ns : people / composers / composer [  % s ]  \"  ;", "String   performer    =     \"  / ns : people / performers / performer [  % s ]  \"  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composer ,     . musicNamespace ,     0  )  . doesNotExist (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composer ,     . musicNamespace ,     5  )  . doesNotExist (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( performer ,     . musicNamespace ,     0  )  . doesNotExist (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( performer ,     . musicNamespace ,     3  )  . doesNotExist (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composer ,     . musicNamespace ,     0  )  . node ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotExist"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XpathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   composer    =     \"  / ns : people / composers / composer [  % s ]  \"  ;", "String   performer    =     \"  / ns : people / performers / performer [  % s ]  \"  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composer ,     . musicNamespace ,     1  )  . exists (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composer ,     . musicNamespace ,     2  )  . exists (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composer ,     . musicNamespace ,     3  )  . exists (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composer ,     . musicNamespace ,     4  )  . exists (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( performer ,     . musicNamespace ,     1  )  . exists (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( performer ,     . musicNamespace ,     2  )  . exists (  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composer ,     . musicNamespace ,     1  )  . node ( notNullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XpathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "MockMvcBuilders . standaloneSetup ( new   XpathAssertionTests . BlogFeedController (  )  )  . build (  )  . perform ( MockMvcRequestBuilders . get (  \"  / blog . atom \"  )  . accept ( APPLICATION _ ATOM _ XML )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andExpect ( MockMvcResultMatchers . content (  )  . contentTypeCompatibleWith ( APPLICATION _ ATOM _ XML )  )  . andExpect ( MockMvcResultMatchers . xpath (  \"  /  / feed / title \"  )  . string (  \" Test   Feed \"  )  )  . andExpect ( MockMvcResultMatchers . xpath (  \"  /  / feed / icon \"  )  . string (  \" http :  /  / www . example . com / favicon . ico \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFeedWithLinefeedChars"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XpathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . xpath (  \"  / ns : people / composers / composer \"  ,    XpathAssertionTests . musicNamespace )  . nodeCount (  4  )  )  . andExpect ( MockMvcResultMatchers . xpath (  \"  / ns : people / performers / performer \"  ,    XpathAssertionTests . musicNamespace )  . nodeCount (  2  )  )  . andExpect ( MockMvcResultMatchers . xpath (  \"  / ns : people / composers / composer \"  ,    XpathAssertionTests . musicNamespace )  . nodeCount ( equalTo (  4  )  )  )  . andExpect ( MockMvcResultMatchers . xpath (  \"  / ns : people / performers / performer \"  ,    XpathAssertionTests . musicNamespace )  . nodeCount ( equalTo (  2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNodeCount"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XpathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   composerDouble    =     \"  / ns : people / composers / composer [  % s ]  / someDouble \"  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerDouble ,     . musicNamespace ,     1  )  . number (  2  1  .  0  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerDouble ,     . musicNamespace ,     2  )  . number (  0  .  0  0  2  5  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerDouble ,     . musicNamespace ,     3  )  . number (  1  .  6  0  3  5  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerDouble ,     . musicNamespace ,     4  )  . number ( Double . NaN )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerDouble ,     . musicNamespace ,     1  )  . number ( equalTo (  2  1  .  0  )  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerDouble ,     . musicNamespace ,     3  )  . number ( closeTo (  1  .  6  ,     0  .  0  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNumber"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XpathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "String   composerName    =     \"  / ns : people / composers / composer [  % s ]  / name \"  ;", "String   performerName    =     \"  / ns : people / performers / performer [  % s ]  / name \"  ;", "this . mockMvc . perform ( MockMvcRequestBuilders . get (  \"  / music / people \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerName ,     . musicNamespace ,     1  )  . string (  \" Johann   Sebastian   Bach \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerName ,     . musicNamespace ,     2  )  . string (  \" Johannes   Brahms \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerName ,     . musicNamespace ,     3  )  . string (  \" Edvard   Grieg \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerName ,     . musicNamespace ,     4  )  . string (  \" Robert   Schumann \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( performerName ,     . musicNamespace ,     1  )  . string (  \" Vladimir   Ashkenazy \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( performerName ,     . musicNamespace ,     2  )  . string (  \" Yehudi   Menuhin \"  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerName ,     . musicNamespace ,     1  )  . string ( equalTo (  \" Johann   Sebastian   Bach \"  )  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerName ,     . musicNamespace ,     1  )  . string ( startsWith (  \" Johann \"  )  )  )  . andExpect ( MockMvcResultMatchers . xpath ( composerName ,     . musicNamespace ,     1  )  . string ( notNullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testString"], "fileName": "org.springframework.test.web.servlet.samples.standalone.resultmatchers.XpathAssertionTests"}, {"methodBody": ["METHOD_START", "{", "this . dispatcherServletCustomizers . add ( customizer )  ;", "return   self (  )  ;", "}", "METHOD_END"], "methodName": ["addDispatcherServletCustomizer"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( filter ,     \" filter   cannot   be   null \"  )  ;", "Assert . notNull ( urlPatterns ,     \" urlPatterns   cannot   be   null \"  )  ;", "if    (  ( urlPatterns . length )     >     0  )     {", "filter    =    new   PatternMappingFilterProxy ( filter ,    urlPatterns )  ;", "}", "this . filters . add ( filter )  ;", "return   self (  )  ;", "}", "METHOD_END"], "methodName": ["addFilter"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( filters ,     \" filters   cannot   be   null \"  )  ;", "for    ( Filter   f    :    filters )     {", "Assert . notNull ( f ,     \" filters   cannot   contain   null   values \"  )  ;", "this . filters . add ( f )  ;", "}", "return   self (  )  ;", "}", "METHOD_END"], "methodName": ["addFilters"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . globalResultHandlers . add ( resultHandler )  ;", "rrn   self (  )  ;", "}", "METHOD_END"], "methodName": ["alwaysDo"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . globalResultMatchers . add ( resultMatcher )  ;", "rrn   self (  )  ;", "}", "METHOD_END"], "methodName": ["alwaysExpect"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "configurer . afterConfigurerAdded ( this )  ;", "this . configurers . add ( configurer )  ;", "rrn   self (  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . defaultRequestBuilder    =    requestBuilder ;", "return   self (  )  ;", "}", "METHOD_END"], "methodName": ["defaultRequest"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "return   addDispatcherServletCustomizer (  (    dispatcherServlet )     -  >    dispatcherServlet . setDispatchOptionsRequest ( dispatchOptions )  )  ;", "}", "METHOD_END"], "methodName": ["dispatchOptions"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["self"], "fileName": "org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "request . setRequestURI (  (  ( request . getContextPath (  )  )     +    requestUri )  )  ;", "filter    =    new   PatternMappingFilterProxy ( delegate ,    pattern )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertThat ( delegate . request ,    equalTo (  (  ( ServletRequest )     ( request )  )  )  )  ;", "assertThat ( delegate . response ,    equalTo (  (  ( ServletResponse )     ( response )  )  )  )  ;", "assertThat ( delegate . chain ,    equalTo (  (  ( FilterChain )     ( filterChain )  )  )  )  ;", "delegate    =    new    . MockFilter (  )  ;", "}", "METHOD_END"], "methodName": ["assertFilterInvoked"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "request . setRequestURI (  (  ( request . getContextPath (  )  )     +    requestUri )  )  ;", "filter    =    new   PatternMapp ( delegate ,    pattern )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertThat ( delegate . request ,    equalTo (  (  ( ServletRequest )     ( null )  )  )  )  ;", "assertThat ( delegate . response ,    equalTo (  (  ( ServletResponse )     ( null )  )  )  )  ;", "assertThat ( delegate . chain ,    equalTo (  (  ( FilterChain )     ( null )  )  )  )  ;", "assertThat ( filterChain . getRequest (  )  ,    equalTo (  (  ( ServletRequest )     ( request )  )  )  )  ;", "assertThat ( filterChain . getResponse (  )  ,    equalTo (  (  ( ServletResponse )     ( response )  )  )  )  ;", "filterChain    =    new   MockFilterChain (  )  ;", "}", "METHOD_END"], "methodName": ["assertFilterNotInvoked"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "filter    =    new   PatternMappingFilterProxy ( delegate ,     \"  /  \"  )  ;", "filter . destroy (  )  ;", "assertThat ( delegate . destroy ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "FilterConfig   config    =    new   MockFilterConfig (  )  ;", "filter    =    new   PatternMapp ( delegate ,     \"  /  \"  )  ;", "filter . init ( config )  ;", "assertThat ( delegate . filterConfig ,    is ( config )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test \"  ,     \"  / test \"  )  ;", "}", "METHOD_END"], "methodName": ["matchExact"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  \"  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchExactEmpty"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test / this . html \"  ,     \"  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["matchExtension"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test / this / here . html \"  ,     \"  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["matchExtensionMulti"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test . html \"  ,     \"  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["matchExtensionNoFolder"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  /  . html \"  ,     \"  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["matchExtensionNoPrefix"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test \"  ,     \"  /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchPathMappingAll"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  \"  ,     \"  /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchPathMappingAllContextRoot"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test / this \"  ,     \"  /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchPathMappingAllFolder"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  /  \"  ,     \"  /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchPathMappingContextRootAndSlash"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test / this \"  ,     \"  / test /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchPathMappingFolderPattern"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test / this / here \"  ,     \"  / test /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchPathMappingFolderPatternWithMultiFolderPath"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test \"  ,     \"  / test /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchPathMappingMissingSlash"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / test /  \"  ,     \"  / test /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["matchPathMappingNoSuffix"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  / index . htm \"  ,     \"  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchExtensionLarger"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  . html \"  ,     \"  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchExtensionNoSlash"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  / index . html .  \"  ,     \"  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchExtensionPeriodEnd"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  / index . html /  \"  ,     \"  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchExtensionSlashEnd"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  / index . html \"  ,     \"  /  *  . html \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchInvalidPattern"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  / this / test \"  ,     \"  / test /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchPathMappingEnd"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  / test 2  /  \"  ,     \"  / test /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchPathMappingEndSuffix"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  / test 2  \"  ,     \"  / test /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchPathMappingMissingSlash"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterNotInvoked (  \"  / this / test / here \"  ,     \"  / test /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["noMatchPathMappingMulti"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "request    =    new   MockHttpServletRequest (  )  ;", "request . setContextPath (  \"  / context \"  )  ;", "response    =    new   MockHttpServletResponse (  )  ;", "filterChain    =    new   MockFilterChain (  )  ;", "delegate    =    new    . MockFilter (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / catalog \"  ,     \"  / catalog \"  )  ;", "}", "METHOD_END"], "methodName": ["specExactMatch"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / index . bop \"  ,     \"  *  . bop \"  )  ;", "}", "METHOD_END"], "methodName": ["specExtensionMapping"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / catalog / racecar . bop \"  ,     \"  *  . bop \"  )  ;", "}", "METHOD_END"], "methodName": ["specExtensionMappingSingleFolder"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / baz / index . html \"  ,     \"  / baz /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["specPathMapping"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / foo / bar / index . html \"  ,     \"  / foo / bar /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["specPathMappingMultiFolderPattern"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / foo / bar / index . bop \"  ,     \"  / foo / bar /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["specPathMappingMultiFolderPatternAlternate"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "assertFilterInvoked (  \"  / baz \"  ,     \"  / baz /  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["specPathMappingNoSlash"], "fileName": "org.springframework.test.web.servlet.setup.ConditionalDelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "StubWebApplicationContext   root    =    new   StubWebApplicationContext ( this . servletContext )  ;", "builder    =    MockMvcBuilders . webAppContextSetup ( root )  ;", "builder . addDispatcherServletCustomizer (  (    ds )     -  >    ds . setContextId (  \" test - id \"  )  )  ;", "builder . dispatchOptions ( true )  ;", "MockMvc   mvc    =    builder . build (  )  ;", "DispatcherServlet   ds    =     (  ( DispatcherServlet )     ( new   DirectFieldAccessor ( mvc )  . getPropertyValue (  \" servlet \"  )  )  )  ;", "assertEquals (  \" test - id \"  ,    ds . getContextId (  )  )  ;", "}", "METHOD_END"], "methodName": ["dispatcherServletCustomizer"], "fileName": "org.springframework.test.web.servlet.setup.DefaultMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StubWebApplicationContext   root    =    new   StubWebApplicationContext ( this . servletContext )  ;", "builder    =    MockMvcBuilders . webAppContextSetup ( root )  ;", "builder . addDispatcherServletCustomizer (  (    ds )     -  >    ds . setContextId (  \" test - id \"  )  )  ;", "builder . addDispatcherServletCustomizer (  (    ds )     -  >    ds . setContextId (  \" override - id \"  )  )  ;", "builder . dispatchOptions ( true )  ;", "MockMvc   mvc    =    builder . build (  )  ;", "DispatcherServlet   ds    =     (  ( DispatcherServlet )     ( new   DirectFieldAccessor ( mvc )  . getPropertyValue (  \" servlet \"  )  )  )  ;", "assertEquals (  \" override - id \"  ,    ds . getContextId (  )  )  ;", "}", "METHOD_END"], "methodName": ["dispatcherServletCustomizerProcessedInOrder"], "fileName": "org.springframework.test.web.servlet.setup.DefaultMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StubWebApplicationContext   root    =    new   StubWebApplicationContext ( this . servletContext )  ;", "builder    =    MockMvcBuilders . webAppContextSetup ( root )  ;", "WebApplicationContext   wac    =    builder . initWebAppContext (  )  ;", "assertSame ( root ,    wac )  ;", "assertSame ( root ,    WebApplicationContextUtils . getRequiredWebApplicationContext ( this . servletContext )  )  ;", "}", "METHOD_END"], "methodName": ["rootWacServletContainerAttributeNotPreviouslySet"], "fileName": "org.springframework.test.web.servlet.setup.DefaultMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ear    =    new   StaticApplicationContext (  )  ;", "StaticWebApplicationContext   root    =    new   StaticWebApplicationContext (  )  ;", "root . setParent ( ear )  ;", "root . setServletContext ( this . servletContext )  ;", "StaticWebApplicationContext   dispatcher    =    new   StaticWebApplicationContext (  )  ;", "dispatcher . setParent ( root )  ;", "dispatcher . setServletContext ( this . servletContext )  ;", "builder    =    MockMvcBuilders . webAppContextSetup ( dispatcher )  ;", "WebApplicationContext   wac    =    builder . initWebAppContext (  )  ;", "assertSame ( dispatcher ,    wac )  ;", "assertSame ( root ,    wac . getParent (  )  )  ;", "assertSame ( ear ,    wac . getParent (  )  . getParent (  )  )  ;", "assertSame ( root ,    WebApplicationContextUtils . getRequiredWebApplicationContext ( this . servletContext )  )  ;", "}", "METHOD_END"], "methodName": ["rootWacServletContainerAttributeNotPreviouslySetWithContextHierarchy"], "fileName": "org.springframework.test.web.servlet.setup.DefaultMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StubWebApplicationContext   child    =    new   StubWebApplicationContext ( this . servletContext )  ;", "this . servletContext . setAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    child )  ;", "builder    =    MockMvcBuilders . webAppContextSetup ( child )  ;", "assertSame ( builder . initWebAppContext (  )  ,    WebApplicationContextUtils . getRequiredWebApplicationContext ( this . servletContext )  )  ;", "}", "METHOD_END"], "methodName": ["rootWacServletContainerAttributePreviouslySet"], "fileName": "org.springframework.test.web.servlet.setup.DefaultMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StubWebApplicationContext   root    =    new   StubWebApplicationContext ( this . servletContext )  ;", "this . servletContext . setAttribute ( ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    root )  ;", "StaticWebApplicationContext   child    =    new   StaticWebApplicationContext (  )  ;", "child . setParent ( root )  ;", "child . setServletContext ( this . servletContext )  ;", "builder    =    MockMvcBuilders . webAppContextSetup ( child )  ;", "assertSame ( builder . initWebAppContext (  )  . getParent (  )  ,    WebApplicationContextUtils . getRequiredWebApplicationContext ( this . servletContext )  )  ;", "}", "METHOD_END"], "methodName": ["rootWacServletContainerAttributePreviouslySetWithContextHierarchy"], "fileName": "org.springframework.test.web.servlet.setup.DefaultMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( equalTo (  \" WebApplicationContext   must   have   a   ServletContext \"  )  )  ;", "s . webAppContextSetup ( new   StubWebApplicationContext ( null )  )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetupWithNullServletContext"], "fileName": "org.springframework.test.web.servlet.setup.DefaultMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( equalTo (  \" WebApplicationContext   is   required \"  )  )  ;", "s . webAppContextSetup ( null )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetupWithNullWac"], "fileName": "org.springframework.test.web.servlet.setup.DefaultMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   new   StandaloneMockMvcBuilder ( controllers )  ;", "}", "METHOD_END"], "methodName": ["standaloneSetup"], "fileName": "org.springframework.test.web.servlet.setup.MockMvcBuilders"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultMockMvcBuilder ( context )  ;", "}", "METHOD_END"], "methodName": ["webAppContextSetup"], "fileName": "org.springframework.test.web.servlet.setup.MockMvcBuilders"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["beforeMockMvcCreated"], "fileName": "org.springframework.test.web.servlet.setup.MockMvcConfigurer"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( urlPattern ,     \" Found   null   URL   Pattern \"  )  ;", "if    ( urlPattern . startsWith (  . EXTENSION _ MAPPING _ PATTERN )  )     {", "this . endsWithMatches . add ( urlPattern . substring (  1  ,    urlPattern . length (  )  )  )  ;", "} else", "if    ( urlPattern . equals (  . PATH _ MAPPING _ PATTERN )  )     {", "this . startsWithMatches . add (  \"  \"  )  ;", "} else", "if    ( urlPattern . endsWith (  . PATH _ MAPPING _ PATTERN )  )     {", "this . startsWithMatches . add ( urlPattern . substring (  0  ,     (  ( urlPattern . length (  )  )     -     1  )  )  )  ;", "this . exactMatches . add ( urlPattern . substring (  0  ,     (  ( urlPattern . length (  )  )     -     2  )  )  )  ;", "} else    {", "if    (  \"  \"  . equals ( urlPattern )  )     {", "urlPattern    =     \"  /  \"  ;", "}", "this . exactMatches . add ( urlPattern )  ;", "}", "}", "METHOD_END"], "methodName": ["addUrlPattern"], "fileName": "org.springframework.test.web.servlet.setup.PatternMappingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "for    ( String   pattern    :    this . exactMatches )     {", "if    ( pattern . equals ( requestPath )  )     {", "return   true ;", "}", "}", "if    (  !  ( requestPath . startsWith (  \"  /  \"  )  )  )     {", "return   false ;", "}", "for    ( String   pattern    :    this . endsWithMatches )     {", "if    ( requestPath . endsWith ( pattern )  )     {", "return   true ;", "}", "}", "for    ( String   pattern    :    this . startsWithMatches )     {", "if    ( requestPath . startsWith ( pattern )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.springframework.test.web.servlet.setup.PatternMappingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "return   new   SharedHttpSessionConfigurer (  )  ;", "}", "METHOD_END"], "methodName": ["sharedHttpSession"], "fileName": "org.springframework.test.web.servlet.setup.SharedHttpSessionConfigurer"}, {"methodBody": ["METHOD_START", "{", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   SharedHttpSessionTests . TestController (  )  )  . apply ( SharedHttpSessionConfigurer . sharedHttpSession (  )  )  . build (  )  ;", "String   url    =     \"  / session \"  ;", "MvcResult   result    =    mockMvc . perform ( MockMvcRequestBuilders . get ( url )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andReturn (  )  ;", "HttpSession   session    =    result . getRequest (  )  . getSession ( false )  ;", "assertNotNull ( session )  ;", "assertEquals (  1  ,    session . getAttribute (  \" counter \"  )  )  ;", "result    =    mockMvc . perform ( MockMvcRequestBuilders . get ( url )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andReturn (  )  ;", "session    =    result . getRequest (  )  . getSession ( false )  ;", "assertNotNull ( session )  ;", "assertEquals (  2  ,    session . getAttribute (  \" counter \"  )  )  ;", "result    =    mockMvc . perform ( MockMvcRequestBuilders . get ( url )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andReturn (  )  ;", "session    =    result . getRequest (  )  . getSession ( false )  ;", "assertNotNull ( session )  ;", "assertEquals (  3  ,    session . getAttribute (  \" counter \"  )  )  ;", "}", "METHOD_END"], "methodName": ["httpSession"], "fileName": "org.springframework.test.web.servlet.setup.SharedHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "MockMvc   mockMvc    =    MockMvcBuilders . standaloneSetup ( new   SharedHttpSessionTests . TestController (  )  )  . apply ( SharedHttpSessionConfigurer . sharedHttpSession (  )  )  . build (  )  ;", "String   url    =     \"  / no - session \"  ;", "MvcResult   result    =    mockMvc . perform ( MockMvcRequestBuilders . get ( url )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andReturn (  )  ;", "HttpSession   session    =    result . getRequest (  )  . getSession ( false )  ;", "assertNull ( session )  ;", "result    =    mockMvc . perform ( MockMvcRequestBuilders . get ( url )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andReturn (  )  ;", "session    =    result . getRequest (  )  . getSession ( false )  ;", "assertNull ( session )  ;", "url    =     \"  / session \"  ;", "result    =    mockMvc . perform ( MockMvcRequestBuilders . get ( url )  )  . andExpect ( MockMvcResultMatchers . status (  )  . isOk (  )  )  . andReturn (  )  ;", "session    =    result . getRequest (  )  . getSession ( false )  ;", "assertNotNull ( session )  ;", "assertEquals (  1  ,    session . getAttribute (  \" counter \"  )  )  ;", "}", "METHOD_END"], "methodName": ["noHttpSession"], "fileName": "org.springframework.test.web.servlet.setup.SharedHttpSessionTests"}, {"methodBody": ["METHOD_START", "{", "addMappedInterceptors ( null ,    interceptors )  ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["addInterceptors"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( HandlerInterceptor   interceptor    :    interceptors )     {", "this . mappedInterceptors . add ( new   web . servlet . handler . MappedInterceptor ( pathPatterns ,    interceptor )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addMappedInterceptors"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . placeholderValues . put ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addPlaceholderValue"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . viewResolvers    =     (  ( this . viewResolvers )     !  =    null )     ?    this . viewResolvers    :    Collections . singletonList ( new   InternalResourceViewResolver (  )  )  ;", "for    ( Object   viewResolver    :    this . viewResolvers )     {", "if    ( viewResolver   instanceof   WebApplicationObjectSupport )     {", "(  ( WebApplicationObjectSupport )     ( viewResolver )  ) ApplicationContext ( wac )  ;", "}", "}", "return   this . viewResolvers ;", "}", "METHOD_END"], "methodName": ["initViewResolvers"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "List < Object >    instances    =    new   ArrayList <  >  ( specified . length )  ;", "for    ( Object   obj    :    specified )     {", "instances . add (  ( obj   instanceof   Class    ?    BeanUtils . instantiateClass (  (  ( Class <  ?  >  )     ( obj )  )  )     :    obj )  )  ;", "}", "return   instances ;", "}", "METHOD_END"], "methodName": ["instantiateIfNecessary"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilder . StandaloneConfiguration   config    =    new   StandaloneMockMvcBuilder . StandaloneConfiguration (  )  ;", "config . setApplicationContext ( wac )  ;", "ServletContext   sc    =    wac . getServletContext (  )  ;", "wac . addBeans ( this . controllers )  ;", "wac . addBeans ( this . controllerAdvice )  ;", "RequestMappingHandlerMapping   hm    =    config . getHandlerMapping (  )  ;", "if    ( sc    !  =    null )     {", "hm . setServletContext ( sc )  ;", "}", "hm . setApplicationContext ( wac )  ;", "hm . afterPropertiesSet (  )  ;", "wac . addBean (  \" requestMappingHandlerMapping \"  ,    hm )  ;", "RequestMappingHandlerAdapter   ha    =    config . requestMappingHandlerAdapter (  )  ;", "if    ( sc    !  =    null )     {", "ha . setServletContext ( sc )  ;", "}", "ha . setApplicationContext ( wac )  ;", "ha . afterPropertiesSet (  )  ;", "wac . addBean (  \" requestMappingHandlerAdapter \"  ,    ha )  ;", "wac . addBean (  \" handlerExceptionResolver \"  ,    config . handlerExceptionResolver (  )  )  ;", "wac . addBeans ( initViewResolvers ( wac )  )  ;", "wac . addBean ( LOCALE _ RESOLVER _ BEAN _ NAME ,    this . localeResolver )  ;", "wac . addBean ( THEME _ RESOLVER _ BEAN _ NAME ,    new   FixedThemeResolver (  )  )  ;", "wac . addBean ( REQUEST _ TO _ VIEW _ NAME _ TRANSLATOR _ BEAN _ NAME ,    new   DefaultRequestToViewNameTranslator (  )  )  ;", "this . flashMapManager    =    new   SessionFlashMapManager (  )  ;", "wac . addBean ( FLASH _ MAP _ MANAGER _ BEAN _ NAME ,    this . flashMapManager )  ;", "}", "METHOD_END"], "methodName": ["registerMvcSingletons"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . asyncRequestTimeout    =    timeout ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAsyncRequestTimeout"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . contentNegotiationManager    =    manager ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["setContentNegotiationManager"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . controllerAdvice    =    StandaloneMockMvcBuilder . instantiateIfNecessary ( controllerAdvice )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setControllerAdvice"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . conversionService    =    conversionService ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setConversionService"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . customArgumentResolvers    =    Arrays . asList ( argumentResolvers )  ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["setCustomArgumentResolvers"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . handlerMappingFactory    =    factory ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCustomHandlerMapping"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . customReturnValueHandlers    =    Arrays . asList ( handlers )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCustomReturnValueHandlers"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . flashMapManager    =    flashMapManager ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["setFlashMapManager"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . handlerExceptionResolvers    =    exceptionResolvers ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHandlerExceptionResolvers"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . handlerExceptionResolvers    =    Arrays . asList ( exceptionResolvers )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHandlerExceptionResolvers"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . localeResolver    =    localeResolver ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["setLocaleResolver"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . messageConverters    =    Arrays . asList ( messageConverters )  ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["setMessageConverters"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . removeSemicolonContent    =    removeSemicolonContent ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRemoveSemicolonContent"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . viewResolvers    =    Collections .  < ViewResolver > singletonList ( new   StandaloneMockMvcBuilder . StaticViewResolver ( view )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSingleView"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . useSuffixPatternMatch    =    useSuffixPatternMatch ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["setUseSuffixPatternMatch"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . useTrailingSlashPatternMatch    =    useTrailingSlashPatternMatch ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUseTrailingSlashPatternMatch"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . validator    =    validator ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["setValidator"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "this . viewResolvers    =    Arrays . asList ( resolvers )  ;", "rrn   this ;", "}", "METHOD_END"], "methodName": ["setViewResolvers"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilder   builder    =    MockMvcBuilders . standaloneSetup ( new   StandaloneMockMvcBuilderTests . PersonController (  )  )  ;", "builder . addFilter ( new   StandaloneMockMvcBuilderTests . ContinueFilter (  )  ,     (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addFilterPatternContainsNull"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilder   builder    =    MockMvcBuilders . standaloneSetup ( new   StandaloneMockMvcBuilderTests . PersonController (  )  )  ;", "builder . addFilter ( new   StandaloneMockMvcBuilderTests . ContinueFilter (  )  ,     (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addFilterPatternsNull"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilder   builder    =    MockMvcBuilders . standaloneSetup ( new   StandaloneMockMvcBuilderTests . PersonController (  )  )  ;", "builder . addFilters ( new   StandaloneMockMvcBuilderTests . ContinueFilter (  )  ,     (  ( Filter )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addFiltersFiltersContainsNull"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilder   builder    =    MockMvcBuilders . standaloneSetup ( new   StandaloneMockMvcBuilderTests . PersonController (  )  )  ;", "builder . addFilters (  (  ( Filter [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addFiltersFiltersNull"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilderTests . TestStandaloneMockMvcBuilder   builder    =    new   StandaloneMockMvcBuilderTests . TestStandaloneMockMvcBuilder ( new   StandaloneMockMvcBuilderTests . PlaceholderController (  )  )  ;", "builder . addPlaceholderValue (  \" sys . login . ajax \"  ,     \"  / foo \"  )  ;", "WebApplicationContext   wac    =    builder . initWebAppContext (  )  ;", "assertEquals ( wac ,    WebApplicationContextUtils . getRequiredWebApplicationContext ( wac . getServletContext (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["applicationContextAttribute"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilderTests . TestStandaloneMockMvcBuilder   builder    =    new   StandaloneMockMvcBuilderTests . TestStandaloneMockMvcBuilder ( new   StandaloneMockMvcBuilderTests . PlaceholderController (  )  )  ;", "builder . addPlaceholderValue (  \" sys . login . ajax \"  ,     \"  / foo \"  )  ;", "builder . build (  )  ;", "RequestMappingHandlerMapping   hm    =    builder . wac . getBean ( RequestMappingHandlerMapping . class )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / foo \"  )  ;", "HandlerExecutionChain   chain    =    hm . getHandler ( request )  ;", "assertNotNull ( chain )  ;", "assertEquals (  \" handleWithPlaceholders \"  ,     (  ( HandlerMethod )     ( chain . getHandler (  )  )  )  . getMethod (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["placeHoldersInRequestMapping"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilderTests . TestStandaloneMockMvcBuilder   builder    =    new   StandaloneMockMvcBuilderTests . TestStandaloneMockMvcBuilder ( new   StandaloneMockMvcBuilderTests . PersonController (  )  )  ;", "builder . build (  )  ;", "SpringHandlerInstantiator   instantiator    =    new   SpringHandlerInstantiator ( builder . wac . getAutowireCapableBeanFactory (  )  )  ;", "JsonSerializer   serializer    =    instantiator . serializerInstance ( null ,    null ,    UnknownSerializer . class )  ;", "assertNotNull ( serializer )  ;", "}", "METHOD_END"], "methodName": ["springHandlerInstantiator"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "StandaloneMockMvcBuilderTests . TestStandaloneMockMvcBuilder   builder    =    new   StandaloneMockMvcBuilderTests . TestStandaloneMockMvcBuilder ( new   StandaloneMockMvcBuilderTests . PersonController (  )  )  ;", "builder . setUseSuffixPatternMatch ( false )  ;", "builder . build (  )  ;", "RequestMappingHandlerMapping   hm    =    builder . wac . getBean ( RequestMappingHandlerMapping . class )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / persons \"  )  ;", "HandlerExecutionChain   chain    =    hm . getHandler ( request )  ;", "assertNotNull ( chain )  ;", "assertEquals (  \" persons \"  ,     (  ( HandlerMethod )     ( chain . getHandler (  )  )  )  . getMethod (  )  . getName (  )  )  ;", "request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / persons . xml \"  )  ;", "chain    =    hm . getHandler ( request )  ;", "assertNull ( chain )  ;", "}", "METHOD_END"], "methodName": ["suffixPatternMatch"], "fileName": "org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . addBean ( name ,    bean )  ;", "}", "METHOD_END"], "methodName": ["addBean"], "fileName": "org.springframework.test.web.servlet.setup.StubWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    ( beans    !  =    null )     {", "for    ( Object   bean    :    beans )     {", "St   name    =     (  ( bean . getClass (  )  . getName (  )  )     +     \"  #  \"  )     +     ( ObjectUtils . getIdentityHexSt ( bean )  )  ;", "this . beanFactory . addBean ( name ,    bean )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addBeans"], "fileName": "org.springframework.test.web.servlet.setup.StubWebApplicationContext"}]