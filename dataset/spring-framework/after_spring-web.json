[{"methodBody": ["METHOD_START", "{", "return   this . executed ;", "}", "METHOD_END"], "methodName": ["wasExecuted"], "fileName": "org.springframework.core.task.MockRunnable"}, {"methodBody": ["METHOD_START", "{", "if    (  ( builder . length (  )  )     >     0  )     {", "builder . append (  \"  ,     \"  )  ;", "}", "builder . append ( value )  ;", "}", "METHOD_END"], "methodName": ["appendDirective"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "this . cachePrivate    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["cachePrivate"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "this . cachePublic    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["cachePublic"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "return   new   CacheControl (  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   ccValue    =    new   StringBuilder (  )  ;", "if    (  ( this . maxAge )     !  =     (  -  1  )  )     {", "appendDirective ( ccValue ,     (  \" max - age =  \"     +     ( Long . toString ( this . maxAge )  )  )  )  ;", "}", "if    ( this . no )     {", "appendDirective ( ccValue ,     \" no - cache \"  )  ;", "}", "if    ( this . noStore )     {", "appendDirective ( ccValue ,     \" no - store \"  )  ;", "}", "if    ( this . mustRevalidate )     {", "appendDirective ( ccValue ,     \" must - revalidate \"  )  ;", "}", "if    ( this . noTransform )     {", "appendDirective ( ccValue ,     \" no - transform \"  )  ;", "}", "if    ( this . cachePublic )     {", "appendDirective ( ccValue ,     \" public \"  )  ;", "}", "if    ( this . cachePrivate )     {", "appendDirective ( ccValue ,     \" private \"  )  ;", "}", "if    ( this . proxyRevalidate )     {", "appendDirective ( ccValue ,     \" proxy - revalidate \"  )  ;", "}", "if    (  ( this . sMaxAge )     !  =     (  -  1  )  )     {", "appendDirective ( ccValue ,     (  \" s - maxage =  \"     +     ( Long . toString ( this . sMaxAge )  )  )  )  ;", "}", "if    (  ( this . staleIfError )     !  =     (  -  1  )  )     {", "appendDirective ( ccValue ,     (  \" stale - if - error =  \"     +     ( Long . toString ( this . staleIfError )  )  )  )  ;", "}", "if    (  ( this . staleWhileRevalidate )     !  =     (  -  1  )  )     {", "appendDirective ( ccValue ,     (  \" stale - while - revalidate =  \"     +     ( Long . toString ( this . staleWhileRevalidate )  )  )  )  ;", "}", "String   ccHeaderValue    =    ccValue . toString (  )  ;", "return   StringUtils . hasText ( ccHeaderValue )     ?    ccHeaderValue    :    null ;", "}", "METHOD_END"], "methodName": ["getHeaderValue"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    new   CacheControl (  )  ;", "cc . maxAge    =    unit . toSeconds ( maxAge )  ;", "return   cc ;", "}", "METHOD_END"], "methodName": ["maxAge"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "this . mustRevalidate    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mustRevalidate"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    new   CacheControl (  )  ;", "cc . noCache    =    true ;", "return   cc ;", "}", "METHOD_END"], "methodName": ["noCache"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    new   CacheControl (  )  ;", "cc . noStore    =    true ;", "return   cc ;", "}", "METHOD_END"], "methodName": ["noStore"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "this . noTransform    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["noTransform"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "this . proxyRevalidate    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["proxyRevalidate"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "this . sMaxAge    =    unit . toSeconds ( sMaxAge )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sMaxAge"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "this . staleIfError    =    unit . toSeconds ( staleIfError )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["staleIfError"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "this . staleWhileRevalidate    =    unit . toSeconds ( staleWhileRevalidate )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["staleWhileRevalidate"], "fileName": "org.springframework.http.CacheControl"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    CacheControl . empty (  )  ;", "assertThat ( cc . getHeaderValue (  )  ,    Matchers . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyCacheControl"], "fileName": "org.springframework.http.CacheControlTests"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    CacheControl . maxAge (  1  ,    TimeUnit . HOURS )  ;", "assertThat ( cc . getHeaderValue (  )  ,    Matchers . equalTo (  \" max - age =  3  6  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["maxAge"], "fileName": "org.springframework.http.CacheControlTests"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    CacheControl . maxAge (  3  6  0  0  ,    TimeUnit . SECONDS )  . cachePublic (  )  . noTransform (  )  ;", "assertThat ( cc . getHeaderValue (  )  ,    Matchers . equalTo (  \" max - age =  3  6  0  0  ,    no - transform ,    public \"  )  )  ;", "}", "METHOD_END"], "methodName": ["maxAgeAndDirectives"], "fileName": "org.springframework.http.CacheControlTests"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    CacheControl . maxAge (  1  ,    TimeUnit . HOURS )  . sMaxAge (  3  0  ,    TimeUnit . MINUTES )  ;", "assertThat ( cc . getHeaderValue (  )  ,    Matchers . equalTo (  \" max - age =  3  6  0  0  ,    s - maxage =  1  8  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["maxAgeAndSMaxAge"], "fileName": "org.springframework.http.CacheControlTests"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    CacheControl . noCache (  )  . cachePrivate (  )  ;", "assertThat ( cc . getHeaderValue (  )  ,    Matchers . equalTo (  \" no - cache ,    private \"  )  )  ;", "}", "METHOD_END"], "methodName": ["noCachePrivate"], "fileName": "org.springframework.http.CacheControlTests"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    CacheControl . noStore (  )  ;", "assertThat ( cc . getHeaderValue (  )  ,    Matchers . equalTo (  \" no - store \"  )  )  ;", "}", "METHOD_END"], "methodName": ["noStore"], "fileName": "org.springframework.http.CacheControlTests"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    CacheControl . maxAge (  1  ,    TimeUnit . HOURS )  . staleIfError (  2  ,    TimeUnit . HOURS )  ;", "assertThat ( cc . getHeaderValue (  )  ,    Matchers . equalTo (  \" max - age =  3  6  0  0  ,    stale - if - error =  7  2  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["staleIfError"], "fileName": "org.springframework.http.CacheControlTests"}, {"methodBody": ["METHOD_START", "{", "CacheControl   cc    =    CacheControl . maxAge (  1  ,    TimeUnit . HOURS )  . staleWhileRevalidate (  2  ,    TimeUnit . HOURS )  ;", "assertThat ( cc . getHeaderValue (  )  ,    Matchers . equalTo (  \" max - age =  3  6  0  0  ,    stale - while - revalidate =  7  2  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["staleWhileRevalidate"], "fileName": "org.springframework.http.CacheControlTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ContentDisposition . BuilderImpl ( type )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( input ,     \" Input   String   should   not   be   null \"  )  ;", "int   firstQuoteIndex    =    input . indexOf (  '  \\  '  '  )  ;", "int   secondQuoteIndex    =    input . indexOf (  '  \\  '  '  ,     ( firstQuoteIndex    +     1  )  )  ;", "if    (  ( firstQuoteIndex    =  =     (  -  1  )  )     |  |     ( secondQuoteIndex    =  =     (  -  1  )  )  )     {", "return   input ;", "}", "Charset   charset    =    Charset . forName ( input . substring (  0  ,    firstQuoteIndex )  )  ;", "Assert . isTrue (  (  ( StandardCharsets . UTF _  8  . equals ( charset )  )     |  |     ( StandardCharsets . ISO _  8  8  5  9  _  1  . equals ( charset )  )  )  ,     \" Charset   should   be   UTF -  8    or   ISO -  8  8  5  9  -  1  \"  )  ;", "byte [  ]    value    =    input . substring (  ( secondQuoteIndex    +     1  )  ,    input . length (  )  )  . getBytes ( charset )  ;", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream (  )  ;", "int   index    =     0  ;", "while    ( index    <     ( value . length )  )     {", "byte   b    =    value [ index ]  ;", "if    (  . isRFC 5  9  8  7 AttrChar ( b )  )     {", "bos . write (  (  ( char )     ( b )  )  )  ;", "index +  +  ;", "} else", "if    ( b    =  =     '  %  '  )     {", "char [  ]    array    =    new   char [  ]  {     (  ( char )     ( value [  ( index    +     1  )  ]  )  )  ,     (  ( char )     ( value [  ( index    +     2  )  ]  )  )     }  ;", "bos . write ( Integer . parseInt ( String . valueOf ( array )  ,     1  6  )  )  ;", "index    +  =     3  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Invalid   header   field   parameter   format    ( as   defined   in   RFC    5  9  8  7  )  \"  )  ;", "}", "}", "return   new   String ( bos . toByteArray (  )  ,    charset )  ;", "}", "METHOD_END"], "methodName": ["decodeHeaderFieldParam"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   new   ContentDisposition (  \"  \"  ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( input ,     \" Input   String   should   not   be   null \"  )  ;", "Assert . notNull ( charset ,     \" Charset   should   not   be   null \"  )  ;", "if    ( StandardCharsets . US _ ASCII . equals ( charset )  )     {", "return   input ;", "}", "Assert . isTrue (  (  ( StandardCharsets . UTF _  8  . equals ( charset )  )     |  |     ( StandardCharsets . ISO _  8  8  5  9  _  1  . equals ( charset )  )  )  ,     \" Charset   should   be   UTF -  8    or   ISO -  8  8  5  9  -  1  \"  )  ;", "byte [  ]    source    =    input . getBytes ( charset )  ;", "int   len    =    source . length ;", "StringBuilder   sb    =    new   StringBuilder (  ( len    <  <     1  )  )  ;", "sb . append ( charset . name (  )  )  ;", "sb . append (  \"  '  '  \"  )  ;", "for    ( byte   b    :    source )     {", "if    (  . isRFC 5  9  8  7 AttrChar ( b )  )     {", "sb . append (  (  ( char )     ( b )  )  )  ;", "} else    {", "sb . append (  '  %  '  )  ;", "char   hex 1     =    Character . toUpperCase ( Character . forDigit (  (  ( b    >  >     4  )     &     1  5  )  ,     1  6  )  )  ;", "char   hex 2     =    Character . toUpperCase ( Character . forDigit (  ( b    &     1  5  )  ,     1  6  )  )  ;", "sb . append ( hex 1  )  ;", "sb . append ( hex 2  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["encodeHeaderFieldParam"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   this . charset ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   this . creationDate ;", "}", "METHOD_END"], "methodName": ["getCreationDate"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   this . filename ;", "}", "METHOD_END"], "methodName": ["getFilename"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   this . modificationDate ;", "}", "METHOD_END"], "methodName": ["getModificationDate"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   this . readDate ;", "}", "METHOD_END"], "methodName": ["getReadDate"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   this . size ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  ( c    >  =     '  0  '  )     &  &     ( c    <  =     '  9  '  )  )     |  |     (  ( c    >  =     ' a '  )     &  &     ( c    <  =     ' z '  )  )  )     |  |     (  ( c    >  =     ' A '  )     &  &     ( c    <  =     ' Z '  )  )  )     |  |     ( c    =  =     '  !  '  )  )     |  |     ( c    =  =     '  #  '  )  )     |  |     ( c    =  =     '  $  '  )  )     |  |     ( c    =  =     '  &  '  )  )     |  |     ( c    =  =     '  +  '  )  )     |  |     ( c    =  =     '  -  '  )  )     |  |     ( c    =  =     '  .  '  )  )     |  |     ( c    =  =     '  ^  '  )  )     |  |     ( c    =  =     '  _  '  )  )     |  |     ( c    =  =     '  `  '  )  )     |  |     ( c    =  =     '  |  '  )  )     |  |     ( c    =  =     '  ~  '  )  ;", "}", "METHOD_END"], "methodName": ["isRFC5987AttrChar"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "List < String >    parts    =    ContentDisposition . tokenize ( contentDisposition )  ;", "String   type    =    parts . get (  0  )  ;", "String   name    =    null ;", "String   filename    =    null ;", "Charset   charset    =    null ;", "Long   size    =    null ;", "ZonedDateTime   creationDate    =    null ;", "ZonedDateTime   modificationDate    =    null ;", "ZonedDateTime   readDate    =    null ;", "for    ( int   i    =     1  ;    i    <     ( parts . size (  )  )  ;    i +  +  )     {", "String   part    =    parts . get ( i )  ;", "int   eqIndex    =    part . indexOf (  '  =  '  )  ;", "if    ( eqIndex    !  =     (  -  1  )  )     {", "String   attribute    =    part . substring (  0  ,    eqIndex )  ;", "String   value    =     (  ( part . startsWith (  \"  \\  \"  \"  ,     ( eqIndex    +     1  )  )  )     &  &     ( part . endsWith (  \"  \\  \"  \"  )  )  )     ?    part . substring (  ( eqIndex    +     2  )  ,     (  ( part . length (  )  )     -     1  )  )     :    part . substring (  ( eqIndex    +     1  )  ,    part . length (  )  )  ;", "if    ( attribute . equals (  \" name \"  )  )     {", "name    =    value ;", "} else", "if    ( attribute . equals (  \" filename *  \"  )  )     {", "filename    =    ContentDisposition . decodeHeaderFieldParam ( value )  ;", "charset    =    Charset . forName ( value . substring (  0  ,    value . indexOf (  '  \\  '  '  )  )  )  ;", "util . Assert . isTrue (  (  ( equals ( charset )  )     |  |     ( equals ( charset )  )  )  ,     \" Charset   should   be   UTF -  8    or   ISO -  8  8  5  9  -  1  \"  )  ;", "} else", "if    (  ( attribute . equals (  \" filename \"  )  )     &  &     ( filename    =  =    null )  )     {", "filename    =    value ;", "} else", "if    ( attribute . equals (  \" size \"  )  )     {", "size    =    Long . parseLong ( value )  ;", "} else", "if    ( attribute . equals (  \" creation - date \"  )  )     {", "try    {", "creationDate    =    ZonedDateTime . parse ( value ,    RFC _  1  1  2  3  _ DATE _ TIME )  ;", "}    catch    ( DateTimeParseException   ex )     {", "}", "} else", "if    ( attribute . equals (  \" modification - date \"  )  )     {", "try    {", "modificationDate    =    ZonedDateTime . parse ( value ,    RFC _  1  1  2  3  _ DATE _ TIME )  ;", "}    catch    ( DateTimeParseException   ex )     {", "}", "} else", "if    ( attribute . equals (  \" read - date \"  )  )     {", "try    {", "readDate    =    ZonedDateTime . parse ( value ,    RFC _  1  1  2  3  _ DATE _ TIME )  ;", "}    catch    ( DateTimeParseException   ex )     {", "}", "}", "} else    {", "throw   new   IllegalArgumentException (  \" Invalid   content   disposition   format \"  )  ;", "}", "}", "return   new   ContentDisposition ( type ,    name ,    filename ,    charset ,    size ,    creationDate ,    modificationDate ,    readDate )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "int   index    =    headerValue . indexOf (  '  ;  '  )  ;", "String   type    =     ( index    >  =     0     ?    headerValue . substring (  0  ,    index )     :    headerValue )  . trim (  )  ;", "if    ( type . isEmpty (  )  )     {", "throw   new   IllegalArgumentException (  \" Content -    header   must   not   be   empty \"  )  ;", "}", "List < String >    parts    =    new   ArrayList <  >  (  )  ;", "parts . add ( type )  ;", "if    ( index    >  =     0  )     {", "do    {", "int   nextIndex    =    index    +     1  ;", "boolean   quoted    =    false ;", "while    ( nextIndex    <     ( headerValue . length (  )  )  )     {", "char   ch    =    headerValue . charAt ( nextIndex )  ;", "if    ( ch    =  =     '  ;  '  )     {", "if    (  ! quoted )     {", "break ;", "}", "} else", "if    ( ch    =  =     '  \"  '  )     {", "quoted    =     ! quoted ;", "}", "nextIndex +  +  ;", "}", "String   part    =    headerValue . substring (  ( index    +     1  )  ,    nextIndex )  . trim (  )  ;", "if    (  !  ( part . isEmpty (  )  )  )     {", "parts . add ( part )  ;", "}", "index    =    nextIndex ;", "}    while    ( index    <     ( headerValue . length (  )  )     )  ;", "}", "return   parts ;", "}", "METHOD_END"], "methodName": ["tokenize"], "fileName": "org.springframework.http.ContentDisposition"}, {"methodBody": ["METHOD_START", "{", "Method   decode    =    ReflectionUtils . findMethod ( ContentDisposition . class ,     \" decodeHeaderFieldParam \"  ,    String . class )  ;", "ReflectionUtils . makeAccessible ( decode )  ;", "String   result    =     (  ( String )     ( ReflectionUtils . invokeMethod ( decode ,    null ,     \" test . txt \"  )  )  )  ;", "assertEquals (  \" test . txt \"  ,    result )  ;", "result    =     (  ( String )     ( ReflectionUtils . invokeMethod ( decode ,    null ,     \" UTF -  8  '  '  % E 4  % B 8  % AD % E 6  %  9  6  %  8  7  . txt \"  )  )  )  ;", "assertEquals (  \"  \u00d6\u00d0  \u00ce\u00c4  . txt \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["decodeHeaderFieldParam"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "Method   decode    =    ReflectionUtils . findMethod ( ContentDisposition . class ,     \" decodeHeaderFieldParam \"  ,    String . class )  ;", "ReflectionUtils . makeAccessible ( decode )  ;", "ReflectionUtils . invokeMethod ( decode ,    null ,     \" UTF -  1  6  '  ' test \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeHeaderFieldParamInvalidCharset"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "Method   encode    =    ReflectionUtils . findMethod ( ContentDisposition . class ,     \" encodeHeaderFieldParam \"  ,    String . class ,    Charset . class )  ;", "ReflectionUtils . makeAccessible ( encode )  ;", "String   result    =     (  ( String )     ( ReflectionUtils . invokeMethod ( encode ,    null ,     \" test . txt \"  ,    StandardCharsets . US _ ASCII )  )  )  ;", "assertEquals (  \" test . txt \"  ,    result )  ;", "result    =     (  ( String )     ( ReflectionUtils . invokeMethod ( encode ,    null ,     \"  \u00d6\u00d0  \u00ce\u00c4  . txt \"  ,    StandardCharsets . UTF _  8  )  )  )  ;", "assertEquals (  \" UTF -  8  '  '  % E 4  % B 8  % AD % E 6  %  9  6  %  8  7  . txt \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["encodeHeaderFieldParam"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "Method   encode    =    ReflectionUtils . findMethod ( ContentDisposition . class ,     \" encodeHeaderFieldParam \"  ,    String . class ,    Charset . class )  ;", "ReflectionUtils . makeAccessible ( encode )  ;", "ReflectionUtils . invokeMethod ( encode ,    null ,     \" test \"  ,    StandardCharsets . UTF _  1  6  )  ;", "}", "METHOD_END"], "methodName": ["encodeHeaderFieldParamInvalidCharset"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . builder (  \" form - data \"  )  . name (  \" foo \"  )  . filename (  \" foo . txt \"  )  . size (  1  2  3 L )  . build (  )  ;", "assertEquals (  \" form - data ;    name =  \\  \" foo \\  \"  ;    filename =  \\  \" foo . txt \\  \"  ;    size =  1  2  3  \"  ,    disposition . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["headerValue"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . builder (  \" form - data \"  )  . name (  \" name \"  )  . filename (  \"  \u00d6\u00d0  \u00ce\u00c4  . txt \"  ,    StandardCharsets . UTF _  8  )  . build (  )  ;", "assertEquals (  \" form - data ;    name =  \\  \" name \\  \"  ;    filename *  = UTF -  8  \\  '  \\  '  % E 4  % B 8  % AD % E 6  %  9  6  %  8  7  . txt \"  ,    disposition . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["headerValueWithEncodedFilename"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . parse (  \" form - data ;    name =  \\  \" foo \\  \"  ;    filename =  \\  \" foo . txt \\  \"  ;    size =  1  2  3  \"  )  ;", "assertEquals ( ContentDisposition . builder (  \" form - data \"  )  . name (  \" foo \"  )  . filename (  \" foo . txt \"  )  . size (  1  2  3 L )  . build (  )  ,    disposition )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . parse (  \" form - data ;    name =  \\  \" foo \\  \"  ;  ;     ;    filename =  \\  \" foo . txt \\  \"  ;    size =  1  2  3  \"  )  ;", "assertEquals ( ContentDisposition . builder (  \" form - data \"  )  . name (  \" foo \"  )  . filename (  \" foo . txt \"  )  . size (  1  2  3 L )  . build (  )  ,    disposition )  ;", "}", "METHOD_END"], "methodName": ["parseAndIgnoreEmptyParts"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . parse (  (  \" attachment ;    creation - date =  \\  \" Mon ,     1  2    Feb    2  0  0  7     1  0  :  1  5  :  3  0     -  0  5  0  0  \\  \"  ;     \"     +     (  \" modification - date =  \\  \" Tue ,     1  3    Feb    2  0  0  7     1  0  :  1  5  :  3  0     -  0  5  0  0  \\  \"  ;     \"     +     \" read - date =  \\  \" Wed ,     1  4    Feb    2  0  0  7     1  0  :  1  5  :  3  0     -  0  5  0  0  \\  \"  \"  )  )  )  ;", "DateTimeFormatter   formatter    =    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME ;", "assertEquals ( ContentDisposition . builder (  \" attachment \"  )  . creationDate ( ZonedDateTime . parse (  \" Mon ,     1  2    Feb    2  0  0  7     1  0  :  1  5  :  3  0     -  0  5  0  0  \"  ,    formatter )  )  . modificationDate ( ZonedDateTime . parse (  \" Tue ,     1  3    Feb    2  0  0  7     1  0  :  1  5  :  3  0     -  0  5  0  0  \"  ,    formatter )  )  . readDate ( ZonedDateTime . parse (  \" Wed ,     1  4    Feb    2  0  0  7     1  0  :  1  5  :  3  0     -  0  5  0  0  \"  ,    formatter )  )  . build (  )  ,    disposition )  ;", "}", "METHOD_END"], "methodName": ["parseDates"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition . parse (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseEmpty"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . parse (  \" form - data ;    name =  \\  \" name \\  \"  ;    filename *  = UTF -  8  \\  '  \\  '  % E 4  % B 8  % AD % E 6  %  9  6  %  8  7  . txt \"  )  ;", "assertEquals ( ContentDisposition . builder (  \" form - data \"  )  . name (  \" name \"  )  . filename (  \"  \u00d6\u00d0  \u00ce\u00c4  . txt \"  ,    StandardCharsets . UTF _  8  )  . build (  )  ,    disposition )  ;", "}", "METHOD_END"], "methodName": ["parseEncodedFilename"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . parse (  \" attachment ;    filename =  \\  \" filename   with    ;    semicolon . txt \\  \"  \"  )  ;", "assertEquals ( ContentDisposition . builder (  \" attachment \"  )  . filename (  \" filename   with    ;    semicolon . txt \"  )  . build (  )  ,    disposition )  ;", "}", "METHOD_END"], "methodName": ["parseFilenameWithSemicolon"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . parse (  (  \" attachment ;    creation - date =  \\  \"  -  1  \\  \"  ;    modification - date =  \\  \"  -  1  \\  \"  ;     \"     +     \" read - date =  \\  \" Wed ,     1  4    Feb    2  0  0  7     1  0  :  1  5  :  3  0     -  0  5  0  0  \\  \"  \"  )  )  ;", "DateTimeFormatter   formatter    =    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME ;", "assertEquals ( ContentDisposition . builder (  \" attachment \"  )  . readDate ( ZonedDateTime . parse (  \" Wed ,     1  4    Feb    2  0  0  7     1  0  :  1  5  :  3  0     -  0  5  0  0  \"  ,    formatter )  )  . build (  )  ,    disposition )  ;", "}", "METHOD_END"], "methodName": ["parseInvalidDates"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition . parse (  \" foo ; bar \"  )  ;", "}", "METHOD_END"], "methodName": ["parseInvalidParameter"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition . parse (  \"  ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseNoType"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . parse (  \" form - data \"  )  ;", "assertEquals ( ContentDisposition . builder (  \" form - data \"  )  . build (  )  ,    disposition )  ;", "}", "METHOD_END"], "methodName": ["parseType"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    ContentDisposition . parse (  \" form - data ;    filename = unquoted \"  )  ;", "assertEquals ( ContentDisposition . builder (  \" form - data \"  )  . filename (  \" unquoted \"  )  . build (  )  ,    disposition )  ;", "}", "METHOD_END"], "methodName": ["parseUnquotedFilename"], "fileName": "org.springframework.http.ContentDispositionTests"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.http.HttpCookie"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.http.HttpCookie"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.springframework.http.HttpEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.http.HttpEntity"}, {"methodBody": ["METHOD_START", "{", "return    ( this . body )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasBody"], "fileName": "org.springframework.http.HttpEntity"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", "String   body    =     \" foo \"  ;", "< String >    entity    =    new    ( body ,    headers )  ;", "assertEquals ( body ,    entity . getBody (  )  )  ;", "assertEquals ( MediaType . TEXT _ PLAIN ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" text / plain \"  ,    entity . getHeaders (  )  . getFirst (  \" Content - Type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaders"], "fileName": "org.springframework.http.HttpEntityTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    map    =    new   LinkedMultiValueMap (  )  ;", "map . set (  \" Content - Type \"  ,     \" text / plain \"  )  ;", "String   body    =     \" foo \"  ;", "HttpEntity < String >    entity    =    new   HttpEntity ( body ,    map )  ;", "assertEquals ( body ,    entity . getBody (  )  )  ;", "assertEquals ( MediaType . TEXT _ PLAIN ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" text / plain \"  ,    entity . getHeaders (  )  . getFirst (  \" Content - Type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["multiValueMap"], "fileName": "org.springframework.http.HttpEntityTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "< String >    entity    =    new    <  >  ( body )  ;", "assertSame ( body ,    entity . getBody (  )  )  ;", "assertTrue ( entity . getHeaders (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["noHeaders"], "fileName": "org.springframework.http.HttpEntityTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", "String   body    =     \" foo \"  ;", "< String >    httpEntity    =    new    ( body ,    headers )  ;", "RequestEntity < String >    requestEntity    =    new   RequestEntity ( body ,    headers ,    HttpMethod . GET ,    new   URI (  \"  /  \"  )  )  ;", "RequestEntity < String >    requestEntity 2     =    new   RequestEntity ( body ,    headers ,    HttpMethod . GET ,    new   URI (  \"  /  \"  )  )  ;", "assertEquals ( body ,    requestEntity . getBody (  )  )  ;", "assertEquals ( MediaType . TEXT _ PLAIN ,    requestEntity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" text / plain \"  ,    requestEntity . getHeaders (  )  . getFirst (  \" Content - Type \"  )  )  ;", "assertEquals (  \" text / plain \"  ,    requestEntity . getHeaders (  )  . getFirst (  \" Content - Type \"  )  )  ;", "assertFalse ( httpEntity . equals ( requestEntity )  )  ;", "assertFalse ( requestEntity . equals ( httpEntity )  )  ;", "assertTrue ( requestEntity . equals ( requestEntity 2  )  )  ;", "assertTrue ( requestEntity 2  . equals ( requestEntity )  )  ;", "}", "METHOD_END"], "methodName": ["requestEntity"], "fileName": "org.springframework.http.HttpEntityTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", "String   body    =     \" foo \"  ;", "< String >    httpEntity    =    new    ( body ,    headers )  ;", "ResponseEntity < String >    responseEntity    =    new   ResponseEntity ( body ,    headers ,    HttpStatus . OK )  ;", "ResponseEntity < String >    responseEntity 2     =    new   ResponseEntity ( body ,    headers ,    HttpStatus . OK )  ;", "assertEquals ( body ,    responseEntity . getBody (  )  )  ;", "assertEquals ( MediaType . TEXT _ PLAIN ,    responseEntity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" text / plain \"  ,    responseEntity . getHeaders (  )  . getFirst (  \" Content - Type \"  )  )  ;", "assertEquals (  \" text / plain \"  ,    responseEntity . getHeaders (  )  . getFirst (  \" Content - Type \"  )  )  ;", "assertFalse ( httpEntity . equals ( responseEntity )  )  ;", "assertFalse ( responseEntity . equals ( httpEntity )  )  ;", "assertTrue ( responseEntity . equals ( responseEntity 2  )  )  ;", "assertTrue ( responseEntity 2  . equals ( responseEntity )  )  ;", "}", "METHOD_END"], "methodName": ["responseEntity"], "fileName": "org.springframework.http.HttpEntityTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    map 1     =    new   LinkedMultiValueMap (  )  ;", "map 1  . set (  \" Content - Type \"  ,     \" text / plain \"  )  ;", "MultiValueMap < String ,    String >    map 2     =    new   LinkedMultiValueMap (  )  ;", "map 2  . set (  \" Content - Type \"  ,     \" application / json \"  )  ;", "assertTrue ( new   HttpEntity <  >  (  )  . equals ( new   HttpEntity < Object >  (  )  )  )  ;", "assertFalse ( new   HttpEntity ( map 1  )  . equals ( new   HttpEntity < Object >  (  )  )  )  ;", "assertFalse ( new   HttpEntity <  >  (  )  . equals ( new   HttpEntity < Object >  ( map 2  )  )  )  ;", "assertTrue ( new   HttpEntity ( map 1  )  . equals ( new   HttpEntity < Object >  ( map 1  )  )  )  ;", "assertFalse ( new   HttpEntity ( map 1  )  . equals ( new   HttpEntity < Object >  ( map 2  )  )  )  ;", "assertTrue ( new   HttpEntity < String >  ( null ,    null )  . equals ( new   HttpEntity < String >  ( null ,    null )  )  )  ;", "assertFalse ( new   HttpEntity <  >  (  \" foo \"  ,    null )  . equals ( new   HttpEntity < String >  ( null ,    null )  )  )  ;", "assertFalse ( new   HttpEntity < String >  ( null ,    null )  . equals ( new   HttpEntity <  >  (  \" bar \"  ,    null )  )  )  ;", "assertTrue ( new   HttpEntity (  \" foo \"  ,    map 1  )  . equals ( new   HttpEntity < String >  (  \" foo \"  ,    map 1  )  )  )  ;", "assertFalse ( new   HttpEntity (  \" foo \"  ,    map 1  )  . equals ( new   HttpEntity < String >  (  \" bar \"  ,    map 1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEquals"], "fileName": "org.springframework.http.HttpEntityTests"}, {"methodBody": ["METHOD_START", "{", "return   MediaType . parseMediaTypes ( get ( HttpHeaders . ACCEPT )  )  ;", "}", "METHOD_END"], "methodName": ["getAccept"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . ACCEPT _ CHARSET )  ;", "if    ( value    !  =    null )     {", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( value ,     \"  ,  \"  )  ;", "List < Charset >    result    =    new   ArrayList <  >  ( tokens . length )  ;", "for    ( String   token    :    tokens )     {", "int   paramIdx    =    token . indexOf (  '  ;  '  )  ;", "String   charsetName ;", "if    ( paramIdx    =  =     (  -  1  )  )     {", "charsetName    =    token ;", "} else    {", "charsetName    =    token . substring (  0  ,    paramIdx )  ;", "}", "if    (  !  ( charsetName . equals (  \"  *  \"  )  )  )     {", "result . add ( Charset . forName ( charsetName )  )  ;", "}", "}", "return   result ;", "} else    {", "return   Collections . emptyList (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAcceptCharset"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . ACCEPT _ LANGUAGE )  ;", "return   StringUtils . hasText ( value )     ?    Locale . LanguageRange . parse ( value )     :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getAcceptLanguage"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "List < Locale . LanguageRange >    ranges    =    getAcceptLanguage (  )  ;", "if    ( ranges . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "}", "return   ranges . stream (  )  . map (  (    range )     -  >    Locale . forLanguageTag ( range . getRange (  )  )  )  . filter (  (    locale )     -  >    StUtils . hasText ( locale . getDisplayName (  )  )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAcceptLanguageAsLocales"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . parseBoolean ( getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "}", "METHOD_END"], "methodName": ["getAccessControlAllowCredentials"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getValuesAsList ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  ;", "}", "METHOD_END"], "methodName": ["getAccessControlAllowHeaders"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "List < HttpMethod >    result    =    new   ArrayList <  >  (  )  ;", "String   value    =    getFirst (  . ACCESS _ CONTROL _ ALLOW _ METHODS )  ;", "if    ( value    !  =    null )     {", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( value ,     \"  ,  \"  )  ;", "for    ( String   token    :    tokens )     {", "HttpMethod   resolved    =    HttpMethod . resolve ( token )  ;", "if    ( resolved    !  =    null )     {", "result . add ( resolved )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAccessControlAllowMethods"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFieldValues ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  ;", "}", "METHOD_END"], "methodName": ["getAccessControlAllowOrigin"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getValuesAsList ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  ;", "}", "METHOD_END"], "methodName": ["getAccessControlExposeHeaders"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . ACCESS _ CONTROL _ MAX _ AGE )  ;", "return   value    !  =    null    ?    Long . parseLong ( value )     :     -  1  ;", "}", "METHOD_END"], "methodName": ["getAccessControlMaxAge"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getValuesAsList ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  ;", "}", "METHOD_END"], "methodName": ["getAccessControlRequestHeaders"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   HttpMethod . resolve ( getFirst ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD )  )  ;", "}", "METHOD_END"], "methodName": ["getAccessControlRequestMethod"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . ALLOW )  ;", "if    (  !  ( StringUtils . isEmpty ( value )  )  )     {", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( value ,     \"  ,  \"  )  ;", "List < HttpMethod >    result    =    new   ArrayList <  >  ( tokens . length )  ;", "for    ( String   token    :    tokens )     {", "HttpMethod   resolved    =    HttpMethod . resolve ( token )  ;", "if    ( resolved    !  =    null )     {", "result . add ( resolved )  ;", "}", "}", "return   EnumSet . copyOf ( result )  ;", "} else    {", "return   EnumSet . noneOf ( HttpMethod . class )  ;", "}", "}", "METHOD_END"], "methodName": ["getAllow"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFieldValues ( HttpHeaders . CACHE _ CONTROL )  ;", "}", "METHOD_END"], "methodName": ["getCacheControl"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getValuesAsList ( HttpHeaders . CONNECTION )  ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   contentDisposition    =    getFirst ( HttpHeaders . CONTENT _ DISPOSITION )  ;", "if    ( contentDisposition    !  =    null )     {", "return   ContentDisposition . parse ( contentDisposition )  ;", "}", "return   ContentDisposition . empty (  )  ;", "}", "METHOD_END"], "methodName": ["getContentDisposition"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getValuesAsList ( HttpHeaders . CONTENT _ LANGUAGE )  . stream (  )  . findFirst (  )  . map ( Locale :  : forLanguageTag )  . orElse ( null )  ;", "}", "METHOD_END"], "methodName": ["getContentLanguage"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . CONTENT _ LENGTH )  ;", "return   value    !  =    null    ?    Long . parseLong ( value )     :     -  1  ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . CONTENT _ TYPE )  ;", "return   StringUtils . hasLength ( value )     ?    MediaType . parseMediaType ( value )     :    null ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirstDate ( HttpHeaders . DATE )  ;", "}", "METHOD_END"], "methodName": ["getDate"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( HttpHeaders . ETAG )  ;", "}", "METHOD_END"], "methodName": ["getETag"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "List < String >    values    =    get ( headerName )  ;", "if    ( values    !  =    null )     {", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "for    ( String   value    :    values )     {", "if    ( value    !  =    null )     {", "Matcher   matcher    =     . ETAG _ HEADER _ VALUE _ PATTERN . matcher ( value )  ;", "while    ( matcher . find (  )  )     {", "if    (  \"  *  \"  . equals ( matcher . group (  )  )  )     {", "result . add ( matcher . group (  )  )  ;", "} else    {", "result . add ( matcher . group (  1  )  )  ;", "}", "}", "if    ( result . isEmpty (  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Could   not   parse   header    '  \"     +    headerName )     +     \"  '    with   value    '  \"  )     +    value )     +     \"  '  \"  )  )  ;", "}", "}", "}", "return   result ;", "}", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getETagValuesAsList"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirstDate ( HttpHeaders . EXPIRES ,    false )  ;", "}", "METHOD_END"], "methodName": ["getExpires"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "List < String >    headerValues    =    get ( headerName )  ;", "return   headerValues    !  =    null    ?    toCommaDelimitedString ( headerValues )     :    null ;", "}", "METHOD_END"], "methodName": ["getFieldValues"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirstDate ( headerName ,    true )  ;", "}", "METHOD_END"], "methodName": ["getFirstDate"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "ZonedDateTime   zonedDateTime    =    getFirstZonedDateTime ( headerName ,    rejectInvalid )  ;", "return   zonedDateTime    !  =    null    ?    zonedDateTime . toInstant (  )  . toEpochMilli (  )     :     -  1  ;", "}", "METHOD_END"], "methodName": ["getFirstDate"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirstZonedDateTime ( headerName ,    true )  ;", "}", "METHOD_END"], "methodName": ["getFirstZonedDateTime"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   headerValue    =    getFirst ( headerName )  ;", "if    ( headerValue    =  =    null )     {", "return   null ;", "}", "if    (  ( headerValue . length (  )  )     >  =     3  )     {", "int   parametersIndex    =    headerValue . indexOf (  '  ;  '  )  ;", "if    ( parametersIndex    !  =     (  -  1  )  )     {", "headerValue    =    headerValue . substring (  0  ,    parametersIndex )  ;", "}", "for    ( DateTimeFormatter   dateFormatter    :     . DATE _ FORMATTERS )     {", "try    {", "return   ZonedDateTime . parse ( headerValue ,    dateFormatter )  ;", "}    catch    ( DateTimeParseException   ex )     {", "}", "}", "}", "if    ( rejectInvalid )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Cannot   parse   date   value    \\  \"  \"     +    headerValue )     +     \"  \\  \"    for    \\  \"  \"  )     +    headerName )     +     \"  \\  \"    header \"  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFirstZonedDateTime"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . HOST )  ;", "if    ( value    =  =    null )     {", "return   null ;", "}", "String   host    =    null ;", "int   port    =     0  ;", "int   separator    =     ( value . startsWith (  \"  [  \"  )  )     ?    value . indexOf (  '  :  '  ,    value . indexOf (  '  ]  '  )  )     :    value . lastIndexOf (  '  :  '  )  ;", "if    ( separator    !  =     (  -  1  )  )     {", "host    =    value . substring (  0  ,    separator )  ;", "String   portString    =    value . substring (  ( separator    +     1  )  )  ;", "try    {", "port    =    Integer . parseInt ( portString )  ;", "}    catch    ( NumberFormatException   ex )     {", "}", "}", "if    ( host    =  =    null )     {", "host    =    value ;", "}", "return   InetSocketAddress . createUnresolved ( host ,    port )  ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getETagValuesAsList ( HttpHeaders . IF _ MATCH )  ;", "}", "METHOD_END"], "methodName": ["getIfMatch"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirstDate ( HttpHeaders . IF _ MODIFIED _ SINCE ,    false )  ;", "}", "METHOD_END"], "methodName": ["getIfModifiedSince"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getETagValuesAsList ( HttpHeaders . IF _ NONE _ MATCH )  ;", "}", "METHOD_END"], "methodName": ["getIfNoneMatch"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirstDate ( HttpHeaders . IF _ UNMODIFIED _ SINCE ,    false )  ;", "}", "METHOD_END"], "methodName": ["getIfUnmodifiedSince"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirstDate ( HttpHeaders . LAST _ MODIFIED ,    false )  ;", "}", "METHOD_END"], "methodName": ["getLastModified"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . LOCATION )  ;", "return   value    !  =    null    ?    URI . create ( value )     :    null ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( HttpHeaders . ORIGIN )  ;", "}", "METHOD_END"], "methodName": ["getOrigin"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( HttpHeaders . PRAGMA )  ;", "}", "METHOD_END"], "methodName": ["getPragma"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( HttpHeaders . RANGE )  ;", "return   HttpRange . parseRanges ( value )  ;", "}", "METHOD_END"], "methodName": ["getRange"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( HttpHeaders . UPGRADE )  ;", "}", "METHOD_END"], "methodName": ["getUpgrade"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "List < String >    values    =    get ( headerName )  ;", "if    ( values    !  =    null )     {", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "for    ( String   value    :    values )     {", "if    ( value    !  =    null )     {", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( value ,     \"  ,  \"  )  ;", "for    ( String   token    :    tokens )     {", "result . add ( token )  ;", "}", "}", "}", "return   result ;", "}", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getValuesAsList"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getValuesAsList ( HttpHeaders . VARY )  ;", "}", "METHOD_END"], "methodName": ["getVary"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   headers . readOnly    ?    headers    :    new   HttpHeaders ( headers ,    true )  ;", "}", "METHOD_END"], "methodName": ["readOnlyHttpHeaders"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCEPT ,    MediaType . toString ( acceptableMediaTypes )  )  ;", "}", "METHOD_END"], "methodName": ["setAccept"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( Iterator < Charset >    iterator    =    acceptableCharsets . iterator (  )  ;    iterator . hasNext (  )  ;  )     {", "Charset   charset    =    iterator . next (  )  ;", "builder . append ( charset . name (  )  . toLowerCase ( Locale . ENGLISH )  )  ;", "if    ( iterator . hasNext (  )  )     {", "builder . append (  \"  ,     \"  )  ;", "}", "}", "set (  . ACCEPT _ CHARSET ,    builder . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["setAcceptCharset"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( languages ,     \"  ' languages '    must   not   be   null \"  )  ;", "DecimalFormat   decimal    =    new   DecimalFormat (  \"  0  .  0  \"  ,     . DECIMAL _ FORMAT _ SYMBOLS )  ;", "List < String >    values    =    languages . stream (  )  . map (  (    range )     -  >     ( range . getWeight (  )  )     =  =     ( Locale . LanguageRange . MAX _ WEIGHT )     ?    range . getRange (  )     :     (  ( range . getRange (  )  )     +     \"  ; q =  \"  )     +     ( decimal . format ( range . getWeight (  )  )  )  )  . collect ( Collectors . toList (  )  )  ;", "set (  . ACCEPT _ LANGUAGE ,    toCommaDelimitedString ( values )  )  ;", "}", "METHOD_END"], "methodName": ["setAcceptLanguage"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "setAcceptLanguage ( locales . stream (  )  . map (  (    locale )     -  >    new   Locale . LanguageRange ( locale . toLanguageTag (  )  )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setAcceptLanguageAsLocales"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS ,    Boolean . toString ( allowCredentials )  )  ;", "}", "METHOD_END"], "methodName": ["setAccessControlAllowCredentials"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS ,    toCommaDelimitedString ( allowedHeaders )  )  ;", "}", "METHOD_END"], "methodName": ["setAccessControlAllowHeaders"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ METHODS ,    StringUtils . collectionToCommaDelimitedString ( allowedMethods )  )  ;", "}", "METHOD_END"], "methodName": ["setAccessControlAllowMethods"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN ,    allowedOrigin )  ;", "}", "METHOD_END"], "methodName": ["setAccessControlAllowOrigin"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS ,    toCommaDelimitedString ( exposedHeaders )  )  ;", "}", "METHOD_END"], "methodName": ["setAccessControlExposeHeaders"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCESS _ CONTROL _ MAX _ AGE ,    Long . toString ( maxAge )  )  ;", "}", "METHOD_END"], "methodName": ["setAccessControlMaxAge"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,    toCommaDelimitedString ( requestHeaders )  )  ;", "}", "METHOD_END"], "methodName": ["setAccessControlRequestHeaders"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     ( requestMethod    !  =    null    ?    requestMethod . name (  )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["setAccessControlRequestMethod"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ALLOW ,    StringUtils . collectionToCommaDelimitedString ( allowedMethods )  )  ;", "}", "METHOD_END"], "methodName": ["setAllow"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . CACHE _ CONTROL ,    cacheControl )  ;", "}", "METHOD_END"], "methodName": ["setCacheControl"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . CACHE _ CONTROL ,    cacheControl . getHeaderValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setCacheControl"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . CONNECTION ,    connection )  ;", "}", "METHOD_END"], "methodName": ["setConnection"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . CONNECTION ,    toCommaDelimitedString ( connection )  )  ;", "}", "METHOD_END"], "methodName": ["setConnection"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . CONTENT _ DISPOSITION ,    contentDisposition . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentDisposition"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \"  ' name '    must   not   be   null \"  )  ;", "ContentDisposition . Builder   disposition    =    ContentDisposition . builder (  \" form - data \"  )  . name ( name )  ;", "if    ( filename    !  =    null )     {", "disposition . filename ( filename )  ;", "}", "setContentDisposition ( disposition . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["setContentDispositionFormData"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . CONTENT _ LANGUAGE ,     ( locale    !  =    null    ?    locale . toLanguageTag (  )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["setContentLanguage"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . CONTENT _ LENGTH ,    Long . toString ( contentLength )  )  ;", "}", "METHOD_END"], "methodName": ["setContentLength"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "if    ( mediaType    !  =    null )     {", "Assert . isTrue (  (  !  ( mediaType . isWildcardType (  )  )  )  ,     \"  ' Content - Type '    cannot   contain   wildcard   type    '  *  '  \"  )  ;", "Assert . isTrue (  (  !  ( mediaType . isWildcardSubtype (  )  )  )  ,     \"  ' Content - Type '    cannot   contain   wildcard   subtype    '  *  '  \"  )  ;", "set (  . CONTENT _ TYPE ,    mediaType . toString (  )  )  ;", "} else    {", "set (  . CONTENT _ TYPE ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "Instant   instant    =    Instant . ofEpochMilli ( date )  ;", "ZonedDateTime   zonedDateTime    =    ZonedDateTime . ofInstant ( instant ,     . GMT )  ;", "set ( headerName ,     . DATE _ FORMATTERS [  0  ]  . format ( zonedDateTime )  )  ;", "}", "METHOD_END"], "methodName": ["setDate"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "setDate ( HttpHeaders . DATE ,    date )  ;", "}", "METHOD_END"], "methodName": ["setDate"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "if    ( etag    !  =    null )     {", "Assert . isTrue (  (  ( etag . startsWith (  \"  \\  \"  \"  )  )     |  |     ( etag . startsWith (  \" W /  \"  )  )  )  ,     \" Invalid   ETag :    does   not   start   with   W /    or    \\  \"  \"  )  ;", "Assert . isTrue ( etag . endsWith (  \"  \\  \"  \"  )  ,     \" Invalid   ETag :    does   not   end   with    \\  \"  \"  )  ;", "}", "set (  . ETAG ,    etag )  ;", "}", "METHOD_END"], "methodName": ["setETag"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "setZonedDateTime ( HttpHeaders . EXPIRES ,    expires )  ;", "}", "METHOD_END"], "methodName": ["setExpires"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "setDate ( HttpHeaders . EXPIRES ,    expires )  ;", "}", "METHOD_END"], "methodName": ["setExpires"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "if    ( host    !  =    null )     {", "String   value    =    host . getHostString (  )  ;", "int   port    =    host . getPort (  )  ;", "if    ( port    !  =     0  )     {", "value    =     ( value    +     \"  :  \"  )     +    port ;", "}", "set (  . HOST ,    value )  ;", "} else    {", "set (  . HOST ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["setHost"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . IF _ MATCH ,    ifMatch )  ;", "}", "METHOD_END"], "methodName": ["setIfMatch"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . IF _ MATCH ,    toCommaDelimitedString ( ifMatchList )  )  ;", "}", "METHOD_END"], "methodName": ["setIfMatch"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "setDate ( HttpHeaders . IF _ MODIFIED _ SINCE ,    ifModifiedSince )  ;", "}", "METHOD_END"], "methodName": ["setIfModifiedSince"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . IF _ NONE _ MATCH ,    ifNoneMatch )  ;", "}", "METHOD_END"], "methodName": ["setIfNoneMatch"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . IF _ NONE _ MATCH ,    toCommaDelimitedString ( ifNoneMatchList )  )  ;", "}", "METHOD_END"], "methodName": ["setIfNoneMatch"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "setDate ( HttpHeaders . IF _ UNMODIFIED _ SINCE ,    ifUnmodifiedSince )  ;", "}", "METHOD_END"], "methodName": ["setIfUnmodifiedSince"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "setDate ( HttpHeaders . LAST _ MODIFIED ,    lastModified )  ;", "}", "METHOD_END"], "methodName": ["setLastModified"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . LOCATION ,     ( location    !  =    null    ?    location . toASCIIString (  )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["setLocation"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . ORIGIN ,    origin )  ;", "}", "METHOD_END"], "methodName": ["setOrigin"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . PRAGMA ,    pragma )  ;", "}", "METHOD_END"], "methodName": ["setPragma"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    HttpRange . toString ( ranges )  ;", "set (  . RANGE ,    value )  ;", "}", "METHOD_END"], "methodName": ["setRange"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . UPGRADE ,    upgrade )  ;", "}", "METHOD_END"], "methodName": ["setUpgrade"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( HttpHeaders . VARY ,    toCommaDelimitedString ( requestHeaders )  )  ;", "}", "METHOD_END"], "methodName": ["setVary"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( headerName ,    HttpHeaders . DATE _ FORMATTERS [  0  ]  . format ( date )  )  ;", "}", "METHOD_END"], "methodName": ["setZonedDateTime"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( Iterator < String >    it    =    hValues . iterator (  )  ;    it . hasNext (  )  ;  )     {", "String   val    =    it . next (  )  ;", "builder . append ( val )  ;", "if    ( it . hasNext (  )  )     {", "builder . append (  \"  ,     \"  )  ;", "}", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toCommaDelimitedString"], "fileName": "org.springframework.http.HttpHeaders"}, {"methodBody": ["METHOD_START", "{", "MediaType   mediaType 1     =    new   MediaType (  \" text \"  ,     \" html \"  )  ;", "MediaType   mediaType 2     =    new   MediaType (  \" text \"  ,     \" plain \"  )  ;", "List < MediaType >    mediaTypes    =    new   ArrayList <  >  (  2  )  ;", "mediaTypes . add ( mediaType 1  )  ;", "mediaTypes . add ( mediaType 2  )  ;", "h . setAccept ( mediaTypes )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    mediaTypes ,    h . getAccept (  )  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,     \" text / html ,    text / plain \"  ,    h . getFirst (  \" Accept \"  )  )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . set (  \" Accept - Charset \"  ,     \" ISO -  8  8  5  9  -  1  , utf -  8  ; q =  0  .  7  ,  *  ; q =  0  .  7  \"  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    Arrays . asList ( StandardCharsets . ISO _  8  8  5  9  _  1  ,    StandardCharsets . UTF _  8  )  ,    headers . getAcceptCharset (  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptCharsetWildcard"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Charset   charset 1     =    StandardCharsets . UTF _  8  ;", "Charset   charset 2     =    StandardCharsets . ISO _  8  8  5  9  _  1  ;", "List < Charset >    charsets    =    new   ArrayList <  >  (  2  )  ;", "charsets . add ( charset 1  )  ;", "charsets . add ( charset 2  )  ;", "h . setAcceptCharset ( charsets )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    charsets ,    h . getAcceptCharset (  )  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,     \" utf -  8  ,    iso -  8  8  5  9  -  1  \"  ,    h . getFirst (  \" Accept - Charset \"  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptCharsets"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "String   headerValue    =     \" fr - ch ,    fr ; q =  0  .  9  ,    en -  *  ; q =  0  .  8  ,    de ; q =  0  .  7  ,     *  ; q =  0  .  5  \"  ;", "headers . setAcceptLanguage ( Locale . LanguageRange . parse ( headerValue )  )  ;", "assertEquals ( headerValue ,    headers . getFirst (  . ACCEPT _ LANGUAGE )  )  ;", "List < Locale . LanguageRange >    expectedRanges    =    Arrays . asList ( new   Locale . LanguageRange (  \" fr - ch \"  )  ,    new   Locale . LanguageRange (  \" fr \"  ,     0  .  9  )  ,    new   Locale . LanguageRange (  \" en -  *  \"  ,     0  .  8  )  ,    new   Locale . LanguageRange (  \" de \"  ,     0  .  7  )  ,    new   Locale . LanguageRange (  \"  *  \"  ,     0  .  5  )  )  ;", "assertEquals ( expectedRanges ,    headers . getAcceptLanguage (  )  )  ;", "assertEquals ( Locale . forLanguageTag (  \" fr - ch \"  )  ,    headers . getAcceptLanguageAsLocales (  )  . get (  0  )  )  ;", "headers . setAcceptLanguageAsLocales ( Collections . singletonList ( Locale . FRANCE )  )  ;", "assertEquals ( Locale . FRANCE ,    headers . getAcceptLanguageAsLocales (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptLanguage"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . set ( HttpHeaders . ACCEPT _ LANGUAGE ,     \"  \"  )  ;", "assertEquals ( Collections . emptyList (  )  ,    this . headers . getAcceptLanguageAsLocales (  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptLanguageWithEmptyValue"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . add (  \" Accept \"  ,     \" text / html , text / pdf \"  )  ;", "headers . add (  \" Accept \"  ,     \" text / plain , text / csv \"  )  ;", "List < MediaType >    expected    =    Arrays . asList ( new   MediaType (  \" text \"  ,     \" html \"  )  ,    new   MediaType (  \" text \"  ,     \" pdf \"  )  ,    new   MediaType (  \" text \"  ,     \" plain \"  )  ,    new   MediaType (  \" text \"  ,     \" csv \"  )  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    expected ,    headers . getAccept (  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptWithMultipleCommaSeparatedHeaderValues"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . add (  \" Accept \"  ,     \" text / html \"  )  ;", "headers . add (  \" Accept \"  ,     \" text / plain \"  )  ;", "List < MediaType >    expected    =    Arrays . asList ( new   MediaType (  \" text \"  ,     \" html \"  )  ,    new   MediaType (  \" text \"  ,     \" plain \"  )  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    expected ,    headers . getAccept (  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptWithMultipleHeaderValues"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( headers . getAccessControlAllowCredentials (  )  )  ;", "headers . setAccessControlAllowCredentials ( false )  ;", "assertFalse ( headers . getAccessControlAllowCredentials (  )  )  ;", "headers . setAccessControlAllowCredentials ( true )  ;", "assertTrue ( headers . getAccessControlAllowCredentials (  )  )  ;", "}", "METHOD_END"], "methodName": ["accessControlAllowCredentials"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    allowedHeaders    =    headers . getAccessControlAllowHeaders (  )  ;", "assertThat ( allowedHeaders ,    Matchers . emptyCollectionOf ( String . class )  )  ;", "headers . setAccessControlAllowHeaders ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  ;", "allowedHeaders    =    headers . getAccessControlAllowHeaders (  )  ;", "assertEquals ( allowedHeaders ,    Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["accessControlAllowHeaders"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    allowedHeaders    =    headers . getAccessControlAllowHeaders (  )  ;", "assertThat ( allowedHeaders ,    Matchers . emptyCollectionOf ( String . class )  )  ;", "headers . add (  . ACCESS _ CONTROL _ ALLOW _ HEADERS ,     \" header 1  ,    header 2  \"  )  ;", "headers . add (  . ACCESS _ CONTROL _ ALLOW _ HEADERS ,     \" header 3  \"  )  ;", "allowedHeaders    =    headers . getAccessControlAllowHeaders (  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  ,     \" header 3  \"  )  ,    allowedHeaders )  ;", "}", "METHOD_END"], "methodName": ["accessControlAllowHeadersMultipleValues"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMethod >    allowedMethods    =    headers . getAccessControlAllowMethods (  )  ;", "assertThat ( allowedMethods ,    Matchers . emptyCollectionOf ( HttpMethod . class )  )  ;", "headers . setAccessControlAllowMethods ( Arrays . asList ( HttpMethod . GET ,    HttpMethod . POST )  )  ;", "allowedMethods    =    headers . getAccessControlAllowMethods (  )  ;", "assertEquals ( allowedMethods ,    Arrays . asList ( HttpMethod . GET ,    HttpMethod . POST )  )  ;", "}", "METHOD_END"], "methodName": ["accessControlAllowMethods"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( headers . getAccessControlAllowOrigin (  )  )  ;", "headers . setAccessControlAllowOrigin (  \"  *  \"  )  ;", "assertEquals (  \"  *  \"  ,    headers . getAccessControlAllowOrigin (  )  )  ;", "}", "METHOD_END"], "methodName": ["accessControlAllowOrigin"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    exposedHeaders    =    headers . getAccessControlExposeHeaders (  )  ;", "assertThat ( exposedHeaders ,    Matchers . emptyCollectionOf ( String . class )  )  ;", "headers . setAccessControlExposeHeaders ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  ;", "exposedHeaders    =    headers . getAccessControlExposeHeaders (  )  ;", "assertEquals ( exposedHeaders ,    Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["accessControlExposeHeaders"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  -  1  )  ,    headers . getAccessControlMaxAge (  )  )  ;", "headers . setAccessControlMaxAge (  3  6  0  0  )  ;", "assertEquals (  3  6  0  0  ,    headers . getAccessControlMaxAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["accessControlMaxAge"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    requestHeaders    =    headers . getAccessControlRequestHeaders (  )  ;", "assertThat ( requestHeaders ,    Matchers . emptyCollectionOf ( String . class )  )  ;", "headers . setAccessControlRequestHeaders ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  ;", "requestHeaders    =    headers . getAccessControlRequestHeaders (  )  ;", "assertEquals ( requestHeaders ,    Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["accessControlRequestHeaders"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( headers . getAccessControlRequestMethod (  )  )  ;", "headers . setAccessControlRequestMethod ( HttpMethod . POST )  ;", "assertEquals ( HttpMethod . POST ,    headers . getAccessControlRequestMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["accessControlRequestMethod"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "EnumSet < HttpMethod >    methods    =    EnumSet . of ( HttpMethod . GET ,    HttpMethod . POST )  ;", "h . setAllow ( methods )  ;", "assertEquals (  \" Invalid   Allow   header \"  ,    methods ,    h . getAllow (  )  )  ;", "assertEquals (  \" Invalid   Allow   header \"  ,     \" GET , POST \"  ,    h . getFirst (  \" Allow \"  )  )  ;", "}", "METHOD_END"], "methodName": ["allow"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . setCacheControl (  \" no - cache \"  )  ;", "assertEquals (  \" Invalid   Cache - Control   header \"  ,     \" no - cache \"  ,    headers . getCacheControl (  )  )  ;", "assertEquals (  \" Invalid   Cache - Control   header \"  ,     \" no - cache \"  ,    headers . getFirst (  \" cache - control \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheControl"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . add ( HttpHeaders . CACHE _ CONTROL ,     \" max - age =  1  0  0  0  ,    public \"  )  ;", "headers . add ( HttpHeaders . CACHE _ CONTROL ,     \" s - maxage =  1  0  0  0  \"  )  ;", "assertThat ( headers . getCacheControl (  )  ,    is (  \" max - age =  1  0  0  0  ,    public ,    s - maxage =  1  0  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheControlAllValues"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . setCacheControl ( CacheControl . noCache (  )  )  ;", "assertEquals (  \" Invalid   Cache - Control   header \"  ,     \" no - cache \"  ,    headers . getCacheControl (  )  )  ;", "assertEquals (  \" Invalid   Cache - Control   header \"  ,     \" no - cache \"  ,    headers . getFirst (  \" cache - control \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheControlBuilder"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "ContentDisposition   disposition    =    headers . getContentDisposition (  )  ;", "assertNotNull ( disposition )  ;", "assertEquals (  \" Invalid   Content - Disposition   header \"  ,    ContentDisposition . empty (  )  ,    headers . getContentDisposition (  )  )  ;", "disposition    =    ContentDisposition . builder (  \" attachment \"  )  . name (  \" foo \"  )  . filename (  \" foo . txt \"  )  . size (  1  2  3 L )  . build (  )  ;", "headers . setContentDisposition ( disposition )  ;", "assertEquals (  \" Invalid   Content - Disposition   header \"  ,    disposition ,    headers . getContentDisposition (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentDisposition"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . setContentLanguage ( Locale . FRANCE )  ;", "assertEquals ( Locale . FRANCE ,    headers . getContentLanguage (  )  )  ;", "assertEquals (  \" fr - FR \"  ,    headers . getFirst (  . CONTENT _ LANGUAGE )  )  ;", "}", "METHOD_END"], "methodName": ["contentLanguage"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . set ( HttpHeaders . CONTENT _ LANGUAGE ,     \" de ,    en _ CA \"  )  ;", "assertEquals (  \" Expected   one    ( first )    locale \"  ,    Locale . GERMAN ,    headers . getContentLanguage (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLanguageSerialized"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "long   length    =     4  2 L ;", "h . setContentLength ( length )  ;", "assertEquals (  \" Invalid   Content - Length   header \"  ,    length ,    h . getContentLength (  )  )  ;", "assertEquals (  \" Invalid   Content - Length   header \"  ,     \"  4  2  \"  ,    h . getFirst (  \" Content - Length \"  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    new   MediaType (  \" text \"  ,     \" html \"  ,    StandardCharsets . UTF _  8  )  ;", "h . setContentType ( contentType )  ;", "assertEquals (  \" Invalid   Content - Type   header \"  ,    contentType ,    h . getContentType (  )  )  ;", "assertEquals (  \" Invalid   Content - Type   header \"  ,     \" text / html ; charset = UTF -  8  \"  ,    h . getFirst (  \" Content - Type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   calendar    =    new   GregorianCalendar (  2  0  0  8  ,     1  1  ,     1  8  ,     1  1  ,     2  0  )  ;", "calendar . setTimeZone ( TimeZone . getTimeZone (  \" CET \"  )  )  ;", "long   date    =    calendar . getTimeInMillis (  )  ;", "h . setDate ( date )  ;", "assertEquals (  \" Invalid   Date   header \"  ,    date ,    h . getDate (  )  )  ;", "assertEquals (  \" Invalid   Date   header \"  ,     \" Thu ,     1  8    Dec    2  0  0  8     1  0  :  2  0  :  0  0    GMT \"  ,    h . getFirst (  \" date \"  )  )  ;", "h . set (  \" Date \"  ,     \" Thu ,     1  8    Dec    2  0  0  8     1  0  :  2  0  :  0  0    GMT \"  )  ;", "assertEquals (  \" Invalid   Date   header \"  ,    date ,    h . getDate (  )  )  ;", "}", "METHOD_END"], "methodName": ["date"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . set (  \" Date \"  ,     \" Foo   Bar   Baz \"  )  ;", "headers . getDate (  )  ;", "}", "METHOD_END"], "methodName": ["dateInvalid"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Locale   defaultLocale    =    Locale . getDefault (  )  ;", "try    {", "Locale . setDefault ( new   Locale (  \" nl \"  ,     \" nl \"  )  )  ;", "Calendar   calendar    =    new   GregorianCalendar (  2  0  0  8  ,     1  1  ,     1  8  ,     1  1  ,     2  0  )  ;", "calendar . setTimeZone ( TimeZone . getTimeZone (  \" CET \"  )  )  ;", "long   date    =    calendar . getTimeInMillis (  )  ;", "h . setDate ( date )  ;", "assertEquals (  \" Invalid   Date   header \"  ,     \" Thu ,     1  8    Dec    2  0  0  8     1  0  :  2  0  :  0  0    GMT \"  ,    h . getFirst (  \" date \"  )  )  ;", "assertEquals (  \" Invalid   Date   header \"  ,    date ,    h . getDate (  )  )  ;", "}    finally    {", "Locale . setDefault ( defaultLocale )  ;", "}", "}", "METHOD_END"], "methodName": ["dateOtherLocale"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" v 2  .  6  \\  \"  \"  ;", "h . setETag ( eTag )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,    eTag ,    h . getETag (  )  )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,     \"  \\  \" v 2  .  6  \\  \"  \"  ,    h . getFirst (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["eTag"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . set (  \" Expires \"  ,     \"  -  1  \"  )  ;", "assertEquals (  (  -  1  )  ,    headers . getExpires (  )  )  ;", "}", "METHOD_END"], "methodName": ["expiresInvalidDate"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . setExpires ( Long . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["expiresLargeDate"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   calendar    =    new   GregorianCalendar (  2  0  0  8  ,     1  1  ,     1  8  ,     1  1  ,     2  0  )  ;", "calendar . setTimeZone ( TimeZone . getTimeZone (  \" CET \"  )  )  ;", "long   date    =    calendar . getTimeInMillis (  )  ;", "h . setExpires ( date )  ;", "assertEquals (  \" Invalid   Expires   header \"  ,    date ,    h . getExpires (  )  )  ;", "assertEquals (  \" Invalid   Expires   header \"  ,     \" Thu ,     1  8    Dec    2  0  0  8     1  0  :  2  0  :  0  0    GMT \"  ,    h . getFirst (  \" expires \"  )  )  ;", "}", "METHOD_END"], "methodName": ["expiresLong"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "ZonedDateTime   zonedDateTime    =    ZonedDateTime . of (  2  0  0  8  ,     1  2  ,     1  8  ,     1  0  ,     2  0  ,     0  ,     0  ,    ZoneId . of (  \" GMT \"  )  )  ;", "h . setExpires ( zonedDateTime )  ;", "assertEquals (  \" Invalid   Expires   header \"  ,    zonedDateTime . toInstant (  )  . toEpochMilli (  )  ,    h . getExpires (  )  )  ;", "assertEquals (  \" Invalid   Expires   header \"  ,     \" Thu ,     1  8    Dec    2  0  0  8     1  0  :  2  0  :  0  0    GMT \"  ,    h . getFirst (  \" expires \"  )  )  ;", "}", "METHOD_END"], "methodName": ["expiresZonedDateTime"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . setDate ( HttpHeaders . DATE ,     1  2  2  9  5  9  5  6  0  0  0  0  0 L )  ;", "assertThat ( headers . getFirstDate ( HttpHeaders . DATE )  ,    is (  1  2  2  9  5  9  5  6  0  0  0  0  0 L )  )  ;", "headers . clear (  )  ;", "headers . add ( HttpHeaders . DATE ,     \" Thu ,     1  8    Dec    2  0  0  8     1  0  :  2  0  :  0  0    GMT \"  )  ;", "headers . add ( HttpHeaders . DATE ,     \" Sat ,     1  8    Dec    2  0  1  0     1  0  :  2  0  :  0  0    GMT \"  )  ;", "assertThat ( headers . getFirstDate ( HttpHeaders . DATE )  ,    is (  1  2  2  9  5  9  5  6  0  0  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["firstDate"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "ZonedDateTime   date    =    ZonedDateTime . of (  2  0  1  7  ,     6  ,     2  2  ,     2  2  ,     2  2  ,     0  ,     0  ,    ZoneId . of (  \" GMT \"  )  )  ;", "headers . setZonedDateTime (  . DATE ,    date )  ;", "assertThat ( headers . getFirst (  . DATE )  ,    is (  \" Thu ,     2  2    Jun    2  0  1  7     2  2  :  2  2  :  0  0    GMT \"  )  )  ;", "assertTrue ( headers . getFirstZonedDateTime (  . DATE )  . isEqual ( date )  )  ;", "headers . clear (  )  ;", "ZonedDateTime   otherDate    =    ZonedDateTime . of (  2  0  1  0  ,     1  2  ,     1  8  ,     1  0  ,     2  0  ,     0  ,     0  ,    ZoneId . of (  \" GMT \"  )  )  ;", "headers . add (  . DATE ,    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME . format ( date )  )  ;", "headers . add (  . DATE ,    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME . format ( otherDate )  )  ;", "assertTrue ( headers . getFirstZonedDateTime (  . DATE )  . isEqual ( date )  )  ;", "headers . clear (  )  ;", "headers . set (  . DATE ,     \" Thursday ,     2  2  - Jun -  1  7     2  2  :  2  2  :  0  0    GMT \"  )  ;", "assertTrue ( headers . getFirstZonedDateTime (  . DATE )  . isEqual ( date )  )  ;", "headers . clear (  )  ;", "headers . set (  . DATE ,     \" Thu   Jun    2  2     2  2  :  2  2  :  0  0     2  0  1  7  \"  )  ;", "assertTrue ( headers . getFirstZonedDateTime (  . DATE )  . isEqual ( date )  )  ;", "}", "METHOD_END"], "methodName": ["firstZonedDateTime"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . setAllow ( Collections .  < HttpMethod > emptySet (  )  )  ;", "assertThat ( headers . getAllow (  )  ,    Matchers . emptyCollectionOf ( HttpMethod . class )  )  ;", "}", "METHOD_END"], "methodName": ["getAllowEmptySet"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . add ( HttpHeaders . CACHE _ CONTROL ,     \" max - age =  1  0  0  0  ,    public \"  )  ;", "headers . add ( HttpHeaders . CACHE _ CONTROL ,     \" s - maxage =  1  0  0  0  \"  )  ;", "assertThat ( headers . getFirst ( HttpHeaders . CACHE _ CONTROL )  ,    is (  \" max - age =  1  0  0  0  ,    public \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "InetSocketAddress   host    =    InetSocketAddress . createUnresolved (  \" localhost \"  ,     8  0  8  0  )  ;", "h . setHost ( host )  ;", "assertEquals (  \" Invalid   Host   header \"  ,    host ,    h . getHost (  )  )  ;", "assertEquals (  \" Invalid   Host   header \"  ,     \" localhost :  8  0  8  0  \"  ,    h . getFirst (  \" Host \"  )  )  ;", "}", "METHOD_END"], "methodName": ["host"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "InetSocketAddress   host    =    InetSocketAddress . createUnresolved (  \" localhost \"  ,     0  )  ;", "h . setHost ( host )  ;", "assertEquals (  \" Invalid   Host   header \"  ,    host ,    h . getHost (  )  )  ;", "assertEquals (  \" Invalid   Host   header \"  ,     \" localhost \"  ,    h . getFirst (  \" Host \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hostNoPort"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "String   ifMatch    =     \"  \\  \" v 2  .  6  \\  \"  \"  ;", "h . setIfMatch ( ifMatch )  ;", "assertEquals (  \" Invalid   If - Match   header \"  ,    ifMatch ,    h . getIfMatch (  )  . get (  0  )  )  ;", "assertEquals (  \" Invalid   If - Match   header \"  ,     \"  \\  \" v 2  .  6  \\  \"  \"  ,    h . getFirst (  \" If - Match \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ifMatch"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . setIfMatch (  \" Illegal \"  )  ;", "headers . getIfMatch (  )  ;", "}", "METHOD_END"], "methodName": ["ifMatchIllegalHeader"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . add ( HttpHeaders . IF _ MATCH ,     \"  \\  \" v 2  ,  0  \\  \"  \"  )  ;", "headers . add ( HttpHeaders . IF _ MATCH ,     \" W /  \\  \" v 2  ,  1  \\  \"  ,     \\  \" v 2  ,  2  \\  \"  \"  )  ;", "assertEquals (  \" Invalid   If - Match   header \"  ,     \"  \\  \" v 2  ,  0  \\  \"  \"  ,    headers . get ( HttpHeaders . IF _ MATCH )  . get (  0  )  )  ;", "assertEquals (  \" Invalid   If - Match   header \"  ,     \" W /  \\  \" v 2  ,  1  \\  \"  ,     \\  \" v 2  ,  2  \\  \"  \"  ,    headers . get ( HttpHeaders . IF _ MATCH )  . get (  1  )  )  ;", "assertThat ( headers . getIfMatch (  )  ,    Matchers . contains (  \"  \\  \" v 2  ,  0  \\  \"  \"  ,     \" W /  \\  \" v 2  ,  1  \\  \"  \"  ,     \"  \\  \" v 2  ,  2  \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ifMatchMultipleHeaders"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   calendar    =    new   GregorianCalendar (  2  0  0  8  ,     1  1  ,     1  8  ,     1  1  ,     2  0  )  ;", "calendar . setTimeZone ( TimeZone . getTimeZone (  \" CET \"  )  )  ;", "long   date    =    calendar . getTimeInMillis (  )  ;", "h . setIfModifiedSince ( date )  ;", "assertEquals (  \" Invalid   If - Modified - Since   header \"  ,    date ,    h . getIfModifiedSince (  )  )  ;", "assertEquals (  \" Invalid   If - Modified - Since   header \"  ,     \" Thu ,     1  8    Dec    2  0  0  8     1  0  :  2  0  :  0  0    GMT \"  ,    h . getFirst (  \" if - modified - since \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ifModifiedSince"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "String   ifNoneMatch    =     \"  \\  \" v 2  .  6  \\  \"  \"  ;", "h . setIfNoneMatch ( ifNoneMatch )  ;", "assertEquals (  \" Invalid   If - None - Match   header \"  ,    ifNoneMatch ,    h . getIfNoneMatch (  )  . get (  0  )  )  ;", "assertEquals (  \" Invalid   If - None - Match   header \"  ,     \"  \\  \" v 2  .  6  \\  \"  \"  ,    h . getFirst (  \" If - None - Match \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ifNoneMatch"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "String   ifNoneMatch 1     =     \"  \\  \" v 2  .  6  \\  \"  \"  ;", "String   ifNoneMatch 2     =     \"  \\  \" v 2  .  7  \\  \"  ,     \\  \" v 2  .  8  \\  \"  \"  ;", "List < String >    ifNoneMatchList    =    new   ArrayList <  >  (  2  )  ;", "ifNoneMatchList . add ( ifNoneMatch 1  )  ;", "ifNoneMatchList . add ( ifNoneMatch 2  )  ;", "h . setIfNoneMatch ( ifNoneMatchList )  ;", "assertThat ( h . getIfNoneMatch (  )  ,    Matchers . contains (  \"  \\  \" v 2  .  6  \\  \"  \"  ,     \"  \\  \" v 2  .  7  \\  \"  \"  ,     \"  \\  \" v 2  .  8  \\  \"  \"  )  )  ;", "assertEquals (  \" Invalid   If - None - Match   header \"  ,     \"  \\  \" v 2  .  6  \\  \"  ,     \\  \" v 2  .  7  \\  \"  ,     \\  \" v 2  .  8  \\  \"  \"  ,    h . getFirst (  \" If - None - Match \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ifNoneMatchList"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "String   ifNoneMatch    =     \"  *  \"  ;", "h . setIfNoneMatch ( ifNoneMatch )  ;", "assertEquals (  \" Invalid   If - None - Match   header \"  ,    ifNoneMatch ,    h . getIfNoneMatch (  )  . get (  0  )  )  ;", "assertEquals (  \" Invalid   If - None - Match   header \"  ,     \"  *  \"  ,    h . getFirst (  \" If - None - Match \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ifNoneMatchWildCard"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \" v 2  .  6  \"  ;", "h . setETag ( eTag )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,    eTag ,    h . getETag (  )  )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,     \"  \\  \" v 2  .  6  \\  \"  \"  ,    h . getFirst (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["illegalETag"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers . set ( HttpHeaders . IF _ MODIFIED _ SINCE ,     \"  0  \"  )  ;", "assertEquals (  (  -  1  )  ,    headers . getIfModifiedSince (  )  )  ;", "headers . set ( HttpHeaders . IF _ MODIFIED _ SINCE ,     \"  -  1  \"  )  ;", "assertEquals (  (  -  1  )  ,    headers . getIfModifiedSince (  )  )  ;", "headers . set ( HttpHeaders . IF _ MODIFIED _ SINCE ,     \" XXX \"  )  ;", "assertEquals (  (  -  1  )  ,    headers . getIfModifiedSince (  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidIfModifiedSinceHeader"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "InetSocketAddress   host    =    InetSocketAddress . createUnresolved (  \"  [  :  :  1  ]  \"  ,     0  )  ;", "h . setHost ( host )  ;", "assertEquals (  \" Invalid   Host   header \"  ,    host ,    h . getHost (  )  )  ;", "assertEquals (  \" Invalid   Host   header \"  ,     \"  [  :  :  1  ]  \"  ,    h . getFirst (  \" Host \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ipv6Host"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   calendar    =    new   GregorianCalendar (  2  0  0  8  ,     1  1  ,     1  8  ,     1  1  ,     2  0  )  ;", "calendar . setTimeZone ( TimeZone . getTimeZone (  \" CET \"  )  )  ;", "long   date    =    calendar . getTimeInMillis (  )  ;", "h . setLastModified ( date )  ;", "assertEquals (  \" Invalid   Last - Modified   header \"  ,    date ,    h . getLastModified (  )  )  ;", "assertEquals (  \" Invalid   Last - Modified   header \"  ,     \" Thu ,     1  8    Dec    2  0  0  8     1  0  :  2  0  :  0  0    GMT \"  ,    h . getFirst (  \" last - modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    new   URI (  \" http :  /  / www . example . com / hotels \"  )  ;", "h . setLocation ( location )  ;", "assertEquals (  \" Invalid   Location   header \"  ,    location ,    h . getLocation (  )  )  ;", "assertEquals (  \" Invalid   Location   header \"  ,     \" http :  /  / www . example . com / hotels \"  ,    h . getFirst (  \" Location \"  )  )  ;", "}", "METHOD_END"], "methodName": ["location"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "String   pragma    =     \" no - cache \"  ;", "h . setPragma ( pragma )  ;", "assertEquals (  \" Invalid   Pragma   header \"  ,    pragma ,    h . getPragma (  )  )  ;", "assertEquals (  \" Invalid   Pragma   header \"  ,     \" no - cache \"  ,    h . getFirst (  \" pragma \"  )  )  ;", "}", "METHOD_END"], "methodName": ["pragma"], "fileName": "org.springframework.http.HttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this )     =  =     ( HttpMethod . resolve ( method )  )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.springframework.http.HttpMethod"}, {"methodBody": ["METHOD_START", "{", "return   method    !  =    null    ?    HttpMethod . mappings . get ( method )     :    null ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.http.HttpMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   HttpRange . ByteRange ( firstBytePos ,    null )  ;", "}", "METHOD_END"], "methodName": ["createByteRange"], "fileName": "org.springframework.http.HttpRange"}, {"methodBody": ["METHOD_START", "{", "return   new   HttpRange . ByteRange ( firstBytePos ,    lastBytePos )  ;", "}", "METHOD_END"], "methodName": ["createByteRange"], "fileName": "org.springframework.http.HttpRange"}, {"methodBody": ["METHOD_START", "{", "return   new   HttpRange . SuffixByteRange ( suffixLength )  ;", "}", "METHOD_END"], "methodName": ["createSuffixRange"], "fileName": "org.springframework.http.HttpRange"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( range ,     \" Range   String   must   not   be   empty \"  )  ;", "int   dashIdx    =    range . indexOf (  '  -  '  )  ;", "if    ( dashIdx    >     0  )     {", "long   firstPos    =    Long . parseLong ( range . substring (  0  ,    dashIdx )  )  ;", "if    ( dashIdx    <     (  ( range . length (  )  )     -     1  )  )     {", "Long   lastPos    =    Long . parseLong ( range . substring (  ( dashIdx    +     1  )  ,    range . length (  )  )  )  ;", "return   new    . ByteRange ( firstPos ,    lastPos )  ;", "} else    {", "return   new    . ByteRange ( firstPos ,    null )  ;", "}", "} else", "if    ( dashIdx    =  =     0  )     {", "long   suffixLength    =    Long . parseLong ( range . substring (  1  )  )  ;", "return   new    . SuffixByteRange ( suffixLength )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Range    '  \"     +    range )     +     \"  \\  '    does   not   contain    \\  \"  -  \\  \"  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseRange"], "fileName": "org.springframework.http.HttpRange"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( ranges )  )  )     {", "return   Collections . emptyList (  )  ;", "}", "if    (  !  ( ranges . startsWith (  . BYTE _ RANGE _ PREFIX )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Range    '  \"     +    ranges )     +     \"  '    does   not   start   with    ' bytes =  '  \"  )  )  ;", "}", "ranges    =    ranges . substring (  . BYTE _ RANGE _ PREFIX . length (  )  )  ;", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( ranges ,     \"  ,  \"  )  ;", "List <  >    result    =    new   ArrayList <  >  ( tokens . length )  ;", "for    ( String   token    :    tokens )     {", "result . add (  . parseRange ( token )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseRanges"], "fileName": "org.springframework.http.HttpRange"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( resource . getClass (  )  )     !  =     ( InputStreamResource . class )  )  ,     \" Cannot   convert   an   InputStreamResource   to   a   ResourceRegion \"  )  ;", "try    {", "long   contentLength    =    resource . contentLength (  )  ;", "Assert . isTrue (  ( contentLength    >     0  )  ,     \" Resource   content   length   should   be    >     0  \"  )  ;", "long   start    =    getRangeStart ( contentLength )  ;", "long   end    =    getRangeEnd ( contentLength )  ;", "return   new   core . io . support . ResourceRegion ( resource ,    start ,     (  ( end    -    start )     +     1  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalArgumentException (  \" Failed   to   convert   Resource   to   ResourceRegion \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["toResourceRegion"], "fileName": "org.springframework.http.HttpRange"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( ranges )  )     {", "return   Collections . emptyList (  )  ;", "}", "List < ResourceRegion >    regions    =    new   ArrayList <  >  ( ranges . size (  )  )  ;", "for    (    range    :    ranges )     {", "regions . add ( range . toResourceRegion ( resource )  )  ;", "}", "return   regions ;", "}", "METHOD_END"], "methodName": ["toResourceRegions"], "fileName": "org.springframework.http.HttpRange"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( ranges ,     \" Ranges   Collection   must   not   be   empty \"  )  ;", "StringBuilder   builder    =    new   StringBuilder (  . BYTE _ RANGE _ PREFIX )  ;", "for    ( Iterator <  >    iterator    =    ranges . iterator (  )  ;    iterator . hasNext (  )  ;  )     {", "range    =    iterator . next (  )  ;", "builder . append ( range )  ;", "if    ( iterator . hasNext (  )  )     {", "builder . append (  \"  ,     \"  )  ;", "}", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.http.HttpRange"}, {"methodBody": ["METHOD_START", "{", "HttpRange   range    =    HttpRange . createByteRange (  0  ,     4  9  9  )  ;", "assertEquals (  0  ,    range . getRangeStart (  1  0  0  0  )  )  ;", "assertEquals (  4  9  9  ,    range . getRangeEnd (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["byteRange"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "HttpRange   range    =    HttpRange . createByteRange (  9  5  0  0  ,     9  5  0  0  )  ;", "assertEquals (  9  5  0  0  ,    range . getRangeStart (  1  0  0  0  0  )  )  ;", "assertEquals (  9  5  0  0  ,    range . getRangeEnd (  1  0  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["byteRangeOfZeroLength"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "HttpRange   range    =    HttpRange . createByteRange (  9  5  0  0  )  ;", "assertEquals (  9  5  0  0  ,    range . getRangeStart (  1  0  0  0  0  )  )  ;", "assertEquals (  9  9  9  9  ,    range . getRangeEnd (  1  0  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["byteRangeWithoutLastPosition"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "HttpRange . createByteRange (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidFirstPosition"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "HttpRange . createByteRange (  1  0  ,     9  )  ;", "}", "METHOD_END"], "methodName": ["invalidLastLessThanFirst"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "HttpRange . createSuffixRange (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidSuffixLength"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpRange >    ranges    =    HttpRange . parseRanges (  \" bytes =  0  -  0  ,  5  0  0  -  ,  -  1  \"  )  ;", "assertEquals (  3  ,    ranges . size (  )  )  ;", "assertEquals (  0  ,    ranges . get (  0  )  . getRangeStart (  1  0  0  0  )  )  ;", "assertEquals (  0  ,    ranges . get (  0  )  . getRangeEnd (  1  0  0  0  )  )  ;", "assertEquals (  5  0  0  ,    ranges . get (  1  )  . getRangeStart (  1  0  0  0  )  )  ;", "assertEquals (  9  9  9  ,    ranges . get (  1  )  . getRangeEnd (  1  0  0  0  )  )  ;", "assertEquals (  9  9  9  ,    ranges . get (  2  )  . getRangeStart (  1  0  0  0  )  )  ;", "assertEquals (  9  9  9  ,    ranges . get (  2  )  . getRangeEnd (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["parseRanges"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpRange >    ranges    =    new   ArrayList <  >  (  )  ;", "ranges . add ( HttpRange . createByteRange (  0  ,     4  9  9  )  )  ;", "ranges . add ( HttpRange . createByteRange (  9  5  0  0  )  )  ;", "ranges . add ( HttpRange . createSuffixRange (  5  0  0  )  )  ;", "assertEquals (  \" Invalid   Range   header \"  ,     \" bytes =  0  -  4  9  9  ,     9  5  0  0  -  ,     -  5  0  0  \"  ,    HttpRange . toString ( ranges )  )  ;", "}", "METHOD_END"], "methodName": ["rangeToString"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "HttpRange   range    =    HttpRange . createSuffixRange (  5  0  0  )  ;", "assertEquals (  5  0  0  ,    range . getRangeStart (  1  0  0  0  )  )  ;", "assertEquals (  9  9  9  ,    range . getRangeEnd (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["suffixRange"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "HttpRange   range    =    HttpRange . createSuffixRange (  5  0  0  )  ;", "assertEquals (  0  ,    range . getRangeStart (  3  5  0  )  )  ;", "assertEquals (  3  4  9  ,    range . getRangeEnd (  3  5  0  )  )  ;", "}", "METHOD_END"], "methodName": ["suffixRangeShorterThanRepresentation"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =     \" Spring   Framework \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "ByteArrayResource   resource    =    new   ByteArrayResource ( bytes )  ;", "range    =     . createByteRange (  0  ,     5  )  ;", "ResourceRegion   region    =    range . toResourceRegion ( resource )  ;", "assertEquals ( resource ,    region . getResource (  )  )  ;", "assertEquals (  0 L ,    region . getPosition (  )  )  ;", "assertEquals (  6 L ,    region . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["toResourceRegion"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "InputStreamResource   resource    =    mock ( InputStreamResource . class )  ;", "given ( resource . contentLength (  )  )  . willThrow ( IOException . class )  ;", "range    =     . createByteRange (  0  ,     9  )  ;", "range . toResourceRegion ( resource )  ;", "}", "METHOD_END"], "methodName": ["toResourceRegionExceptionLength"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "ByteArrayResource   resource    =    mock ( ByteArrayResource . class )  ;", "given ( resource . contentLength (  )  )  . willReturn (  (  -  1 L )  )  ;", "range    =     . createByteRange (  0  ,     9  )  ;", "range . toResourceRegion ( resource )  ;", "}", "METHOD_END"], "methodName": ["toResourceRegionIllegalLength"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "InputStreamResource   resource    =    mock ( InputStreamResource . class )  ;", "range    =     . createByteRange (  0  ,     9  )  ;", "range . toResourceRegion ( resource )  ;", "}", "METHOD_END"], "methodName": ["toResourceRegionInputStreamResource"], "fileName": "org.springframework.http.HttpRangeTests"}, {"methodBody": ["METHOD_START", "{", "return   HttpMethod . resolve ( getMethodValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.http.HttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . reasonPhrase ;", "}", "METHOD_END"], "methodName": ["getReasonPhrase"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "return   HttpStatus . Series . INFORMATIONAL . equals ( series (  )  )  ;", "}", "METHOD_END"], "methodName": ["is1xxInformational"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "return   HttpStatus . Series . SUCCESSFUL . equals ( series (  )  )  ;", "}", "METHOD_END"], "methodName": ["is2xxSuccessful"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "return   HttpStatus . Series . REDIRECTION . equals ( series (  )  )  ;", "}", "METHOD_END"], "methodName": ["is3xxRedirection"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "return   HttpStatus . Series . CLIENT _ ERROR . equals ( series (  )  )  ;", "}", "METHOD_END"], "methodName": ["is4xxClientError"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "return   HttpStatus . Series . SERVER _ ERROR . equals ( series (  )  )  ;", "}", "METHOD_END"], "methodName": ["is5xxServerError"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "return    ( is 4 xxClientError (  )  )     |  |     ( is 5 xxServerError (  )  )  ;", "}", "METHOD_END"], "methodName": ["isError"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "for    ( HttpStatus   status    :    HttpStatus . values (  )  )     {", "if    (  ( status . value )     =  =    statusCode )     {", "return   status ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "return   HttpStatus . Series . valueOf ( this )  ;", "}", "METHOD_END"], "methodName": ["series"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   status    =    HttpStatus . resolve ( statusCode )  ;", "if    ( status    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  \" No   matching   constant   for    [  \"     +    statusCode )     +     \"  ]  \"  )  )  ;", "}", "return   status ;", "}", "METHOD_END"], "methodName": ["valueOf"], "fileName": "org.springframework.http.HttpStatus"}, {"methodBody": ["METHOD_START", "{", "statusCodes . put (  1  0  0  ,     \" CONTINUE \"  )  ;", "statusCodes . put (  1  0  1  ,     \" SWITCHING _ PROTOCOLS \"  )  ;", "statusCodes . put (  1  0  2  ,     \" PROCESSING \"  )  ;", "statusCodes . put (  1  0  3  ,     \" CHECKPOINT \"  )  ;", "statusCodes . put (  2  0  0  ,     \" OK \"  )  ;", "statusCodes . put (  2  0  1  ,     \" CREATED \"  )  ;", "statusCodes . put (  2  0  2  ,     \" ACCEPTED \"  )  ;", "statusCodes . put (  2  0  3  ,     \" NON _ AUTHORITATIVE _ INFORMATION \"  )  ;", "statusCodes . put (  2  0  4  ,     \" NO _ CONTENT \"  )  ;", "statusCodes . put (  2  0  5  ,     \" RESET _ CONTENT \"  )  ;", "statusCodes . put (  2  0  6  ,     \" PARTIAL _ CONTENT \"  )  ;", "statusCodes . put (  2  0  7  ,     \" MULTI _ STATUS \"  )  ;", "statusCodes . put (  2  0  8  ,     \" ALREADY _ REPORTED \"  )  ;", "statusCodes . put (  2  2  6  ,     \" IM _ USED \"  )  ;", "statusCodes . put (  3  0  0  ,     \" MULTIPLE _ CHOICES \"  )  ;", "statusCodes . put (  3  0  1  ,     \" MOVED _ PERMANENTLY \"  )  ;", "statusCodes . put (  3  0  2  ,     \" FOUND \"  )  ;", "statusCodes . put (  3  0  3  ,     \" SEE _ OTHER \"  )  ;", "statusCodes . put (  3  0  4  ,     \" NOT _ MODIFIED \"  )  ;", "statusCodes . put (  3  0  5  ,     \" USE _ PROXY \"  )  ;", "statusCodes . put (  3  0  7  ,     \" TEMPORARY _ REDIRECT \"  )  ;", "statusCodes . put (  3  0  8  ,     \" PERMANENT _ REDIRECT \"  )  ;", "statusCodes . put (  4  0  0  ,     \" BAD _ REQUEST \"  )  ;", "statusCodes . put (  4  0  1  ,     \" UNAUTHORIZED \"  )  ;", "statusCodes . put (  4  0  2  ,     \" PAYMENT _ REQUIRED \"  )  ;", "statusCodes . put (  4  0  3  ,     \" FORBIDDEN \"  )  ;", "statusCodes . put (  4  0  4  ,     \" NOT _ FOUND \"  )  ;", "statusCodes . put (  4  0  5  ,     \" METHOD _ NOT _ ALLOWED \"  )  ;", "statusCodes . put (  4  0  6  ,     \" NOT _ ACCEPTABLE \"  )  ;", "statusCodes . put (  4  0  7  ,     \" PROXY _ AUTHENTICATION _ REQUIRED \"  )  ;", "statusCodes . put (  4  0  8  ,     \" REQUEST _ TIMEOUT \"  )  ;", "statusCodes . put (  4  0  9  ,     \" CONFLICT \"  )  ;", "statusCodes . put (  4  1  0  ,     \" GONE \"  )  ;", "statusCodes . put (  4  1  1  ,     \" LENGTH _ REQUIRED \"  )  ;", "statusCodes . put (  4  1  2  ,     \" PRECONDITION _ FAILED \"  )  ;", "statusCodes . put (  4  1  3  ,     \" PAYLOAD _ TOO _ LARGE \"  )  ;", "statusCodes . put (  4  1  4  ,     \" URI _ TOO _ LONG \"  )  ;", "statusCodes . put (  4  1  5  ,     \" UNSUPPORTED _ MEDIA _ TYPE \"  )  ;", "statusCodes . put (  4  1  6  ,     \" REQUESTED _ RANGE _ NOT _ SATISFIABLE \"  )  ;", "statusCodes . put (  4  1  7  ,     \" EXPECTATION _ FAILED \"  )  ;", "statusCodes . put (  4  1  8  ,     \" I _ AM _ A _ TEAPOT \"  )  ;", "statusCodes . put (  4  1  9  ,     \" INSUFFICIENT _ SPACE _ ON _ RESOURCE \"  )  ;", "statusCodes . put (  4  2  0  ,     \" METHOD _ FAILURE \"  )  ;", "statusCodes . put (  4  2  1  ,     \" DESTINATION _ LOCKED \"  )  ;", "statusCodes . put (  4  2  2  ,     \" UNPROCESSABLE _ ENTITY \"  )  ;", "statusCodes . put (  4  2  3  ,     \" LOCKED \"  )  ;", "statusCodes . put (  4  2  4  ,     \" FAILED _ DEPENDENCY \"  )  ;", "statusCodes . put (  4  2  6  ,     \" UPGRADE _ REQUIRED \"  )  ;", "statusCodes . put (  4  2  8  ,     \" PRECONDITION _ REQUIRED \"  )  ;", "statusCodes . put (  4  2  9  ,     \" TOO _ MANY _ REQUESTS \"  )  ;", "statusCodes . put (  4  3  1  ,     \" REQUEST _ HEADER _ FIELDS _ TOO _ LARGE \"  )  ;", "statusCodes . put (  4  5  1  ,     \" UNAVAILABLE _ FOR _ LEGAL _ REASONS \"  )  ;", "statusCodes . put (  5  0  0  ,     \" INTERNAL _ SERVER _ ERROR \"  )  ;", "statusCodes . put (  5  0  1  ,     \" NOT _ IMPLEMENTED \"  )  ;", "statusCodes . put (  5  0  2  ,     \" BAD _ GATEWAY \"  )  ;", "statusCodes . put (  5  0  3  ,     \" SERVICE _ UNAVAILABLE \"  )  ;", "statusCodes . put (  5  0  4  ,     \" GATEWAY _ TIMEOUT \"  )  ;", "statusCodes . put (  5  0  5  ,     \" HTTP _ VERSION _ NOT _ SUPPORTED \"  )  ;", "statusCodes . put (  5  0  6  ,     \" VARIANT _ ALSO _ NEGOTIATES \"  )  ;", "statusCodes . put (  5  0  7  ,     \" INSUFFICIENT _ STORAGE \"  )  ;", "statusCodes . put (  5  0  8  ,     \" LOOP _ DETECTED \"  )  ;", "statusCodes . put (  5  0  9  ,     \" BANDWIDTH _ LIMIT _ EXCEEDED \"  )  ;", "statusCodes . put (  5  1  0  ,     \" NOT _ EXTENDED \"  )  ;", "statusCodes . put (  5  1  1  ,     \" NETWORK _ AUTHENTICATION _ REQUIRED \"  )  ;", "}", "METHOD_END"], "methodName": ["createStatusCodes"], "fileName": "org.springframework.http.HttpStatusTests"}, {"methodBody": ["METHOD_START", "{", "for    ( HttpStatus   status    :    HttpStatus . values (  )  )     {", "int   value    =    status . value (  )  ;", "if    (  (  ( value    =  =     3  0  2  )     |  |     ( value    =  =     4  1  3  )  )     |  |     ( value    =  =     4  1  4  )  )     {", "continue ;", "}", "assertTrue (  (  (  \" Map   has   no   value   for    [  \"     +    value )     +     \"  ]  \"  )  ,    statusCodes . containsKey ( value )  )  ;", "assertEquals (  (  (  \" Invalid   name   for    [  \"     +    value )     +     \"  ]  \"  )  ,    statusCodes . get ( value )  ,    status . name (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fromEnumToMap"], "fileName": "org.springframework.http.HttpStatusTests"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < Integer ,    String >    entry    :    statusCodes . entrySet (  )  )     {", "int   value    =    entry . getKey (  )  ;", "status    =     . valueOf ( value )  ;", "assertEquals (  \" Invalid   value \"  ,    value ,    status . value (  )  )  ;", "assertEquals (  (  (  \" Invalid   name   for    [  \"     +    value )     +     \"  ]  \"  )  ,    entry . getValue (  )  ,    status . name (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fromMapToEnum"], "fileName": "org.springframework.http.HttpStatusTests"}, {"methodBody": ["METHOD_START", "{", "return   this . mediaType ;", "}", "METHOD_END"], "methodName": ["getMediaType"], "fileName": "org.springframework.http.InvalidMediaTypeException"}, {"methodBody": ["METHOD_START", "{", "if    ( mimeType   instanceof   MediaType )     {", "return    (  ( MediaType )     ( mimeType )  )  ;", "}", "return   new   MediaType ( mimeType . getType (  )  ,    mimeType . getSubtype (  )  ,    mimeType . getParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["asMediaType"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "return   mimeTypes . stream (  )  . map ( MediaType :  : asMediaType )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["asMediaTypes"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( mediaType . getParameters (  )  . containsKey ( MediaType . PARAM _ QUALITY _ FACTOR )  )  )     {", "return   this ;", "}", "Map < String ,    String >    params    =    new   LinkedHashMap ( getParameters (  )  )  ;", "params . put ( MediaType . PARAM _ QUALITY _ FACTOR ,    mediaType . getParameters (  )  . get ( MediaType . PARAM _ QUALITY _ FACTOR )  )  ;", "return   new   MediaType ( this ,    params )  ;", "}", "METHOD_END"], "methodName": ["copyQualityValue"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "String   qualityFactor    =    getParameter ( MediaType . PARAM _ QUALITY _ FACTOR )  ;", "return   qualityFactor    !  =    null    ?    Double . parseDouble ( unquote ( qualityFactor )  )     :     1  .  0  ;", "}", "METHOD_END"], "methodName": ["getQualityValue"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "return   super . includes ( other )  ;", "}", "METHOD_END"], "methodName": ["includes"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "return   super . isCompatibleWith ( other )  ;", "}", "METHOD_END"], "methodName": ["isCompatibleWith"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "MimeType   type ;", "try    {", "type    =    MimeTypeUtils . parseMimeType ( mediaType )  ;", "}    catch    ( InvalidMimeTypeException   ex )     {", "throw   new   InvalidException ( ex )  ;", "}", "try    {", "return   new    ( type . getType (  )  ,    type . getSubtype (  )  ,    type . getParameters (  )  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   InvalidException ( mediaType ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseMediaType"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( mediaTypes )  )  )     {", "return   Collections . emptyList (  )  ;", "}", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( mediaTypes ,     \"  ,  \"  )  ;", "List <  >    result    =    new   ArrayList <  >  ( tokens . length )  ;", "for    ( String   token    :    tokens )     {", "result . add (  . parse ( token )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseMediaTypes"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( mediaTypes )  )     {", "return   Collections . emptyList (  )  ;", "} else", "if    (  ( mediaTypes . size (  )  )     =  =     1  )     {", "return    . parses ( mediaTypes . get (  0  )  )  ;", "} else    {", "List <  >    result    =    new   ArrayList <  >  (  8  )  ;", "for    ( String   mediaType    :    mediaTypes )     {", "result . addAll (  . parses ( mediaType )  )  ;", "}", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["parseMediaTypes"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( getParameters (  )  . containsKey ( MediaType . PARAM _ QUALITY _ FACTOR )  )  )     {", "return   this ;", "}", "Map < String ,    String >    params    =    new   LinkedHashMap ( getParameters (  )  )  ;", "params . remove ( MediaType . PARAM _ QUALITY _ FACTOR )  ;", "return   new   MediaType ( this ,    params )  ;", "}", "METHOD_END"], "methodName": ["removeQualityValue"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mediaTypes ,     \"  ' mediaTypes '    must   not   be   null \"  )  ;", "if    (  ( mediaTypes . size (  )  )     >     1  )     {", "mediaTypes . sort (  . QUALITY _ VALUE _ COMPARATOR )  ;", "}", "}", "METHOD_END"], "methodName": ["sortByQualityValue"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mediaTypes ,     \"  ' mediaTypes '    must   not   be   null \"  )  ;", "if    (  ( mediaTypes . size (  )  )     >     1  )     {", "mediaTypes . sort (  . SPECIFICITY _ COMPARATOR )  ;", "}", "}", "METHOD_END"], "methodName": ["sortBySpecificity"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mediaTypes ,     \"  ' mediaTypes '    must   not   be   null \"  )  ;", "if    (  ( mediaTypes . size (  )  )     >     1  )     {", "mediaTypes . sort (  . SPECIFICITY _ COMPARATOR . thenComparing (  . QUALITY _ VALUE _ COMPARATOR )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sortBySpecificityAndQuality"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "return   MimeTypeUtils . toString ( mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "return   MediaType . parseMediaType ( value )  ;", "}", "METHOD_END"], "methodName": ["valueOf"], "fileName": "org.springframework.http.MediaType"}, {"methodBody": ["METHOD_START", "{", "return   MediaTypeFactory . getMediaTypes ( filename )  . stream (  )  . findFirst (  )  ;", "}", "METHOD_END"], "methodName": ["getMediaType"], "fileName": "org.springframework.http.MediaTypeFactory"}, {"methodBody": ["METHOD_START", "{", "return   Optional . ofNullable ( resource )  . map ( Resource :  : getFilename )  . flatMap ( MediaTypeFactory :  : getMediaType )  ;", "}", "METHOD_END"], "methodName": ["getMediaType"], "fileName": "org.springframework.http.MediaTypeFactory"}, {"methodBody": ["METHOD_START", "{", "return   Optional . ofNullable ( StringUtils . getFilenameExtension ( filename )  )  . map (  (    s )     -  >    s . toLowerCase ( Locale . ENGLISH )  )  . map ( MediaTypeFactory . fileExtensionToMediaTypes :  : get )  . orElse ( Collections . emptyList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMediaTypes"], "fileName": "org.springframework.http.MediaTypeFactory"}, {"methodBody": ["METHOD_START", "{", "try    ( InputStream   is    =    MediaTypeFactory . class . getResourceAsStream ( MediaTypeFactory . MIME _ TYPES _ FILE _ NAME )  )     {", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( is ,    StandardCharsets . US _ ASCII )  )  ;", "MultiValueMap < String ,    MediaType >    result    =    new   util . LinkedMultiValueMap (  )  ;", "String   line ;", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "if    (  ( line . isEmpty (  )  )     |  |     (  ( line . charAt (  0  )  )     =  =     '  #  '  )  )     {", "continue ;", "}", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( line ,     \"     \\ t \\ n \\ r \\ f \"  )  ;", "MediaType   mediaType    =    MediaType . parseMediaType ( tokens [  0  ]  )  ;", "for    ( int   i    =     1  ;    i    <     ( tokens . length )  ;    i +  +  )     {", "String   fileExtension    =    tokens [ i ]  . toLowerCase ( Locale . ENGLISH )  ;", "result . add ( fileExtension ,    mediaType )  ;", "}", "}", "return   result ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   load    '  \"     +     ( MediaTypeFactory . MIME _ TYPES _ FILE _ NAME )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["parseMimeTypes"], "fileName": "org.springframework.http.MediaTypeFactory"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( MediaType . APPLICATION _ XML ,    MediaTypeFactory . getMediaType (  \" file . xml \"  )  . get (  )  )  ;", "assertEquals ( MediaType . parseMediaType (  \" application / javascript \"  )  ,    MediaTypeFactory . getMediaType (  \" file . js \"  )  . get (  )  )  ;", "assertEquals ( MediaType . parseMediaType (  \" text / css \"  )  ,    MediaTypeFactory . getMediaType (  \" file . css \"  )  . get (  )  )  ;", "assertFalse ( MediaTypeFactory . getMediaType (  \" file . foobar \"  )  . isPresent (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMediaType"], "fileName": "org.springframework.http.MediaTypeFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( MediaTypeFactory . getMediaType (  (  ( String )     ( null )  )  )  . isPresent (  )  )  ;", "assertFalse ( MediaTypeFactory . getMediaType (  (  ( Resource )     ( null )  )  )  . isPresent (  )  )  ;", "assertTrue ( MediaTypeFactory . getMediaTypes ( null )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["nullParameter"], "fileName": "org.springframework.http.MediaTypeFactoryTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   audioBasic    =    new   MediaType (  \" audio \"  ,     \" basic \"  )  ;", "MediaType   audio    =    new   MediaType (  \" audio \"  )  ;", "MediaType   audioWave    =    new   MediaType (  \" audio \"  ,     \" wave \"  )  ;", "MediaType   audioBasicLevel    =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" level \"  ,     \"  1  \"  )  )  ;", "MediaType   audioBasic 0  7     =    new   MediaType (  \" audio \"  ,     \" basic \"  ,     0  .  7  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    audioBasic . compareTo ( audioBasic )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    audio . compareTo ( audio )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    audioBasicLevel . compareTo ( audioBasicLevel )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( audioBasicLevel . compareTo ( audio )  )     >     0  )  )  ;", "List < MediaType >    expected    =    new   ArrayList <  >  (  )  ;", "expected . add ( audio )  ;", "expected . add ( audioBasic )  ;", "expected . add ( audioBasicLevel )  ;", "expected . add ( audioBasic 0  7  )  ;", "expected . add ( audioWave )  ;", "List < MediaType >    result    =    new   ArrayList <  >  ( expected )  ;", "Random   rnd    =    new   Random (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "Collections . shuffle ( result ,    rnd )  ;", "Collections . sort ( result )  ;", "for    ( int   j    =     0  ;    j    <     ( result . size (  )  )  ;    j +  +  )     {", "assertSame (  (  (  (  \" Invalid   media   type   at    \"     +    j )     +     \"  ,    run    \"  )     +    i )  ,    expected . get ( j )  ,    result . get ( j )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   m 1     =    new   MediaType (  \" audio \"  ,     \" basic \"  )  ;", "MediaType   m 2     =    new   MediaType (  \" Audio \"  ,     \" Basic \"  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    m 1  . compareTo ( m 2  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    m 2  . compareTo ( m 1  )  )  ;", "m 1     =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  ;", "m 2     =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" Foo \"  ,     \" bar \"  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    m 1  . compareTo ( m 2  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    m 2  . compareTo ( m 1  )  )  ;", "m 1     =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  ;", "m 2     =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" foo \"  ,     \" Bar \"  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( m 1  . compareTo ( m 2  )  )     !  =     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( m 2  . compareTo ( m 1  )  )     !  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToCaseSensitivity"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   m 1     =    MediaType . parseMediaType (  \" text / html ;    q =  0  .  7  ;    charset = iso -  8  8  5  9  -  1  \"  )  ;", "MediaType   m 2     =    MediaType . parseMediaType (  \" text / html ;    charset = iso -  8  8  5  9  -  1  ;    q =  0  .  7  \"  )  ;", "assertEquals (  \" Media   types   not   equal \"  ,    m 1  ,    m 2  )  ;", "assertEquals (  \" compareTo (  )    not   consistent   with   equals \"  ,     0  ,    m 1  . compareTo ( m 2  )  )  ;", "assertEquals (  \" compareTo (  )    not   consistent   with   equals \"  ,     0  ,    m 2  . compareTo ( m 1  )  )  ;", "m 1     =    MediaType . parseMediaType (  \" text / html ;    q =  0  .  7  ;    charset = iso -  8  8  5  9  -  1  \"  )  ;", "m 2     =    MediaType . parseMediaType (  \" text / html ;    Q =  0  .  7  ;    charset = iso -  8  8  5  9  -  1  \"  )  ;", "assertEquals (  \" Media   types   not   equal \"  ,    m 1  ,    m 2  )  ;", "assertEquals (  \" compareTo (  )    not   consistent   with   equals \"  ,     0  ,    m 1  . compareTo ( m 2  )  )  ;", "assertEquals (  \" compareTo (  )    not   consistent   with   equals \"  ,     0  ,    m 2  . compareTo ( m 1  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToConsistentWithEquals"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   mediaType    =    new   MediaType (  \" text \"  ,     \" plain \"  )  ;", "assertEquals (  \" Invalid   quality   value \"  ,     1  ,    mediaType . getQualityValue (  )  ,     0  .  0  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultQualityValue"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" text / plain   not   concrete \"  ,    MediaType . TEXT _ PLAIN . isConcrete (  )  )  ;", "assertFalse (  \"  *  /  *    concrete \"  ,    MediaType . ALL . isConcrete (  )  )  ;", "assertFalse (  \" text /  *    concrete \"  ,    new   MediaType (  \" text \"  ,     \"  *  \"  )  . isConcrete (  )  )  ;", "}", "METHOD_END"], "methodName": ["isConcrete"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" audio /  *  ;    q =  0  .  2  \"  ;", "mediaType    =     . parse ( s )  ;", "assertEquals (  \" Invalid   type \"  ,     \" audio \"  ,    mediaType . getType (  )  )  ;", "assertEquals (  \" Invalid   subtype \"  ,     \"  *  \"  ,    mediaType . getSubtype (  )  )  ;", "assertEquals (  \" Invalid   quality   factor \"  ,     0  .  2  ,    mediaType . getQualityValue (  )  ,     0  .  0  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaType"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio /  *  ;  = value \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeEmptyParameterAttribute"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio /  *  ; attr =  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeEmptyParameterValue"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" text / html ;    charset = foo - bar \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeIllegalCharset"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio /  *  ; attr <  = value \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeIllegalParameterAttribute"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio /  *  ; attr = v > alue \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeIllegalParameterValue"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio / basic ; q =  1  .  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeIllegalQualityFactor"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio / basic )  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeIllegalSubtype"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio (  / basic \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeIllegalType"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeNoSubtype"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \" audio /  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeNoSubtypeSlash"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType . parseMediaType (  \"  *  / json \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypeTypeRange"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" text / plain ;    q =  0  .  5  ,    text / html ,    text / x - dvi ;    q =  0  .  8  ,    text / x - c \"  ;", "List <  >    mediaTypes    =     . parses ( s )  ;", "assertNotNull (  \" No   media   types   returned \"  ,    mediaTypes )  ;", "assertEquals (  \" Invalid   amount   of   media   types \"  ,     4  ,    mediaTypes . size (  )  )  ;", "mediaTypes    =     . parses (  \"  \"  )  ;", "assertNotNull (  \" No   media   types   returned \"  ,    mediaTypes )  ;", "assertEquals (  \" Invalid   amount   of   media   types \"  ,     0  ,    mediaTypes . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMediaTypes"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \"  *  ;    q =  .  2  \"  ;", "mediaType    =     . parse ( s )  ;", "assertEquals (  \" Invalid   type \"  ,     \"  *  \"  ,    mediaType . getType (  )  )  ;", "assertEquals (  \" Invalid   subtype \"  ,     \"  *  \"  ,    mediaType . getSubtype (  )  )  ;", "assertEquals (  \" Invalid   quality   factor \"  ,     0  .  2  ,    mediaType . getQualityValue (  )  ,     0  .  0  )  ;", "}", "METHOD_END"], "methodName": ["parseURLConnectionMediaType"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   audioBasic    =    new   MediaType (  \" audio \"  ,     \" basic \"  )  ;", "MediaType   audioWave    =    new   MediaType (  \" audio \"  ,     \" wave \"  )  ;", "MediaType   audio    =    new   MediaType (  \" audio \"  )  ;", "MediaType   audio 0  3     =    new   MediaType (  \" audio \"  ,     \"  *  \"  ,     0  .  3  )  ;", "MediaType   audio 0  7     =    new   MediaType (  \" audio \"  ,     \"  *  \"  ,     0  .  7  )  ;", "MediaType   audioBasicLevel    =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" level \"  ,     \"  1  \"  )  )  ;", "MediaType   textHtml    =    new   MediaType (  \" text \"  ,     \" html \"  )  ;", "MediaType   allXml    =    new   MediaType (  \" application \"  ,     \"  *  + xml \"  )  ;", "MediaType   all    =    MediaType . ALL ;", "Comparator < MediaType >    comp    =    MediaType . QUALITY _ VALUE _ COMPARATOR ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioBasic ,    audioBasic )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audio ,    audio )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audio 0  7  ,    audio 0  7  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audio 0  3  ,    audio 0  3  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioBasicLevel ,    audioBasicLevel )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audioBasic ,    audio )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audioBasic ,    all )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio ,    all )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( MediaType . APPLICATION _ XHTML _ XML ,    allXml )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio ,    audioBasic )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( all ,    audioBasic )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( all ,    audio )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( allXml ,    MediaType . APPLICATION _ XHTML _ XML )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio ,    audio 0  7  )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio 0  7  ,    audio )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio 0  7  ,    audio 0  3  )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio 0  3  ,    audio 0  7  )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio 0  3  ,    all )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( all ,    audio 0  3  )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audioBasic ,    audioBasicLevel )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audioBasicLevel ,    audioBasic )  )     <     0  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioBasic ,    textHtml )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( textHtml ,    audioBasic )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioBasic ,    audioWave )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioWave ,    audioBasic )  )  ;", "}", "METHOD_END"], "methodName": ["qualityComparator"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "new   MediaType (  \" text \"  ,     \"  /  \"  )  ;", "}", "METHOD_END"], "methodName": ["slashInSubtype"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "new   MediaType (  \" text / plain \"  )  ;", "}", "METHOD_END"], "methodName": ["slashInType"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   audioBasic    =    new   MediaType (  \" audio \"  ,     \" basic \"  )  ;", "MediaType   audio    =    new   MediaType (  \" audio \"  )  ;", "MediaType   audio 0  3     =    new   MediaType (  \" audio \"  ,     \"  *  \"  ,     0  .  3  )  ;", "MediaType   audio 0  7     =    new   MediaType (  \" audio \"  ,     \"  *  \"  ,     0  .  7  )  ;", "MediaType   audioBasicLevel    =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" level \"  ,     \"  1  \"  )  )  ;", "MediaType   all    =    MediaType . ALL ;", "List < MediaType >    expected    =    new   ArrayList <  >  (  )  ;", "expected . add ( audioBasicLevel )  ;", "expected . add ( audioBasic )  ;", "expected . add ( audio )  ;", "expected . add ( all )  ;", "expected . add ( audio 0  7  )  ;", "expected . add ( audio 0  3  )  ;", "List < MediaType >    result    =    new   ArrayList <  >  ( expected )  ;", "Random   rnd    =    new   Random (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "Collections . shuffle ( result ,    rnd )  ;", "MediaType . sortByQualityValue ( result )  ;", "for    ( int   j    =     0  ;    j    <     ( result . size (  )  )  ;    j +  +  )     {", "assertSame (  (  \" Invalid   media   type   at    \"     +    j )  ,    expected . get ( j )  ,    result . get ( j )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["sortByQualityRelated"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   audioBasic    =    new   MediaType (  \" audio \"  ,     \" basic \"  )  ;", "MediaType   audioWave    =    new   MediaType (  \" audio \"  ,     \" wave \"  )  ;", "MediaType   textHtml    =    new   MediaType (  \" text \"  ,     \" html \"  )  ;", "List < MediaType >    expected    =    new   ArrayList <  >  (  )  ;", "expected . add ( textHtml )  ;", "expected . add ( audioBasic )  ;", "expected . add ( audioWave )  ;", "List < MediaType >    result    =    new   ArrayList <  >  ( expected )  ;", "MediaType . sortBySpecificity ( result )  ;", "for    ( int   i    =     0  ;    i    <     ( result . size (  )  )  ;    i +  +  )     {", "assertSame (  (  \" Invalid   media   type   at    \"     +    i )  ,    expected . get ( i )  ,    result . get ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sortByQualityUnrelated"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   audioBasic    =    new   MediaType (  \" audio \"  ,     \" basic \"  )  ;", "MediaType   audio    =    new   MediaType (  \" audio \"  )  ;", "MediaType   audio 0  3     =    new   MediaType (  \" audio \"  ,     \"  *  \"  ,     0  .  3  )  ;", "MediaType   audio 0  7     =    new   MediaType (  \" audio \"  ,     \"  *  \"  ,     0  .  7  )  ;", "MediaType   audioBasicLevel    =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" level \"  ,     \"  1  \"  )  )  ;", "MediaType   all    =    MediaType . ALL ;", "List < MediaType >    expected    =    new   ArrayList <  >  (  )  ;", "expected . add ( audioBasicLevel )  ;", "expected . add ( audioBasic )  ;", "expected . add ( audio )  ;", "expected . add ( audio 0  7  )  ;", "expected . add ( audio 0  3  )  ;", "expected . add ( all )  ;", "List < MediaType >    result    =    new   ArrayList <  >  ( expected )  ;", "Random   rnd    =    new   Random (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "Collections . shuffle ( result ,    rnd )  ;", "MediaType . sortBySpecificity ( result )  ;", "for    ( int   j    =     0  ;    j    <     ( result . size (  )  )  ;    j +  +  )     {", "assertSame (  (  \" Invalid   media   type   at    \"     +    j )  ,    expected . get ( j )  ,    result . get ( j )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["sortBySpecificityRelated"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   audioBasic    =    new   MediaType (  \" audio \"  ,     \" basic \"  )  ;", "MediaType   audioWave    =    new   MediaType (  \" audio \"  ,     \" wave \"  )  ;", "MediaType   textHtml    =    new   MediaType (  \" text \"  ,     \" html \"  )  ;", "List < MediaType >    expected    =    new   ArrayList <  >  (  )  ;", "expected . add ( textHtml )  ;", "expected . add ( audioBasic )  ;", "expected . add ( audioWave )  ;", "List < MediaType >    result    =    new   ArrayList <  >  ( expected )  ;", "MediaType . sortBySpecificity ( result )  ;", "for    ( int   i    =     0  ;    i    <     ( result . size (  )  )  ;    i +  +  )     {", "assertSame (  (  \" Invalid   media   type   at    \"     +    i )  ,    expected . get ( i )  ,    result . get ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sortBySpecificityUnrelated"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   audioBasic    =    new   MediaType (  \" audio \"  ,     \" basic \"  )  ;", "MediaType   audioWave    =    new   MediaType (  \" audio \"  ,     \" wave \"  )  ;", "MediaType   audio    =    new   MediaType (  \" audio \"  )  ;", "MediaType   audio 0  3     =    new   MediaType (  \" audio \"  ,     \"  *  \"  ,     0  .  3  )  ;", "MediaType   audio 0  7     =    new   MediaType (  \" audio \"  ,     \"  *  \"  ,     0  .  7  )  ;", "MediaType   audioBasicLevel    =    new   MediaType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" level \"  ,     \"  1  \"  )  )  ;", "MediaType   textHtml    =    new   MediaType (  \" text \"  ,     \" html \"  )  ;", "MediaType   allXml    =    new   MediaType (  \" application \"  ,     \"  *  + xml \"  )  ;", "MediaType   all    =    MediaType . ALL ;", "Comparator < MediaType >    comp    =    MediaType . SPECIFICITY _ COMPARATOR ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioBasic ,    audioBasic )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audio ,    audio )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audio 0  7  ,    audio 0  7  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audio 0  3  ,    audio 0  3  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioBasicLevel ,    audioBasicLevel )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audioBasic ,    audio )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audioBasic ,    all )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio ,    all )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( MediaType . APPLICATION _ XHTML _ XML ,    allXml )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio ,    audioBasic )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( allXml ,    MediaType . APPLICATION _ XHTML _ XML )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( all ,    audioBasic )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( all ,    audio )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio ,    audio 0  7  )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio 0  7  ,    audio )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio 0  7  ,    audio 0  3  )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio 0  3  ,    audio 0  7  )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audio 0  3  ,    all )  )     <     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( all ,    audio 0  3  )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audioBasic ,    audioBasicLevel )  )     >     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( comp . compare ( audioBasicLevel ,    audioBasic )  )     <     0  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioBasic ,    textHtml )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( textHtml ,    audioBasic )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioBasic ,    audioWave )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    comp . compare ( audioWave ,    audioBasic )  )  ;", "}", "METHOD_END"], "methodName": ["specificityComparator"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   mediaType    =    new   MediaType (  \" text \"  ,     \" plain \"  ,     0  .  7  )  ;", "String   result    =    mediaType . toString (  )  ;", "assertEquals (  \" Invalid   toString (  )    returned \"  ,     \" text / plain ; q =  0  .  7  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testToString"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "ConversionService   conversionService    =    new   DefaultConversionService (  )  ;", "assertTrue ( conversionService . canConvert ( String . class ,     . class )  )  ;", "mediaType    =     . parse (  \" application / xml \"  )  ;", "assertEquals ( mediaType ,    conversionService . convert (  \" application / xml \"  ,     . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWithConversionService"], "fileName": "org.springframework.http.MediaTypeTests"}, {"methodBody": ["METHOD_START", "{", "writeHeaders (  )  ;", "return   body . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsBytes"], "fileName": "org.springframework.http.MockHttpOutputMessage"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    getBodyAsBytes (  )  ;", "return   new   St ( bytes ,    charset )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsString"], "fileName": "org.springframework.http.MockHttpOutputMessage"}, {"methodBody": ["METHOD_START", "{", "return   writtenHeaders ;", "}", "METHOD_END"], "methodName": ["getWrittenHeaders"], "fileName": "org.springframework.http.MockHttpOutputMessage"}, {"methodBody": ["METHOD_START", "{", "if    ( this . headersWritten )     {", "return ;", "}", "this . headersWritten    =    true ;", "this . writtenHeaders . All ( this . headers )  ;", "}", "METHOD_END"], "methodName": ["writeHeaders"], "fileName": "org.springframework.http.MockHttpOutputMessage"}, {"methodBody": ["METHOD_START", "{", "return   RequestEntity . method ( HttpMethod . DELETE ,    url )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   RequestEntity . method ( HttpMethod . GET ,    url )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . type )     =  =    null )     {", "T   body    =    getBody (  )  ;", "if    ( body    !  =    null )     {", "return   body . getClass (  )  ;", "}", "}", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   this . url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   RequestEntity . method ( HttpMethod . HEAD ,    url )  ;", "}", "METHOD_END"], "methodName": ["head"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestEntity . DefaultBodyBuilder ( method ,    url )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   RequestEntity . method ( HttpMethod . OPTIONS ,    url )  ;", "}", "METHOD_END"], "methodName": ["options"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   RequestEntity . method ( HttpMethod . PATCH ,    url )  ;", "}", "METHOD_END"], "methodName": ["patch"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   RequestEntity . method ( HttpMethod . POST ,    url )  ;", "}", "METHOD_END"], "methodName": ["post"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "return   RequestEntity . method ( HttpMethod . PUT ,    url )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.http.RequestEntity"}, {"methodBody": ["METHOD_START", "{", "RequestEntity < Void >    requestEntity    =    RequestEntity . get ( URI . create (  \" http :  /  / example . com \"  )  )  . accept ( MediaType . IMAGE _ GIF ,    MediaType . IMAGE _ JPEG ,    MediaType . IMAGE _ PNG )  . build (  )  ;", "assertNotNull ( requestEntity )  ;", "assertEquals ( HttpMethod . GET ,    requestEntity . getMethod (  )  )  ;", "assertTrue ( requestEntity . getHeaders (  )  . containsKey (  \" Accept \"  )  )  ;", "assertEquals (  \" image / gif ,    image / jpeg ,    image / png \"  ,    requestEntity . getHeaders (  )  . getFirst (  \" Accept \"  )  )  ;", "assertNull ( requestEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.http.RequestEntityTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   accept    =    MediaType . TEXT _ PLAIN ;", "long   ifModifiedSince    =     1  2  3  4  5 L ;", "String   ifNoneMatch    =     \"  \\  \" foo \\  \"  \"  ;", "long   contentLength    =     6  7  8  9  0  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "< Void >    responseEntity    =     . post ( new   URI (  \" http :  /  / example . com \"  )  )  . accept ( accept )  . acceptCharset ( StandardCharsets . UTF _  8  )  . ifModifiedSince ( ifModifiedSince )  . ifNoneMatch ( ifNoneMatch )  . contentLength ( contentLength )  . contentType ( contentType )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpMethod . POST ,    responseEntity . getMethod (  )  )  ;", "assertEquals ( new   URI (  \" http :  /  / example . com \"  )  ,    responseEntity . getUrl (  )  )  ;", "HttpHeaders   responseHeaders    =    responseEntity . getHeaders (  )  ;", "assertEquals (  \" text / plain \"  ,    responseHeaders . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \" utf -  8  \"  ,    responseHeaders . getFirst (  \" Accept - Charset \"  )  )  ;", "assertEquals (  \" Thu ,     1    Jan    1  9  7  0     0  0  :  0  0  :  1  2    GMT \"  ,    responseHeaders . getFirst (  \" If - Modified - Since \"  )  )  ;", "assertEquals ( ifNoneMatch ,    responseHeaders . getFirst (  \" If - None - Match \"  )  )  ;", "assertEquals ( String . valueOf ( contentLength )  ,    responseHeaders . getFirst (  \" Content - Length \"  )  )  ;", "assertEquals ( contentType . toString (  )  ,    responseHeaders . getFirst (  \" Content - Type \"  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.http.RequestEntityTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  \" http :  /  / example . com \"  )  ;", "<  ?  >    entity    =     . get ( url )  . build (  )  ;", "assertEquals ( HttpMethod . GET ,    entity . getMethod (  )  )  ;", "entity    =     . post ( url )  . build (  )  ;", "assertEquals ( HttpMethod . POST ,    entity . getMethod (  )  )  ;", "entity    =     . head ( url )  . build (  )  ;", "assertEquals ( HttpMethod . HEAD ,    entity . getMethod (  )  )  ;", "entity    =     . options ( url )  . build (  )  ;", "assertEquals ( HttpMethod . OPTIONS ,    entity . getMethod (  )  )  ;", "entity    =     . put ( url )  . build (  )  ;", "assertEquals ( HttpMethod . PUT ,    entity . getMethod (  )  )  ;", "entity    =     . patch ( url )  . build (  )  ;", "assertEquals ( HttpMethod . PATCH ,    entity . getMethod (  )  )  ;", "entity    =     . delete ( url )  . build (  )  ;", "assertEquals ( HttpMethod . DELETE ,    entity . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["methods"], "fileName": "org.springframework.http.RequestEntityTests"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =     \" My - Custom - Header \"  ;", "String   headerValue    =     \" HeaderValue \"  ;", "URI   url    =    new   URI (  \" http :  /  / example . com \"  )  ;", "Integer   entity    =     4  2  ;", "< Object >    requestEntity    =     . method ( HttpMethod . GET ,    url )  . header ( headerName ,    headerValue )  . body ( entity )  ;", "assertNotNull ( requestEntity )  ;", "assertEquals ( HttpMethod . GET ,    requestEntity . getMethod (  )  )  ;", "assertTrue ( requestEntity . getHeaders (  )  . containsKey ( headerName )  )  ;", "assertEquals ( headerValue ,    requestEntity . getHeaders (  )  . getFirst ( headerName )  )  ;", "assertEquals ( entity ,    requestEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "org.springframework.http.RequestEntityTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  \" http :  /  / example . com \"  )  ;", "List < String >    body    =    Arrays . asList (  \" foo \"  ,     \" bar \"  )  ;", "ParameterizedTypeReference <  ?  >    typeReference    =    new   ParameterizedTypeReference < List < String >  >  (  )     {  }  ;", "<  ?  >    entity    =     . post ( url )  . body ( body ,    typeReference . getType (  )  )  ;", "assertEquals ( typeReference . getType (  )  ,    entity . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["types"], "fileName": "org.springframework.http.RequestEntityTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   UriTemplate (  \" http :  /  / example . com /  { foo }  \"  )  . expand (  \" bar \"  )  ;", ". get ( uri )  . accept ( MediaType . TEXT _ PLAIN )  . build (  )  ;", "String   url    =     \" http :  /  / www .  { host }  . com /  { path }  \"  ;", "String   host    =     \" example \"  ;", "String   path    =     \" foo / bar \"  ;", "URI   expected    =    new   URI (  \" http :  /  / www . example . com / foo / bar \"  )  ;", "uri    =    new   UriTemplate ( url )  . expand ( host ,    path )  ;", "<  ?  >    entity    =     . get ( uri )  . build (  )  ;", "assertEquals ( expected ,    entity . getUrl (  )  )  ;", "Map < String ,    String >    uriVariables    =    new   HashMap <  >  (  2  )  ;", "uriVariables . put (  \" host \"  ,    host )  ;", "uriVariables . put (  \" path \"  ,    path )  ;", "uri    =    new   UriTemplate ( url )  . expand ( uriVariables )  ;", "entity    =     . get ( uri )  . build (  )  ;", "assertEquals ( expected ,    entity . getUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["uriVariablesExpansion"], "fileName": "org.springframework.http.RequestEntityTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ResponseCookie . ResponseCookieBuilder (  )     {", "private   Duration   maxAge    =    Duration . ofSeconds (  (  -  1  )  )  ;", "@ Nullable", "private   String   domain ;", "@ Nullable", "private   String   path ;", "private   boolean   secure ;", "private   boolean   httpOnly ;", "@ Override", "public   ResponseCookie . ResponseCookieBuilder   maxAge ( Duration   maxAge )     {", "this . maxAge    =    maxAge ;", "return   this ;", "}", "@ Override", "public   ResponseCookie . ResponseCookieBuilder   maxAge ( long   maxAgeSeconds )     {", "this . maxAge    =     ( maxAgeSeconds    >  =     0  )     ?    Duration . ofSeconds ( maxAgeSeconds )     :    Duration . ofSeconds (  (  -  1  )  )  ;", "return   this ;", "}", "@ Override", "public   ResponseCookie . ResponseCookieBuilder   domain ( String   domain )     {", "this . domain    =    domain ;", "return   this ;", "}", "@ Override", "public   ResponseCookie . ResponseCookieBuilder   path ( String   path )     {", "this . path    =    path ;", "return   this ;", "}", "@ Override", "public   ResponseCookie . ResponseCookieBuilder   secure ( boolean   secure )     {", "this . secure    =    secure ;", "return   this ;", "}", "@ Override", "public   ResponseCookie . ResponseCookieBuilder   httpOnly ( boolean   httpOnly )     {", "this . httpOnly    =    httpOnly ;", "return   this ;", "}", "@ Override", "public   ResponseCookie   build (  )     {", "return   new   ResponseCookie ( name ,    value ,    this . maxAge ,    this . domain ,    this . path ,    this . secure ,    this . httpOnly )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.http.ResponseCookie"}, {"methodBody": ["METHOD_START", "{", "return   this . domain ;", "}", "METHOD_END"], "methodName": ["getDomain"], "fileName": "org.springframework.http.ResponseCookie"}, {"methodBody": ["METHOD_START", "{", "return   this . maxAge ;", "}", "METHOD_END"], "methodName": ["getMaxAge"], "fileName": "org.springframework.http.ResponseCookie"}, {"methodBody": ["METHOD_START", "{", "return   this . path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.springframework.http.ResponseCookie"}, {"methodBody": ["METHOD_START", "{", "return   this . httpOnly ;", "}", "METHOD_END"], "methodName": ["isHttpOnly"], "fileName": "org.springframework.http.ResponseCookie"}, {"methodBody": ["METHOD_START", "{", "return   this . secure ;", "}", "METHOD_END"], "methodName": ["isSecure"], "fileName": "org.springframework.http.ResponseCookie"}, {"methodBody": ["METHOD_START", "{", "return   ResponseEntity . status ( HttpStatus . ACCEPTED )  ;", "}", "METHOD_END"], "methodName": ["accepted"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "return   ResponseEntity . status ( HttpStatus . BAD _ REQUEST )  ;", "}", "METHOD_END"], "methodName": ["badRequest"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity . BodyBuilder   builder    =    ResponseEntity . status ( HttpStatus . CREATED )  ;", "return   builder . location ( location )  ;", "}", "METHOD_END"], "methodName": ["created"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . status )    instanceof   HttpStatus )     {", "return    (  ( HttpStatus )     ( this . status )  )  ;", "} else    {", "return   HttpStatus . valueOf (  (  ( Integer )     ( this . status )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getStatusCode"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . status )    instanceof   HttpStatus )     {", "return    (  ( HttpStatus )     ( this . status )  )  . value (  )  ;", "} else    {", "return    (  ( Integer )     ( this . status )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getStatusCodeValue"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "return   ResponseEntity . status ( HttpStatus . NO _ CONTENT )  ;", "}", "METHOD_END"], "methodName": ["noContent"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "return   ResponseEntity . status ( HttpStatus . NOT _ FOUND )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "return   ResponseEntity . status ( HttpStatus . OK )  ;", "}", "METHOD_END"], "methodName": ["ok"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity . BodyBuilder   builder    =    ResponseEntity . ok (  )  ;", "return   builder . body ( body )  ;", "}", "METHOD_END"], "methodName": ["ok"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "return   new   ResponseEntity . DefaultBuilder ( status )  ;", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( status ,     \" HttpStatus   must   not   be   null \"  )  ;", "return   new    . DefaultBuilder ( status )  ;", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "return   ResponseEntity . status ( HttpStatus . UNPROCESSABLE _ ENTITY )  ;", "}", "METHOD_END"], "methodName": ["unprocessableEntity"], "fileName": "org.springframework.http.ResponseEntity"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    responseEntity    =    ResponseEntity . ok (  )  . eTag (  \"  \\  \" foo \\  \"  \"  )  . build (  )  ;", "assertEquals (  \"  \\  \" foo \\  \"  \"  ,    responseEntity . getHeaders (  )  . getETag (  )  )  ;", "responseEntity    =    ResponseEntity . ok (  )  . eTag (  \" foo \"  )  . build (  )  ;", "assertEquals (  \"  \\  \" foo \\  \"  \"  ,    responseEntity . getHeaders (  )  . getETag (  )  )  ;", "responseEntity    =    ResponseEntity . ok (  )  . eTag (  \" W /  \\  \" foo \\  \"  \"  )  . build (  )  ;", "assertEquals (  \" W /  \\  \" foo \\  \"  \"  ,    responseEntity . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["Etagheader"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    responseEntity    =    ResponseEntity . accepted (  )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . ACCEPTED ,    responseEntity . getStatusCode (  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptedNoBody"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    responseEntity    =    ResponseEntity . accepted (  )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . ACCEPTED ,    responseEntity . getStatusCode (  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptedNoBodyWithAlternativeBodyType"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    responseEntity    =    ResponseEntity . badRequest (  )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . BAD _ REQUEST ,    responseEntity . getStatusCode (  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["badRequest"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "Integer   entity    =     4  2  ;", "< Integer >    responseEntity    =     . status ( HttpStatus . OK )  . cacheControl ( CacheControl . maxAge (  1  ,    TimeUnit . HOURS )  . cachePrivate (  )  . mustRevalidate (  )  . proxyRevalidate (  )  . sMaxAge (  3  0  ,    TimeUnit . MINUTES )  )  . body ( entity )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . OK ,    responseEntity . getStatusCode (  )  )  ;", "assertTrue ( responseEntity . getHeaders (  )  . containsKey ( HttpHeaders . CACHE _ CONTROL )  )  ;", "assertEquals ( entity ,    responseEntity . getBody (  )  )  ;", "String   cacheControlHeader    =    responseEntity . getHeaders (  )  . getCacheControl (  )  ;", "assertThat ( cacheControlHeader ,    Matchers . equalTo (  \" max - age =  3  6  0  0  ,    must - revalidate ,    private ,    proxy - revalidate ,    s - maxage =  1  8  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheControl"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "Integer   entity    =     4  2  ;", "< Integer >    responseEntity    =     . status ( HttpStatus . OK )  . cacheControl ( CacheControl . noStore (  )  )  . body ( entity )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . OK ,    responseEntity . getStatusCode (  )  )  ;", "assertTrue ( responseEntity . getHeaders (  )  . containsKey ( HttpHeaders . CACHE _ CONTROL )  )  ;", "assertEquals ( entity ,    responseEntity . getBody (  )  )  ;", "String   cacheControlHeader    =    responseEntity . getHeaders (  )  . getCacheControl (  )  ;", "assertThat ( cacheControlHeader ,    Matchers . equalTo (  \" no - store \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheControlNoCache"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    new   URI (  \" location \"  )  ;", "< Void >    responseEntity    =     . created ( location )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . CREATED ,    responseEntity . getStatusCode (  )  )  ;", "assertTrue ( responseEntity . getHeaders (  )  . containsKey (  \" Location \"  )  )  ;", "assertEquals ( location . toString (  )  ,    responseEntity . getHeaders (  )  . getFirst (  \" Location \"  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", ". created ( location )  . header (  \" MyResponseHeader \"  ,     \" MyValue \"  )  . body (  \" Hello   World \"  )  ;", "}", "METHOD_END"], "methodName": ["createdLocation"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "Integer   entity    =     4  2  ;", "< Integer >    responseEntity    =     . status (  2  9  9  )  . body ( entity )  ;", "assertEquals (  2  9  9  ,    responseEntity . getStatusCodeValue (  )  )  ;", "assertEquals ( entity ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["customStatusCode"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "Integer   entity    =     4  2  ;", "< Integer >    responseEntity    =     . status ( HttpStatus . OK )  . cacheControl ( CacheControl . empty (  )  )  . body ( entity )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . OK ,    responseEntity . getStatusCode (  )  )  ;", "assertFalse ( responseEntity . getHeaders (  )  . containsKey ( HttpHeaders . CACHE _ CONTROL )  )  ;", "assertEquals ( entity ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyCacheControl"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    new   URI (  \" location \"  )  ;", "long   contentLength    =     6  7  8  9  0  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "< Void >    responseEntity    =     . ok (  )  . allow ( HttpMethod . GET )  . lastModified (  1  2  3  4  5 L )  . location ( location )  . contentLength ( contentLength )  . contentType ( contentType )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . OK ,    responseEntity . getStatusCode (  )  )  ;", "HttpHeaders   responseHeaders    =    responseEntity . getHeaders (  )  ;", "assertEquals (  \" GET \"  ,    responseHeaders . getFirst (  \" Allow \"  )  )  ;", "assertEquals (  \" Thu ,     1    Jan    1  9  7  0     0  0  :  0  0  :  1  2    GMT \"  ,    responseHeaders . getFirst (  \" Last - Modified \"  )  )  ;", "assertEquals ( location . toASCIIString (  )  ,    responseHeaders . getFirst (  \" Location \"  )  )  ;", "assertEquals ( String . valueOf ( contentLength )  ,    responseHeaders . getFirst (  \" Content - Length \"  )  )  ;", "assertEquals ( contentType . toString (  )  ,    responseHeaders . getFirst (  \" Content - Type \"  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   customHeaders    =    new   HttpHeaders (  )  ;", "customHeaders . set (  \" X - CustomHeader \"  ,     \" vale \"  )  ;", "< Void >    responseEntity    =     . ok (  )  . headers ( customHeaders )  . build (  )  ;", "HttpHeaders   responseHeaders    =    responseEntity . getHeaders (  )  ;", "assertEquals ( HttpStatus . OK ,    responseEntity . getStatusCode (  )  )  ;", "assertEquals (  1  ,    responseHeaders . size (  )  )  ;", "assertEquals (  1  ,    responseHeaders . get (  \" X - CustomHeader \"  )  . size (  )  )  ;", "assertEquals (  \" vale \"  ,    responseHeaders . getFirst (  \" X - CustomHeader \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headersCopy"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    responseEntityWithEmptyHeaders    =    ResponseEntity . ok (  )  . headers ( new   HttpHeaders (  )  )  . build (  )  ;", "ResponseEntity < Void >    responseEntityWithNullHeaders    =    ResponseEntity . ok (  )  . headers ( null )  . build (  )  ;", "assertEquals ( HttpStatus . OK ,    responseEntityWithEmptyHeaders . getStatusCode (  )  )  ;", "assertTrue ( responseEntityWithEmptyHeaders . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals ( responseEntityWithEmptyHeaders . toString (  )  ,    responseEntityWithNullHeaders . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["headersCopyWithEmptyAndNull"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    responseEntity    =    ResponseEntity . noContent (  )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . NO _ CONTENT ,    responseEntity . getStatusCode (  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["noContent"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =     \" My - Custom - Header \"  ;", "String   headerValue 1     =     \" HeaderValue 1  \"  ;", "String   headerValue 2     =     \" HeaderValue 2  \"  ;", "Integer   entity    =     4  2  ;", "< Integer >    responseEntity    =     . status ( HttpStatus . OK )  . header ( headerName ,    headerValue 1  ,    headerValue 2  )  . body ( entity )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . OK ,    responseEntity . getStatusCode (  )  )  ;", "assertTrue ( responseEntity . getHeaders (  )  . containsKey ( headerName )  )  ;", "List < String >    list    =    responseEntity . getHeaders (  )  . get ( headerName )  ;", "assertEquals (  2  ,    list . size (  )  )  ;", "assertEquals ( headerValue 1  ,    list . get (  0  )  )  ;", "assertEquals ( headerValue 2  ,    list . get (  1  )  )  ;", "assertEquals ( entity ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    responseEntity    =    ResponseEntity . notFound (  )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,    responseEntity . getStatusCode (  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "Integer   entity    =     4  2  ;", "< Integer >    responseEntity    =     . ok ( entity )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . OK ,    responseEntity . getStatusCode (  )  )  ;", "assertEquals ( entity ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["okEntity"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    responseEntity    =    ResponseEntity . ok (  )  . build (  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . OK ,    responseEntity . getStatusCode (  )  )  ;", "assertNull ( responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["okNoBody"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "Integer   entity    =     4  2  ;", "< Integer >    responseEntity    =     . status (  2  0  0  )  . body ( entity )  ;", "assertEquals (  2  0  0  ,    responseEntity . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( entity ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["statusCodeAsInt"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    responseEntity    =    ResponseEntity . unprocessableEntity (  )  . body (  \" error \"  )  ;", "assertNotNull ( responseEntity )  ;", "assertEquals ( HttpStatus . UNPROCESSABLE _ ENTITY ,    responseEntity . getStatusCode (  )  )  ;", "assertEquals (  \" error \"  ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["unprocessableEntity"], "fileName": "org.springframework.http.ResponseEntityTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  !  ( this . executed )  )  ,     \" ClientHttpRequest   already   executed \"  )  ;", "}", "METHOD_END"], "methodName": ["assertNotExecuted"], "fileName": "org.springframework.http.client.AbstractAsyncClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "ClientHttpResponse   response    =    null ;", "try    {", "AsyncClient   request    =    this . factory . createAsyncRequest ( new   URI (  (  (  ( baseUrl )     +     \"  / methods /  \"  )     +    path )  )  ,    method )  ;", "if    (  (  ( method    =  =     ( HttpMethod . POST )  )     |  |     ( method    =  =     ( HttpMethod . PUT )  )  )     |  |     ( method    =  =     ( HttpMethod . PATCH )  )  )     {", "request . getBody (  )  . write (  3  2  )  ;", "}", "Future < ClientHttpResponse >    futureResponse    =    request . executeAsync (  )  ;", "response    =    futureResponse . get (  )  ;", "assertEquals (  \" Invalid   response   status \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  \" Invalid   method \"  ,    path . toUpperCase ( Locale . ENGLISH )  ,    request . getMethod (  )  . name (  )  )  ;", "}    finally    {", "if    ( response    !  =    null )     {", "response . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertHttpMethod"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / status / notfound \"  )  )  ;", "AsyncClient   request    =    this . factory . createAsyncRequest ( uri ,    HttpMethod . GET )  ;", "Future < ClientHttpResponse >    futureResponse    =    request . executeAsync (  )  ;", "futureResponse . cancel ( true )  ;", "assertTrue ( futureResponse . isCancelled (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "this . factory    =    createRequestFactory (  )  ;", "if    (  ( this . factory )    instanceof   InitializingBean )     {", "(  ( InitializingBean )     ( this . factory )  )  . afterPropertiesSet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createFactory"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . factory )    instanceof   DisposableBean )     {", "(  ( DisposableBean )     ( this . factory )  )  . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["destroyFactory"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "AsyncClientHttpRequest   request    =    this . factory . createAsyncRequest ( new   URI (  (  ( baseUrl )     +     \"  / echo \"  )  )  ,    HttpMethod . PUT )  ;", "assertEquals (  \" Invalid   HTTP   method \"  ,    HttpMethod . PUT ,    request . getMethod (  )  )  ;", "String   headerName    =     \" MyHeader \"  ;", "String   headerValue 1     =     \" value 1  \"  ;", "request . getHeaders (  )  . add ( headerName ,    headerValue 1  )  ;", "String   headerValue 2     =     \" value 2  \"  ;", "request . getHeaders (  )  . add ( headerName ,    headerValue 2  )  ;", "final   byte [  ]    body    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "request . getHeaders (  )  . setContentLength ( body . length )  ;", "if    ( request   instanceof   StreamingHttpOutputMessage )     {", "StreamingHttpOutputMessage   streamingRequest    =     (  ( StreamingHttpOutputMessage )     ( request )  )  ;", "streamingRequest . setBody (  (    outputStream )     -  >    StreamUtils . copy ( body ,    outputStream )  )  ;", "} else    {", "StreamUtils . copy ( body ,    request . getBody (  )  )  ;", "}", "Future < ClientHttpResponse >    futureResponse    =    request . executeAsync (  )  ;", "ClientHttpResponse   response    =    futureResponse . get (  )  ;", "try    {", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "assertTrue (  \" Header   not   found \"  ,    response . getHeaders (  )  . containsKey ( headerName )  )  ;", "assertEquals (  \" Header   value   not   found \"  ,    Arrays . asList ( headerValue 1  ,    headerValue 2  )  ,    response . getHeaders (  )  . get ( headerName )  )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( response . getBody (  )  )  ;", "assertTrue (  \" Invalid   body \"  ,    Arrays . equals ( body ,    result )  )  ;", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["echo"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "AsyncClientHttpRequest   request    =    this . factory . createAsyncRequest ( new   URI (  (  ( baseUrl )     +     \"  / echo \"  )  )  ,    HttpMethod . POST )  ;", "request . getHeaders (  )  . add (  \" MyHeader \"  ,     \" value \"  )  ;", "byte [  ]    body    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FileCopyUtils . copy ( body ,    request . getBody (  )  )  ;", "Future < ClientHttpResponse >    futureResponse    =    request . executeAsync (  )  ;", "ClientHttpResponse   response    =    futureResponse . get (  )  ;", "try    {", "request . getHeaders (  )  . add (  \" MyHeader \"  ,     \" value \"  )  ;", "fail (  \" UnsupportedOperationException   expected \"  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["headersAfterExecute"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "assertHttpMethod (  \" get \"  ,    HttpMethod . GET )  ;", "assertHttpMethod (  \" head \"  ,    HttpMethod . HEAD )  ;", "assertHttpMethod (  \" post \"  ,    HttpMethod . POST )  ;", "assertHttpMethod (  \" put \"  ,    HttpMethod . PUT )  ;", "assertHttpMethod (  \" options \"  ,    HttpMethod . OPTIONS )  ;", "assertHttpMethod (  \" delete \"  ,    HttpMethod . DELETE )  ;", "}", "METHOD_END"], "methodName": ["httpMethods"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "AsyncClientHttpRequest   request    =    this . factory . createAsyncRequest ( new   URI (  (  ( baseUrl )     +     \"  / echo \"  )  )  ,    HttpMethod . POST )  ;", "final   byte [  ]    body    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "if    ( request   instanceof   StreamingHttpOutputMessage )     {", "StreamingHttpOutputMessage   streamingRequest    =     (  ( StreamingHttpOutputMessage )     ( request )  )  ;", "streamingRequest . setBody (  (    outputStream )     -  >    StreamUtils . copy ( body ,    outputStream )  )  ;", "} else    {", "StreamUtils . copy ( body ,    request . getBody (  )  )  ;", "}", "Future < ClientHttpResponse >    futureResponse    =    request . executeAsync (  )  ;", "ClientHttpResponse   response    =    futureResponse . get (  )  ;", "try    {", "FileCopyUtils . copy ( body ,    request . getBody (  )  )  ;", "fail (  \" IllegalStateException   expected \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["multipleWrites"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / status / notfound \"  )  )  ;", "AsyncClient   request    =    this . factory . createAsyncRequest ( uri ,    HttpMethod . GET )  ;", "assertEquals (  \" Invalid   HTTP   method \"  ,    HttpMethod . GET ,    request . getMethod (  )  )  ;", "assertEquals (  \" Invalid   HTTP   URI \"  ,    uri ,    request . getURI (  )  )  ;", "Future < ClientHttpResponse >    futureResponse    =    request . executeAsync (  )  ;", "ClientHttpResponse   response    =    futureResponse . get (  )  ;", "try    {", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . NOT _ FOUND ,    response . getStatusCode (  )  )  ;", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / status / notfound \"  )  )  ;", "AsyncClientHttpRequest   request    =    this . factory . createAsyncRequest ( uri ,    HttpMethod . GET )  ;", "assertEquals (  \" Invalid   HTTP   method \"  ,    HttpMethod . GET ,    request . getMethod (  )  )  ;", "assertEquals (  \" Invalid   HTTP   URI \"  ,    uri ,    request . getURI (  )  )  ;", "ListenableFuture < ClientHttpResponse >    listenableFuture    =    request . executeAsync (  )  ;", "listenableFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < ClientHttpResponse >  (  )     {", "@ Override", "public   void   onSuccess ( ClientHttpResponse   result )     {", "try    {", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . NOT _ FOUND ,    result . getStatusCode (  )  )  ;", "}    catch    ( IOException   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "ClientHttpResponse   response    =    listenableFuture . get (  )  ;", "try    {", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . NOT _ FOUND ,    response . getStatusCode (  )  )  ;", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["statusCallback"], "fileName": "org.springframework.http.client.AbstractAsyncHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  !  ( this . executed )  )  ,     \" ClientHttpRequest   already   executed \"  )  ;", "}", "METHOD_END"], "methodName": ["assertNotExecuted"], "fileName": "org.springframework.http.client.AbstractClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "ClientHttpResponse   response    =    null ;", "try    {", "Clien   request    =    factory . createRequest ( new   URI (  (  (  ( baseUrl )     +     \"  / methods /  \"  )     +    path )  )  ,    method )  ;", "if    (  (  ( method    =  =     ( HttpMethod . POST )  )     |  |     ( method    =  =     ( HttpMethod . PUT )  )  )     |  |     ( method    =  =     ( HttpMethod . PATCH )  )  )     {", "try    {", "request . getBody (  )  . write (  3  2  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", "}", "}", "response    =    request . execute (  )  ;", "assertEquals (  \" Invalid   response   status \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  \" Invalid   method \"  ,    path . toUpperCase ( Locale . ENGLISH )  ,    request . getMethod (  )  . name (  )  )  ;", "}    finally    {", "if    ( response    !  =    null )     {", "response . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertHttpMethod"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "factory    =    createRequestFactory (  )  ;", "if    (  ( factory )    instanceof   InitializingBean )     {", "(  ( InitializingBean )     ( factory )  )  . afterPropertiesSet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createFactory"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( factory )    instanceof   DisposableBean )     {", "(  ( DisposableBean )     ( factory )  )  . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["destroyFactory"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "ClientHttpRequest   request    =    factory . createRequest ( new   URI (  (  ( baseUrl )     +     \"  / echo \"  )  )  ,    HttpMethod . PUT )  ;", "assertEquals (  \" Invalid   HTTP   method \"  ,    HttpMethod . PUT ,    request . getMethod (  )  )  ;", "String   headerName    =     \" MyHeader \"  ;", "String   headerValue 1     =     \" value 1  \"  ;", "request . getHeaders (  )  . add ( headerName ,    headerValue 1  )  ;", "String   headerValue 2     =     \" value 2  \"  ;", "request . getHeaders (  )  . add ( headerName ,    headerValue 2  )  ;", "final   byte [  ]    body    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "request . getHeaders (  )  . setContentLength ( body . length )  ;", "if    ( request   instanceof   StreamingHttpOutputMessage )     {", "StreamingHttpOutputMessage   streamingRequest    =     (  ( StreamingHttpOutputMessage )     ( request )  )  ;", "streamingRequest . setBody (  (    outputStream )     -  >    StreamUtils . copy ( body ,    outputStream )  )  ;", "} else    {", "StreamUtils . copy ( body ,    request . getBody (  )  )  ;", "}", "ClientHttpResponse   response    =    request . execute (  )  ;", "try    {", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "assertTrue (  \" Header   not   found \"  ,    response . getHeaders (  )  . containsKey ( headerName )  )  ;", "assertEquals (  \" Header   value   not   found \"  ,    Arrays . asList ( headerValue 1  ,    headerValue 2  )  ,    response . getHeaders (  )  . get ( headerName )  )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( response . getBody (  )  )  ;", "assertTrue (  \" Invalid   body \"  ,    Arrays . equals ( body ,    result )  )  ;", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["echo"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "ClientHttpRequest   request    =    factory . createRequest ( new   URI (  (  ( baseUrl )     +     \"  / echo \"  )  )  ,    HttpMethod . POST )  ;", "request . getHeaders (  )  . add (  \" MyHeader \"  ,     \" value \"  )  ;", "byte [  ]    body    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FileCopyUtils . copy ( body ,    request . getBody (  )  )  ;", "ClientHttpResponse   response    =    request . execute (  )  ;", "try    {", "request . getHeaders (  )  . add (  \" MyHeader \"  ,     \" value \"  )  ;", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["headersAfterExecute"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "assertHttpMethod (  \" get \"  ,    HttpMethod . GET )  ;", "assertHttpMethod (  \" head \"  ,    HttpMethod . HEAD )  ;", "assertHttpMethod (  \" post \"  ,    HttpMethod . POST )  ;", "assertHttpMethod (  \" put \"  ,    HttpMethod . PUT )  ;", "assertHttpMethod (  \" options \"  ,    HttpMethod . OPTIONS )  ;", "assertHttpMethod (  \" delete \"  ,    HttpMethod . DELETE )  ;", "}", "METHOD_END"], "methodName": ["httpMethods"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "ClientHttpRequest   request    =    factory . createRequest ( new   URI (  (  ( baseUrl )     +     \"  / echo \"  )  )  ,    HttpMethod . POST )  ;", "final   byte [  ]    body    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "if    ( request   instanceof   StreamingHttpOutputMessage )     {", "StreamingHttpOutputMessage   streamingRequest    =     (  ( StreamingHttpOutputMessage )     ( request )  )  ;", "streamingRequest . setBody (  (    outputStream )     -  >     {", "StreamUtils . copy ( body ,    outputStream )  ;", "outputStream . flush (  )  ;", "outputStream . close (  )  ;", "}  )  ;", "} else    {", "StreamUtils . copy ( body ,    request . getBody (  )  )  ;", "}", "request . execute (  )  ;", "FileCopyUtils . copy ( body ,    request . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleWrites"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / params ? param 1  = value & param 2  = value 1  & param 2  = value 2  \"  )  )  ;", "Clien   request    =    factory . createRequest ( uri ,    HttpMethod . GET )  ;", "ClientHttpResponse   response    =    request . execute (  )  ;", "try    {", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["queryParameters"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / status / notfound \"  )  )  ;", "Clien   request    =    factory . createRequest ( uri ,    HttpMethod . GET )  ;", "assertEquals (  \" Invalid   HTTP   method \"  ,    HttpMethod . GET ,    request . getMethod (  )  )  ;", "assertEquals (  \" Invalid   HTTP   URI \"  ,    uri ,    request . getURI (  )  )  ;", "ClientHttpResponse   response    =    request . execute (  )  ;", "try    {", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . NOT _ FOUND ,    response . getStatusCode (  )  )  ;", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.http.client.AbstractHttpRequestFactoryTestCase"}, {"methodBody": ["METHOD_START", "{", "this . server    =    new   MockWebServer (  )  ;", "this . server . setDispatcher ( new    . TestDispatcher (  )  )  ;", "this . server . start (  )  ;", "this . port    =    this . server . getPort (  )  ;", "this . baseUrl    =     \" http :  /  / localhost :  \"     +     ( this . port )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . server . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.http.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "HttpURLConnection   connection    =    new   BufferedSimpleHttpRequestFactoryTests . TestHttpURLConnection ( new   URL (  \" http :  /  / example . com \"  )  )  ;", "(  ( SimpleClientHttpRequestFactory )     ( this . factory )  )  . prepareConnection ( connection ,     \" DELETE \"  )  ;", "SimpleBufferingClientHttpRequest   request    =    new   SimpleBufferingClientHttpRequest ( connection ,    false )  ;", "request . execute (  )  ;", "}", "METHOD_END"], "methodName": ["deleteWithoutBodyDoesNotRaiseException"], "fileName": "org.springframework.http.client.BufferedSimpleHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "URL   uri    =    new   URL (  \" http :  /  / example . com \"  )  ;", "testBodyAllowed ( uri ,     \" GET \"  ,    false )  ;", "testBodyAllowed ( uri ,     \" HEAD \"  ,    false )  ;", "testBodyAllowed ( uri ,     \" OPTIONS \"  ,    false )  ;", "testBodyAllowed ( uri ,     \" TRACE \"  ,    false )  ;", "testBodyAllowed ( uri ,     \" PUT \"  ,    true )  ;", "testBodyAllowed ( uri ,     \" POST \"  ,    true )  ;", "testBodyAllowed ( uri ,     \" DELETE \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["prepareConnectionWithRequestBody"], "fileName": "org.springframework.http.client.BufferedSimpleHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "HttpURLConnection   connection    =    new   BufferedSimpleHttpRequestFactoryTests . TestHttpURLConnection ( uri )  ;", "(  ( SimpleClientHttpRequestFactory )     ( this . factory )  )  . prepareConnection ( connection ,    httpMethod )  ;", "assertEquals ( allowed ,    connection . getDoOutput (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRequestBodyAllowed"], "fileName": "org.springframework.http.client.BufferedSimpleHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldBuffer"], "fileName": "org.springframework.http.client.BufferingClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "ClientHttpRequest   request    =    factory . createRequest ( new   URI (  (  ( baseUrl )     +     \"  / echo \"  )  )  ,    HttpMethod . PUT )  ;", "assertEquals (  \" Invalid   HTTP   method \"  ,    HttpMethod . PUT ,    request . getMethod (  )  )  ;", "String   headerName    =     \" MyHeader \"  ;", "String   headerValue 1     =     \" value 1  \"  ;", "request . getHeaders (  )  . add ( headerName ,    headerValue 1  )  ;", "String   headerValue 2     =     \" value 2  \"  ;", "request . getHeaders (  )  . add ( headerName ,    headerValue 2  )  ;", "byte [  ]    body    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "request . getHeaders (  )  . setContentLength ( body . length )  ;", "FileCopyUtils . copy ( body ,    request . getBody (  )  )  ;", "ClientHttpResponse   response    =    request . execute (  )  ;", "try    {", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "assertTrue (  \" Header   not   found \"  ,    response . getHeaders (  )  . containsKey ( headerName )  )  ;", "assertTrue (  \" Header   not   found \"  ,    response . getHeaders (  )  . containsKey ( headerName )  )  ;", "assertEquals (  \" Header   value   not   found \"  ,    Arrays . asList ( headerValue 1  ,    headerValue 2  )  ,    response . getHeaders (  )  . get ( headerName )  )  ;", "assertEquals (  \" Header   value   not   found \"  ,    Arrays . asList ( headerValue 1  ,    headerValue 2  )  ,    response . getHeaders (  )  . get ( headerName )  )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( response . getBody (  )  )  ;", "assertTrue (  \" Invalid   body \"  ,    Arrays . equals ( body ,    result )  )  ;", "FileCopyUtils . copyToByteArray ( response . getBody (  )  )  ;", "assertTrue (  \" Invalid   body \"  ,    Arrays . equals ( body ,    result )  )  ;", "}    finally    {", "response . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["repeatableRead"], "fileName": "org.springframework.http.client.BufferingClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   this . httpContext ;", "}", "METHOD_END"], "methodName": ["getHttpContext"], "fileName": "org.springframework.http.client.HttpComponentsAsyncClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . asyncClient ;", "}", "METHOD_END"], "methodName": ["getAsyncClient"], "fileName": "org.springframework.http.client.HttpComponentsAsyncClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . asyncClient )    instanceof   CloseableHttpAsyncClient )  ,     \" No   CloseableHttpAsyncClient    -    use   getAsyncClient (  )    instead \"  )  ;", "return    (  ( CloseableHttpAsyncClient )     ( this . asyncClient )  )  ;", "}", "METHOD_END"], "methodName": ["getHttpAsyncClient"], "fileName": "org.springframework.http.client.HttpComponentsAsyncClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( asyncClient ,     \" HttpAsyncClient   must   not   be   null \"  )  ;", "this . asyncClient    =    asyncClient ;", "}", "METHOD_END"], "methodName": ["setAsyncClient"], "fileName": "org.springframework.http.client.HttpComponentsAsyncClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . asyncClient    =    asyncClient ;", "}", "METHOD_END"], "methodName": ["setHttpAsyncClient"], "fileName": "org.springframework.http.client.HttpComponentsAsyncClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "HttpAsyncClient   client    =    getAsyncClient (  )  ;", "if    ( client   instanceof   CloseableHttpAsyncClient )     {", "CloseableHttpAsyncClient   closeableAsyncClient    =     (  ( CloseableHttpAsyncClient )     ( client )  )  ;", "if    (  !  ( closeableAsyncClient . isRunning (  )  )  )     {", "closeableAsyncClient . start (  )  ;", "}", "}", "return   client ;", "}", "METHOD_END"], "methodName": ["startAsyncClient"], "fileName": "org.springframework.http.client.HttpComponentsAsyncClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "HttpComponentsAsyncClientHttpRequestFactory   factory    =    new   HttpComponentsAsyncClientHttpRequestFactory (  )  ;", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / status / ok \"  )  )  ;", "HttpComponentsAsyncClientHttpRequest   request    =     (  ( HttpComponentsAsyncClientHttpRequest )     ( factory . createAsyncRequest ( uri ,    HttpMethod . GET )  )  )  ;", "assertNull (  \" No   custom   config   should   be   set   with   a   custom   HttpAsyncClient \"  ,    request . getHttpContext (  )  . getAttribute ( REQUEST _ CONFIG )  )  ;", "}", "METHOD_END"], "methodName": ["customHttpAsyncClientUsesItsDefault"], "fileName": "org.springframework.http.client.HttpComponentsAsyncClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "CloseableHttpAsyncClient   client    =    HttpAsyncClientBuilder . create (  )  . setDefaultRequestConfig ( RequestConfig . custom (  )  . setConnectTimeout (  1  2  3  4  )  . build (  )  )  . build (  )  ;", "factory    =    new    ( client )  ;", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / status / ok \"  )  )  ;", "HttpComponentsAsyncClientHttpRequest   request    =     (  ( HttpComponentsAsyncClientHttpRequest )     ( factory . createAsyncRequest ( uri ,    HttpMethod . GET )  )  )  ;", "assertNull (  \" No   custom   config   should   be   set   with   a   custom   HttpClient \"  ,    request . getHttpContext (  )  . getAttribute ( REQUEST _ CONFIG )  )  ;", "factory . setConnectionRequestTimeout (  4  5  6  7  )  ;", "HttpComponentsAsyncClientHttpRequest   request 2     =     (  ( HttpComponentsAsyncClientHttpRequest )     ( factory . createAsyncRequest ( uri ,    HttpMethod . GET )  )  )  ;", "Object   requestConfigAttribute    =    request 2  . getHttpContext (  )  . getAttribute ( REQUEST _ CONFIG )  ;", "assertNotNull ( requestConfigAttribute )  ;", "RequestConfig   requestConfig    =     (  ( RequestConfig )     ( requestConfigAttribute )  )  ;", "assertEquals (  4  5  6  7  ,    requestConfig . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  (  -  1  )  ,    requestConfig . getConnectTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultSettingsOfHttpAsyncClientLostOnExecutorCustomization"], "fileName": "org.springframework.http.client.HttpComponentsAsyncClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "headers . forEach (  (    headerName ,    headerValues )     -  >     {", "if    ( HttpHeaders . COOKIE . equalsIgnoreCase ( headerName )  )     {", "String   headerValue    =    StringUtils . collectionToDelimitedString ( headerValues ,     \"  ;     \"  )  ;", "h . addHeader ( headerName ,    headerValue )  ;", "} else", "if    (  (  !  ( HTTP . CONTENT _ LEN . equalsIgnoreCase ( headerName )  )  )     &  &     (  !  ( HTTP . TRANSFER _ ENCODING . equalsIgnoreCase ( headerName )  )  )  )     {", "for    ( String   headerValue    :    headerValues )     {", "h . addHeader ( headerName ,    headerValue )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addHeaders"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . httpContext ;", "}", "METHOD_END"], "methodName": ["getHttpContext"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["createHttpContext"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "switch    ( httpMethod )     {", "case   GET    :", "return   new   HttpGet ( uri )  ;", "case   HEAD    :", "return   new   HttpHead ( uri )  ;", "case   POST    :", "return   new   HttpPost ( uri )  ;", "case   PUT    :", "return   new   HttpPut ( uri )  ;", "case   PATCH    :", "return   new   HttpPatch ( uri )  ;", "case   DELETE    :", "return   new    . HttpDelete ( uri )  ;", "case   OPTIONS    :", "return   new   HttpOptions ( uri )  ;", "case   TRACE    :", "return   new   HttpTrace ( uri )  ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Invalid   HTTP   method :     \"     +    httpMethod )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createHttpUriRequest"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( client   instanceof   Configurable )     {", "Config   clientConfig    =     (  ( Configurable )     ( client )  )  . getConfig (  )  ;", "return   mergeConfig ( clientConfig )  ;", "}", "return   this . requestConfig ;", "}", "METHOD_END"], "methodName": ["createRequestConfig"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . httpClient ;", "}", "METHOD_END"], "methodName": ["getHttpClient"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . requestConfig )     =  =    null )     {", "return   clientConfig ;", "}", "Config . Builder   builder    =    Config . copy ( clientConfig )  ;", "int   connectTimeout    =    this . requestConfig . getConnectTimeout (  )  ;", "if    ( connectTimeout    >  =     0  )     {", "builder . setConnectTimeout ( connectTimeout )  ;", "}", "int   connectionTimeout    =    this . requestConfig . getConnectionTimeout (  )  ;", "if    ( connectionTimeout    >  =     0  )     {", "builder . setConnectionTimeout ( connectionTimeout )  ;", "}", "int   socketTimeout    =    this . requestConfig . getSocketTimeout (  )  ;", "if    ( socketTimeout    >  =     0  )     {", "builder . setSocketTimeout ( socketTimeout )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["mergeRequestConfig"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( this . requestConfig )     !  =    null    ?    RequestConfig . copy ( this . requestConfig )     :    RequestConfig . custom (  )  ;", "}", "METHOD_END"], "methodName": ["requestConfigBuilder"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . bufferRequestBody    =    bufferRequestBody ;", "}", "METHOD_END"], "methodName": ["setBufferRequestBody"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( timeout    >  =     0  )  ,     \" Timeout   must   be   a   non - negative   value \"  )  ;", "this . rConfig    =    rConfigBuilder (  )  . setConnectTimeout ( timeout )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setConnectTimeout"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . requestConfig    =    requestConfigBuilder (  )  . setConnectionRequestTimeout ( connectionRequestTimeout )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setConnectionRequestTimeout"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( httpClient ,     \" HttpClient   must   not   be   null \"  )  ;", "this . httpClient    =    httpClient ;", "}", "METHOD_END"], "methodName": ["setHttpClient"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( timeout    >  =     0  )  ,     \" Timeout   must   be   a   non - negative   value \"  )  ;", "this . rConfig    =    rConfigBuilder (  )  . setSocketTimeout ( timeout )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setReadTimeout"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "HttpClient   httpClient    =    HttpClientBuilder . create (  )  . build (  )  ;", "hrf    =    new    ( httpClient )  ;", "hrf . setConnectTimeout (  1  2  3  4  )  ;", "hrf . setConnectionRequestTimeout (  4  3  2  1  )  ;", "hrf . setReadTimeout (  4  5  6  7  )  ;", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / status / ok \"  )  )  ;", "HttpComponentsClientHttpRequest   request    =     (  ( HttpComponentsClientHttpRequest )     ( hrf . createRequest ( uri ,    HttpMethod . GET )  )  )  ;", "Object   config    =    request . getHttpContext (  )  . getAttribute ( REQUEST _ CONFIG )  ;", "assertNotNull (  \" Request   config   should   be   set \"  ,    config )  ;", "assertTrue (  (  \" Wrong   request   config   type \"     +     ( config . getClass (  )  . getName (  )  )  )  ,    RequestConfig . class . isInstance ( config )  )  ;", "RequestConfig   requestConfig    =     (  ( RequestConfig )     ( config )  )  ;", "assertEquals (  \" Wrong   custom   connection   timeout \"  ,     1  2  3  4  ,    requestConfig . getConnectTimeout (  )  )  ;", "assertEquals (  \" Wrong   custom   connection   request   timeout \"  ,     4  3  2  1  ,    requestConfig . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  \" Wrong   custom   socket   timeout \"  ,     4  5  6  7  ,    requestConfig . getSocketTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCustomConfig"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" http :  /  / example . com \"  )  ;", "testBodyAllowed ( uri ,    HttpMethod . GET ,    false )  ;", "testBodyAllowed ( uri ,    HttpMethod . HEAD ,    false )  ;", "testBodyAllowed ( uri ,    HttpMethod . OPTIONS ,    false )  ;", "testBodyAllowed ( uri ,    HttpMethod . TRACE ,    false )  ;", "testBodyAllowed ( uri ,    HttpMethod . PUT ,    true )  ;", "testBodyAllowed ( uri ,    HttpMethod . POST ,    true )  ;", "testBodyAllowed ( uri ,    HttpMethod . PATCH ,    true )  ;", "testBodyAllowed ( uri ,    HttpMethod . DELETE ,    true )  ;", "}", "METHOD_END"], "methodName": ["createHttpUriRequest"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "RequestConfig   defaultConfig    =    RequestConfig . custom (  )  . setConnectTimeout (  1  2  3  4  )  . build (  )  ;", "CloseableHttpClient   client    =    mock ( CloseableHttpClient . class ,    withSettings (  )  . extraInterfaces ( Configurable . class )  )  ;", "Configurable   configurable    =     (  ( Configurable )     ( client )  )  ;", "when ( configurable . getConfig (  )  )  . thenReturn ( defaultConfig )  ;", "hrf    =    new    ( client )  ;", "assertSame (  \" Default   client   configuration   is   expected \"  ,    defaultConfig ,    retrieveRequestConfig ( hrf )  )  ;", "hrf . setConnectionRequestTimeout (  4  5  6  7  )  ;", "RequestConfig   requestConfig    =    retrieveRequestConfig ( hrf )  ;", "assertNotNull ( requestConfig )  ;", "assertEquals (  4  5  6  7  ,    requestConfig . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  1  2  3  4  ,    requestConfig . getConnectTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultSettingsOfHttpClientMergedOnExecutorCustomization"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "RequestConfig   defaultConfig    =    RequestConfig . custom (  )  . setConnectTimeout (  1  2  3  4  )  . setConnectionRequestTimeout (  6  7  8  9  )  . build (  )  ;", "CloseableHttpClient   client    =    mock ( CloseableHttpClient . class ,    withSettings (  )  . extraInterfaces ( Configurable . class )  )  ;", "Configurable   configurable    =     (  ( Configurable )     ( client )  )  ;", "when ( configurable . getConfig (  )  )  . thenReturn ( defaultConfig )  ;", "hrf    =    new    ( client )  ;", "hrf . setConnectTimeout (  5  0  0  0  )  ;", "RequestConfig   requestConfig    =    retrieveRequestConfig ( hrf )  ;", "assertEquals (  5  0  0  0  ,    requestConfig . getConnectTimeout (  )  )  ;", "assertEquals (  6  7  8  9  ,    requestConfig . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  (  -  1  )  ,    requestConfig . getSocketTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["localSettingsOverrideClientDefaultSettings"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "RequestConfig   defaultConfig    =    RequestConfig . custom (  )  . setSocketTimeout (  1  2  3  4  )  . build (  )  ;", "final   CloseableHttpClient   client    =    mock ( CloseableHttpClient . class ,    withSettings (  )  . extraInterfaces ( Configurable . class )  )  ;", "Configurable   configurable    =     (  ( Configurable )     ( client )  )  ;", "when ( configurable . getConfig (  )  )  . thenReturn ( defaultConfig )  ;", "hrf    =    new    (  )     {", "@ Override", "public   HttpClient   getHttpClient (  )     {", "return   client ;", "}", "}  ;", "hrf . setReadTimeout (  5  0  0  0  )  ;", "RequestConfig   requestConfig    =    retrieveRequestConfig ( hrf )  ;", "assertEquals (  (  -  1  )  ,    requestConfig . getConnectTimeout (  )  )  ;", "assertEquals (  (  -  1  )  ,    requestConfig . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  5  0  0  0  ,    requestConfig . getSocketTimeout (  )  )  ;", "RequestConfig   updatedDefaultConfig    =    RequestConfig . custom (  )  . setConnectTimeout (  1  2  3  4  )  . build (  )  ;", "when ( configurable . getConfig (  )  )  . thenReturn ( updatedDefaultConfig )  ;", "hrf . setReadTimeout (  7  0  0  0  )  ;", "RequestConfig   requestConfig 2     =    retrieveRequestConfig ( hrf )  ;", "assertEquals (  1  2  3  4  ,    requestConfig 2  . getConnectTimeout (  )  )  ;", "assertEquals (  (  -  1  )  ,    requestConfig 2  . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  7  0  0  0  ,    requestConfig 2  . getSocketTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeBasedOnCurrentHttpClient"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  ( baseUrl )     +     \"  / status / ok \"  )  )  ;", "request    =     (  (  )     ( factory . createRequest ( uri ,    HttpMethod . GET )  )  )  ;", "return    (  ( RequestConfig )     ( request . getHttpContext (  )  . getAttribute ( REQUEST _ CONFIG )  )  )  ;", "}", "METHOD_END"], "methodName": ["retrieveRequestConfig"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "HttpUriRequest   request    =     (  ( HttpComponentsClientHttpRequestFactory )     ( this . factory )  )  . createHttpUriRequest ( method ,    uri )  ;", "assertEquals ( allowed ,     ( request   instanceof   HttpEntityEnclosingRequest )  )  ;", "}", "METHOD_END"], "methodName": ["testRequestBodyAllowed"], "fileName": "org.springframework.http.client.HttpComponentsClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "List < ClientHttpRequestInterceptor >    interceptors    =    new   ArrayList <  >  (  )  ;", "interceptors . add ( new    . NoOpInterceptor (  )  )  ;", "interceptors . add ( new    . NoOpInterceptor (  )  )  ;", "interceptors . add ( new    . NoOpInterceptor (  )  )  ;", "requestFactory    =    new   InterceptingClientHttpRequestFactory ( requestFactoryMock ,    interceptors )  ;", "ClientHttpRequest   request    =    requestFactory . createRequest ( new   URI (  \" http :  /  / example . com \"  )  ,    HttpMethod . GET )  ;", "ClientHttpResponse   response    =    request . execute (  )  ;", "assertTrue (  (  (  . NoOpInterceptor )     ( interceptors . get (  0  )  )  )  . invoked )  ;", "assertTrue (  (  (  . NoOpInterceptor )     ( interceptors . get (  1  )  )  )  . invoked )  ;", "assertTrue (  (  (  . NoOpInterceptor )     ( interceptors . get (  2  )  )  )  . invoked )  ;", "assertTrue ( requestMock . executed )  ;", "assertSame ( responseMock ,    response )  ;", "}", "METHOD_END"], "methodName": ["basic"], "fileName": "org.springframework.http.client.InterceptingClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "final   byte [  ]    changedBody    =     \" Foo \"  . getBytes (  )  ;", "ClientHttpRequestInterceptor   interceptor    =    new   ClientHttpRequestInterceptor (  )     {", "@ Override", "public   ClientHttpResponse   intercept ( HttpRequest   request ,    byte [  ]    body ,    ClientHttpRequestExecution   execution )    throws   IOException    {", "return   execution . execute ( request ,    changedBody )  ;", "}", "}  ;", "requestFactory    =    new    ( requestFactoryMock ,    Collections . singletonList ( interceptor )  )  ;", "ClientHttpRequest   request    =    requestFactory . createRequest ( new   URI (  \" http :  /  / example . com \"  )  ,    HttpMethod . GET )  ;", "request . execute (  )  ;", "assertTrue ( Arrays . equals ( changedBody ,    requestMock . body . toByteArray (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["changeBody"], "fileName": "org.springframework.http.client.InterceptingClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "final   String   headerName    =     \" Foo \"  ;", "final   String   headerValue    =     \" Bar \"  ;", "final   String   otherValue    =     \" Baz \"  ;", "ClientHttpRequestInterceptor   interceptor    =    new   ClientHttpRequestInterceptor (  )     {", "@ Override", "public   ClientHttpResponse   intercept ( HttpRequest   request ,    byte [  ]    body ,    ClientHttpRequestExecution   execution )    throws   IOException    {", "HttpRequestWrapper   wrapper    =    new   HttpRequestWrapper ( request )  ;", "wrapper . getHeaders (  )  . add ( headerName ,    otherValue )  ;", "return   execution . execute ( wrapper ,    body )  ;", "}", "}  ;", "requestMock    =    new    . RequestMock (  )     {", "@ Override", "public   ClientHttpResponse   execute (  )    throws   IOException    {", "List < String >    headerValues    =    getHeaders (  )  . get ( headerName )  ;", "assertEquals (  2  ,    headerValues . size (  )  )  ;", "assertEquals ( headerValue ,    headerValues . get (  0  )  )  ;", "assertEquals ( otherValue ,    headerValues . get (  1  )  )  ;", "return   super . execute (  )  ;", "}", "}  ;", "requestMock . getHeaders (  )  . add ( headerName ,    headerValue )  ;", "requestFactory    =    new   InterceptingClientHttpRequestFactory ( requestFactoryMock ,    Collections . singletonList ( interceptor )  )  ;", "ClientHttpRequest   request    =    requestFactory . createRequest ( new   URI (  \" http :  /  / example . com \"  )  ,    HttpMethod . GET )  ;", "request . execute (  )  ;", "}", "METHOD_END"], "methodName": ["changeHeaders"], "fileName": "org.springframework.http.client.InterceptingClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "final   HttpMethod   changedMethod    =    HttpMethod . POST ;", "ClientHttpRequestInterceptor   interceptor    =    new   ClientHttpRequestInterceptor (  )     {", "@ Override", "public   ClientHttpResponse   intercept ( HttpRequest   request ,    byte [  ]    body ,    ClientHttpRequestExecution   execution )    throws   IOException    {", "return   execution . execute ( new   HttpRequestWrapper ( request )     {", "@ Override", "public   HttpMethod   getMethod (  )     {", "return   changedMethod ;", "}", "}  ,    body )  ;", "}", "}  ;", "requestFactoryMock    =    new    . RequestFactoryMock (  )     {", "@ Override", "public   ClientHttpRequest   createRequest ( URI   uri ,    HttpMethod   httpMethod )    throws   IOException    {", "assertEquals ( changedMethod ,    httpMethod )  ;", "return   super . createRequest ( uri ,    httpMethod )  ;", "}", "}  ;", "requestFactory    =    new   InterceptingClientHttpRequestFactory ( requestFactoryMock ,    Collections . singletonList ( interceptor )  )  ;", "ClientHttpRequest   request    =    requestFactory . createRequest ( new   URI (  \" http :  /  / example . com \"  )  ,    HttpMethod . GET )  ;", "request . execute (  )  ;", "}", "METHOD_END"], "methodName": ["changeMethod"], "fileName": "org.springframework.http.client.InterceptingClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "final   URI   changedUri    =    new   URI (  \" http :  /  / example . com /  2  \"  )  ;", "ClientHttpRequestInterceptor   interceptor    =    new   ClientHttpRequestInterceptor (  )     {", "@ Override", "public   ClientHttpResponse   intercept ( HttpRequest   request ,    byte [  ]    body ,    ClientHttpRequestExecution   execution )    throws   IOException    {", "return   execution . execute ( new   HttpRequestWrapper ( request )     {", "@ Override", "public   URI   getURI (  )     {", "return   changedUri ;", "}", "}  ,    body )  ;", "}", "}  ;", "requestFactoryMock    =    new    . RequestFactoryMock (  )     {", "@ Override", "public   ClientHttpRequest   createRequest ( URI   uri ,    HttpMethod   httpMethod )    throws   IOException    {", "assertEquals ( changedUri ,    uri )  ;", "return   super . createRequest ( uri ,    httpMethod )  ;", "}", "}  ;", "requestFactory    =    new   InterceptingClientHttpRequestFactory ( requestFactoryMock ,    Collections . singletonList ( interceptor )  )  ;", "ClientHttpRequest   request    =    requestFactory . createRequest ( new   URI (  \" http :  /  / example . com \"  )  ,    HttpMethod . GET )  ;", "request . execute (  )  ;", "}", "METHOD_END"], "methodName": ["changeURI"], "fileName": "org.springframework.http.client.InterceptingClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "List < ClientHttpRequestInterceptor >    interceptors    =    new   ArrayList <  >  (  )  ;", "interceptors . add ( new   ClientHttpRequestInterceptor (  )     {", "@ Override", "public   ClientHttpResponse   intercept ( HttpRequest   request ,    byte [  ]    body ,    ClientHttpRequestExecution   execution )    throws   IOException    {", "return   responseMock ;", "}", "}  )  ;", "interceptors . add ( new    . NoOpInterceptor (  )  )  ;", "requestFactory    =    new   InterceptingClientHttpRequestFactory ( requestFactoryMock ,    interceptors )  ;", "ClientHttpRequest   request    =    requestFactory . createRequest ( new   URI (  \" http :  /  / example . com \"  )  ,    HttpMethod . GET )  ;", "ClientHttpResponse   response    =    request . execute (  )  ;", "assertFalse (  (  (  . NoOpInterceptor )     ( interceptors . get (  1  )  )  )  . invoked )  ;", "assertFalse ( requestMock . executed )  ;", "assertSame ( responseMock ,    response )  ;", "}", "METHOD_END"], "methodName": ["noExecution"], "fileName": "org.springframework.http.client.InterceptingClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( elementClass ,     \"  ' elementClass '    must   not   be   null \"  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( elementClass )  ;", "Assert . hasLength ( name ,     \"  ' name '    must   not   be   empty \"  )  ;", "Assert . notNull ( publisher ,     \"  ' publisher '    must   not   be   null \"  )  ;", "Assert . notNull ( elementType ,     \"  ' elementType '    must   not   be   null \"  )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", ". PublisherPartBuilder < T ,    P >    builder    =    new    . PublisherPartBuilder ( headers ,    publisher ,    elementClass )  ;", "this . parts . add ( name ,    builder )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["asyncPart"], "fileName": "org.springframework.http.client.MultipartBodyBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( typeReference ,     \"  ' typeReference '    must   not   be   null \"  )  ;", "ResolvableType   elementType 1     =    ResolvableType . forType ( typeReference )  ;", "Assert . hasLength ( name ,     \"  ' name '    must   not   be   empty \"  )  ;", "Assert . notNull ( publisher ,     \"  ' publisher '    must   not   be   null \"  )  ;", "Assert . notNull ( elementType 1  ,     \"  ' typeReference '    must   not   be   null \"  )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", ". PublisherPartBuilder < T ,    P >    builder    =    new    . PublisherPartBuilder ( headers ,    publisher ,    typeReference )  ;", "this . parts . add ( name ,    builder )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["asyncPart"], "fileName": "org.springframework.http.client.MultipartBodyBuilder"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    HttpEntity <  ?  >  >    result    =    new   LinkedMultiValueMap ( this . parts . size (  )  )  ;", "for    ( Map . Entry < String ,    List < MultipartBodyBuilder . DefaultPartBuilder >  >    entry    :    this . parts . entrySet (  )  )     {", "for    ( MultipartBodyBuilder . DefaultPartBuilder   builder    :    entry . getValue (  )  )     {", "HttpEntity <  ?  >    entity    =    builder . build (  )  ;", "result . add ( entry . getKey (  )  ,    entity )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.http.client.MultipartBodyBuilder"}, {"methodBody": ["METHOD_START", "{", "return   part ( name ,    part ,    null )  ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "org.springframework.http.client.MultipartBodyBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( name ,     \"  ' name '    must   not   be   empty \"  )  ;", "Assert . notNull ( part ,     \"  ' part '    must   not   be   null \"  )  ;", "if    ( part   instanceof   Publisher )     {", "throw   new   IllegalArgumentException (  (  \" Use   publisher ( String ,    Publisher ,    Class )    or    \"     +     \" publisher ( String ,    Publisher ,    ParameterizedTypeReference )    for   adding   Publisher   parts \"  )  )  ;", "}", "if    ( part   instanceof    . PublisherEntity <  ?  ,     ?  >  )     {", ". PublisherPartBuilder <  ?  ,     ?  >    builder    =    new    . PublisherPartBuilder (  (  (  . PublisherEntity <  ?  ,     ?  >  )     ( part )  )  )  ;", "this . parts . add ( name ,    builder )  ;", "return   builder ;", "}", "Object   partBody ;", "HttpHeaders   partHeaders    =    new   HttpHeaders (  )  ;", "if    ( part   instanceof   HttpEntity )     {", "HttpEntity <  ?  >    other    =     (  ( HttpEntity <  ?  >  )     ( part )  )  ;", "partBody    =    other . getBody (  )  ;", "partHeaders . addAll ( other . getHeaders (  )  )  ;", "} else    {", "partBody    =    part ;", "}", "if    ( contentType    !  =    null )     {", "partHeaders . setContentType ( contentType )  ;", "}", ". DefaultPartBuilder   builder    =    new    . DefaultPartBuilder ( partHeaders ,    partBody )  ;", "this . parts . add ( name ,    builder )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["part"], "fileName": "org.springframework.http.client.MultipartBodyBuilder"}, {"methodBody": ["METHOD_START", "{", "MultipartBodyBuilder   builder    =    new   MultipartBodyBuilder (  )  ;", "MultiValueMap < String ,    String >    multipartData    =    new   LinkedMultiValueMap (  )  ;", "multipartData . add (  \" form   field \"  ,     \" form   value \"  )  ;", "builder . part (  \" key \"  ,    multipartData )  . header (  \" foo \"  ,     \" bar \"  )  ;", "Resource   logo    =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )  ;", "builder . part (  \" logo \"  ,    logo )  . header (  \" baz \"  ,     \" qux \"  )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . add (  \" foo \"  ,     \" bar \"  )  ;", "HttpEntity < String >    entity    =    new   HttpEntity (  \" body \"  ,    entityHeaders )  ;", "builder . part (  \" entity \"  ,    entity )  . header (  \" baz \"  ,     \" qux \"  )  ;", "Publisher < String >    publisher    =    Flux . just (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "builder . asyncPart (  \" publisherClass \"  ,    publisher ,    String . class )  . header (  \" baz \"  ,     \" qux \"  )  ;", "builder . asyncPart (  \" publisherPtr \"  ,    publisher ,    new   ParameterizedTypeReference < String >  (  )     {  }  )  . header (  \" baz \"  ,     \" qux \"  )  ;", "MultiValueMap < String ,    HttpEntity <  ?  >  >    result    =    builder . build (  )  ;", "assertEquals (  5  ,    result . size (  )  )  ;", "HttpEntity <  ?  >    resultEntity    =    result . getFirst (  \" key \"  )  ;", "assertNotNull ( resultEntity )  ;", "assertEquals ( multipartData ,    resultEntity . getBody (  )  )  ;", "assertEquals (  \" bar \"  ,    resultEntity . getHeaders (  )  . getFirst (  \" foo \"  )  )  ;", "resultEntity    =    result . getFirst (  \" logo \"  )  ;", "assertNotNull ( resultEntity )  ;", "assertEquals ( logo ,    resultEntity . getBody (  )  )  ;", "assertEquals (  \" qux \"  ,    resultEntity . getHeaders (  )  . getFirst (  \" baz \"  )  )  ;", "resultEntity    =    result . getFirst (  \" entity \"  )  ;", "assertNotNull ( resultEntity )  ;", "assertEquals (  \" body \"  ,    resultEntity . getBody (  )  )  ;", "assertEquals (  \" bar \"  ,    resultEntity . getHeaders (  )  . getFirst (  \" foo \"  )  )  ;", "assertEquals (  \" qux \"  ,    resultEntity . getHeaders (  )  . getFirst (  \" baz \"  )  )  ;", "resultEntity    =    result . getFirst (  \" publisherClass \"  )  ;", "assertNotNull ( resultEntity )  ;", "assertEquals ( publisher ,    resultEntity . getBody (  )  )  ;", "assertEquals ( ResolvableType . forClass ( String . class )  ,     (  ( MultipartBodyBuilder . PublisherEntity <  ?  ,     ?  >  )     ( resultEntity )  )  . getResolvableType (  )  )  ;", "assertEquals (  \" qux \"  ,    resultEntity . getHeaders (  )  . getFirst (  \" baz \"  )  )  ;", "resultEntity    =    result . getFirst (  \" publisherPtr \"  )  ;", "assertNotNull ( resultEntity )  ;", "assertEquals ( publisher ,    resultEntity . getBody (  )  )  ;", "assertEquals ( ResolvableType . forClass ( String . class )  ,     (  ( MultipartBodyBuilder . PublisherEntity <  ?  ,     ?  >  )     ( resultEntity )  )  . getResolvableType (  )  )  ;", "assertEquals (  \" qux \"  ,    resultEntity . getHeaders (  )  . getFirst (  \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.http.client.MultipartBodyBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Publisher < String >    publisher    =    Flux . just (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "builder    =    new    (  )  ;", "builder . asyncPart (  \" publisherClass \"  ,    publisher ,    String . class )  . header (  \" baz \"  ,     \" qux \"  )  ;", "HttpEntity <  ?  >    entity    =    builder . build (  )  . getFirst (  \" publisherClass \"  )  ;", "assertNotNull ( entity )  ;", "assertEquals (  . PublisherEntity . class ,    entity . getClass (  )  )  ;", "builder    =    new    (  )  ;", "builder . part (  \" publisherClass \"  ,    entity )  ;", "entity    =    builder . build (  )  . getFirst (  \" publisherClass \"  )  ;", "assertNotNull ( entity )  ;", "assertEquals (  . PublisherEntity . class ,    entity . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherEntityAcceptedAsInput"], "fileName": "org.springframework.http.client.MultipartBodyBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Netty 4 AsyncClientHttpRequestFactoryTests . eventLoopGroup    =    new   NioEventLoopGroup (  )  ;", "}", "METHOD_END"], "methodName": ["createEventLoopGroup"], "fileName": "org.springframework.http.client.Netty4AsyncClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Netty 4 AsyncClientHttpRequestFactoryTests . eventLoopGroup . shutdownGracefully (  )  . sync (  )  ;", "}", "METHOD_END"], "methodName": ["shutdownEventLoopGroup"], "fileName": "org.springframework.http.client.Netty4AsyncClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "HttpMethod   nettyMethod    =    HttpMethod . valueOf ( this . method . name (  )  )  ;", "String   authority    =    this . uri . getRawAuthority (  )  ;", "String   path    =    this . uri . toString (  )  . substring (  (  ( this . uri . toString (  )  . indexOf ( authority )  )     +     ( authority . length (  )  )  )  )  ;", "FullHttpRequest   nettyRequest    =    new   io . netty . handler . codec . http . DefaultFullHttpRequest ( HttpVersion . HTTP _  1  _  1  ,    nettyMethod ,    path ,    this . body . buffer (  )  )  ;", "nettyRequest . headers (  )  . set ( HttpHeaders . HOST ,     (  (  ( this . uri . getHost (  )  )     +     \"  :  \"  )     +     (  . getPort ( uri )  )  )  )  ;", "nettyRequest . headers (  )  . set ( HttpHeaders . CONNECTION ,     \" close \"  )  ;", "headers . forEach (  (    headerName ,    headerValues )     -  >    nettyRequest . headers (  )  . add ( headerName ,    headerValues )  )  ;", "if    (  (  !  ( nettyRequest . headers (  )  . contains ( HttpHeaders . CONTENT _ LENGTH )  )  )     &  &     (  ( this . body . buffer (  )  . readableBytes (  )  )     >     0  )  )     {", "nettyRequest . headers (  )  . set ( HttpHeaders . CONTENT _ LENGTH ,    this . body . buffer (  )  . readableBytes (  )  )  ;", "}", "return   nettyRequest ;", "}", "METHOD_END"], "methodName": ["createFullHttpRequest"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "int   port    =    uri . getPort (  )  ;", "if    ( port    =  =     (  -  1  )  )     {", "if    (  \"  \"  . equalsIgnoreCase ( uri . getScheme (  )  )  )     {", "port    =     8  0  ;", "} else", "if    (  \" s \"  . equalsIgnoreCase ( uri . getScheme (  )  )  )     {", "port    =     4  4  3  ;", "}", "}", "return   port ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Bootstrap   bootstrap    =    new   Bootstrap (  )  ;", "bootstrap . group ( this . eventLoopGroup )  . channel ( NioSocketChannel . class )  . handler ( new   io . netty . channel . ChannelInitializer < SocketChannel >  (  )     {", "@ Override", "protected   void   initChannel ( SocketChannel   channel )    throws   Exception    {", "configureChannel ( channel . config (  )  )  ;", "ChannelPipeline   pipeline    =    channel . pipeline (  )  ;", "if    ( isSecure )     {", "Assert . notNull ( sslContext ,     \" sslContext   should   not   be   null \"  )  ;", "pipeline . addLast ( sslContext . newHandler ( channel . alloc (  )  ,    uri . getHost (  )  ,    uri . getPort (  )  )  )  ;", "}", "pipeline . addLast ( new   HttpCodec (  )  )  ;", "pipeline . addLast ( new   HttpObjectAggregator ( maxResponseSize )  )  ;", "if    (  ( readTimeout )     >     0  )     {", "pipeline . addLast ( new   ReadTimeoutHandler ( readTimeout ,    TimeUnit . MILLISECONDS )  )  ;", "}", "}", "}  )  ;", "return   bootstrap ;", "}", "METHOD_END"], "methodName": ["buildBootstrap"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . connectTimeout )     >  =     0  )     {", "confietConnectTimeoutMillis ( this . connectTimeout )  ;", "}", "}", "METHOD_END"], "methodName": ["configureChannel"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   Netty 4 ClientHttpRequest ( getBootstrap ( uri )  ,    uri ,    httpMethod )  ;", "}", "METHOD_END"], "methodName": ["createRequestInternal"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "boolean   isSecure    =     (  ( uri . getPort (  )  )     =  =     4  4  3  )     |  |     (  \" https \"  . equalsIgnoreCase ( uri . getScheme (  )  )  )  ;", "if    ( isSecure )     {", "return   buildBootstrap ( uri ,    true )  ;", "} else    {", "Bootstrap   bootstrap    =    this . bootstrap ;", "if    ( bootstrap    =  =    null )     {", "bootstrap    =    buildBootstrap ( uri ,    false )  ;", "this . bootstrap    =    bootstrap ;", "}", "return   bootstrap ;", "}", "}", "METHOD_END"], "methodName": ["getBootstrap"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   SslContextBuilder . for (  )  . build (  )  ;", "}    catch    ( SSLException   ex )     {", "throw   new   IllegalStateException (  \" Could   not   create   default   client   SslContext \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getDefaultClientSslContext"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . connectTimeout    =    connectTimeout ;", "}", "METHOD_END"], "methodName": ["setConnectTimeout"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . maxResponseSize    =    maxResponseSize ;", "}", "METHOD_END"], "methodName": ["setMaxResponseSize"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . readTimeout    =    readTimeout ;", "}", "METHOD_END"], "methodName": ["setReadTimeout"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . sslContext    =    sslContext ;", "}", "METHOD_END"], "methodName": ["setSslContext"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "Netty 4 ClientHttpRequestFactoryTests . eventLoopGroup    =    new   NioEventLoopGroup (  )  ;", "}", "METHOD_END"], "methodName": ["createEventLoopGroup"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Netty 4 ClientHttpRequestFactoryTests . eventLoopGroup . shutdownGracefully (  )  . sync (  )  ;", "}", "METHOD_END"], "methodName": ["shutdownEventLoopGroup"], "fileName": "org.springframework.http.client.Netty4ClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    OkHttp 3 ClientHttpRequestFactory . getContentType ( headers )  ;", "RequestBody   body    =     (  (  ( content . length )     >     0  )     |  |     ( HttpMethod . requiresRequestBody ( method . name (  )  )  )  )     ?    RequestBody . create ( contentType ,    content )     :    null ;", "Request . Builder   builder    =    new   Request . Builder (  )  . url ( uri . toURL (  )  )  . method ( method . name (  )  ,    body )  ;", "headers . forEach (  (    headerName ,    headerValues )     -  >     {", "for    ( String   headerValue    :    headerValues )     {", "builder . addHeader ( headerName ,    headerValue )  ;", "}", "}  )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildRequest"], "fileName": "org.springframework.http.client.OkHttp3ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "String   rawContentType    =    headers . getFirst ( HttpHeaders . CONTENT _ TYPE )  ;", "return   StringUtils . hasText ( rawContentType )     ?    MediaType . parse ( rawContentType )     :    null ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.http.client.OkHttp3ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . client    =    this . client . newBuilder (  )  . connectTimeout ( connectTimeout ,    MILLISECONDS )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setConnectTimeout"], "fileName": "org.springframework.http.client.OkHttp3ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . client    =    this . client . newBuilder (  )  . readTimeout ( readTimeout ,    MILLISECONDS )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setReadTimeout"], "fileName": "org.springframework.http.client.OkHttp3ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . client    =    this . client . newBuilder (  )  . writeTimeout ( writeTimeout ,    MILLISECONDS )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setWriteTimeout"], "fileName": "org.springframework.http.client.OkHttp3ClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "headers . forEach (  (    headerName ,    headerValues )     -  >     {", "if    ( HttpHeaders . COOKIE . equalsIgnoreCase ( headerName )  )     {", "String   headerValue    =    StringUtils . collectionToDelimitedString ( headerValues ,     \"  ;     \"  )  ;", "connection . setProperty ( headerName ,    headerValue )  ;", "} else    {", "for    ( String   headerValue    :    headerValues )     {", "String   actualHeaderValue    =     ( headerValue    !  =    null )     ?    headerValue    :     \"  \"  ;", "connection . addProperty ( headerName ,    actualHeaderValue )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addHeaders"], "fileName": "org.springframework.http.client.SimpleBufferingClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "URLConnection   urlConnection    =     ( proxy    !  =    null )     ?    url . openConnection ( proxy )     :    url . openConnection (  )  ;", "if    (  !  ( URLConnection . class . isInstance ( urlConnection )  )  )     {", "throw   new   IllegalStateException (  (  (  (  \" URLConnection   required   for    [  \"     +    url )     +     \"  ]    but   got :     \"  )     +    urlConnection )  )  ;", "}", "return    (  ( URLConnection )     ( urlConnection )  )  ;", "}", "METHOD_END"], "methodName": ["openConnection"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . connectTimeout )     >  =     0  )     {", "connection . setConnectTimeout ( this . connectTimeout )  ;", "}", "if    (  ( this . readTimeout )     >  =     0  )     {", "connection . setReadTimeout ( this . readTimeout )  ;", "}", "connection . setDoInput ( true )  ;", "if    (  \" GET \"  . equals ( httpMethod )  )     {", "connection . setInstanceFollowRedirects ( true )  ;", "} else    {", "connection . setInstanceFollowRedirects ( false )  ;", "}", "if    (  (  (  (  \" POST \"  . equals ( httpMethod )  )     |  |     (  \" PUT \"  . equals ( httpMethod )  )  )     |  |     (  \" PATCH \"  . equals ( httpMethod )  )  )     |  |     (  \" DELETE \"  . equals ( httpMethod )  )  )     {", "connection . setDoOutput ( true )  ;", "} else    {", "connection . setDoOutput ( false )  ;", "}", "connection . setMethod ( httpMethod )  ;", "}", "METHOD_END"], "methodName": ["prepareConnection"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . bufferRequestBody    =    bufferRequestBody ;", "}", "METHOD_END"], "methodName": ["setBufferRequestBody"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . chunkSize    =    chunkSize ;", "}", "METHOD_END"], "methodName": ["setChunkSize"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . connectTimeout    =    connectTimeout ;", "}", "METHOD_END"], "methodName": ["setConnectTimeout"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . outputStreaming    =    outputStreaming ;", "}", "METHOD_END"], "methodName": ["setOutputStreaming"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . proxy    =    proxy ;", "}", "METHOD_END"], "methodName": ["setProxy"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . readTimeout    =    readTimeout ;", "}", "METHOD_END"], "methodName": ["setReadTimeout"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactory"}, {"methodBody": ["METHOD_START", "{", "HttpURLConnection   urlConnection    =    mock ( HttpURLConnection . class )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . set (  \" foo \"  ,    null )  ;", "SimpleBuffering . addHeaders ( urlConnection ,    headers )  ;", "verify ( urlConnection ,    times (  1  )  )  . addRequestProperty (  \" foo \"  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["headerWithNullValue"], "fileName": "org.springframework.http.client.SimpleClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "this . connection    =    mock ( HttpURLConnection . class )  ;", "this . response    =    new    ( this . connection )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.http.client.SimpleClientHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buf    =    new   byte [  6  ]  ;", ". TestByteArrayInputStream   is    =    new    . TestByteArrayInputStream (  \" SpringSpring \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "given ( this . connection . getErrorStream (  )  )  . willReturn ( is )  ;", "InputStream   responseStream    =    this . response . getBody (  )  ;", "responseStream . read ( buf )  ;", "assertThat ( new   String ( buf ,    StandardCharsets . UTF _  8  )  ,    is (  \" Spring \"  )  )  ;", "assertThat ( is . available (  )  ,    is (  6  )  )  ;", "this . response . close (  )  ;", "assertThat ( is . available (  )  ,    is (  0  )  )  ;", "assertTrue ( is . isClosed (  )  )  ;", "verify ( this . connection ,    never (  )  )  . disconnect (  )  ;", "}", "METHOD_END"], "methodName": ["shouldDrainErrorStreamWhenResponseClosed"], "fileName": "org.springframework.http.client.SimpleClientHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buf    =    new   byte [  6  ]  ;", ". TestByteArrayInputStream   is    =    new    . TestByteArrayInputStream (  \" SpringSpring \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "given ( this . connection . getErrorStream (  )  )  . willReturn ( null )  ;", "given ( this . connection . getInputStream (  )  )  . willReturn ( is )  ;", "InputStream   responseStream    =    this . response . getBody (  )  ;", "responseStream . read ( buf )  ;", "assertThat ( new   String ( buf ,    StandardCharsets . UTF _  8  )  ,    is (  \" Spring \"  )  )  ;", "assertThat ( is . available (  )  ,    is (  6  )  )  ;", "this . response . close (  )  ;", "assertThat ( is . available (  )  ,    is (  0  )  )  ;", "assertTrue ( is . isClosed (  )  )  ;", "verify ( this . connection ,    never (  )  )  . disconnect (  )  ;", "}", "METHOD_END"], "methodName": ["shouldDrainStreamWhenResponseClosed"], "fileName": "org.springframework.http.client.SimpleClientHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "SimpleClientHttpResponseTests . TestByteArrayInputStream   is    =    new   SimpleClientHttpResponseTests . TestByteArrayInputStream (  \" Spring \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "given ( this . connection . getErrorStream (  )  )  . willReturn ( null )  ;", "given ( this . connection . getInputStream (  )  )  . willReturn ( is )  ;", "InputStream   responseStream    =    this . response . getBody (  )  ;", "assertThat ( StreamUtils . copyToString ( responseStream ,    StandardCharsets . UTF _  8  )  ,    is (  \" Spring \"  )  )  ;", "this . response . close (  )  ;", "assertTrue ( is . isClosed (  )  )  ;", "verify ( this . connection ,    never (  )  )  . disconnect (  )  ;", "}", "METHOD_END"], "methodName": ["shouldNotCloseConnectionWhenResponseClosed"], "fileName": "org.springframework.http.client.SimpleClientHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "final   String   headerName    =     \" MyHeader \"  ;", "final   String   headerValue    =     \" MyValue \"  ;", "ClientHttpRequestInterceptor   interceptor    =     (    request ,    body ,    execution )     -  >     {", "request . getHeaders (  )  . add ( headerName ,    headerValue )  ;", "return   execution . execute ( request ,    body )  ;", "}  ;", "Intercepting   factory    =    new   Intercepting ( createRequestFactory (  )  ,    Collections . singletonList ( interceptor )  )  ;", "ClientHttpResponse   response    =    null ;", "try    {", "ClientHttpRequest   request    =    factory . createRequest ( new   URI (  (  ( baseUrl )     +     \"  / echo \"  )  )  ,    HttpMethod . GET )  ;", "response    =    request . execute (  )  ;", "assertEquals (  \" Invalid   response   status \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "HttpHeaders   responseHeaders    =    response . getHeaders (  )  ;", "assertEquals (  \" Custom   header   invalid \"  ,    headerValue ,    responseHeaders . getFirst ( headerName )  )  ;", "}    finally    {", "if    ( response    !  =    null )     {", "response . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["interceptor"], "fileName": "org.springframework.http.client.StreamingSimpleClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Random   rnd    =    new   Random (  )  ;", "ClientHttpResponse   response    =    null ;", "try    {", "request    =    factory . createRequest ( new   URI (  (  ( baseUrl )     +     \"  / methods / post \"  )  )  ,    HttpMethod . POST )  ;", "final   int   BUF _ SIZE    =     4  0  9  6  ;", "final   int   ITERATIONS    =     ( Integer . MAX _ VALUE )     /    BUF _ SIZE ;", "OutputStream   body    =    request . getBody (  )  ;", "for    ( int   i    =     0  ;    i    <    ITERATIONS ;    i +  +  )     {", "byte [  ]    buffer    =    new   byte [ BUF _ SIZE ]  ;", "rnd . nextBytes ( buffer )  ;", "body . write ( buffer )  ;", "}", "response    =    request . execute (  )  ;", "assertEquals (  \" Invalid   response   status \"  ,    HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "}    finally    {", "if    ( response    !  =    null )     {", "response . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["largeFileUpload"], "fileName": "org.springframework.http.client.StreamingSimpleClientHttpRequestFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   doCommit ( null )  ;", "}", "METHOD_END"], "methodName": ["doCommit"], "fileName": "org.springframework.http.client.reactive.AbstractClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . state . compareAndSet ( AbstractClientHttpRequest . State . NEW ,    AbstractClientHttpRequest . State . COMMITTING )  )  )     {", "return   Mono . empty (  )  ;", "}", "this . commitActions . add (  (  )     -  >     {", "applyHeaders (  )  ;", "applyCookies (  )  ;", "this . state . set ( State . COMMITTED )  ;", "return   Mono . empty (  )  ;", "}  )  ;", "if    ( writeAction    !  =    null )     {", "this . commitActions . add ( writeAction )  ;", "}", "List <  ?    extends   Publisher < Void >  >    actions    =    this . commitActions . stream (  )  . map ( Supplier :  : get )  . collect ( Collectors . toList (  )  )  ;", "return   Mono . fromDirect ( Flux . concat ( actions )  )  ;", "}", "METHOD_END"], "methodName": ["doCommit"], "fileName": "org.springframework.http.client.reactive.AbstractClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.http.client.reactive.ClientHttpRequestDecorator"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.http.client.reactive.ClientHttpResponseDecorator"}, {"methodBody": ["METHOD_START", "{", "return   HttpMethod . valueOf ( method . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["adaptHttpMethod"], "fileName": "org.springframework.http.client.reactive.ReactorClientHttpConnector"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactorClientHttpRequest ( method ,    uri ,    request )  ;", "}", "METHOD_END"], "methodName": ["adaptRequest"], "fileName": "org.springframework.http.client.reactive.ReactorClientHttpConnector"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactorClientHttpResponse ( response )  ;", "}", "METHOD_END"], "methodName": ["adaptResponse"], "fileName": "org.springframework.http.client.reactive.ReactorClientHttpConnector"}, {"methodBody": ["METHOD_START", "{", "return   Flux . from ( dataBuffers )  . map ( NettyDataBufferFactory :  : toByteBuf )  ;", "}", "METHOD_END"], "methodName": ["toByteBufs"], "fileName": "org.springframework.http.client.reactive.ReactorClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "AsyncClientHttpRequest   request    =    getAsyncRequestFactory (  )  . createAsyncRequest ( url ,    method )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Created   asynchronous    \"     +     ( method . name (  )  )  )     +     \"    request   for    \\  \"  \"  )     +    url )     +     \"  \\  \"  \"  )  )  ;", "}", "return   request ;", "}", "METHOD_END"], "methodName": ["createAsyncRequest"], "fileName": "org.springframework.http.client.support.AsyncHttpAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( asyncRequestFactory )     !  =    null )  ,     \" No   AsyncClientHttpRequestFactory   set \"  )  ;", "return   this . asyncRequestFactory ;", "}", "METHOD_END"], "methodName": ["getAsyncRequestFactory"], "fileName": "org.springframework.http.client.support.AsyncHttpAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( asyncRequestFactory ,     \" AsyncClientHttpRequestFactory   must   not   be   null \"  )  ;", "this . asyncRequestFactory    =    asyncRequestFactory ;", "}", "METHOD_END"], "methodName": ["setAsyncRequestFactory"], "fileName": "org.springframework.http.client.support.AsyncHttpAccessor"}, {"methodBody": ["METHOD_START", "{", "BasicAuthorizationInterceptor   interceptor    =    new   BasicAuthorizationInterceptor (  \" username \"  ,    null )  ;", "assertEquals (  \"  \"  ,    new   DirectFieldAccessor ( interceptor )  . getPropertyValue (  \" password \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createWhenPasswordIsNullShouldUseEmptyPassword"], "fileName": "org.springframework.http.client.support.BasicAuthorizationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Username   must   not   contain   a   colon \"  )  ;", "new    (  \" username :  \"  ,     \" password \"  )  ;", "}", "METHOD_END"], "methodName": ["createWhenUsernameContainsColonShouldThrowException"], "fileName": "org.springframework.http.client.support.BasicAuthorizationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BasicAuthorizationInterceptor   interceptor    =    new   BasicAuthorizationInterceptor ( null ,     \" password \"  )  ;", "assertEquals (  \"  \"  ,    new   DirectFieldAccessor ( interceptor )  . getPropertyValue (  \" username \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createWhenUsernameIsNullShouldUseEmptyUsername"], "fileName": "org.springframework.http.client.support.BasicAuthorizationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "SimpleClientHttpRequestFactory   requestFactory    =    new   SimpleClientHttpRequestFactory (  )  ;", "ClientHttpRequest   request    =    requestFactory . createRequest ( new   URI (  \" http :  /  / example . com \"  )  ,    HttpMethod . GET )  ;", "ClientHttpRequestExecution   execution    =    mock ( ClientHttpRequestExecution . class )  ;", "byte [  ]    body    =    new   byte [  ]  {        }  ;", "new    (  \" spring \"  ,     \" boot \"  )  . intercept ( request ,    body ,    execution )  ;", "verify ( execution )  . execute ( request ,    body )  ;", "assertEquals (  \" Basic   c 3 ByaW 5 nOmJvb 3 Q =  \"  ,    request . getHeaders (  )  . getFirst (  \" Authorization \"  )  )  ;", "}", "METHOD_END"], "methodName": ["interceptShouldAddHeader"], "fileName": "org.springframework.http.client.support.BasicAuthorizationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ClientHttpRequest   request    =    getRequestFactory (  )  . createRequest ( url ,    method )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Created    \"     +     ( method . name (  )  )  )     +     \"    request   for    \\  \"  \"  )     +    url )     +     \"  \\  \"  \"  )  )  ;", "}", "return   request ;", "}", "METHOD_END"], "methodName": ["createRequest"], "fileName": "org.springframework.http.client.support.HttpAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . requestFactory ;", "}", "METHOD_END"], "methodName": ["getRequestFactory"], "fileName": "org.springframework.http.client.support.HttpAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( requestFactory ,     \" ClientHttpRequestFactory   must   not   be   null \"  )  ;", "this . requestFactory    =    requestFactory ;", "}", "METHOD_END"], "methodName": ["setRequestFactory"], "fileName": "org.springframework.http.client.support.HttpAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . request ;", "}", "METHOD_END"], "methodName": ["getRequest"], "fileName": "org.springframework.http.client.support.HttpRequestWrapper"}, {"methodBody": ["METHOD_START", "{", "return   this . interceptors ;", "}", "METHOD_END"], "methodName": ["getInterceptors"], "fileName": "org.springframework.http.client.support.InterceptingAsyncHttpAccessor"}, {"methodBody": ["METHOD_START", "{", "this . interceptors    =    interceptors ;", "}", "METHOD_END"], "methodName": ["setInterceptors"], "fileName": "org.springframework.http.client.support.InterceptingAsyncHttpAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . interceptors ;", "}", "METHOD_END"], "methodName": ["getInterceptors"], "fileName": "org.springframework.http.client.support.InterceptingHttpAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . interceptors )     !  =    interceptors )     {", "this . interceptors . clear (  )  ;", "this . interceptors . addAll ( interceptors )  ;", "AnnotationAwareOrderComparator . sort ( this . interceptors )  ;", "}", "}", "METHOD_END"], "methodName": ["setInterceptors"], "fileName": "org.springframework.http.client.support.InterceptingHttpAccessor"}, {"methodBody": ["METHOD_START", "{", "InterceptingHttpAccessorTests . TestInterceptingHttpAccessor   accessor    =    new   InterceptingHttpAccessorTests . TestInterceptingHttpAccessor (  )  ;", "List < ClientHttpRequestInterceptor >    interceptors    =    Arrays . asList ( new   InterceptingHttpAccessorTests . SecondClientHttpRequestInterceptor (  )  ,    new   InterceptingHttpAccessorTests . ThirdClientHttpRequestInterceptor (  )  ,    new   InterceptingHttpAccessorTests . FirstClientHttpRequestInterceptor (  )  )  ;", "accessor . setInterceptors ( interceptors )  ;", "assertThat ( accessor . getInterceptors (  )  . get (  0  )  ,    Matchers . instanceOf ( InterceptingHttpAccessorTests . FirstClientHttpRequestInterceptor . class )  )  ;", "assertThat ( accessor . getInterceptors (  )  . get (  1  )  ,    Matchers . instanceOf ( InterceptingHttpAccessorTests . SecondClientHttpRequestInterceptor . class )  )  ;", "assertThat ( accessor . getInterceptors (  )  . get (  2  )  ,    Matchers . instanceOf ( InterceptingHttpAccessorTests . ThirdClientHttpRequestInterceptor . class )  )  ;", "}", "METHOD_END"], "methodName": ["getInterceptors"], "fileName": "org.springframework.http.client.support.InterceptingHttpAccessorTests"}, {"methodBody": ["METHOD_START", "{", "this . hostname    =    hostname ;", "}", "METHOD_END"], "methodName": ["setHostname"], "fileName": "org.springframework.http.client.support.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . port    =    port ;", "}", "METHOD_END"], "methodName": ["setPort"], "fileName": "org.springframework.http.client.support.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.springframework.http.client.support.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "factoryBean . setHostname (  \"  \"  )  ;", "factoryBean . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["noHostname"], "fileName": "org.springframework.http.client.support.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factoryBean . setHostname (  \" example . com \"  )  ;", "factoryBean . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["noPort"], "fileName": "org.springframework.http.client.support.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factoryBean . setType ( null )  ;", "factoryBean . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["noType"], "fileName": "org.springframework.http.client.support.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Proxy . Type   type    =    Proxy . Type . HTTP ;", "f . setType ( type )  ;", "String   hostname    =     \" example . com \"  ;", "f . setHostname ( hostname )  ;", "int   port    =     8  0  8  0  ;", "f . setPort ( port )  ;", "f . afterPropertiesSet (  )  ;", "Proxy   result    =    f . getObject (  )  ;", "assertEquals ( type ,    result . type (  )  )  ;", "InetSocketAddress   address    =     (  ( InetSocketAddress )     ( result . address (  )  )  )  ;", "assertEquals ( hostname ,    address . getHostName (  )  )  ;", "assertEquals ( port ,    address . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "org.springframework.http.client.support.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factoryBean    =    new   ProxyFactoryBean (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.client.support.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   CodecConfigurerFactory . create ( ClientCodecConfigurer . class )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.http.codec.ClientCodecConfigurer"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    impl    =    CodecConfigurerFactory . defaultCodecConfigurers . get ( ifc )  ;", "if    ( impl    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   default   codec   configurer   found   for    \"     +    ifc )  )  ;", "}", "return    (  ( T )     ( BeanUtils . instantiateClass ( impl )  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.http.codec.CodecConfigurerFactory"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    inputMessage . getHeaders (  )  . getContentType (  )  ;", "return   contentType    !  =    null    ?    contentType    :    MediaType . APPLICATION _ OCTET _ STREAM ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.http.codec.DecoderHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "return   this . decoder ;", "}", "METHOD_END"], "methodName": ["getDecoder"], "fileName": "org.springframework.http.codec.DecoderHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . decoder )    instanceof   HttpMessageDecoder )     {", "HttpMessageDecoder <  ?  >    httpDecoder    =     (  ( HttpMessageDecoder <  ?  >  )     ( this . decoder )  )  ;", "return   httpDecoder . getDecodeHints ( actualType ,    elementType ,    request ,    response )  ;", "}", "return   Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getReadHints"], "fileName": "org.springframework.http.codec.DecoderHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( main . getCharset (  )  )     =  =    null )     &  &     ( defaultType    !  =    null )  )     &  &     (  ( defaultType . getCharset (  )  )     !  =    null )  )     {", "return   new   MediaType ( main ,    defaultType . getCharset (  )  )  ;", "}", "return   main ;", "}", "METHOD_END"], "methodName": ["addDefaultCharset"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return   this . encoder ;", "}", "METHOD_END"], "methodName": ["getEncoder"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . encoder )    instanceof   HttpMessageEncoder )     {", "HttpMessageEncoder <  ?  >    httpEncoder    =     (  ( HttpMessageEncoder <  ?  >  )     ( this . encoder )  )  ;", "return   httpEncoder . getEncodeHints ( streamType ,    elementType ,    mediaType ,    request ,    response )  ;", "}", "return   Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getWriteHints"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return   mediaTypes . stream (  )  . filter ( MediaType :  : isConcrete )  . findFirst (  )  . orElse ( null )  ;", "}", "METHOD_END"], "methodName": ["initDefaultMediaType"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( contentType    !  =    null )     &  &     (  ( this . encoder )    instanceof   HttpMessageEncoder )  )     &  &     (  (  ( HttpMessageEncoder <  ?  >  )     ( this . encoder )  )  . getStreamingMediaTypes (  )  . stream (  )  . anyMatch ( contentType :  : isCompatibleWith )  )  ;", "}", "METHOD_END"], "methodName": ["isStreamingMediaType"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "MediaType   result    =    message . getHeaders (  )  . getContentType (  )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "MediaType   fallback    =    this . defaultMediaType ;", "result    =     (  . useFallback ( mediaType ,    fallback )  )     ?    fallback    :    mediaType ;", "if    ( result    !  =    null )     {", "result    =     . addDefaultCharset ( result ,    fallback )  ;", "message . getHeaders (  )  . setContentType ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["updateContentType"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( main    =  =    null )     |  |     (  !  ( main . isConcrete (  )  )  )  )     |  |     (  ( main . equals ( MediaType . APPLICATION _ OCTET _ STREAM )  )     &  &     ( fallback    !  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["useFallback"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "HttpMessageWriter <  ?  >    writer    =    getWriter ( TEXT _ HTML )  ;", "when ( this . encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ HTML )  )  . thenReturn ( true )  ;", "assertTrue ( writer . canWrite ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ HTML )  )  ;", "assertFalse ( writer . canWrite ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ XML )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageWriter <  ?  >    writer    =    getWriter ( TEXT _ HTML ,    TEXT _ XML )  ;", "assertEquals ( Arrays . asList ( MediaType . TEXT _ HTML ,    MediaType . TEXT _ XML )  ,    writer . getWritableMediaTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["getWritableMediaTypes"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "List < MimeType >    typeList    =    Arrays . asList ( mimeTypes )  ;", "when ( this . encoder . getEncodableMimeTypes (  )  )  . thenReturn ( typeList )  ;", "when ( this . encoder . encode ( any (  )  ,    any (  )  ,    any (  )  ,    this . mediaTypeCaptor . capture (  )  ,    any (  )  )  )  . thenReturn ( Flux . empty (  )  )  ;", "return   new    ( this . encoder )  ;", "}", "METHOD_END"], "methodName": ["getWriter"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "this . mediaTypeCaptor    =    ArgumentCaptor . forClass ( MediaType . class )  ;", "this . response    =    new   MockServResponse (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "this . response    =    new   MockServerHttpResponse (  )  ;", "this . mediaTypeCaptor    =    ArgumentCaptor . forClass ( MediaType . class )  ;", "MimeType   defaultContentType    =    MimeTypeUtils . TEXT _ XML ;", "HttpMessageWriter < String >    writer    =    getWriter ( defaultContentType )  ;", "writer . write ( Mono . just (  \" body \"  )  ,    ResolvableType . forClass ( String . class )  ,    negotiatedMediaType ,    this . response ,     . NO _ HINTS )  ;", "assertEquals ( defaultContentType ,    this . response . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals ( defaultContentType ,    this . mediaTypeCaptor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultMediaType"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "testDefaultMediaType ( null )  ;", "testDefaultMediaType ( new   MediaType (  \" text \"  ,     \"  *  \"  )  )  ;", "testDefaultMediaType ( new   MediaType (  \"  *  \"  ,     \"  *  \"  )  )  ;", "testDefaultMediaType ( MediaType . APPLICATION _ OCTET _ STREAM )  ;", "}", "METHOD_END"], "methodName": ["useDefaultMediaType"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageWriter < String >    writer    =    getWriter ( EncoderHttpMessageWriterTests . TEXT _ PLAIN _ UTF _  8  ,    MediaType . TEXT _ HTML )  ;", "writer . write ( Mono . just (  \" body \"  )  ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ HTML ,    response ,    EncoderHttpMessageWriterTests . NO _ HINTS )  ;", "assertEquals ( new   MediaType (  \" text \"  ,     \" html \"  ,    StandardCharsets . UTF _  8  )  ,    this . response . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals ( new   MediaType (  \" text \"  ,     \" html \"  ,    StandardCharsets . UTF _  8  )  ,    this . mediaTypeCaptor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["useDefaultMediaTypeCharset"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   outputMessageMediaType    =    MediaType . TEXT _ HTML ;", "this . response . getHeaders (  )  . setContentType ( outputMessageMediaType )  ;", "HttpMessageWriter < String >    writer    =    getWriter (  . TEXT _ PLAIN _ UTF _  8  ,    MediaType . TEXT _ HTML )  ;", "writer . write ( Mono . just (  \" body \"  )  ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ PLAIN ,    this . response ,     . NO _ HINTS )  ;", "assertEquals ( outputMessageMediaType ,    this . response . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals ( outputMessageMediaType ,    this . mediaTypeCaptor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["useHttpOutputMessageMediaType"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageWriter < String >    writer    =    getWriter ( ALL )  ;", "writer . write ( Mono . just (  \" body \"  )  ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ PLAIN ,    this . response ,     . NO _ HINTS )  ;", "assertEquals ( MediaType . TEXT _ PLAIN ,    response . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals ( MediaType . TEXT _ PLAIN ,    this . mediaTypeCaptor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["useNegotiatedMediaType"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   negotiatedMediaType    =    new   MediaType (  \" text \"  ,     \" html \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  ;", "HttpMessageWriter < String >    writer    =    getWriter (  . TEXT _ PLAIN _ UTF _  8  ,    MediaType . TEXT _ HTML )  ;", "writer . write ( Mono . just (  \" body \"  )  ,    ResolvableType . forClass ( String . class )  ,    negotiatedMediaType ,    this . response ,     . NO _ HINTS )  ;", "assertEquals ( negotiatedMediaType ,    this . response . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals ( negotiatedMediaType ,    this . mediaTypeCaptor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["useNegotiatedMediaTypeCharset"], "fileName": "org.springframework.http.codec.EncoderHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultCharset ;", "}", "METHOD_END"], "methodName": ["getDefaultCharset"], "fileName": "org.springframework.http.codec.FormHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mediaType    !  =    null )     &  &     (  ( mediaType . getCharset (  )  )     !  =    null )  )     {", "return   mediaType . getCharset (  )  ;", "} else    {", "return   getDefaultCharset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getMediaTypeCharset"], "fileName": "org.springframework.http.codec.FormHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "String [  ]    pairs    =    StringUtils . tokenizeToStringArray ( body ,     \"  &  \"  )  ;", "MultiValueMap < String ,    String >    result    =    new   util . LinkedMultiValueMap ( pairs . length )  ;", "try    {", "for    ( String   pair    :    pairs )     {", "int   idx    =    pair . indexOf (  '  =  '  )  ;", "if    ( idx    =  =     (  -  1  )  )     {", "result . add ( URLDecoder . decode ( pair ,    charset . name (  )  )  ,    null )  ;", "} else    {", "String   name    =    URLDecoder . decode ( pair . substring (  0  ,    idx )  ,    charset . name (  )  )  ;", "String   value    =    URLDecoder . decode ( pair . substring (  ( idx    +     1  )  )  ,    charset . name (  )  )  ;", "result . add ( name ,    value )  ;", "}", "}", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseFormData"], "fileName": "org.springframework.http.codec.FormHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( charset ,     \" Charset   must   not   be   null \"  )  ;", "this . defaultCharset    =    charset ;", "}", "METHOD_END"], "methodName": ["setDefaultCharset"], "fileName": "org.springframework.http.codec.FormHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . reader . canRead ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    String . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "assertTrue ( this . reader . canRead ( ResolvableType . forInstance ( new   util . LinkedMultiValueMap < String ,    String >  (  )  )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "assertFalse ( this . reader . canRead ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Object . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "assertFalse ( this . reader . canRead ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    Object . class ,    String . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "assertFalse ( this . reader . canRead ( ResolvableType . forClassWithGenerics ( Map . class ,    String . class ,    String . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "assertFalse ( this . reader . canRead ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    String . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.codec.FormHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  ;", "MockServerHttpRequest   request    =    request ( body )  ;", "MultiValueMap < String ,    String >    result    =    this . r . read ( null ,    request ,    null )  . single (  )  . block (  )  ;", "assertEquals (  \" Invalid   result \"  ,     3  ,    result . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    1  \"  ,    result . getFirst (  \" name    1  \"  )  )  ;", "List < String >    values    =    result . get (  \" name    2  \"  )  ;", "assertEquals (  \" Invalid   result \"  ,     2  ,    values . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    2  +  1  \"  ,    values . get (  0  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    2  +  2  \"  ,    values . get (  1  )  )  ;", "assertNull (  \" Invalid   result \"  ,    result . getFirst (  \" name    3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readFormAsFlux"], "fileName": "org.springframework.http.codec.FormHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  ;", "MockServerHttpRequest   request    =    request ( body )  ;", "MultiValueMap < String ,    String >    result    =    this . r . readMono ( null ,    request ,    null )  . block (  )  ;", "assertEquals (  \" Invalid   result \"  ,     3  ,    result . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    1  \"  ,    result . getFirst (  \" name    1  \"  )  )  ;", "List < String >    values    =    result . get (  \" name    2  \"  )  ;", "assertEquals (  \" Invalid   result \"  ,     2  ,    values . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    2  +  1  \"  ,    values . get (  0  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    2  +  2  \"  ,    values . get (  1  )  )  ;", "assertNull (  \" Invalid   result \"  ,    result . getFirst (  \" name    3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readFormAsMono"], "fileName": "org.springframework.http.codec.FormHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HttpMethod . GET ,     \"  /  \"  )  . header ( HttpHeaders . CONTENT _ TYPE ,    MediaType . APPLICATION _ FORM _ URLENCODED _ VALUE )  . body ( body )  ;", "}", "METHOD_END"], "methodName": ["request"], "fileName": "org.springframework.http.codec.FormHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultCharset ;", "}", "METHOD_END"], "methodName": ["getDefaultCharset"], "fileName": "org.springframework.http.codec.FormHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mediaType    !  =    null )     &  &     (  ( mediaType . getCharset (  )  )     !  =    null )  )     {", "return   mediaType . getCharset (  )  ;", "} else    {", "return   getDefaultCharset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getMediaTypeCharset"], "fileName": "org.springframework.http.codec.FormHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "try    {", "for    ( Iterator < String >    names    =    form . keySet (  )  . iterator (  )  ;    names . hasNext (  )  ;  )     {", "String   name    =    names . next (  )  ;", "for    ( Iterator <  ?  >    values    =    form . get ( name )  . iterator (  )  ;    values . hasNext (  )  ;  )     {", "Object   rawValue    =    values . next (  )  ;", "builder . append ( URLEncoder . encode ( name ,    charset . name (  )  )  )  ;", "if    ( rawValue    !  =    null )     {", "builder . append (  '  =  '  )  ;", "Assert . isInstanceOf ( String . class ,    rawValue ,     (  \"    supports   String   values   only .     \"     +     \" Use   MultipartHttpMessageWriter   for   multipart   requests .  \"  )  )  ;", "builder . append ( URLEncoder . encode (  (  ( String )     ( rawValue )  )  ,    charset . name (  )  )  )  ;", "if    ( values . hasNext (  )  )     {", "builder . append (  '  &  '  )  ;", "}", "}", "}", "if    ( names . hasNext (  )  )     {", "builder . append (  '  &  '  )  ;", "}", "}", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["serializeForm"], "fileName": "org.springframework.http.codec.FormHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( charset ,     \" Charset   must   not   be   null \"  )  ;", "this . defaultCharset    =    charset ;", "}", "METHOD_END"], "methodName": ["setDefaultCharset"], "fileName": "org.springframework.http.codec.FormHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    String . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "assertTrue ( this . writer . canWrite ( ResolvableType . forInstance ( new   util . LinkedMultiValueMap < String ,    String >  (  )  )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "assertFalse ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Object . class )  ,    null )  )  ;", "assertFalse ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    Object . class ,    String . class )  ,    null )  )  ;", "assertFalse ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( Map . class ,    String . class ,    String . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "assertFalse ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    String . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.codec.FormHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    body    =    new   LinkedMultiValueMap (  )  ;", "body . set (  \" name    1  \"  ,     \" value    1  \"  )  ;", "body . add (  \" name    2  \"  ,     \" value    2  +  1  \"  )  ;", "body . add (  \" name    2  \"  ,     \" value    2  +  2  \"  )  ;", "body . add (  \" name    3  \"  ,    null )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "this . writer . write ( Mono . just ( body )  ,    null ,    MediaType . APPLICATION _ FORM _ URLENCODED ,    response ,    null )  . block (  )  ;", "String   responseBody    =    response . getBodyAsString (  )  . block (  )  ;", "assertEquals (  \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  ,    responseBody )  ;", "HttpHeaders   headers    =    response . getHeaders (  )  ;", "assertEquals (  \" application / x - www - form - urlencoded ; charset = UTF -  8  \"  ,    headers . getContentType (  )  . toString (  )  )  ;", "assertEquals ( responseBody . getBytes (  )  . length ,    headers . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeForm"], "fileName": "org.springframework.http.codec.FormHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getEncodeHints"], "fileName": "org.springframework.http.codec.HttpMessageEncoder"}, {"methodBody": ["METHOD_START", "{", "return   read ( elementType ,    request ,    hints )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.codec.HttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "return   readMono ( elementType ,    request ,    hints )  ;", "}", "METHOD_END"], "methodName": ["readMono"], "fileName": "org.springframework.http.codec.HttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "return   write ( inputStream ,    elementType ,    mediaType ,    response ,    hints )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.codec.HttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return   this . bar ;", "}", "METHOD_END"], "methodName": ["getBar"], "fileName": "org.springframework.http.codec.Pojo"}, {"methodBody": ["METHOD_START", "{", "return   this . foo ;", "}", "METHOD_END"], "methodName": ["getFoo"], "fileName": "org.springframework.http.codec.Pojo"}, {"methodBody": ["METHOD_START", "{", "this . bar    =    bar ;", "}", "METHOD_END"], "methodName": ["setBar"], "fileName": "org.springframework.http.codec.Pojo"}, {"methodBody": ["METHOD_START", "{", "this . foo    =    foo ;", "}", "METHOD_END"], "methodName": ["setFoo"], "fileName": "org.springframework.http.codec.Pojo"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    body    =    this . regionEncoder . encode ( publisher ,    message . bufferFactory (  )  ,    ResourceHttpMessageWriter . REGION _ TYPE ,    mediaType ,    hints )  ;", "return   message . writeWith ( body )  ;", "}", "METHOD_END"], "methodName": ["encodeAndWriteRegions"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( mediaType    !  =    null )     &  &     ( mediaType . isConcrete (  )  )  )     &  &     (  !  ( mediaType . equals ( MediaType . APPLICATION _ OCTET _ STREAM )  )  )  )     {", "return   mediaType ;", "}", "return   MediaTypeFactory . getMediaType ( r )  . orElse ( MediaType . APPLICATION _ OCTET _ STREAM )  ;", "}", "METHOD_END"], "methodName": ["getResourceMediaType"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    message . getHeaders (  )  ;", "MediaType   resourceMediaType    =     . getResourceMediaType ( mediaType ,    resource )  ;", "headers . setContentType ( resourceMediaType )  ;", "if    (  ( headers . getContentLength (  )  )     <     0  )     {", "Long   contentLength    =    this . encoder . getContentLength ( resource ,    mediaType )  ;", "if    ( contentLength    !  =    null )     {", "headers . setContentLength ( contentLength )  ;", "}", "}", "return    . zeroCopy ( resource ,    null ,    message )  . orElseGet (  (  )     -  >     {", "Mono < Resource >    input    =    reactor . core . publisher . Mono . just ( resource )  ;", "DataBufferFactory   factory    =    message . bufferFactory (  )  ;", "Flux < DataBuffer >    body    =    this . encoder . encode ( input ,    factory ,    type ,    resourceMediaType ,    hints )  ;", "return   message . writeWith ( body )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["writeResource"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return   ResourceHttpMessageWriter . zeroCopy ( region . getResource (  )  ,    region ,    message )  . orElseGet (  (  )     -  >     {", "Publisher <  ?    extends   ResourceRegion >    input    =    Mono . just ( region )  ;", "MediaType   mediaType    =    message . getHeaders (  )  . getContentType (  )  ;", "return   encodeAndWriteRegions ( input ,    mediaType ,    message ,    emptyMap (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["writeSingleRegion"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( message   instanceof   ZeroCopyHttpOutputMessage )     &  &     ( resource . isFile (  )  )  )     {", "try    {", "File   file    =    resource . getFile (  )  ;", "long   pos    =     ( region    !  =    null )     ?    region . getPosition (  )     :     0  ;", "long   count    =     ( region    !  =    null )     ?    region . getCount (  )     :    file . length (  )  ;", "return   Optional . of (  (  ( ZeroCopyHttpOutputMessage )     ( message )  )  . writeWith ( file ,    pos ,    count )  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "return   Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["zeroCopy"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . writer . getWritableMediaTypes (  )  ,    containsInAnyOrder ( APPLICATION _ OCTET _ STREAM ,    ALL )  )  ;", "}", "METHOD_END"], "methodName": ["getWritableMediaTypes"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "testWrite ( MockServerHttpRequest . get (  \"  /  \"  )  . header ( HttpHeaders . RANGE ,     \" invalid \"  )  . build (  )  )  ;", "assertThat ( this . response . getHeaders (  )  . getFirst ( HttpHeaders . ACCEPT _ RANGES )  ,    is (  \" bytes \"  )  )  ;", "assertThat ( this . response . getStatusCode (  )  ,    is ( HttpStatus . REQUESTED _ RANGE _ NOT _ SATISFIABLE )  )  ;", "}", "METHOD_END"], "methodName": ["invalidRange"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "return   HttpRange . createByteRange ( first ,    last )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Void >    mono    =    this . writer . write ( this . input ,    null ,    null ,    MediaType . TEXT _ PLAIN ,    request ,    this . response ,    ResourceHttpMessageWriterTests . HINTS )  ;", "StepVerifier . create ( mono )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["testWrite"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "testWrite ( MockServerHttpRequest . get (  \"  /  \"  )  . range ( ResourceHttpMessageWriterTests . of (  0  ,     5  )  ,    ResourceHttpMessageWriterTests . of (  7  ,     1  5  )  ,    ResourceHttpMessageWriterTests . of (  1  7  ,     2  0  )  ,    ResourceHttpMessageWriterTests . of (  2  2  ,     3  8  )  )  . build (  )  )  ;", "HttpHeaders   headers    =    this . response . getHeaders (  )  ;", "String   contentType    =    headers . getContentType (  )  . toString (  )  ;", "String   boundary    =    contentType . substring (  3  0  )  ;", "assertThat ( contentType ,    startsWith (  \" multipart / byteranges ; boundary =  \"  )  )  ;", "StepVerifier . create ( this . response . getBodyAsString (  )  )  . consumeNextWith (  (    content )     -  >     {", "String [  ]    actualRanges    =    StringUtils . tokenizeToStringArray ( content ,     \"  \\ r \\ n \"  ,    false ,    true )  ;", "String [  ]    expected    =    new   String [  ]  {     \"  -  -  \"     +    boundary ,     \" Content - Type :    text / plain \"  ,     \" Content - Range :    bytes    0  -  5  /  3  9  \"  ,     \" Spring \"  ,     \"  -  -  \"     +    boundary ,     \" Content - Type :    text / plain \"  ,     \" Content - Range :    bytes    7  -  1  5  /  3  9  \"  ,     \" Framework \"  ,     \"  -  -  \"     +    boundary ,     \" Content - Type :    text / plain \"  ,     \" Content - Range :    bytes    1  7  -  2  0  /  3  9  \"  ,     \" test \"  ,     \"  -  -  \"     +    boundary ,     \" Content - Type :    text / plain \"  ,     \" Content - Range :    bytes    2  2  -  3  8  /  3  9  \"  ,     \" resource   content .  \"  ,     (  \"  -  -  \"     +    boundary )     +     \"  -  -  \"     }  ;", "assertArrayEquals ( expected ,    actualRanges )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writeMultipleRegions"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "testWrite ( MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  )  ;", "assertThat ( this . response . getHeaders (  )  . getContentType (  )  ,    is ( MediaType . TEXT _ PLAIN )  )  ;", "assertThat ( this . response . getHeaders (  )  . getContentLength (  )  ,    is (  3  9 L )  )  ;", "assertThat ( this . response . getHeaders (  )  . getFirst ( HttpHeaders . ACCEPT _ RANGES )  ,    is (  \" bytes \"  )  )  ;", "String   content    =     \" Spring   F   test   resource   content .  \"  ;", "StepVerifier . create ( this . response . getBodyAsString (  )  )  . expectNext ( content )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writeResource"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "testWrite ( MockServerHttpRequest . get (  \"  /  \"  )  . range ( ResourceHttpMessageWriterTests . of (  0  ,     5  )  )  . build (  )  )  ;", "assertThat ( this . response . getHeaders (  )  . getContentType (  )  ,    is ( MediaType . TEXT _ PLAIN )  )  ;", "assertThat ( this . response . getHeaders (  )  . getFirst ( HttpHeaders . CONTENT _ RANGE )  ,    is (  \" bytes    0  -  5  /  3  9  \"  )  )  ;", "assertThat ( this . response . getHeaders (  )  . getContentLength (  )  ,    is (  6 L )  )  ;", "StepVerifier . create ( this . response . getBodyAsString (  )  )  . expectNext (  \" Spring \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writeSingleRegion"], "fileName": "org.springframework.http.codec.ResourceHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "return   CodecConfigurerFactory . create ( ServerCodecConfigurer . class )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.http.codec.ServerCodecConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   new   ServerSentEvent . BuilderImpl <  >  (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.http.codec.ServerSentEvent"}, {"methodBody": ["METHOD_START", "{", "return   new   ServerSentEvent . BuilderImpl <  >  ( data )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.http.codec.ServerSentEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . comment ;", "}", "METHOD_END"], "methodName": ["comment"], "fileName": "org.springframework.http.codec.ServerSentEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . data ;", "}", "METHOD_END"], "methodName": ["data"], "fileName": "org.springframework.http.codec.ServerSentEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . event ;", "}", "METHOD_END"], "methodName": ["event"], "fileName": "org.springframework.http.codec.ServerSentEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["id"], "fileName": "org.springframework.http.codec.ServerSentEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . retry ;", "}", "METHOD_END"], "methodName": ["retry"], "fileName": "org.springframework.http.codec.ServerSentEvent"}, {"methodBody": ["METHOD_START", "{", "ServerSentEvent . Builder < Object >    sseBuilder    =    ServerSentEvent . builder (  )  ;", "StringBuilder   data    =    null ;", "StringBuilder   comment    =    null ;", "for    ( String   line    :    lines )     {", "if    ( line . startsWith (  \" id :  \"  )  )     {", "sseBuilder . id ( line . substring (  3  )  )  ;", "} else", "if    ( line . startsWith (  \" event :  \"  )  )     {", "sseBuilder . event ( line . substring (  6  )  )  ;", "} else", "if    ( line . startsWith (  \" data :  \"  )  )     {", "data    =     ( data    !  =    null )     ?    data    :    new   StringBuilder (  )  ;", "data . append ( line . substring (  5  )  )  . append (  \"  \\ n \"  )  ;", "} else", "if    ( line . startsWith (  \" retry :  \"  )  )     {", "sseBuilder . retry ( ofMillis ( Long . valueOf ( line . substring (  6  )  )  )  )  ;", "} else", "if    ( line . startsWith (  \"  :  \"  )  )     {", "comment    =     ( comment    !  =    null )     ?    comment    :    new   StringBuilder (  )  ;", "comment . append ( line . substring (  1  )  )  . append (  \"  \\ n \"  )  ;", "}", "}", "if    ( comment    !  =    null )     {", "sseBuilder . comment ( comment . toString (  )  . substring (  0  ,     (  ( comment . length (  )  )     -     1  )  )  )  ;", "}", "if    ( data    !  =    null )     {", "return   decodeData ( data . toString (  )  ,    valueType ,    hints )  . map (  (    decodedData )     -  >     {", "sseBuilder . data ( decodedData )  ;", "return   sseBuilder . build (  )  ;", "}  )  ;", "} else    {", "return   Mono . just ( sseBuilder . build (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildEvent"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( String . class )     =  =     ( dataType . resolve (  )  )  )     {", "return   Mono . just ( data . substring (  0  ,     (  ( data . length (  )  )     -     1  )  )  )  ;", "}", "if    (  ( this . decoder )     =  =    null )     {", "return   Mono . error ( new   CodecException (  \" No   SSE   decoder   configured   and   the   data   is   not   String .  \"  )  )  ;", "}", "byte [  ]    bytes    =    data . getBytes ( StandardCharsets . UTF _  8  )  ;", "Mono < DataBuffer >    input    =    Mono . just (  . bufferFactory . wrap ( bytes )  )  ;", "return   this . decoder . decodeToMono ( input ,    dataType ,    MediaType . TEXT _ EVENT _ STREAM ,    hints )  ;", "}", "METHOD_END"], "methodName": ["decodeData"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "return   this . decoder ;", "}", "METHOD_END"], "methodName": ["getDecoder"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    rawClass    =    elementType . getRawClass (  )  ;", "return    ( rawClass    !  =    null )     &  &     (  . class . isAssignableFrom ( rawClass )  )  ;", "}", "METHOD_END"], "methodName": ["isServerSentEvent"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "List < DataBuffer >    results    =    new   ArrayList <  >  (  )  ;", "int   startIdx    =     0  ;", "int   endIdx ;", "final   int   limit    =    dataBuffer . readableByteCount (  )  ;", "do    {", "endIdx    =    dataBuffer . indexOf (  . NEWLINE _ DELIMITER ,    startIdx )  ;", "int   length    =     ( endIdx    !  =     (  -  1  )  )     ?     ( endIdx    -    startIdx )     +     1     :    limit    -    startIdx ;", "DataBuffer   token    =    dataBuffer . slice ( startIdx ,    length )  ;", "results . add ( DataBufferUtils . retain ( token )  )  ;", "startIdx    =    endIdx    +     1  ;", "}    while    (  ( startIdx    <    limit )     &  &     ( endIdx    !  =     (  -  1  )  )     )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "return   Flux . fromIterable ( results )  ;", "}", "METHOD_END"], "methodName": ["splitOnNewline"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( messageReader . canRead ( ResolvableType . forClass ( Object . class )  ,    new   MediaType (  \" text \"  ,     \" event - stream \"  )  )  )  ;", "assertTrue ( messageReader . canRead ( ResolvableType . forClass (  . class )  ,    new   MediaType (  \" foo \"  ,     \" bar \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( messageReader . canRead ( ResolvableType . forClass ( Object . class )  ,    new   MediaType (  \" foo \"  ,     \" bar \"  )  )  )  ;", "assertFalse ( messageReader . canRead ( ResolvableType . forClass ( Object . class )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["cantRead"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" data : foo \\ ndata : bar \\ n \\ ndata : baz \\ n \\ n \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body ( body )  ;", "String   actual    =    m . readMono ( ResolvableType . forClass ( String . class )  ,    request ,    Collections . emptyMap (  )  )  . cast ( String . class )  . block ( Duration . ZERO )  ;", "assertEquals ( body ,    actual )  ;", "}", "METHOD_END"], "methodName": ["decodeFullContentAsString"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body (  (  \" data :  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \\ n \\ n \"     +     \" data :  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  \\ n \\ n \"  )  )  ;", "Flux < Pojo >    data    =    m . read ( ResolvableType . forClass ( Pojo . class )  ,    request ,    Collections . emptyMap (  )  )  . cast ( Pojo . class )  ;", "StepVerifier . create ( data )  . consumeNextWith (  (    pojo )     -  >     {", "assertEquals (  \" foofoo \"  ,    pojo . getFoo (  )  )  ;", "assertEquals (  \" barbar \"  ,    pojo . getBar (  )  )  ;", "}  )  . consumeNextWith (  (    pojo )     -  >     {", "assertEquals (  \" foofoofoo \"  ,    pojo . getFoo (  )  )  ;", "assertEquals (  \" barbarbar \"  ,    pojo . getBar (  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["readPojo"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body (  (  \" id : c 4  2  \\ nevent : foo \\ nretry :  1  2  3  \\ n : bla \\ n : bla   bla \\ n : bla   bla   bla \\ ndata : bar \\ n \\ n \"     +     \" id : c 4  3  \\ nevent : bar \\ nretry :  4  5  6  \\ ndata : baz \\ n \\ n \"  )  )  ;", "Flux <  >    events    =    this . messageReader . read ( ResolvableType . forClassWithGenerics (  . class ,    String . class )  ,    request ,    Collections . emptyMap (  )  )  . cast (  . class )  ;", "StepVerifier . create ( events )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \" c 4  2  \"  ,    event . id (  )  )  ;", "assertEquals (  \" foo \"  ,    event . event (  )  )  ;", "assertEquals ( Duration . ofMillis (  1  2  3  )  ,    event . retry (  )  )  ;", "assertEquals (  \" bla \\ nbla   bla \\ nbla   bla   bla \"  ,    event . comment (  )  )  ;", "assertEquals (  \" bar \"  ,    event . data (  )  )  ;", "}  )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \" c 4  3  \"  ,    event . id (  )  )  ;", "assertEquals (  \" bar \"  ,    event . event (  )  )  ;", "assertEquals ( Duration . ofMillis (  4  5  6  )  ,    event . retry (  )  )  ;", "assertNull ( event . comment (  )  )  ;", "assertEquals (  \" baz \"  ,    event . data (  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["readServerSentEvents"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body ( Flux . just ( stringBuffer (  \" id : c 4  2  \\ nev \"  )  ,    stringBuffer (  \" ent : foo \\ nretry :  1  2  3  \\ n : bla \\ n : bla   bla \\ n : bla   bla   bla \\ ndata :  \"  )  ,    stringBuffer (  \" bar \\ n \\ nid : c 4  3  \\ nevent : bar \\ nretry :  4  5  6  \\ ndata : baz \\ n \\ n \"  )  )  )  ;", "Flux <  >    events    =    messageReader . read ( ResolvableType . forClassWithGenerics (  . class ,    String . class )  ,    request ,    Collections . emptyMap (  )  )  . cast (  . class )  ;", "StepVerifier . create ( events )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \" c 4  2  \"  ,    event . id (  )  )  ;", "assertEquals (  \" foo \"  ,    event . event (  )  )  ;", "assertEquals ( Duration . ofMillis (  1  2  3  )  ,    event . retry (  )  )  ;", "assertEquals (  \" bla \\ nbla   bla \\ nbla   bla   bla \"  ,    event . comment (  )  )  ;", "assertEquals (  \" bar \"  ,    event . data (  )  )  ;", "}  )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \" c 4  3  \"  ,    event . id (  )  )  ;", "assertEquals (  \" bar \"  ,    event . event (  )  )  ;", "assertEquals ( Duration . ofMillis (  4  5  6  )  ,    event . retry (  )  )  ;", "assertNull ( event . comment (  )  )  ;", "assertEquals (  \" baz \"  ,    event . data (  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["readServerSentEventsWithMultipleChunks"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" data : foo \\ ndata : bar \\ n \\ ndata : baz \\ n \\ n \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body ( body )  ;", "Flux < String >    data    =    m . read ( ResolvableType . forClass ( String . class )  ,    request ,    Collections . emptyMap (  )  )  . cast ( String . class )  ;", "StepVerifier . create ( data )  . expectNextMatches (  (    elem )     -  >    elem . equals (  \" foo \\ nbar \"  )  )  . expectNextMatches (  (    elem )     -  >    elem . equals (  \" baz \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    elementClass    =    elementType . getRawClass (  )  ;", "ResolvableType   valueType    =     (  ( elementClass    !  =    null )     &  &     (  . class . isAssignableFrom ( elementClass )  )  )     ?    elementType . getGeneric (  )     :    elementType ;", "return   Flux . from ( input )  . map (  (    element )     -  >     {", "<  ?  >    sse    =     ( element   instanceof    )     ?     (  (  <  ?  >  )     ( element )  )     :     . builder (  )  . data ( element )  . build (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "String   id    =    sse . id (  )  ;", "String   event    =    sse . event (  )  ;", "Duration   retry    =    sse . retry (  )  ;", "String   comment    =    sse . comment (  )  ;", "Object   data    =    sse . data (  )  ;", "if    ( id    !  =    null )     {", "writeField (  \" id \"  ,    id ,    sb )  ;", "}", "if    ( event    !  =    null )     {", "writeField (  \" event \"  ,    event ,    sb )  ;", "}", "if    ( retry    !  =    null )     {", "writeField (  \" retry \"  ,    retry . toMillis (  )  ,    sb )  ;", "}", "if    ( comment    !  =    null )     {", "sb . append (  '  :  '  )  . append ( comment . replaceAll (  \"  \\  \\ n \"  ,     \"  \\ n :  \"  )  )  . append (  \"  \\ n \"  )  ;", "}", "if    ( data    !  =    null )     {", "sb . append (  \" data :  \"  )  ;", "}", "return   Flux . concat ( encodeText ( sb ,    mediaType ,    factory )  ,    encodeData ( data ,    valueType ,    mediaType ,    factory ,    hints )  ,    encodeText (  \"  \\ n \"  ,    mediaType ,    factory )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( data    =  =    null )     {", "return   Flux . empty (  )  ;", "}", "if    ( data   instanceof   St )     {", "St   text    =     (  ( St )     ( data )  )  ;", "return   Flux . from ( encodeText (  (  ( text . replaceAll (  \"  \\  \\ n \"  ,     \"  \\ ndata :  \"  )  )     +     \"  \\ n \"  )  ,    mediaType ,    factory )  )  ;", "}", "if    (  ( this . encoder )     =  =    null )     {", "return   Flux . error ( new   CodecException (  \" No   SSE   encoder   configured   and   the   data   is   not   St .  \"  )  )  ;", "}", "return    (  ( Encoder < T >  )     ( this . encoder )  )  . encode ( Mono . just ( data )  ,    factory ,    valueType ,    mediaType ,    hints )  . concatWith ( encodeText (  \"  \\ n \"  ,    mediaType ,    factory )  )  ;", "}", "METHOD_END"], "methodName": ["encodeData"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mediaType . getCharset (  )  ,     \" Expected   MediaType   with   charset \"  )  ;", "byte [  ]    bytes    =    text . toSt (  )  . getBytes ( mediaType . getCharset (  )  )  ;", "DataBuffer   buffer    =    bufferFactory . allocateBuffer ( bytes . length )  . write ( bytes )  ;", "return   Mono . just ( buffer )  ;", "}", "METHOD_END"], "methodName": ["encodeText"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . encoder )    instanceof   HttpMessageEncoder )     {", "HttpMessageEncoder <  ?  >    httpEncoder    =     (  ( HttpMessageEncoder <  ?  >  )     ( this . encoder )  )  ;", "return   httpEncoder . getEncodeHints ( actualType ,    elementType ,    mediaType ,    request ,    response )  ;", "}", "return   Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getEncodeHints"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return   this . encoder ;", "}", "METHOD_END"], "methodName": ["getEncoder"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "stringBuilder . append ( fieldName )  ;", "stringBuilder . append (  '  :  '  )  ;", "stringBuilder . append ( fieldValue . toString (  )  )  ;", "stringBuilder . append (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["writeField"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . messageWriter . canWrite ( forClass ( Object . class )  ,    null )  )  ;", "assertFalse ( this . messageWriter . canWrite ( forClass ( Object . class )  ,    new   MediaType (  \" foo \"  ,     \" bar \"  )  )  )  ;", "assertTrue ( this . messageWriter . canWrite ( null ,    MediaType . TEXT _ EVENT _ STREAM )  )  ;", "assertTrue ( this . messageWriter . canWrite ( forClass (  . class )  ,    new   MediaType (  \" foo \"  ,     \" bar \"  )  )  )  ;", "assertTrue ( this . messageWriter . canWrite ( NONE ,    MediaType . TEXT _ EVENT _ STREAM )  )  ;", "assertFalse ( this . messageWriter . canWrite ( NONE ,    new   MediaType (  \" foo \"  ,     \" bar \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "this . messageWriter . write ( source ,    forClass ( clazz )  ,    mediaType ,    response ,    ServerSentEventHttpMessageWriterTests . HINTS )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testWrite"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "testWrite ( source ,    MediaType . TEXT _ EVENT _ STREAM ,    response ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["testWrite"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    source    =    Flux . just (  \" foo \\ nbar \"  ,     \" foo \\ nbaz \"  )  ;", "MockServerHttpResponse   output    =    new   MockServerHttpResponse (  )  ;", "testWrite ( source ,    output ,    String . class )  ;", "StepVerifier . create ( output . getBodyAsString (  )  )  . expectNext (  \" data : foo \\ ndata : bar \\ n \\ ndata : foo \\ ndata : baz \\ n \\ n \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writeMultiLineString"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  ,    new   Pojo (  \" foofoofoo \"  ,     \" barbarbar \"  )  )  ;", "MockServerHttpResponse   output    =    new   MockServerHttpResponse (  )  ;", "testWrite ( source ,    output ,    Pojo . class )  ;", "StepVerifier . create ( output . getBodyAsString (  )  )  . expectNext (  (  \" data :  {  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  }  \\ n \\ n \"     +     \" data :  {  \\  \" foo \\  \"  :  \\  \" foofoofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbarbar \\  \"  }  \\ n \\ n \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writePojo"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foo \\ ud 8  3  4  \\ udd 1 e \"  ,     \" bar \\ ud 8  3  4  \\ udd 1 e \"  )  )  ;", "Charset   charset    =    StandardCharsets . UTF _  1  6 LE ;", "MediaType   mediaType    =    new   MediaType (  \" text \"  ,     \" event - stream \"  ,    charset )  ;", "MockServerHttpResponse   output    =    new   MockServerHttpResponse (  )  ;", "testWrite ( source ,    mediaType ,    output ,    Pojo . class )  ;", "assertEquals ( mediaType ,    output . getHeaders (  )  . getContentType (  )  )  ;", "StepVerifier . create ( output . getBodyAsString (  )  )  . expectNext (  \" data :  {  \\  \" foo \\  \"  :  \\  \" foo \\ ud 8  3  4  \\ udd 1 e \\  \"  ,  \\  \" bar \\  \"  :  \\  \" bar \\ ud 8  3  4  \\ udd 1 e \\  \"  }  \\ n \\ n \"  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["writePojoWithCustomEncoding"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   mapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . indentOutput ( true )  . build (  )  ;", "this . messageWriter    =    new    ( new   Jackson 2 JsonEncoder ( mapper )  )  ;", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  ,    new   Pojo (  \" foofoofoo \"  ,     \" barbarbar \"  )  )  ;", "MockServerHttpResponse   outputMessage    =    new   MockServerHttpResponse (  )  ;", "testWrite ( source ,    outputMessage ,    Pojo . class )  ;", "StepVerifier . create ( outputMessage . getBodyAsString (  )  )  . expectNext (  (  \" data :  {  \\ n \"     +     (  (  (  (  (  (  \" data :        \\  \" foo \\  \"     :     \\  \" foofoo \\  \"  ,  \\ n \"     +     \" data :        \\  \" bar \\  \"     :     \\  \" barbar \\  \"  \\ n \"  )     +     \" data :  }  \\ n \\ n \"  )     +     \" data :  {  \\ n \"  )     +     \" data :        \\  \" foo \\  \"     :     \\  \" foofoofoo \\  \"  ,  \\ n \"  )     +     \" data :        \\  \" bar \\  \"     :     \\  \" barbarbar \\  \"  \\ n \"  )     +     \" data :  }  \\ n \\ n \"  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writePojoWithPrettyPrint"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "ServerSentEvent <  ?  >    event    =    ServerSentEvent . builder (  )  . data (  \" bar \"  )  . id (  \" c 4  2  \"  )  . event (  \" foo \"  )  . comment (  \" bla \\ nbla   bla \\ nbla   bla   bla \"  )  . retry ( Duration . ofMillis (  1  2  3 L )  )  . build (  )  ;", "Mono < ServerSentEvent >    source    =    Mono . just ( event )  ;", "MockServerHttpResponse   outputMessage    =    new   MockServerHttpResponse (  )  ;", "testWrite ( source ,    outputMessage ,    ServerSentEvent . class )  ;", "StepVerifier . create ( outputMessage . getBodyAsString (  )  )  . expectNext (  \" id : c 4  2  \\ nevent : foo \\ nretry :  1  2  3  \\ n : bla \\ n : bla   bla \\ n : bla   bla   bla \\ ndata : bar \\ n \\ n \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writeServerSentEvent"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    source    =    Flux . just (  \" foo \"  ,     \" bar \"  )  ;", "MockServerHttpResponse   output    =    new   MockServerHttpResponse (  )  ;", "testWrite ( source ,    output ,    String . class )  ;", "StepVerifier . create ( output . getBodyAsString (  )  )  . expectNext (  \" data : foo \\ n \\ ndata : bar \\ n \\ n \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    source    =    Flux . just (  \"  \\ u 0  0 a 3  \"  )  ;", "Charset   charset    =    StandardCharsets . ISO _  8  8  5  9  _  1  ;", "MediaType   mediaType    =    new   MediaType (  \" text \"  ,     \" event - stream \"  ,    charset )  ;", "MockServerHttpResponse   output    =    new   MockServerHttpResponse (  )  ;", "testWrite ( source ,    mediaType ,    output ,    String . class )  ;", "assertEquals ( mediaType ,    output . getHeaders (  )  . getContentType (  )  )  ;", "StepVerifier . create ( output . getBodyAsString (  )  )  . expectNext (  \" data :  \\ u 0  0 a 3  \\ n \\ n \"  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["writeStringWithCustomCharset"], "fileName": "org.springframework.http.codec.ServerSentEventHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( tokens ,     \"  ' tokens '    must   not   be   null \"  )  ;", "Assert . notNull ( elementType ,     \"  ' elementType '    must   not   be   null \"  )  ;", "MethodParameter   param    =    getParameter ( elementType )  ;", "Class <  ?  >    contextClass    =     ( param    !  =    null )     ?    param . getContainingClass (  )     :    null ;", "JavaType   javaType    =    getJavaType ( elementType . getType (  )  ,    contextClass )  ;", "Class <  ?  >    jsonView    =     ( hints    !  =    null )     ?     (  ( Class <  ?  >  )     ( hints . get ( CodecSupport . JSON _ VIEW _ HINT )  )  )     :    null ;", "ObjectReader   reader    =     ( jsonView    !  =    null )     ?    getObjectMapper (  )  . readerWithView ( jsonView )  . forType ( javaType )     :    getObjectMapper (  )  . readerFor ( javaType )  ;", "return   tokens . map (  (    tokenBuffer )     -  >     {", "try    {", "return   reader . readValue ( tokenBuffer . asParser ( getObjectMapper (  )  )  )  ;", "}    catch    (    ex )     {", "throw   new    < ex > CodecException (  (  \" Type   definition   error :     \"     +     ( ex . getType (  )  )  )  )  ;", "}    catch    (    ex )     {", "throw   new    < ex > DecodingException (  (  \" JSON   decoding   error :     \"     +     ( ex . getOriginalMessage (  )  )  )  )  ;", "}    catch    (    ex )     {", "throw   new    < ex > DecodingException (  \" I / O   error   while   parsing   input   stream \"  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["decodeInternal"], "fileName": "org.springframework.http.codec.json.AbstractJackson2Decoder"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    inputFlux    =    Flux . from ( input )  ;", "JsonFactory   factory    =    getObjectMapper (  )  . getFactory (  )  ;", "return   Tokenizer . tokenize ( inputFlux ,    factory ,    tokenizeArrayElements )  ;", "}", "METHOD_END"], "methodName": ["tokenize"], "fileName": "org.springframework.http.codec.json.AbstractJackson2Decoder"}, {"methodBody": ["METHOD_START", "{", "return   writer ;", "}", "METHOD_END"], "methodName": ["customizeWriter"], "fileName": "org.springframework.http.codec.json.AbstractJackson2Encoder"}, {"methodBody": ["METHOD_START", "{", "JavaType   javaType    =    getJavaType ( elementType . getType (  )  ,    null )  ;", "Class <  ?  >    jsonView    =     ( hints    !  =    null )     ?     (  ( Class <  ?  >  )     ( hints . get ( CodecSupport . JSON _ VIEW _ HINT )  )  )     :    null ;", "ObjectWriter   writer    =     ( jsonView    !  =    null )     ?    getObjectMapper (  )  . writerWithView ( jsonView )     :    getObjectMapper (  )  . writer (  )  ;", "if    ( isContainerType (  )  )     {", "writer    =    writer . forType ( javaType )  ;", "}", "writer    =    customizeWriter ( writer ,    mimeType ,    elementType ,    hints )  ;", "DataBuffer   buffer    =    bufferFactory . allocateBuffer (  )  ;", "OutputStream   outputStream    =    buffer . asOutputStream (  )  ;", "try    {", "JsonGenerator   generator    =    getObjectMapper (  )  . getFactory (  )  . createGenerator ( outputStream ,    encoding )  ;", "writer . writeValue ( generator ,    value )  ;", "}    catch    ( InvalidDefinitionException   ex )     {", "throw   new   CodecException (  (  \" Type   definition   error :     \"     +     ( ex . getType (  )  )  )  ,    ex )  ;", "}    catch    ( JsonProcessingException   ex )     {", "throw   new   EncodingException (  (  \" JSON   encoding   error :     \"     +     ( ex . getOriginalMessage (  )  )  )  ,    ex )  ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  \" Unexpected   I / O   error   while   writing   to   data   buffer \"  ,    ex )  ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["encodeValue"], "fileName": "org.springframework.http.codec.json.AbstractJackson2Encoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mimeType    !  =    null )     &  &     (  ( mimeType . getCharset (  )  )     !  =    null )  )     {", "Charset   charset    =    mimeType . getCharset (  )  ;", "for    ( Jsoning   encoding    :    Jsoning . values (  )  )     {", "if    ( charset . name (  )  . equals ( encoding . getJavaName (  )  )  )     {", "return   encoding ;", "}", "}", "}", "return   Jsoning . UTF 8  ;", "}", "METHOD_END"], "methodName": ["getJsonEncoding"], "fileName": "org.springframework.http.codec.json.AbstractJackson2Encoder"}, {"methodBody": ["METHOD_START", "{", "this . streamingMediaTypes . clear (  )  ;", "this . streamingMediaTypes . addAll ( mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["setStreamingMediaTypes"], "fileName": "org.springframework.http.codec.json.AbstractJackson2Encoder"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    getParameter ( resolvableType )  ;", "if    ( param    !  =    null )     {", "JsonView   annotation    =    getAnnotation ( param ,    JsonView . class )  ;", "if    ( annotation    !  =    null )     {", "Class <  ?  >  [  ]    classes    =    annotation . value (  )  ;", "Assert . isTrue (  (  ( classes . length )     =  =     1  )  ,     (  (  . JSON _ VIEW _ HINT _ ERROR )     +    param )  )  ;", "return   Collections . singletonMap (  . JSON _ VIEW _ HINT ,    classes [  0  ]  )  ;", "}", "}", "return   Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getHints"], "fileName": "org.springframework.http.codec.json.Jackson2CodecSupport"}, {"methodBody": ["METHOD_START", "{", "TypeFactory   typeFactory    =    this . objectMapper . getTypeFactory (  )  ;", "return   typeFactorynstructType ( GenericTypeResolver . resolveType ( type , ntextClass )  )  ;", "}", "METHOD_END"], "methodName": ["getJavaType"], "fileName": "org.springframework.http.codec.json.Jackson2CodecSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . mimeTypes ;", "}", "METHOD_END"], "methodName": ["getMimeTypes"], "fileName": "org.springframework.http.codec.json.Jackson2CodecSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . objectMapper ;", "}", "METHOD_END"], "methodName": ["getObjectMapper"], "fileName": "org.springframework.http.codec.json.Jackson2CodecSupport"}, {"methodBody": ["METHOD_START", "{", "return    ( type . getSource (  )  )    instanceof   MethodParameter    ?     (  ( MethodParameter )     ( type . getSource (  )  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.springframework.http.codec.json.Jackson2CodecSupport"}, {"methodBody": ["METHOD_START", "{", "return    ( mimeType    =  =    null )     |  |     ( this . mimeTypes . stream (  )  . anyMatch (  (    m )     -  >    m . isCompatibleWith ( mimeType )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsMimeType"], "fileName": "org.springframework.http.codec.json.Jackson2CodecSupport"}, {"methodBody": ["METHOD_START", "{", "Jackson 2 JsonDecoder   decoder    =    new   Jackson 2 JsonDecoder (  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ JSON )  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ JSON _ UTF 8  )  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ STREAM _ JSON )  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    null )  )  ;", "assertFalse ( decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    null )  )  ;", "assertFalse ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ XML )  )  ;", "}", "METHOD_END"], "methodName": ["canDecode"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   textJavascript    =    new   MimeType (  \" text \"  ,     \" javascript \"  ,    StandardCharsets . UTF _  8  )  ;", "decoder    =    new    ( new   ObjectMapper (  )  ,    textJavascript )  ;", "assertEquals ( Collections . singletonList ( textJavascript )  ,    decoder . getDecodableMimeTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["canDecodeWithProvidedMimeType"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  {  \\  \" withView 1  \\  \"     :     \\  \" with \\  \"  ,     \\  \" withView 2  \\  \"     :     \\  \" with \\  \"  ,     \\  \" withoutView \\  \"     :     \\  \" without \\  \"  }  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( JacksonViewBean . class )  ;", "Map < String ,    Object >    hints    =    Collections . singletonMap ( Jackson 2 CodecSupport . JSON _ VIEW _ HINT ,    JacksonViewBean . MyJacksonView 3  . class )  ;", "Flux < JacksonViewBean >    flux    =    new    (  )  . decode ( source ,    elementType ,    null ,    hints )  . cast ( JacksonViewBean . class )  ;", "StepVerifier . create ( flux )  . consumeNextWith (  (    b )     -  >     {", "assertNull ( b . getWithView 1  (  )  )  ;", "assertNull ( b . getWithView 2  (  )  )  ;", "assertTrue ( b . getWithoutView (  )  . equals (  \" without \"  )  )  ;", "}  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["classLevelJsonView"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    new   DefaultDataBufferFactory (  )  . wrap (  \"  {  \\  \" test \\  \"  :     1  }  \"  . getBytes (  )  )  ;", "Jackson 2 JsonDecoder   decoder    =    new   Jackson 2 JsonDecoder ( new   ObjectMapper (  )  )  ;", "Flux <  . TestObject >    decoded    =    decoder . decode ( Mono . just ( buffer )  ,    ResolvableType . forClass (  . TestObject . class )  ,    null ,    null )  . cast (  . TestObject . class )  ;", "StepVerifier . create ( decoded )  . assertNext (  (    v )     -  >    assertEquals (  1  ,    v . getTest (  )  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["customDeserializer"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   textJavascript    =    new   MimeType (  \" text \"  ,     \" javascript \"  ,    StandardCharsets . UTF _  8  )  ;", "decoder    =    new    ( new   ObjectMapper (  )  ,    textJavascript )  ;", "decoder . getMimeTypes (  )  . add ( new   MimeType (  \" text \"  ,     \" ecmascript \"  )  )  ;", "}", "METHOD_END"], "methodName": ["decodableMimeTypesIsImmutable"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    new    (  )  . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . expectNext ( new   Pojo (  \" f 1  \"  ,     \" b 1  \"  )  )  . expectNext ( new   Pojo (  \" f 2  \"  ,     \" b 2  \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodeArrayToFlux"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  [  ]  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    new    (  )  . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . expectNextCount (  0  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodeEmptyArrayToFlux"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . empty (  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Mono < Object >    mono    =    new    (  )  . decodeToMono ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodeEmptyBodyToMono"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    new    (  )  . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . expectNext ( new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodePojo"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  {  \\  \" foo \\  \"  :  }  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    new    (  )  . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . verifyError ( CodecException . class )  ;", "}", "METHOD_END"], "methodName": ["decodePojoWithError"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  \"  )  ,    stringBuffer (  \"  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    new    (  )  . decode ( source ,    elementType ,    MediaType . APPLICATION _ STREAM _ JSON ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . expectNext ( new   Pojo (  \" f 1  \"  ,     \" b 1  \"  )  )  . expectNext ( new   Pojo (  \" f 2  \"  ,     \" b 2  \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodeStreamToFlux"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClassWithGenerics ( List . class ,    Pojo . class )  ;", "Mono < Object >    mono    =    new    (  )  . decodeToMono ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( mono )  . expectNext ( Arrays . asList ( new   Pojo (  \" f 1  \"  ,     \" b 1  \"  )  ,    new   Pojo (  \" f 2  \"  ,     \" b 2  \"  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeToList"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  {  \\  \" withView 1  \\  \"     :     \\  \" with \\  \"  ,     \\  \" withView 2  \\  \"     :     \\  \" with \\  \"  ,     \\  \" withoutView \\  \"     :     \\  \" without \\  \"  }  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( JacksonViewBean . class )  ;", "Map < String ,    Object >    hints    =    Collections . singletonMap ( Jackson 2 CodecSupport . JSON _ VIEW _ HINT ,    JacksonViewBean . MyJacksonView 1  . class )  ;", "Flux < JacksonViewBean >    flux    =    new    (  )  . decode ( source ,    elementType ,    null ,    hints )  . cast ( JacksonViewBean . class )  ;", "StepVerifier . create ( flux )  . consumeNextWith (  (    b )     -  >     {", "assertTrue ( b . getWithView 1  (  )  . equals (  \" with \"  )  )  ;", "assertNull ( b . getWithView 2  (  )  )  ;", "assertNull ( b . getWithoutView (  )  )  ;", "}  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["fieldLevelJsonView"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  {  \\  \" foofoo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" barbar \\  \"  :     \\  \" barbar \\  \"  }  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    new    ( new   ObjectMapper (  )  )  . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . verifyErrorMatches (  (    ex )     -  >    ex   instanceof   DecodingException )  ;", "}", "METHOD_END"], "methodName": ["invalidData"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  {  \\  \" property 1  \\  \"  :  \\  \" foo \\  \"  ,  \\  \" property 2  \\  \"  :  \\  \" bar \\  \"  }  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass (  . BeanWithNoDefaultConstructor . class )  ;", "Flux < Object >    flux    =    new   Jackson 2 JsonDecoder (  )  . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . verifyError ( CodecException . class )  ;", "}", "METHOD_END"], "methodName": ["noDefaultConstructor"], "fileName": "org.springframework.http.codec.json.Jackson2JsonDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DefaultPrettyPrinter   printer    =    new   DefaultPrettyPrinter (  )  ;", "printer . indentObjectsWith ( new   DefaultIndenter (  \"        \"  ,     \"  \\ ndata :  \"  )  )  ;", "return   printer ;", "}", "METHOD_END"], "methodName": ["initSsePrettyPrinter"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoder"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   pojoType    =    ResolvableType . forClass ( Pojo . class )  ;", "assertTrue ( this . encoder . ca ( pojoType ,    MediaType . APPLICATION _ JSON )  )  ;", "assertTrue ( this . encoder . ca ( pojoType ,    MediaType . APPLICATION _ JSON _ UTF 8  )  )  ;", "assertTrue ( this . encoder . ca ( pojoType ,    MediaType . APPLICATION _ STREAM _ JSON )  )  ;", "assertTrue ( this . encoder . ca ( pojoType ,    null )  )  ;", "assertTrue ( this . encoder . ca ( NONE ,    null )  )  ;", "assertFalse ( this . encoder . ca ( ResolvableType . forClass ( Object . class )  ,    MediaType . APPLICATION _ OCTET _ STREAM )  )  ;", "}", "METHOD_END"], "methodName": ["canEncode"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   textJavascript    =    new   MimeType (  \" text \"  ,     \" javascript \"  ,    StandardCharsets . UTF _  8  )  ;", "encoder    =    new    ( new   ObjectMapper (  )  ,    textJavascript )  ;", "assertEquals ( Collections . singletonList ( textJavascript )  ,    encoder . getEncodableMimeTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["canEncodeWithCustomMimeType"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    null )  )  ;", "assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ XML )  )  ;", "ResolvableType   sseType    =    ResolvableType . forClass ( ServerSentEvent . class )  ;", "assertFalse ( this . encoder . canEncode ( sseType ,    MediaType . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["canNotEncode"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "JacksonViewBean   bean    =    new   JacksonViewBean (  )  ;", "bean . setWithView 1  (  \" with \"  )  ;", "bean . setWithView 2  (  \" with \"  )  ;", "bean . setWithoutView (  \" without \"  )  ;", "ResolvableType   type    =    ResolvableType . forClass ( JacksonViewBean . class )  ;", "Map < String ,    Object >    hints    =    Collections . singletonMap ( CodecSupport . JSON _ VIEW _ HINT ,    JacksonViewBean . MyJacksonView 3  . class )  ;", "Flux < DataBuffer >    output    =    this . encoder . encode ( Mono . just ( bean )  ,    this . bufferFactory ,    type ,    null ,    hints )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer (  \"  {  \\  \" withoutView \\  \"  :  \\  \" without \\  \"  }  \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["classLevelJsonView"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   textJavascript    =    new   MimeType (  \" text \"  ,     \" javascript \"  ,    StandardCharsets . UTF _  8  )  ;", "encoder    =    new    ( new   ObjectMapper (  )  ,    textJavascript )  ;", "encoder . getMimeTypes (  )  . add ( new   MimeType (  \" text \"  ,     \" ecmascript \"  )  )  ;", "}", "METHOD_END"], "methodName": ["encodableMimeTypesIsImmutable"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foo \"  ,     \" bar \"  )  ,    new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  ,    new   Pojo (  \" foofoofoo \"  ,     \" barbarbar \"  )  )  ;", "ResolvableType   type    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < DataBuffer >    output    =    this . e . encode ( source ,    this . bufferFactory ,    type ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer (  (  \"  [  \"     +     (  (  \"  {  \\  \" foo \\  \"  :  \\  \" foo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" bar \\  \"  }  ,  \"     +     \"  {  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  }  ,  \"  )     +     \"  {  \\  \" foo \\  \"  :  \\  \" foofoofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbarbar \\  \"  }  ]  \"  )  )  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foo \"  ,     \" bar \"  )  ,    new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  ,    new   Pojo (  \" foofoofoo \"  ,     \" barbarbar \"  )  )  ;", "ResolvableType   type    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < DataBuffer >    output    =    this . e . encode ( source ,    this . bufferFactory ,    type ,    MediaType . APPLICATION _ STREAM _ JSON ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer (  \"  {  \\  \" foo \\  \"  :  \\  \" foo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" bar \\  \"  }  \\ n \"  )  )  . consumeNextWith ( stringConsumer (  \"  {  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  }  \\ n \"  )  )  . consumeNextWith ( stringConsumer (  \"  {  \\  \" foo \\  \"  :  \\  \" foofoofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbarbar \\  \"  }  \\ n \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["encodeAsStream"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   fooMediaType    =    new   MediaType (  \" application \"  ,     \" foo \"  )  ;", "MediaType   barMediaType    =    new   MediaType (  \" application \"  ,     \" bar \"  )  ;", "this . e . setStreamingMediaTypes ( Arrays . asList ( fooMediaType ,    barMediaType )  )  ;", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foo \"  ,     \" bar \"  )  ,    new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  ,    new   Pojo (  \" foofoofoo \"  ,     \" barbarbar \"  )  )  ;", "ResolvableType   type    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < DataBuffer >    output    =    this . e . encode ( source ,    this . bufferFactory ,    type ,    barMediaType ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer (  \"  {  \\  \" foo \\  \"  :  \\  \" foo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" bar \\  \"  }  \\ n \"  )  )  . consumeNextWith ( stringConsumer (  \"  {  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  }  \\ n \"  )  )  . consumeNextWith ( stringConsumer (  \"  {  \\  \" foo \\  \"  :  \\  \" foofoofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbarbar \\  \"  }  \\ n \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["encodeAsStreamWithCustomStreamingType"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < Jackson 2 JsonEncoderTests . ParentClass >    source    =    Flux . just ( new   Jackson 2 JsonEncoderTests . Foo (  )  ,    new   Jackson 2 JsonEncoderTests . Bar (  )  )  ;", "ResolvableType   type    =    ResolvableType . forClass ( Jackson 2 JsonEncoderTests . ParentClass . class )  ;", "Flux < DataBuffer >    output    =    this . encoder . encode ( source ,    this . bufferFactory ,    type ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer (  \"  [  {  \\  \" type \\  \"  :  \\  \" foo \\  \"  }  ,  {  \\  \" type \\  \"  :  \\  \" bar \\  \"  }  ]  \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["encodeWithType"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "JacksonViewBean   bean    =    new   JacksonViewBean (  )  ;", "bean . setWithView 1  (  \" with \"  )  ;", "bean . setWithView 2  (  \" with \"  )  ;", "bean . setWithoutView (  \" without \"  )  ;", "ResolvableType   type    =    ResolvableType . forClass ( JacksonViewBean . class )  ;", "Map < String ,    Object >    hints    =    Collections . singletonMap ( CodecSupport . JSON _ VIEW _ HINT ,    JacksonViewBean . MyJacksonView 1  . class )  ;", "Flux < DataBuffer >    output    =    this . encoder . encode ( Mono . just ( bean )  ,    this . bufferFactory ,    type ,    null ,    hints )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer (  \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  }  \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["fieldLevelJsonView"], "fileName": "org.springframework.http.codec.json.Jackson2JsonEncoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    Jackson 2 SmileDecoderTests . SMILE _ MIME _ TYPE )  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    Jackson 2 SmileDecoderTests . STREAM _ SMILE _ MIME _ TYPE )  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    null )  )  ;", "assertFalse ( decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    null )  )  ;", "assertFalse ( decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["canDecode"], "fileName": "org.springframework.http.codec.json.Jackson2SmileDecoderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   mapper    =    Jackson 2 ObjectMapperBuilder . smile (  )  . build (  )  ;", "List < Pojo >    list    =    Arrays . asList ( new   Pojo (  \" f 1  \"  ,     \" b 1  \"  )  ,    new   Pojo (  \" f 2  \"  ,     \" b 2  \"  )  )  ;", "byte [  ]    serializedList    =    mapper . writer (  )  . writeValueAsBytes ( list )  ;", "Flux < DataBuffer >    source    =    Flux . just ( this . bufferFactory . wrap ( serializedList )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    decoder . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . expectNext ( new   Pojo (  \" f 1  \"  ,     \" b 1  \"  )  )  . expectNext ( new   Pojo (  \" f 2  \"  ,     \" b 2  \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodeListToFlux"], "fileName": "org.springframework.http.codec.json.Jackson2SmileDecoderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   mapper    =    Jackson 2 ObjectMapperBuilder . smile (  )  . build (  )  ;", "Pojo   pojo    =    new   Pojo (  \" foo \"  ,     \" bar \"  )  ;", "byte [  ]    serializedPojo    =    mapper . writer (  )  . writeValueAsBytes ( pojo )  ;", "Flux < DataBuffer >    source    =    Flux . just ( this . bufferFactory . wrap ( serializedPojo )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    decoder . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . expectNext ( pojo )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodePojo"], "fileName": "org.springframework.http.codec.json.Jackson2SmileDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  1  2  3  \"  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    d . decode ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . verifyError ( CodecException . class )  ;", "}", "METHOD_END"], "methodName": ["decodePojoWithError"], "fileName": "org.springframework.http.codec.json.Jackson2SmileDecoderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   mapper    =    Jackson 2 ObjectMapperBuilder . smile (  )  . build (  )  ;", "List < Pojo >    list    =    Arrays . asList ( new   Pojo (  \" f 1  \"  ,     \" b 1  \"  )  ,    new   Pojo (  \" f 2  \"  ,     \" b 2  \"  )  )  ;", "byte [  ]    serializedList    =    mapper . writer (  )  . writeValueAsBytes ( list )  ;", "Flux < DataBuffer >    source    =    Flux . just ( this . bufferFactory . wrap ( serializedList )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < Object >    flux    =    decoder . decode ( source ,    elementType ,     . STREAM _ SMILE _ MIME _ TYPE ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( flux )  . expectNext ( new   Pojo (  \" f 1  \"  ,     \" b 1  \"  )  )  . expectNext ( new   Pojo (  \" f 2  \"  ,     \" b 2  \"  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodeStreamToFlux"], "fileName": "org.springframework.http.codec.json.Jackson2SmileDecoderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   mapper    =    Jackson 2 ObjectMapperBuilder . smile (  )  . build (  )  ;", "List < Pojo >    list    =    Arrays . asList ( new   Pojo (  \" f 1  \"  ,     \" b 1  \"  )  ,    new   Pojo (  \" f 2  \"  ,     \" b 2  \"  )  )  ;", "byte [  ]    serializedList    =    mapper . writer (  )  . writeValueAsBytes ( list )  ;", "Flux < DataBuffer >    source    =    Flux . just ( this . bufferFactory . wrap ( serializedList )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClassWithGenerics ( List . class ,    Pojo . class )  ;", "Mono < Object >    mono    =    decoder . decodeToMono ( source ,    elementType ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( mono )  . expectNext ( list )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeToList"], "fileName": "org.springframework.http.codec.json.Jackson2SmileDecoderTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   pojoType    =    ResolvableType . forClass ( Pojo . class )  ;", "assertTrue ( this . encoder . canEncode ( pojoType ,     . SMILE _ MIME _ TYPE )  )  ;", "assertTrue ( this . encoder . canEncode ( pojoType ,     . STREAM _ SMILE _ MIME _ TYPE )  )  ;", "assertTrue ( this . encoder . canEncode ( pojoType ,    null )  )  ;", "assertTrue ( this . encoder . canEncode ( NONE ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canEncode"], "fileName": "org.springframework.http.codec.json.Jackson2SmileEncoderTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    null )  )  ;", "assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ XML )  )  ;", "ResolvableType   sseType    =    ResolvableType . forClass ( ServerSentEvent . class )  ;", "assertFalse ( this . encoder . canEncode ( sseType ,     . SMILE _ MIME _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["canNotEncode"], "fileName": "org.springframework.http.codec.json.Jackson2SmileEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foo \"  ,     \" bar \"  )  ,    new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  ,    new   Pojo (  \" foofoofoo \"  ,     \" barbarbar \"  )  )  ;", "ResolvableType   type    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < DataBuffer >    output    =    this . encoder . encode ( source ,    this . bufferFactory ,    type ,    null ,    Collections . emptyMap (  )  )  ;", "ObjectMapper   mapper    =    ObjectMapperBuilder . smile (  )  . build (  )  ;", "StepVerifier . create ( output )  . consumeNextWith (  (    dataBuffer )     -  >    readPojo ( mapper ,     . class ,    dataBuffer )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.http.codec.json.Jackson2SmileEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foo \"  ,     \" bar \"  )  ,    new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  ,    new   Pojo (  \" foofoofoo \"  ,     \" barbarbar \"  )  )  ;", "ResolvableType   type    =    ResolvableType . forClass ( Pojo . class )  ;", "Flux < DataBuffer >    output    =    this . encoder . encode ( source ,    this . bufferFactory ,    type ,     . STREAM _ SMILE _ MIME _ TYPE ,    Collections . emptyMap (  )  )  ;", "ObjectMapper   mapper    =    Jackson 2 ObjectMapperBuilder . smile (  )  . build (  )  ;", "StepVerifier . create ( output )  . consumeNextWith (  (    dataBuffer )     -  >    readPojo ( mapper ,     . class ,    dataBuffer )  )  . consumeNextWith (  (    dataBuffer )     -  >    readPojo ( mapper ,     . class ,    dataBuffer )  )  . consumeNextWith (  (    dataBuffer )     -  >    readPojo ( mapper ,     . class ,    dataBuffer )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["encodeAsStream"], "fileName": "org.springframework.http.codec.json.Jackson2SmileEncoderTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "T   value    =    mapper . reader (  )  . forType ( valueType )  . readValue ( DataBuffUtils . dumpBytes ( dataBuffer )  )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "return   value ;", "}    catch    ( IOException   ex )     {", "throw   new   UncheckedIOException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readPojo"], "fileName": "org.springframework.http.codec.json.Jackson2SmileEncoderTests"}, {"methodBody": ["METHOD_START", "{", "this . inputFeeder . endOfInput (  )  ;", "try    {", "return   parseBufferFlux (  )  ;", "}    catch    ( JsonProcessingException   ex )     {", "return   Flux . error ( new   DecodingException (  (  \" JSON   decoding   error :     \"     +     ( ex . getOriginalMessage (  )  )  )  ,    ex )  )  ;", "}    catch    ( IOException   ex )     {", "return   Flux . error ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["endOfInput"], "fileName": "org.springframework.http.codec.json.Jackson2Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . objectDepth )     =  =     0  )     &  &     (  (  ( token    =  =     ( JsonToken . START _ ARRAY )  )     &  &     (  ( this . arrayDepth )     =  =     1  )  )     |  |     (  ( token    =  =     ( JsonToken . END _ ARRAY )  )     &  &     (  ( this . arrayDepth )     =  =     0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTopLevelArrayToken"], "fileName": "org.springframework.http.codec.json.Jackson2Tokenizer"}, {"methodBody": ["METHOD_START", "{", "List < TokenBuffer >    result    =    new   ArrayList <  >  (  )  ;", "while    ( true )     {", "JsonToken   token    =    this . parser . nextToken (  )  ;", "if    (  ( token    =  =     ( JsonToken . NOT _ AVAILABLE )  )     |  |     (  ( token    =  =    null )     &  &     (  ( token    =    this . parser . nextToken (  )  )     =  =    null )  )  )     {", "break ;", "}", "updateDepth ( token )  ;", "if    (  !  ( this . tArrayElements )  )     {", "processTokenNormal ( token ,    result )  ;", "} else    {", "processTokenArray ( token ,    result )  ;", "}", "}", "return   Flux . fromIterable ( result )  ;", "}", "METHOD_END"], "methodName": ["parseTokenBufferFlux"], "fileName": "org.springframework.http.codec.json.Jackson2Tokenizer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isTopLevelArrayToken ( token )  )  )     {", "this . tokenBuffer . copyCurrentEvent ( this . parser )  ;", "}", "if    (  (  (  ( this . objectDepth )     =  =     0  )     &  &     (  (  ( this . arrayDepth )     =  =     0  )     |  |     (  ( this . arrayDepth )     =  =     1  )  )  )     &  &     (  ( token    =  =     ( JsonToken . END _ OBJECT )  )     |  |     ( token . isScalarValue (  )  )  )  )     {", "result . add ( this . tokenBuffer )  ;", "this . tokenBuffer    =    new   TokenBuffer ( this . parser )  ;", "}", "}", "METHOD_END"], "methodName": ["processTokenArray"], "fileName": "org.springframework.http.codec.json.Jackson2Tokenizer"}, {"methodBody": ["METHOD_START", "{", "this . tokenBuffer . copyCurrentEvent ( this . parser )  ;", "if    (  (  (  ( token . isStructEnd (  )  )     |  |     ( token . isScalarValue (  )  )  )     &  &     (  ( this . objectDepth )     =  =     0  )  )     &  &     (  ( this . arrayDepth )     =  =     0  )  )     {", "result . add ( this . tokenBuffer )  ;", "this . tokenBuffer    =    new   Buffer ( this . parser )  ;", "}", "}", "METHOD_END"], "methodName": ["processTokenNormal"], "fileName": "org.springframework.http.codec.json.Jackson2Tokenizer"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [ dataBuffer . readableByteCount (  )  ]  ;", "dataBuffer . read ( bytes )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "try    {", "this . inputFeeder . feedInput ( bytes ,     0  ,    bytes . length )  ;", "return   parseBufferFlux (  )  ;", "}    catch    ( JsonProcessingException   ex )     {", "return   Flux . error ( new   DecodingException (  (  \" JSON   decoding   error :     \"     +     ( ex . getOriginalMessage (  )  )  )  ,    ex )  )  ;", "}    catch    ( IOException   ex )     {", "return   Flux . error ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["tokenize"], "fileName": "org.springframework.http.codec.json.Jackson2Tokenizer"}, {"methodBody": ["METHOD_START", "{", "try    {", "JsonParser   parser    =    jsonFactory . createNonBlockingByteArrayParser (  )  ;", "tokenizer    =    new    ( parser ,    tokenizeArrayElements )  ;", "return   dataBuffers . flatMap ( tokenizer :  : tokenize ,    Flux :  : error ,    tokenizer :  : endOfInput )  ;", "}    catch    ( IOException   ex )     {", "return   Flux . error ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["tokenize"], "fileName": "org.springframework.http.codec.json.Jackson2Tokenizer"}, {"methodBody": ["METHOD_START", "{", "switch    ( token )     {", "case   START _ OBJECT    :", "( this . objectDepth )  +  +  ;", "break ;", "case   END _ OBJECT    :", "( this . objectDepth )  -  -  ;", "break ;", "case   START _ ARRAY    :", "( this . arrayDepth )  +  +  ;", "break ;", "case   END _ ARRAY    :", "( this . arrayDepth )  -  -  ;", "break ;", "}", "}", "METHOD_END"], "methodName": ["updateDepth"], "fileName": "org.springframework.http.codec.json.Jackson2Tokenizer"}, {"methodBody": ["METHOD_START", "{", "this . jsonFactory    =    new   JsonFactory (  )  ;", "this . objectMapper    =    new   ObjectMapper ( this . jsonFactory )  ;", "}", "METHOD_END"], "methodName": ["createParser"], "fileName": "org.springframework.http.codec.json.Jackson2TokenizerTests"}, {"methodBody": ["METHOD_START", "{", "testTokenize ( Collections . singletonList (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  )  ,    Collections . singletonList (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  )  ,    false )  ;", "testTokenize ( Arrays . asList (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  \"  ,     \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  )  ,    Collections . singletonList (  \"  {  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  }  \"  )  ,    false )  ;", "testTokenize ( Collections . singletonList (  (  \"  [  \"     +     (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  ,  \"     +     \"  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  ]  \"  )  )  )  ,    Collections . singletonList (  (  \"  [  \"     +     (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  ,  \"     +     \"  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  ]  \"  )  )  )  ,    false )  ;", "testTokenize ( Collections . singletonList (  \"  [  {  \\  \" foo \\  \"  :     \\  \" bar \\  \"  }  ,  {  \\  \" foo \\  \"  :     \\  \" baz \\  \"  }  ]  \"  )  ,    Collections . singletonList (  \"  [  {  \\  \" foo \\  \"  :     \\  \" bar \\  \"  }  ,  {  \\  \" foo \\  \"  :     \\  \" baz \\  \"  }  ]  \"  )  ,    false )  ;", "testTokenize ( Arrays . asList (  (  \"  [  \"     +     \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  \"  )  ,     (  \"  :     \\  \" barbar \\  \"  }  ,  \"     +     \"  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  ]  \"  )  )  ,    Collections . singletonList (  (  \"  [  \"     +     (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  ,  \"     +     \"  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  ]  \"  )  )  )  ,    false )  ;", "testTokenize ( Arrays . asList (  \"  [  \"  ,     \"  {  \\  \" id \\  \"  :  1  ,  \\  \" name \\  \"  :  \\  \" Robert \\  \"  }  \"  ,     \"  ,  \"  ,     \"  {  \\  \" id \\  \"  :  2  ,  \\  \" name \\  \"  :  \\  \" Raide \\  \"  }  \"  ,     \"  ,  \"  ,     \"  {  \\  \" id \\  \"  :  3  ,  \\  \" name \\  \"  :  \\  \" Ford \\  \"  }  \"  ,     \"  ]  \"  )  ,    Collections . singletonList (  (  \"  [  \"     +     (  (  \"  {  \\  \" id \\  \"  :  1  ,  \\  \" name \\  \"  :  \\  \" Robert \\  \"  }  ,  \"     +     \"  {  \\  \" id \\  \"  :  2  ,  \\  \" name \\  \"  :  \\  \" Raide \\  \"  }  ,  \"  )     +     \"  {  \\  \" id \\  \"  :  3  ,  \\  \" name \\  \"  :  \\  \" Ford \\  \"  }  ]  \"  )  )  )  ,    false )  ;", "testTokenize ( Arrays . asList (  \"  \\  \" foo \"  ,     \" bar \\  \"  \"  )  ,    Collections . singletonList (  \"  \\  \" foobar \\  \"  \"  )  ,    false )  ;", "testTokenize ( Arrays . asList (  \"  1  2  \"  ,     \"  3  4  \"  )  ,    Collections . singletonList (  \"  1  2  3  4  \"  )  ,    false )  ;", "testTokenize ( Arrays . asList (  \"  1  2  .  \"  ,     \"  3  4  \"  )  ,    Collections . singletonList (  \"  1  2  .  3  4  \"  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["doNotTokenizeArrayElements"], "fileName": "org.springframework.http.codec.json.Jackson2TokenizerTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  {  \\  \" status \\  \"  :     \\  \" noClosingQuote }  \"  )  )  ;", "Flux < TokenBuffer >    tokens    =     . tokenize ( source ,    this . jsonFactory ,    false )  ;", "tokens . blockLast (  )  ;", "}", "METHOD_END"], "methodName": ["jsonEOFExceptionIsWrappedAsDecodingError"], "fileName": "org.springframework.http.codec.json.Jackson2TokenizerTests"}, {"methodBody": ["METHOD_START", "{", "Flux < TokenBuffer >    tokenBufferFlux    =    Jackson 2 Tokenizer . tokenize ( Flux . fromIterable ( source )  . map ( this :  : stringBuffer )  ,    this . jsonFactory ,    tokenizeArrayElements )  ;", "Flux < String >    result    =    tokenBufferFlux . map (  (    tokenBuffer )     -  >     {", "try    {", "TreeNode   root    =    this . objectMapper . readTree ( tokenBuffer . asParser (  )  )  ;", "return   this . objectMapper . writeValueAsString ( root )  ;", "}    catch    (    ex )     {", "throw   new    < ex > UncheckedIOException (  )  ;", "}", "}  )  ;", "StepVerifier . FirstStep < String >    builder    =    StepVerifier . create ( result )  ;", "expected . forEach (  (    s )     -  >    builder . assertNext ( new    . JSONAssertConsumer ( s )  )  )  ;", "builder . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["testTokenize"], "fileName": "org.springframework.http.codec.json.Jackson2TokenizerTests"}, {"methodBody": ["METHOD_START", "{", "testTokenize ( Collections . singletonList (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  )  ,    Collections . singletonList (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  )  ,    true )  ;", "testTokenize ( Arrays . asList (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  \"  ,     \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  )  ,    Collections . singletonList (  \"  {  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  }  \"  )  ,    true )  ;", "testTokenize ( Collections . singletonList (  (  \"  [  \"     +     (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  ,  \"     +     \"  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  ]  \"  )  )  )  ,    Arrays . asList (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  ,     \"  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  \"  )  ,    true )  ;", "testTokenize ( Collections . singletonList (  \"  [  {  \\  \" foo \\  \"  :     \\  \" bar \\  \"  }  ,  {  \\  \" foo \\  \"  :     \\  \" baz \\  \"  }  ]  \"  )  ,    Arrays . asList (  \"  {  \\  \" foo \\  \"  :     \\  \" bar \\  \"  }  \"  ,     \"  {  \\  \" foo \\  \"  :     \\  \" baz \\  \"  }  \"  )  ,    true )  ;", "testTokenize ( Collections . singletonList (  (  \"  [  \"     +     (  (  (  \"  {  \\  \" id \\  \"  :  \\  \"  0  \\  \"  ,  \\  \" start \\  \"  :  [  -  9  9  9  9  9  9  9  9  9  ,  1  ,  1  ]  ,  \\  \" end \\  \"  :  [  9  9  9  9  9  9  9  9  9  ,  1  2  ,  3  1  ]  }  ,  \"     +     \"  {  \\  \" id \\  \"  :  \\  \"  1  \\  \"  ,  \\  \" start \\  \"  :  [  -  9  9  9  9  9  9  9  9  9  ,  1  ,  1  ]  ,  \\  \" end \\  \"  :  [  9  9  9  9  9  9  9  9  9  ,  1  2  ,  3  1  ]  }  ,  \"  )     +     \"  {  \\  \" id \\  \"  :  \\  \"  2  \\  \"  ,  \\  \" start \\  \"  :  [  -  9  9  9  9  9  9  9  9  9  ,  1  ,  1  ]  ,  \\  \" end \\  \"  :  [  9  9  9  9  9  9  9  9  9  ,  1  2  ,  3  1  ]  }  \"  )     +     \"  ]  \"  )  )  )  ,    Arrays . asList (  \"  {  \\  \" id \\  \"  :  \\  \"  0  \\  \"  ,  \\  \" start \\  \"  :  [  -  9  9  9  9  9  9  9  9  9  ,  1  ,  1  ]  ,  \\  \" end \\  \"  :  [  9  9  9  9  9  9  9  9  9  ,  1  2  ,  3  1  ]  }  \"  ,     \"  {  \\  \" id \\  \"  :  \\  \"  1  \\  \"  ,  \\  \" start \\  \"  :  [  -  9  9  9  9  9  9  9  9  9  ,  1  ,  1  ]  ,  \\  \" end \\  \"  :  [  9  9  9  9  9  9  9  9  9  ,  1  2  ,  3  1  ]  }  \"  ,     \"  {  \\  \" id \\  \"  :  \\  \"  2  \\  \"  ,  \\  \" start \\  \"  :  [  -  9  9  9  9  9  9  9  9  9  ,  1  ,  1  ]  ,  \\  \" end \\  \"  :  [  9  9  9  9  9  9  9  9  9  ,  1  2  ,  3  1  ]  }  \"  )  ,    true )  ;", "testTokenize ( Collections . singletonList (  \"  {  \\  \" speakerIds \\  \"  :  [  \\  \" tastapod \\  \"  ]  ,  \\  \" language \\  \"  :  \\  \" ENGLISH \\  \"  }  \"  )  ,    Collections . singletonList (  \"  {  \\  \" speakerIds \\  \"  :  [  \\  \" tastapod \\  \"  ]  ,  \\  \" language \\  \"  :  \\  \" ENGLISH \\  \"  }  \"  )  ,    true )  ;", "testTokenize ( Arrays . asList (  (  \"  [  \"     +     \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  \"  )  ,     (  \"  :     \\  \" barbar \\  \"  }  ,  \"     +     \"  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  ]  \"  )  )  ,    Arrays . asList (  \"  {  \\  \" foo \\  \"  :     \\  \" foofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbar \\  \"  }  \"  ,     \"  {  \\  \" foo \\  \"  :     \\  \" foofoofoo \\  \"  ,     \\  \" bar \\  \"  :     \\  \" barbarbar \\  \"  }  \"  )  ,    true )  ;", "testTokenize ( Arrays . asList (  \"  [  \"  ,     \"  {  \\  \" id \\  \"  :  1  ,  \\  \" name \\  \"  :  \\  \" Robert \\  \"  }  \"  ,     \"  ,  \"  ,     \"  {  \\  \" id \\  \"  :  2  ,  \\  \" name \\  \"  :  \\  \" Raide \\  \"  }  \"  ,     \"  ,  \"  ,     \"  {  \\  \" id \\  \"  :  3  ,  \\  \" name \\  \"  :  \\  \" Ford \\  \"  }  \"  ,     \"  ]  \"  )  ,    Arrays . asList (  \"  {  \\  \" id \\  \"  :  1  ,  \\  \" name \\  \"  :  \\  \" Robert \\  \"  }  \"  ,     \"  {  \\  \" id \\  \"  :  2  ,  \\  \" name \\  \"  :  \\  \" Raide \\  \"  }  \"  ,     \"  {  \\  \" id \\  \"  :  3  ,  \\  \" name \\  \"  :  \\  \" Ford \\  \"  }  \"  )  ,    true )  ;", "testTokenize ( Arrays . asList (  \"  \\  \" foo \"  ,     \" bar \\  \"  \"  )  ,    Collections . singletonList (  \"  \\  \" foobar \\  \"  \"  )  ,    true )  ;", "testTokenize ( Arrays . asList (  \"  1  2  \"  ,     \"  3  4  \"  )  ,    Collections . singletonList (  \"  1  2  3  4  \"  )  ,    true )  ;", "testTokenize ( Arrays . asList (  \"  1  2  .  \"  ,     \"  3  4  \"  )  ,    Collections . singletonList (  \"  1  2  .  3  4  \"  )  ,    true )  ;", "testTokenize ( Arrays . asList (  \"  [  1  \"  ,     \"  ,  2  ,  \"  ,     \"  3  ]  \"  )  ,    Arrays . asList (  \"  1  \"  ,     \"  2  \"  ,     \"  3  \"  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["tokenizeArrayElements"], "fileName": "org.springframework.http.codec.json.Jackson2TokenizerTests"}, {"methodBody": ["METHOD_START", "{", "return   withView 1  ;", "}", "METHOD_END"], "methodName": ["getWithView1"], "fileName": "org.springframework.http.codec.json.JacksonViewBean"}, {"methodBody": ["METHOD_START", "{", "return   withView 2  ;", "}", "METHOD_END"], "methodName": ["getWithView2"], "fileName": "org.springframework.http.codec.json.JacksonViewBean"}, {"methodBody": ["METHOD_START", "{", "return   withoutView ;", "}", "METHOD_END"], "methodName": ["getWithoutView"], "fileName": "org.springframework.http.codec.json.JacksonViewBean"}, {"methodBody": ["METHOD_START", "{", "this . withView 1     =    withView 1  ;", "}", "METHOD_END"], "methodName": ["setWithView1"], "fileName": "org.springframework.http.codec.json.JacksonViewBean"}, {"methodBody": ["METHOD_START", "{", "this . withView 2     =    withView 2  ;", "}", "METHOD_END"], "methodName": ["setWithView2"], "fileName": "org.springframework.http.codec.json.JacksonViewBean"}, {"methodBody": ["METHOD_START", "{", "this . withoutView    =    withoutView ;", "}", "METHOD_END"], "methodName": ["setWithoutView"], "fileName": "org.springframework.http.codec.json.JacksonViewBean"}, {"methodBody": ["METHOD_START", "{", "return   collection   instanceof   List    ?     (  ( List < Part >  )     ( collection )  )     :    new   ArrayList <  >  ( collection )  ;", "}", "METHOD_END"], "methodName": ["toList"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedMultiValueMap ( map . entrySet (  )  . stream (  )  . collect ( Collectors . toMap ( Map . Entry :  : getKey ,     (    e )     -  >    toList ( e . getValue (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toMultiValueMap"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageReader"}, {"methodBody": ["METHOD_START", "{", "MultipartHttpMessageWriter . MultipartHttpOutputMessage   outputMessage    =    new   MultipartHttpMessageWriter . MultipartHttpOutputMessage ( this . bufferFactory ,    getCharset (  )  )  ;", "HttpHeaders   outputHeaders    =    outputMessage . getHeaders (  )  ;", "T   body ;", "ResolvableType   resolvableType    =    null ;", "if    ( value   instanceof   HttpEntity )     {", "HttpEntity < T >    httpEntity    =     (  ( HttpEntity < T >  )     ( value )  )  ;", "outputHeaders . putAll ( httpEntity . getHeaders (  )  )  ;", "body    =    httpEntity . getBody (  )  ;", "Assert . state (  ( body    !  =    null )  ,     \" MultipartHttpMessageWriter   only   supports   HttpEntity   with   body \"  )  ;", "if    ( httpEntity   instanceof   MultipartBodyBuilder . PublisherEntity <  ?  ,     ?  >  )     {", "MultipartBodyBuilder . PublisherEntity <  ?  ,     ?  >    publisherEntity    =     (  ( MultipartBodyBuilder . PublisherEntity <  ?  ,     ?  >  )     ( httpEntity )  )  ;", "resolvableType    =    publisherEntity . getResolvableType (  )  ;", "}", "} else    {", "body    =    value ;", "}", "if    ( resolvableType    =  =    null )     {", "resolvableType    =    ResolvableType . forClass ( body . getClass (  )  )  ;", "}", "if    (  !  ( outputHeaders . containsKey ( HttpHeaders . CONTENT _ DISPOSITION )  )  )     {", "if    ( body   instanceof   Resource )     {", "outputHeaders . setContentDispositionFormData ( name ,     (  ( Resource )     ( body )  )  . getFilename (  )  )  ;", "} else", "if    ( Resource . class . equals ( resolvableType . getRawClass (  )  )  )     {", "body    =     (  ( T )     ( Mono . from (  (  ( Publisher <  ?  >  )     ( body )  )  )  . doOnNext (  (    o )     -  >    outputHeaders . setContentDispositionFormData ( name ,     (  ( Resource )     ( o )  )  . getFilename (  )  )  )  )  )  ;", "} else    {", "outputHeaders . setContentDispositionFormData ( name ,    null )  ;", "}", "}", "MediaType   contentType    =    outputHeaders . getContentType (  )  ;", "final   ResolvableType   finalBodyType    =    resolvableType ;", "Optional < HttpMessageWriter <  ?  >  >    writer    =    this . partWriters . stream (  )  . filter (  (    partWriter )     -  >    partWriter . canWrite ( finalBodyType ,    contentType )  )  . findFirst (  )  ;", "if    (  !  ( writer . isPresent (  )  )  )     {", "return   Flux . error ( new   CodecException (  (  \" No   suitable   writer   found   for   part :     \"     +    name )  )  )  ;", "}", "Publisher < T >    bodyPublisher    =     ( body   instanceof   Publisher )     ?     (  ( Publisher < T >  )     ( body )  )     :    Mono . just ( body )  ;", "Mono < Void >    partContentReady    =     (  ( HttpMessageWriter < T >  )     ( writer . get (  )  )  )  . write ( bodyPublisher ,    resolvableType ,    contentType ,    outputMessage ,    Collections . emptyMap (  )  )  ;", "Flux < DataBuffer >    partContent    =    partContentReady . thenMany ( Flux . defer ( outputMessage :  : getBody )  )  ;", "return   Flux . concat ( Mono . just ( generateBoundaryLine ( boundary )  )  ,    partContent ,    Mono . just ( generateNewLine (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodePart"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return   Flux . concat ( values . stream (  )  . map (  (    v )     -  >    encodePart ( boundary ,    name ,    v )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodePartValues"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    this . bufferFactory . allocateBuffer (  (  ( boundary . length )     +     4  )  )  ;", "buffer . w (  (  ( byte )     (  '  -  '  )  )  )  ;", "buffer . w (  (  ( byte )     (  '  -  '  )  )  )  ;", "buffer . w ( boundary )  ;", "buffer . w (  (  ( byte )     (  '  \\ r '  )  )  )  ;", "buffer . w (  (  ( byte )     (  '  \\ n '  )  )  )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["generateBoundaryLine"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    this . bufferFactory . allocateBuffer (  (  ( boundary . length )     +     6  )  )  ;", "buffer . w (  (  ( byte )     (  '  -  '  )  )  )  ;", "buffer . w (  (  ( byte )     (  '  -  '  )  )  )  ;", "buffer . w ( boundary )  ;", "buffer . w (  (  ( byte )     (  '  -  '  )  )  )  ;", "buffer . w (  (  ( byte )     (  '  -  '  )  )  )  ;", "buffer . w (  (  ( byte )     (  '  \\ r '  )  )  )  ;", "buffer . w (  (  ( byte )     (  '  \\ n '  )  )  )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["generateLastLine"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return   MimeTypeUtils . generateMultipartBoundary (  )  ;", "}", "METHOD_END"], "methodName": ["generateMultipartBoundary"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    this . bufferFactory . allocateBuffer (  2  )  ;", "buffer . w (  (  ( byte )     (  '  \\ r '  )  )  )  ;", "buffer . w (  (  ( byte )     (  '  \\ n '  )  )  )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["generateNewLine"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "return   this . charset ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "List < MediaType >    result    =    new   ArrayList <  >  (  )  ;", "result . add ( MediaType . MULTIPART _ FORM _ DATA )  ;", "if    ( form    !  =    null )     {", "result . addAll ( form . getWritableMediaTypes (  )  )  ;", "}", "return   Collections . unmodifiableList ( result )  ;", "}", "METHOD_END"], "methodName": ["initMediaTypes"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( contentType    !  =    null )     {", "return   MediaType . MULTIPART _ FORM _ DATA . includes ( contentType )  ;", "}", "for    ( St   name    :    map . keySet (  )  )     {", "for    ( Object   value    :    map . get ( name )  )     {", "if    (  ( value    !  =    null )     &  &     (  !  ( value   instanceof   St )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isMultipart"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( charset ,     \" Charset   must   not   be   null \"  )  ;", "this . charset    =    charset ;", "}", "METHOD_END"], "methodName": ["setCharset"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    boundary    =    generateMultipartBoundary (  )  ;", "Map < String ,    String >    params    =    new   HashMap <  >  (  2  )  ;", "params . put (  \" boundary \"  ,    new   String ( boundary ,    StandardCharsets . US _ ASCII )  )  ;", "params . put (  \" charset \"  ,    getCharset (  )  . name (  )  )  ;", "outputMessage . getHeaders (  )  . setContentType ( new   MediaType ( MediaType . MULTIPART _ FORM _ DATA ,    params )  )  ;", "Flux < DataBuffer >    body    =    Flux . fromIterable ( map . entrySet (  )  )  . concatMap (  (    entry )     -  >    encodePartValues ( boundary ,    entry . getKey (  )  ,    entry . getValue (  )  )  )  . concatWith ( Mono . just ( generateLastLine ( boundary )  )  )  ;", "return   outputMessage . writeWith ( body )  ;", "}", "METHOD_END"], "methodName": ["writeMultipart"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Object . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "assertTrue ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    String . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "assertFalse ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( Map . class ,    String . class ,    Object . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "assertTrue ( this . writer . canWrite ( ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Object . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   logo    =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )  ;", "Flux < DataBuffer >    buffers    =    DataBufferUtils . read ( logo ,    new   DefaultDataBufferFactory (  )  ,     1  0  2  4  )  ;", "long   contentLength    =    logo . contentLength (  )  ;", "MultipartBodyBuilder   bodyBuilder    =    new   MultipartBodyBuilder (  )  ;", "bodyBuilder . part (  \" resource \"  ,    logo )  . headers (  (    h )     -  >    h . setContentDispositionFormData (  \" resource \"  ,     \" spring . jpg \"  )  )  ;", "bodyBuilder . asyncPart (  \" buffers \"  ,    buffers ,    DataBuffer . class )  . headers (  (    h )     -  >     {", "h . setContentDispositionFormData (  \" buffers \"  ,     \" buffers . jpg \"  )  ;", "h . setContentType ( MediaType . IMAGE _ JPEG )  ;", "h . setContentLength ( contentLength )  ;", "}  )  ;", "MultiValueMap < String ,    HttpEntity <  ?  >  >    multipartData    =    bodyBuilder . build (  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Map < String ,    Object >    hints    =    Collections . emptyMap (  )  ;", "this . writer . write ( Mono . just ( multipartData )  ,    null ,    MediaType . MULTIPART _ FORM _ DATA ,    response ,    hints )  . block (  )  ;", "MultiValueMap < String ,    Part >    requestParts    =    parse ( response ,    hints )  ;", "assertEquals (  2  ,    requestParts . size (  )  )  ;", "Part   part    =    requestParts . getFirst (  \" resource \"  )  ;", "assertTrue (  ( part   instanceof   FilePart )  )  ;", "assertEquals (  \" spring . jpg \"  ,     (  ( FilePart )     ( part )  )  . filename (  )  )  ;", "assertEquals ( logo . getFile (  )  . length (  )  ,    part . headers (  )  . getContentLength (  )  )  ;", "part    =    requestParts . getFirst (  \" buffers \"  )  ;", "assertTrue (  ( part   instanceof   FilePart )  )  ;", "assertEquals (  \" buffers . jpg \"  ,     (  ( FilePart )     ( part )  )  . filename (  )  )  ;", "assertEquals ( logo . getFile (  )  . length (  )  ,    part . headers (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["customContentDisposition"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    response . getHeaders (  )  . getContentType (  )  ;", "assertNotNull (  \" No   boundary   found \"  ,    contentType . getParameter (  \" boundary \"  )  )  ;", "SynchronossPartHttpMessageReader   synchronossReader    =    new   SynchronossPartHttpMessageReader (  )  ;", "Reader   reader    =    new   Reader ( synchronossReader )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( MediaType . parseMediaType ( contentType . toString (  )  )  )  . body ( response . getBody (  )  )  ;", "ResolvableType   elementType    =    ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Part . class )  ;", "MultiValueMap < String ,    Part >    result    =    reader . readMono ( elementType ,    request ,    hints )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertNotNull ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "UnicastProcessor < Resource >    processor    =    UnicastProcessor . create (  )  ;", "Resource   logo    =    new   ClassPathResource (  \"  / org /  / http / converter / logo . jpg \"  )  ;", "Mono . just ( logo )  . subscribe ( processor )  ;", "MultipartBodyBuilder   bodyBuilder    =    new   MultipartBodyBuilder (  )  ;", "bodyBuilder . asyncPart (  \" logo \"  ,    processor ,    Resource . class )  ;", "Mono < MultiValueMap < String ,    HttpEntity <  ?  >  >  >    result    =    Mono . just ( bodyBuilder . build (  )  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Map < String ,    Object >    hints    =    Collections . emptyMap (  )  ;", "this . writer . write ( result ,    null ,    MediaType . MULTIPART _ FORM _ DATA ,    response ,    hints )  . block (  )  ;", "MultiValueMap < String ,    Part >    requestParts    =    parse ( response ,    hints )  ;", "assertEquals (  1  ,    requestParts . size (  )  )  ;", "Part   part    =    requestParts . getFirst (  \" logo \"  )  ;", "assertEquals (  \" logo \"  ,    part . name (  )  )  ;", "assertTrue (  ( part   instanceof   FilePart )  )  ;", "assertEquals (  \" logo . jpg \"  ,     (  ( FilePart )     ( part )  )  . filename (  )  )  ;", "assertEquals ( MediaType . IMAGE _ JPEG ,    part . headers (  )  . getContentType (  )  )  ;", "assertEquals ( logo . getFile (  )  . length (  )  ,    part . headers (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["singleSubscriberWithResource"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "UnicastProcessor < String >    processor    =    UnicastProcessor . create (  )  ;", "Flux . just (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  . subscribe ( processor )  ;", "BodyBuilder   bodyBuilder    =    new   BodyBuilder (  )  ;", "bodyBuilder . asyncPart (  \" name \"  ,    processor ,    String . class )  ;", "Mono < MultiValueMap < String ,    HttpEntity <  ?  >  >  >    result    =    Mono . just ( bodyBuilder . build (  )  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Map < String ,    Object >    hints    =    Collections . emptyMap (  )  ;", "this . writer . write ( result ,    null ,    MediaType . MULTIPART _ FORM _ DATA ,    response ,    hints )  . block (  )  ;", "}", "METHOD_END"], "methodName": ["singleSubscriberWithStrings"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   logo    =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )  ;", "Resource   utf 8     =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )     {", "@ Override", "public   String   getFilename (  )     {", "return    \" Hall \\ u 0  0 f 6 le . jpg \"  ;", "}", "}  ;", "Publisher < String >    publisher    =    Flux . just (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "MultipartBodyBuilder   bodyBuilder    =    new   MultipartBodyBuilder (  )  ;", "bodyBuilder . part (  \" name    1  \"  ,     \" value    1  \"  )  ;", "bodyBuilder . part (  \" name    2  \"  ,     \" value    2  +  1  \"  )  ;", "bodyBuilder . part (  \" name    2  \"  ,     \" value    2  +  2  \"  )  ;", "bodyBuilder . part (  \" logo \"  ,    logo )  ;", "bodyBuilder . part (  \" utf 8  \"  ,    utf 8  )  ;", "bodyBuilder . part (  \" json \"  ,    new    . Foo (  \" bar \"  )  ,    MediaType . APPLICATION _ JSON _ UTF 8  )  ;", "bodyBuilder . asyncPart (  \" publisher \"  ,    publisher ,    String . class )  ;", "Mono < MultiValueMap < String ,    HttpEntity <  ?  >  >  >    result    =    Mono . just ( bodyBuilder . build (  )  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Map < String ,    Object >    hints    =    Collections . emptyMap (  )  ;", "this . writer . write ( result ,    null ,    MediaType . MULTIPART _ FORM _ DATA ,    response ,    hints )  . block ( Duration . ofSeconds (  5  )  )  ;", "MultiValueMap < String ,    Part >    requestParts    =    parse ( response ,    hints )  ;", "assertEquals (  6  ,    requestParts . size (  )  )  ;", "Part   part    =    requestParts . getFirst (  \" name    1  \"  )  ;", "assertTrue (  ( part   instanceof   FormFieldPart )  )  ;", "assertEquals (  \" name    1  \"  ,    part . name (  )  )  ;", "assertEquals (  \" value    1  \"  ,     (  ( FormFieldPart )     ( part )  )  . value (  )  )  ;", "List < Part >    parts 2     =    requestParts . get (  \" name    2  \"  )  ;", "assertEquals (  2  ,    parts 2  . size (  )  )  ;", "part    =    parts 2  . get (  0  )  ;", "assertTrue (  ( part   instanceof   FormFieldPart )  )  ;", "assertEquals (  \" name    2  \"  ,    part . name (  )  )  ;", "assertEquals (  \" value    2  +  1  \"  ,     (  ( FormFieldPart )     ( part )  )  . value (  )  )  ;", "part    =    parts 2  . get (  1  )  ;", "assertTrue (  ( part   instanceof   FormFieldPart )  )  ;", "assertEquals (  \" name    2  \"  ,    part . name (  )  )  ;", "assertEquals (  \" value    2  +  2  \"  ,     (  ( FormFieldPart )     ( part )  )  . value (  )  )  ;", "part    =    requestParts . getFirst (  \" logo \"  )  ;", "assertTrue (  ( part   instanceof   FilePart )  )  ;", "assertEquals (  \" logo \"  ,    part . name (  )  )  ;", "assertEquals (  \" logo . jpg \"  ,     (  ( FilePart )     ( part )  )  . filename (  )  )  ;", "assertEquals ( MediaType . IMAGE _ JPEG ,    part . headers (  )  . getContentType (  )  )  ;", "assertEquals ( logo . getFile (  )  . length (  )  ,    part . headers (  )  . getContentLength (  )  )  ;", "part    =    requestParts . getFirst (  \" utf 8  \"  )  ;", "assertTrue (  ( part   instanceof   FilePart )  )  ;", "assertEquals (  \" utf 8  \"  ,    part . name (  )  )  ;", "assertEquals (  \" Hall \\ u 0  0 f 6 le . jpg \"  ,     (  ( FilePart )     ( part )  )  . filename (  )  )  ;", "assertEquals ( MediaType . IMAGE _ JPEG ,    part . headers (  )  . getContentType (  )  )  ;", "assertEquals ( utf 8  . getFile (  )  . length (  )  ,    part . headers (  )  . getContentLength (  )  )  ;", "part    =    requestParts . getFirst (  \" json \"  )  ;", "assertEquals (  \" json \"  ,    part . name (  )  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON _ UTF 8  ,    part . headers (  )  . getContentType (  )  )  ;", "String   value    =    StringDecoder . textPlainOnly ( false )  . decodeToMono ( part . content (  )  ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ PLAIN ,    Collections . emptyMap (  )  )  . block ( Duration . ZERO )  ;", "assertEquals (  \"  {  \\  \" bar \\  \"  :  \\  \" bar \\  \"  }  \"  ,    value )  ;", "part    =    requestParts . getFirst (  \" publisher \"  )  ;", "assertEquals (  \" publisher \"  ,    part . name (  )  )  ;", "value    =    StringDecoder . textPlainOnly ( false )  . decodeToMono ( part . content (  )  ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ PLAIN ,    Collections . emptyMap (  )  )  . block ( Duration . ZERO )  ;", "assertEquals (  \" foobarbaz \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["writeMultipart"], "fileName": "org.springframework.http.codec.multipart.MultipartHttpMessageWriterTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    generateErrorMultipartRequest (  )  ;", "ResolvableType   elementType    =    forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Part . class )  ;", "StepVerifier . create ( this . reader . readMono ( elementType ,    request ,    Collections . emptyMap (  )  )  )  . verifyError (  )  ;", "}", "METHOD_END"], "methodName": ["bodyError"], "fileName": "org.springframework.http.codec.multipart.SynchronossPartHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . reader . canRead ( forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Part . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "assertFalse ( this . reader . canRead ( forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Object . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "assertFalse ( this . reader . canRead ( forClassWithGenerics ( MultiValueMap . class ,    String . class ,    String . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "assertFalse ( this . reader . canRead ( forClassWithGenerics ( Map . class ,    String . class ,    String . class )  ,    MediaType . MULTIPART _ FORM _ DATA )  )  ;", "assertFalse ( this . reader . canRead ( forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Part . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.codec.multipart.SynchronossPartHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . post (  \"  /  \"  )  . header ( HttpHeaders . CONTENT _ TYPE ,    MediaType . MULTIPART _ FORM _ DATA . toString (  )  )  . body ( Flux . just ( new   DefaultDataBufferFactory (  )  . wrap (  \" invalid   content \"  . getBytes (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["generateErrorMultipartRequest"], "fileName": "org.springframework.http.codec.multipart.SynchronossPartHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "MultipartBodyBuilder   partsBuilder    =    new   MultipartBodyBuilder (  )  ;", "partsBuilder . part (  \" fooPart \"  ,    new   ClassPathResource (  \" org /  / http / codec / multipart / foo . txt \"  )  )  ;", "partsBuilder . part (  \" barPart \"  ,     \" bar \"  )  ;", "MockClientHttpRequest   outputMessage    =    new   MockClientHttpRequest ( HttpMethod . POST ,     \"  /  \"  )  ;", "new   MultipartHttpMessageWriter (  )  . write ( Mono . just ( partsBuilder . build (  )  )  ,    null ,    MediaType . MULTIPART _ FORM _ DATA ,    outputMessage ,    null )  . block ( Duration . ofSeconds (  5  )  )  ;", "return   MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( outputMessage . getHeaders (  )  . getContentType (  )  )  . body ( outputMessage . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["generateMultipartRequest"], "fileName": "org.springframework.http.codec.multipart.SynchronossPartHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    generateMultipartRequest (  )  ;", "ResolvableType   elementType    =    forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Part . class )  ;", "MultiValueMap < String ,    Part >    parts    =    this . reader . readMono ( elementType ,    request ,    Collections . emptyMap (  )  )  . block (  )  ;", "assertEquals (  2  ,    parts . size (  )  )  ;", "assertTrue ( parts . containsKey (  \" fooPart \"  )  )  ;", "Part   part    =    parts . getFirst (  \" fooPart \"  )  ;", "assertTrue (  ( part   instanceof   FilePart )  )  ;", "assertEquals (  \" fooPart \"  ,    part . name (  )  )  ;", "assertEquals (  \" foo . txt \"  ,     (  ( FilePart )     ( part )  )  . filename (  )  )  ;", "DataBuffer   buffer    =    DataBufferUtils . join ( part . content (  )  )  . block (  )  ;", "assertEquals (  1  2  ,    buffer . readableByteCount (  )  )  ;", "byte [  ]    byteContent    =    new   byte [  1  2  ]  ;", "buffer . read ( byteContent )  ;", "assertEquals (  \" Lorem   Ipsum .  \"  ,    new   String ( byteContent )  )  ;", "assertTrue ( parts . containsKey (  \" barPart \"  )  )  ;", "part    =    parts . getFirst (  \" barPart \"  )  ;", "assertTrue (  ( part   instanceof   FormFieldPart )  )  ;", "assertEquals (  \" barPart \"  ,    part . name (  )  )  ;", "assertEquals (  \" bar \"  ,     (  ( FormFieldPart )     ( part )  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveParts"], "fileName": "org.springframework.http.codec.multipart.SynchronossPartHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    generateMultipartRequest (  )  ;", "ResolvableType   elementType    =    forClassWithGenerics ( MultiValueMap . class ,    String . class ,    Part . class )  ;", "MultiValueMap < String ,    Part >    parts    =    this . reader . readMono ( elementType ,    request ,    Collections . emptyMap (  )  )  . block (  )  ;", "assertNotNull ( parts )  ;", "FilePart   part    =     (  ( FilePart )     ( parts . getFirst (  \" fooPart \"  )  )  )  ;", "assertNotNull ( part )  ;", "File   dest    =    new   File (  (  (  ( System . getProperty (  \" tmpdir \"  )  )     +     \"  /  \"  )     +     ( part . filename (  )  )  )  )  ;", "part . transferTo ( dest )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertTrue ( dest . exists (  )  )  ;", "assertEquals (  1  2  ,    dest . length (  )  )  ;", "assertTrue ( dest . delete (  )  )  ;", "}", "METHOD_END"], "methodName": ["transferTo"], "fileName": "org.springframework.http.codec.multipart.SynchronossPartHttpMessageReaderTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageReader <  ?  >    reader    =    readers . get ( this . index . getAndIncrement (  )  )  ;", "assertEquals ( ServerSentEventHttpMessageReader . class ,    reader . getClass (  )  )  ;", "Der <  ?  >    der    =     (  ( ServerSentEventHttpMessageReader )     ( reader )  )  . getDer (  )  ;", "assertNotNull ( der )  ;", "assertEquals ( Jackson 2 JsonDer . class ,    der . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSseReader"], "fileName": "org.springframework.http.codec.support.ClientCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( StringDecoder . class ,    decoder . getClass (  )  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    TEXT _ PLAIN )  )  ;", "assertEquals (  (  ! textOnly )  ,    decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ EVENT _ STREAM )  )  ;", "Flux < String >    decoded    =     (  ( Flux < String >  )     ( decoder . decode ( Flux . just ( new   DefaultDataBufferFactory (  )  . wrap (  \" line 1  \\ nline 2  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ,    ResolvableType . forClass ( String . class )  ,    TEXT _ PLAIN ,    Collections . emptyMap (  )  )  )  )  ;", "assertEquals ( Arrays . asList (  \" line 1  \"  ,     \" line 2  \"  )  ,    decoded . collectList (  )  . block ( Duration . ZERO )  )  ;", "}", "METHOD_END"], "methodName": ["assertStringDecoder"], "fileName": "org.springframework.http.codec.support.ClientCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( CharSequenceEncoder . class ,    encoder . getClass (  )  )  ;", "assertTrue ( encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    TEXT _ PLAIN )  )  ;", "assertEquals (  (  ! textOnly )  ,    encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ EVENT _ STREAM )  )  ;", "}", "METHOD_END"], "methodName": ["assertStringEncoder"], "fileName": "org.springframework.http.codec.support.ClientCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageReader <  ?  >  >    readers    =    this . configurer . getReaders (  )  ;", "assertEquals (  1  0  ,    readers . size (  )  )  ;", "assertEquals ( ByteArrayDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( ByteBufferDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( DataBufferDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( ResourceDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertStringDecoder ( getNextDecoder ( readers )  ,    true )  ;", "assertEquals ( Jackson 2 JsonDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 SmileDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( Jaxb 2 XmlDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertSseReader ( readers )  ;", "assertStringDecoder ( getNextDecoder ( readers )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["defaultReaders"], "fileName": "org.springframework.http.codec.support.ClientCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageWriter <  ?  >  >    writers    =    this . configurer . getWriters (  )  ;", "assertEquals (  1  0  ,    writers . size (  )  )  ;", "assertEquals ( ByteArrayEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( ByteBufferEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( DataBufferEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( ResourceHttpMessageWriter . class ,    writers . get ( index . getAndIncrement (  )  )  . getClass (  )  )  ;", "assertStringEncoder ( getNextEncoder ( writers )  ,    true )  ;", "assertEquals ( MultipartHttpMessageWriter . class ,    writers . get ( this . index . getAndIncrement (  )  )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 JsonEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 SmileEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( Jaxb 2 XmlEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertStringEncoder ( getNextEncoder ( writers )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["defaultWriters"], "fileName": "org.springframework.http.codec.support.ClientCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageReader <  ?  >    reader    =    readers . get ( this . index . getAndIncrement (  )  )  ;", "assertEquals ( DerHttpMessageReader . class ,    reader . getClass (  )  )  ;", "return    (  ( DerHttpMessageReader <  ?  >  )     ( reader )  )  . getDer (  )  ;", "}", "METHOD_END"], "methodName": ["getNextDecoder"], "fileName": "org.springframework.http.codec.support.ClientCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageWriter <  ?  >    writer    =    writers . get ( this . index . getAndIncrement (  )  )  ;", "assertEquals ( EnrHttpMessageWriter . class ,    writer . getClass (  )  )  ;", "return    (  ( EnrHttpMessageWriter <  ?  >  )     ( writer )  )  . getEnr (  )  ;", "}", "METHOD_END"], "methodName": ["getNextEncoder"], "fileName": "org.springframework.http.codec.support.ClientCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Jackson 2 JsonDecoder   decoder    =    new   Jackson 2 JsonDecoder (  )  ;", "this . c . defaultCodecs (  )  . jackson 2 JsonDecoder ( decoder )  ;", "assertSame ( decoder ,    this . c . getReaders (  )  . stream (  )  . filter (  (    reader )     -  >    ServerSentEventHttpMessageReader . class . equals ( reader . getClass (  )  )  )  . map (  (    reader )     -  >     (  ( ServerSentEventHttpMessageReader )     ( reader )  )  )  . findFirst (  )  . map ( ServerSentEventHttpMessageReader :  : getDecoder )  . filter (  (    e )     -  >    e    =  =    decoder )  . orElse ( null )  )  ;", "}", "METHOD_END"], "methodName": ["jackson2EncoderOverride"], "fileName": "org.springframework.http.codec.support.ClientCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( StringDecoder . class ,    decoder . getClass (  )  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    TEXT _ PLAIN )  )  ;", "assertEquals (  (  ! textOnly )  ,    decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ EVENT _ STREAM )  )  ;", "}", "METHOD_END"], "methodName": ["assertStringDecoder"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( CharSequenceEncoder . class ,    encoder . getClass (  )  )  ;", "assertTrue ( encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    TEXT _ PLAIN )  )  ;", "assertEquals (  (  ! textOnly )  ,    encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ EVENT _ STREAM )  )  ;", "}", "METHOD_END"], "methodName": ["assertStringEncoder"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Decoder <  ?  >    customDecoder 1     =    mock ( Decoder . class )  ;", "Decoder <  ?  >    customDecoder 2     =    mock ( Decoder . class )  ;", "when ( customDecoder 1  . canDecode ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( false )  ;", "when ( customDecoder 2  . canDecode ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( true )  ;", "HttpMessageReader <  ?  >    customReader 1     =    mock ( HttpMessageReader . class )  ;", "HttpMessageReader <  ?  >    customReader 2     =    mock ( HttpMessageReader . class )  ;", "when ( customReader 1  . canRead ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( false )  ;", "when ( customReader 2  . canRead ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( true )  ;", "this . c . customCodecs (  )  . decoder ( customDecoder 1  )  ;", "this . c . customCodecs (  )  . decoder ( customDecoder 2  )  ;", "this . c . customCodecs (  )  . reader ( customReader 1  )  ;", "this . c . customCodecs (  )  . reader ( customReader 2  )  ;", "List < HttpMessageReader <  ?  >  >    readers    =    this . c . getReaders (  )  ;", "assertEquals (  1  3  ,    readers . size (  )  )  ;", "assertEquals ( ByteArrayDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( ByteBufferDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( DataBufferDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( ResourceDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( StringDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertSame ( customDecoder 1  ,    getNextDecoder ( readers )  )  ;", "assertSame ( customReader 1  ,    readers . get ( this . index . getAndIncrement (  )  )  )  ;", "assertEquals ( Jackson 2 JsonDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 SmileDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( Jaxb 2 XmlDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertSame ( customDecoder 2  ,    getNextDecoder ( readers )  )  ;", "assertSame ( customReader 2  ,    readers . get ( this . index . getAndIncrement (  )  )  )  ;", "assertEquals ( StringDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultAndCustomReaders"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Encoder <  ?  >    customEncoder 1     =    mock ( Encoder . class )  ;", "Encoder <  ?  >    customEncoder 2     =    mock ( Encoder . class )  ;", "when ( customEncoder 1  . canEncode ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( false )  ;", "when ( customEncoder 2  . canEncode ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( true )  ;", "HttpMessageWriter <  ?  >    customWriter 1     =    mock ( HttpMessageWriter . class )  ;", "HttpMessageWriter <  ?  >    customWriter 2     =    mock ( HttpMessageWriter . class )  ;", "when ( customWriter 1  . canWrite ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( false )  ;", "when ( customWriter 2  . canWrite ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( true )  ;", "this . c . customCodecs (  )  . encoder ( customEncoder 1  )  ;", "this . c . customCodecs (  )  . encoder ( customEncoder 2  )  ;", "this . c . customCodecs (  )  . writer ( customWriter 1  )  ;", "this . c . customCodecs (  )  . writer ( customWriter 2  )  ;", "List < HttpMessageWriter <  ?  >  >    writers    =    this . c . getWriters (  )  ;", "assertEquals (  1  3  ,    writers . size (  )  )  ;", "assertEquals ( ByteArrayEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( ByteBufferEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( DataBufferEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( ResourceHttpMessageWriter . class ,    writers . get ( index . getAndIncrement (  )  )  . getClass (  )  )  ;", "assertEquals ( CharSequenceEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertSame ( customEncoder 1  ,    getNextEncoder ( writers )  )  ;", "assertSame ( customWriter 1  ,    writers . get ( this . index . getAndIncrement (  )  )  )  ;", "assertEquals ( Jackson 2 JsonEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 SmileEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( Jaxb 2 XmlEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertSame ( customEncoder 2  ,    getNextEncoder ( writers )  )  ;", "assertSame ( customWriter 2  ,    writers . get ( this . index . getAndIncrement (  )  )  )  ;", "assertEquals ( CharSequenceEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultAndCustomWriters"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageReader <  ?  >  >    readers    =    this . configurer . getReaders (  )  ;", "assertEquals (  9  ,    readers . size (  )  )  ;", "assertEquals ( ByteArrayDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( ByteBufferDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( DataBufferDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( ResourceDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertStringDecoder ( getNextDecoder ( readers )  ,    true )  ;", "assertEquals ( Jackson 2 JsonDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 SmileDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( Jaxb 2 XmlDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertStringDecoder ( getNextDecoder ( readers )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["defaultReaders"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageWriter <  ?  >  >    writers    =    this . configurer . getWriters (  )  ;", "assertEquals (  9  ,    writers . size (  )  )  ;", "assertEquals ( ByteArrayEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( ByteBufferEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( DataBufferEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( ResourceHttpMessageWriter . class ,    writers . get ( index . getAndIncrement (  )  )  . getClass (  )  )  ;", "assertStringEncoder ( getNextEncoder ( writers )  ,    true )  ;", "assertEquals ( Jackson 2 JsonEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 SmileEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( Jaxb 2 XmlEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertStringEncoder ( getNextEncoder ( writers )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["defaultWriters"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Decoder <  ?  >    customDecoder 1     =    mock ( Decoder . class )  ;", "Decoder <  ?  >    customDecoder 2     =    mock ( Decoder . class )  ;", "when ( customDecoder 1  . canDecode ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( false )  ;", "when ( customDecoder 2  . canDecode ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( true )  ;", "HttpMessageReader <  ?  >    customReader 1     =    mock ( HttpMessageReader . class )  ;", "HttpMessageReader <  ?  >    customReader 2     =    mock ( HttpMessageReader . class )  ;", "when ( customReader 1  . canRead ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( false )  ;", "when ( customReader 2  . canRead ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( true )  ;", "this . c . customCodecs (  )  . decoder ( customDecoder 1  )  ;", "this . c . customCodecs (  )  . decoder ( customDecoder 2  )  ;", "this . c . customCodecs (  )  . reader ( customReader 1  )  ;", "this . c . customCodecs (  )  . reader ( customReader 2  )  ;", "this . c . registerDefaults ( false )  ;", "List < HttpMessageReader <  ?  >  >    readers    =    this . c . getReaders (  )  ;", "assertEquals (  4  ,    readers . size (  )  )  ;", "assertSame ( customDecoder 1  ,    getNextDecoder ( readers )  )  ;", "assertSame ( customReader 1  ,    readers . get ( this . index . getAndIncrement (  )  )  )  ;", "assertSame ( customDecoder 2  ,    getNextDecoder ( readers )  )  ;", "assertSame ( customReader 2  ,    readers . get ( this . index . getAndIncrement (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultsOffCustomReaders"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Encoder <  ?  >    customEncoder 1     =    mock ( Encoder . class )  ;", "Encoder <  ?  >    customEncoder 2     =    mock ( Encoder . class )  ;", "when ( customEncoder 1  . canEncode ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( false )  ;", "when ( customEncoder 2  . canEncode ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( true )  ;", "HttpMessageWriter <  ?  >    customWriter 1     =    mock ( HttpMessageWriter . class )  ;", "HttpMessageWriter <  ?  >    customWriter 2     =    mock ( HttpMessageWriter . class )  ;", "when ( customWriter 1  . canWrite ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( false )  ;", "when ( customWriter 2  . canWrite ( ResolvableType . forClass ( Object . class )  ,    null )  )  . thenReturn ( true )  ;", "this . c . customCodecs (  )  . encoder ( customEncoder 1  )  ;", "this . c . customCodecs (  )  . encoder ( customEncoder 2  )  ;", "this . c . customCodecs (  )  . writer ( customWriter 1  )  ;", "this . c . customCodecs (  )  . writer ( customWriter 2  )  ;", "this . c . registerDefaults ( false )  ;", "List < HttpMessageWriter <  ?  >  >    writers    =    this . c . getWriters (  )  ;", "assertEquals (  4  ,    writers . size (  )  )  ;", "assertSame ( customEncoder 1  ,    getNextEncoder ( writers )  )  ;", "assertSame ( customWriter 1  ,    writers . get ( this . index . getAndIncrement (  )  )  )  ;", "assertSame ( customEncoder 2  ,    getNextEncoder ( writers )  )  ;", "assertSame ( customWriter 2  ,    writers . get ( this . index . getAndIncrement (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultsOffWithCustomWriters"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageReader <  ?  >    reader    =    readers . get ( this . index . getAndIncrement (  )  )  ;", "assertEquals ( DerHttpMessageReader . class ,    reader . getClass (  )  )  ;", "return    (  ( DerHttpMessageReader <  ?  >  )     ( reader )  )  . getDer (  )  ;", "}", "METHOD_END"], "methodName": ["getNextDecoder"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageWriter <  ?  >    writer    =    writers . get ( this . index . getAndIncrement (  )  )  ;", "assertEquals ( EnrHttpMessageWriter . class ,    writer . getClass (  )  )  ;", "return    (  ( EnrHttpMessageWriter <  ?  >  )     ( writer )  )  . getEnr (  )  ;", "}", "METHOD_END"], "methodName": ["getNextEncoder"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Jackson 2 JsonDecoder   decoder    =    new   Jackson 2 JsonDecoder (  )  ;", "this . c . defaultCodecs (  )  . jackson 2 JsonDecoder ( decoder )  ;", "assertSame ( decoder ,    this . c . getReaders (  )  . stream (  )  . filter (  (    writer )     -  >    writer   instanceof   DecoderHttpMessageReader )  . map (  (    writer )     -  >     (  ( DecoderHttpMessageReader <  ?  >  )     ( writer )  )  . getDecoder (  )  )  . filter (  (    e )     -  >     . class . equals ( e . getClass (  )  )  )  . findFirst (  )  . filter (  (    e )     -  >    e    =  =    decoder )  . orElse ( null )  )  ;", "}", "METHOD_END"], "methodName": ["jackson2DecoderOverride"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Jackson 2 JsonEncoder   encoder    =    new   Jackson 2 JsonEncoder (  )  ;", "this . c . defaultCodecs (  )  . jackson 2 JsonEncoder ( encoder )  ;", "assertSame ( encoder ,    this . c . getWriters (  )  . stream (  )  . filter (  (    writer )     -  >    writer   instanceof   EncoderHttpMessageWriter )  . map (  (    writer )     -  >     (  ( EncoderHttpMessageWriter <  ?  >  )     ( writer )  )  . getEncoder (  )  )  . filter (  (    e )     -  >     . class . equals ( e . getClass (  )  )  )  . findFirst (  )  . filter (  (    e )     -  >    e    =  =    encoder )  . orElse ( null )  )  ;", "}", "METHOD_END"], "methodName": ["jackson2EncoderOverride"], "fileName": "org.springframework.http.codec.support.CodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageWriter <  ?  >    writer    =    writers . get ( this . index . getAndIncrement (  )  )  ;", "assertEquals ( SentEventHttpMessageWriter . class ,    writer . getClass (  )  )  ;", "Encoder <  ?  >    encoder    =     (  ( SentEventHttpMessageWriter )     ( writer )  )  . getEncoder (  )  ;", "assertNotNull ( encoder )  ;", "assertEquals ( Jackson 2 JsonEncoder . class ,    encoder . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSseWriter"], "fileName": "org.springframework.http.codec.support.ServerCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( StringDecoder . class ,    decoder . getClass (  )  )  ;", "assertTrue ( decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    TEXT _ PLAIN )  )  ;", "assertEquals (  (  ! textOnly )  ,    decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ EVENT _ STREAM )  )  ;", "Flux < String >    flux    =     (  ( Flux < String >  )     ( decoder . decode ( Flux . just ( new   DefaultDataBufferFactory (  )  . wrap (  \" line 1  \\ nline 2  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ,    ResolvableType . forClass ( String . class )  ,    TEXT _ PLAIN ,    Collections . emptyMap (  )  )  )  )  ;", "assertEquals ( Arrays . asList (  \" line 1  \"  ,     \" line 2  \"  )  ,    flux . collectList (  )  . block ( Duration . ZERO )  )  ;", "}", "METHOD_END"], "methodName": ["assertStringDecoder"], "fileName": "org.springframework.http.codec.support.ServerCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( CharSequenceEncoder . class ,    encoder . getClass (  )  )  ;", "assertTrue ( encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    TEXT _ PLAIN )  )  ;", "assertEquals (  (  ! textOnly )  ,    encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ EVENT _ STREAM )  )  ;", "}", "METHOD_END"], "methodName": ["assertStringEncoder"], "fileName": "org.springframework.http.codec.support.ServerCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageReader <  ?  >  >    readers    =    this . configurer . getReaders (  )  ;", "assertEquals (  1  2  ,    readers . size (  )  )  ;", "assertEquals ( ByteArrayDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( ByteBufferDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( DataBufferDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( ResourceDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertStringDecoder ( getNextDecoder ( readers )  ,    true )  ;", "assertEquals ( FormHttpMessageReader . class ,    readers . get ( this . index . getAndIncrement (  )  )  . getClass (  )  )  ;", "assertEquals ( SynchronossPartHttpMessageReader . class ,    readers . get ( this . index . getAndIncrement (  )  )  . getClass (  )  )  ;", "assertEquals ( MultipartHttpMessageReader . class ,    readers . get ( this . index . getAndIncrement (  )  )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 JsonDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 SmileDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertEquals ( Jaxb 2 XmlDecoder . class ,    getNextDecoder ( readers )  . getClass (  )  )  ;", "assertStringDecoder ( getNextDecoder ( readers )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["defaultReaders"], "fileName": "org.springframework.http.codec.support.ServerCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageWriter <  ?  >  >    writers    =    this . configurer . getWriters (  )  ;", "assertEquals (  1  0  ,    writers . size (  )  )  ;", "assertEquals ( ByteArrayEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( ByteBufferEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( DataBufferEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( ResourceHttpMessageWriter . class ,    writers . get ( index . getAndIncrement (  )  )  . getClass (  )  )  ;", "assertStringEncoder ( getNextEncoder ( writers )  ,    true )  ;", "assertEquals ( Jackson 2 JsonEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( Jackson 2 SmileEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertEquals ( Jaxb 2 XmlEncoder . class ,    getNextEncoder ( writers )  . getClass (  )  )  ;", "assertSseWriter ( writers )  ;", "assertStringEncoder ( getNextEncoder ( writers )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["defaultWriters"], "fileName": "org.springframework.http.codec.support.ServerCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageReader <  ?  >    reader    =    readers . get ( this . index . getAndIncrement (  )  )  ;", "assertEquals ( DerHttpMessageReader . class ,    reader . getClass (  )  )  ;", "return    (  ( DerHttpMessageReader <  ?  >  )     ( reader )  )  . getDer (  )  ;", "}", "METHOD_END"], "methodName": ["getNextDecoder"], "fileName": "org.springframework.http.codec.support.ServerCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageWriter <  ?  >    writer    =    writers . get ( this . index . getAndIncrement (  )  )  ;", "assertEquals ( EnrHttpMessageWriter . class ,    writer . getClass (  )  )  ;", "return    (  ( EnrHttpMessageWriter <  ?  >  )     ( writer )  )  . getEnr (  )  ;", "}", "METHOD_END"], "methodName": ["getNextEncoder"], "fileName": "org.springframework.http.codec.support.ServerCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Jackson 2 JsonEncoder   encoder    =    new   Jackson 2 JsonEncoder (  )  ;", "this . c . defaultCodecs (  )  . jackson 2 JsonEncoder ( encoder )  ;", "assertSame ( encoder ,    this . c . getWriters (  )  . stream (  )  . filter (  (    writer )     -  >    ServerSentEventHttpMessageWriter . class . equals ( writer . getClass (  )  )  )  . map (  (    writer )     -  >     (  ( ServerSentEventHttpMessageWriter )     ( writer )  )  )  . findFirst (  )  . map ( ServerSentEventHttpMessageWriter :  : getEncoder )  . filter (  (    e )     -  >    e    =  =    encoder )  . orElse ( null )  )  ;", "}", "METHOD_END"], "methodName": ["jackson2EncoderOverride"], "fileName": "org.springframework.http.codec.support.ServerCodecConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "return   xmlEventFlux . flatMap ( new   Jaxb 2 XmlDecoder . SplitFunction ( desiredName )  )  ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoder"}, {"methodBody": ["METHOD_START", "{", "String   localPart ;", "String   namespaceUri ;", "if    ( outputClass . isAnnotationPresent ( XmlRootElement . class )  )     {", "XmlRootElement   annotation    =    outputClass . getAnnotation ( XmlRootElement . class )  ;", "localPart    =    annotation . name (  )  ;", "namespaceUri    =    annotation . namespace (  )  ;", "} else", "if    ( outputClass . isAnnotationPresent ( class )  )     {", "XmlType   annotation    =    outputClass . getAnnotation ( class )  ;", "localPart    =    annotation . name (  )  ;", "namespaceUri    =    annotation . namespace (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Output   class    [  \"     +     ( outputClass . getName (  )  )  )     +     \"  ]    is   neither   annotated   with    @ XmlRootElement   nor    @ XmlType \"  )  )  ;", "}", "if    (  . JAXB _ DEFAULT _ ANNOTATION _ VALUE . equals ( localPart )  )     {", "localPart    =    ClassUtils . getShortNameAsProperty ( outputClass )  ;", "}", "if    (  . JAXB _ DEFAULT _ ANNOTATION _ VALUE . equals ( namespaceUri )  )     {", "Package   outputClassPackage    =    outputClass . getPackage (  )  ;", "if    (  ( outputClassPackage    !  =    null )     &  &     ( outputClassPackage . isAnnotationPresent ( XmlSchema . class )  )  )     {", "XmlSchema   annotation    =    outputClassPackage . getAnnotation ( XmlSchema . class )  ;", "namespaceUri    =    annotation . namespace (  )  ;", "} else    {", "namespaceUri    =    XMLConstants . NULL _ NS _ URI ;", "}", "}", "return   new   QName ( namespaceUri ,    localPart )  ;", "}", "METHOD_END"], "methodName": ["toQName"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "Unmarshaller   unmarshaller    =    this . jaxbContexts . createUnmarshaller ( outputClass )  ;", "XMLEventReader   eventReader    =    StaxUtils . createXMLEventReader ( events )  ;", "if    ( outputClass . isAnnotationPresent ( XmlRootElement . class )  )     {", "return   unmarshaller . unmarshal ( eventReader )  ;", "} else    {", "JAXBElement <  ?  >    jaxbElement    =    unmarshaller . unmarshal ( eventReader ,    outputClass )  ;", "return   jaxbElement . getValue (  )  ;", "}", "}    catch    ( UnmarshalException   ex )     {", "throw   new   ingException (  (  \" Could   not   unmarshal   XML   to    \"     +    outputClass )  ,    ex )  ;", "}    catch    ( JAXBException   ex )     {", "throw   new   CodecException (  \" Invalid   JAXB   configuration \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["unmarshal"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoder"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( event . isCharacters (  )  )  ;", "assertEquals ( expectedData ,    event . asCharacters (  )  . getData (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCharacters"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( event . isEndElement (  )  )  ;", "assertEquals ( expectedLocalN ,    event . asEndElement (  )  . getN (  )  . getLocalPart (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEndElement"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( event . isStartElement (  )  )  ;", "assertEquals ( expectedLocalN ,    event . asStartElement (  )  . getN (  )  . getLocalPart (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertStartElement"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ XML )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . TEXT _ XML )  )  ;", "assertFalse ( this . decoder . canDecode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ JSON )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass (  . TypePojo . class )  ,    MediaType . APPLICATION _ XML )  )  ;", "assertFalse ( this . decoder . canDecode ( ResolvableType . forClass ( getClass (  )  )  ,    MediaType . APPLICATION _ XML )  )  ;", "}", "METHOD_END"], "methodName": ["canDecode"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer ( Jaxb 2 XmlDecoderTests . POJO _ CHILD )  )  ;", "Flux < Object >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass ( Pojo . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext ( new   Pojo (  \" foo \"  ,     \" bar \"  )  )  . expectNext ( new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeMultipleXmlRootElement"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer ( Jaxb 2 XmlDecoderTests . POJO _ CHILD )  )  ;", "Flux < Object >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass ( Jaxb 2 XmlDecoderTests . TypePojo . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext ( new   Jaxb 2 XmlDecoderTests . TypePojo (  \" foo \"  ,     \" bar \"  )  )  . expectNext ( new   Jaxb 2 XmlDecoderTests . TypePojo (  \" foofoo \"  ,     \" barbar \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeMultipleXmlTypeElement"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer ( Jaxb 2 XmlDecoderTests . POJO _ ROOT )  )  ;", "Flux < Object >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass ( Pojo . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext ( new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeSingleXmlRootElement"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer ( Jaxb 2 XmlDecoderTests . POJO _ ROOT )  )  ;", "Flux < Object >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass ( Jaxb 2 XmlDecoderTests . TypePojo . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext ( new   Jaxb 2 XmlDecoderTests . TypePojo (  \" foofoo \"  ,     \" barbar \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeSingleXmlTypeElement"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < XMLEvent >    xmlEvents    =    this . xmlEventDecoder . decode ( Flux . just ( stringBuffer ( Jaxb 2 XmlDecoderTests . POJO _ CHILD )  )  ,    null ,    null ,    Collections . emptyMap (  )  )  ;", "Flux < List < XMLEvent >  >    result    =    this . decoder . split ( xmlEvents ,    new   QName (  \" pojo \"  )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    events )     -  >     {", "assertEquals (  8  ,    events . size (  )  )  ;", "assertStartElement ( events . get (  0  )  ,     \" pojo \"  )  ;", "assertStartElement ( events . get (  1  )  ,     \" foo \"  )  ;", "assertCharacters ( events . get (  2  )  ,     \" foo \"  )  ;", "assertEndElement ( events . get (  3  )  ,     \" foo \"  )  ;", "assertStartElement ( events . get (  4  )  ,     \" bar \"  )  ;", "assertCharacters ( events . get (  5  )  ,     \" bar \"  )  ;", "assertEndElement ( events . get (  6  )  ,     \" bar \"  )  ;", "assertEndElement ( events . get (  7  )  ,     \" pojo \"  )  ;", "}  )  . consumeNextWith (  (    events )     -  >     {", "assertEquals (  8  ,    events . size (  )  )  ;", "assertStartElement ( events . get (  0  )  ,     \" pojo \"  )  ;", "assertStartElement ( events . get (  1  )  ,     \" foo \"  )  ;", "assertCharacters ( events . get (  2  )  ,     \" foofoo \"  )  ;", "assertEndElement ( events . get (  3  )  ,     \" foo \"  )  ;", "assertStartElement ( events . get (  4  )  ,     \" bar \"  )  ;", "assertCharacters ( events . get (  5  )  ,     \" barbar \"  )  ;", "assertEndElement ( events . get (  6  )  ,     \" bar \"  )  ;", "assertEndElement ( events . get (  7  )  ,     \" pojo \"  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["splitMultipleBranches"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < XMLEvent >    xmlEvents    =    this . xmlEventDecoder . decode ( Flux . just ( stringBuffer ( Jaxb 2 XmlDecoderTests . POJO _ ROOT )  )  ,    null ,    null ,    Collections . emptyMap (  )  )  ;", "Flux < List < XMLEvent >  >    result    =    this . decoder . split ( xmlEvents ,    new   QName (  \" pojo \"  )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    events )     -  >     {", "assertEquals (  8  ,    events . size (  )  )  ;", "assertStartElement ( events . get (  0  )  ,     \" pojo \"  )  ;", "assertStartElement ( events . get (  1  )  ,     \" foo \"  )  ;", "assertCharacters ( events . get (  2  )  ,     \" foofoo \"  )  ;", "assertEndElement ( events . get (  3  )  ,     \" foo \"  )  ;", "assertStartElement ( events . get (  4  )  ,     \" bar \"  )  ;", "assertCharacters ( events . get (  5  )  ,     \" barbar \"  )  ;", "assertEndElement ( events . get (  6  )  ,     \" bar \"  )  ;", "assertEndElement ( events . get (  7  )  ,     \" pojo \"  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["splitOneBranches"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   QName (  \" pojo \"  )  ,    this . decoder . toQName ( Pojo . class )  )  ;", "assertEquals ( new   QName (  \" pojo \"  )  ,    this . decoder . toQName (  . TypePojo . class )  )  ;", "assertEquals ( new   QName (  \" namespace \"  ,     \" name \"  )  ,    this . decoder . toQName ( XmlRootElementWithNameAndNamespace . class )  )  ;", "assertEquals ( new   QName (  \" namespace \"  ,     \" name \"  )  ,    this . decoder . toQName ( XmlRootElementWithName . class )  )  ;", "assertEquals ( new   QName (  \" namespace \"  ,     \" xmlRootElement \"  )  ,    this . decoder . toQName ( XmlRootElement . class )  )  ;", "assertEquals ( new   QName (  \" namespace \"  ,     \" name \"  )  ,    this . decoder . toQName ( XmlTypeWithNameAndNamespace . class )  )  ;", "assertEquals ( new   QName (  \" namespace \"  ,     \" name \"  )  ,    this . decoder . toQName ( XmlTypeWithName . class )  )  ;", "assertEquals ( new   QName (  \" namespace \"  ,     \" xmlType \"  )  ,    this . decoder . toQName ( XmlType . class )  )  ;", "}", "METHOD_END"], "methodName": ["toExpectedQName"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ XML )  )  ;", "assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . TEXT _ XML )  )  ;", "assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ JSON )  )  ;", "assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( Jaxb 2 XmlDe . TypePojo . class )  ,    MediaType . APPLICATION _ XML )  )  ;", "assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( getClass (  )  )  ,    MediaType . APPLICATION _ XML )  )  ;", "assertFalse ( this . encoder . canEncode ( NONE ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canEncode"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < Pojo >    source    =    Flux . just ( new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  ,    new   Pojo (  \" foofoofoo \"  ,     \" barbarbar \"  )  )  ;", "Flux < DataBuffer >    output    =    this . e . encode ( source ,    this . bufferFactory ,    ResolvableType . forClass ( Pojo . class )  ,    MediaType . APPLICATION _ XML ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith (  (    dataBuffer )     -  >     {", "try    {", "String   s    =    DataBufferTestUtils . dumpString ( dataBuffer ,    StandardCharsets . UTF _  8  )  ;", "assertThat ( s ,    isSimilarTo (  (  \"  <  ? xml   version =  '  1  .  0  '    encoding =  ' UTF -  8  '    standalone =  ' yes '  ?  >  \"     +     \"  < pojo >  < bar > barbar <  / bar >  < foo > foofoo <  / foo >  <  / pojo >  \"  )  )  )  ;", "}    finally    {", "DataBufferUtils . release ( dataBuffer )  ;", "}", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.http.codec.xml.Jaxb2XmlEncoderTests"}, {"methodBody": ["METHOD_START", "{", "JAXBContext   jaxbContext    =    getJaxbContext ( clazz )  ;", "return   jaxbContext . createMarshaller (  )  ;", "}", "METHOD_END"], "methodName": ["createMarshaller"], "fileName": "org.springframework.http.codec.xml.JaxbContextContainer"}, {"methodBody": ["METHOD_START", "{", "JAXBContext   jaxbContext    =    getJaxbContext ( clazz )  ;", "return   jaxbContext . createUnmarshaller (  )  ;", "}", "METHOD_END"], "methodName": ["createUnmarshaller"], "fileName": "org.springframework.http.codec.xml.JaxbContextContainer"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "JAXBContext   j    =    this . js . get ( clazz )  ;", "if    ( j    =  =    null )     {", "j    =    JAXBContext . newInstance ( clazz )  ;", "this . js . putIfAbsent ( clazz ,    j )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["getJaxbContext"], "fileName": "org.springframework.http.codec.xml.JaxbContextContainer"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( event . isCharacters (  )  )  ;", "assertEquals ( expectedData ,    event . asCharacters (  )  . getData (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCharacters"], "fileName": "org.springframework.http.codec.xml.XmlEventDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  ( event    +     \"    is   no   end   element \"  )  ,    event . isEndElement (  )  )  ;", "assertEquals ( expectedLocalName ,    event . asEndElement (  )  . getName (  )  . getLocalPart (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEndElement"], "fileName": "org.springframework.http.codec.xml.XmlEventDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( event . isStartElement (  )  )  ;", "assertEquals ( expectedLocalName ,    event . asStartElement (  )  . getName (  )  . getLocalPart (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertStartElement"], "fileName": "org.springframework.http.codec.xml.XmlEventDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < XMLEvent >    events    =    this . decoder . decode ( Flux . just ( stringBuffer ( XmlEventDecoderTests . XML )  )  ,    null ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( events )  . consumeNextWith (  (    e )     -  >    assertTrue ( e . isStartDocument (  )  )  )  . consumeNextWith (  (    e )     -  >    assertStartElement ( e ,     \" pojo \"  )  )  . consumeNextWith (  (    e )     -  >    assertStartElement ( e ,     \" foo \"  )  )  . consumeNextWith (  (    e )     -  >    assertCharacters ( e ,     \" foofoo \"  )  )  . consumeNextWith (  (    e )     -  >    assertEndElement ( e ,     \" foo \"  )  )  . consumeNextWith (  (    e )     -  >    assertStartElement ( e ,     \" bar \"  )  )  . consumeNextWith (  (    e )     -  >    assertCharacters ( e ,     \" barbar \"  )  )  . consumeNextWith (  (    e )     -  >    assertEndElement ( e ,     \" bar \"  )  )  . consumeNextWith (  (    e )     -  >    assertEndElement ( e ,     \" pojo \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toXMLEventsAalto"], "fileName": "org.springframework.http.codec.xml.XmlEventDecoderTests"}, {"methodBody": ["METHOD_START", "{", "decoder . useAalto    =    false ;", "Flux < XMLEvent >    events    =    this . decoder . decode ( Flux . just ( stringBuffer (  . XML )  )  ,    null ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( events )  . consumeNextWith (  (    e )     -  >    assertTrue ( e . isStartDocument (  )  )  )  . consumeNextWith (  (    e )     -  >    assertStartElement ( e ,     \" pojo \"  )  )  . consumeNextWith (  (    e )     -  >    assertStartElement ( e ,     \" foo \"  )  )  . consumeNextWith (  (    e )     -  >    assertCharacters ( e ,     \" foofoo \"  )  )  . consumeNextWith (  (    e )     -  >    assertEndElement ( e ,     \" foo \"  )  )  . consumeNextWith (  (    e )     -  >    assertStartElement ( e ,     \" bar \"  )  )  . consumeNextWith (  (    e )     -  >    assertCharacters ( e ,     \" barbar \"  )  )  . consumeNextWith (  (    e )     -  >    assertEndElement ( e ,     \" bar \"  )  )  . consumeNextWith (  (    e )     -  >    assertEndElement ( e ,     \" pojo \"  )  )  . consumeNextWith (  (    e )     -  >    assertTrue ( e . isEndDocument (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toXMLEventsNonAalto"], "fileName": "org.springframework.http.codec.xml.XmlEventDecoderTests"}, {"methodBody": ["METHOD_START", "{", "final   HttpHeaders   headers    =    outputMessage . getHeaders (  )  ;", "addDefaultHeaders ( headers ,    t ,    contentType )  ;", "if    ( outputMessage   instanceof   StreamingHttpOutputMessage )     {", "StreamingHttpOutputMessage   streamingOutputMessage    =     (  ( StreamingHttpOutputMessage )     ( outputMessage )  )  ;", "streamingOutputMessage . setBody (  (    outputStream )     -  >    writeInternal ( t ,    type ,    new   HttpOutputMessage (  )     {", "@ Override", "public   OutputStream   getBody (  )     {", "return   outputStream ;", "}", "@ Override", "public   HttpHeaders   getHeaders (  )     {", "return   headers ;", "}", "}  )  )  ;", "} else    {", "writeInternal ( t ,    type ,    outputMessage )  ;", "outputMessage . getBody (  )  . flush (  )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.AbstractGenericHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( headers . getContentType (  )  )     =  =    null )     {", "MediaTypetentTypeToUse    = tentType ;", "if    (  ( tentType    =  =    null )     |  |    tentType . isWildcardType (  )  )  )     |  |    tentType . isWildcardSubtype (  )  )  )     {", "tentTypeToUse    =    getDefaultContentType ( t )  ;", "} else", "if    ( MediaType . APPLICATION _ OCTET _ STREAM . equalstentType )  )     {", "MediaType   mediaType    =    getDefaultContentType ( t )  ;", "tentTypeToUse    =     ( mediaType    !  =    null )     ?    mediaType    : tentTypeToUse ;", "}", "if   tentTypeToUse    !  =    null )     {", "if    ( tentTypeToUse . getCharset (  )  )     =  =    null )     {", "Charset   defaultCharset    =    getDefaultCharset (  )  ;", "if    ( defaultCharset    !  =    null )     {", "tentTypeToUse    =    new   MediaTypetentTypeToUse ,    defaultCharset )  ;", "}", "}", "headers . setContentTypetentTypeToUse )  ;", "}", "}", "if    (  (  ( headers . getContentLength (  )  )     <     0  )     &  &     (  !  ( headerstainsKey ( HttpHeaders . TRANSFER _ ENCODING )  )  )  )     {", "LongtentLength    =    getContentLength ( t ,    headers . getContentType (  )  )  ;", "if   tentLength    !  =    null )     {", "headers . setContentLengthtentLength )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addDefaultHeaders"], "fileName": "org.springframework.http.converter.AbstractHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( mediaType    =  =    null )     {", "return   true ;", "}", "for    ( MediaType   suppodMediaType    :    getSuppodMediaTypes (  )  )     {", "if    ( suppodMediaType . includes ( mediaType )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.AbstractHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mediaType    =  =    null )     |  |     ( MediaType . ALL . equals ( mediaType )  )  )     {", "return   true ;", "}", "for    ( MediaType   suppodMediaType    :    getSuppodMediaTypes (  )  )     {", "if    ( suppodMediaType . isCompatibleWith ( mediaType )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.AbstractHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.http.converter.AbstractHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultCharset ;", "}", "METHOD_END"], "methodName": ["getDefaultCharset"], "fileName": "org.springframework.http.converter.AbstractHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "List < MediaType >    mediaTypes    =    getSupportedMediaTypes (  )  ;", "return    !  ( mediaTypes . isEmpty (  )  )     ?    mediaTypes . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDefaultContentType"], "fileName": "org.springframework.http.converter.AbstractHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . defaultCharset    =    defaultCharset ;", "}", "METHOD_END"], "methodName": ["setDefaultCharset"], "fileName": "org.springframework.http.converter.AbstractHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( supportedMediaTypes ,     \" MediaType   List   must   not   be   empty \"  )  ;", "this . supportedMediaTypes    =    new   ArrayList <  >  ( supportedMediaTypes )  ;", "}", "METHOD_END"], "methodName": ["setSupportedMediaTypes"], "fileName": "org.springframework.http.converter.AbstractHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cacheDir )     !  =    null )     {", "return   new   FileCacheInputStream ( is ,    cacheDir )  ;", "} else    {", "return   new   MemoryCacheInputStream ( is )  ;", "}", "}", "METHOD_END"], "methodName": ["createImageInputStream"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cacheDir )     !  =    null )     {", "return   new   FileCacheOutputStream ( os ,    this . cacheDir )  ;", "} else    {", "return   new   MemoryCacheOutputStream ( os )  ;", "}", "}", "METHOD_END"], "methodName": ["createImageOutputStream"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( contentType    =  =    null )     |  |     ( contentType . isWildcardType (  )  )  )     |  |     ( contentType . isWildcardSubtype (  )  )  )     {", "contentType    =    getDefaultContentType (  )  ;", "}", "Assert . notNull ( contentType ,     (  \" Could   not   select   Content - Type .     \"     +     \" Please   specify   one   through   the    ' defaultContentType '    property .  \"  )  )  ;", "return   contentType ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultContentType ;", "}", "METHOD_END"], "methodName": ["getDefaultContentType"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( mediaType    =  =    null )     {", "return   true ;", "}", "Iterator < Reader >    imageReaders    =    IO . getReadersByMIMEType ( mediaType . toString (  )  )  ;", "return   imageReaders . hasNext (  )  ;", "}", "METHOD_END"], "methodName": ["isReadable"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mediaType    =  =    null )     |  |     ( MediaType . ALL . equals ( mediaType )  )  )     {", "return   true ;", "}", "Iterator < Writer >    imageWriters    =    IO . getWritersByMIMEType ( mediaType . toString (  )  )  ;", "return   imageWriters . hasNext (  )  ;", "}", "METHOD_END"], "methodName": ["isWritable"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cacheDir ,     \"  ' cacheDir '    must   not   be   null \"  )  ;", "Assert . isTrue ( cacheDir . isDirectory (  )  ,     \"  ' cacheDir '    is   not   a   directory \"  )  ;", "this . cacheDir    =    cacheDir ;", "}", "METHOD_END"], "methodName": ["setCacheDir"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( defaultContentType    !  =    null )     {", "Iterator < Writer >    imageWriters    =    IO . getWritersByMIMEType ( defaultContentType . toString (  )  )  ;", "if    (  !  ( imageWriters . hasNext (  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Content - Type    [  \"     +    defaultContentType )     +     \"  ]    is   not   supported   by   the   Java      I / O   API \"  )  )  ;", "}", "}", "this . defaultContentType    =    defaultContentType ;", "}", "METHOD_END"], "methodName": ["setDefaultContentType"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "ImageOutputStream   imageOutputStream    =    null ;", "ImageWriter   imageWriter    =    null ;", "try    {", "Iterator < ImageWriter >    imageWriters    =    ImageIO . getImageWritersByMIMEType ( contentType . toString (  )  )  ;", "if    ( imageWriters . hasNext (  )  )     {", "imageWriter    =    imageWriters . next (  )  ;", "ImageWriteParam   iwp    =    imageWriter . getDefaultWriteParam (  )  ;", "process ( iwp )  ;", "imageOutputStream    =    createImageOutputStream ( body )  ;", "imageWriter . setOutput ( imageOutputStream )  ;", "imageWriter . write ( null ,    new   IIOImage ( image ,    null ,    null )  ,    iwp )  ;", "} else    {", "throw   new   NotWritableException (  (  (  \" Could   not   find   ImageWriter   for   Content - Type    [  \"     +    contentType )     +     \"  ]  \"  )  )  ;", "}", "}    finally    {", "if    ( imageWriter    !  =    null )     {", "imageWriter . dispose (  )  ;", "}", "if    ( imageOutputStream    !  =    null )     {", "try    {", "imageOutputStream . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["writeInternal"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Image   not   supported \"  ,    converter . canRead ( BufferedImage . class ,    null )  )  ;", "assertTrue (  \" Image   not   supported \"  ,    converter . canRead ( BufferedImage . class ,    new   MediaType (  \" image \"  ,     \" png \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Image   not   supported \"  ,    converter . canWrite ( BufferedImage . class ,    null )  )  ;", "assertTrue (  \" Image   not   supported \"  ,    converter . canWrite ( BufferedImage . class ,    new   MediaType (  \" image \"  ,     \" png \"  )  )  )  ;", "assertTrue (  \" Image   not   supported \"  ,    converter . canWrite ( BufferedImage . class ,    new   MediaType (  \"  *  \"  ,     \"  *  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   logo    =    new   ClassPathResource (  \" logo . jpg \"  ,    BufferedImageHttpMessageConverterTests . class )  ;", "byte [  ]    body    =    FileCopyUtils . copyToByteArray ( logo . getInputStream (  )  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" image \"  ,     \" jpeg \"  )  )  ;", "BufferedImage   result    =    converter . read ( BufferedImage . class ,    inputMessage )  ;", "assertEquals (  \" Invalid   height \"  ,     5  0  0  ,    result . getHeight (  )  )  ;", "assertEquals (  \" Invalid   width \"  ,     7  5  0  ,    result . getWidth (  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter    =    new   BufferedImageHttpMessageConverter (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   logo    =    new   ClassPathResource (  \" logo . jpg \"  ,    BufferedImageHttpMessageConverterTests . class )  ;", "BufferedImage   body    =    ImageIO . read ( logo . getFile (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "MediaType   contentType    =    new   MediaType (  \" image \"  ,     \" png \"  )  ;", "converter . write ( body ,    contentType ,    outputMessage )  ;", "assertEquals (  \" Invalid   content   type \"  ,    contentType ,    outputMessage . getWrittenHeaders (  )  . getContentType (  )  )  ;", "assertTrue (  \" Invalid   size \"  ,     (  ( outputMessage . getBodyAsBytes (  )  . length )     >     0  )  )  ;", "BufferedImage   result    =    ImageIO . read ( new   ByteArrayInputStream ( outputMessage . getBodyAsBytes (  )  )  )  ;", "assertEquals (  \" Invalid   height \"  ,     5  0  0  ,    result . getHeight (  )  )  ;", "assertEquals (  \" Invalid   width \"  ,     7  5  0  ,    result . getWidth (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   logo    =    new   ClassPathResource (  \" logo . jpg \"  ,    BufferedImageHttpMessageConverterTests . class )  ;", "MediaType   contentType    =    new   MediaType (  \" image \"  ,     \" png \"  )  ;", "converter . setDefaultContentType ( contentType )  ;", "BufferedImage   body    =    ImageIO . read ( logo . getFile (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( body ,    new   MediaType (  \"  *  \"  ,     \"  *  \"  )  ,    outputMessage )  ;", "assertEquals (  \" Invalid   content   type \"  ,    contentType ,    outputMessage . getWrittenHeaders (  )  . getContentType (  )  )  ;", "assertTrue (  \" Invalid   size \"  ,     (  ( outputMessage . getBodyAsBytes (  )  . length )     >     0  )  )  ;", "BufferedImage   result    =    ImageIO . read ( new   ByteArrayInputStream ( outputMessage . getBodyAsBytes (  )  )  )  ;", "assertEquals (  \" Invalid   height \"  ,     5  0  0  ,    result . getHeight (  )  )  ;", "assertEquals (  \" Invalid   width \"  ,     7  5  0  ,    result . getWidth (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeDefaultContentType"], "fileName": "org.springframework.http.converter.BufferedImageHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( byte [  ]  . class ,    new   MediaType (  \" application \"  ,     \" octet - stream \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.ByteArrayHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( byte [  ]  . class ,    new   MediaType (  \" application \"  ,     \" octet - stream \"  )  )  )  ;", "assertTrue ( converter . canWrite ( byte [  ]  . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.ByteArrayHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =    new   byte [  ]  {     1  ,     2     }  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" octet - stream \"  )  )  ;", "byte [  ]    result    =    read ( byte [  ]  . class ,    inputMessage )  ;", "assertArrayEquals (  \" Invalid   result \"  ,    body ,    result )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.ByteArrayHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter    =    new   ByteArrayHttpMessageConverter (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.ByteArrayHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "byte [  ]    body    =    new   byte [  ]  {     1  ,     2     }  ;", "write ( body ,    null ,    outputMessage )  ;", "assertArrayEquals (  \" Invalid   result \"  ,    body ,    outputMessage . getBodyAsBytes (  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" octet - stream \"  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   content - length \"  ,     2  ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.ByteArrayHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( partConverter ,     \"  ' partConverter '    must   not   be   null \"  )  ;", "this . partConverters . add ( partConverter )  ;", "}", "METHOD_END"], "methodName": ["addPartConverter"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( HttpMessageConverter <  ?  >    candidate    :    this . partConverters )     {", "if    ( candidate   instanceof   AbstractHttpMessageConverter )     {", "AbstractHttpMessageConverter <  ?  >    converter    =     (  ( AbstractHttpMessageConverter <  ?  >  )     ( candidate )  )  ;", "if    (  ( converter . getDefaultCharset (  )  )     !  =    null )     {", "converter . setDefaultCharset ( this . charset )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["applyDefaultCharset"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   MimeTypeUtils . generateMultipartBoundary (  )  ;", "}", "METHOD_END"], "methodName": ["generateMultipartBoundary"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( part   instanceof   Resource )     {", "Resource   resource    =     (  ( Resource )     ( part )  )  ;", "String   filename    =    resource . getFilename (  )  ;", "if    (  ( filename    !  =    null )     &  &     (  ( this . multipartCharset )     !  =    null )  )     {", "filename    =     . MimeDelegate . encode ( filename ,    this . multipartCharset . name (  )  )  ;", "}", "return   filename ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getFilename"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   part   instanceof   HttpEntity    ?     (  ( HttpEntity <  ?  >  )     ( part )  )     :    new   HttpEntity <  >  ( part )  ;", "}", "METHOD_END"], "methodName": ["getHttpEntity"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . multipartCharset )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isFilenameCharsetSet"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( contentType    !  =    null )     {", "return   MediaType . MULTIPART _ FORM _ DATA . includes ( contentType )  ;", "}", "for    ( St   name    :    map . keySet (  )  )     {", "for    ( Object   value    :    map . get ( name )  )     {", "if    (  ( value    !  =    null )     &  &     (  !  ( value   instanceof   St )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isMultipart"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( charset    !  =     ( this . charset )  )     {", "this . charset    =     ( charset    !  =    null )     ?    charset    :     . DEFAULT _ CHARSET ;", "applyDefaultCharset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setCharset"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . multipartCharset    =    charset ;", "}", "METHOD_END"], "methodName": ["setMultipartCharset"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( partConverters ,     \"  ' partConverters '    must   not   be   empty \"  )  ;", "this . partConverters    =    partConverters ;", "}", "METHOD_END"], "methodName": ["setPartConverters"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . supportedMediaTypes    =    supportedMediaTypes ;", "}", "METHOD_END"], "methodName": ["setSupportedMediaTypes"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "os . write (  '  -  '  )  ;", "os . write (  '  -  '  )  ;", "os . write ( boundary )  ;", ". writeNewLine ( os )  ;", "}", "METHOD_END"], "methodName": ["writeBoundary"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "os . write (  '  -  '  )  ;", "os . write (  '  -  '  )  ;", "os . write ( boundary )  ;", "os . write (  '  -  '  )  ;", "os . write (  '  -  '  )  ;", ". writeNewLine ( os )  ;", "}", "METHOD_END"], "methodName": ["writeEnd"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "contentType    =     ( contentType    !  =    null )     ?    contentType    :    FormHttpMessageConverter . DEFAULT _ FORM _ DATA _ MEDIA _ TYPE ;", "Charset   charset    =    contentType . getCharset (  )  ;", "if    ( charset    =  =    null )     {", "charset    =    this . charset ;", "contentType    =    new   MediaType ( contentType ,    charset )  ;", "}", "outputMessage . getHeaders (  )  . setContentType ( contentType )  ;", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( Iterator < String >    nameIterator    =    form . keySet (  )  . iterator (  )  ;    nameIterator . hasNext (  )  ;  )     {", "String   name    =    nameIterator . next (  )  ;", "for    ( Iterator < String >    valueIterator    =    form . get ( name )  . iterator (  )  ;    valueIterator . hasNext (  )  ;  )     {", "String   value    =    valueIterator . next (  )  ;", "builder . append ( URLEncoder . encode ( name ,    charset . name (  )  )  )  ;", "if    ( value    !  =    null )     {", "builder . append (  '  =  '  )  ;", "builder . append ( URLEncoder . encode ( value ,    charset . name (  )  )  )  ;", "if    ( valueIterator . hasNext (  )  )     {", "builder . append (  '  &  '  )  ;", "}", "}", "}", "if    ( nameIterator . hasNext (  )  )     {", "builder . append (  '  &  '  )  ;", "}", "}", "final   byte [  ]    bytes    =    builder . toString (  )  . getBytes ( charset )  ;", "outputMessage . getHeaders (  )  . setContentLength ( bytes . length )  ;", "if    ( outputMessage   instanceof   StreamingHttpOutputMessage )     {", "StreamingHttpOutputMessage   streamingOutputMessage    =     (  ( StreamingHttpOutputMessage )     ( outputMessage )  )  ;", "streamingOutputMessage . setBody (  (    outputStream )     -  >    StreamUtils . copy ( bytes ,    outputStream )  )  ;", "} else    {", "StreamUtils . copy ( bytes ,    outputMessage . getBody (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeForm"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "final   byte [  ]    boundary    =    generateMultipartBoundary (  )  ;", "Map < String ,    String >    parameters    =    new   HashMap <  >  (  2  )  ;", "parameters . put (  \" boundary \"  ,    new   String ( boundary ,     \" US - ASCII \"  )  )  ;", "if    (  !  ( isFilenameCharsetSet (  )  )  )     {", "parameters . put (  \" charset \"  ,    this . charset . name (  )  )  ;", "}", "MediaType   contentType    =    new   MediaType ( MediaType . MULTIPART _ FORM _ DATA ,    parameters )  ;", "HttpHeaders   headers    =    outputMessage . getHeaders (  )  ;", "headers . setContentType ( contentType )  ;", "if    ( outputMessage   instanceof   StreamingHttpOutputMessage )     {", "StreamingHttpOutputMessage   streamingOutputMessage    =     (  ( StreamingHttpOutputMessage )     ( outputMessage )  )  ;", "streamingOutputMessage . setBody (  (    outputStream )     -  >     {", "writeParts ( outputStream ,    parts ,    boundary )  ;", ". writeEnd ( outputStream ,    boundary )  ;", "}  )  ;", "} else    {", "writeParts ( outputMessage . getBody (  )  ,    parts ,    boundary )  ;", ". writeEnd ( outputMessage . getBody (  )  ,    boundary )  ;", "}", "}", "METHOD_END"], "methodName": ["writeMultipart"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "os . write (  '  \\ r '  )  ;", "os . write (  '  \\ n '  )  ;", "}", "METHOD_END"], "methodName": ["writeNewLine"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Object   partBody    =    partEntity . getBody (  )  ;", "if    ( partBody    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" Empty   body   for   part    '  \"     +    name )     +     \"  '  :     \"  )     +    partEntity )  )  ;", "}", "Class <  ?  >    partType    =    partBody . getClass (  )  ;", "HttpHeaders   partHeaders    =    partEntity . getHeaders (  )  ;", "MediaType   partContentType    =    partHeaders . getContentType (  )  ;", "for    ( HttpMessageConverter <  ?  >    messageConverter    :    this . partConverters )     {", "if    ( messageConverter . canWrite ( partType ,    partContentType )  )     {", "Charset   charset    =     ( isFilenameCharsetSet (  )  )     ?    StandardCharsets . US _ ASCII    :    this . charset ;", "HttpOutputMessage   multipartMessage    =    new    . MultipartHttpOutputMessage ( os ,    charset )  ;", "multipartMessage . getHeaders (  )  . setContentDispositionFormData ( name ,    getFilename ( partBody )  )  ;", "if    (  !  ( partHeaders . isEmpty (  )  )  )     {", "multipartMessage . getHeaders (  )  . putAll ( partHeaders )  ;", "}", "(  ( HttpMessageConverter < Object >  )     ( messageConverter )  )  . write ( partBody ,    partContentType ,    multipartMessage )  ;", "return ;", "}", "}", "throw   new   HttpMessageNotWritableException (  (  (  (  \" Could   not   write   request :    no   suitable   HttpMessageConverter    \"     +     \" found   for   request   type    [  \"  )     +     ( partType . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["writePart"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    List < Object >  >    entry    :    parts . entrySet (  )  )     {", "String   name    =    entry . getKey (  )  ;", "for    ( Object   part    :    entry . getValue (  )  )     {", "if    ( part    !  =    null )     {", "writeBoundary ( os ,    boundary )  ;", "writePart ( name ,    getHttpEntity ( part )  ,    os )  ;", ". writeNewLine ( os )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["writeParts"], "fileName": "org.springframework.http.converter.FormHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canRead ( MultiValueMap . class ,    new   MediaType (  \" application \"  ,     \" x - www - form - urlencoded \"  )  )  )  ;", "assertFalse ( this . converter . canRead ( MultiValueMap . class ,    new   MediaType (  \" multipart \"  ,     \" form - data \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.FormHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canWrite ( MultiValueMap . class ,    new   MediaType (  \" application \"  ,     \" x - www - form - urlencoded \"  )  )  )  ;", "assertTrue ( this . converter . canWrite ( MultiValueMap . class ,    new   MediaType (  \" multipart \"  ,     \" form - data \"  )  )  )  ;", "assertTrue ( this . converter . canWrite ( MultiValueMap . class ,    new   MediaType (  \" multipart \"  ,     \" form - data \"  ,    StandardCharsets . UTF _  8  )  )  )  ;", "assertTrue ( this . converter . canWrite ( MultiValueMap . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.FormHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes ( StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" x - www - form - urlencoded \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "MultiValueMap < String ,    String >    result    =    thisread ( null ,    inputMessage )  ;", "assertEquals (  \" Invalid   result \"  ,     3  ,    result . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    1  \"  ,    result . getFirst (  \" name    1  \"  )  )  ;", "List < String >    values    =    result . get (  \" name    2  \"  )  ;", "assertEquals (  \" Invalid   result \"  ,     2  ,    values . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    2  +  1  \"  ,    values . get (  0  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    2  +  2  \"  ,    values . get (  1  )  )  ;", "assertNull (  \" Invalid   result \"  ,    result . getFirst (  \" name    3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readForm"], "fileName": "org.springframework.http.converter.FormHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    body    =    new   LinkedMultiValueMap (  )  ;", "body . set (  \" name    1  \"  ,     \" value    1  \"  )  ;", "body . add (  \" name    2  \"  ,     \" value    2  +  1  \"  )  ;", "body . add (  \" name    2  \"  ,     \" value    2  +  2  \"  )  ;", "body . add (  \" name    3  \"  ,    null )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "this . converter . write ( body ,    MediaType . APPLICATION _ FORM _ URLENCODED ,    outputMessage )  ;", "assertEquals (  \" Invalid   result \"  ,     \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,     \" application / x - www - form - urlencoded ; charset = UTF -  8  \"  ,    outputMessage . getHeaders (  )  . getContentType (  )  . toString (  )  )  ;", "assertEquals (  \" Invalid   content - length \"  ,    outputMessage . getBodyAsBytes (  )  . length ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeForm"], "fileName": "org.springframework.http.converter.FormHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    parts    =    new   LinkedMultiValueMap (  )  ;", "parts . add (  \" name    1  \"  ,     \" value    1  \"  )  ;", "parts . add (  \" name    2  \"  ,     \" value    2  +  1  \"  )  ;", "parts . add (  \" name    2  \"  ,     \" value    2  +  2  \"  )  ;", "parts . add (  \" name    3  \"  ,    null )  ;", "Resource   logo    =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )  ;", "parts . add (  \" logo \"  ,    logo )  ;", "Resource   utf 8     =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )     {", "@ Override", "public   String   getFilename (  )     {", "return    \" Hall \\ u 0  0 f 6 le . jpg \"  ;", "}", "}  ;", "parts . add (  \" utf 8  \"  ,    utf 8  )  ;", "Source   xml    =    new   StreamSource ( new   StringReader (  \"  < root >  < child /  >  <  / root >  \"  )  )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( MediaType . TEXT _ XML )  ;", "HttpEntity < Source >    entity    =    new   HttpEntity ( xml ,    entityHeaders )  ;", "parts . add (  \" xml \"  ,    entity )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "this . converter . write ( parts ,    new   MediaType (  \" multipart \"  ,     \" form - data \"  ,    StandardCharsets . UTF _  8  )  ,    outputMessage )  ;", "final   MediaType   contentType    =    outputMessage . getHeaders (  )  . getContentType (  )  ;", "assertNotNull (  \" No   boundary   found \"  ,    contentType . getParameter (  \" boundary \"  )  )  ;", "FileItemFactory   fileItemFactory    =    new   DiskFileItemFactory (  )  ;", "FileUpload   fileUpload    =    new   FileUpload ( fileItemFactory )  ;", "RequestContext   requestContext    =    new    . MockHttpOutputMessageRequestContext ( outputMessage )  ;", "List < FileItem >    items    =    fileUpload . parseRequest ( requestContext )  ;", "assertEquals (  6  ,    items . size (  )  )  ;", "FileItem   item    =    items . get (  0  )  ;", "assertTrue ( item . isFormField (  )  )  ;", "assertEquals (  \" name    1  \"  ,    item . getFieldName (  )  )  ;", "assertEquals (  \" value    1  \"  ,    item . getString (  )  )  ;", "item    =    items . get (  1  )  ;", "assertTrue ( item . isFormField (  )  )  ;", "assertEquals (  \" name    2  \"  ,    item . getFieldName (  )  )  ;", "assertEquals (  \" value    2  +  1  \"  ,    item . getString (  )  )  ;", "item    =    items . get (  2  )  ;", "assertTrue ( item . isFormField (  )  )  ;", "assertEquals (  \" name    2  \"  ,    item . getFieldName (  )  )  ;", "assertEquals (  \" value    2  +  2  \"  ,    item . getString (  )  )  ;", "item    =    items . get (  3  )  ;", "assertFalse ( item . isFormField (  )  )  ;", "assertEquals (  \" logo \"  ,    item . getFieldName (  )  )  ;", "assertEquals (  \" logo . jpg \"  ,    item . getName (  )  )  ;", "assertEquals (  \" image / jpeg \"  ,    item . getContentType (  )  )  ;", "assertEquals ( logo . getFile (  )  . length (  )  ,    item . getSize (  )  )  ;", "item    =    items . get (  4  )  ;", "assertFalse ( item . isFormField (  )  )  ;", "assertEquals (  \" utf 8  \"  ,    item . getFieldName (  )  )  ;", "assertEquals (  \" Hall \\ u 0  0 f 6 le . jpg \"  ,    item . getName (  )  )  ;", "assertEquals (  \" image / jpeg \"  ,    item . getContentType (  )  )  ;", "assertEquals ( logo . getFile (  )  . length (  )  ,    item . getSize (  )  )  ;", "item    =    items . get (  5  )  ;", "assertEquals (  \" xml \"  ,    item . getFieldName (  )  )  ;", "assertEquals (  \" text / xml \"  ,    item . getContentType (  )  )  ;", "verify ( outputMessage . getBody (  )  ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["writeMultipart"], "fileName": "org.springframework.http.converter.FormHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "FormHttpMessageConverterTests . MyBean   myBean    =    new   FormHttpMessageConverterTests . MyBean (  )  ;", "myBean . setString (  \" foo \"  )  ;", "MultiValueMap < String ,    Object >    parts    =    new   LinkedMultiValueMap (  )  ;", "parts . add (  \" part 1  \"  ,    myBean )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( MediaType . TEXT _ XML )  ;", "HttpEntity < FormHttpMessageConverterTests . MyBean >    entity    =    new   HttpEntity ( myBean ,    entityHeaders )  ;", "parts . add (  \" part 2  \"  ,    entity )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "this . converter . setMultipartCharset ( StandardCharsets . UTF _  8  )  ;", "this . converter . write ( parts ,    new   MediaType (  \" multipart \"  ,     \" form - data \"  ,    StandardCharsets . UTF _  8  )  ,    outputMessage )  ;", "final   MediaType   contentType    =    outputMessage . getHeaders (  )  . getContentType (  )  ;", "assertNotNull (  \" No   boundary   found \"  ,    contentType . getParameter (  \" boundary \"  )  )  ;", "FileItemFactory   fileItemFactory    =    new   DiskFileItemFactory (  )  ;", "FileUpload   fileUpload    =    new   FileUpload ( fileItemFactory )  ;", "RequestContext   requestContext    =    new   FormHttpMessageConverterTests . MockHttpOutputMessageRequestContext ( outputMessage )  ;", "List < FileItem >    items    =    fileUpload . parseRequest ( requestContext )  ;", "assertEquals (  2  ,    items . size (  )  )  ;", "FileItem   item    =    items . get (  0  )  ;", "assertTrue ( item . isFormField (  )  )  ;", "assertEquals (  \" part 1  \"  ,    item . getFieldName (  )  )  ;", "assertEquals (  \"  {  \\  \" string \\  \"  :  \\  \" foo \\  \"  }  \"  ,    item . getString (  )  )  ;", "item    =    items . get (  1  )  ;", "assertTrue ( item . isFormField (  )  )  ;", "assertEquals (  \" part 2  \"  ,    item . getFieldName (  )  )  ;", "assertThat ( item . getString (  )  ,    allOf ( startsWith (  \"  < MyBean \"  )  ,    endsWith (  \"  >  < string > foo <  / string >  <  / MyBean >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeMultipartOrder"], "fileName": "org.springframework.http.converter.FormHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   mediaType    =    new   MediaType (  \" foo \"  ,     \" bar \"  )  ;", "HttpMessageConverter <  . MyType >    converter    =    new    . MyHttpMessageConverter <  >  ( mediaType )  ;", "assertTrue ( converter . canRead (  . MyType . class ,    mediaType )  )  ;", "assertFalse ( converter . canRead (  . MyType . class ,    new   MediaType (  \" foo \"  ,     \"  *  \"  )  )  )  ;", "assertFalse ( converter . canRead (  . MyType . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   mediaType    =    new   MediaType (  \" foo \"  )  ;", "HttpMessageConverter <  . MyType >    converter    =    new    . MyHttpMessageConverter <  >  ( mediaType )  ;", "assertTrue ( converter . canRead (  . MyType . class ,    new   MediaType (  \" foo \"  ,     \" bar \"  )  )  )  ;", "assertTrue ( converter . canRead (  . MyType . class ,    new   MediaType (  \" foo \"  ,     \"  *  \"  )  )  )  ;", "assertFalse ( converter . canRead (  . MyType . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canReadWithWildcardSubtype"], "fileName": "org.springframework.http.converter.HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   mediaType    =    new   MediaType (  \" foo \"  ,     \" bar \"  )  ;", "HttpMessageConverter <  . MyType >    converter    =    new    . MyHttpMessageConverter <  >  ( mediaType )  ;", "assertTrue ( converter . canWrite (  . MyType . class ,    mediaType )  )  ;", "assertTrue ( converter . canWrite (  . MyType . class ,    new   MediaType (  \" foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( converter . canWrite (  . MyType . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   mediaType    =    new   MediaType (  \" foo \"  )  ;", "HttpMessageConverter <  . MyType >    converter    =    new    . MyHttpMessageConverter <  >  ( mediaType )  ;", "assertTrue ( converter . canWrite (  . MyType . class ,    new   MediaType (  \" foo \"  ,     \" bar \"  )  )  )  ;", "assertTrue ( converter . canWrite (  . MyType . class ,    new   MediaType (  \" foo \"  ,     \"  *  \"  )  )  )  ;", "assertTrue ( converter . canWrite (  . MyType . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWriteWithWildcardInSupportedSubtype"], "fileName": "org.springframework.http.converter.HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . stringHttpMessageConverter . setWriteAcceptCharset ( writeAcceptCharset )  ;", "}", "METHOD_END"], "methodName": ["setWriteAcceptCharset"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . converter . canRead ( Math . class ,    null )  )  ;", "assertFalse ( this . converter . canRead ( Resource . class ,    null )  )  ;", "assertTrue ( this . converter . canRead ( Locale . class ,    null )  )  ;", "assertTrue ( this . converter . canRead ( BigInteger . class ,    null )  )  ;", "assertFalse ( this . converter . canRead ( BigInteger . class ,    MediaType . TEXT _ HTML )  )  ;", "assertFalse ( this . converter . canRead ( BigInteger . class ,    MediaType . TEXT _ XML )  )  ;", "assertFalse ( this . converter . canRead ( BigInteger . class ,    MediaType . APPLICATION _ XML )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . converter . canWrite ( Math . class ,    null )  )  ;", "assertFalse ( this . converter . canWrite ( Resource . class ,    null )  )  ;", "assertTrue ( this . converter . canWrite ( Locale . class ,    null )  )  ;", "assertTrue ( this . converter . canWrite ( Double . class ,    null )  )  ;", "assertFalse ( this . converter . canWrite ( BigInteger . class ,    MediaType . TEXT _ HTML )  )  ;", "assertFalse ( this . converter . canWrite ( BigInteger . class ,    MediaType . TEXT _ XML )  )  ;", "assertFalse ( this . converter . canWrite ( BigInteger . class ,    MediaType . APPLICATION _ XML )  )  ;", "assertTrue ( this . converter . canWrite ( BigInteger . class ,    MediaType . valueOf (  \" text /  *  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter . write ( Integer . valueOf (  5  )  ,    null ,    response )  ;", "assertEquals (  \" ISO -  8  8  5  9  -  1  \"  ,    servletResponse . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultCharset"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ConversionService   cs    =    new   DefaultConversionService (  )  ;", "converter    =    new    ( cs ,    StandardCharsets . UTF _  1  6  )  ;", "converter . write (  (  ( byte )     (  3  1  )  )  ,    null ,    this . response )  ;", "assertEquals (  \" UTF -  1  6  \"  ,    this . servletResponse . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultCharsetModified"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setContentType ( MediaType . TEXT _ PLAIN _ VALUE )  ;", "Short   shortValue    =    Short . valueOf (  (  ( short )     (  7  8  1  )  )  )  ;", "request . setContent ( shortValue . toString (  )  . getBytes (  . DEFAULT _ CHARSET )  )  ;", "assertEquals ( shortValue ,    this . converter . read ( Short . class ,    new   ServletServerHttpRequest ( request )  )  )  ;", "Float   floatValue    =    Float . valueOf (  1  2  3  )  ;", "request . setCharacterEncoding (  \" UTF -  1  6  \"  )  ;", "request . setContent ( floatValue . toString (  )  . getBytes (  \" UTF -  1  6  \"  )  )  ;", "assertEquals ( floatValue ,    this . converter . read ( Float . class ,    new   ServletServerHttpRequest ( request )  )  )  ;", "Long   longValue    =    Long . valueOf (  5  5  8  1  9  1  8  2  8  2  1  3  3  1 L )  ;", "request . setCharacterEncoding (  \" UTF -  8  \"  )  ;", "request . setContent ( longValue . toString (  )  . getBytes (  \" UTF -  8  \"  )  )  ;", "assertEquals ( longValue ,    this . converter . read ( Long . class ,    new   ServletServerHttpRequest ( request )  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ConversionService   conversionService    =    new   DefaultConversionService (  )  ;", "this . converter    =    new    ( conversionService )  ;", "this . servletResponse    =    new   MockHttpServletResponse (  )  ;", "this . response    =    new   ServletServerHttpResponse ( this . servletResponse )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "new   ObjectToStringHttpMessageConverter ( null )  ;", "}", "METHOD_END"], "methodName": ["testConversionServiceRequired"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter . write (  (  ( byte )     (  -  8  )  )  ,    null ,    this . response )  ;", "assertEquals (  \" ISO -  8  8  5  9  -  1  \"  ,    this . servletResponse . getCharacterEncoding (  )  )  ;", "assertTrue ( this . servletResponse . getContentType (  )  . startsWith ( MediaType . TEXT _ PLAIN _ VALUE )  )  ;", "assertEquals (  2  ,    this . servletResponse . getContentLength (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     '  -  '  ,     '  8  '     }  ,    this . servletResponse . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter . write ( new   Date (  )  ,    null ,    this . response )  ;", "assertNotNull ( this . servletResponse . getHeader (  \" Accept - Charset \"  )  )  ;", "}", "METHOD_END"], "methodName": ["writeAcceptCharset"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter . setWriteAcceptCharset ( false )  ;", "this . converter . write ( new   Date (  )  ,    null ,    this . response )  ;", "assertNull ( this . servletResponse . getHeader (  \" Accept - Charset \"  )  )  ;", "}", "METHOD_END"], "methodName": ["writeAcceptCharsetTurnedOff"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . UTF _  1  6  )  ;", "thiswrite ( Integer . valueOf (  9  5  8  )  ,    contentType ,    this . response )  ;", "assertEquals (  \" UTF -  1  6  \"  ,    this . servletResponse . getCharacterEncoding (  )  )  ;", "assertTrue ( this . servletResponse . getContentType (  )  . startsWith ( MediaType . TEXT _ PLAIN _ VALUE )  )  ;", "assertEquals (  8  ,    this . servletResponse . getContentLength (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     -  2  ,     -  1  ,     0  ,     '  9  '  ,     0  ,     '  5  '  ,     0  ,     '  8  '     }  ,    this . servletResponse . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeUtf16"], "fileName": "org.springframework.http.converter.ObjectToStringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "InputStream   in    =    r . getInputStream (  )  ;", "try    {", "StreamUtils . copy ( in ,    outputMessage . getBody (  )  )  ;", "}    catch    ( NullPointerException   ex )     {", "}    finally    {", "try    {", "in . close (  )  ;", "}    catch    ( Throwable   ex )     {", "}", "}", "}    catch    ( FileNotFoundException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["writeContent"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( Resource . class ,    new   MediaType (  \" application \"  ,     \" octet - stream \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canReadResource"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( Resource . class ,    new   MediaType (  \" application \"  ,     \" octet - stream \"  )  )  )  ;", "assertTrue ( converter . canWrite ( Resource . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWriteResource"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ResourceHttpMessageConverter   noStreamConverter    =    new   ResourceHttpMessageConverter ( false )  ;", "try    ( InputStream   body    =    getClass (  )  . getResourceAsStream (  \" logo . jpg \"  )  )     {", "this . thrown . expect ( IllegalStateException . class )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "inputMessage . getHeaders (  )  . setContentType ( MediaType . IMAGE _ JPEG )  ;", "noStreamConverter . read ( InputStreamResource . class ,    inputMessage )  ;", "}", "}", "METHOD_END"], "methodName": ["shouldNotReadInputStreamResource"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =    FileCopyUtils . copyToByteArray ( getClass (  )  . getResourceAsStream (  \" logo . jpg \"  )  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "inputMessage . getHeaders (  )  . setContentType ( MediaType . IMAGE _ JPEG )  ;", "inputMessage . getHeaders (  )  . setContentDisposition ( ContentDisposition . builder (  \" attachment \"  )  . filename (  \" yourlogo . jpg \"  )  . build (  )  )  ;", "Resource   actualResource    =    read ( Resource . class ,    inputMessage )  ;", "assertThat ( FileCopyUtils . copyToByteArray ( actualResource . getInputStream (  )  )  ,    is ( body )  )  ;", "assertEquals (  \" yourlogo . jpg \"  ,    actualResource . getFilename (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldReadImageResource"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "try    ( InputStream   body    =    getClass (  )  . getResourceAsStream (  \" logo . jpg \"  )  )     {", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "inputMessage . getHeaders (  )  . setContentType ( MediaType . IMAGE _ JPEG )  ;", "inputMessage . getHeaders (  )  . setContentDisposition ( ContentDisposition . builder (  \" attachment \"  )  . filename (  \" yourlogo . jpg \"  )  . build (  )  )  ;", "Resource   actualResource    =    read ( InputStreamResource . class ,    inputMessage )  ;", "assertThat ( actualResource ,    instanceOf ( InputStreamResource . class )  )  ;", "assertThat ( actualResource . getInputStream (  )  ,    is ( body )  )  ;", "assertEquals (  \" yourlogo . jpg \"  ,    actualResource . getFilename (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["shouldReadInputStreamResource"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "Resource   body    =    new   ClassPathResource (  \" logo . jpg \"  ,    getClass (  )  )  ;", "write ( body ,    null ,    outputMessage )  ;", "assertEquals (  \" Invalid   content - type \"  ,    MediaType . IMAGE _ JPEG ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   content - length \"  ,    body . getFile (  )  . length (  )  ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldWriteImageResource"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "byte [  ]    byteArray    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", "Resource   body    =    new   ByteArrayResource ( byteArray )  ;", "write ( body ,    null ,    outputMessage )  ;", "assertTrue ( Arrays . equals ( byteArray ,    outputMessage . getBodyAsBytes (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeByteArrayNullMediaType"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "Resource   resource    =    mock ( Resource . class )  ;", "InputStream   in    =    mock ( InputStream . class )  ;", "given ( resource . getInputStream (  )  )  . willReturn ( in )  ;", "given ( in . read ( any (  )  )  )  . willThrow ( NullPointerException . class )  ;", "write ( resource ,    MediaType . APPLICATION _ OCTET _ STREAM ,    outputMessage )  ;", "assertEquals (  0  ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeContentInputStreamThrowingNullPointerException"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "Resource   resource    =    mock ( Resource . class )  ;", "InputStream   inputStream    =    mock ( InputStream . class )  ;", "given ( resource . getInputStream (  )  )  . willReturn ( inputStream )  ;", "given ( inputStream . read ( any (  )  )  )  . willReturn (  (  -  1  )  )  ;", "doThrow ( new   NullPointerException (  )  )  . when ( inputStream )  . close (  )  ;", "write ( resource ,    MediaType . APPLICATION _ OCTET _ STREAM ,    outputMessage )  ;", "assertEquals (  0  ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeContentNotClosingInputStream"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "Resource   resource    =    mock ( Resource . class )  ;", "given ( resource . getInputStream (  )  )  . willThrow ( FileNotFoundException . class )  ;", "write ( resource ,    MediaType . APPLICATION _ OCTET _ STREAM ,    outputMessage )  ;", "assertEquals (  0  ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeContentNotGettingInputStream"], "fileName": "org.springframework.http.converter.ResourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "os . write ( buf . getBytes ( StandardCharsets . US _ ASCII )  )  ;", "}", "METHOD_END"], "methodName": ["print"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "os . write (  '  \\ r '  )  ;", "os . write (  '  \\ n '  )  ;", "}", "METHOD_END"], "methodName": ["println"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( region ,     \" ResourceRegion   must   not   be   null \"  )  ;", "HttpHeaders   responseHeaders    =    outputMessage . getHeaders (  )  ;", "long   start    =    region . getPosition (  )  ;", "long   end    =     ( start    +     ( region . getCount (  )  )  )     -     1  ;", "Long   resourceLength    =    region . getResource (  )  . contentLength (  )  ;", "end    =    Math . min ( end ,     ( resourceLength    -     1  )  )  ;", "long   rangeLength    =     ( end    -    start )     +     1  ;", "responseHeaders . add (  \" Content - Range \"  ,     (  (  (  (  (  \" bytes    \"     +    start )     +     '  -  '  )     +    end )     +     '  /  '  )     +    resourceLength )  )  ;", "responseHeaders . setContentLength ( rangeLength )  ;", "InputStream   in    =    region . getResource (  )  . getInputStream (  )  ;", "try    {", "StreamUtils . copyRange ( in ,    outputMessage . getBody (  )  ,    start ,    end )  ;", "}    finally    {", "try    {", "in . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["writeResourceRegion"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceRegions ,     \" Collection   of   ResourceRegion   should   not   be   null \"  )  ;", "HttpHeaders   responseHeaders    =    outputMessage . getHeaders (  )  ;", "MediaType   contentType    =    responseHeaders . getContentType (  )  ;", "String   boundaryString    =    MimeTypeUtils . generateMultipartBoundaryString (  )  ;", "responseHeaders . set ( HttpHeaders . CONTENT _ TYPE ,     (  \" multipart / byteranges ;    boundary =  \"     +    boundaryString )  )  ;", "OutputStream   out    =    outputMessage . getBody (  )  ;", "for    ( ResourceRegion   region    :    resourceRegions )     {", "long   start    =    region . getPosition (  )  ;", "long   end    =     ( start    +     ( region . getCount (  )  )  )     -     1  ;", "InputStream   in    =    region . getResource (  )  . getInputStream (  )  ;", "try    {", ". println ( out )  ;", ". print ( out ,     (  \"  -  -  \"     +    boundaryString )  )  ;", ". println ( out )  ;", "if    ( contentType    !  =    null )     {", ". print ( out ,     (  \" Content - Type :     \"     +     ( contentType . toString (  )  )  )  )  ;", ". println ( out )  ;", "}", "Long   resourceLength    =    region . getResource (  )  . contentLength (  )  ;", "end    =    Math . min ( end ,     ( resourceLength    -     1  )  )  ;", ". print ( out ,     (  (  (  (  (  \" Content - Range :    bytes    \"     +    start )     +     '  -  '  )     +    end )     +     '  /  '  )     +    resourceLength )  )  ;", ". println ( out )  ;", ". println ( out )  ;", "StreamUtils . copyRange ( in ,    out ,    start ,    end )  ;", "}    finally    {", "try    {", "in . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", ". println ( out )  ;", ". print ( out ,     (  (  \"  -  -  \"     +    boundaryString )     +     \"  -  -  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["writeResourceRegionCollection"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "ClassPathResource   body    =    Mockito . mock ( ClassPathResource . class )  ;", "BDDMockito . given ( body . getFilename (  )  )  . willReturn (  \" spring . dat \"  )  ;", "BDDMockito . given ( body . contentLength (  )  )  . willReturn (  1  2 L )  ;", "BDDMockito . given ( body . getInputStream (  )  )  . willReturn ( new   ByteArrayInputStream (  \" Spring   Framework \"  . getBytes (  )  )  )  ;", "HttpRange   range    =    HttpRange . createByteRange (  0  ,     5  )  ;", "resourceRegion    =    range . to ( body )  ;", "converter . write ( Collections . singletonList ( resourceRegion )  ,    null ,    outputMessage )  ;", "assertThat ( outputMessage . getHeaders (  )  . getContentType (  )  ,    is ( MediaType . APPLICATION _ OCTET _ STREAM )  )  ;", "assertThat ( outputMessage . getHeaders (  )  . getFirst ( HttpHeaders . CONTENT _ RANGE )  ,    is (  \" bytes    0  -  5  /  1  2  \"  )  )  ;", "assertThat ( outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    is (  \" Spring \"  )  )  ;", "}", "METHOD_END"], "methodName": ["applicationOctetStreamDefaultContentType"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( converter . canRead ( Resource . class ,    MediaType . APPLICATION _ OCTET _ STREAM )  )  ;", "assertFalse ( converter . canRead ( Resource . class ,    MediaType . ALL )  )  ;", "assertFalse ( converter . canRead ( List . class ,    MediaType . APPLICATION _ OCTET _ STREAM )  )  ;", "assertFalse ( converter . canRead ( List . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canReadResource"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( ResourceRegion . class ,    null ,    MediaType . APPLICATION _ OCTET _ STREAM )  )  ;", "assertTrue ( converter . canWrite ( ResourceRegion . class ,    null ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWriteResource"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Type   resourceRegionList    =    new   ParameterizedTypeReference < List < ResourceRegion >  >  (  )     {  }  . getType (  )  ;", "assertTrue ( converter . canWrite ( resourceRegionList ,    null ,    MediaType . APPLICATION _ OCTET _ STREAM )  )  ;", "assertTrue ( converter . canWrite ( resourceRegionList ,    null ,    MediaType . ALL )  )  ;", "assertFalse ( converter . canWrite ( class ,    MediaType . APPLICATION _ OCTET _ STREAM )  )  ;", "assertFalse ( converter . canWrite ( class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWriteResourceCollection"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "Resource   body    =    new   ClassPathResource (  \" byterangeresource . txt \"  ,    getClass (  )  )  ;", "List < HttpRange >    rangeList    =    HttpRange . parseRanges (  \" bytes =  0  -  5  ,  7  -  1  5  ,  1  7  -  2  0  ,  2  2  -  3  8  \"  )  ;", "List <  >    regions    =    new   ArrayList <  >  (  )  ;", "for    ( HttpRange   range    :    rangeList )     {", "regions . add ( range . to ( body )  )  ;", "}", "converter . write ( regions ,    MediaType . TEXT _ PLAIN ,    outputMessage )  ;", "HttpHeaders   headers    =    outputMessage . getHeaders (  )  ;", "assertThat ( headers . getContentType (  )  . toString (  )  ,    Matchers . startsWith (  \" multipart / byteranges ; boundary =  \"  )  )  ;", "String   boundary    =     \"  -  -  \"     +     ( headers . getContentType (  )  . toString (  )  . substring (  3  0  )  )  ;", "String   content    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "String [  ]    ranges    =    StringUtils . tokenizeToStringArray ( content ,     \"  \\ r \\ n \"  ,    false ,    true )  ;", "assertThat ( ranges [  0  ]  ,    is ( boundary )  )  ;", "assertThat ( ranges [  1  ]  ,    is (  \" Content - Type :    text / plain \"  )  )  ;", "assertThat ( ranges [  2  ]  ,    is (  \" Content - Range :    bytes    0  -  5  /  3  9  \"  )  )  ;", "assertThat ( ranges [  3  ]  ,    is (  \" Spring \"  )  )  ;", "assertThat ( ranges [  4  ]  ,    is ( boundary )  )  ;", "assertThat ( ranges [  5  ]  ,    is (  \" Content - Type :    text / plain \"  )  )  ;", "assertThat ( ranges [  6  ]  ,    is (  \" Content - Range :    bytes    7  -  1  5  /  3  9  \"  )  )  ;", "assertThat ( ranges [  7  ]  ,    is (  \" Framework \"  )  )  ;", "assertThat ( ranges [  8  ]  ,    is ( boundary )  )  ;", "assertThat ( ranges [  9  ]  ,    is (  \" Content - Type :    text / plain \"  )  )  ;", "assertThat ( ranges [  1  0  ]  ,    is (  \" Content - Range :    bytes    1  7  -  2  0  /  3  9  \"  )  )  ;", "assertThat ( ranges [  1  1  ]  ,    is (  \" test \"  )  )  ;", "assertThat ( ranges [  1  2  ]  ,    is ( boundary )  )  ;", "assertThat ( ranges [  1  3  ]  ,    is (  \" Content - Type :    text / plain \"  )  )  ;", "assertThat ( ranges [  1  4  ]  ,    is (  \" Content - Range :    bytes    2  2  -  3  8  /  3  9  \"  )  )  ;", "assertThat ( ranges [  1  5  ]  ,    is (  \" resource   content .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["partialContentMultipleByteRanges"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "Resource   body    =    new   ClassPathResource (  \" byterangeresource . txt \"  ,    getClass (  )  )  ;", "region    =    HttpRange . createByteRange (  0  ,     5  )  . to ( body )  ;", "converter . write ( region ,    MediaType . TEXT _ PLAIN ,    outputMessage )  ;", "HttpHeaders   headers    =    outputMessage . getHeaders (  )  ;", "assertThat ( headers . getContentType (  )  ,    is ( MediaType . TEXT _ PLAIN )  )  ;", "assertThat ( headers . getContentLength (  )  ,    is (  6 L )  )  ;", "assertThat ( headers . get ( HttpHeaders . CONTENT _ RANGE )  . size (  )  ,    is (  1  )  )  ;", "assertThat ( headers . get ( HttpHeaders . CONTENT _ RANGE )  . get (  0  )  ,    is (  \" bytes    0  -  5  /  3  9  \"  )  )  ;", "assertThat ( outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    is (  \" Spring \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldWritePartialContentByteRange"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "Resource   body    =    new   ClassPathResource (  \" byterangeresource . txt \"  ,    getClass (  )  )  ;", "region    =    HttpRange . createByteRange (  7  )  . to ( body )  ;", "converter . write ( region ,    MediaType . TEXT _ PLAIN ,    outputMessage )  ;", "HttpHeaders   headers    =    outputMessage . getHeaders (  )  ;", "assertThat ( headers . getContentType (  )  ,    is ( MediaType . TEXT _ PLAIN )  )  ;", "assertThat ( headers . getContentLength (  )  ,    is (  3  2 L )  )  ;", "assertThat ( headers . get ( HttpHeaders . CONTENT _ RANGE )  . size (  )  ,    is (  1  )  )  ;", "assertThat ( headers . get ( HttpHeaders . CONTENT _ RANGE )  . get (  0  )  ,    is (  \" bytes    7  -  3  8  /  3  9  \"  )  )  ;", "assertThat ( outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    is (  \" Framework   test   resource   content .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldWritePartialContentByteRangeNoEnd"], "fileName": "org.springframework.http.converter.ResourceRegionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < Charset >    charsets    =    this . availableCharsets ;", "if    ( charsets    =  =    null )     {", "charsets    =    new   ArrayList <  >  ( Charset . availableCharsets (  )  . values (  )  )  ;", "this . availableCharsets    =    charsets ;", "}", "return   charsets ;", "}", "METHOD_END"], "methodName": ["getAcceptedCharsets"], "fileName": "org.springframework.http.converter.StringHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contentType    !  =    null )     &  &     (  ( contentType . getCharset (  )  )     !  =    null )  )     {", "return   contentType . getCharset (  )  ;", "} else    {", "Charset   charset    =    getDefaultCharset (  )  ;", "Assert . state (  ( charset    !  =    null )  ,     \" No   default   charset \"  )  ;", "return   charset ;", "}", "}", "METHOD_END"], "methodName": ["getContentTypeCharset"], "fileName": "org.springframework.http.converter.StringHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . writeAcceptCharset    =    writeAcceptCharset ;", "}", "METHOD_END"], "methodName": ["setWriteAcceptCharset"], "fileName": "org.springframework.http.converter.StringHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canRead ( String . class ,    MediaType . TEXT _ PLAIN )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.StringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canWrite ( String . class ,    MediaType . TEXT _ PLAIN )  )  ;", "assertTrue ( this . converter . canWrite ( String . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.StringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" Hello   World \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "inputMessage . getHeaders (  )  . setContentType (  . TEXT _ PLAIN _ UTF _  8  )  ;", "String   result    =    this . converter . read ( String . class ,    inputMessage )  ;", "assertEquals (  \" Invalid   result \"  ,    body ,    result )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.StringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter    =    new   StringHttpMessageConverter (  )  ;", "this . outputMessage    =    new   MockHttpOutputMessage (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.StringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "thiswrite ( body ,    null ,    this . outputMessage )  ;", "HttpHeaders   headers    =    this . outputMessage . getHeaders (  )  ;", "assertEquals ( body ,    this . outputMessage . getBodyAsString ( StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "assertEquals ( new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  ,    headers . getContentType (  )  )  ;", "assertEquals ( body . getBytes ( StandardCharsets . ISO _  8  8  5  9  _  1  )  . length ,    headers . getContentLength (  )  )  ;", "assertFalse ( headers . getAcceptCharset (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeDefaultCharset"], "fileName": "org.springframework.http.converter.StringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "MediaType   requestedContentType    =    new   MediaType (  \" text \"  ,     \" html \"  )  ;", "HttpHeaders   headers    =    this . outputMessage . getHeaders (  )  ;", "headers . setContentType (  . TEXT _ PLAIN _ UTF _  8  )  ;", "this . converter . write ( body ,    requestedContentType ,    this . outputMessage )  ;", "assertEquals ( body ,    this . outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  . TEXT _ PLAIN _ UTF _  8  ,    headers . getContentType (  )  )  ;", "assertEquals ( body . getBytes ( StandardCharsets . UTF _  8  )  . length ,    headers . getContentLength (  )  )  ;", "assertFalse ( headers . getAcceptCharset (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeOverrideRequestedContentType"], "fileName": "org.springframework.http.converter.StringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "this . converter . write ( body ,     . TEXT _ PLAIN _ UTF _  8  ,    this . outputMessage )  ;", "HttpHeaders   headers    =    this . outputMessage . getHeaders (  )  ;", "assertEquals ( body ,    this . outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  . TEXT _ PLAIN _ UTF _  8  ,    headers . getContentType (  )  )  ;", "assertEquals ( body . getBytes ( StandardCharsets . UTF _  8  )  . length ,    headers . getContentLength (  )  )  ;", "assertFalse ( headers . getAcceptCharset (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeUTF8"], "fileName": "org.springframework.http.converter.StringHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( Feed . class ,    new   MediaType (  \" application \"  ,     \" atom + xml \"  )  )  )  ;", "assertTrue ( converter . canRead ( Feed . class ,    new   MediaType (  \" application \"  ,     \" atom + xml \"  ,    StandardCharsets . UTF _  8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.feed.AtomFeedHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( Feed . class ,    new   MediaType (  \" application \"  ,     \" atom + xml \"  )  )  )  ;", "assertTrue ( converter . canWrite ( Feed . class ,    new   MediaType (  \" application \"  ,     \" atom + xml \"  ,    StandardCharsets . UTF _  8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.feed.AtomFeedHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    getClass (  )  . getResourceAsStream (  \" atom . xml \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( is )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" atom + xml \"  ,    StandardCharsets . UTF _  8  )  )  ;", "Feed   result    =    read ( Feed . class ,    inputMessage )  ;", "assertEquals (  \" title \"  ,    result . getTitle (  )  )  ;", "assertEquals (  \" subtitle \"  ,    result . getSubtitle (  )  . getValue (  )  )  ;", "List <  ?  >    entries    =    result . getEntries (  )  ;", "assertEquals (  2  ,    entries . size (  )  )  ;", "Entry   entry 1     =     (  ( Entry )     ( entries . get (  0  )  )  )  ;", "assertEquals (  \" id 1  \"  ,    entry 1  . getId (  )  )  ;", "assertEquals (  \" title 1  \"  ,    entry 1  . getTitle (  )  )  ;", "Entry   entry 2     =     (  ( Entry )     ( entries . get (  1  )  )  )  ;", "assertEquals (  \" id 2  \"  ,    entry 2  . getId (  )  )  ;", "assertEquals (  \" title 2  \"  ,    entry 2  . getTitle (  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.feed.AtomFeedHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter    =    new   AtomFeedHttpMessageConverter (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.feed.AtomFeedHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Feed   feed    =    new   Feed (  \" atom _  1  .  0  \"  )  ;", "feed . setTitle (  \" title \"  )  ;", "Entry   entry 1     =    new   Entry (  )  ;", "entry 1  . setId (  \" id 1  \"  )  ;", "entry 1  . setTitle (  \" title 1  \"  )  ;", "Entry   entry 2     =    new   Entry (  )  ;", "entry 2  . setId (  \" id 2  \"  )  ;", "entry 2  . setTitle (  \" title 2  \"  )  ;", "List < Entry >    entries    =    new   ArrayList <  >  (  2  )  ;", "entries . add ( entry 1  )  ;", "entries . add ( entry 2  )  ;", "feed . setEntries ( entries )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "write ( feed ,    null ,    outputMessage )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" atom + xml \"  ,    StandardCharsets . UTF _  8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "String   expected    =     \"  < feed   xmlns =  \\  \" http :  /  / www . w 3  . org /  2  0  0  5  / Atom \\  \"  >  \"     +     (  (  \"  < title > title <  / title >  \"     +     \"  < entry >  < id > id 1  <  / id >  < title > title 1  <  / title >  <  / entry >  \"  )     +     \"  < entry >  < id > id 2  <  / id >  < title > title 2  <  / title >  <  / entry >  <  / feed >  \"  )  ;", "NodeMatcher   nm    =    new   DefaultNodeMatcher ( ElementSelectors . byName )  ;", "assertThat ( outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    isSimilarTo ( expected )  . ignoreWhitespace (  )  . withNodeMatcher ( nm )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.feed.AtomFeedHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Feed   feed    =    new   Feed (  \" atom _  1  .  0  \"  )  ;", "feed . setTitle (  \" title \"  )  ;", "String   encoding    =     \" ISO -  8  8  5  9  -  1  \"  ;", "feed . setEncoding ( encoding )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "write ( feed ,    null ,    outputMessage )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" atom + xml \"  ,    Charset . forName ( encoding )  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeOtherCharset"], "fileName": "org.springframework.http.converter.feed.AtomFeedHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( Channel . class ,    new   MediaType (  \" application \"  ,     \" rss + xml \"  )  )  )  ;", "assertTrue ( converter . canRead ( Channel . class ,    new   MediaType (  \" application \"  ,     \" rss + xml \"  ,    StandardCharsets . UTF _  8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.feed.RssChannelHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( Channel . class ,    new   MediaType (  \" application \"  ,     \" rss + xml \"  )  )  )  ;", "assertTrue ( converter . canWrite ( Channel . class ,    new   MediaType (  \" application \"  ,     \" rss + xml \"  ,    StandardCharsets . UTF _  8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.feed.RssChannelHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   CompareMatcher . isSimilarTo ( content )  . ignoreWhitespace (  )  ;", "}", "METHOD_END"], "methodName": ["isSimilarTo"], "fileName": "org.springframework.http.converter.feed.RssChannelHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    getClass (  )  . getResourceAsStream (  \" rss . xml \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( is )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" rss + xml \"  ,    StandardCharsets . UTF _  8  )  )  ;", "Channel   result    =    read ( Channel . class ,    inputMessage )  ;", "assertEquals (  \" title \"  ,    result . getTitle (  )  )  ;", "assertEquals (  \" http :  /  / example . com \"  ,    result . getLink (  )  )  ;", "assertEquals (  \" description \"  ,    result . getDescription (  )  )  ;", "List <  ?  >    items    =    result . getItems (  )  ;", "assertEquals (  2  ,    items . size (  )  )  ;", "Item   item 1     =     (  ( Item )     ( items . get (  0  )  )  )  ;", "assertEquals (  \" title 1  \"  ,    item 1  . getTitle (  )  )  ;", "Item   item 2     =     (  ( Item )     ( items . get (  1  )  )  )  ;", "assertEquals (  \" title 2  \"  ,    item 2  . getTitle (  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.feed.RssChannelHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter    =    new   RssChannelHttpMessageConverter (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.feed.RssChannelHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Channel   channel    =    new   Channel (  \" rss _  2  .  0  \"  )  ;", "channel . setTitle (  \" title \"  )  ;", "channel . setLink (  \" http :  /  / example . com \"  )  ;", "channel . setDescription (  \" description \"  )  ;", "Item   item 1     =    new   Item (  )  ;", "item 1  . setTitle (  \" title 1  \"  )  ;", "Item   item 2     =    new   Item (  )  ;", "item 2  . setTitle (  \" title 2  \"  )  ;", "List < Item >    items    =    new   ArrayList <  >  (  2  )  ;", "items . add ( item 1  )  ;", "items . add ( item 2  )  ;", "channel . setItems ( items )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( channel ,    null ,    outputMessage )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" rss + xml \"  ,    StandardCharsets . UTF _  8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "String   expected    =     \"  < rss   version =  \\  \"  2  .  0  \\  \"  >  \"     +     (  (  (  \"  < channel >  < title > title <  / title >  < link > http :  /  / example . com <  / link >  < description > description <  / description >  \"     +     \"  < item >  < title > title 1  <  / title >  <  / item >  \"  )     +     \"  < item >  < title > title 2  <  / title >  <  / item >  \"  )     +     \"  <  / channel >  <  / rss >  \"  )  ;", "assertThat ( outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,     . isSimilarTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.feed.RssChannelHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Channel   channel    =    new   Channel (  \" rss _  2  .  0  \"  )  ;", "channel . setTitle (  \" title \"  )  ;", "channel . setLink (  \" http :  /  / example . com \"  )  ;", "channel . setDescription (  \" description \"  )  ;", "String   encoding    =     \" ISO -  8  8  5  9  -  1  \"  ;", "channel . setEncoding ( encoding )  ;", "Item   item 1     =    new   Item (  )  ;", "item 1  . setTitle (  \" title 1  \"  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "write ( channel ,    null ,    outputMessage )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" rss + xml \"  ,    Charset . forName ( encoding )  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeOtherCharset"], "fileName": "org.springframework.http.converter.feed.RssChannelHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . prettyPrint )     !  =    null )     {", "this . objectMapperfigure ( SerializationFeature . INDENT _ OUTPUT ,    this . prettyPrint )  ;", "}", "}", "METHOD_END"], "methodName": ["configurePrettyPrint"], "fileName": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "TypeFactory   typeFactory    =    this . objectMapper . getTypeFactory (  )  ;", "return   typeFactorystructType ( GenericTypeResolver . resolveType ( type , textClass )  )  ;", "}", "METHOD_END"], "methodName": ["getJavaType"], "fileName": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contentType    !  =    null )     &  &     (  ( contentType . getCharset (  )  )     !  =    null )  )     {", "Charset   charset    =    contentType . getCharset (  )  ;", "for    ( JsonEncoding   encoding    :    JsonEncoding . values (  )  )     {", "if    ( charset . name (  )  . equals ( encoding . getJavaName (  )  )  )     {", "return   encoding ;", "}", "}", "}", "return   JsonEncoding . UTF 8  ;", "}", "METHOD_END"], "methodName": ["getJsonEncoding"], "fileName": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . objectMapper ;", "}", "METHOD_END"], "methodName": ["getObjectMapper"], "fileName": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( cause    =  =    null )     {", "return ;", "}", "boolean   debugLevel    =     ( cause   instanceof   JsonMappingException )     &  &     ( cause . get (  )  . startsWith (  \" Can   not   find \"  )  )  ;", "if    ( debugLevel    ?    logger . isDebugEnabled (  )     :    logger . isWarnEnabled (  )  )     {", "String   msg    =     (  (  (  \" Failed   to   evaluate   Jackson    \"     +     ( type   instanceof   JavaType    ?     \" de \"     :     \"  \"  )  )     +     \" serialization   for   type    [  \"  )     +    type )     +     \"  ]  \"  ;", "if    ( debugLevel )     {", "logger . debug ( msg ,    cause )  ;", "} else", "if    ( logger . isDebugEnabled (  )  )     {", "logger . warn ( msg ,    cause )  ;", "} else    {", "logger . warn (  (  ( msg    +     \"  :     \"  )     +    cause )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["logWarningIfNecessary"], "fileName": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( inputMessage   instanceof   MappingJacksonInputMessage )     {", "Class <  ?  >    deserializationView    =     (  ( MappingJacksonInputMessage )     ( inputMessage )  )  . getDeserializationView (  )  ;", "if    ( deserializationView    !  =    null )     {", "return   this . objectMapper . readerWithView ( deserializationView )  . forType ( javaType )  . readValue ( inputMessage . getBody (  )  )  ;", "}", "}", "return   this . objectMapper . readValue ( inputMessage . getBody (  )  ,    javaType )  ;", "}    catch    ( InvalidDefinitionException   ex )     {", "throw   new   sionException (  (  \" Type   definition   error :     \"     +     ( ex . getType (  )  )  )  ,    ex )  ;", "}    catch    ( JsonProcessingException   ex )     {", "throw   new   HttpMessageNotReadableException (  (  \" JSON   parse   error :     \"     +     ( ex . getOriginalMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readJavaType"], "fileName": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( objectMapper ,     \" ObjectMapper   must   not   be   null \"  )  ;", "this . objectMapper    =    objectMapper ;", "configurePrettyPrint (  )  ;", "}", "METHOD_END"], "methodName": ["setObjectMapper"], "fileName": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . prettyPrint    =    prettyPrint ;", "configurePrettyPrint (  )  ;", "}", "METHOD_END"], "methodName": ["setPrettyPrint"], "fileName": "org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =     (  ( headers . getContentType (  )  )     !  =    null )     ?    headers . getContentType (  )  . getCharset (  )     :    null ;", "return   charset    !  =    null    ?    charset    :     . DEFAULT _ CHARSET ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.http.converter.json.AbstractJsonHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   new   InputStreamReader ( inputMessage . getBody (  )  ,    AbstractJsonHttpMessageConverter . getCharset ( inputMessage . getHeaders (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getReader"], "fileName": "org.springframework.http.converter.json.AbstractJsonHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   new   OutputStreamWriter ( outputMessage . getBody (  )  ,    AbstractJsonHttpMessageConverter . getCharset ( outputMessage . getHeaders (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getWriter"], "fileName": "org.springframework.http.converter.json.AbstractJsonHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Reader   reader    =    AbstractJsonHttpMessageConverter . getReader ( inputMessage )  ;", "try    {", "return   readInternal ( resolvedType ,    reader )  ;", "}    catch    ( Exception   ex )     {", "throw   new   HttpMessageNotReadableException (  (  \" Could   not   read   JSON :     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readResolved"], "fileName": "org.springframework.http.converter.json.AbstractJsonHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . jsonPrefix    =    jsonPrefix ;", "}", "METHOD_END"], "methodName": ["setJsonPrefix"], "fileName": "org.springframework.http.converter.json.AbstractJsonHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . jsonPrefix    =     ( prefixJson )     ?     \"  )  ]  }  '  ,     \"     :    null ;", "}", "METHOD_END"], "methodName": ["setPrefixJson"], "fileName": "org.springframework.http.converter.json.AbstractJsonHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "GsonBuilder   builder    =    new   GsonBuilder (  )  ;", "builder . registerTypeHierarchyAdapter ( byte [  ]  . class ,    new    . Base 6  4 TypeAdapter (  )  )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["gsonBuilderWithBase64EncodedByteArrays"], "fileName": "org.springframework.http.converter.json.GsonBuilderUtils"}, {"methodBody": ["METHOD_START", "{", "this . base 6  4 EncodeByteArrays    =    base 6  4 EncodeByteArrays ;", "}", "METHOD_END"], "methodName": ["setBase64EncodeByteArrays"], "fileName": "org.springframework.http.converter.json.GsonFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . dateFormatPattern    =    dateFormatPattern ;", "}", "METHOD_END"], "methodName": ["setDateFormatPattern"], "fileName": "org.springframework.http.converter.json.GsonFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . disableHtmlEscaping    =    disableHtmlEscaping ;", "}", "METHOD_END"], "methodName": ["setDisableHtmlEscaping"], "fileName": "org.springframework.http.converter.json.GsonFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . prettyPrinting    =    prettyPrinting ;", "}", "METHOD_END"], "methodName": ["setPrettyPrinting"], "fileName": "org.springframework.http.converter.json.GsonFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . serializeNulls    =    serializeNulls ;", "}", "METHOD_END"], "methodName": ["setSerializeNulls"], "fileName": "org.springframework.http.converter.json.GsonFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . factory . setBase 6  4 EncodeByteArrays ( true )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". ByteArrayBean   bean    =    new    . ByteArrayBean (  )  ;", "bean . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  \\  \" bytes \\  \"  :  \\  \" AQI \\  \\ u 0  0  3 d \\  \"  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["base64EncodeByteArrays"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setBase 6  4 EncodeByteArrays ( true )  ;", "this . factory . setDisableHtmlEscaping ( true )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". ByteArrayBean   bean    =    new    . ByteArrayBean (  )  ;", "bean . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["base64EncodeByteArraysDisableHtmlEscaping"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setBase 6  4 EncodeByteArrays ( false )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". ByteArrayBean   bean    =    new    . ByteArrayBean (  )  ;", "bean . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["base64EncodeByteArraysFalse"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". DateBean   bean    =    new    . DateBean (  )  ;", "Calendar   cal    =    Calendar . getInstance (  )  ;", "cal . clear (  )  ;", "cal . set ( Calendar . YEAR ,     2  0  1  4  )  ;", "cal . set ( Calendar . MONTH ,    Calendar . JANUARY )  ;", "cal . set ( Calendar . DATE ,     1  )  ;", "Date   date    =    cal . getTime (  )  ;", "bean . setDate ( date )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertTrue ( result . startsWith (  \"  {  \\  \" date \\  \"  :  \\  \" Jan    1  ,     2  0  1  4  \"  )  )  ;", "assertTrue ( result . endsWith (  \"  1  2  :  0  0  :  0  0    AM \\  \"  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeDateFormatNone"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setDateFormatPattern ( GsonFactoryBeanTests . DATE _ FORMAT )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", "GsonFactoryBeanTests . DateBean   bean    =    new   GsonFactoryBeanTests . DateBean (  )  ;", "Calendar   cal    =    Calendar . getInstance (  )  ;", "cal . clear (  )  ;", "cal . set ( Calendar . YEAR ,     2  0  1  4  )  ;", "cal . set ( Calendar . MONTH ,    Calendar . JANUARY )  ;", "cal . set ( Calendar . DATE ,     1  )  ;", "Date   date    =    cal . getTime (  )  ;", "bean . setDate ( date )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  \\  \" date \\  \"  :  \\  \"  2  0  1  4  -  0  1  -  0  1  \\  \"  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["customizeDateFormatPattern"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setDisableHtmlEscaping ( true )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". StringBean   bean    =    new    . StringBean (  )  ;", "bean . setName (  \" Bob = Bob \"  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  \\  \" name \\  \"  :  \\  \" Bob = Bob \\  \"  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["disableHtmlEscaping"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setDisableHtmlEscaping ( false )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". StringBean   bean    =    new    . StringBean (  )  ;", "bean . setName (  \" Bob = Bob \"  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  \\  \" name \\  \"  :  \\  \" Bob \\  \\ u 0  0  3 dBob \\  \"  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["disableHtmlEscapingFalse"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setPrettyPrinting ( true )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". StringBean   bean    =    new    . StringBean (  )  ;", "bean . setName (  \" Jason \"  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertTrue ( result . contains (  \"        \\  \" name \\  \"  :     \\  \" Jason \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["prettyPrinting"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setPrettyPrinting ( false )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". StringBean   bean    =    new    . StringBean (  )  ;", "bean . setName (  \" Jason \"  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  \\  \" name \\  \"  :  \\  \" Jason \\  \"  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["prettyPrintingFalse"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setSerializeNulls ( true )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". StringBean   bean    =    new    . StringBean (  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  \\  \" name \\  \"  : null }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["serializeNulls"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setSerializeNulls ( false )  ;", "this . factory . afterPropertiesSet (  )  ;", "Gson   gson    =    this . factory . getObject (  )  ;", ". StringBean   bean    =    new    . StringBean (  )  ;", "String   result    =    gson . toJson ( bean )  ;", "assertEquals (  \"  {  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["serializeNullsFalse"], "fileName": "org.springframework.http.converter.json.GsonFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   this . gson ;", "}", "METHOD_END"], "methodName": ["getGson"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( gson ,     \" A   Gson   instance   is   required \"  )  ;", "this . gson    =    gson ;", "}", "METHOD_END"], "methodName": ["setGson"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canRead ( GsonHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "assertTrue ( this . converter . canRead ( Map . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canRead ( GsonHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" vnd . test - micro - type + json \"  )  )  )  ;", "assertTrue ( this . converter . canWrite ( GsonHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" vnd . test - micro - type + json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canReadAndWriteMicroformats"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canWrite ( GsonHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "assertTrue ( this . converter . canWrite ( Map . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "thissetPrefixJson ( true )  ;", "thiswriteInternal (  \" foo \"  ,    null ,    outputMessage )  ;", "assertEquals (  \"  )  ]  }  \\  '  ,     \\  \" foo \\  \"  \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["prefixJson"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "thissetJsonPrefix (  \"  )  )  )  \"  )  ;", "thiswriteInternal (  \" foo \"  ,    null ,    outputMessage )  ;", "assertEquals (  \"  )  )  )  \\  \" foo \\  \"  \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["prefixJsonCustom"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Field   beansList    =    GsonHttpMessageConverterTests . ListHolder . class . getField (  \" listField \"  )  ;", "String   body    =     \"  [  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "Type   genericType    =    beansList . getGenericType (  )  ;", "List < GsonHttpMessageConverterTests . MyBean >    results    =     (  ( List < GsonHttpMessageConverterTests . MyBean >  )     ( converter . read ( genericType ,    GsonHttpMessageConverterTests . MyBeanListHolder . class ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", "GsonHttpMessageConverterTests . MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    genericType ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["readAndWriteGenerics"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < List < GsonHttpMessageConverterTests . MyBean >  >    beansList    =    new   ParameterizedTypeReference < List < GsonHttpMessageConverterTests . MyBean >  >  (  )     {  }  ;", "String   body    =     \"  [  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "List < GsonHttpMessageConverterTests . MyBean >    results    =     (  ( List < GsonHttpMessageConverterTests . MyBean >  )     ( converter . read ( beansList . getType (  )  ,    null ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", "GsonHttpMessageConverterTests . MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    beansList . getType (  )  ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["readAndWriteParameterizedType"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" FooBar \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "this . converter . read (  . MyBean . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readInvalidJson"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", ". MyBean   result    =     (  (  . MyBean )     ( this . converter . read (  . MyBean . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["readTyped"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "HashMap < String ,    Object >    result    =     (  ( HashMap < String ,    Object >  )     ( thisread ( HashMap . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo \"  ,    result . get (  \" string \"  )  )  ;", "Number   n    =     (  ( Number )     ( result . get (  \" number \"  )  )  )  ;", "assertEquals (  4  2  ,    n . longValue (  )  )  ;", "n    =     (  ( Number )     ( result . get (  \" fraction \"  )  )  )  ;", "assertEquals (  4  2  .  0  ,    n . doubleValue (  )  ,     0  .  0  )  ;", "List < String >    array    =    new   ArrayList <  >  (  )  ;", "array . add (  \" Foo \"  )  ;", "array . add (  \" Bar \"  )  ;", "assertEquals ( array ,    result . get (  \" array \"  )  )  ;", "assertEquals ( Boolean . TRUE ,    result . get (  \" bool \"  )  )  ;", "byte [  ]    bytes    =    new   byte [  2  ]  ;", "List < Number >    resultBytes    =     (  ( ArrayList < Number >  )     ( result . get (  \" bytes \"  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     2  ;    i +  +  )     {", "bytes [ i ]     =    resultBytes . get ( i )  . byteValue (  )  ;", "}", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    bytes )  ;", "}", "METHOD_END"], "methodName": ["readUntyped"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   body    =    new    . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "this . converter . write ( body ,    null ,    outputMessage )  ;", "Charset   utf 8     =    StandardCharsets . UTF _  8  ;", "String   result    =    outputMessage . getBodyAsString ( utf 8  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "assertTrue ( result . contains (  \" fraction \\  \"  :  4  2  .  0  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bool \\  \"  : true \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bytes \\  \"  :  [  1  ,  2  ]  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" json \"  ,    utf 8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < List < GsonHttpMessageConverterTests . MyBean >  >    beansList    =    new   ParameterizedTypeReference < List < GsonHttpMessageConverterTests . MyBean >  >  (  )     {  }  ;", "ParameterizedTypeReference < List < GsonHttpMessageConverterTests . MyBase >  >    baseList    =    new   ParameterizedTypeReference < List < GsonHttpMessageConverterTests . MyBase >  >  (  )     {  }  ;", "String   body    =     \"  [  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "List < GsonHttpMessageConverterTests . MyBean >    results    =     (  ( List < GsonHttpMessageConverterTests . MyBean >  )     ( converter . read ( beansList . getType (  )  ,    null ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", "GsonHttpMessageConverterTests . MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    baseList . getType (  )  ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["writeParameterizedBaseType"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    new   MediaType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  1  6 BE )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "String   body    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "thiswrite ( body ,    contentType ,    outputMessage )  ;", "assertEquals (  \" Invalid   result \"  ,     (  (  \"  \\  \"  \"     +    body )     +     \"  \\  \"  \"  )  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  1  6 BE )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    contentType ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeUTF16"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   body    =    new    . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "this . converter . write ( body ,     . MyBase . class ,    null ,    outputMessage )  ;", "Charset   utf 8     =    StandardCharsets . UTF _  8  ;", "String   result    =    outputMessage . getBodyAsString ( utf 8  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "assertTrue ( result . contains (  \" fraction \\  \"  :  4  2  .  0  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bool \\  \"  : true \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bytes \\  \"  :  [  1  ,  2  ]  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" json \"  ,    utf 8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeWithBaseType"], "fileName": "org.springframework.http.converter.json.GsonHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . deserializers . forEach (  (    type ,    deserializer )     -  >    module . addDeserializer (  (  ( Class < T >  )     ( type )  )  ,     (  ( JsonDeserializer <  ?    extends   T >  )     ( deserializer )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addDeserializers"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . serializers . forEach (  (    type ,    serializer )     -  >    module . addSerializer (  (  ( Class <  ?    extends   T >  )     ( type )  )  ,     (  ( JsonSerializer < T >  )     ( serializer )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addSerializers"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . annotationIntrospector    =    annotationIntrospector ;", "return   this ;", "}", "METHOD_END"], "methodName": ["annotationIntrospector"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . applicationContext    =    applicationContext ;", "return   this ;", "}", "METHOD_END"], "methodName": ["applicationContext"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . features . put ( MapperFeature . AUTO _ DETECT _ FIELDS ,    autoDetectFields )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["autoDetectFields"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . features . put ( MapperFeature . AUTO _ DETECT _ GETTERS ,    autoDetectGettersSetters )  ;", "this . features . put ( MapperFeature . AUTO _ DETECT _ SETTERS ,    autoDetectGettersSetters )  ;", "this . features . put ( MapperFeature . AUTO _ DETECT _ IS _ GETTERS ,    autoDetectGettersSetters )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["autoDetectGettersSetters"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   mapper ;", "if    ( this . createXmlMapper )     {", "mapper    =     (  ( this . defaultUseWrapper )     !  =    null )     ?    new    . XmlObjectMapperInitializer (  )  . create ( this . defaultUseWrapper )     :    new    . XmlObjectMapperInitializer (  )  . create (  )  ;", "} else    {", "mapper    =     (  ( this . factory )     !  =    null )     ?    new   ObjectMapper ( this . factory )     :    new   ObjectMapper (  )  ;", "}", "configure ( mapper )  ;", "return    (  ( T )     ( mapper )  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   Jackson 2 ObjectMapperBuilder (  )  . factory ( new   Jackson 2 ObjectMapperBuilder . CborFactoryInitializer (  )  . create (  )  )  ;", "}", "METHOD_END"], "methodName": ["cbor"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( objectMapper ,     \" ObjectMapper   must   not   be   null \"  )  ;", "if    ( this . findModulesViaServiceLoader )     {", "objectMapper . registerModules ( ObjectMapper . findModules ( this . moduleClassLoader )  )  ;", "} else", "if    ( this . findWellKnownModules )     {", "registerWellKnownModulesIfAvailable ( objectMapper )  ;", "}", "if    (  ( this . modules )     !  =    null )     {", "objectMapper . registerModules ( this . modules )  ;", "}", "if    (  ( this . moduleClasses )     !  =    null )     {", "for    ( Class <  ?    extends   Module >    module    :    this . moduleClasses )     {", "objectMapper . registerModule ( BeanUtils . instantiateClass ( module )  )  ;", "}", "}", "if    (  ( this . dateFormat )     !  =    null )     {", "objectMapper . setDateFormat ( this . dateFormat )  ;", "}", "if    (  ( this . locale )     !  =    null )     {", "objectMapper . setLocale ( this . locale )  ;", "}", "if    (  ( this . timeZone )     !  =    null )     {", "objectMapper . setTimeZone ( this . timeZone )  ;", "}", "if    (  ( this . annotationIntrospector )     !  =    null )     {", "objectMapper . setAnnotationIntrospector ( this . annotationIntrospector )  ;", "}", "if    (  ( this . propertyNamingStrategy )     !  =    null )     {", "objectMapper . setPropertyNamingStrategy ( this . propertyNamingStrategy )  ;", "}", "if    (  ( this . defaultTyping )     !  =    null )     {", "objectMapper . setDefaultTyping ( this . defaultTyping )  ;", "}", "if    (  ( this . serializationInclusion )     !  =    null )     {", "objectMapper . setSerializationInclusion ( this . serializationInclusion )  ;", "}", "if    (  ( this . filters )     !  =    null )     {", "objectMapper . setFilterProvider ( this . filters )  ;", "}", "this . mixIns . forEach (  (    target ,    mixinSource )     -  >    objectMapper . addMixIn ( target ,    mixinSource )  )  ;", "if    (  (  !  ( this . serializers . isEmpty (  )  )  )     |  |     (  !  ( this . deserializers . isEmpty (  )  )  )  )     {", "SimpleModule   module    =    new   SimpleModule (  )  ;", "addSerializers ( module )  ;", "addDeserializers ( module )  ;", "objectMapper . registerModule ( module )  ;", "}", "customizeDefaultFeatures ( objectMapper )  ;", "this . features . forEach (  (    feature ,    enabled )     -  >    configureFeature ( objectMapper ,    feature ,    enabled )  )  ;", "if    (  ( this . handlerInstantiator )     !  =    null )     {", "objectMapper . setHandlerInstantiator ( this . handlerInstantiator )  ;", "} else", "if    (  ( this . applicationContext )     !  =    null )     {", "objectMapper . setHandlerInstantiator ( new   SpringHandlerInstantiator ( this . applicationContext . getAutowireCapableBeanFactory (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( feature   instanceof   JsonParser . Feature )     {", "objectMapper . configure (  (  ( JsonParser . Feature )     ( feature )  )  ,    enabled )  ;", "} else", "if    ( feature   instanceof   com . fasterxml . jackson . core . JsonGenerator . Feature )     {", "objectMapper . configure (  (  ( com . fasterxml . jackson . core . JsonGenerator . Feature )     ( feature )  )  ,    enabled )  ;", "} else", "if    ( feature   instanceof   com . fasterxml . jackson . databind . SerializationFeature )     {", "objectMapper . configure (  (  ( com . fasterxml . jackson . databind . SerializationFeature )     ( feature )  )  ,    enabled )  ;", "} else", "if    ( feature   instanceof   com . fasterxml . jackson . databind . DeserializationFeature )     {", "objectMapper . configure (  (  ( com . fasterxml . jackson . databind . DeserializationFeature )     ( feature )  )  ,    enabled )  ;", "} else", "if    ( feature   instanceof   com . fasterxml . jackson . databind . MapperFeature )     {", "objectMapper . configure (  (  ( com . fasterxml . jackson . databind . MapperFeature )     ( feature )  )  ,    enabled )  ;", "} else    {", "throw   new   beans . FatalBeanException (  (  \" Unknown   feature   class :     \"     +     ( feature . getClass (  )  . getName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureFeature"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . createXmlMapper    =    createXmlMapper ;", "return   this ;", "}", "METHOD_END"], "methodName": ["createXmlMapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . features . containsKey ( MapperFeature . DEFAULT _ VIEW _ INCLUSION )  )  )     {", "configureFeature ( o ,    MapperFeature . DEFAULT _ VIEW _ INCLUSION ,    false )  ;", "}", "if    (  !  ( this . features . containsKey ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  )     {", "configureFeature ( o ,    DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["customizeDefaultFeatures"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . dateFormat    =    dateFormat ;", "return   this ;", "}", "METHOD_END"], "methodName": ["dateFormat"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . defaultTyping    =    typeResolverBuilder ;", "return   this ;", "}", "METHOD_END"], "methodName": ["defaultTyping"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . defaultUseWrapper    =    defaultUseWrapper ;", "return   this ;", "}", "METHOD_END"], "methodName": ["defaultUseWrapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . features . put ( MapperFeature . DEFAULT _ VIEW _ INCLUSION ,    defaultViewInclusion )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["defaultViewInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . deserializers . put ( type ,    deserializer )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["deserializerByType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( JsonDeserializer <  ?  >    deserializer    :    deserializers )     {", "Class <  ?  >    handledType    =    deserializer . handledType (  )  ;", "if    (  ( handledType    =  =    null )     |  |     ( handledType    =  =     (  . class )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Unknown   handled   type   in    \"     +     ( deserializer . getClass (  )  . getName (  )  )  )  )  ;", "}", "this . deserializers . put ( deserializer . handledType (  )  ,    deserializer )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["deserializers"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . deserializers . putAll ( deserializers )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["deserializersByType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . factory    =    factory ;", "return   this ;", "}", "METHOD_END"], "methodName": ["factory"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . features . put ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS ,    failOnEmptyBeans )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["failOnEmptyBeans"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . features . put ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES ,    failOnUnknownProperties )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["failOnUnknownProperties"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   feature    :    featuresToDisable )     {", "this . features . put ( feature ,    Boolean . FALSE )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["featuresToDisable"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   feature    :    featuresToEnable )     {", "this . features . put ( feature ,    Boolean . TRUE )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["featuresToEnable"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . filters    =    filters ;", "return   this ;", "}", "METHOD_END"], "methodName": ["filters"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . findModulesViaServiceLoader    =    findModules ;", "return   this ;", "}", "METHOD_END"], "methodName": ["findModulesViaServiceLoader"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . handlerInstantiator    =    handlerInstantiator ;", "return   this ;", "}", "METHOD_END"], "methodName": ["handlerInstantiator"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . features . put ( SerializationFeature . INDENT _ OUTPUT ,    indentOutput )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["indentOutput"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   Jackson 2 ObjectMapperBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["json"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . locale    =    StringUtils . parseLocale ( localeString )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["locale"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . locale    =    locale ;", "return   this ;", "}", "METHOD_END"], "methodName": ["locale"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . mixIns . put ( target ,    mixinSource )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mixIn"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . mixIns . putAll ( mixIns )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mixIns"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . moduleClassLoader    =    moduleClassLoader ;", "return   this ;", "}", "METHOD_END"], "methodName": ["moduleClassLoader"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "return   modules ( Arrays . asList ( modules )  )  ;", "}", "METHOD_END"], "methodName": ["modules"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . modules    =    new   LinkedList <  >  ( modules )  ;", "this . findModulesViaServiceLoa    =    false ;", "this . findWellKnownModules    =    false ;", "return   this ;", "}", "METHOD_END"], "methodName": ["modules"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . modules    =    Arrays . asList ( modules )  ;", "this . findWellKnownModules    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["modulesToInstall"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . moduleClasses    =    modules ;", "this . fdWellKnownModules    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["modulesToInstall"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . propertyNamingStrategy    =    propertyNamingStrategy ;", "return   this ;", "}", "METHOD_END"], "methodName": ["propertyNamingStrategy"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?    extends   Module >    jdk 8 Module    =     (  ( Class <  ?    extends   Module >  )     ( ClassUtils . forName (  \" com . fasterxml . jackson . datatype . jdk 8  . Jdk 8 Module \"  ,    this . moduleClassLoader )  )  )  ;", "objectMapper . registerModule ( BeanUtils . instantiateClass ( jdk 8 Module )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "}", "try    {", "Class <  ?    extends   Module >    javaTimeModule    =     (  ( Class <  ?    extends   Module >  )     ( ClassUtils . forName (  \" com . fasterxml . jackson . datatype . jsr 3  1  0  . JavaTimeModule \"  ,    this . moduleClassLoader )  )  )  ;", "objectMapper . registerModule ( BeanUtils . instantiateClass ( javaTimeModule )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "}", "if    ( ClassUtils . isPresent (  \" LocalDate \"  ,    this . moduleClassLoader )  )     {", "try    {", "Class <  ?    extends   Module >    jodaModule    =     (  ( Class <  ?    extends   Module >  )     ( ClassUtils . forName (  \" com . fasterxml . jackson . datatype . joda . JodaModule \"  ,    this . moduleClassLoader )  )  )  ;", "objectMapper . registerModule ( BeanUtils . instantiateClass ( jodaModule )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "}", "}", "if    ( KotlinDetector . isKotlinPresent (  )  )     {", "try    {", "Class <  ?    extends   Module >    kotlinModule    =     (  ( Class <  ?    extends   Module >  )     ( ClassUtils . forName (  \" com . fasterxml . jackson . module . kotlin . KotlinModule \"  ,    this . moduleClassLoader )  )  )  ;", "objectMapper . registerModule ( BeanUtils . instantiateClass ( kotlinModule )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "if    (  !  (  . kotlinWarningLogged )  )     {", ". kotlinWarningLogged    =    true ;", "logger . warn (  (  \" For   Jackson   Kotlin   classes   support   please   add    \"     +     \"  \\  \" com . fasterxml . jackson . module : jackson - module - kotlin \\  \"    to   the   classpath \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["registerWellKnownModulesIfAvailable"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . serializationInclusion    =    serializationInclusion ;", "return   this ;", "}", "METHOD_END"], "methodName": ["serializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . serializers . put ( type ,    serializer )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["serializerByType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( JsonSerializer <  ?  >    serializer    :    serializers )     {", "Class <  ?  >    handledType    =    serializer . handledType (  )  ;", "if    (  ( handledType    =  =    null )     |  |     ( handledType    =  =     (  . class )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Unknown   handled   type   in    \"     +     ( serializer . getClass (  )  . getName (  )  )  )  )  ;", "}", "this . serializers . put ( serializer . handledType (  )  ,    serializer )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["serializers"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . serializers . putAll ( serializers )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["serializersByType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . dateFormat    =    new   SimpleDateFormat ( format )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["simpleDateFormat"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   Jackson 2 ObjectMapperBuilder (  )  . factory ( new   Jackson 2 ObjectMapperBuilder . SmileFactoryInitializer (  )  . create (  )  )  ;", "}", "METHOD_END"], "methodName": ["smile"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . timeZone    =    StringUtils . parseTimeZoneString ( timeZoneString )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["timeZone"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "this . timeZone    =    timeZone ;", "return   this ;", "}", "METHOD_END"], "methodName": ["timeZone"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   Jackson 2 ObjectMapperBuilder (  )  . createXmlMapper ( true )  ;", "}", "METHOD_END"], "methodName": ["xml"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . featuresToEnable ( MapperFeature . DEFAULT _ VIEW _ INCLUSION ,    DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES ,    SerializationFeature . INDENT _ OUTPUT )  . featuresToDisable ( MapperFeature . AUTO _ DETECT _ FIELDS ,    MapperFeature . AUTO _ DETECT _ GETTERS ,    MapperFeature . AUTO _ DETECT _ SETTERS ,    SerializationFeature . FAIL _ ON _ EMPTY _ BEANS )  . build (  )  ;", "assertNotNull ( objectMapper )  ;", "assertTrue ( objectMapper . isEnabled ( MapperFeature . DEFAULT _ VIEW _ INCLUSION )  )  ;", "assertTrue ( objectMapper . isEnabled ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  ;", "assertFalse ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ FIELDS )  )  ;", "assertFalse ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ GETTERS )  )  ;", "assertFalse ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ SETTERS )  )  ;", "assertTrue ( objectMapper . isEnabled ( SerializationFeature . INDENT _ OUTPUT )  )  ;", "assertFalse ( objectMapper . isEnabled ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS )  )  ;", "}", "METHOD_END"], "methodName": ["booleanSetters"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . cbor (  )  . build (  )  ;", "assertNotNull ( objectMapper )  ;", "assertEquals ( CBORFactory . class ,    objectMapper . getFactory (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["cbor"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "NopAnnotationIntrospector   annotationIntrospector    =    NopAnnotationIntrospector . instance ;", "Map < Class <  ?  >  ,    JsonDeserializer <  ?  >  >    deserializerMap    =    new   HashMap <  >  (  )  ;", "JsonDeserializer < Date >    deserializer    =    new   DateDeserializers . DateDeserializer (  )  ;", "deserializerMap . put ( Date . class ,    deserializer )  ;", "JsonSerializer < Class <  ?  >  >    serializer 1     =    new   ClassSerializer (  )  ;", "JsonSerializer < Number >    serializer 2     =    new   NumberSerializer ( Integer . class )  ;", "Jackson 2 ObjectMapperBuilder   builder    =    Jackson 2 ObjectMapperBuilder . json (  )  . modules ( new   ArrayList <  >  (  )  )  . serializers ( serializer 1  )  . serializersByType ( Collections . singletonMap ( Boolean . class ,    serializer 2  )  )  . deserializersByType ( deserializerMap )  . annotationIntrospector ( annotationIntrospector )  . featuresToEnable ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS ,    DeserializationFeature . UNWRAP _ ROOT _ VALUE ,    JsonParser . Feature . ALLOW _ BACKSLASH _ ESCAPING _ ANY _ CHARACTER ,    JsonGenerator . Feature . WRITE _ NUMBERS _ AS _ STRINGS )  . featuresToDisable ( MapperFeature . AUTO _ DETECT _ GETTERS ,    MapperFeature . AUTO _ DETECT _ FIELDS ,    JsonParser . Feature . AUTO _ CLOSE _ SOURCE ,    JsonGenerator . Feature . QUOTE _ FIELD _ NAMES )  . serializationInclusion ( JsonInclude . Include . NON _ NULL )  ;", "ObjectMapper   mapper    =    new   ObjectMapper (  )  ;", "builder . configure ( mapper )  ;", "assertTrue (  . getSerializerFactoryConfig ( mapper )  . hasSerializers (  )  )  ;", "assertTrue (  . getDeserializerFactoryConfig ( mapper )  . hasDeserializers (  )  )  ;", "Serializers   serializers    =     . getSerializerFactoryConfig ( mapper )  . serializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( serializer 1  ,    serializers . findSerializer ( null ,    SimpleType . construct ( Class . class )  ,    null )  )  ;", "assertSame ( serializer 2  ,    serializers . findSerializer ( null ,    SimpleType . construct ( Boolean . class )  ,    null )  )  ;", "assertNull ( serializers . findSerializer ( null ,    SimpleType . construct ( Number . class )  ,    null )  )  ;", "Deserializers   deserializers    =     . getDeserializerFactoryConfig ( mapper )  . deserializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( deserializer ,    deserializers . findBeanDeserializer ( SimpleType . construct ( Date . class )  ,    null ,    null )  )  ;", "assertSame ( annotationIntrospector ,    mapper . getSerializationConfig (  )  . getAnnotationIntrospector (  )  )  ;", "assertSame ( annotationIntrospector ,    mapper . getDeserializationConfig (  )  . getAnnotationIntrospector (  )  )  ;", "assertTrue ( mapper . getSerializationConfig (  )  . isEnabled ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS )  )  ;", "assertTrue ( mapper . getDeserializationConfig (  )  . isEnabled ( DeserializationFeature . UNWRAP _ ROOT _ VALUE )  )  ;", "assertTrue ( mapper . getFactory (  )  . isEnabled ( JsonParser . Feature . ALLOW _ BACKSLASH _ ESCAPING _ ANY _ CHARACTER )  )  ;", "assertTrue ( mapper . getFactory (  )  . isEnabled ( JsonGenerator . Feature . WRITE _ NUMBERS _ AS _ STRINGS )  )  ;", "assertFalse ( mapper . getSerializationConfig (  )  . isEnabled ( MapperFeature . AUTO _ DETECT _ GETTERS )  )  ;", "assertFalse ( mapper . getDeserializationConfig (  )  . isEnabled ( MapperFeature . DEFAULT _ VIEW _ INCLUSION )  )  ;", "assertFalse ( mapper . getDeserializationConfig (  )  . isEnabled ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  ;", "assertFalse ( mapper . getDeserializationConfig (  )  . isEnabled ( MapperFeature . AUTO _ DETECT _ FIELDS )  )  ;", "assertFalse ( mapper . getFactory (  )  . isEnabled ( JsonParser . Feature . AUTO _ CLOSE _ SOURCE )  )  ;", "assertFalse ( mapper . getFactory (  )  . isEnabled ( JsonGenerator . Feature . QUOTE _ FIELD _ NAMES )  )  ;", "assertSame ( JsonInclude . Include . NON _ NULL ,    mapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["completeSetup"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Jackson 2 ObjectMapperBuilder   builder    =    Jackson 2 ObjectMapperBuilder . json (  )  . indentOutput ( true )  ;", "ObjectMapper   jsonObjectMapper    =    builder . build (  )  ;", "ObjectMapper   xmlObjectMapper    =    builder . createXmlMapper ( true )  . build (  )  ;", "assertTrue ( jsonObjectMapper . isEnabled ( SerializationFeature . INDENT _ OUTPUT )  )  ;", "assertTrue ( xmlObjectMapper . isEnabled ( SerializationFeature . INDENT _ OUTPUT )  )  ;", "assertTrue ( xmlObjectMapper . getClass (  )  . isAssignableFrom ( XmlMapper . class )  )  ;", "}", "METHOD_END"], "methodName": ["createXmlMapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . modulesToInstall ( new   Jackson 2 ObjectMapperBuilderTests . CustomIntegerModule (  )  )  . build (  )  ;", "DateTime   dateTime    =    new   DateTime (  1  3  2  2  9  0  3  7  3  0  0  0  0 L ,    DateTimeZone . UTC )  ;", "assertEquals (  \"  1  3  2  2  9  0  3  7  3  0  0  0  0  \"  ,    new   String ( objectMapper . writeValueAsBytes ( dateTime )  ,     \" UTF -  8  \"  )  )  ;", "assertThat ( new   String ( objectMapper . writeValueAsBytes ( new   Integer (  4  )  )  ,     \" UTF -  8  \"  )  ,    containsString (  \" customid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeWellKnownModulesWithModule"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . modulesToInstall ( Jackson 2 ObjectMapperBuilderTests . CustomIntegerModule . class )  . build (  )  ;", "DateTime   dateTime    =    new   DateTime (  1  3  2  2  9  0  3  7  3  0  0  0  0 L ,    DateTimeZone . UTC )  ;", "assertEquals (  \"  1  3  2  2  9  0  3  7  3  0  0  0  0  \"  ,    new   String ( objectMapper . writeValueAsBytes ( dateTime )  ,     \" UTF -  8  \"  )  )  ;", "assertThat ( new   String ( objectMapper . writeValueAsBytes ( new   Integer (  4  )  )  ,     \" UTF -  8  \"  )  ,    containsString (  \" customid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeWellKnownModulesWithModuleClass"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . serializerByType ( Integer . class ,    new   Jackson 2 ObjectMapperBuilderTests . CustomIntegerSerializer (  )  )  . build (  )  ;", "DateTime   dateTime    =    new   DateTime (  1  3  2  2  9  0  3  7  3  0  0  0  0 L ,    DateTimeZone . UTC )  ;", "assertEquals (  \"  1  3  2  2  9  0  3  7  3  0  0  0  0  \"  ,    new   String ( objectMapper . writeValueAsBytes ( dateTime )  ,     \" UTF -  8  \"  )  )  ;", "assertThat ( new   String ( objectMapper . writeValueAsBytes ( new   Integer (  4  )  )  ,     \" UTF -  8  \"  )  ,    containsString (  \" customid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeWellKnownModulesWithSerializer"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleDateFormat   dateFormat    =    new   SimpleDateFormat ( Jackson 2 ObjectMapperBuilderTests . DATE _ FORMAT )  ;", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . dateFormat ( dateFormat )  . build (  )  ;", "assertEquals ( dateFormat ,    objectMapper . getSerializationConfig (  )  . getDateFormat (  )  )  ;", "assertEquals ( dateFormat ,    objectMapper . getDeserializationConfig (  )  . getDateFormat (  )  )  ;", "}", "METHOD_END"], "methodName": ["dateTimeFormatSetter"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . build (  )  ;", "assertNotNull ( objectMapper )  ;", "assertFalse ( objectMapper . isEnabled ( MapperFeature . DEFAULT _ VIEW _ INCLUSION )  )  ;", "assertFalse ( objectMapper . isEnabled ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  ;", "assertTrue ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ FIELDS )  )  ;", "assertTrue ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ GETTERS )  )  ;", "assertTrue ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ IS _ GETTERS )  )  ;", "assertTrue ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ SETTERS )  )  ;", "assertFalse ( objectMapper . isEnabled ( SerializationFeature . INDENT _ OUTPUT )  )  ;", "assertTrue ( objectMapper . isEnabled ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS )  )  ;", "}", "METHOD_END"], "methodName": ["defaultProperties"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . xml (  )  . defaultUseWrapper ( false )  . build (  )  ;", "assertNotNull ( objectMapper )  ;", "assertEquals ( XmlMapper . class ,    objectMapper . getClass (  )  )  ;", ". ListContainer < String >    container    =    new    . ListContainer <  >  ( Arrays . asList (  \" foo \"  ,     \" bar \"  )  )  ;", "String   output    =    objectMapper . writeValueAsString ( container )  ;", "assertThat ( output ,    containsString (  \"  < list > foo <  / list >  < list > bar <  / list >  <  / ListContainer >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultUseWrapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "JsonDeserializer < Date >    deserializer    =    new   DateDeserializers . DateDeserializer (  )  ;", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . modules ( new   ArrayList <  >  (  )  )  . deserializerByType ( Date . class ,    deserializer )  . build (  )  ;", "assertTrue (  . getDeserializerFactoryConfig ( objectMapper )  . hasDeserializers (  )  )  ;", "Deserializers   deserializers    =     . getDeserializerFactoryConfig ( objectMapper )  . deserializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( deserializer ,    deserializers . findBeanDeserializer ( SimpleType . construct ( Date . class )  ,    null ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["deserializerByType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    new   Jackson 2 ObjectMapperBuilder (  )  . factory ( new   SmileFactory (  )  )  . build (  )  ;", "assertNotNull ( objectMapper )  ;", "assertEquals ( SmileFactory . class ,    objectMapper . getFactory (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["factory"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . filters ( new   SimpleFilterProvider (  )  . setFailOnUnknownId ( false )  )  . build (  )  ;", ". JacksonFilteredBean   bean    =    new    . JacksonFilteredBean (  \" value 1  \"  ,     \" value 2  \"  )  ;", "String   output    =    objectMapper . writeValueAsString ( bean )  ;", "assertThat ( output ,    containsString (  \" value 1  \"  )  )  ;", "assertThat ( output ,    containsString (  \" value 2  \"  )  )  ;", "SimpleFilterProvider   provider    =    new   SimpleFilterProvider (  )  . setFailOnUnknownId ( false )  . setDefaultFilter ( SimpleBeanPropertyFilter . serializeAllExcept (  \" property 2  \"  )  )  ;", "objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . filters ( provider )  . build (  )  ;", "output    =    objectMapper . writeValueAsString ( bean )  ;", "assertThat ( output ,    containsString (  \" value 1  \"  )  )  ;", "assertThat ( output ,    not ( containsString (  \" value 2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["filters"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( BasicDeserializerFactory )     ( objectMapper . getDeserializationContext (  )  . getFactory (  )  )  )  . getFactoryConfig (  )  ;", "}", "METHOD_END"], "methodName": ["getDeserializerFactoryConfig"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( BasicSerializerFactory )     ( objectMapper . getSerializerFactory (  )  )  )  . getFactoryConfig (  )  ;", "}", "METHOD_END"], "methodName": ["getSerializerFactoryConfig"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . locale ( Locale . FRENCH )  . build (  )  ;", "assertEquals ( Locale . FRENCH ,    objectMapper . getSerializationConfig (  )  . getLocale (  )  )  ;", "assertEquals ( Locale . FRENCH ,    objectMapper . getDeserializationConfig (  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["localeSetter"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    target    =    String . class ;", "Class <  ?  >    mixInSource    =    Object . class ;", "ObjectMapper   objectMapper    =     . json (  )  . modules (  )  . mixIn ( target ,    mixInSource )  . build (  )  ;", "assertEquals (  1  ,    objectMapper . mixInCount (  )  )  ;", "assertSame ( mixInSource ,    objectMapper . findMixInClassFor ( target )  )  ;", "}", "METHOD_END"], "methodName": ["mixIn"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    target    =    String . class ;", "Class <  ?  >    mixInSource    =    Object . class ;", "Map < Class <  ?  >  ,    Class <  ?  >  >    mixIns    =    new   HashMap <  >  (  )  ;", "mixIns . put ( target ,    mixInSource )  ;", "ObjectMapper   objectMapper    =     . json (  )  . modules (  )  . mixIns ( mixIns )  . build (  )  ;", "assertEquals (  1  ,    objectMapper . mixInCount (  )  )  ;", "assertSame ( mixInSource ,    objectMapper . findMixInClassFor ( target )  )  ;", "}", "METHOD_END"], "methodName": ["mixIns"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "NumberSerializer   serializer 1     =    new   NumberSerializer ( Integer . class )  ;", "SimpleModule   module    =    new   SimpleModule (  )  ;", "module . addSerializer ( Integer . class ,    serializer 1  )  ;", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . modules ( module )  . build (  )  ;", "Serializers   serializers    =     . getSerializerFactoryConfig ( objectMapper )  . serializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( serializer 1  ,    serializers . findSerializer ( null ,    SimpleType . construct ( Integer . class )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["modules"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . modulesToInstall ( Jackson 2 ObjectMapperBuilderTests . CustomIntegerModule . class )  . build (  )  ;", "Serializers   serializers    =    Jackson 2 ObjectMapperBuilderTests . getSerializerFactoryConfig ( objectMapper )  . serializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( Jackson 2 ObjectMapperBuilderTests . CustomIntegerSerializer . class ,    serializers . findSerializer ( null ,    SimpleType . construct ( Integer . class )  ,    null )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["modulesToInstallByClass"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . modulesToInstall ( new   Jackson 2 ObjectMapperBuilderTests . CustomIntegerModule (  )  )  . build (  )  ;", "Serializers   serializers    =    Jackson 2 ObjectMapperBuilderTests . getSerializerFactoryConfig ( objectMapper )  . serializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( Jackson 2 ObjectMapperBuilderTests . CustomIntegerSerializer . class ,    serializers . findSerializer ( null ,    SimpleType . construct ( Integer . class )  ,    null )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["modulesToInstallByInstance"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . autoDetectFields ( false )  . defaultViewInclusion ( true )  . failOnUnknownProperties ( true )  . failOnEmptyBeans ( false )  . autoDetectGettersSetters ( false )  . indentOutput ( true )  . build (  )  ;", "assertNotNull ( objectMapper )  ;", "assertTrue ( objectMapper . isEnabled ( MapperFeature . DEFAULT _ VIEW _ INCLUSION )  )  ;", "assertTrue ( objectMapper . isEnabled ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  ;", "assertFalse ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ FIELDS )  )  ;", "assertFalse ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ GETTERS )  )  ;", "assertFalse ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ IS _ GETTERS )  )  ;", "assertFalse ( objectMapper . isEnabled ( MapperFeature . AUTO _ DETECT _ SETTERS )  )  ;", "assertTrue ( objectMapper . isEnabled ( SerializationFeature . INDENT _ OUTPUT )  )  ;", "assertFalse ( objectMapper . isEnabled ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS )  )  ;", "}", "METHOD_END"], "methodName": ["propertiesShortcut"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "PropertyNamingStrategy   strategy    =    new   PropertyNamingStrategy . LowerCaseWithUnderscoresStrategy (  )  ;", "ObjectMapper   objectMapper    =     . json (  )  . propertyNamingStrategy ( strategy )  . build (  )  ;", "assertSame ( strategy ,    objectMapper . getSerializationConfig (  )  . getPropertyNamingStrategy (  )  )  ;", "assertSame ( strategy ,    objectMapper . getDeserializationConfig (  )  . getPropertyNamingStrategy (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyNamingStrategy"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "JsonSerializer < Number >    serializer    =    new   NumberSerializer ( Integer . class )  ;", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . modules ( new   ArrayList <  >  (  )  )  . serializerByType ( Boolean . class ,    serializer )  . build (  )  ;", "assertTrue (  . getSerializerFactoryConfig ( objectMapper )  . hasSerializers (  )  )  ;", "Serializers   serializers    =     . getSerializerFactoryConfig ( objectMapper )  . serializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( serializer ,    serializers . findSerializer ( null ,    SimpleType . construct ( Boolean . class )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["serializerByType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . build (  )  ;", "assertSame ( JsonInclude . Include . ALWAYS ,    objectMapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . serializationInclusion ( JsonInclude . Include . NON _ DEFAULT )  . build (  )  ;", "assertSame ( JsonInclude . Include . NON _ DEFAULT ,    objectMapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["setNotDefaultSerializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . build (  )  ;", "assertSame ( JsonInclude . Include . ALWAYS ,    objectMapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . serializationInclusion ( JsonInclude . Include . NON _ EMPTY )  . build (  )  ;", "assertSame ( JsonInclude . Include . NON _ EMPTY ,    objectMapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["setNotEmptySerializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . build (  )  ;", "assertSame ( JsonInclude . Include . ALWAYS ,    objectMapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . serializationInclusion ( JsonInclude . Include . NON _ NULL )  . build (  )  ;", "assertSame ( JsonInclude . Include . NON _ NULL ,    objectMapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["setNotNullSerializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleDateFormat   dateFormat    =    new   SimpleDateFormat ( Jackson 2 ObjectMapperBuilderTests . DATE _ FORMAT )  ;", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . simpleDateFormat ( Jackson 2 ObjectMapperBuilderTests . DATE _ FORMAT )  . build (  )  ;", "assertEquals ( dateFormat ,    objectMapper . getSerializationConfig (  )  . getDateFormat (  )  )  ;", "assertEquals ( dateFormat ,    objectMapper . getDeserializationConfig (  )  . getDateFormat (  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleDateFormatStringSetter"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . smile (  )  . build (  )  ;", "assertNotNull ( objectMapper )  ;", "assertEquals ( SmileFactory . class ,    objectMapper . getFactory (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["smile"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "TimeZone   timeZone    =    TimeZone . getTimeZone (  \" Europe / Paris \"  )  ;", "ObjectMapper   objectMapper    =     . json (  )  . timeZone ( timeZone )  . build (  )  ;", "assertEquals ( timeZone ,    objectMapper . getSerializationConfig (  )  . getTimeZone (  )  )  ;", "assertEquals ( timeZone ,    objectMapper . getDeserializationConfig (  )  . getTimeZone (  )  )  ;", "}", "METHOD_END"], "methodName": ["timeZoneSetter"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   zoneId    =     \" Europe / Paris \"  ;", "ObjectMapper   objectMapper    =     . json (  )  . timeZone ( zoneId )  . build (  )  ;", "TimeZone   timeZone    =    TimeZone . getTimeZone ( zoneId )  ;", "assertEquals ( timeZone ,    objectMapper . getSerializationConfig (  )  . getTimeZone (  )  )  ;", "assertEquals ( timeZone ,    objectMapper . getDeserializationConfig (  )  . getTimeZone (  )  )  ;", "}", "METHOD_END"], "methodName": ["timeZoneStringSetter"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Jackson 2 ObjectMapperBuilder . json (  )  . featuresToEnable ( Boolean . TRUE )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["unknownFeature"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . build (  )  ;", "Long   timestamp    =     1  3  2  2  9  0  3  7  3  0  0  0  0 L ;", "DateTime   dateTime    =    new   DateTime ( timestamp ,    DateTimeZone . UTC )  ;", "assertEquals ( timestamp . toString (  )  ,    new   String ( objectMapper . writeValueAsBytes ( dateTime )  ,     \" UTF -  8  \"  )  )  ;", "Path   file    =    Paths . get (  \" foo \"  )  ;", "assertTrue ( new   String ( objectMapper . writeValueAsBytes ( file )  ,     \" UTF -  8  \"  )  . endsWith (  \" foo \\  \"  \"  )  )  ;", "Optional < String >    optional    =    Optional . of (  \" test \"  )  ;", "assertEquals (  \"  \\  \" test \\  \"  \"  ,    new   String ( objectMapper . writeValueAsBytes ( optional )  ,     \" UTF -  8  \"  )  )  ;", "IntRange   range    =    new   IntRange (  1  ,     3  )  ;", "assertEquals (  \"  {  \\  \" start \\  \"  :  1  ,  \\  \" end \\  \"  :  3  }  \"  ,    new   String ( objectMapper . writeValueAsBytes ( range )  ,     \" UTF -  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["wellKnownModules"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   zoneId    =     \" foo \"  ;", ". json (  )  . timeZone ( zoneId )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["wrongTimeZoneStringSetter"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    Jackson 2 ObjectMapperBuilder . xml (  )  . build (  )  ;", "assertNotNull ( objectMapper )  ;", "assertEquals ( XmlMapper . class ,    objectMapper . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["xmlMapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . builder . annotationIntrospector ( annotationIntrospector )  ;", "}", "METHOD_END"], "methodName": ["setAnnotationIntrospector"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . autoDetectFields ( autoDetectFields )  ;", "}", "METHOD_END"], "methodName": ["setAutoDetectFields"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . autoDetectGettersSetters ( autoDetectGettersSetters )  ;", "}", "METHOD_END"], "methodName": ["setAutoDetectGettersSetters"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . createXmlMapper ( createXmlMapper )  ;", "}", "METHOD_END"], "methodName": ["setCreateXmlMapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . dateFormat ( dateFormat )  ;", "}", "METHOD_END"], "methodName": ["setDateFormat"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . defaultTyping ( typeResolverBuilder )  ;", "}", "METHOD_END"], "methodName": ["setDefaultTyping"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . defaultUseWrapper ( defaultUseWrapper )  ;", "}", "METHOD_END"], "methodName": ["setDefaultUseWrapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . defaultViewInclusion ( defaultViewInclusion )  ;", "}", "METHOD_END"], "methodName": ["setDefaultViewInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . deserializers ( deserializers )  ;", "}", "METHOD_END"], "methodName": ["setDeserializers"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . deserializersByType ( deserializers )  ;", "}", "METHOD_END"], "methodName": ["setDeserializersByType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . factory ( factory )  ;", "}", "METHOD_END"], "methodName": ["setFactory"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . failOnEmptyBeans ( failOnEmptyBeans )  ;", "}", "METHOD_END"], "methodName": ["setFailOnEmptyBeans"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . failOnUnknownProperties ( failOnUnknownProperties )  ;", "}", "METHOD_END"], "methodName": ["setFailOnUnknownProperties"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . featuresToDisable ( featuresToDisable )  ;", "}", "METHOD_END"], "methodName": ["setFeaturesToDisable"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . featuresToEnable ( featuresToEnable )  ;", "}", "METHOD_END"], "methodName": ["setFeaturesToEnable"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . filters ( filters )  ;", "}", "METHOD_END"], "methodName": ["setFilters"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . findModulesViaServiceLoader ( findModules )  ;", "}", "METHOD_END"], "methodName": ["setFindModulesViaServiceLoader"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . handlerInstantiator ( handlerInstantiator )  ;", "}", "METHOD_END"], "methodName": ["setHandlerInstantiator"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . indentOutput ( indentOutput )  ;", "}", "METHOD_END"], "methodName": ["setIndentOutput"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . locale ( locale )  ;", "}", "METHOD_END"], "methodName": ["setLocale"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . mixIns ( mixIns )  ;", "}", "METHOD_END"], "methodName": ["setMixIns"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . modules ( modules )  ;", "}", "METHOD_END"], "methodName": ["setModules"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . modulesToInstall ( modules )  ;", "}", "METHOD_END"], "methodName": ["setModulesToInstall"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . objectMapper    =    objectMapper ;", "}", "METHOD_END"], "methodName": ["setObjectMapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . propertyNamingStrategy ( propertyNamingStrategy )  ;", "}", "METHOD_END"], "methodName": ["setPropertyNamingStrategy"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . serializationInclusion ( serializationInclusion )  ;", "}", "METHOD_END"], "methodName": ["setSerializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . serializers ( serializers )  ;", "}", "METHOD_END"], "methodName": ["setSerializers"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . serializersByType ( serializers )  ;", "}", "METHOD_END"], "methodName": ["setSerializersByType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . simpleDateFormat ( format )  ;", "}", "METHOD_END"], "methodName": ["setSimpleDateFormat"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . builder . timeZone ( timeZone )  ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . factory . setAutoDetectFields ( false )  ;", "this . factory . setAutoDetectGettersSetters ( false )  ;", "this . factory . setDefaultViewInclusion ( false )  ;", "this . factory . setFailOnEmptyBeans ( false )  ;", "this . factory . setIndentOutput ( true )  ;", "this . factory . afterPropertiesSet (  )  ;", "objectMapper    =    this . factory . getObject (  )  ;", "assertFalse ( objectMapper . getSerializationConfig (  )  . isEnabled ( MapperFeature . AUTO _ DETECT _ FIELDS )  )  ;", "assertFalse ( objectMapper . getDeserializationConfig (  )  . isEnabled ( MapperFeature . AUTO _ DETECT _ FIELDS )  )  ;", "assertFalse ( objectMapper . getSerializationConfig (  )  . isEnabled ( MapperFeature . AUTO _ DETECT _ GETTERS )  )  ;", "assertFalse ( objectMapper . getDeserializationConfig (  )  . isEnabled ( MapperFeature . AUTO _ DETECT _ SETTERS )  )  ;", "assertFalse ( objectMapper . getDeserializationConfig (  )  . isEnabled ( MapperFeature . DEFAULT _ VIEW _ INCLUSION )  )  ;", "assertFalse ( objectMapper . getSerializationConfig (  )  . isEnabled ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS )  )  ;", "assertTrue ( objectMapper . getSerializationConfig (  )  . isEnabled ( SerializationFeature . INDENT _ OUTPUT )  )  ;", "assertSame ( JsonInclude . Include . ALWAYS ,    objectMapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["booleanSetters"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "NopAnnotationIntrospector   annotationIntrospector    =    NopAnnotationIntrospector . instance ;", "ObjectMapper   objectMapper    =    new   ObjectMapper (  )  ;", "this . factory . setObjectMapper ( objectMapper )  ;", "assertTrue ( this . factory . isSingleton (  )  )  ;", "assertEquals ( ObjectMapper . class ,    this . factory . getObjectType (  )  )  ;", "Map < Class <  ?  >  ,    JsonDeserializer <  ?  >  >    deserializers    =    new   HashMap <  >  (  )  ;", "deserializers . put ( Date . class ,    new   DateDeserializers . DateDeserializer (  )  )  ;", "JsonSerializer < Class <  ?  >  >    serializer 1     =    new   ClassSerializer (  )  ;", "JsonSerializer < Number >    serializer 2     =    new   NumberSerializer ( Integer . class )  ;", "this . factory . setModules ( new   ArrayList <  >  (  )  )  ;", "this . factory . setSerializers ( serializer 1  )  ;", "this . factory . setSerializersByType ( Collections . singletonMap ( Boolean . class ,    serializer 2  )  )  ;", "this . factory . setDeserializersByType ( deserializers )  ;", "this . factory . setAnnotationIntrospector ( annotationIntrospector )  ;", "this . factory . setFeaturesToEnable ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS ,    DeserializationFeature . UNWRAP _ ROOT _ VALUE ,    JsonParser . Feature . ALLOW _ BACKSLASH _ ESCAPING _ ANY _ CHARACTER ,    JsonGenerator . Feature . WRITE _ NUMBERS _ AS _ STRINGS )  ;", "this . factory . setFeaturesToDisable ( MapperFeature . AUTO _ DETECT _ GETTERS ,    MapperFeature . AUTO _ DETECT _ FIELDS ,    JsonParser . Feature . AUTO _ CLOSE _ SOURCE ,    JsonGenerator . Feature . QUOTE _ FIELD _ NAMES )  ;", "assertFalse (  . getSerializerFactoryConfig ( objectMapper )  . hasSerializers (  )  )  ;", "assertFalse (  . getDeserializerFactoryConfig ( objectMapper )  . hasDeserializers (  )  )  ;", "this . factory . setSerializationInclusion ( JsonInclude . Include . NON _ NULL )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertSame ( objectMapper ,    this . factory . getObject (  )  )  ;", "assertTrue (  . getSerializerFactoryConfig ( objectMapper )  . hasSerializers (  )  )  ;", "assertTrue (  . getDeserializerFactoryConfig ( objectMapper )  . hasDeserializers (  )  )  ;", "Serializers   serializers    =     . getSerializerFactoryConfig ( objectMapper )  . serializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( serializer 1  ,    serializers . findSerializer ( null ,    SimpleType . construct ( Class . class )  ,    null )  )  ;", "assertSame ( serializer 2  ,    serializers . findSerializer ( null ,    SimpleType . construct ( Boolean . class )  ,    null )  )  ;", "assertNull ( serializers . findSerializer ( null ,    SimpleType . construct ( Number . class )  ,    null )  )  ;", "assertSame ( annotationIntrospector ,    objectMapper . getSerializationConfig (  )  . getAnnotationIntrospector (  )  )  ;", "assertSame ( annotationIntrospector ,    objectMapper . getDeserializationConfig (  )  . getAnnotationIntrospector (  )  )  ;", "assertTrue ( objectMapper . getSerializationConfig (  )  . isEnabled ( SerializationFeature . FAIL _ ON _ EMPTY _ BEANS )  )  ;", "assertTrue ( objectMapper . getDeserializationConfig (  )  . isEnabled ( DeserializationFeature . UNWRAP _ ROOT _ VALUE )  )  ;", "assertTrue ( objectMapper . getFactory (  )  . isEnabled ( JsonParser . Feature . ALLOW _ BACKSLASH _ ESCAPING _ ANY _ CHARACTER )  )  ;", "assertTrue ( objectMapper . getFactory (  )  . isEnabled ( JsonGenerator . Feature . WRITE _ NUMBERS _ AS _ STRINGS )  )  ;", "assertFalse ( objectMapper . getSerializationConfig (  )  . isEnabled ( MapperFeature . AUTO _ DETECT _ GETTERS )  )  ;", "assertFalse ( objectMapper . getDeserializationConfig (  )  . isEnabled ( MapperFeature . DEFAULT _ VIEW _ INCLUSION )  )  ;", "assertFalse ( objectMapper . getDeserializationConfig (  )  . isEnabled ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  ;", "assertFalse ( objectMapper . getDeserializationConfig (  )  . isEnabled ( MapperFeature . AUTO _ DETECT _ FIELDS )  )  ;", "assertFalse ( objectMapper . getFactory (  )  . isEnabled ( JsonParser . Feature . AUTO _ CLOSE _ SOURCE )  )  ;", "assertFalse ( objectMapper . getFactory (  )  . isEnabled ( JsonGenerator . Feature . QUOTE _ FIELD _ NAMES )  )  ;", "assertSame ( JsonInclude . Include . NON _ NULL ,    objectMapper . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["completeSetup"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setModulesToInstall ( Jackson 2 ObjectMapperFactoryBeanTests . CustomIntegerModule . class )  ;", "this . factory . afterPropertiesSet (  )  ;", "ObjectMapper   objectMapper    =    this . factory . getObject (  )  ;", "DateTime   dateTime    =    new   DateTime (  1  3  2  2  9  0  3  7  3  0  0  0  0 L ,    DateTimeZone . UTC )  ;", "assertEquals (  \"  1  3  2  2  9  0  3  7  3  0  0  0  0  \"  ,    new   String ( objectMapper . writeValueAsBytes ( dateTime )  ,     \" UTF -  8  \"  )  )  ;", "assertThat ( new   String ( objectMapper . writeValueAsBytes ( new   Integer (  4  )  )  ,     \" UTF -  8  \"  )  ,    containsString (  \" customid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeDefaultModulesWithModuleClass"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Map < Class <  ?  >  ,    JsonSerializer <  ?  >  >    serializers    =    new   HashMap <  >  (  )  ;", "serializers . put ( Integer . class ,    new    . CustomIntegerSerializer (  )  )  ;", "this . factory . setSerializersByType ( serializers )  ;", "this . factory . afterPropertiesSet (  )  ;", "ObjectMapper   objectMapper    =    this . factory . getObject (  )  ;", "DateTime   dateTime    =    new   DateTime (  1  3  2  2  9  0  3  7  3  0  0  0  0 L ,    DateTimeZone . UTC )  ;", "assertEquals (  \"  1  3  2  2  9  0  3  7  3  0  0  0  0  \"  ,    new   String ( objectMapper . writeValueAsBytes ( dateTime )  ,     \" UTF -  8  \"  )  )  ;", "assertThat ( new   String ( objectMapper . writeValueAsBytes ( new   Integer (  4  )  )  ,     \" UTF -  8  \"  )  ,    containsString (  \" customid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeDefaultModulesWithSerializer"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . afterPropertiesSet (  )  ;", "objectMapper    =    this . factory . getObject (  )  ;", "Long   timestamp    =     1  3  2  2  9  0  3  7  3  0  0  0  0 L ;", "DateTime   dateTime    =    new   DateTime ( timestamp ,    DateTimeZone . UTC )  ;", "assertEquals ( timestamp . toString (  )  ,    new   String ( objectMapper . writeValueAsBytes ( dateTime )  ,     \" UTF -  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultModules"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . afterPropertiesSet (  )  ;", "assertSame ( JsonInclude . Include . ALWAYS ,    this . factory . getObject (  )  . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultSerializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( BasicDeserializerFactory )     ( objectMapper . getDeserializationContext (  )  . getFactory (  )  )  )  . getFactoryConfig (  )  ;", "}", "METHOD_END"], "methodName": ["getDeserializerFactoryConfig"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( BasicSerializerFactory )     ( objectMapper . getSerializerFactory (  )  )  )  . getFactoryConfig (  )  ;", "}", "METHOD_END"], "methodName": ["getSerializerFactoryConfig"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setSerializationInclusion ( JsonInclude . Include . NON _ DEFAULT )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertSame ( JsonInclude . Include . NON _ DEFAULT ,    this . factory . getObject (  )  . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["nonDefaultSerializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setSerializationInclusion ( JsonInclude . Include . NON _ EMPTY )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertSame ( JsonInclude . Include . NON _ EMPTY ,    this . factory . getObject (  )  . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["nonEmptySerializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setSerializationInclusion ( JsonInclude . Include . NON _ NULL )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertSame ( JsonInclude . Include . NON _ NULL ,    this . factory . getObject (  )  . getSerializationConfig (  )  . getSerializationInclusion (  )  )  ;", "}", "METHOD_END"], "methodName": ["nonNullSerializationInclusion"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "PropertyNamingStrategy   strategy    =    new   PropertyNamingStrategy . LowerCaseWithUnderscoresStrategy (  )  ;", "this . f . setPropertyNamingStrategy ( strategy )  ;", "this . f . afterPropertiesSet (  )  ;", "assertSame ( strategy ,    this . f . getObject (  )  . getSerializationConfig (  )  . getPropertyNamingStrategy (  )  )  ;", "assertSame ( strategy ,    this . f . getObject (  )  . getDeserializationConfig (  )  . getPropertyNamingStrategy (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyNamingStrategy"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setCreateXmlMapper ( true )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertNotNull ( this . factory . getObject (  )  )  ;", "assertTrue ( this . factory . isSingleton (  )  )  ;", "assertEquals ( XmlMapper . class ,    this . factory . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["setCreateXmlMapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setDateFormat ( this . dateFormat )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertEquals ( this . dateFormat ,    this . factory . getObject (  )  . getSerializationConfig (  )  . getDateFormat (  )  )  ;", "assertEquals ( this . dateFormat ,    this . factory . getObject (  )  . getDeserializationConfig (  )  . getDateFormat (  )  )  ;", "}", "METHOD_END"], "methodName": ["setDateFormat"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setFactory ( new   SmileFactory (  )  )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertNotNull ( this . factory . getObject (  )  )  ;", "assertTrue ( this . factory . isSingleton (  )  )  ;", "assertEquals ( SmileFactory . class ,    this . factory . getObject (  )  . getFactory (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["setFactory"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setFilters ( new   SimpleFilterProvider (  )  . setFailOnUnknownId ( false )  )  ;", "this . factory . afterPropertiesSet (  )  ;", "ObjectMapper   objectMapper    =    this . factory . getObject (  )  ;", ". JacksonFilteredBean   bean    =    new    . JacksonFilteredBean (  \" value 1  \"  ,     \" value 2  \"  )  ;", "String   output    =    objectMapper . writeValueAsString ( bean )  ;", "assertThat ( output ,    containsString (  \" value 1  \"  )  )  ;", "assertThat ( output ,    containsString (  \" value 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setFilters"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setLocale ( Locale . FRENCH )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertEquals ( Locale . FRENCH ,    this . factory . getObject (  )  . getSerializationConfig (  )  . getLocale (  )  )  ;", "assertEquals ( Locale . FRENCH ,    this . factory . getObject (  )  . getDeserializationConfig (  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["setLocale"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    target    =    String . class ;", "Class <  ?  >    mixinSource    =    Object . class ;", "Map < Class <  ?  >  ,    Class <  ?  >  >    mixIns    =    new   HashMap <  >  (  )  ;", "mixIns . put ( target ,    mixinSource )  ;", "this . factory . setModules ( Collections . emptyList (  )  )  ;", "this . factory . setMixIns ( mixIns )  ;", "this . factory . afterPropertiesSet (  )  ;", "objectMapper    =    this . factory . getObject (  )  ;", "assertEquals (  1  ,    objectMapper . mixInCount (  )  )  ;", "assertSame ( mixinSource ,    objectMapper . findMixInClassFor ( target )  )  ;", "}", "METHOD_END"], "methodName": ["setMixIns"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "NumberSerializer   serializer    =    new   NumberSerializer ( Integer . class )  ;", "SimpleModule   module    =    new   SimpleModule (  )  ;", "module . addSerializer ( Integer . class ,    serializer )  ;", "this . factory . setModules ( Arrays . asList ( new   Module [  ]  {    module    }  )  )  ;", "this . factory . afterPropertiesSet (  )  ;", "ObjectMapper   objectMapper    =    this . factory . getObject (  )  ;", "Serializers   serializers    =     . getSerializerFactoryConfig ( objectMapper )  . serializers (  )  . iterator (  )  . next (  )  ;", "assertSame ( serializer ,    serializers . findSerializer ( null ,    SimpleType . construct ( Integer . class )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["setModules"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setObjectMapper ( new   XmlMapper (  )  )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertNotNull ( this . factory . getObject (  )  )  ;", "assertTrue ( this . factory . isSingleton (  )  )  ;", "assertEquals ( XmlMapper . class ,    this . factory . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["setObjectMapper"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setSimpleDateFormat ( Jackson 2 ObjectMapperFactoryBeanTests . DATE _ FORMAT )  ;", "this . factory . afterPropertiesSet (  )  ;", "assertEquals ( this . dateFormat ,    this . factory . getObject (  )  . getSerializationConfig (  )  . getDateFormat (  )  )  ;", "assertEquals ( this . dateFormat ,    this . factory . getObject (  )  . getDeserializationConfig (  )  . getDateFormat (  )  )  ;", "}", "METHOD_END"], "methodName": ["setSimpleDateFormat"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "TimeZone   timeZone    =    TimeZone . getTimeZone (  \" Europe / Paris \"  )  ;", "this . f . setTimeZone ( timeZone )  ;", "this . f . afterPropertiesSet (  )  ;", "assertEquals ( timeZone ,    this . f . getObject (  )  . getSerializationConfig (  )  . getTimeZone (  )  )  ;", "assertEquals ( timeZone ,    this . f . getObject (  )  . getDeserializationConfig (  )  . getTimeZone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setTimeZone ( TimeZone . getTimeZone (  \" bogusZoneId \"  )  )  ;", "this . factory . afterPropertiesSet (  )  ;", "TimeZone   timeZone    =    TimeZone . getTimeZone (  \" GMT \"  )  ;", "assertEquals ( timeZone ,    this . factory . getObject (  )  . getSerializationConfig (  )  . getTimeZone (  )  )  ;", "assertEquals ( timeZone ,    this . factory . getObject (  )  . getDeserializationConfig (  )  . getTimeZone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setTimeZoneWithInvalidZoneId"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . afterPropertiesSet (  )  ;", "assertNotNull ( this . factory . getObject (  )  )  ;", "assertTrue ( this . factory . isSingleton (  )  )  ;", "assertEquals (  . class ,    this . factory . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleSetup"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( this . factory . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["undefinedObjectType"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setFeaturesToEnable ( Boolean . TRUE )  ;", "this . factory . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["unknownFeature"], "fileName": "org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   this . jsonb ;", "}", "METHOD_END"], "methodName": ["getJsonb"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( jsonb ,     \" A   Jsonb   instance   is   required \"  )  ;", "this . jsonb    =    jsonb ;", "}", "METHOD_END"], "methodName": ["setJsonb"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canRead ( JsonbHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "assertTrue ( this . converter . canRead ( Map . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canRead ( JsonbHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" vnd . test - micro - type + json \"  )  )  )  ;", "assertTrue ( this . converter . canWrite ( JsonbHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" vnd . test - micro - type + json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canReadAndWriteMicroformats"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canWrite ( JsonbHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "assertTrue ( this . converter . canWrite ( Map . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "thissetPrefixJson ( true )  ;", "thiswriteInternal (  \" foo \"  ,    null ,    outputMessage )  ;", "assertEquals (  \"  )  ]  }  '  ,    foo \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["prefixJson"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "thissetJsonPrefix (  \"  )  )  )  \"  )  ;", "thiswriteInternal (  \" foo \"  ,    null ,    outputMessage )  ;", "assertEquals (  \"  )  )  ) foo \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["prefixJsonCustom"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Field   beansList    =    JsonbHttpMessageConverterTests . ListHolder . class . getField (  \" listField \"  )  ;", "String   body    =     \"  [  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "Type   genericType    =    beansList . getGenericType (  )  ;", "List < JsonbHttpMessageConverterTests . MyBean >    results    =     (  ( List < JsonbHttpMessageConverterTests . MyBean >  )     ( converter . read ( genericType ,    JsonbHttpMessageConverterTests . MyBeanListHolder . class ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", "JsonbHttpMessageConverterTests . MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    genericType ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["readAndWriteGenerics"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < List < JsonbHttpMessageConverterTests . MyBean >  >    beansList    =    new   ParameterizedTypeReference < List < JsonbHttpMessageConverterTests . MyBean >  >  (  )     {  }  ;", "String   body    =     \"  [  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "List < JsonbHttpMessageConverterTests . MyBean >    results    =     (  ( List < JsonbHttpMessageConverterTests . MyBean >  )     ( converter . read ( beansList . getType (  )  ,    null ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", "JsonbHttpMessageConverterTests . MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    beansList . getType (  )  ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["readAndWriteParameterizedType"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" FooBar \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "this . converter . read (  . MyBean . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readInvalidJson"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", ". MyBean   result    =     (  (  . MyBean )     ( this . converter . read (  . MyBean . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["readTyped"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "HashMap < String ,    Object >    result    =     (  ( HashMap < String ,    Object >  )     ( thisread ( HashMap . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo \"  ,    result . get (  \" string \"  )  )  ;", "Number   n    =     (  ( Number )     ( result . get (  \" number \"  )  )  )  ;", "assertEquals (  4  2  ,    n . longValue (  )  )  ;", "n    =     (  ( Number )     ( result . get (  \" fraction \"  )  )  )  ;", "assertEquals (  4  2  .  0  ,    n . doubleValue (  )  ,     0  .  0  )  ;", "List < String >    array    =    new   ArrayList <  >  (  )  ;", "array . add (  \" Foo \"  )  ;", "array . add (  \" Bar \"  )  ;", "assertEquals ( array ,    result . get (  \" array \"  )  )  ;", "assertEquals ( Boolean . TRUE ,    result . get (  \" bool \"  )  )  ;", "byte [  ]    bytes    =    new   byte [  2  ]  ;", "List < Number >    resultBytes    =     (  ( ArrayList < Number >  )     ( result . get (  \" bytes \"  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     2  ;    i +  +  )     {", "bytes [ i ]     =    resultBytes . get ( i )  . byteValue (  )  ;", "}", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    bytes )  ;", "}", "METHOD_END"], "methodName": ["readUntyped"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   body    =    new    . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "this . converter . write ( body ,    null ,    outputMessage )  ;", "Charset   utf 8     =    StandardCharsets . UTF _  8  ;", "String   result    =    outputMessage . getBodyAsString ( utf 8  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "assertTrue ( result . contains (  \" fraction \\  \"  :  4  2  .  0  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bool \\  \"  : true \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bytes \\  \"  :  [  1  ,  2  ]  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" json \"  ,    utf 8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < List < JsonbHttpMessageConverterTests . MyBean >  >    beansList    =    new   ParameterizedTypeReference < List < JsonbHttpMessageConverterTests . MyBean >  >  (  )     {  }  ;", "ParameterizedTypeReference < List < JsonbHttpMessageConverterTests . MyBase >  >    baseList    =    new   ParameterizedTypeReference < List < JsonbHttpMessageConverterTests . MyBase >  >  (  )     {  }  ;", "String   body    =     \"  [  {  \\  \" bytes \\  \"  :  [  1  ,  2  ]  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "List < JsonbHttpMessageConverterTests . MyBean >    results    =     (  ( List < JsonbHttpMessageConverterTests . MyBean >  )     ( converter . read ( beansList . getType (  )  ,    null ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", "JsonbHttpMessageConverterTests . MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    baseList . getType (  )  ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["writeParameterizedBaseType"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    new   MediaType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  1  6 BE )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "String   body    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "thiswrite ( body ,    contentType ,    outputMessage )  ;", "assertEquals (  \" Invalid   result \"  ,    body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  1  6 BE )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    contentType ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeUTF16"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   body    =    new    . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "this . converter . write ( body ,     . MyBase . class ,    null ,    outputMessage )  ;", "Charset   utf 8     =    StandardCharsets . UTF _  8  ;", "String   result    =    outputMessage . getBodyAsString ( utf 8  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "assertTrue ( result . contains (  \" fraction \\  \"  :  4  2  .  0  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bool \\  \"  : true \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bytes \\  \"  :  [  1  ,  2  ]  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" json \"  ,    utf 8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeWithBaseType"], "fileName": "org.springframework.http.converter.json.JsonbHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . jsonPrefix    =    jsonPrefix ;", "}", "METHOD_END"], "methodName": ["setJsonPrefix"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . jsonPrefix    =     ( prefixJson )     ?     \"  )  ]  }  '  ,     \"     :    null ;", "}", "METHOD_END"], "methodName": ["setPrefixJson"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( MappingJackson 2 HttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "assertTrue ( converter . canRead ( Map . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( MappingJackson 2 HttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" vnd . test - micro - type + json \"  )  )  )  ;", "assertTrue ( converter . canWrite ( MappingJackson 2 HttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" vnd . test - micro - type + json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canReadAndWriteMicroformats"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( MappingJackson 2 HttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "assertTrue ( converter . canWrite ( Map . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". JacksonViewBean   bean    =    new    . JacksonViewBean (  )  ;", "bean . setWithView 1  (  \" with \"  )  ;", "bean . setWithView 2  (  \" with \"  )  ;", "bean . setWithoutView (  \" without \"  )  ;", "MappingJacksonValue   jacksonValue    =    new   MappingJacksonValue ( bean )  ;", "jacksonValue . setSerializationView (  . MyJacksonView 3  . class )  ;", "this . converter . writeInternal ( jacksonValue ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertThat ( result ,    not ( containsString (  \"  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  \"  )  )  )  ;", "assertThat ( result ,    not ( containsString (  \"  \\  \" withView 2  \\  \"  :  \\  \" with \\  \"  \"  )  )  )  ;", "assertThat ( result ,    containsString (  \"  \\  \" withoutView \\  \"  :  \\  \" without \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["classLevelJsonView"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". JacksonViewBean   bean    =    new    . JacksonViewBean (  )  ;", "bean . setWithView 1  (  \" with \"  )  ;", "bean . setWithView 2  (  \" with \"  )  ;", "bean . setWithoutView (  \" without \"  )  ;", "MappingJacksonValue   jacksonValue    =    new   MappingJacksonValue ( bean )  ;", "jacksonValue . setSerializationView (  . MyJacksonView 1  . class )  ;", "this . converter . writeInternal ( jacksonValue ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertThat ( result ,    containsString (  \"  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  \"  )  )  ;", "assertThat ( result ,    not ( containsString (  \"  \\  \" withView 2  \\  \"  :  \\  \" with \\  \"  \"  )  )  )  ;", "assertThat ( result ,    not ( containsString (  \"  \\  \" withoutView \\  \"  :  \\  \" without \\  \"  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldLevelJsonView"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". JacksonFilteredBean   bean    =    new    . JacksonFilteredBean (  )  ;", "bean . setProperty 1  (  \" value \"  )  ;", "bean . setProperty 2  (  \" value \"  )  ;", "MappingJacksonValue   jacksonValue    =    new   MappingJacksonValue ( bean )  ;", "FilterProvider   filters    =    new   SimpleFilterProvider (  )  . addFilter (  \" myJacksonFilter \"  ,    SimpleBeanPropertyFilter . serializeAllExcept (  \" property 2  \"  )  )  ;", "jacksonValue . setFilters ( filters )  ;", "this . converter . writeInternal ( jacksonValue ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertThat ( result ,    containsString (  \"  \\  \" property 1  \\  \"  :  \\  \" value \\  \"  \"  )  )  ;", "assertThat ( result ,    not ( containsString (  \"  \\  \" property 2  \\  \"  :  \\  \" value \\  \"  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["filters"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJacksonValue   jacksonValue    =    new   MappingJacksonValue (  \" foo \"  )  ;", "jacksonValue . setSerializationView (  . MyJacksonView 1  . class )  ;", "jacksonValue . setJsonpFunction (  \" callback \"  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "this . converter . writeInternal ( jacksonValue ,    null ,    outputMessage )  ;", "assertEquals (  \"  /  *  *  / callback (  \\  \" foo \\  \"  )  ;  \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonp"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". JacksonViewBean   bean    =    new    . JacksonViewBean (  )  ;", "bean . setWithView 1  (  \" with \"  )  ;", "bean . setWithView 2  (  \" with \"  )  ;", "bean . setWithoutView (  \" without \"  )  ;", "MappingJacksonValue   jacksonValue    =    new   MappingJacksonValue ( bean )  ;", "jacksonValue . setSerializationView (  . MyJacksonView 1  . class )  ;", "jacksonValue . setJsonpFunction (  \" callback \"  )  ;", "this . converter . writeInternal ( jacksonValue ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertThat ( result ,    startsWith (  \"  /  *  *  / callback (  \"  )  )  ;", "assertThat ( result ,    endsWith (  \"  )  ;  \"  )  )  ;", "assertThat ( result ,    containsString (  \"  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  \"  )  )  ;", "assertThat ( result ,    not ( containsString (  \"  \\  \" withView 2  \\  \"  :  \\  \" with \\  \"  \"  )  )  )  ;", "assertThat ( result ,    not ( containsString (  \"  \\  \" withoutView \\  \"  :  \\  \" without \\  \"  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonpAndJsonView"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "thissetPrefixJson ( true )  ;", "thiswriteInternal (  \" foo \"  ,    null ,    outputMessage )  ;", "assertEquals (  \"  )  ]  }  \\  '  ,     \\  \" foo \\  \"  \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["prefixJson"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "thissetJsonPrefix (  \"  )  )  )  \"  )  ;", "thiswriteInternal (  \" foo \"  ,    null ,    outputMessage )  ;", "assertEquals (  \"  )  )  )  \\  \" foo \\  \"  \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["prefixJsonCustom"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". PrettyPrintBean   bean    =    new    . PrettyPrintBean (  )  ;", "bean . setName (  \" Jason \"  )  ;", "this . converter . setPrettyPrint ( true )  ;", "this . converter . writeInternal ( bean ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertEquals (  (  (  (  (  \"  {  \"     +     (  . NEWLINE _ SYSTEM _ PROPERTY )  )     +     \"        \\  \" name \\  \"     :     \\  \" Jason \\  \"  \"  )     +     (  . NEWLINE _ SYSTEM _ PROPERTY )  )     +     \"  }  \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "outputMessage . getHeaders (  )  . setContentType ( MediaType . TEXT _ EVENT _ STREAM )  ;", ". PrettyPrintBean   bean    =    new    . PrettyPrintBean (  )  ;", "bean . setName (  \" Jason \"  )  ;", "this . converter . setPrettyPrint ( true )  ;", "this . converter . writeInternal ( bean ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertEquals (  \"  {  \\ ndata :        \\  \" name \\  \"     :     \\  \" Jason \\  \"  \\ ndata :  }  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["prettyPrintWithSse"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 HttpMessageConverter   converter    =    new   MappingJackson 2 HttpMessageConverter (  )     {", "@ Override", "protected   JavaType   getJavaType ( Type   type ,     @ Nullable", "Class <  ?  >    contextClass )     {", "if    (  ( type   instanceof   Class )     &  &     ( List . class . isAssignableFrom (  (  ( Class <  ?  >  )     ( type )  )  )  )  )     {", "return   new   ObjectMapper (  )  . getTypeFactory (  )  . constructCollectionType ( ArrayList . class ,     . MyBean . class )  ;", "} else    {", "return   super . getJavaType ( type ,    contextClass )  ;", "}", "}", "}  ;", "String   body    =     \"  [  {  \"     +     (  (  (  (  (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  ,  \"     +     \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"  )     +     \"  \\  \" number \\  \"  :  4  2  ,  \"  )     +     \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \"  )     +     \"  \\  \" bool \\  \"  : true ,  \"  )     +     \"  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "List <  . MyBean >    results    =     (  ( List <  . MyBean >  )     ( converter . read ( List . class ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", ". MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["readAndWriteGenerics"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < List < MappingJackson 2 HttpMessageConverterTests . MyBean >  >    beansList    =    new   ParameterizedTypeReference < List < MappingJackson 2 HttpMessageConverterTests . MyBean >  >  (  )     {  }  ;", "String   body    =     \"  [  {  \"     +     (  (  (  (  (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  ,  \"     +     \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"  )     +     \"  \\  \" number \\  \"  :  4  2  ,  \"  )     +     \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \"  )     +     \"  \\  \" bool \\  \"  : true ,  \"  )     +     \"  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "MappingJackson 2 HttpMessageConverter   converter    =    new   MappingJackson 2 HttpMessageConverter (  )  ;", "List < MappingJackson 2 HttpMessageConverterTests . MyBean >    results    =     (  ( List < MappingJackson 2 HttpMessageConverterTests . MyBean >  )     ( converter . read ( beansList . getType (  )  ,    null ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", "MappingJackson 2 HttpMessageConverterTests . MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    beansList . getType (  )  ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["readAndWriteParameterizedType"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" FooBar \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "converter . read (  . MyBean . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readInvalidJson"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \"     +     (  (  (  (  (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  ,  \"     +     \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"  )     +     \"  \\  \" number \\  \"  :  4  2  ,  \"  )     +     \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \"  )     +     \"  \\  \" bool \\  \"  : true ,  \"  )     +     \"  \\  \" fraction \\  \"  :  4  2  .  0  }  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", ". MyBean   result    =     (  (  . MyBean )     ( converter . read (  . MyBean . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["readTyped"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \"     +     (  (  (  (  (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  ,  \"     +     \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"  )     +     \"  \\  \" number \\  \"  :  4  2  ,  \"  )     +     \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \"  )     +     \"  \\  \" bool \\  \"  : true ,  \"  )     +     \"  \\  \" fraction \\  \"  :  4  2  .  0  }  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "HashMap < String ,    Object >    result    =     (  ( HashMap < String ,    Object >  )     ( read ( HashMap . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo \"  ,    result . get (  \" string \"  )  )  ;", "assertEquals (  4  2  ,    result . get (  \" number \"  )  )  ;", "assertEquals (  4  2  .  0  ,     (  ( Double )     ( result . get (  \" fraction \"  )  )  )  ,     0  .  0  )  ;", "List < String >    array    =    new   ArrayList <  >  (  )  ;", "array . add (  \" Foo \"  )  ;", "array . add (  \" Bar \"  )  ;", "assertEquals ( array ,    result . get (  \" array \"  )  )  ;", "assertEquals ( Boolean . TRUE ,    result . get (  \" bool \"  )  )  ;", "assertEquals (  \" AQI =  \"  ,    result . get (  \" bytes \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readUntyped"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" string \\  \"  :  \\  \" string \\  \"  ,  \\  \" unknownProperty \\  \"  :  \\  \" value \\  \"  }  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "converter . read (  . MyBean . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readValidJsonWithUnknownProperty"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" property 1  \\  \"  :  \\  \" foo \\  \"  ,  \\  \" property 2  \\  \"  :  \\  \" bar \\  \"  }  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "try    {", "converter . read (  . BeanWithNoDefaultConstructor . class ,    inputMessage )  ;", "}    catch    ( HttpMessageConversionException   ex )     {", "assertTrue ( ex . getMessage (  )  ,    ex . getMessage (  )  . startsWith (  \" Type   definition   error :  \"  )  )  ;", "return ;", "}", "fail (  )  ;", "}", "METHOD_END"], "methodName": ["readWithNoDefaultConstructor"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   body    =    new    . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "converter . write ( body ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "assertTrue ( result . contains (  \" fraction \\  \"  :  4  2  .  0  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bool \\  \"  : true \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < List < MappingJackson 2 HttpMessageConverterTests . MyBean >  >    beansList    =    new   ParameterizedTypeReference < List < MappingJackson 2 HttpMessageConverterTests . MyBean >  >  (  )     {  }  ;", "ParameterizedTypeReference < List < MappingJackson 2 HttpMessageConverterTests . MyBase >  >    baseList    =    new   ParameterizedTypeReference < List < MappingJackson 2 HttpMessageConverterTests . MyBase >  >  (  )     {  }  ;", "String   body    =     \"  [  {  \"     +     (  (  (  (  (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  ,  \"     +     \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"  )     +     \"  \\  \" number \\  \"  :  4  2  ,  \"  )     +     \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \"  )     +     \"  \\  \" bool \\  \"  : true ,  \"  )     +     \"  \\  \" fraction \\  \"  :  4  2  .  0  }  ]  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  )  )  ;", "MappingJackson 2 HttpMessageConverter   converter    =    new   MappingJackson 2 HttpMessageConverter (  )  ;", "List < MappingJackson 2 HttpMessageConverterTests . MyBean >    results    =     (  ( List < MappingJackson 2 HttpMessageConverterTests . MyBean >  )     ( converter . read ( beansList . getType (  )  ,    null ,    inputMessage )  )  )  ;", "assertEquals (  1  ,    results . size (  )  )  ;", "MappingJackson 2 HttpMessageConverterTests . MyBean   result    =    results . get (  0  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "converter . write ( results ,    baseList . getType (  )  ,    new   MediaType (  \" application \"  ,     \" json \"  )  ,    outputMessage )  ;", "JSONAssert . assertEquals ( body ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["writeParameterizedBaseType"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   bean    =    new    . MyBean (  )  ;", "bean . setString (  \" Foo \"  )  ;", "bean . setNumber (  4  2  )  ;", "this . converter . writeInternal ( bean ,     . MyInterface . class ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["writeSubType"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "List <  . MyBean >    beans    =    new   ArrayList <  >  (  )  ;", ". MyBean   foo    =    new    . MyBean (  )  ;", "foo . setString (  \" Foo \"  )  ;", "foo . setNumber (  4  2  )  ;", "beans . add ( foo )  ;", ". MyBean   bar    =    new    . MyBean (  )  ;", "bar . setString (  \" Bar \"  )  ;", "bar . setNumber (  1  2  3  )  ;", "beans . add ( bar )  ;", "ParameterizedTypeReference < List <  . MyInterface >  >    typeReference    =    new   ParameterizedTypeReference < List <  . MyInterface >  >  (  )     {  }  ;", "this . converter . writeInternal ( beans ,    typeReference . getType (  )  ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Bar \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  1  2  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["writeSubTypeList"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    new   MediaType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  1  6 BE )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "String   body    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "write ( body ,    contentType ,    outputMessage )  ;", "assertEquals (  \" Invalid   result \"  ,     (  (  \"  \\  \"  \"     +    body )     +     \"  \\  \"  \"  )  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  1  6 BE )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    contentType ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeUTF16"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   body    =    new    . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "converter . write ( body ,     . MyBase . class ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertTrue ( result . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "assertTrue ( result . contains (  \" fraction \\  \"  :  4  2  .  0  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bool \\  \"  : true \"  )  )  ;", "assertTrue ( result . contains (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeWithBaseType"], "fileName": "org.springframework.http.converter.json.MappingJackson2HttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . deserializationView ;", "}", "METHOD_END"], "methodName": ["getDeserializationView"], "fileName": "org.springframework.http.converter.json.MappingJacksonInputMessage"}, {"methodBody": ["METHOD_START", "{", "this . deserializationView    =    deserializationView ;", "}", "METHOD_END"], "methodName": ["setDeserializationView"], "fileName": "org.springframework.http.converter.json.MappingJacksonInputMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . filters ;", "}", "METHOD_END"], "methodName": ["getFilters"], "fileName": "org.springframework.http.converter.json.MappingJacksonValue"}, {"methodBody": ["METHOD_START", "{", "return   this . jsonpFunction ;", "}", "METHOD_END"], "methodName": ["getJsonpFunction"], "fileName": "org.springframework.http.converter.json.MappingJacksonValue"}, {"methodBody": ["METHOD_START", "{", "return   this . serializationView ;", "}", "METHOD_END"], "methodName": ["getSerializationView"], "fileName": "org.springframework.http.converter.json.MappingJacksonValue"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.http.converter.json.MappingJacksonValue"}, {"methodBody": ["METHOD_START", "{", "this . filters    =    filters ;", "}", "METHOD_END"], "methodName": ["setFilters"], "fileName": "org.springframework.http.converter.json.MappingJacksonValue"}, {"methodBody": ["METHOD_START", "{", "this . jsonpFunction    =    functionName ;", "}", "METHOD_END"], "methodName": ["setJsonpFunction"], "fileName": "org.springframework.http.converter.json.MappingJacksonValue"}, {"methodBody": ["METHOD_START", "{", "this . serializationView    =    serializationView ;", "}", "METHOD_END"], "methodName": ["setSerializationView"], "fileName": "org.springframework.http.converter.json.MappingJacksonValue"}, {"methodBody": ["METHOD_START", "{", "this . value    =    value ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.springframework.http.converter.json.MappingJacksonValue"}, {"methodBody": ["METHOD_START", "{", "this . objectMapper . writeValueAsString ( new   SpringHandlerInstantiatorTests . Group (  )  )  ;", "assertTrue ( SpringHandlerInstantiatorTests . CustomTypeIdResolver . isAutowiredFiledInitialized )  ;", "}", "METHOD_END"], "methodName": ["applicationContextAwareTypeIdResolver"], "fileName": "org.springframework.http.converter.json.SpringHandlerInstantiatorTests"}, {"methodBody": ["METHOD_START", "{", "this . objectMapper . writeValueAsString ( new   SpringHandlerInstantiatorTests . Group (  )  )  ;", "assertTrue ( SpringHandlerInstantiatorTests . CustomTypeResolverBuilder . isAutowiredFiledInitialized )  ;", "}", "METHOD_END"], "methodName": ["applicationContextAwaretypeResolverBuilder"], "fileName": "org.springframework.http.converter.json.SpringHandlerInstantiatorTests"}, {"methodBody": ["METHOD_START", "{", "String   json    =     \"  {  \\  \" username \\  \"  :  \\  \" bob \\  \"  }  \"  ;", ". User   user    =    this . objectMapper . readValue ( json ,     . User . class )  ;", "assertEquals (  \" BOB \"  ,    user . getUsername (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredDeserializer"], "fileName": "org.springframework.http.converter.json.SpringHandlerInstantiatorTests"}, {"methodBody": ["METHOD_START", "{", "String   json    =     \"  {  \\  \" credentials \\  \"  :  {  \\  \" bob \\  \"  :  \\  \" admin \\  \"  }  }  \"  ;", ". SecurityRegistry   registry    =    this . objectMapper . readValue ( json ,     . SecurityRegistry . class )  ;", "assertTrue ( registry . getCredentials (  )  . keySet (  )  . contains (  \" BOB \"  )  )  ;", "assertFalse ( registry . getCredentials (  )  . keySet (  )  . contains (  \" bob \"  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredKeyDeserializer"], "fileName": "org.springframework.http.converter.json.SpringHandlerInstantiatorTests"}, {"methodBody": ["METHOD_START", "{", "SpringHandlerInstantiatorTests . User   user    =    new   SpringHandlerInstantiatorTests . User (  \" bob \"  )  ;", "String   json    =    this . objectMapper . writeValueAsString ( user )  ;", "assertEquals (  \"  {  \\  \" username \\  \"  :  \\  \" BOB \\  \"  }  \"  ,    json )  ;", "}", "METHOD_END"], "methodName": ["autowiredSerializer"], "fileName": "org.springframework.http.converter.json.SpringHandlerInstantiatorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" capitalizer \"  ,    new   RootBeanDefinition (  . Capitalizer . class )  )  ;", "instantiator    =    new   SpringHandlerInstantiator ( bf )  ;", "objectMapper    =    Jackson 2 ObjectMapperBuilder . json (  )  . handlerInstantiator ( instantiator )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.http.converter.json.SpringHandlerInstantiatorTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ProtobufHttpMessageConverter . methodCache . get ( clazz )  ;", "if    ( method    =  =    null )     {", "method    =    clazz . getMethod (  \" newBuilder \"  )  ;", "ProtobufHttpMessageConverter . methodCache . put ( clazz ,    method )  ;", "}", "return    (  ( Message . Builder )     ( method . invoke ( clazz )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageBuilder"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "response . getHeaders (  )  . set ( ProtobufHttpMessageConverter . X _ PROTOBUF _ SCHEMA _ HEADER ,    message . getDescriptorForType (  )  . getFile (  )  . getName (  )  )  ;", "response . getHeaders (  )  . set ( ProtobufHttpMessageConverter . X _ PROTOBUF _ MESSAGE _ HEADER ,    message . getDescriptorForType (  )  . getFullName (  )  )  ;", "}", "METHOD_END"], "methodName": ["setProtoHeader"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canRead ( Msg . class ,    null )  )  ;", "assertTrue ( this . converter . canRead ( Msg . class ,     . PROTOBUF )  )  ;", "assertTrue ( this . converter . canRead ( Msg . class ,    MediaType . APPLICATION _ JSON )  )  ;", "assertTrue ( this . converter . canRead ( Msg . class ,    MediaType . APPLICATION _ XML )  )  ;", "assertTrue ( this . converter . canRead ( Msg . class ,    MediaType . TEXT _ PLAIN )  )  ;", "assertFalse ( this . converter . canRead ( Msg . class ,    MediaType . TEXT _ HTML )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canWrite ( Msg . class ,    null )  )  ;", "assertTrue ( this . converter . canWrite ( Msg . class ,     . PROTOBUF )  )  ;", "assertTrue ( this . converter . canWrite ( Msg . class ,    MediaType . APPLICATION _ JSON )  )  ;", "assertTrue ( this . converter . canWrite ( Msg . class ,    MediaType . APPLICATION _ XML )  )  ;", "assertTrue ( this . converter . canWrite ( Msg . class ,    MediaType . TEXT _ PLAIN )  )  ;", "assertTrue ( this . converter . canWrite ( Msg . class ,    MediaType . TEXT _ HTML )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ProtobufHttpMessageConverter . PROTOBUF ,    this . converter . getDefaultContentType ( this . testMsg )  )  ;", "}", "METHOD_END"], "methodName": ["defaultContentType"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "verify ( this . registryInitializer ,    times (  1  )  )  . initializeExtensionRegistry ( any (  )  )  ;", "}", "METHOD_END"], "methodName": ["extensionRegistryInitialized"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "new   ProtobufHttpMessageConverter ( null )  ;", "}", "METHOD_END"], "methodName": ["extensionRegistryNull"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "MediaType   contentType    =     . PROTOBUF ;", "this . converter . write ( this . testMsg ,    contentType ,    outputMessage )  ;", "assertEquals (  (  -  1  )  ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =    this . testMsg . toByteArray (  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "inputMessage . getHeaders (  )  . setContentType (  . PROTOBUF )  ;", "Message   result    =    this . converter . read ( Msg . class ,    inputMessage )  ;", "assertEquals ( this . testMsg ,    result )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =    this . testMsg . toByteArray (  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "Message   result    =    thisread ( Msg . class ,    inputMessage )  ;", "assertEquals ( this . testMsg ,    result )  ;", "}", "METHOD_END"], "methodName": ["readNoContentType"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . registryInitializer    =    mock ( ExtensionRegistryInitializer . class )  ;", "this . converter    =    new    ( this . registryInitializer )  ;", "this . testMsg    =    Msg . newBuilder (  )  . setFoo (  \" Foo \"  )  . setBlah ( SecondMsg . newBuilder (  )  . setBlah (  1  2  3  )  . build (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter    =    new   ProtobufHttpMessageConverter ( new   ProtobufHttpMessageConverter . ProtobufJavaUtilSupport ( null ,    null )  ,    this . registryInitializer )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "MediaType   contentType    =    MediaType . APPLICATION _ JSON _ UTF 8  ;", "this . converter . write ( this . testMsg ,    contentType ,    outputMessage )  ;", "assertEquals ( contentType ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "final   String   body    =    outputMessage . getBodyAsString ( Charset . forName (  \" UTF -  8  \"  )  )  ;", "assertFalse (  \" body   is   empty \"  ,    body . isEmpty (  )  )  ;", "Msg . Builder   builder    =    Msg . newBuilder (  )  ;", "JsonFormat . parser (  )  . merge ( body ,    builder )  ;", "assertEquals ( this . testMsg ,    builder . build (  )  )  ;", "assertNull ( outputMessage . getHeaders (  )  . getFirst ( ProtobufHttpMessageConverter . X _ PROTOBUF _ MESSAGE _ HEADER )  )  ;", "assertNull ( outputMessage . getHeaders (  )  . getFirst ( ProtobufHttpMessageConverter . X _ PROTOBUF _ SCHEMA _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["writeJsonWithGoogleProtobuf"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter    =    new   ProtobufHttpMessageConverter ( new   ProtobufHttpMessageConverter . ProtobufJavaFormatSupport (  )  ,    this . registryInitializer )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "MediaType   contentType    =    MediaType . APPLICATION _ JSON _ UTF 8  ;", "this . converter . write ( this . testMsg ,    contentType ,    outputMessage )  ;", "assertEquals ( contentType ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "final   String   body    =    outputMessage . getBodyAsString ( Charset . forName (  \" UTF -  8  \"  )  )  ;", "assertFalse (  \" body   is   empty \"  ,    body . isEmpty (  )  )  ;", "Msg . Builder   builder    =    Msg . newBuilder (  )  ;", "JsonFormat . parser (  )  . merge ( body ,    builder )  ;", "assertEquals ( this . testMsg ,    builder . build (  )  )  ;", "assertNull ( outputMessage . getHeaders (  )  . getFirst ( ProtobufHttpMessageConverter . X _ PROTOBUF _ MESSAGE _ HEADER )  )  ;", "assertNull ( outputMessage . getHeaders (  )  . getFirst ( ProtobufHttpMessageConverter . X _ PROTOBUF _ SCHEMA _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["writeJsonWithJavaFormat"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "MediaType   contentType    =     . PROTOBUF ;", "this . converter . write ( this . testMsg ,    contentType ,    outputMessage )  ;", "assertEquals ( contentType ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "assertTrue (  (  ( outputMessage . getBodyAsBytes (  )  . length )     >     0  )  )  ;", "Message   result    =    Msg . parseFrom ( outputMessage . getBodyAsBytes (  )  )  ;", "assertEquals ( this . testMsg ,    result )  ;", "String   messageHeader    =    outputMessage . getHeaders (  )  . getFirst (  . X _ PROTOBUF _ MESSAGE _ HEADER )  ;", "assertEquals (  \" Msg \"  ,    messageHeader )  ;", "String   schemaHeader    =    outputMessage . getHeaders (  )  . getFirst (  . X _ PROTOBUF _ SCHEMA _ HEADER )  ;", "assertEquals (  \" sample . proto \"  ,    schemaHeader )  ;", "}", "METHOD_END"], "methodName": ["writeProtobuf"], "fileName": "org.springframework.http.converter.protobuf.ProtobufHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canRead ( Msg . class ,    null )  )  ;", "assertTrue ( this . converter . canRead ( Msg . class ,    Protobuf . PROTOBUF )  )  ;", "assertTrue ( this . converter . canRead ( Msg . class ,    MediaType . APPLICATION _ JSON )  )  ;", "assertTrue ( this . converter . canRead ( Msg . class ,    MediaType . TEXT _ PLAIN )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . converter . canWrite ( Msg . class ,    null )  )  ;", "assertTrue ( this . converter . canWrite ( Msg . class ,    Protobuf . PROTOBUF )  )  ;", "assertTrue ( this . converter . canWrite ( Msg . class ,    MediaType . APPLICATION _ JSON )  )  ;", "assertTrue ( this . converter . canWrite ( Msg . class ,    MediaType . TEXT _ PLAIN )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ProtobufHttpMessageConverter . PROTOBUF ,    this . converter . getDefaultContentType ( this . testMsg )  )  ;", "}", "METHOD_END"], "methodName": ["defaultContentType"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "verify ( this . registryInitializer ,    times (  1  )  )  . initializeExtensionRegistry ( any (  )  )  ;", "}", "METHOD_END"], "methodName": ["extensionRegistryInitialized"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "new   ProtobufHttpMessageConverter ( null )  ;", "}", "METHOD_END"], "methodName": ["extensionRegistryNull"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "MediaType   contentType    =    Protobuf . PROTOBUF ;", "this . converter . write ( this . testMsg ,    contentType ,    outputMessage )  ;", "assertEquals (  (  -  1  )  ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =    this . testMsg . toByteArray (  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "inputMessage . getHeaders (  )  . setContentType ( Protobuf . PROTOBUF )  ;", "Message   result    =    this . converter . read ( Msg . class ,    inputMessage )  ;", "assertEquals ( this . testMsg ,    result )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =    this . testMsg . toByteArray (  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", "Message   result    =    thisread ( Msg . class ,    inputMessage )  ;", "assertEquals ( this . testMsg ,    result )  ;", "}", "METHOD_END"], "methodName": ["readNoContentType"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . registryInitializer    =    mock ( ExtensionRegistryInitializer . class )  ;", "this . converter    =    new    ( JsonFormat . parser (  )  ,    JsonFormat . printer (  )  ,    this . registryInitializer )  ;", "this . testMsg    =    Msg . newBuilder (  )  . setFoo (  \" Foo \"  )  . setBlah ( SecondMsg . newBuilder (  )  . setBlah (  1  2  3  )  . build (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "MediaType   contentType    =    Protobuf . PROTOBUF ;", "this . converter . write ( this . testMsg ,    contentType ,    outputMessage )  ;", "assertEquals ( contentType ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "assertTrue (  (  ( outputMessage . getBodyAsBytes (  )  . length )     >     0  )  )  ;", "Message   result    =    Msg . parseFrom ( outputMessage . getBodyAsBytes (  )  )  ;", "assertEquals ( this . testMsg ,    result )  ;", "String   messageHeader    =    outputMessage . getHeaders (  )  . getFirst ( Protobuf . X _ PROTOBUF _ MESSAGE _ HEADER )  ;", "assertEquals (  \" Msg \"  ,    messageHeader )  ;", "String   schemaHeader    =    outputMessage . getHeaders (  )  . getFirst ( Protobuf . X _ PROTOBUF _ SCHEMA _ HEADER )  ;", "assertEquals (  \" sample . proto \"  ,    schemaHeader )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.protobuf.ProtobufJsonFormatHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( MappingJackson 2 SmileHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" x - jackson - smile \"  )  )  )  ;", "assertFalse ( converter . canRead ( MappingJackson 2 SmileHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "assertFalse ( converter . canRead ( MappingJackson 2 SmileHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" xml \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.smile.MappingJackson2SmileHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( MappingJackson 2 SmileHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" x - jackson - smile \"  )  )  )  ;", "assertFalse ( converter . canWrite ( MappingJackson 2 SmileHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" json \"  )  )  )  ;", "assertFalse ( converter . canWrite ( MappingJackson 2 SmileHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" xml \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.smile.MappingJackson2SmileHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 SmileHttpMessageConverterTests . MyBean   body    =    new   MappingJackson 2 SmileHttpMessageConverterTests . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( mapper . writeValueAsBytes ( body )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" x - jackson - smile \"  )  )  ;", "MappingJackson 2 SmileHttpMessageConverterTests . MyBean   result    =     (  ( MappingJackson 2 SmileHttpMessageConverterTests . MyBean )     ( converter . read ( MappingJackson 2 SmileHttpMessageConverterTests . MyBean . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.smile.MappingJackson2SmileHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   body    =    new    . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "converter . write ( body ,    null ,    outputMessage )  ;", "assertArrayEquals ( mapper . writeValueAsBytes ( body )  ,    outputMessage . getBodyAsBytes (  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" x - jackson - smile \"  ,    StandardCharsets . UTF _  8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.smile.MappingJackson2SmileHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "JAXBContext   jaxbContext    =    getJaxbContext ( clazz )  ;", "Marshaller   marshaller    =    jaxbContext . createMarshaller (  )  ;", "customizeMarshaller ( marshaller )  ;", "return   marshaller ;", "}    catch    ( JAXBException   ex )     {", "throw   new   sionException (  (  (  (  \" Could   not   create   Marshaller   for   class    [  \"     +    clazz )     +     \"  ]  :     \"  )     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createMarshaller"], "fileName": "org.springframework.http.converter.xml.AbstractJaxb2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "try    {", "JAXBContext   jaxbContext    =    getJaxbContext ( clazz )  ;", "Unmarshaller   unmarshaller    =    jaxbContext . createUnmarshaller (  )  ;", "customizeUnmarshaller ( unmarshaller )  ;", "return   unmarshaller ;", "}    catch    ( JAXBException   ex )     {", "throw   new   sionException (  (  (  (  \" Could   not   create   Unmarshaller   for   class    [  \"     +    clazz )     +     \"  ]  :     \"  )     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createUnmarshaller"], "fileName": "org.springframework.http.converter.xml.AbstractJaxb2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \"  ' clazz '    must   not   be   null \"  )  ;", "JAXBContext   jaxbContext    =    this . jaxbContexts . get ( clazz )  ;", "if    ( jaxbContext    =  =    null )     {", "try    {", "jaxbContext    =    JAXBContext . newInstance ( clazz )  ;", "this . jaxbContexts . putIfAbsent ( clazz ,    jaxbContext )  ;", "}    catch    ( JAXBException   ex )     {", "throw   new   sionException (  (  (  (  \" Could   not   instantiate   JAXBContext   for   class    [  \"     +    clazz )     +     \"  ]  :     \"  )     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "return   jaxbContext ;", "}", "METHOD_END"], "methodName": ["getJaxbContext"], "fileName": "org.springframework.http.converter.xml.AbstractJaxb2HttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . transformerFactory . newTransformer (  )  . transform ( source ,    result )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.springframework.http.converter.xml.AbstractXmlHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( collectionClass . isInterface (  )  )  )     {", "try    {", "return    (  ( T )     ( ReflectionUtils . accessibleConstructor ( collectionClass )  . newInstance (  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  \" Could   not   instantiate   collection   class :     \"     +     ( collectionClass . getName (  )  )  )  ,    ex )  ;", "}", "} else", "if    (  ( class )     =  =    collectionClass )     {", "return    (  ( T )     ( new   ArrayList (  )  )  )  ;", "} else", "if    (  ( class )     =  =    collectionClass )     {", "return    (  ( T )     ( new   TreeSet (  )  )  )  ;", "} else    {", "return    (  ( T )     ( new   LinkedHashSet (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createCollection"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   StaxUtils . createDefensiveInputFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createXmlInputFactory"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "int   event    =    streamReader . next (  )  ;", "while    ( event    !  =     ( XMLStreamReader . START _ ELEMENT )  )     {", "event    =    streamReader . next (  )  ;", "}", "event    =    streamReader . next (  )  ;", "while    (  ( event    !  =     ( XMLStreamReader . START _ ELEMENT )  )     &  &     ( event    !  =     ( XMLStreamReader . END _ DOCUMENT )  )  )     {", "event    =    streamReader . next (  )  ;", "}", "return   event ;", "}", "METHOD_END"], "methodName": ["moveToFirstChildOfRootElement"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "int   event    =    streamReader . getEventType (  )  ;", "while    (  ( event    !  =     ( XMLStreamReader . START _ ELEMENT )  )     &  &     ( event    !  =     ( XMLStreamReader . END _ DOCUMENT )  )  )     {", "event    =    streamReader . next (  )  ;", "}", "return   event ;", "}", "METHOD_END"], "methodName": ["moveToNextElement"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( rootElementListType ,    null ,    null )  )  ;", "assertTrue ( converter . canRead ( rootElementSetType ,    null ,    null )  )  ;", "assertTrue ( converter . canRead ( typeSetType ,    null ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   external    =    new   ClassPathResource (  \" external . txt \"  ,    getClass (  )  )  ;", "String   content    =     (  (  (  \"  <  ! DOCTYPE   root    [  \"     +     (  \"        <  ! ELEMENT   external   ANY    >  \\ n \"     +     \"        <  ! ENTITY   ext   SYSTEM    \\  \"  \"  )  )     +     ( external . getURI (  )  )  )     +     \"  \\  \"     >  ]  >  \"  )     +     \"        < list >  < rootElement >  < type   s =  \\  \"  1  \\  \"  /  >  < external >  & ext ;  <  / external >  <  / rootElement >  <  / list >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "converter    =    new   Jaxb 2 CollectionHttpMessageConverter < Collection < Object >  >  (  )     {", "@ Override", "protected   XMLInputFactory   createXmlInputFactory (  )     {", "XMLInputFactory   inputFactory    =    super . createXmlInputFactory (  )  ;", "inputFactory . setProperty ( XMLInputFactory . SUPPORT _ DTD ,    true )  ;", "return   inputFactory ;", "}", "}  ;", "try    {", "Collection <  . RootElement >    result    =    converter . read ( rootElementListType ,    null ,    inputMessage )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "assertEquals (  \"  \"  ,    result . iterator (  )  . next (  )  . external )  ;", "}    catch    ( HttpMessageNotReadableException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["readXmlRootElementExternalEntityDisabled"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   external    =    new   ClassPathResource (  \" external . txt \"  ,    getClass (  )  )  ;", "String   content    =     (  (  (  \"  <  ! DOCTYPE   root    [  \"     +     (  \"        <  ! ELEMENT   external   ANY    >  \\ n \"     +     \"        <  ! ENTITY   ext   SYSTEM    \\  \"  \"  )  )     +     ( external . getURI (  )  )  )     +     \"  \\  \"     >  ]  >  \"  )     +     \"        < list >  < rootElement >  < type   s =  \\  \"  1  \\  \"  /  >  < external >  & ext ;  <  / external >  <  / rootElement >  <  / list >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "Jaxb 2 CollectionHttpMessageConverter <  ?  >    c    =    new   Jaxb 2 CollectionHttpMessageConverter < Collection < Object >  >  (  )     {", "@ Override", "protected   XMLInputFactory   createXmlInputFactory (  )     {", "XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setProperty ( XMLInputFactory . IS _ REPLACING _ ENTITY _ REFERENCES ,    true )  ;", "return   inputFactory ;", "}", "}  ;", "Collection <  . RootElement >    result    =    c . read ( rootElementListType ,    null ,    inputMessage )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "assertEquals (  \" Foo   Bar \"  ,    result . iterator (  )  . next (  )  . external )  ;", "}", "METHOD_END"], "methodName": ["readXmlRootElementExternalEntityEnabled"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  < list >  < rootElement >  < type   s =  \\  \"  1  \\  \"  /  >  <  / rootElement >  < rootElement >  < type   s =  \\  \"  2  \\  \"  /  >  <  / rootElement >  <  / list >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "List <  . RootElement >    result    =     (  ( List <  . RootElement >  )     ( converter . read ( rootElementListType ,    null ,    inputMessage )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     2  ,    result . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \"  1  \"  ,    result . get (  0  )  . type . s )  ;", "assertEquals (  \" Invalid   result \"  ,     \"  2  \"  ,    result . get (  1  )  . type . s )  ;", "}", "METHOD_END"], "methodName": ["readXmlRootElementList"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  < set >  < rootElement >  < type   s =  \\  \"  1  \\  \"  /  >  <  / rootElement >  < rootElement >  < type   s =  \\  \"  2  \\  \"  /  >  <  / rootElement >  <  / set >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "Set <  . RootElement >    result    =     (  ( Set <  . RootElement >  )     ( converter . read ( rootElementSetType ,    null ,    inputMessage )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     2  ,    result . size (  )  )  ;", "assertTrue (  \" Invalid   result \"  ,    result . contains ( new    . RootElement (  \"  1  \"  )  )  )  ;", "assertTrue (  \" Invalid   result \"  ,    result . contains ( new    . RootElement (  \"  2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readXmlRootElementSet"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  < list >  < foo   s =  \\  \"  1  \\  \"  /  >  < bar   s =  \\  \"  2  \\  \"  /  >  <  / list >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "List <  . TestType >    result    =     (  ( List <  . TestType >  )     ( converter . read ( typeListType ,    null ,    inputMessage )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     2  ,    result . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \"  1  \"  ,    result . get (  0  )  . s )  ;", "assertEquals (  \" Invalid   result \"  ,     \"  2  \"  ,    result . get (  1  )  . s )  ;", "}", "METHOD_END"], "methodName": ["readXmlTypeList"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  < set >  < foo   s =  \\  \"  1  \\  \"  /  >  < bar   s =  \\  \"  2  \\  \"  /  >  <  / set >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "Set <  . TestType >    result    =     (  ( Set <  . TestType >  )     ( converter . read ( typeSetType ,    null ,    inputMessage )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     2  ,    result . size (  )  )  ;", "assertTrue (  \" Invalid   result \"  ,    result . contains ( new    . TestType (  \"  1  \"  )  )  )  ;", "assertTrue (  \" Invalid   result \"  ,    result . contains ( new    . TestType (  \"  2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readXmlTypeSet"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter    =    new   Jaxb 2 CollectionHttpMessageConverter < Collection < Object >  >  (  )  ;", "rootElementListType    =    new   ParameterizedTypeReference < List <  . RootElement >  >  (  )     {  }  . getType (  )  ;", "rootElementSetType    =    new   ParameterizedTypeReference < Set <  . RootElement >  >  (  )     {  }  . getType (  )  ;", "typeListType    =    new   ParameterizedTypeReference < List <  . TestType >  >  (  )     {  }  . getType (  )  ;", "typeSetType    =    new   ParameterizedTypeReference < Set <  . TestType >  >  (  )     {  }  . getType (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"  ?  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \"  <  ! DOCTYPE   lolz    [  \\ n \"     +     \"     <  ! ENTITY   lol    \\  \" lol \\  \"  >  \\ n \"  )     +     \"     <  ! ELEMENT   lolz    (  # PCDATA )  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 1     \\  \"  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 2     \\  \"  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 3     \\  \"  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 4     \\  \"  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 5     \\  \"  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 6     \\  \"  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 7     \\  \"  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 8     \\  \"  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 9     \\  \"  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  \\  \"  >  \\ n \"  )     +     \"  ]  >  \\ n \"  )     +     \"  < list >  < rootElement >  < external >  & lol 9  ;  <  / external >  <  / rootElement >  <  / list >  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "this . thrown . expect ( NotReadableException . class )  ;", "this . thrown . expectMessage (  \"  \\  \" lol 9  \\  \"  \"  )  ;", "this . converter . read ( this . rootElementListType ,    null ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["testXmlBomb"], "fileName": "org.springframework.http.converter.xml.Jaxb2CollectionHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . processExternalEntities ;", "}", "METHOD_END"], "methodName": ["isProcessExternalEntities"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . supportDtd ;", "}", "METHOD_END"], "methodName": ["isSupportDtd"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( source   instanceof   StreamSource )     {", "StreamSource   streamSource    =     (  ( StreamSource )     ( source )  )  ;", "InputSource   inputSource    =    new   InputSource ( streamSource . getInputStream (  )  )  ;", "try    {", "XMLReader   xmlReader    =    XMLReaderFactory . createXMLReader (  )  ;", "xmlReader . setFeature (  \" http :  /  / apache . org / xml / features / disallow - doctype - decl \"  ,     (  !  ( isSupportDtd (  )  )  )  )  ;", "String   featureName    =     \" http :  /  / xml . org / sax / features / external - general - entities \"  ;", "xmlReader . setFeature ( featureName ,    isProcessExternalEntities (  )  )  ;", "if    (  !  ( isProcessExternalEntities (  )  )  )     {", "xmlReader . setEntityResolver (  . NO _ OP _ ENTITY _ RESOLVER )  ;", "}", "return   new   SAXSource ( xmlReader ,    inputSource )  ;", "}    catch    ( SAXException   ex )     {", "logger . warn (  \" Processing   of   external   entities   could   not   be   disabled \"  ,    ex )  ;", "return   source ;", "}", "} else    {", "return   source ;", "}", "}", "METHOD_END"], "methodName": ["processSource"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contentType    !  =    null )     &  &     (  ( contentType . getCharset (  )  )     !  =    null )  )     {", "marshaller . setProperty ( Marshaller . JAXB _ ENCODING ,    contentType . getCharset (  )  . name (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setCharset"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . processExternalEntities    =    processExternalEntities ;", "if    ( processExternalEntities )     {", "setSupportDtd ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["setProcessExternalEntities"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . supportDtd    =    supportDtd ;", "}", "METHOD_END"], "methodName": ["setSupportDtd"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Converter   does   not   support   reading    @ XmlRootElement \"  ,    converter . canRead ( Jaxb 2 RootElementHttpMessageConverterTests . RootElement . class ,    null )  )  ;", "assertTrue (  \" Converter   does   not   support   reading    @ XmlType \"  ,    converter . canRead ( Jaxb 2 RootElementHttpMessageConverterTests . Type . class ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Converter   does   not   support   writing    @ XmlRootElement \"  ,    converter . canWrite ( Jaxb 2 RootElementHttpMessageConverterTests . RootElement . class ,    null )  )  ;", "assertTrue (  \" Converter   does   not   support   writing    @ XmlRootElement   subclass \"  ,    converter . canWrite ( Jaxb 2 RootElementHttpMessageConverterTests . RootElementSubclass . class ,    null )  )  ;", "assertTrue (  \" Converter   does   not   support   writing    @ XmlRootElement   subclass \"  ,    converter . canWrite ( rootElementCglib . getClass (  )  ,    null )  )  ;", "assertFalse (  \" Converter   supports   writing    @ XmlType \"  ,    converter . canWrite ( Jaxb 2 RootElementHttpMessageConverterTests . Type . class ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyJaxb 2 RootElementHttpMessageConverter   myConverter    =    new    . MyJaxb 2 RootElementHttpMessageConverter (  )  ;", "myConverter . write ( new    . MyRootElement ( new    . MyCustomElement (  \" a \"  ,     \" b \"  )  )  ,    null ,    outputMessage )  ;", "DifferenceEvaluator   ev    =    chain ( Default ,    downgradeDifferencesToEqual ( XML _ STANDALONE )  )  ;", "assertThat (  \" Invalid   result \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    isSimilarTo (  \"  < myRootElement >  < element > a |  |  | b <  / element >  <  / myRootElement >  \"  )  . withDifferenceEvaluator ( ev )  )  ;", "}", "METHOD_END"], "methodName": ["customizeMarshaller"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =     \"  < myRootElement >  < element > a |  |  | b <  / element >  <  / myRootElement >  \"  . getBytes (  \" UTF -  8  \"  )  ;", ". MyJaxb 2 RootElementHttpMessageConverter   myConverter    =    new    . MyJaxb 2 RootElementHttpMessageConverter (  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", ". MyRootElement   result    =     (  (  . MyRootElement )     ( myConverter . read (  . MyRootElement . class ,    inputMessage )  )  )  ;", "assertEquals (  \" a \"  ,    result . getElement (  )  . getField 1  (  )  )  ;", "assertEquals (  \" b \"  ,    result . getElement (  )  . getField 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeUnmarshaller"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =     \"  < rootElement >  < type   s =  \\  \" Hello   World \\  \"  /  >  <  / rootElement >  \"  . getBytes (  \" UTF -  8  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", ". RootElement   result    =     (  (  . RootElement )     ( converter . read (  . RootElement . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" Hello   World \"  ,    result . type . s )  ;", "}", "METHOD_END"], "methodName": ["readXmlRootElement"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   external    =    new   ClassPathResource (  \" external . txt \"  ,    getClass (  )  )  ;", "String   content    =     (  (  (  \"  <  ! DOCTYPE   root   SYSTEM    \\  \" http :  /  /  1  9  2  .  1  6  8  .  2  8  .  4  2  /  1  . jsp \\  \"     [  \"     +     (  \"        <  ! ELEMENT   external   ANY    >  \\ n \"     +     \"        <  ! ENTITY   ext   SYSTEM    \\  \"  \"  )  )     +     ( external . getURI (  )  )  )     +     \"  \\  \"     >  ]  >  \"  )     +     \"        < rootElement >  < external >  & ext ;  <  / external >  <  / rootElement >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "converter . setSupportDtd ( true )  ;", ". RootElement   rootElement    =     (  (  . RootElement )     ( converter . read (  . RootElement . class ,    inputMessage )  )  )  ;", "assertEquals (  \"  \"  ,    rootElement . external )  ;", "}", "METHOD_END"], "methodName": ["readXmlRootElementExternalEntityDisabled"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Resource   external    =    new   ClassPathResource (  \" external . txt \"  ,    getClass (  )  )  ;", "String   content    =     (  (  (  \"  <  ! DOCTYPE   root    [  \"     +     (  \"        <  ! ELEMENT   external   ANY    >  \\ n \"     +     \"        <  ! ENTITY   ext   SYSTEM    \\  \"  \"  )  )     +     ( external . getURI (  )  )  )     +     \"  \\  \"     >  ]  >  \"  )     +     \"        < rootElement >  < external >  & ext ;  <  / external >  <  / rootElement >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "this . converter . setProcessExternalEntities ( true )  ;", ". RootElement   rootElement    =     (  (  . RootElement )     ( converter . read (  . RootElement . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo   Bar \"  ,    rootElement . external )  ;", "}", "METHOD_END"], "methodName": ["readXmlRootElementExternalEntityEnabled"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =     \"  < rootElement >  < type   s =  \\  \" Hello   World \\  \"  /  >  <  / rootElement >  \"  . getBytes (  \" UTF -  8  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", ". RootElementSubclass   result    =     (  (  . RootElementSubclass )     ( converter . read (  . RootElementSubclass . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" Hello   World \"  ,    result . getType (  )  . s )  ;", "}", "METHOD_END"], "methodName": ["readXmlRootElementSubclass"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    body    =     \"  < foo   s =  \\  \" Hello   World \\  \"  /  >  \"  . getBytes (  \" UTF -  8  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body )  ;", ". Type   result    =     (  (  . Type )     ( converter . read (  . Type . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" Hello   World \"  ,    result . s )  ;", "}", "METHOD_END"], "methodName": ["readXmlType"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter    =    new   Jaxb 2 RootElementHttpMessageConverter (  )  ;", "rootElement    =    new    . RootElement (  )  ;", "DefaultAopProxyFactory   proxyFactory    =    new   DefaultAopProxyFactory (  )  ;", "AdvisedSupport   advisedSupport    =    new   AdvisedSupport (  )  ;", "advisedSupport . setTarget ( rootElement )  ;", "advisedSupport . setProxyTargetClass ( true )  ;", "AopProxy   proxy    =    proxyFactory . createAopProxy ( advisedSupport )  ;", "rootElementCglib    =     (  (  . RootElement )     ( proxy . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"  ?  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \"  <  ! DOCTYPE   lolz    [  \\ n \"     +     \"     <  ! ENTITY   lol    \\  \" lol \\  \"  >  \\ n \"  )     +     \"     <  ! ELEMENT   lolz    (  # PCDATA )  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 1     \\  \"  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 2     \\  \"  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 3     \\  \"  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 4     \\  \"  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 5     \\  \"  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 6     \\  \"  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 7     \\  \"  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 8     \\  \"  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 9     \\  \"  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  \\  \"  >  \\ n \"  )     +     \"  ]  >  \\ n \"  )     +     \"  < rootElement >  < external >  & lol 9  ;  <  / external >  <  / rootElement >  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "this . thrown . expect ( HttpMessageNotReadableException . class )  ;", "this . thrown . expectMessage (  \" DOCTYPE \"  )  ;", "this . converter . read (  . RootElement . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["testXmlBomb"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "write ( rootElement ,    null ,    outputMessage )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" xml \"  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "DifferenceEvaluator   ev    =    chain ( Default ,    downgradeDifferencesToEqual ( XML _ STANDALONE )  )  ;", "assertThat (  \" Invalid   result \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    isSimilarTo (  \"  < rootElement >  < type   s =  \\  \" Hello   World \\  \"  /  >  <  / rootElement >  \"  )  . withDifferenceEvaluator ( ev )  )  ;", "}", "METHOD_END"], "methodName": ["writeXmlRootElement"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "write ( rootElementCglib ,    null ,    outputMessage )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" xml \"  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "DifferenceEvaluator   ev    =    chain ( Default ,    downgradeDifferencesToEqual ( XML _ STANDALONE )  )  ;", "assertThat (  \" Invalid   result \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    isSimilarTo (  \"  < rootElement >  < type   s =  \\  \" Hello   World \\  \"  /  >  <  / rootElement >  \"  )  . withDifferenceEvaluator ( ev )  )  ;", "}", "METHOD_END"], "methodName": ["writeXmlRootElementSubclass"], "fileName": "org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( MappingJackson 2 XmlHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" xml \"  )  )  )  ;", "assertTrue ( converter . canRead ( MappingJackson 2 XmlHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" text \"  ,     \" xml \"  )  )  )  ;", "assertTrue ( converter . canRead ( MappingJackson 2 XmlHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" soap + xml \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( MappingJackson 2 XmlHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" xml \"  )  )  )  ;", "assertTrue ( converter . canWrite ( MappingJackson 2 XmlHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" text \"  ,     \" xml \"  )  )  )  ;", "assertTrue ( converter . canWrite ( MappingJackson 2 XmlHttpMessageConverterTests . MyBean . class ,    new   MediaType (  \" application \"  ,     \" soap + xml \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "new   MappingJackson 2 XmlHttpMessageConverter ( new   MappingJackson 2 XmlHttpMessageConverterTests . MyXmlMapper (  )  )  ;", "}", "METHOD_END"], "methodName": ["customXmlMapper"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". JacksonViewBean   bean    =    new    . JacksonViewBean (  )  ;", "bean . setWithView 1  (  \" with \"  )  ;", "bean . setWithView 2  (  \" with \"  )  ;", "bean . setWithoutView (  \" without \"  )  ;", "MappingJacksonValue   jacksonValue    =    new   MappingJacksonValue ( bean )  ;", "jacksonValue . setSerializationView (  . MyJacksonView 1  . class )  ;", "this . converter . write ( jacksonValue ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertThat ( result ,    containsString (  \"  < withView 1  > with <  / withView 1  >  \"  )  )  ;", "assertThat ( result ,    not ( containsString (  \"  < withView 2  > with <  / withView 2  >  \"  )  )  )  ;", "assertThat ( result ,    not ( containsString (  \"  < withoutView > without <  / withoutView >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonView"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  < MyBean >  \"     +     (  (  (  (  (  (  \"  < string > Foo <  / string >  \"     +     \"  < number >  4  2  <  / number >  \"  )     +     \"  < fraction >  4  2  .  0  <  / fraction >  \"  )     +     \"  < array >  < array > Foo <  / array >  \"  )     +     \"  < array > Bar <  / array >  <  / array >  \"  )     +     \"  < bool > true <  / bool >  \"  )     +     \"  < bytes > AQI =  <  / bytes >  <  / MyBean >  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", ". MyBean   result    =     (  (  . MyBean )     ( converter . read (  . MyBean . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Foo \"  ,    result . getString (  )  )  ;", "assertEquals (  4  2  ,    result . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    result . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    result . getArray (  )  )  ;", "assertTrue ( result . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    result . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" FooBar \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "this . thrown . expect ( HttpMessageNotReadableException . class )  ;", "converter . read (  . MyBean . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readInvalidXml"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  < MyBean >  < string > string <  / string >  < unknownProperty > value <  / unknownProperty >  <  / MyBean >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "converter . read (  . MyBean . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readValidXmlWithUnknownProperty"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     (  (  \"  <  ! DOCTYPE   MyBean   SYSTEM    \\  \" http :  /  /  1  9  2  .  1  6  8  .  2  8  .  4  2  /  1  . jsp \\  \"     [  \"     +     (  \"        <  ! ELEMENT   root   ANY    >  \\ n \"     +     \"        <  ! ENTITY   ext   SYSTEM    \\  \"  \"  )  )     +     ( new   ClassPathResource (  \" external . txt \"  ,    getClass (  )  )  . getURI (  )  )  )     +     \"  \\  \"     >  ]  >  < MyBean >  < string >  & ext ;  <  / string >  <  / MyBean >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "this . thrown . expect ( HttpMessageNotReadableException . class )  ;", "this . converter . read (  . MyBean . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readWithExternalReference"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"  ?  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \"  <  ! DOCTYPE   lolz    [  \\ n \"     +     \"     <  ! ENTITY   lol    \\  \" lol \\  \"  >  \\ n \"  )     +     \"     <  ! ELEMENT   lolz    (  # PCDATA )  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 1     \\  \"  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 2     \\  \"  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 3     \\  \"  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 4     \\  \"  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 5     \\  \"  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 6     \\  \"  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 7     \\  \"  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 8     \\  \"  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 9     \\  \"  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  \\  \"  >  \\ n \"  )     +     \"  ]  >  \\ n \"  )     +     \"  < MyBean >  & lol 9  ;  <  / MyBean >  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "this . thrown . expect ( HttpMessageNotReadableException . class )  ;", "this . converter . read (  . MyBean . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readWithXmlBomb"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", ". MyBean   body    =    new    . MyBean (  )  ;", "body . setString (  \" Foo \"  )  ;", "body . setNumber (  4  2  )  ;", "body . setFraction (  4  2  .  0 F )  ;", "body . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "body . setBool ( true )  ;", "body . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "converter . write ( body ,    null ,    outputMessage )  ;", "String   result    =    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ;", "assertTrue ( result . contains (  \"  < string > Foo <  / string >  \"  )  )  ;", "assertTrue ( result . contains (  \"  < number >  4  2  <  / number >  \"  )  )  ;", "assertTrue ( result . contains (  \"  < fraction >  4  2  .  0  <  / fraction >  \"  )  )  ;", "assertTrue ( result . contains (  \"  < array >  < array > Foo <  / array >  < array > Bar <  / array >  <  / array >  \"  )  )  ;", "assertTrue ( result . contains (  \"  < bool > true <  / bool >  \"  )  )  ;", "assertTrue ( result . contains (  \"  < bytes > AQI =  <  / bytes >  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" xml \"  ,    StandardCharsets . UTF _  8  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . marshaller    =    marshaller ;", "}", "METHOD_END"], "methodName": ["setMarshaller"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . unmarshaller    =    unmarshaller ;", "}", "METHOD_END"], "methodName": ["setUnmarshaller"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Unmarshaller   unmarshaller    =    mock ( Unmarshaller . class )  ;", "given ( unmarshaller . supports ( Integer . class )  )  . willReturn ( false )  ;", "given ( unmarshaller . supports ( String . class )  )  . willReturn ( true )  ;", "converter    =    new    (  )  ;", "converter . setUnmarshaller ( unmarshaller )  ;", "assertFalse ( converter . canRead ( Boolean . class ,    MediaType . TEXT _ PLAIN )  )  ;", "assertFalse ( converter . canRead ( Integer . class ,    MediaType . TEXT _ XML )  )  ;", "assertTrue ( converter . canRead ( String . class ,    MediaType . TEXT _ XML )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Marshaller   marshaller    =    mock ( Marshaller . class )  ;", "given ( marshaller . supports ( Integer . class )  )  . willReturn ( false )  ;", "given ( marshaller . supports ( String . class )  )  . willReturn ( true )  ;", "converter    =    new    (  )  ;", "converter . setMarshaller ( marshaller )  ;", "assertFalse ( converter . canWrite ( Boolean . class ,    MediaType . TEXT _ PLAIN )  )  ;", "assertFalse ( converter . canWrite ( Integer . class ,    MediaType . TEXT _ XML )  )  ;", "assertTrue ( converter . canWrite ( String . class ,    MediaType . TEXT _ XML )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  < root > Hello   World <  / root >  \"  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( body . getBytes (  \" UTF -  8  \"  )  )  ;", "Unmarshaller   unmarshaller    =    mock ( Unmarshaller . class )  ;", "given ( unmarshaller . unmarshal ( isA ( StreamSource . class )  )  )  . willReturn ( body )  ;", "converter    =    new    (  )  ;", "converter . setUnmarshaller ( unmarshaller )  ;", "String   result    =     (  ( String )     ( converter . read ( Object . class ,    inputMessage )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,    body ,    result )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( new   byte [  0  ]  )  ;", "UnmarshallingFailureException   ex    =    new   UnmarshallingFailureException (  \" forced \"  )  ;", "Unmarshaller   unmarshaller    =    mock ( Unmarshaller . class )  ;", "given ( unmarshaller . unmarshal ( isA ( StreamSource . class )  )  )  . willThrow ( ex )  ;", "converter    =    new    (  )  ;", "converter . setUnmarshaller ( unmarshaller )  ;", "try    {", "converter . read ( Object . class ,    inputMessage )  ;", "fail (  \" HttpMessageNotReadableException   should   be   thrown \"  )  ;", "}    catch    ( HttpMessageNotReadableException   e )     {", "assertTrue (  \" Invalid   exception   hierarchy \"  ,     (  ( e . getCause (  )  )     =  =    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readWithMarshallingFailureException"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( new   byte [  0  ]  )  ;", "Marshaller   marshaller    =    mock ( Marshaller . class )  ;", "Unmarshaller   unmarshaller    =    mock ( Unmarshaller . class )  ;", "given ( unmarshaller . unmarshal ( isA ( StreamSource . class )  )  )  . willReturn ( Integer . valueOf (  3  )  )  ;", "converter    =    new    ( marshaller ,    unmarshaller )  ;", "converter . read ( String . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readWithTypeMismatchException"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "new   MarshallingHttpMessageConverter (  )  . supports ( Object . class )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  < root > Hello   World <  / root >  \"  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "Marshaller   marshaller    =    mock ( Marshaller . class )  ;", "willDoNothing (  )  . given ( marshaller )  . marshal ( eq ( body )  ,    isA ( Result . class )  )  ;", "converter    =    new    ( marshaller )  ;", "converter . write ( body ,    null ,    outputMessage )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" xml \"  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  < root > Hello   World <  / root >  \"  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "MarshallingFailureException   ex    =    new   MarshallingFailureException (  \" forced \"  )  ;", "Marshaller   marshaller    =    mock ( Marshaller . class )  ;", "willThrow ( ex )  . given ( marshaller )  . marshal ( eq ( body )  ,    isA ( Result . class )  )  ;", "try    {", "converter    =    new    ( marshaller )  ;", "converter . write ( body ,    null ,    outputMessage )  ;", "fail (  \" HttpMessageNotWritableException   should   be   thrown \"  )  ;", "}    catch    ( HttpMessageNotWritableException   e )     {", "assertTrue (  \" Invalid   exception   hierarchy \"  ,     (  ( e . getCause (  )  )     =  =    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeWithMarshallingFailureException"], "fileName": "org.springframework.http.converter.xml.MarshallingHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . processExternalEntities ;", "}", "METHOD_END"], "methodName": ["isProcessExternalEntities"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . supportDtd ;", "}", "METHOD_END"], "methodName": ["isSupportDtd"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "try    {", "DocumentBuilderFactory   documentBuilderFactory    =    DocumentBuilderFactory . newInstance (  )  ;", "documentBuilderFactory . setNamespaceAware ( true )  ;", "documentBuilderFactory . setFeature (  \" http :  /  / apache . org / xml / features / disallow - doctype - decl \"  ,     (  !  ( isSupportDtd (  )  )  )  )  ;", "documentBuilderFactory . setFeature (  \" http :  /  / xml . org / sax / features / external - general - entities \"  ,    isProcessExternalEntities (  )  )  ;", "DocumentBuilder   documentBuilder    =    documentBuilderFactory . newDocumentBuilder (  )  ;", "if    (  !  ( isProcessExternalEntities (  )  )  )     {", "documentBuilder . setEntityResolver (  . NO _ OP _ ENTITY _ RESOLVER )  ;", "}", "Document   document    =    documentBuilder . parse ( body )  ;", "return   new   DOMSource ( document )  ;", "}    catch    ( NullPointerException   ex )     {", "if    (  !  ( isSupportDtd (  )  )  )     {", "throw   new   HttpMessageNotReadableException (  (  \" NPE   while   unmarshalling :     \"     +     \" This   can   happen   due   to   the   presence   of   DTD   declarations   which   are   disabled .  \"  )  ,    ex )  ;", "}", "throw   ex ;", "}    catch    ( ParserConfigurationException   ex )     {", "throw   new   HttpMessageNotReadableException (  (  \" Could   not   set   feature :     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}    catch    ( SAXException   ex )     {", "throw   new   HttpMessageNotReadableException (  (  \" Could   not   parse   document :     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readDOMSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "try    {", "XMLReader   xmlReader    =    XMLReaderFactory . createXMLReader (  )  ;", "xmlReader . setFeature (  \" http :  /  / apache . org / xml / features / disallow - doctype - decl \"  ,     (  !  ( isSupportDtd (  )  )  )  )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / external - general - entities \"  ,    isProcessExternalEntities (  )  )  ;", "if    (  !  ( isProcessExternalEntities (  )  )  )     {", "xmlReader . setEntityResolver (  . NO _ OP _ ENTITY _ RESOLVER )  ;", "}", "byte [  ]    bytes    =    StreamUtils . copyToByteArray ( body )  ;", "return   new   SAXSource ( xmlReader ,    new   InputSource ( new   ByteArrayInputStream ( bytes )  )  )  ;", "}    catch    ( SAXException   ex )     {", "throw   new   HttpMessageNotReadableException (  (  \" Could   not   parse   document :     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readSAXSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "try    {", "XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setProperty ( XMLInputFactory . SUPPORT _ DTD ,    isSupportDtd (  )  )  ;", "inputFactory . setProperty ( XMLInputFactory . IS _ SUPPORTING _ EXTERNAL _ ENTITIES ,    isProcessExternalEntities (  )  )  ;", "if    (  !  ( isProcessExternalEntities (  )  )  )     {", "inputFactory . setXMLResolver (  . NO _ OP _ XML _ RESOLVER )  ;", "}", "XMLStreamReader   streamReader    =    inputFactory . createXMLStreamReader ( body )  ;", "return   new   StAXSource ( streamReader )  ;", "}    catch    ( XMLStreamException   ex )     {", "throw   new   HttpMessageNotReadableException (  (  \" Could   not   parse   document :     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readStAXSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    StreamUtils . copyToByteArray ( body )  ;", "return   new   Stream ( new   ByteArrayInputStream ( bytes )  )  ;", "}", "METHOD_END"], "methodName": ["readStreamSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . processExternalEntities    =    processExternalEntities ;", "if    ( processExternalEntities )     {", "setSupportDtd ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["setProcessExternalEntities"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . supportDtd    =    supportDtd ;", "}", "METHOD_END"], "methodName": ["setSupportDtd"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . transformerFactory . newTransformer (  )  . transform ( source ,    result )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverter"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canRead ( Source . class ,    new   MediaType (  \" application \"  ,     \" xml \"  )  )  )  ;", "assertTrue ( converter . canRead ( Source . class ,    new   MediaType (  \" application \"  ,     \" soap + xml \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( converter . canWrite ( Source . class ,    new   MediaType (  \" application \"  ,     \" xml \"  )  )  )  ;", "assertTrue ( converter . canWrite ( Source . class ,    new   MediaType (  \" application \"  ,     \" soap + xml \"  )  )  )  ;", "assertTrue ( converter . canWrite ( Source . class ,    MediaType . ALL )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( SourceHttpMessageConverterTests . BODY . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "DOMSource   result    =     (  ( DOMSource )     ( converter . read ( DOMSource . class ,    inputMessage )  )  )  ;", "Document   document    =     (  ( Document )     ( result . getNode (  )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" root \"  ,    document . getDocumentElement (  )  . getLocalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["readDOMSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( bodyExternal . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "setSupportDtd ( true )  ;", "DOMSource   result    =     (  ( DOMSource )     ( read ( DOMSource . class ,    inputMessage )  )  )  ;", "Document   document    =     (  ( Document )     ( result . getNode (  )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" root \"  ,    document . getDocumentElement (  )  . getLocalName (  )  )  ;", "assertNotEquals (  \" Invalid   result \"  ,     \" Foo   Bar \"  ,    document . getDocumentElement (  )  . getTextContent (  )  )  ;", "}", "METHOD_END"], "methodName": ["readDOMSourceExternal"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"  ?  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \"  <  ! DOCTYPE   lolz    [  \\ n \"     +     \"     <  ! ENTITY   lol    \\  \" lol \\  \"  >  \\ n \"  )     +     \"     <  ! ELEMENT   lolz    (  # PCDATA )  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 1     \\  \"  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 2     \\  \"  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 3     \\  \"  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 4     \\  \"  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 5     \\  \"  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 6     \\  \"  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 7     \\  \"  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 8     \\  \"  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 9     \\  \"  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  \\  \"  >  \\ n \"  )     +     \"  ]  >  \\ n \"  )     +     \"  < root >  & lol 9  ;  <  / root >  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "this . thrown . expect ( NotReadableException . class )  ;", "this . thrown . expectMessage (  \" DOCTYPE \"  )  ;", "this . converter . read ( DOMSource . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readDomSourceWithXmlBomb"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( SourceHttpMessageConverterTests . BODY . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "SAXSource   result    =     (  ( SAXSource )     ( converter . read ( SAXSource . class ,    inputMessage )  )  )  ;", "InputSource   inputSource    =    result . getInputSource (  )  ;", "String   s    =    FileCopyUtils . copyToString ( new   InputStreamReader ( inputSource . getByteStream (  )  )  )  ;", "assertThat (  \" Invalid   result \"  ,    s ,    isSimilarTo ( SourceHttpMessageConverterTests . BODY )  )  ;", "}", "METHOD_END"], "methodName": ["readSAXSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( bodyExternal . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "setSupportDtd ( true )  ;", "SAXSource   result    =     (  ( SAXSource )     ( read ( SAXSource . class ,    inputMessage )  )  )  ;", "InputSource   inputSource    =    result . getInputSource (  )  ;", "XMLReader   reader    =    result . getXMLReader (  )  ;", "reader . setContentHandler ( new   DefaultHandler (  )     {", "@ Override", "public   void   characters ( char [  ]    ch ,    int   start ,    int   length )    throws   SAXException    {", "String   s    =    new   String ( ch ,    start ,    length )  ;", "assertNotEquals (  \" Invalid   result \"  ,     \" Foo   Bar \"  ,    s )  ;", "}", "}  )  ;", "reader . parse ( inputSource )  ;", "}", "METHOD_END"], "methodName": ["readSAXSourceExternal"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"  ?  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \"  <  ! DOCTYPE   lolz    [  \\ n \"     +     \"     <  ! ENTITY   lol    \\  \" lol \\  \"  >  \\ n \"  )     +     \"     <  ! ELEMENT   lolz    (  # PCDATA )  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 1     \\  \"  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 2     \\  \"  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 3     \\  \"  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 4     \\  \"  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 5     \\  \"  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 6     \\  \"  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 7     \\  \"  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 8     \\  \"  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 9     \\  \"  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  \\  \"  >  \\ n \"  )     +     \"  ]  >  \\ n \"  )     +     \"  < root >  & lol 9  ;  <  / root >  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "SAXSource   result    =     (  ( SAXSource )     ( thisread ( SAXSource . class ,    inputMessage )  )  )  ;", "this . thrown . expect ( SAXException . class )  ;", "this . thrown . expectMessage (  \" DOCTYPE \"  )  ;", "InputSource   inputSource    =    result . getInputSource (  )  ;", "XMLReader   reader    =    result . getXMLReader (  )  ;", "reader . parse ( inputSource )  ;", "}", "METHOD_END"], "methodName": ["readSAXSourceWithXmlBomb"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( SourceHttpMessageConverterTests . BODY . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "converter . read ( Source . class ,    inputMessage )  ;", "}", "METHOD_END"], "methodName": ["readSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( SourceHttpMessageConverterTests . BODY . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "StAXSource   result    =     (  ( StAXSource )     ( converter . read ( StAXSource . class ,    inputMessage )  )  )  ;", "XMLStreamReader   streamReader    =    result . getXMLStreamReader (  )  ;", "assertTrue ( streamReader . hasNext (  )  )  ;", "streamReader . nextTag (  )  ;", "String   s    =    streamReader . getLocalName (  )  ;", "assertEquals (  \" root \"  ,    s )  ;", "s    =    streamReader . getElementText (  )  ;", "assertEquals (  \" Hello   World \"  ,    s )  ;", "streamReader . close (  )  ;", "}", "METHOD_END"], "methodName": ["readStAXSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( bodyExternal . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "setSupportDtd ( true )  ;", "StAXSource   result    =     (  ( StAXSource )     ( read ( StAXSource . class ,    inputMessage )  )  )  ;", "XMLStreamReader   streamReader    =    result . getXMLStreamReader (  )  ;", "assertTrue ( streamReader . hasNext (  )  )  ;", "streamReader . next (  )  ;", "streamReader . next (  )  ;", "String   s    =    streamReader . getLocalName (  )  ;", "assertEquals (  \" root \"  ,    s )  ;", "try    {", "s    =    streamReader . getElementText (  )  ;", "assertNotEquals (  \" Foo   Bar \"  ,    s )  ;", "}    catch    ( XMLStreamException   ex )     {", "}", "streamReader . close (  )  ;", "}", "METHOD_END"], "methodName": ["readStAXSourceExternal"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"  ?  >  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \"  <  ! DOCTYPE   lolz    [  \\ n \"     +     \"     <  ! ENTITY   lol    \\  \" lol \\  \"  >  \\ n \"  )     +     \"     <  ! ELEMENT   lolz    (  # PCDATA )  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 1     \\  \"  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  & lol ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 2     \\  \"  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  & lol 1  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 3     \\  \"  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  & lol 2  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 4     \\  \"  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  & lol 3  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 5     \\  \"  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  & lol 4  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 6     \\  \"  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  & lol 5  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 7     \\  \"  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  & lol 6  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 8     \\  \"  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  & lol 7  ;  \\  \"  >  \\ n \"  )     +     \"     <  ! ENTITY   lol 9     \\  \"  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  & lol 8  ;  \\  \"  >  \\ n \"  )     +     \"  ]  >  \\ n \"  )     +     \"  < root >  & lol 9  ;  <  / root >  \"  )  ;", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( content . getBytes (  \" UTF -  8  \"  )  )  ;", "StAXSource   result    =     (  ( StAXSource )     ( thisread ( StAXSource . class ,    inputMessage )  )  )  ;", "XMLStreamReader   streamReader    =    result . getXMLStreamReader (  )  ;", "assertTrue ( streamReader . hasNext (  )  )  ;", "streamReader . next (  )  ;", "streamReader . next (  )  ;", "String   s    =    streamReader . getLocalName (  )  ;", "assertEquals (  \" root \"  ,    s )  ;", "this . thrown . expectMessage (  \"  \\  \" lol 9  \\  \"  \"  )  ;", "s    =    streamReader . getElementText (  )  ;", "}", "METHOD_END"], "methodName": ["readStAXSourceWithXmlBomb"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpInputMessage   inputMessage    =    new   MockHttpInputMessage ( SourceHttpMessageConverterTests . BODY . getBytes (  \" UTF -  8  \"  )  )  ;", "inputMessage . getHeaders (  )  . setContentType ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ;", "StreamSource   result    =     (  ( StreamSource )     ( converter . read ( StreamSource . class ,    inputMessage )  )  )  ;", "String   s    =    FileCopyUtils . copyToString ( new   InputStreamReader ( result . getInputStream (  )  )  )  ;", "assertThat (  \" Invalid   result \"  ,    s ,    isSimilarTo ( SourceHttpMessageConverterTests . BODY )  )  ;", "}", "METHOD_END"], "methodName": ["readStreamSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter    =    new   SourceHttpMessageConverter <  >  (  )  ;", "Resource   external    =    new   ClassPathResource (  \" external . txt \"  ,    getClass (  )  )  ;", "bodyExternal    =     (  (  \"  <  ! DOCTYPE   root   SYSTEM    \\  \" http :  /  /  1  9  2  .  1  6  8  .  2  8  .  4  2  /  1  . jsp \\  \"     [  \"     +     (  \"        <  ! ELEMENT   root   ANY    >  \\ n \"     +     \"        <  ! ENTITY   ext   SYSTEM    \\  \"  \"  )  )     +     ( external . getURI (  )  )  )     +     \"  \\  \"     >  ]  >  < root >  & ext ;  <  / root >  \"  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "DocumentBuilderFactory   documentBuilderFactory    =    DocumentBuilderFactory . newInstance (  )  ;", "documentBuilderFactory . setNamespaceAware ( true )  ;", "Document   document    =    documentBuilderFactory . newDocumentBuilder (  )  . newDocument (  )  ;", "Element   rootElement    =    document . createElement (  \" root \"  )  ;", "document . appendChild ( rootElement )  ;", "rootElement . setTextContent (  \" Hello   World \"  )  ;", "DOMSource   domSource    =    new   DOMSource ( document )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "write ( domSource ,    null ,    outputMessage )  ;", "assertThat (  \" Invalid   result \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    isSimilarTo (  \"  < root > Hello   World <  / root >  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" xml \"  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   content - length \"  ,    outputMessage . getBodyAsBytes (  )  . length ,    outputMessage . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeDOMSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   xml    =     \"  < root > Hello   World <  / root >  \"  ;", "SAXSource   saxSource    =    new   SAXSource ( new   InputSource ( new   StringReader ( xml )  )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "write ( saxSource ,    null ,    outputMessage )  ;", "assertThat (  \" Invalid   result \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    isSimilarTo (  \"  < root > Hello   World <  / root >  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" xml \"  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeSAXSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   xml    =     \"  < root > Hello   World <  / root >  \"  ;", "StreamSource   streamSource    =    new   StreamSource ( new   StringReader ( xml )  )  ;", "MockHttpOutputMessage   outputMessage    =    new   MockHttpOutputMessage (  )  ;", "write ( streamSource ,    null ,    outputMessage )  ;", "assertThat (  \" Invalid   result \"  ,    outputMessage . getBodyAsString ( StandardCharsets . UTF _  8  )  ,    isSimilarTo (  \"  < root > Hello   World <  / root >  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MediaType (  \" application \"  ,     \" xml \"  )  ,    outputMessage . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeStreamSource"], "fileName": "org.springframework.http.converter.xml.SourceHttpMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "if    ( path . equals (  \"  \"  )  )     {", "return    . EMPTY _ PATH ;", "}", "String   separator    =     \"  /  \"  ;", "PathContainer . Separator   separatorElement    =     ( separator . equals (  . SEPARATOR . value (  )  )  )     ?     . SEPARATOR    :     (  )     -  >    separator ;", "List < PathContainer . Element >    elements    =    new   ArrayList <  >  (  )  ;", "int   begin ;", "if    (  (  ( path . length (  )  )     >     0  )     &  &     ( path . startsWith ( separator )  )  )     {", "begin    =    separator . length (  )  ;", "elements . add ( separatorElement )  ;", "} else    {", "begin    =     0  ;", "}", "while    ( begin    <     ( path . length (  )  )  )     {", "int   end    =    path . indexOf ( separator ,    begin )  ;", "String   segment    =     ( end    !  =     (  -  1  )  )     ?    path . substring ( begin ,    end )     :    path . substring ( begin )  ;", "if    (  !  ( segment . equals (  \"  \"  )  )  )     {", "elements . add (  . parsePathSegment ( segment )  )  ;", "}", "if    ( end    =  =     (  -  1  )  )     {", "break ;", "}", "elements . add ( separatorElement )  ;", "begin    =    end    +     ( separator . length (  )  )  ;", "}", "return   new    ( path ,    elements )  ;", "}", "METHOD_END"], "methodName": ["createFromUrlPath"], "fileName": "org.springframework.http.server.DefaultPathContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( input )  )     {", "int   index    =    input . indexOf (  '  =  '  )  ;", "if    ( index    !  =     (  -  1  )  )     {", "String   name    =    input . substring (  0  ,    index )  ;", "String   value    =    input . substring (  ( index    +     1  )  )  ;", "for    ( String   v    :    StringUtils . commaDelimitedListToStringArray ( value )  )     {", "name    =    StringUtils . uriDecode ( name ,    charset )  ;", "if    ( StringUtils . hasText ( name )  )     {", "output . add ( name ,    StringUtils . uriDecode ( v ,    charset )  )  ;", "}", "}", "} else    {", "String   name    =    StringUtils . uriDecode ( input ,    charset )  ;", "if    ( StringUtils . hasText ( name )  )     {", "output . add ( input ,     \"  \"  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parsePathParamValues"], "fileName": "org.springframework.http.server.DefaultPathContainer"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    result    =    new   LinkedMultiValueMap (  )  ;", "int   begin    =     1  ;", "while    ( begin    <     ( input . length (  )  )  )     {", "int   end    =    input . indexOf (  '  ;  '  ,    begin )  ;", "String   param    =     ( end    !  =     (  -  1  )  )     ?    input . substring ( begin ,    end )     :    input . substring ( begin )  ;", "DefaultPathContainer . parsePathParamValues ( param ,    charset ,    result )  ;", "if    ( end    =  =     (  -  1  )  )     {", "break ;", "}", "begin    =    end    +     1  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parsePathParams"], "fileName": "org.springframework.http.server.DefaultPathContainer"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    StandardCharsets . UTF _  8  ;", "int   index    =    segment . indexOf (  '  ;  '  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "String   valueToMatch    =    StringUtils . uriDecode ( segment ,    charset )  ;", "return   new    . DefaultPathSegment ( segment ,    valueToMatch ,     . EMPTY _ MAP )  ;", "} else    {", "String   valueToMatch    =    StringUtils . uriDecode ( segment . substring (  0  ,    index )  ,    charset )  ;", "String   pathParameterContent    =    segment . substring ( index )  ;", "MultiValueMap < String ,    String >    parameters    =     . parsePathParams ( pathParameterContent ,    charset )  ;", "return   new    . DefaultPathSegment ( segment ,    valueToMatch ,    parameters )  ;", "}", "}", "METHOD_END"], "methodName": ["parsePathSegment"], "fileName": "org.springframework.http.server.DefaultPathContainer"}, {"methodBody": ["METHOD_START", "{", "List < PathContainer . Element >    elements    =    container . elements (  )  ;", "if    (  ( fromIndex    =  =     0  )     &  &     ( toIndex    =  =     ( elements . size (  )  )  )  )     {", "return   container ;", "}", "if    ( fromIndex    =  =    toIndex )     {", "return    . EMPTY _ PATH ;", "}", "Assert . isTrue (  (  ( fromIndex    >  =     0  )     &  &     ( fromIndex    <     ( elements . size (  )  )  )  )  ,     (  )     -  >     \" Invalid   fromIndex :     \"     +    fromIndex )  ;", "Assert . isTrue (  (  ( toIndex    >  =     0  )     &  &     ( toIndex    <  =     ( elements . size (  )  )  )  )  ,     (  )     -  >     \" Invalid   toIndex :     \"     +    toIndex )  ;", "Assert . isTrue (  ( fromIndex    <    toIndex )  ,     (  )     -  >     (  (  \" fromIndex :     \"     +    fromIndex )     +     \"    should   be    <    toIndex    \"  )     +    toIndex )  ;", "List < PathContainer . Element >    subList    =    elements . subList ( fromIndex ,    toIndex )  ;", "String   path    =    subList . stream (  )  . map ( PathContainer . Element :  : value )  . collect ( Collectors . joining (  \"  \"  )  )  ;", "return   new    ( path ,    subList )  ;", "}", "METHOD_END"], "methodName": ["subPath"], "fileName": "org.springframework.http.server.DefaultPathContainer"}, {"methodBody": ["METHOD_START", "{", "testPath (  \"  / a / b / c \"  ,     \"  / a / b / c \"  ,    Arrays . asList (  \"  /  \"  ,     \" a \"  ,     \"  /  \"  ,     \" b \"  ,     \"  /  \"  ,     \" c \"  )  )  ;", "testPath (  \"  /  \"  ,     \"  /  \"  ,    Collections . singletonList (  \"  /  \"  )  )  ;", "testPath (  \"  \"  ,     \"  \"  ,    Collections . emptyList (  )  )  ;", "testPath (  \"  %  2  0  %  2  0  \"  ,     \"  %  2  0  %  2  0  \"  ,    Collections . singletonList (  \"  %  2  0  %  2  0  \"  )  )  ;", "testPath (  \"  / a / b /  \"  ,     \"  / a / b /  \"  ,    Arrays . asList (  \"  /  \"  ,     \" a \"  ,     \"  /  \"  ,     \" b \"  ,     \"  /  \"  )  )  ;", "testPath (  \"  / a / b /  /  \"  ,     \"  / a / b /  /  \"  ,    Arrays . asList (  \"  /  \"  ,     \" a \"  ,     \"  /  \"  ,     \" b \"  ,     \"  /  \"  ,     \"  /  \"  )  )  ;", "testPath (  \"  /  %  2  0  \"  ,     \"  /  %  2  0  \"  ,    Arrays . asList (  \"  /  \"  ,     \"  %  2  0  \"  )  )  ;", "testPath (  \"  /  /  %  2  0  /  %  2  0  \"  ,     \"  /  /  %  2  0  /  %  2  0  \"  ,    Arrays . asList (  \"  /  \"  ,     \"  /  \"  ,     \"  %  2  0  \"  ,     \"  /  \"  ,     \"  %  2  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.springframework.http.server.DefaultPathContainerTests"}, {"methodBody": ["METHOD_START", "{", "testPathSegment (  \" cars \"  ,     \" cars \"  ,    new   LinkedMultiValueMap (  )  )  ;", "testPathSegment (  \"  \"  ,     \"  \"  ,    new   LinkedMultiValueMap (  )  )  ;", "testPathSegment (  \"  %  2  0  %  2  0  \"  ,     \"        \"  ,    new   LinkedMultiValueMap (  )  )  ;", "testPathSegment (  \"  %  2  0 a %  2  0  \"  ,     \"    a    \"  ,    new   LinkedMultiValueMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathSegment"], "fileName": "org.springframework.http.server.DefaultPathContainerTests"}, {"methodBody": ["METHOD_START", "{", "LinkedMultiValueMap < String ,    String >    params    =    new   LinkedMultiValueMap (  )  ;", "params . add (  \" colors \"  ,     \" red \"  )  ;", "params . add (  \" colors \"  ,     \" blue \"  )  ;", "params . add (  \" colors \"  ,     \" green \"  )  ;", "params . add (  \" year \"  ,     \"  2  0  1  2  \"  )  ;", "tesSegment (  \" cars ; colors = red , blue , green ; year =  2  0  1  2  \"  ,     \" cars \"  ,    params )  ;", "params    =    new   LinkedMultiValueMap (  )  ;", "params . add (  \" p \"  ,     \"  1  \"  )  ;", "tesSegment (  \" path ; p =  1  ;  \"  ,     \" path \"  ,    params )  ;", "params    =    new   LinkedMultiValueMap (  )  ;", "params . add (  \" param   name \"  ,     \" param   value \"  )  ;", "tesSegment (  \" path ; param %  2  0 name = param %  2  0 value ;  %  2  0  \"  ,     \" path \"  ,    params )  ;", "params    =    new   LinkedMultiValueMap (  )  ;", "params . add (  \" p \"  ,     \"  1  \"  )  ;", "tesSegment (  \" path ;  ;  ;  %  2  0  ;  %  2  0  ; p =  1  ;  %  2  0  \"  ,     \" path \"  ,    params )  ;", "}", "METHOD_END"], "methodName": ["pathSegmentParams"], "fileName": "org.springframework.http.server.DefaultPathContainerTests"}, {"methodBody": ["METHOD_START", "{", "PathContainer   path    =    PathContainer . parsePath (  \"  / a / b / c \"  )  ;", "assertSame ( path ,    path . subPath (  0  )  )  ;", "assertEquals (  \"  / b / c \"  ,    path . subPath (  2  )  . value (  )  )  ;", "assertEquals (  \"  / c \"  ,    path . subPath (  4  )  . value (  )  )  ;", "path    =    PathContainer . parsePath (  \"  /  \"  )  ;", "assertEquals (  \"  /  \"  ,    path . subPath (  0  )  . value (  )  )  ;", "path    =    PathContainer . parsePath (  \"  / a / b /  \"  )  ;", "assertEquals (  \"  / b /  \"  ,    path . subPath (  2  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["subPath"], "fileName": "org.springframework.http.server.DefaultPathContainerTests"}, {"methodBody": ["METHOD_START", "{", "PathContainer   path    =    PathContainer . parsePath ( input )  ;", "assertEquals (  (  (  \" value :     '  \"     +    input )     +     \"  '  \"  )  ,    value ,    path . value (  )  )  ;", "assertEquals (  (  \" elements :     \"     +    input )  ,    expectedElements ,    path . elements (  )  . stream (  )  . map ( PathContainer . Element :  : value )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPath"], "fileName": "org.springframework.http.server.DefaultPathContainerTests"}, {"methodBody": ["METHOD_START", "{", "PathContainer   container    =    PathContainer . parsePath ( rawValue )  ;", "if    (  \"  \"  . equals ( rawValue )  )     {", "assertEquals (  0  ,    container . elements (  )  . size (  )  )  ;", "return ;", "}", "assertEquals (  1  ,    container . elements (  )  . size (  )  )  ;", "PathContainer . PathSegment   segment    =     (  ( PathContainer . PathSegment )     ( container . elements (  )  . get (  0  )  )  )  ;", "assertEquals (  (  (  \" value :     '  \"     +    rawValue )     +     \"  '  \"  )  ,    rawValue ,    segment . value (  )  )  ;", "assertEquals (  (  (  \" valueToMatch :     '  \"     +    rawValue )     +     \"  '  \"  )  ,    valueToMatch ,    segment . valueToMatch (  )  )  ;", "assertEquals (  (  (  \" params :     '  \"     +    rawValue )     +     \"  '  \"  )  ,    params ,    segment . parameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPathSegment"], "fileName": "org.springframework.http.server.DefaultPathContainerTests"}, {"methodBody": ["METHOD_START", "{", "return   fullPath . subPath ( contextPath . elements (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["extractPathWithinApplication"], "fileName": "org.springframework.http.server.DefaultRequestPath"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( StringUtils . hasText ( contextPath )  )  )     |  |     (  \"  /  \"  . equals ( contextPath )  )  )     {", "return   PathContainer . parsePath (  \"  \"  )  ;", "}", ". validateContextPath ( path . value (  )  ,    contextPath )  ;", "int   length    =    contextPath . length (  )  ;", "int   counter    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( path . elements (  )  . size (  )  )  ;    i +  +  )     {", "PathContainer . Element   element    =    path . elements (  )  . get ( i )  ;", "counter    +  =    element . value (  )  . length (  )  ;", "if    ( length    =  =    counter )     {", "return   path . subPath (  0  ,     ( i    +     1  )  )  ;", "}", "}", "throw   new   IllegalStateException (  (  (  (  (  (  \" Failed   to   initialize   contextPath    '  \"     +    contextPath )     +     \"  '  \"  )     +     \"    for   requestPath    '  \"  )     +     ( path . value (  )  )  )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["initContextPath"], "fileName": "org.springframework.http.server.DefaultRequestPath"}, {"methodBody": ["METHOD_START", "{", "int   length    =    contextPath . length (  )  ;", "if    (  (  ( contextPath . charAt (  0  )  )     !  =     '  /  '  )     |  |     (  ( contextPath . charAt (  ( length    -     1  )  )  )     =  =     '  /  '  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Invalid   contextPath :     '  \"     +    contextPath )     +     \"  '  :     \"  )     +     \" must   start   with    '  /  '    and   not   end   with    '  /  '  \"  )  )  ;", "}", "if    (  !  ( fullPath . startsWith ( contextPath )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Invalid   contextPath    '  \"     +    contextPath )     +     \"  '  :     \"  )     +     \" must   match   the   start   of   r :     '  \"  )     +    fullPath )     +     \"  '  \"  )  )  ;", "}", "if    (  (  ( fullPath . length (  )  )     >    length )     &  &     (  ( fullPath . charAt ( length )  )     !  =     '  /  '  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Invalid   contextPath    '  \"     +    contextPath )     +     \"  '  :     \"  )     +     \" must   match   to   full   path   segments   for   r :     '  \"  )     +    fullPath )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateContextPath"], "fileName": "org.springframework.http.server.DefaultRequestPath"}, {"methodBody": ["METHOD_START", "{", "testRequestPath (  \"  / app / a / b / c \"  ,     \"  / app \"  ,     \"  / a / b / c \"  )  ;", "testRequestPath (  \"  / a / b / c \"  ,     \"  \"  ,     \"  / a / b / c \"  )  ;", "testRequestPath (  \"  / a / b \"  ,     \"  / a / b \"  ,     \"  \"  )  ;", "testRequestPath (  \"  /  \"  ,     \"  \"  ,     \"  /  \"  )  ;", "testRequestPath (  \"  \"  ,     \"  \"  ,     \"  \"  )  ;", "testRequestPath (  \"  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "testRequestPath (  \"  / app / a /  \"  ,     \"  / app \"  ,     \"  / a /  \"  )  ;", "testRequestPath (  \"  / app / a /  /  \"  ,     \"  / app \"  ,     \"  / a /  /  \"  )  ;", "}", "METHOD_END"], "methodName": ["requestPath"], "fileName": "org.springframework.http.server.DefaultRequestPathTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    URI . create (  (  \" http :  /  / localhost :  8  0  8  0  \"     +    fullPath )  )  ;", "requestPath    =     . parse ( uri ,    contextPath )  ;", "assertEquals (  ( contextPath . equals (  \"  /  \"  )     ?     \"  \"     :    contextPath )  ,    requestPath . contextPath (  )  . value (  )  )  ;", "assertEquals ( pathWithinApplication ,    requestPath . pathWithinApplication (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRequestPath"], "fileName": "org.springframework.http.server.DefaultRequestPathTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    URI . create (  \" http :  /  / localhost :  8  0  8  0  / aA / bB / cC \"  )  ;", "requestPath    =     . parse ( uri ,    null )  ;", "assertEquals (  \"  \"  ,    requestPath . contextPath (  )  . value (  )  )  ;", "assertEquals (  \"  / aA / bB / cC \"  ,    requestPath . pathWithinApplication (  )  . value (  )  )  ;", "requestPath    =    requestPath . modifyContextPath (  \"  / aA \"  )  ;", "assertEquals (  \"  / aA \"  ,    requestPath . contextPath (  )  . value (  )  )  ;", "assertEquals (  \"  / bB / cC \"  ,    requestPath . pathWithinApplication (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["updateRequestPath"], "fileName": "org.springframework.http.server.DefaultRequestPathTests"}, {"methodBody": ["METHOD_START", "{", "return   DefaultPathContainer . createFromUrlPath ( path )  ;", "}", "METHOD_END"], "methodName": ["parsePath"], "fileName": "org.springframework.http.server.PathContainer"}, {"methodBody": ["METHOD_START", "{", "return   subPath ( index ,    elements (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["subPath"], "fileName": "org.springframework.http.server.PathContainer"}, {"methodBody": ["METHOD_START", "{", "return   DefaultPathContainer . subPath ( this ,    startIndex ,    endIndex )  ;", "}", "METHOD_END"], "methodName": ["subPath"], "fileName": "org.springframework.http.server.PathContainer"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultRequestPath ( uri ,    contextPath )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.http.server.RequestPath"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream (  1  0  2  4  )  ;", "Writer   writer    =    new   OutputStreamWriter ( bos ,     . FORM _ CHARSET )  ;", "Map < String ,    String [  ]  >    form    =    request . getParameterMap (  )  ;", "for    ( Iterator < String >    nameIterator    =    form . keySet (  )  . iterator (  )  ;    nameIterator . hasNext (  )  ;  )     {", "String   name    =    nameIterator . next (  )  ;", "List < String >    values    =    Arrays . asList ( form . get ( name )  )  ;", "for    ( Iterator < String >    valueIterator    =    values . iterator (  )  ;    valueIterator . hasNext (  )  ;  )     {", "String   value    =    valueIterator . next (  )  ;", "writer . write ( URLEncoder . encode ( name ,     . FORM _ CHARSET . name (  )  )  )  ;", "if    ( value    !  =    null )     {", "writer . write (  '  =  '  )  ;", "writer . write ( URLEncoder . encode ( value ,     . FORM _ CHARSET . name (  )  )  )  ;", "if    ( valueIterator . hasNext (  )  )     {", "writer . write (  '  &  '  )  ;", "}", "}", "}", "if    ( nameIterator . hasNext (  )  )     {", "writer . append (  '  &  '  )  ;", "}", "}", "writer . flush (  )  ;", "return   new   ByteArrayInputStream ( bos . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyFromServletRequestParameters"], "fileName": "org.springframework.http.server.ServletServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . servletRequest ;", "}", "METHOD_END"], "methodName": ["getServletRequest"], "fileName": "org.springframework.http.server.ServletServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =    request . getContentType (  )  ;", "return    (  ( contentType    !  =    null )     &  &     ( contentType . contains (  . FORM _ CONTENT _ TYPE )  )  )     &  &     ( HttpMethod . POST . matches ( request . getMethod (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isFormPost"], "fileName": "org.springframework.http.server.ServletServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "mockRequest    =    new   MockHttpServletRequest (  )  ;", "request    =    new    ( mockRequest )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    content    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "mock . setContent ( content )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( request . getBody (  )  )  ;", "assertArrayEquals (  \" Invalid   content   returned \"  ,    content ,    result )  ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "mockRequest . setContentType (  \" application / x - www - form - urlencoded ;    charset = UTF -  8  \"  )  ;", "mockRequest . setMethod (  \" POST \"  )  ;", "mockRequest . addParameter (  \" name    1  \"  ,     \" value    1  \"  )  ;", "mockRequest . addParameter (  \" name    2  \"  ,    new   String [  ]  {     \" value    2  +  1  \"  ,     \" value    2  +  2  \"     }  )  ;", "mockRequest . addParameter (  \" name    3  \"  ,     (  ( String )     ( null )  )  )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( request . getBody (  )  )  ;", "byte [  ]    content    =     \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  . getBytes (  \" UTF -  8  \"  )  ;", "assertArrayEquals (  \" Invalid   content   returned \"  ,    content ,    result )  ;", "}", "METHOD_END"], "methodName": ["getFormBody"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =     \" MyHeader \"  ;", "String   headerValue 1     =     \" value 1  \"  ;", "String   headerValue 2     =     \" value 2  \"  ;", "mock . addHeader ( headerName ,    headerValue 1  )  ;", "mock . addHeader ( headerName ,    headerValue 2  )  ;", "mock . setContentType (  \" text / plain \"  )  ;", "mock . setCharacterEncoding (  \" UTF -  8  \"  )  ;", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "assertNotNull (  \" No   HttpHeaders   returned \"  ,    headers )  ;", "assertTrue (  \" Invalid   headers   returned \"  ,    headers . containsKey ( headerName )  )  ;", "List < String >    headerValues    =    headers . get ( headerName )  ;", "assertEquals (  \" Invalid   header   values   returned \"  ,     2  ,    headerValues . size (  )  )  ;", "assertTrue (  \" Invalid   header   values   returned \"  ,    headerValues . contains ( headerValue 1  )  )  ;", "assertTrue (  \" Invalid   header   values   returned \"  ,    headerValues . contains ( headerValue 2  )  )  ;", "assertEquals (  \" Invalid   Content - Type \"  ,    new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . UTF _  8  )  ,    headers . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =     \" MyHeader \"  ;", "String   headerValue 1     =     \" value 1  \"  ;", "String   headerValue 2     =     \" value 2  \"  ;", "mock . addHeader ( headerName ,    headerValue 1  )  ;", "mock . addHeader ( headerName ,    headerValue 2  )  ;", "mock . setContentType (  \"  \"  )  ;", "mock . setCharacterEncoding (  \"  \"  )  ;", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "assertNotNull (  \" No   HttpHeaders   returned \"  ,    headers )  ;", "assertTrue (  \" Invalid   headers   returned \"  ,    headers . containsKey ( headerName )  )  ;", "List < String >    headerValues    =    headers . get ( headerName )  ;", "assertEquals (  \" Invalid   header   values   returned \"  ,     2  ,    headerValues . size (  )  )  ;", "assertTrue (  \" Invalid   header   values   returned \"  ,    headerValues . contains ( headerValue 1  )  )  ;", "assertTrue (  \" Invalid   header   values   returned \"  ,    headerValues . contains ( headerValue 2  )  )  ;", "assertNull ( headers . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHeadersWithEmptyContentTypeAndEncoding"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "mockRequest . setMethod (  \" POST \"  )  ;", "assertEquals (  \" Invalid   method \"  ,    HttpMethod . POST ,    request . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" http :  /  / example . com / path \"  )  ;", "mockRequest . sName ( uri . getHost (  )  )  ;", "mockRequest . sPort ( uri . getPort (  )  )  ;", "mockRequest . setRequestURI ( uri . getPath (  )  )  ;", "mockRequest . setQueryString ( uri . getQuery (  )  )  ;", "assertEquals ( uri ,    request . getURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUriForSimplePath"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  \" https :  /  / example . com /  % E 4  % B 8  % AD % E 6  %  9  6  %  8  7  \"     +     \"  ? redirect = https %  3 A %  2 F %  2 Fgithub . com %  2 Fspring - projects %  2 Fspring - framework \"  )  )  ;", "mockRequest . setScheme ( uri . getScheme (  )  )  ;", "mockRequest . setServerName ( uri . getHost (  )  )  ;", "mockRequest . setServerPort ( uri . getPort (  )  )  ;", "mockRequest . setRequestURI ( uri . getRawPath (  )  )  ;", "mockRequest . setQueryString ( uri . getRawQuery (  )  )  ;", "assertEquals ( uri ,    request . getURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUriWithEncoding"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "mockRequest . setServerName (  \" example . com \"  )  ;", "mockRequest . setRequestURI (  \"  / path \"  )  ;", "mockRequest . setQueryString (  \" query = foo %  % x \"  )  ;", "assertEquals ( new   URI (  \" http :  /  / example . com / path \"  )  ,    request . getURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUriWithMalformedQueryParam"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "mockRequest . setServerName (  \" example . com \"  )  ;", "mockRequest . setRequestURI (  \"  / path \"  )  ;", "mockRequest . setQueryString (  \" query = foo \"  )  ;", "assertEquals ( new   URI (  \" http :  /  / example . com / path ? query = foo \"  )  ,    request . getURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUriWithQueryParam"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" http :  /  / example . com / path ? query \"  )  ;", "mockRequest . sName ( uri . getHost (  )  )  ;", "mockRequest . sPort ( uri . getPort (  )  )  ;", "mockRequest . setRequestURI ( uri . getPath (  )  )  ;", "mockRequest . setQueryString ( uri . getQuery (  )  )  ;", "assertEquals ( uri ,    request . getURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUriWithQueryString"], "fileName": "org.springframework.http.server.ServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "return   this . servletResponse ;", "}", "METHOD_END"], "methodName": ["getServletResponse"], "fileName": "org.springframework.http.server.ServletServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . headersWritten )  )     {", "getHeaders (  )  . forEach (  (    headerName ,    headerValues )     -  >     {", "for    ( String   headerValue    :    headerValues )     {", "this . servlet . addHeader ( headerName ,    headerValue )  ;", "}", "}  )  ;", "if    (  (  ( this . servlet . getContentType (  )  )     =  =    null )     &  &     (  ( this . headers . getContentType (  )  )     !  =    null )  )     {", "this . servlet . setContentType ( this . headers . getContentType (  )  . toString (  )  )  ;", "}", "if    (  (  (  ( this . servlet . getCharacterEncoding (  )  )     =  =    null )     &  &     (  ( this . headers . getContentType (  )  )     !  =    null )  )     &  &     (  ( this . headers . getContentType (  )  . getCharset (  )  )     !  =    null )  )     {", "this . servlet . setCharacterEncoding ( this . headers . getContentType (  )  . getCharset (  )  . name (  )  )  ;", "}", "this . headersWritten    =    true ;", "}", "}", "METHOD_END"], "methodName": ["writeHeaders"], "fileName": "org.springframework.http.server.ServletServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "mockResponse    =    new   MockHttpServletResponse (  )  ;", "response    =    new    ( mockResponse )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.http.server.ServletServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    content    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FileCopyUtils . copy ( content ,    response . getBody (  )  )  ;", "assertArrayEquals (  \" Invalid   content   written \"  ,    content ,    mock . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.springframework.http.server.ServletServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    response . getHeaders (  )  ;", "String   headerName    =     \" MyHeader \"  ;", "String   headerValue 1     =     \" value 1  \"  ;", "headers . add ( headerName ,    headerValue 1  )  ;", "String   headerValue 2     =     \" value 2  \"  ;", "headers . add ( headerName ,    headerValue 2  )  ;", "headers . setContentType ( new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . UTF _  8  )  )  ;", "response . close (  )  ;", "assertTrue (  \" Header   not   set \"  ,    mock . getHeaderNames (  )  . contains ( headerName )  )  ;", "List < String >    headerValues    =    mock . getHeaders ( headerName )  ;", "assertTrue (  \" Header   not   set \"  ,    headerValues . contains ( headerValue 1  )  )  ;", "assertTrue (  \" Header   not   set \"  ,    headerValues . contains ( headerValue 2  )  )  ;", "assertEquals (  \" Invalid   Content - Type \"  ,     \" text / plain ; charset = UTF -  8  \"  ,    mock . getHeader (  \" Content - Type \"  )  )  ;", "assertEquals (  \" Invalid   Content - Type \"  ,     \" text / plain ; charset = UTF -  8  \"  ,    mock . getContentType (  )  )  ;", "assertEquals (  \" Invalid   Content - Type \"  ,     \" UTF -  8  \"  ,    mock . getCharacterEncoding (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.http.server.ServletServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =     \" Access - Control - Allow - Origin \"  ;", "String   headerValue    =     \" localhost :  8  0  8  0  \"  ;", "this . mockResponse . addHeader ( headerName ,    headerValue )  ;", "this . response    =    new    ( this . mockResponse )  ;", "assertEquals ( headerValue ,    this . response . getHeaders (  )  . getFirst ( headerName )  )  ;", "assertEquals ( Collections . singletonList ( headerValue )  ,    this . response . getHeaders (  )  . get ( headerName )  )  ;", "assertTrue ( this . response . getHeaders (  )  . containsKey ( headerName )  )  ;", "assertEquals ( headerValue ,    this . response . getHeaders (  )  . getFirst ( headerName )  )  ;", "assertEquals ( headerValue ,    this . response . getHeaders (  )  . getAccessControlAllowOrigin (  )  )  ;", "}", "METHOD_END"], "methodName": ["preExistingHeadersFromHttpServletResponse"], "fileName": "org.springframework.http.server.ServletServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "response . setStatusCode ( HttpStatus . NOT _ FOUND )  ;", "assertEquals (  \" Invalid   status   code \"  ,     4  0  4  ,    mock . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["setStatusCode"], "fileName": "org.springframework.http.server.ServletServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "File   base    =    new   File ( System . getProperty (  \" tmpdir \"  )  )  ;", "return   new   Object [  ]  [  ]  {    new   Object [  ]  {    new   JettyHttpS (  )     }  ,    new   Object [  ]  {    new   ReactorHttpS (  )     }  ,    new   Object [  ]  {    new   TomcatHttpS ( base . getAbsolutePath (  )  )     }  ,    new   Object [  ]  {    new   UndertowHttpS (  )     }     }  ;", "}", "METHOD_END"], "methodName": ["arguments"], "fileName": "org.springframework.http.server.reactive.AbstractHttpHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   Flux . interval ( period )  . take ( count )  . onBackpressureBuffer ( count )  ;", "}", "METHOD_END"], "methodName": ["interval"], "fileName": "org.springframework.http.server.reactive.AbstractHttpHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . server . setHandler ( createHttpHandler (  )  )  ;", "this . server . afterPropertiesSet (  )  ;", "this . server . start (  )  ;", "this . port    =    this . server . getPort (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.http.server.reactive.AbstractHttpHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . server . stop (  )  ;", "this . port    =     0  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.http.server.reactive.AbstractHttpHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    this . state . compareAndSet ( oldState ,    newState )  ;", "if    ( result    &  &     ( logger . isTraceEnabled (  )  )  )     {", "logger . e (  (  ( oldState    +     \"     -  >     \"  )     +    newState )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["changeState"], "fileName": "org.springframework.http.server.reactive.AbstractListenerReadPublisher"}, {"methodBody": ["METHOD_START", "{", "if    ( changeState ( oldState ,    AbstractListenerReadPublisher . State . DEMAND )  )     {", "if    (  !  ( oldState . equals ( AbstractListenerReadPublisher . State . READING )  )  )     {", "checkOnDataAvailable (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["changeToDemandState"], "fileName": "org.springframework.http.server.reactive.AbstractListenerReadPublisher"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadSubscription (  )  ;", "}", "METHOD_END"], "methodName": ["createSubscription"], "fileName": "org.springframework.http.server.reactive.AbstractListenerReadPublisher"}, {"methodBody": ["METHOD_START", "{", "this . logger . trace (  \" I / O   event   onAllDataRead \"  )  ;", "this . state . get (  )  . onAllDataRead ( this )  ;", "}", "METHOD_END"], "methodName": ["onAllDataRead"], "fileName": "org.springframework.http.server.reactive.AbstractListenerReadPublisher"}, {"methodBody": ["METHOD_START", "{", "this . logger . trace (  \" I / O   event   onDataAvailable \"  )  ;", "this . state . get (  )  . onDataAvailable ( this )  ;", "}", "METHOD_END"], "methodName": ["onDataAvailable"], "fileName": "org.springframework.http.server.reactive.AbstractListenerReadPublisher"}, {"methodBody": ["METHOD_START", "{", "if    ( this . logger . isTraceEnabled (  )  )     {", "this . logger . e (  (  \" I / O   event   onError :     \"     +    ex )  )  ;", "}", "this . state . get (  )  . onError ( this ,    ex )  ;", "}", "METHOD_END"], "methodName": ["onError"], "fileName": "org.springframework.http.server.reactive.AbstractListenerReadPublisher"}, {"methodBody": ["METHOD_START", "{", "long   r ;", "while    (  (  ( r    =    this . demand )     >     0  )     &  &     (  !  ( this . state . get (  )  . equals (  . State . COMPLETED )  )  )  )     {", "T   data    =    read (  )  ;", "if    ( data    !  =    null )     {", "if    ( r    !  =     ( Long . MAX _ VALUE )  )     {", ". DEMAND _ FIELD _ UPDATER . addAndGet ( this ,     (  -  1 L )  )  ;", "}", "Subscriber <  ?    super   T >    subscriber    =    this . subscriber ;", "Assert . state (  ( subscriber    !  =    null )  ,     \" No   subscriber \"  )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  \" Data   item   read ,    publishing .  .  \"  )  ;", "}", "subscriber . onNext ( data )  ;", "} else    {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  \" No   more   data   to   read \"  )  ;", "}", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["readAndPublish"], "fileName": "org.springframework.http.server.reactive.AbstractListenerReadPublisher"}, {"methodBody": ["METHOD_START", "{", "this . logger . trace (  \" Received   request   to   cancel \"  )  ;", "if    (  ( this . subscription )     !  =    null )     {", "this . subscription . cancel (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteFlushProcessor"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    this . state . compareAndSet ( oldState ,    newState )  ;", "if    ( result    &  &     ( logger . isTraceEnabled (  )  )  )     {", "logger . e (  (  ( oldState    +     \"     -  >     \"  )     +    newState )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["changeState"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteFlushProcessor"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    isWritePossible (  )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" isWritePossible [  \"     +    result )     +     \"  ]  \"  )  )  ;", "}", "if    ( result )     {", "onossible (  )  ;", "}", "}", "METHOD_END"], "methodName": ["flushIfPossible"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteFlushProcessor"}, {"methodBody": ["METHOD_START", "{", "this . state . get (  )  . onFlushPossible ( this )  ;", "}", "METHOD_END"], "methodName": ["onFlushPossible"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteFlushProcessor"}, {"methodBody": ["METHOD_START", "{", "this . logger . trace (  \" Received   request   to   cancel \"  )  ;", "if    (  ( this . subscription )     !  =    null )     {", "this . subscription . cancel (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteProcessor"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    this . state . compareAndSet ( oldState ,    newState )  ;", "if    ( result    &  &     ( logger . isTraceEnabled (  )  )  )     {", "logger . e (  (  ( oldState    +     \"     -  >     \"  )     +    newState )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["changeState"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( changeState ( oldState ,    AbstractListenerWriteProcessor . State . COMPLETED )  )     {", "writingComplete (  )  ;", "this . resultPublisher . publishComplete (  )  ;", "} else    {", "this . state . get (  )  . onComplete ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["changeStateToComplete"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( changeState ( oldState ,    AbstractListenerWriteProcessor . State . RECEIVED )  )     {", "writeIfPossible (  )  ;", "}", "}", "METHOD_END"], "methodName": ["changeStateToReceived"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . currentData )     !  =    null )     {", "throw   new   IllegalStateException (  (  \" Current   data   not   ped   yet :     \"     +     ( this . currentData )  )  )  ;", "}", "this . currentData    =    data ;", "}", "METHOD_END"], "methodName": ["dataReceived"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteProcessor"}, {"methodBody": ["METHOD_START", "{", "this . logger . trace (  \" Received   onWritePossible \"  )  ;", "this . state . get (  )  . onWritePossible ( this )  ;", "}", "METHOD_END"], "methodName": ["onWritePossible"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteProcessor"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    isWritePossible (  )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" isWritePossible [  \"     +    result )     +     \"  ]  \"  )  )  ;", "}", "if    ( result )     {", "onWritePossible (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeIfPossible"], "fileName": "org.springframework.http.server.reactive.AbstractListenerWriteProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   URLDecoder . decode ( value ,     \" UTF -  8  \"  )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  (  (  (  \" Could   not   decode   query   param    [  \"     +    value )     +     \"  ]    as    ' UTF -  8  '  .     \"  )     +     \" Falling   back   on   default   encoding ;    exception   message :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "return   URLDecoder . decode ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["decodeQueryParam"], "fileName": "org.springframework.http.server.reactive.AbstractServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    queryParams    =    new   LinkedMultiValueMap (  )  ;", "String   query    =    getURI (  )  . getRawQuery (  )  ;", "if    ( query    !  =    null )     {", "Matcher   matcher    =     . QUERY _ PATTERN . matcher ( query )  ;", "while    ( matcher . find (  )  )     {", "String   name    =    decodeQueryParam ( matcher . group (  1  )  )  ;", "String   eq    =    matcher . group (  2  )  ;", "String   value    =    matcher . group (  3  )  ;", "value    =     ( value    !  =    null )     ?    decodeQueryParam ( value )     :    StringUtils . hasLength ( eq )     ?     \"  \"     :    null ;", "queryParams . add ( name ,    value )  ;", "}", "}", "return   queryParams ;", "}", "METHOD_END"], "methodName": ["initQueryParams"], "fileName": "org.springframework.http.server.reactive.AbstractServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   doCommit ( null )  ;", "}", "METHOD_END"], "methodName": ["doCommit"], "fileName": "org.springframework.http.server.reactive.AbstractServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . state . compareAndSet ( AbstractServerHttpResponse . State . NEW ,    AbstractServerHttpResponse . State . COMMITTING )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" Skipping   doCommit    ( response   already   committed )  .  \"  )  ;", "}", "return   Mono . empty (  )  ;", "}", "this . commitActions . add (  (  )     -  >    Mono . fromRunnable (  (  )     -  >     {", "applyStatusCode (  )  ;", "applyHeaders (  )  ;", "applyCookies (  )  ;", "this . state . set ( State . COMMITTED )  ;", "}  )  )  ;", "if    ( writeAction    !  =    null )     {", "this . commitActions . add ( writeAction )  ;", "}", "List <  ?    extends   Mono < Void >  >    actions    =    this . commitActions . stream (  )  . map ( Supplier :  : get )  . collect ( Collectors . toList (  )  )  ;", "return   Flux . concat ( actions )  . then (  )  ;", "}", "METHOD_END"], "methodName": ["doCommit"], "fileName": "org.springframework.http.server.reactive.AbstractServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . statusCode ;", "}", "METHOD_END"], "methodName": ["getStatusCodeValue"], "fileName": "org.springframework.http.server.reactive.AbstractServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "this . statusCode    =    statusCode ;", "}", "METHOD_END"], "methodName": ["setStatusCodeValue"], "fileName": "org.springframework.http.server.reactive.AbstractServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  (  \" http :  /  / localhost :  \"     +     ( port )  )  )  ;", "ResponseEntity < String >    response    =    new   RestTemplate (  )  . exchange ( RequestEntity . get ( url )  . build (  )  ,    String . class )  ;", "assertThat ( response . getBody (  )  ,    Matchers . equalTo (  \" hello \"  )  )  ;", "}", "METHOD_END"], "methodName": ["basicTest"], "fileName": "org.springframework.http.server.reactive.AsyncIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Void >    completion    =    Flux .  < String > empty (  )  . as ( this :  : sendOperator )  ;", "Signal < Void >    signal    =    completion . materialize (  )  . block (  )  ;", "assertNotNull ( signal )  ;", "assertTrue (  (  \" Unexpected   signal :     \"     +    signal )  ,    signal . isOnComplete (  )  )  ;", "assertEquals (  0  ,    this . writer . items . size (  )  )  ;", "assertTrue ( this . writer . completed )  ;", "}", "METHOD_END"], "methodName": ["completionBeforeFirstItem"], "fileName": "org.springframework.http.server.reactive.ChannelSendOperatorTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   error    =    new   IllegalStateException (  \" boo \"  )  ;", "Flux < String >    publisher    =    Flux . generate (  (  )     -  >     0  ,     (    idx ,    subscriber )     -  >     {", "int   i    =     +  + idx ;", "subscriber . next ( String . valueOf ( i )  )  ;", "if    ( i    =  =     3  )     {", "subscriber . error ( error )  ;", "}", "return   i ;", "}  )  ;", "Mono < Void >    completion    =    publisher . as ( this :  : s )  ;", "Signal < Void >    signal    =    completion . materialize (  )  . block (  )  ;", "assertNotNull ( signal )  ;", "assertSame (  (  \" Unexpected   signal :     \"     +    signal )  ,    error ,    signal . getThrowable (  )  )  ;", "assertEquals (  3  ,    this . writer . items . size (  )  )  ;", "assertEquals (  \"  1  \"  ,    this . writer . items . get (  0  )  )  ;", "assertEquals (  \"  2  \"  ,    this . writer . items . get (  1  )  )  ;", "assertEquals (  \"  3  \"  ,    this . writer . items . get (  2  )  )  ;", "assertSame ( error ,    this . writer . error )  ;", "}", "METHOD_END"], "methodName": ["errorAfterMultipleItems"], "fileName": "org.springframework.http.server.reactive.ChannelSendOperatorTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   error    =    new   IllegalStateException (  \" boo \"  )  ;", "Mono < Void >    completion    =    Mono .  < String > error ( error )  . as ( this :  : s )  ;", "Signal < Void >    signal    =    completion . materialize (  )  . block (  )  ;", "assertNotNull ( signal )  ;", "assertSame (  (  \" Unexpected   signal :     \"     +    signal )  ,    error ,    signal . getThrowable (  )  )  ;", "}", "METHOD_END"], "methodName": ["errorBeforeFirstItem"], "fileName": "org.springframework.http.server.reactive.ChannelSendOperatorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ChannelSendOperator ( source ,    writer :  : send )  ;", "}", "METHOD_END"], "methodName": ["sendOperator"], "fileName": "org.springframework.http.server.reactive.ChannelSendOperatorTests"}, {"methodBody": ["METHOD_START", "{", "this . writer    =    new   ChannelSendOperatorTests . OneByOneAsyncWriter (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.http.server.reactive.ChannelSendOperatorTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    items    =    Arrays . asList (  \" one \"  ,     \" two \"  ,     \" three \"  )  ;", "Mono < Void >    completion    =    Flux . fromIterable ( items )  . as ( this :  : s )  ;", "Signal < Void >    signal    =    completion . materialize (  )  . block (  )  ;", "assertNotNull ( signal )  ;", "assertTrue (  (  \" Unexpected   signal :     \"     +    signal )  ,    signal . isOnComplete (  )  )  ;", "assertEquals (  3  ,    this . writer . items . size (  )  )  ;", "assertEquals (  \" one \"  ,    this . writer . items . get (  0  )  )  ;", "assertEquals (  \" two \"  ,    this . writer . items . get (  1  )  )  ;", "assertEquals (  \" three \"  ,    this . writer . items . get (  2  )  )  ;", "assertTrue ( this . writer . completed )  ;", "}", "METHOD_END"], "methodName": ["writeMultipleItems"], "fileName": "org.springframework.http.server.reactive.ChannelSendOperatorTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Void >    completion    =    Flux . just (  \" one \"  )  . as ( this :  : sendOperator )  ;", "Signal < Void >    signal    =    completion . materialize (  )  . block (  )  ;", "assertNotNull ( signal )  ;", "assertTrue (  (  \" Unexpected   signal :     \"     +    signal )  ,    signal . isOnComplete (  )  )  ;", "assertEquals (  1  ,    this . writer . items . size (  )  )  ;", "assertEquals (  \" one \"  ,    this . writer . items . get (  0  )  )  ;", "assertTrue ( this . writer . completed )  ;", "}", "METHOD_END"], "methodName": ["writeOneItem"], "fileName": "org.springframework.http.server.reactive.ChannelSendOperatorTests"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( contextPath ,     \" Context   path   must   not   be   empty \"  )  ;", "if    ( contextPath . equals (  \"  /  \"  )  )     {", "return ;", "}", "Assert . isTrue ( contextPath . startsWith (  \"  /  \"  )  ,     \" Context   path   must   begin   with    '  /  '  \"  )  ;", "Assert . isTrue (  (  !  ( contextPath . endsWith (  \"  /  \"  )  )  )  ,     \" Context   path   must   not   end   with    '  /  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["assertValidContextPath"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandler"}, {"methodBody": ["METHOD_START", "{", "map . keySet (  )  . forEach ( ContextPathCompositeHandler :  : assertValidContextPath )  ;", "return   new   LinkedHashMap <  >  ( map )  ;", "}", "METHOD_END"], "methodName": ["initHandlers"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandler"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( handler . wasInvoked (  )  )  ;", "assertEquals ( c ,    handler . getRequest (  )  . getPath (  )  . c (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertInvoked"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Arrays . stream ( handlers )  . forEach (  (    handler )     -  >    TestCase . assertFalse ( handler . wasInvoked (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNotInvoked"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testInvalid (  \"        \"  ,     \" Context   path   must   not   be   empty \"  )  ;", "testInvalid (  \" path \"  ,     \" Context   path   must   begin   with    '  /  '  \"  )  ;", "testInvalid (  \"  / path /  \"  ,     \" Context   path   must   not   end   with    '  /  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["invalidContextPath"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ContextPathCompositeHandlerTests . TestHttpHandler   handler 1     =    new   ContextPathCompositeHandlerTests . TestHttpHandler (  )  ;", "ContextPathCompositeHandlerTests . TestHttpHandler   handler 2     =    new   ContextPathCompositeHandlerTests . TestHttpHandler (  )  ;", "ContextPathCompositeHandlerTests . TestHttpHandler   handler 3     =    new   ContextPathCompositeHandlerTests . TestHttpHandler (  )  ;", "Map < String ,    HttpHandler >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  / path \"  ,    handler 1  )  ;", "map . put (  \"  / another / path \"  ,    handler 2  )  ;", "map . put (  \"  / yet / another / path \"  ,    handler 3  )  ;", "testHandle (  \"  / another / path / and / more \"  ,    map )  ;", "assertInvoked ( handler 2  ,     \"  / another / path \"  )  ;", "assertNotInvoked ( handler 1  ,    handler 3  )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ContextPathCompositeHandlerTests . TestHttpHandler   handler 1     =    new   ContextPathCompositeHandlerTests . TestHttpHandler (  )  ;", "ContextPathCompositeHandlerTests . TestHttpHandler   handler 2     =    new   ContextPathCompositeHandlerTests . TestHttpHandler (  )  ;", "ContextPathCompositeHandlerTests . TestHttpHandler   handler 3     =    new   ContextPathCompositeHandlerTests . TestHttpHandler (  )  ;", "Map < String ,    HttpHandler >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  / path \"  ,    handler 1  )  ;", "map . put (  \"  / another / path \"  ,    handler 2  )  ;", "map . put (  \"  / yet / another / path \"  ,    handler 3  )  ;", "testHandle (  \"  / path \"  ,    map )  ;", "assertInvoked ( handler 1  ,     \"  / path \"  )  ;", "assertNotInvoked ( handler 2  ,    handler 3  )  ;", "}", "METHOD_END"], "methodName": ["matchWithContextPathEqualToPath"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / yet / another / path \"  )  . contextPath (  \"  / yet \"  )  . build (  )  ;", ". TestHttpHandler   handler    =    new    . TestHttpHandler (  )  ;", "Map < String ,    HttpHandler >    map    =    Collections . singletonMap (  \"  / another / path \"  ,    handler )  ;", "new   ContextPathCompositeHandler ( map )  . handle ( request ,    new   MockServerHttpResponse (  )  )  ;", "assertTrue ( handler . wasInvoked (  )  )  ;", "assertEquals (  \"  / yet / another / path \"  ,    handler . getRequest (  )  . getPath (  )  . contextPath (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["matchWithNativeContextPath"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ContextPathCompositeHandlerTests . TestHttpHandler   handler 1     =    new   ContextPathCompositeHandlerTests . TestHttpHandler (  )  ;", "ContextPathCompositeHandlerTests . TestHttpHandler   handler 2     =    new   ContextPathCompositeHandlerTests . TestHttpHandler (  )  ;", "Map < String ,    HttpHandler >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  / path \"  ,    handler 1  )  ;", "map . put (  \"  / another / path \"  ,    handler 2  )  ;", "ServerHttpResponse   response    =    testHandle (  \"  / yet / another / path \"  ,    map )  ;", "assertNotInvoked ( handler 1  ,    handler 2  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    MockServerHttpRequest . get ( pathToHandle )  . build (  )  ;", "ServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "new    ( handlerMap )  . handle ( request ,    response )  ;", "return   response ;", "}", "METHOD_END"], "methodName": ["testHandle"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ContextPathCompositeHandler ( Collections . singletonMap ( contextPath ,    new    . TestHttpHandler (  )  )  )  ;", "fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertEquals ( expectedError ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInvalid"], "fileName": "org.springframework.http.server.reactive.ContextPathCompositeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  (  \" http :  /  / localhost :  \"     +     ( port )  )  )  ;", "String   header    =     \" SID =  3  1 d 4 d 9  6 e 4  0  7 aad 4  2  ;    lang = en - US \"  ;", "ResponseEntity < Void >    response    =    new   RestTemplate (  )  . exchange ( RequestEntity . get ( url )  . header (  \"  \"  ,    header )  . build (  )  ,    Void . class )  ;", "Map < String ,    List < Http >  >    requests    =    this . cookieHandler . requests ;", "assertEquals (  2  ,    requests . size (  )  )  ;", "List < Http >    list    =    requests . get (  \" SID \"  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals (  \"  3  1 d 4 d 9  6 e 4  0  7 aad 4  2  \"  ,    list . iterator (  )  . next (  )  . getValue (  )  )  ;", "list    =    requests . get (  \" lang \"  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals (  \" en - US \"  ,    list . iterator (  )  . next (  )  . getValue (  )  )  ;", "List < String >    headerValues    =    response . getHeaders (  )  . get (  \" Set -  \"  )  ;", "assertEquals (  2  ,    headerValues . size (  )  )  ;", "assertThat ( split ( headerValues . get (  0  )  )  ,    containsInAnyOrder ( equalTo (  \" SID =  3  1 d 4 d 9  6 e 4  0  7 aad 4  2  \"  )  ,    equalToIgnoringCase (  \" Path =  /  \"  )  ,    equalToIgnoringCase (  \" Secure \"  )  ,    equalToIgnoringCase (  \" HttpOnly \"  )  )  )  ;", "assertThat ( split ( headerValues . get (  1  )  )  ,    containsInAnyOrder ( equalTo (  \" lang = en - US \"  )  ,    equalToIgnoringCase (  \" Path =  /  \"  )  ,    equalToIgnoringCase (  \" Domain = example . com \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["basicTest"], "fileName": "org.springframework.http.server.reactive.CookieIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "for    ( String   s    :    value . split (  \"  ;  \"  )  )     {", "list . add ( s . trim (  )  )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["splitCookie"], "fileName": "org.springframework.http.server.reactive.CookieIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "source . forEach (  (    key ,    value )     -  >    target . put ( key ,    new   LinkedList <  >  ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["copyMultiValueMap"], "fileName": "org.springframework.http.server.reactive.DefaultServerHttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . uriPath )     =  =    null )     {", "return   this . uri ;", "}", "String   uri    =    new   String (  )  ;", "if    (  ( this . uri . getScheme (  )  )     !  =    null )     {", "uri . append ( this . uri . getScheme (  )  )  . append (  '  :  '  )  ;", "}", "if    (  (  ( this . uri . getRawUserInfo (  )  )     !  =    null )     |  |     (  ( this . uri . getHost (  )  )     !  =    null )  )     {", "uri . append (  \"  /  /  \"  )  ;", "if    (  ( this . uri . getRawUserInfo (  )  )     !  =    null )     {", "uri . append ( this . uri . getRawUserInfo (  )  )  . append (  '  @  '  )  ;", "}", "if    (  ( this . uri . getHost (  )  )     !  =    null )     {", "uri . append ( this . uri . getHost (  )  )  ;", "}", "if    (  ( this . uri . getPort (  )  )     !  =     (  -  1  )  )     {", "uri . append (  '  :  '  )  . append ( this . uri . getPort (  )  )  ;", "}", "}", "if    ( StringUtils . hasLength ( this . uriPath )  )     {", "uri . append ( this . uriPath )  ;", "}", "if    (  ( this . uri . getRawQuery (  )  )     !  =    null )     {", "uri . append (  '  ?  '  )  . append ( this . uri . getRawQuery (  )  )  ;", "}", "if    (  ( this . uri . getRawFragment (  )  )     !  =    null )     {", "uri . append (  '  #  '  )  . append ( this . uri . getRawFragment (  )  )  ;", "}", "try    {", "return   new   URI ( uri . toString (  )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Invalid   URI   path :     \\  \"  \"     +     ( this . uriPath )  )     +     \"  \\  \"  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getUriToUse"], "fileName": "org.springframework.http.server.reactive.DefaultServerHttpRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "Certificate [  ]    certificates ;", "try    {", "certificates    =    session . getPeerCertificates (  )  ;", "}    catch    ( Throwable   ex )     {", "return   null ;", "}", "List < X 5  0  9 Certificate >    res    =    new   ArrayList <  >  ( certificates . length )  ;", "for    ( Certificate   certificate    :    certificates )     {", "if    ( certificate   instanceof   X 5  0  9 Certificate )     {", "res . add (  (  ( X 5  0  9 Certificate )     ( certificate )  )  )  ;", "}", "}", "return    !  ( res . isEmpty (  )  )     ?    res . toArray ( new   X 5  0  9 Certificate [  0  ]  )     :    null ;", "}", "METHOD_END"], "methodName": ["initCertificates"], "fileName": "org.springframework.http.server.reactive.DefaultSslInfo"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    session . getId (  )  ;", "if    ( bytes    =  =    null )     {", "return   null ;", "}", "StBuilder   sb    =    new   StBuilder (  )  ;", "for    ( byte   b    :    bytes )     {", "St   digit    =    Integer . toHexSt ( b )  ;", "if    (  ( digit . length (  )  )     <     2  )     {", "sb . append (  '  0  '  )  ;", "}", "if    (  ( digit . length (  )  )     >     2  )     {", "digit    =    digit . subst (  (  ( digit . length (  )  )     -     2  )  )  ;", "}", "sb . append ( digit )  ;", "}", "return   sb . toSt (  )  ;", "}", "METHOD_END"], "methodName": ["initSessionId"], "fileName": "org.springframework.http.server.reactive.DefaultSslInfo"}, {"methodBody": ["METHOD_START", "{", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "byte [  ]    body    =    randomBytes (  )  ;", "RequestEntity < byte [  ]  >    request    =    RequestEntity . post ( new   URI (  (  \"  :  /  / localhost :  \"     +     ( port )  )  )  )  . body ( body )  ;", "ResponseEntity < byte [  ]  >    response    =    restTemplate . exchange ( request ,    byte [  ]  . class )  ;", "assertArrayEquals ( body ,    response . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["echo"], "fileName": "org.springframework.http.server.reactive.EchoHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buffer    =    new   byte [ EchoHandlerIntegrationTests . REQUEST _ SIZE ]  ;", "rnd . nextBytes ( buffer )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["randomBytes"], "fileName": "org.springframework.http.server.reactive.EchoHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "restTemplate . setErrorHandler (  . NO _ OP _ ERROR _ HANDLER )  ;", "URI   url    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  /  /  \"  )  )  ;", "ResponseEntity < String >    response    =    restTemplate . getForEntity ( url ,    String . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyPathSegments"], "fileName": "org.springframework.http.server.reactive.ErrorHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assumeFalse (  (  ( server )    instanceof   ReactorHttpServer )  )  ;", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "restTemplate . setErrorHandler (  . NO _ OP _ ERROR _ HANDLER )  ;", "URI   url    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / handling - error \"  )  )  ;", "ResponseEntity < String >    response    =    restTemplate . getForEntity ( url ,    String . class )  ;", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["handlingError"], "fileName": "org.springframework.http.server.reactive.ErrorHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assumeFalse (  (  ( server )    instanceof   ReactorHttpServer )  )  ;", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "restTemplate . setErrorHandler (  . NO _ OP _ ERROR _ HANDLER )  ;", "URI   url    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / response - body - error \"  )  )  ;", "ResponseEntity < String >    response    =    restTemplate . getForEntity ( url ,    String . class )  ;", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["responseBodyError"], "fileName": "org.springframework.http.server.reactive.ErrorHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Subscriber < DataBuffer >    subscriber    =    mock ( Subscriber . class )  ;", "doAnswer ( new    . SubscriptionAnswer (  )  )  . when ( subscriber )  . onSubscribe ( isA ( Subscription . class )  )  ;", ". TestListenerReadPublisher   publisher    =    new    . TestListenerReadPublisher (  )  ;", "publisher . subscribe ( subscriber )  ;", "publisher . onDataAvailable (  )  ;", "assertTrue (  (  ( publisher . getReadCalls (  )  )     =  =     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveTwoRequestCallsWhenOnSubscribe"], "fileName": "org.springframework.http.server.reactive.ListenerReadPublisherTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   fooHeaders    =    new   HttpHeaders (  )  ;", "fooHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "ClassPathResource   fooResource    =    new   ClassPathResource (  \" http / codec / multipart / foo . txt \"  )  ;", "HttpEntity < ClassPathResource >    fooPart    =    new   HttpEntity ( fooResource ,    fooHeaders )  ;", "HttpEntity < String >    barPart    =    new   HttpEntity <  >  (  \" bar \"  )  ;", "MultiValueMap < String ,    Object >    parts    =    new   util . LinkedMultiValueMap (  )  ;", "parts . add (  \" fooPart \"  ,    fooPart )  ;", "parts . add (  \" barPart \"  ,    barPart )  ;", "return   parts ;", "}", "METHOD_END"], "methodName": ["generateBody"], "fileName": "org.springframework.http.server.reactive.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "RequestEntity < ValueMap < String ,    Object >  >    request    =    RequestEntity . post ( new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / form - parts \"  )  )  )  . contentType ( MediaType . MULTIPART _ FORM _ DATA )  . body ( generateBody (  )  )  ;", "ResponseEntity < Void >    response    =    restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFormParts"], "fileName": "org.springframework.http.server.reactive.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "byte [  ]    body    =    randomBytes (  )  ;", "RequestEntity < byte [  ]  >    request    =    RequestEntity . post ( new   URI (  (  \" http :  /  / localhost :  \"     +     ( port )  )  )  )  . body ( body )  ;", "ResponseEntity < byte [  ]  >    response    =    restTemplate . exchange ( request ,    byte [  ]  . class )  ;", "assertNotNull ( response . getBody (  )  )  ;", "assertEquals (  . RESPONSE _ SIZE ,    response . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals (  . RESPONSE _ SIZE ,    response . getBody (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["random"], "fileName": "org.springframework.http.server.reactive.RandomHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buffer    =    new   byte [ RandomHandlerIntegrationTests . REQUEST _ SIZE ]  ;", "rnd . nextBytes ( buffer )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["randomBytes"], "fileName": "org.springframework.http.server.reactive.RandomHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ChannelPipeline   pipeline    =    request . context (  )  . channel (  )  . pipeline (  )  ;", "boolean   ssl    =     ( pipeline . get ( SslHandler . class )  )     !  =    null ;", "return   ssl    ?     \" https \"     :     \" http \"  ;", "}", "METHOD_END"], "methodName": ["getScheme"], "fileName": "org.springframework.http.server.reactive.ReactorServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "for    ( String   name    :    channel . rHeaders (  )  . names (  )  )     {", "headers . put ( name ,    channel . rHeaders (  )  . getAll ( name )  )  ;", "}", "return   headers ;", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.http.server.reactive.ReactorServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "SslHandler   sslHandler    =    this . request . context (  )  . channel (  )  . pipeline (  )  . get ( SslHandler . class )  ;", "if    ( sslHandler    !  =    null )     {", "SSLSession   session    =    sslHandler . engine (  )  . getSession (  )  ;", "return   new   DefaultSslInfo ( session )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["initSslInfo"], "fileName": "org.springframework.http.server.reactive.ReactorServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" HttpServerRequest   must   not   be   null \"  )  ;", "return   new   URI (  (  (  . resolveBaseUrl ( request )  . toString (  )  )     +     (  . resolveRequestUri ( request )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["initUri"], "fileName": "org.springframework.http.server.reactive.ReactorServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "String   scheme    =    ReactorServerHttpRequest . getScheme ( request )  ;", "String   header    =    request . requestHeaders (  )  . get ( HOST )  ;", "if    ( header    !  =    null )     {", "final   int   portIndex ;", "if    ( header . startsWith (  \"  [  \"  )  )     {", "portIndex    =    header . indexOf (  '  :  '  ,    header . indexOf (  '  ]  '  )  )  ;", "} else    {", "portIndex    =    header . indexOf (  '  :  '  )  ;", "}", "if    ( portIndex    !  =     (  -  1  )  )     {", "try    {", "return   new   URI ( scheme ,    null ,    header . substring (  0  ,    portIndex )  ,    Integer . parseInt ( header . substring (  ( portIndex    +     1  )  )  )  ,    null ,    null ,    null )  ;", "}    catch    ( NumberFormatException   ex )     {", "throw   new   URISyntaxException ( header ,     \" Unable   to   parse   port \"  ,    portIndex )  ;", "}", "} else    {", "return   new   URI ( scheme ,    header ,    null ,    null )  ;", "}", "} else    {", "InetSocketAddress   localAddress    =     (  ( InetSocketAddress )     ( request . context (  )  . channel (  )  . localAddress (  )  )  )  ;", "return   new   URI ( scheme ,    null ,    localAddress . getHostString (  )  ,    localAddress . getPort (  )  ,    null ,    null ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveBaseUrl"], "fileName": "org.springframework.http.server.reactive.ReactorServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "String   uri    =    request . uri (  )  ;", "for    ( int   i    =     0  ;    i    <     ( uri . length (  )  )  ;    i +  +  )     {", "char   c    =    uri . charAt ( i )  ;", "if    (  (  ( c    =  =     '  /  '  )     |  |     ( c    =  =     '  ?  '  )  )     |  |     ( c    =  =     '  #  '  )  )     {", "break ;", "}", "if    (  ( c    =  =     '  :  '  )     &  &     (  ( i    +     2  )     <     ( uri . length (  )  )  )  )     {", "if    (  (  ( uri . charAt (  ( i    +     1  )  )  )     =  =     '  /  '  )     &  &     (  ( uri . charAt (  ( i    +     2  )  )  )     =  =     '  /  '  )  )     {", "for    ( int   j    =    i    +     3  ;    j    <     ( uri . length (  )  )  ;    j +  +  )     {", "c    =    uri . charAt ( j )  ;", "if    (  (  ( c    =  =     '  /  '  )     |  |     ( c    =  =     '  ?  '  )  )     |  |     ( c    =  =     '  #  '  )  )     {", "return   uri . substring ( j )  ;", "}", "}", "return    \"  \"  ;", "}", "}", "}", "return   uri ;", "}", "METHOD_END"], "methodName": ["resolveRequestUri"], "fileName": "org.springframework.http.server.reactive.ReactorServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   Flux . from ( dataBuffers )  . map ( NettyDataBufferFactory :  : toByteBuf )  ;", "}", "METHOD_END"], "methodName": ["toByteBufs"], "fileName": "org.springframework.http.server.reactive.ReactorServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getRemoteAddress"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getSslInfo"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServerHttpRequestBuilder ( this )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestDecorator"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / foo ? param = bar \"  )  )  ;", "Entity < Void >    request    =    Entity . post ( url )  . build (  )  ;", "ResponseEntity < Void >    response    =    new   RestTemplate (  )  . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkUri"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MockHttpServletRequest (  \" GET \"  ,    path )     {", "@ Override", "public   ServletInputStream   getInputStream (  )     {", "return   new   DelegatingServletInputStream ( new   ByteArrayInputStream ( new   byte [  0  ]  )  )     {", "@ Override", "public   void   setReadListener ( ReadListener   readListener )     {", "}", "}  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createEmptyBodyHttpServletRequest"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    createEmptyBodyHttpServletRequest ( path )  ;", "AsyncContext   asyncContext    =    new   MockAsyncContext ( request ,    new   MockHttpServletResponse (  )  )  ;", "return   new   Servlet ( request ,    asyncContext ,     \"  \"  ,    new   DefaultDataBufferFactory (  )  ,     1  0  2  4  )  ;", "}", "METHOD_END"], "methodName": ["createHttpRequest"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    createHttpRequest (  \"  / path ? name =  % E 6  %  8  9  %  8 E % E 6  % A 0  % B 9  \"  )  . mutate (  )  . path (  \"  / mutatedPath \"  )  . build (  )  ;", "assertEquals (  \"  / mutatedPath \"  ,    request . getURI (  )  . getRawPath (  )  )  ;", "assertEquals (  \" name =  % E 6  %  8  9  %  8 E % E 6  % A 0  % B 9  \"  ,    request . getURI (  )  . getRawQuery (  )  )  ;", "}", "METHOD_END"], "methodName": ["mutatePathWithEncodedQueryParams"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    createHttpRequest (  \"  / path ? a = A & b = B \"  )  . getQueryParams (  )  ;", "assertEquals (  2  ,    params . size (  )  )  ;", "assertEquals ( Collections . singletonList (  \" A \"  )  ,    params . get (  \" a \"  )  )  ;", "assertEquals ( Collections . singletonList (  \" B \"  )  ,    params . get (  \" b \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParams"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    createHttpRequest (  \"  / path \"  )  . getQueryParams (  )  ;", "assertEquals (  0  ,    params . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamsNone"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    createHttpRequest (  \"  / path ? a =  \"  )  . getQueryParams (  )  ;", "assertEquals (  1  ,    params . size (  )  )  ;", "assertEquals ( Collections . singletonList (  \"  \"  )  ,    params . get (  \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamsWithEmptyValue"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    createHttpRequest (  \"  / path ? a =  %  2  0  %  2 B +  % C 3  % A 0  \"  )  . getQueryParams (  )  ;", "assertEquals (  1  ,    params . size (  )  )  ;", "assertEquals ( Collections . singletonList (  \"     +     \\ u 0  0 e 0  \"  )  ,    params . get (  \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamsWithEncodedValue"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    createHttpRequest (  \"  / path ? a =  1  & a =  2  \"  )  . getQueryParams (  )  ;", "assertEquals (  1  ,    params . size (  )  )  ;", "assertEquals ( Arrays . asList (  \"  1  \"  ,     \"  2  \"  )  ,    params . get (  \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamsWithMulitpleValues"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    createHttpRequest (  \"  / path ? a \"  )  . getQueryParams (  )  ;", "assertEquals (  1  ,    params . size (  )  )  ;", "assertEquals ( Collections . singletonList ( null )  ,    params . get (  \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamsWithNoValue"], "fileName": "org.springframework.http.server.reactive.ServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.http.server.reactive.ServerHttpResponseDecorator"}, {"methodBody": ["METHOD_START", "{", "ResponseCookie   cookie    =    ResponseCookie . from (  \" ID \"  ,     \"  1  2  3  \"  )  . build (  )  ;", ". TestServerHttpResponse   response    =    new    . TestServerHttpResponse (  )  ;", "response . beforeCommit (  (  )     -  >     {", "response . getCookies (  )  . add ( cookie . getName (  )  ,    cookie )  ;", "return   Mono . empty (  )  ;", "}  )  ;", "response . setComplete (  )  . block (  )  ;", "TestCase . assertTrue ( response . statusCodeWritten )  ;", "TestCase . assertTrue ( response . headersWritten )  ;", "TestCase . assertTrue ( response . cookiesWritten )  ;", "TestCase . assertTrue ( response . body . isEmpty (  )  )  ;", "assertSame ( cookie ,    response . getCookies (  )  . getFirst (  \" ID \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beforeCommitActionWithSetComplete"], "fileName": "org.springframework.http.server.reactive.ServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "ResponseCookie   cookie    =    ResponseCookie . from (  \" ID \"  ,     \"  1  2  3  \"  )  . build (  )  ;", ". TestServerHttpResponse   response    =    new    . TestServerHttpResponse (  )  ;", "response . beforeCommit (  (  )     -  >    Mono . fromRunnable (  (  )     -  >    response . getCookies (  )  . add ( cookie . getName (  )  ,    cookie )  )  )  ;", "response . writeWith ( Flux . just ( wrap (  \" a \"  )  ,    wrap (  \" b \"  )  ,    wrap (  \" c \"  )  )  )  . block (  )  ;", "TestCase . assertTrue ( response . statusCodeWritten )  ;", "TestCase . assertTrue ( response . headersWritten )  ;", "TestCase . assertTrue ( response . cookiesWritten )  ;", "assertSame ( cookie ,    response . getCookies (  )  . getFirst (  \" ID \"  )  )  ;", "assertEquals (  3  ,    response . body . size (  )  )  ;", "assertEquals (  \" a \"  ,    new   String ( response . body . get (  0  )  . asByteBuffer (  )  . array (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  \" b \"  ,    new   String ( response . body . get (  1  )  . asByteBuffer (  )  . array (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  \" c \"  ,    new   String ( response . body . get (  2  )  . asByteBuffer (  )  . array (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["beforeCommitWithComplete"], "fileName": "org.springframework.http.server.reactive.ServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpResponseTests . TestServerHttpResponse   response    =    new   ServerHttpResponseTests . TestServerHttpResponse (  )  ;", "response . setComplete (  )  . block (  )  ;", "TestCase . assertTrue ( response . statusCodeWritten )  ;", "TestCase . assertTrue ( response . headersWritten )  ;", "TestCase . assertTrue ( response . cookiesWritten )  ;", "TestCase . assertTrue ( response . body . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["setComplete"], "fileName": "org.springframework.http.server.reactive.ServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDataBufferFactory (  )  . wrap ( ByteBuffer . wrap ( a . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.springframework.http.server.reactive.ServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpResponseTests . TestServerHttpResponse   response    =    new   ServerHttpResponseTests . TestServerHttpResponse (  )  ;", "Flux < Flux < DefaultDataBuffer >  >    flux    =    Flux . just ( Flux . just ( wrap (  \" foo \"  )  )  )  ;", "response . writeAndFlushWith ( flux )  . block (  )  ;", "TestCase . assertTrue ( response . statusCodeWritten )  ;", "TestCase . assertTrue ( response . headersWritten )  ;", "TestCase . assertTrue ( response . cookiesWritten )  ;", "assertEquals (  1  ,    response . body . size (  )  )  ;", "assertEquals (  \" foo \"  ,    new   String ( response . body . get (  0  )  . asByteBuffer (  )  . array (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["writeAndFlushWithFluxOfDefaultDataBuffer"], "fileName": "org.springframework.http.server.reactive.ServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpResponseTests . TestServerHttpResponse   response    =    new   ServerHttpResponseTests . TestServerHttpResponse (  )  ;", "response . writeWith ( Flux . just ( wrap (  \" a \"  )  ,    wrap (  \" b \"  )  ,    wrap (  \" c \"  )  )  )  . block (  )  ;", "TestCase . assertTrue ( response . statusCodeWritten )  ;", "TestCase . assertTrue ( response . headersWritten )  ;", "TestCase . assertTrue ( response . cookiesWritten )  ;", "assertEquals (  3  ,    response . body . size (  )  )  ;", "assertEquals (  \" a \"  ,    new   String ( response . body . get (  0  )  . asByteBuffer (  )  . array (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  \" b \"  ,    new   String ( response . body . get (  1  )  . asByteBuffer (  )  . array (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  \" c \"  ,    new   String ( response . body . get (  2  )  . asByteBuffer (  )  . array (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["writeWith"], "fileName": "org.springframework.http.server.reactive.ServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpResponseTests . TestServerHttpResponse   response    =    new   ServerHttpResponseTests . TestServerHttpResponse (  )  ;", "IllegalStateException   error    =    new   IllegalStateException (  \" boo \"  )  ;", "response . writeWith ( Flux . error ( error )  )  . onErrorResume (  (    ex )     -  >    Mono . empty (  )  )  . block (  )  ;", "assertFalse ( response . statusCodeWritten )  ;", "assertFalse ( response . headersWritten )  ;", "assertFalse ( response . cookiesWritten )  ;", "TestCase . assertTrue ( response . body . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeWithError"], "fileName": "org.springframework.http.server.reactive.ServerHttpResponseTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  [  ]  {    new   Object [  ]  {    new   ReactorHttpsServer (  )     }     }  ;", "}", "METHOD_END"], "methodName": ["arguments"], "fileName": "org.springframework.http.server.reactive.ServerHttpsRequestIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  (  (  \" https :  /  / localhost :  \"     +     ( port )  )     +     \"  / foo ? param = bar \"  )  )  ;", "Entity < Void >    request    =    Entity . post ( url )  . build (  )  ;", "ResponseEntity < Void >    response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkUri"], "fileName": "org.springframework.http.server.reactive.ServerHttpsRequestIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . server . setHandler ( new   ServerHttpsRequestIntegrationTests . CheckRequestHandler (  )  )  ;", "this . server . afterPropertiesSet (  )  ;", "this . server . start (  )  ;", "this . port    =    this . server . getPort (  )  ;", "SSLContextBuilder   builder    =    new   SSLContextBuilder (  )  ;", "builder . loadTrustMaterial ( new   TrustSelfSignedStrategy (  )  )  ;", "SSLConnectionSocketFactory   socketFactory    =    new   SSLConnectionSocketFactory ( builder . build (  )  ,    NoopHostnameVerifier . INSTANCE )  ;", "CloseableHttpClient   httpclient    =    HttpClients . custom (  )  . setSSLSocketFactory ( socketFactory )  . build (  )  ;", "HttpComponentsClientHttpRequestFactory   requestFactory    =    new   HttpComponentsClientHttpRequestFactory ( httpclient )  ;", "this . restTemplate    =    new   RestTemplate ( requestFactory )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.http.server.reactive.ServerHttpsRequestIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . server . stop (  )  ;", "this . port    =     0  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.http.server.reactive.ServerHttpsRequestIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . servletPath ,     \" Servlet   path   is   not   initialized \"  )  ;", "return   new   ServletServerHttpRequest ( request ,    context ,    this . servletPath ,    getDataBufferFactory (  )  ,    getBufferSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["createRequest"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   ServletServerHttpResponse ( response ,    context ,    getDataBufferFactory (  )  ,    getBufferSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["createResponse"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . bufferSize ;", "}", "METHOD_END"], "methodName": ["getBufferSize"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . dataBufferFactory ;", "}", "METHOD_END"], "methodName": ["getDataBufferFactory"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . servletPath ;", "}", "METHOD_END"], "methodName": ["getServletPath"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "String   name    =    config . getServletName (  )  ;", "ServletRegistration   registration    =    config . getServletContext (  )  . getServletRegistration ( name )  ;", "if    ( registration    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" ServletRegistration   not   found   for   Servlet    '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "Collection < String >    mappings    =    registration . getMappings (  )  ;", "if    (  ( mappings . size (  )  )     =  =     1  )     {", "String   mapping    =    mappings . iterator (  )  . next (  )  ;", "if    ( mapping . equals (  \"  /  \"  )  )     {", "return    \"  \"  ;", "}", "if    ( mapping . endsWith (  \"  /  *  \"  )  )     {", "String   path    =    mapping . substring (  0  ,     (  ( mapping . length (  )  )     -     2  )  )  ;", "if    (  !  ( path . isEmpty (  )  )  )     {", ". logger . info (  (  (  (  (  \" Found   Servlet   mapping    '  \"     +    path )     +     \"  '    for   Servlet    '  \"  )     +    name )     +     \"  '  \"  )  )  ;", "}", "return   path ;", "}", "}", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Expected   a   single   Servlet   mapping :     \"     +     (  (  \" either   the   default   Servlet   mapping    ( i . e .     '  /  '  )  ,     \"     +     \" or   a   path   based   mapping    ( e . g .     '  /  *  '  ,     '  / foo /  *  '  )  .     \"  )     +     \" Actual   mappings :     \"  )  )     +    mappings )     +     \"    for   Servlet    '  \"  )     +    name )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getServletPath"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( asyncContext . getRequest (  )  . isAsyncStarted (  )  )     &  &     ( isComped . compareAndSet ( false ,    true )  )  )     {", "task . run (  )  ;", "}", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["runIfAsyncNotComplete"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( bufferSize    >     0  )  ,     \" Buffer   size   must   be   larger   than   zero \"  )  ;", "this . bufferSize    =    bufferSize ;", "}", "METHOD_END"], "methodName": ["setBufferSize"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( dataBufferFactory ,     \" DataBufferFactory   must   not   be   null \"  )  ;", "this . dataBufferFactory    =    dataBufferFactory ;", "}", "METHOD_END"], "methodName": ["setDataBufferFactory"], "fileName": "org.springframework.http.server.reactive.ServletHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "for    ( Enumeration <  ?  >    names    =    request . getHeaderNames (  )  ;    names . hasMoreElements (  )  ;  )     {", "String   name    =     (  ( String )     ( names . nextElement (  )  )  )  ;", "for    ( Enumeration <  ?  >    values    =    request . getHeaders ( name )  ;    values . hasMoreElements (  )  ;  )     {", "headers . add ( name ,     (  ( String )     ( values . nextElement (  )  )  )  )  ;", "}", "}", "MediaType   contentType    =    headers . getContentType (  )  ;", "if    ( contentType    =  =    null )     {", "String   requestContentType    =    request . getContentType (  )  ;", "if    ( StringUtils . hasLength ( requestContentType )  )     {", "contentType    =    MediaType . parseMediaType ( requestContentType )  ;", "headers . setContentType ( contentType )  ;", "}", "}", "if    (  ( contentType    !  =    null )     &  &     (  ( contentType . getCharset (  )  )     =  =    null )  )     {", "String   encoding    =    request . getCharacterEncoding (  )  ;", "if    ( StringUtils . hasLength ( encoding )  )     {", "Charset   charset    =    Charset . forName ( encoding )  ;", "Map < String ,    String >    params    =    new   util . LinkedCaseInsensitiveMap (  )  ;", "params . putAll ( contentType . getParameters (  )  )  ;", "params . put (  \" charset \"  ,    charset . toString (  )  )  ;", "headers . setContentType ( new   MediaType ( contentType . getType (  )  ,    contentType . getSubtype (  )  ,    params )  )  ;", "}", "}", "if    (  ( headers . getContentLength (  )  )     =  =     (  -  1  )  )     {", "int   contentLength    =    request . getContentLength (  )  ;", "if    ( contentLength    !  =     (  -  1  )  )     {", "headers . setContentLength ( contentLength )  ;", "}", "}", "return   headers ;", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.http.server.reactive.ServletServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . request . isSecure (  )  )  )     {", "return   null ;", "}", "return   new   DefaultSslInfo (  (  ( String )     ( request . getAttribute (  . SSL _ SESSION _ ID _ ATTRIBUTE )  )  )  ,     (  ( X 5  0  9 Certificate [  ]  )     ( request . getAttribute (  . X 5  0  9  _ CERTIFICATE _ ATTRIBUTE )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["initSslInfo"], "fileName": "org.springframework.http.server.reactive.ServletServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \"  ' request '    must   not   be   null \"  )  ;", "try    {", "StringBuffer   url    =    request . getURL (  )  ;", "String   query    =    request . getQueryString (  )  ;", "if    ( StringUtils . hasText ( query )  )     {", "url . append (  '  ?  '  )  . append ( query )  ;", "}", "return   new   URI ( url . toString (  )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "throw   new   IllegalStateException (  (  \" Could   not   get   URI :     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["initUri"], "fileName": "org.springframework.http.server.reactive.ServletServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "int   read    =    this . request . getInputStream (  )  . read ( this . buffer )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" InputStream   read   returned    \"     +    read )     +     ( read    !  =     (  -  1  )     ?     \"    bytes \"     :     \"  \"  )  )  )  ;", "}", "if    ( read    >     0  )     {", "DataBuffer   dataBuffer    =    this . bufferFactory . allocateBuffer ( read )  ;", "dataBuffer . write ( this . buffer ,     0  ,    read )  ;", "return   dataBuffer ;", "}", "if    ( read    =  =     (  -  1  )  )     {", "return    . EOF _ BUFFER ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["readFromInputStream"], "fileName": "org.springframework.http.server.reactive.ServletServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "ServletOutputStream   outputStream    =    this . outputStream ;", "if    ( outputStream . isReady (  )  )     {", "try    {", "outputStream . flush (  )  ;", "this . flushOnNext    =    false ;", "}    catch    ( IOException   ex )     {", "this . flushOnNext    =    true ;", "throw   ex ;", "}", "} else    {", "this . flushOnNext    =    true ;", "}", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.springframework.http.server.reactive.ServletServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . outputStream . isReady (  )  ;", "}", "METHOD_END"], "methodName": ["isWritePossible"], "fileName": "org.springframework.http.server.reactive.ServletServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "ServletOutputStream   outputStream    =    this . outputStream ;", "InputStream   input    =    dataBuffer . asInputStream (  )  ;", "int   bytesWritten    =     0  ;", "byte [  ]    buffer    =    new   byte [ this . bufferSize ]  ;", "int   bytesRead ;", "while    (  ( outputStream . isReady (  )  )     &  &     (  ( bytesRead    =    input . read ( buffer )  )     !  =     (  -  1  )  )  )     {", "outputStream . write ( buffer ,     0  ,    bytesRead )  ;", "bytesWritten    +  =    bytesRead ;", "}", "return   bytesWritten ;", "}", "METHOD_END"], "methodName": ["writeToOutputStream"], "fileName": "org.springframework.http.server.reactive.ServletServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . bufferFactory ;", "}", "METHOD_END"], "methodName": ["getDataBufferFactory"], "fileName": "org.springframework.http.server.reactive.UndertowHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bufferFactory ,     \" DataBufferFactory   must   not   be   null \"  )  ;", "this . bufferFactory    =    bufferFactory ;", "}", "METHOD_END"], "methodName": ["setDataBufferFactory"], "fileName": "org.springframework.http.server.reactive.UndertowHttpHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "for    ( HeaderValues   values    :    exchange . getHeaders (  )  )     {", "headers . put ( values . getHeaderName (  )  . toString (  )  ,    values )  ;", "}", "return   headers ;", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.http.server.reactive.UndertowServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( exchange ,     \" HttpServerExchange   is   required .  \"  )  ;", "String   requestURL    =    exchange . getURL (  )  ;", "String   query    =    exchange . getQueryString (  )  ;", "String   requestUriAndQuery    =     ( StringUtils . isEmpty ( query )  )     ?    requestURL    :     ( requestURL    +     \"  ?  \"  )     +    query ;", "return   URI . create ( requestUriAndQuery )  ;", "}", "METHOD_END"], "methodName": ["initUri"], "fileName": "org.springframework.http.server.reactive.UndertowServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . responseChannel )     =  =    null )     {", "this . responseChannel    =    this . exchange . getResponseChannel (  )  ;", "}", "return   new    . ResponseBodyProcessor ( this . responseChannel )  ;", "}", "METHOD_END"], "methodName": ["createBodyProcessor"], "fileName": "org.springframework.http.server.reactive.UndertowServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buffer    =    new   byte [ WriteOnlyHandlerIntegrationTests . REQUEST _ SIZE ]  ;", "rnd . nextBytes ( buffer )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["randomBytes"], "fileName": "org.springframework.http.server.reactive.WriteOnlyHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "this . body    =    randomBytes (  )  ;", "RequestEntity < byte [  ]  >    request    =    RequestEntity . post ( new   URI (  (  \"  :  /  / localhost :  \"     +     ( port )  )  )  )  . body (  \"  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "ResponseEntity < byte [  ]  >    response    =    restTemplate . exchange ( request ,    byte [  ]  . class )  ;", "assertArrayEquals ( body ,    response . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeOnly"], "fileName": "org.springframework.http.server.reactive.WriteOnlyHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . state . compareAndSet ( oldState ,    newState )  ;", "}", "METHOD_END"], "methodName": ["changeState"], "fileName": "org.springframework.http.server.reactive.WriteResultPublisher"}, {"methodBody": ["METHOD_START", "{", "if    ( WriteResultPublisher . logger . isTraceEnabled (  )  )     {", "WriteResultPublisher . logger . trace (  (  ( this . state )     +     \"    publishComplete \"  )  )  ;", "}", "this . state . get (  )  . publishComplete ( this )  ;", "}", "METHOD_END"], "methodName": ["publishComplete"], "fileName": "org.springframework.http.server.reactive.WriteResultPublisher"}, {"methodBody": ["METHOD_START", "{", "if    ( WriteResultPublisher . logger . isTraceEnabled (  )  )     {", "WriteResultPublisher . logger . trace (  (  (  ( this . state )     +     \"    publishError :     \"  )     +    t )  )  ;", "}", "this . state . get (  )  . publishError ( this ,    t )  ;", "}", "METHOD_END"], "methodName": ["publishError"], "fileName": "org.springframework.http.server.reactive.WriteResultPublisher"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  (  ( server )    instanceof   ReactorHttpServer )     |  |     (  ( server )    instanceof   UndertowHttpServer )  )  )  ;", "URI   url    =    new   URI (  (  \" http :  /  / localhost :  \"     +     ( port )  )  )  ;", "RequestEntity <  ?  >    request    =    RequestEntity . get ( url )  . build (  )  ;", "ResponseEntity < byte [  ]  >    response    =    new   RestTemplate (  )  . exchange ( request ,    byte [  ]  . class )  ;", "Resource   logo    =    new   ClassPathResource (  \" spring . png \"  ,     . class )  ;", "assertTrue ( response . hasBody (  )  )  ;", "assertEquals ( logo . contentLength (  )  ,    response . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals ( logo . contentLength (  )  ,    response . getBody (  )  . length )  ;", "assertEquals ( MediaType . IMAGE _ PNG ,    response . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["zeroCopy"], "fileName": "org.springframework.http.server.reactive.ZeroCopyIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.springframework.http.server.reactive.bootstrap.AbstractHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   this . httpHandler ;", "}", "METHOD_END"], "methodName": ["getHttpHandler"], "fileName": "org.springframework.http.server.reactive.bootstrap.AbstractHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   this . handlerMap ;", "}", "METHOD_END"], "methodName": ["getHttpHandlerMap"], "fileName": "org.springframework.http.server.reactive.bootstrap.AbstractHttpServer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . handlerM    =  =    null )     {", "this . handlerM =    new   LinkedHashM >  (  )  ;", "}", "this . handlerMput ( contextPath ,    handler )  ;", "}", "METHOD_END"], "methodName": ["registerHttpHandler"], "fileName": "org.springframework.http.server.reactive.bootstrap.AbstractHttpServer"}, {"methodBody": ["METHOD_START", "{", "this . host    =     \"  0  .  0  .  0  .  0  \"  ;", "this . port    =     0  ;", "thisHandler    =    null ;", "this . handlerMap    =    null ;", "resetInternal (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.http.server.reactive.bootstrap.AbstractHttpServer"}, {"methodBody": ["METHOD_START", "{", "return    ( getHttpHandlerMap (  )  )     !  =    null    ?    new   ContextPathCompositeHandler ( getHttpHandlerMap (  )  )     :    getHttpHandler (  )  ;", "}", "METHOD_END"], "methodName": ["resolveHttpHandler"], "fileName": "org.springframework.http.server.reactive.bootstrap.AbstractHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   JettyHttpHandlerAdapter ( resolveHttpHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["createServletAdapter"], "fileName": "org.springframework.http.server.reactive.bootstrap.JettyHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactorHttpHandlerAdapter ( resolveHttpHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["createHttpHandlerAdapter"], "fileName": "org.springframework.http.server.reactive.bootstrap.ReactorHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactorHttpHandlerAdapter ( resolveHttpHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["createHttpHandlerAdapter"], "fileName": "org.springframework.http.server.reactive.bootstrap.ReactorHttpsServer"}, {"methodBody": ["METHOD_START", "{", "return   new   TomcatHttpHandlerAdapter ( resolveHttpHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["initServletAdapter"], "fileName": "org.springframework.http.server.reactive.bootstrap.TomcatHttpServer"}, {"methodBody": ["METHOD_START", "{", "this . contextPath    =    contextPath ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.springframework.http.server.reactive.bootstrap.TomcatHttpServer"}, {"methodBody": ["METHOD_START", "{", "this . servletMapping    =    servletMapping ;", "}", "METHOD_END"], "methodName": ["setServletMapping"], "fileName": "org.springframework.http.server.reactive.bootstrap.TomcatHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   UndertowHttpHandlerAdapter ( resolveHttpHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["initHttpHandlerAdapter"], "fileName": "org.springframework.http.server.reactive.bootstrap.UndertowHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return    (    body )     -  >     {", "this . body    =    body . cache (  )  ;", "return   this . body . then (  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["initDefaultWriteHandler"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( writeHandler ,     \"  ' writeHandler '    is   required \"  )  ;", "this . writeHandler    =    writeHandler ;", "}", "METHOD_END"], "methodName": ["setWriteHandler"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( charset ,     \"  ' charset '    must   not   be   null \"  )  ;", "byte [  ]    bytes    =    new   byte [ bufferdableByteCount (  )  ]  ;", "bufferd ( bytes )  ;", "return   new   String ( bytes ,    charset )  ;", "}", "METHOD_END"], "methodName": ["dumpString"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    getCharset (  )  ;", "return   Flux . from ( getBody (  )  )  . reduce ( bufferFactory . allocateBuffer (  )  ,     (    previous ,    current )     -  >     {", "previous . write ( current )  ;", "DataBufferUtils . release ( current )  ;", "return   previous ;", "}  )  . map (  (    buffer )     -  >    dumpSt ( buffer ,    charset )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsString"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    null ;", "MediaType   contType    =    getHeaders (  )  . getContType (  )  ;", "if    ( contType    !  =    null )     {", "charset    =    contType . getCharset (  )  ;", "}", "return   charset    !  =    null    ?    charset    :    StandardCharsets . UTF _  8  ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "setBody ( body ,    StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["setBody"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    toDataBuffer ( body ,    charset )  ;", "this . body    =    Flux . just ( buffer )  ;", "}", "METHOD_END"], "methodName": ["setBody"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "this . body    =    Flux . from ( body )  ;", "}", "METHOD_END"], "methodName": ["setBody"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    body . getBytes ( charset )  ;", "ByteBuffer   byteBuffer    =    ByteBuffer . wrap ( bytes )  ;", "return   this . bufferFactory . wrap ( byteBuffer )  ;", "}", "METHOD_END"], "methodName": ["toDataBuffer"], "fileName": "org.springframework.mock.http.client.reactive.test.MockClientHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HttpMethod . DELETE ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HttpMethod . GET ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HttpMethod . HEAD ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["head"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    UriComponentsBuilder . fromUriString ( urlTemplate )  . buildAndExpand ( vars )  . encode (  )  . toUri (  )  ;", "return   new    . DefaultBodyBuilder ( method ,    url )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   new   MockServerHttpRequest . DefaultBodyBuilder ( method ,    url )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HttpMethod . OPTIONS ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["options"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HttpMethod . PATCH ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["patch"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HttpMethod . POST ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["post"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( HttpMethod . PUT ,    urlTemplate ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( charset ,     \"  ' charset '    must   not   be   null \"  )  ;", "byte [  ]    bytes    =    new   byte [ buffdableByteCount (  )  ]  ;", "buffd ( bytes )  ;", "return   new   String ( bytes ,    charset )  ;", "}", "METHOD_END"], "methodName": ["bufferToString"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    Optional . ofNullable ( getHeaders (  )  . getContentType (  )  )  . map ( MimeType :  : getCharset )  . orElse ( StandardCharsets . UTF _  8  )  ;", "return   getBody (  )  . reduce ( bufferFactory (  )  . allocateBuffer (  )  ,     (    previous ,    current )     -  >     {", "previous . write ( current )  ;", "DataBufferUtils . release ( current )  ;", "return   previous ;", "}  )  . map (  (    buffer )     -  >    bufferToSt ( buffer ,    charset )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyAsString"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( writeHandler ,     \"  ' writeHandler '    is   required \"  )  ;", "this . body    =    Flux . error ( new   IllegalStateException (  \" Not   available   with   custom   write   handler .  \"  )  )  ;", "this . writeHandler    =    writeHandler ;", "}", "METHOD_END"], "methodName": ["setWriteHandler"], "fileName": "org.springframework.mock.http.server.reactive.test.MockServerHttpResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . sourceStream ;", "}", "METHOD_END"], "methodName": ["getSourceStream"], "fileName": "org.springframework.mock.web.test.DelegatingServletInputStream"}, {"methodBody": ["METHOD_START", "{", "return   this . targetStream ;", "}", "METHOD_END"], "methodName": ["getTargetStream"], "fileName": "org.springframework.mock.web.test.DelegatingServletOutputStream"}, {"methodBody": ["METHOD_START", "{", "this . values . add ( value )  ;", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "CollectionUtils . mergeArrayIntoCollection ( values ,    this . values )  ;", "}", "METHOD_END"], "methodName": ["addValueArray"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "this . values . addAll ( values )  ;", "}", "METHOD_END"], "methodName": ["addValues"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Header   name   must   not   be   null \"  )  ;", "for    ( String   headerName    :    headers . keySet (  )  )     {", "if    ( headerName . equalsIgnoreCase ( name )  )     {", "return   headers . get ( headerName )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getByName"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . values . isEmpty (  )  )     ?    String . valueOf ( this . values . get (  0  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getStringValue"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "List < String >    stringList    =    new   ArrayList <  >  ( this . values . size (  )  )  ;", "for    ( Object   value    :    this . values )     {", "stringList . add ( value . toString (  )  )  ;", "}", "return   Collections . unmodifiableList ( stringList )  ;", "}", "METHOD_END"], "methodName": ["getStringValues"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . values . isEmpty (  )  )     ?    this . values . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . values )  ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "this . values . clear (  )  ;", "if    ( value    !  =    null )     {", "this . values . add ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.springframework.mock.web.test.HeaderValueHolder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( handler ,     \" Dispatch   handler   must   not   be   null \"  )  ;", "hronized ( this )     {", "if    (  ( this . dispatchedPath )     =  =    null )     {", "this . dispatchHandlers . add ( handler )  ;", "} else    {", "handler . run (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addDispatchHandler"], "fileName": "org.springframework.mock.web.test.MockAsyncContext"}, {"methodBody": ["METHOD_START", "{", "return   this . dispatchedPath ;", "}", "METHOD_END"], "methodName": ["getDispatchedPath"], "fileName": "org.springframework.mock.web.test.MockAsyncContext"}, {"methodBody": ["METHOD_START", "{", "return   this . listeners ;", "}", "METHOD_END"], "methodName": ["getListeners"], "fileName": "org.springframework.mock.web.test.MockAsyncContext"}, {"methodBody": ["METHOD_START", "{", "if    ( targetWriter   instanceof   JspWriter )     {", "return    (  ( JspWriter )     ( targetWriter )  )  ;", "} else    {", "return   new   JspWriter ( response ,    targetWriter )  ;", "}", "}", "METHOD_END"], "methodName": ["adaptJspWriter"], "fileName": "org.springframework.mock.web.test.MockBodyContent"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Manager . evaluate (  \" JSP   EL   expression \"  ,    expression ,    expectedType ,    this . pageContext )  ;", "}    catch    ( JspException   ex )     {", "throw   new   ELException (  (  (  \" Parsing   of   JSP   EL   expression    \\  \"  \"     +    expression )     +     \"  \\  \"    failed \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doEvaluate"], "fileName": "org.springframework.mock.web.test.MockExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   this . request ;", "}", "METHOD_END"], "methodName": ["getRequest"], "fileName": "org.springframework.mock.web.test.MockFilterChain"}, {"methodBody": ["METHOD_START", "{", "return   this . response ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.springframework.mock.web.test.MockFilterChain"}, {"methodBody": ["METHOD_START", "{", "Filter [  ]    allFilters    =    ObjectUtils . addObjectToArray ( filters ,    new   MockFilterChain . ServletFilterProxy ( servlet )  )  ;", "return   Arrays . asList ( allFilters )  ;", "}", "METHOD_END"], "methodName": ["initFilterList"], "fileName": "org.springframework.mock.web.test.MockFilterChain"}, {"methodBody": ["METHOD_START", "{", "this . request    =    null ;", "this . response    =    null ;", "this . iterator    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.mock.web.test.MockFilterChain"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . initParameters . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addInitParameter"], "fileName": "org.springframework.mock.web.test.MockFilterConfig"}, {"methodBody": ["METHOD_START", "{", "if    (  ( HttpHeaders . CONTENT _ TYPE . equalsIgnoreCase ( name )  )     &  &     (  !  ( this . headers . containsKey ( HttpHeaders . CONTENT _ TYPE )  )  )  )     {", "setContentType ( value . toString (  )  )  ;", "} else", "if    (  ( HttpHeaders . ACCEPT _ LANGUAGE . equalsIgnoreCase ( name )  )     &  &     (  !  ( this . headers . containsKey ( HttpHeaders . ACCEPT _ LANGUAGE )  )  )  )     {", "try    {", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . add ( HttpHeaders . ACCEPT _ LANGUAGE ,    value . toString (  )  )  ;", "setPreferredLocales ( headers . getAcceptLanguageAsLocales (  )  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "doAddHeaderValue ( name ,    value ,    true )  ;", "}", "} else    {", "doAddHeaderValue ( name ,    value ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["addHeader"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "addParameter ( name ,    new   String [  ]  {    value    }  )  ;", "}", "METHOD_END"], "methodName": ["addParameter"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "String [  ]    oldArr    =    this . parameters . get ( name )  ;", "if    ( oldArr    !  =    null )     {", "String [  ]    newArr    =    new   String [  ( oldArr . length )     +     ( values . length )  ]  ;", "System . arraycopy ( oldArr ,     0  ,    newArr ,     0  ,    oldArr . length )  ;", "System . arraycopy ( values ,     0  ,    newArr ,    oldArr . length ,    values . length )  ;", "this . parameters . put ( name ,    newArr )  ;", "} else    {", "this . parameters . put ( name ,    values )  ;", "}", "}", "METHOD_END"], "methodName": ["addParameter"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( params ,     \" Parameter   map   must   not   be   null \"  )  ;", "for    ( String   key    :    params . keySet (  )  )     {", "Object   value    =    params . get ( key )  ;", "if    ( value   instanceof   String )     {", "addParameter ( key ,     (  ( String )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   String [  ]  )     {", "addParameter ( key ,     (  ( String [  ]  )     ( value )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  \" Parameter   map   value   must   be   single   value    \"     +     \"    or   array   of   type    [  \"  )     +     ( String . class . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addParameters"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . parts . add ( part . getName (  )  ,    part )  ;", "}", "METHOD_END"], "methodName": ["addPart"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( locale ,     \" Locale   must   not   be   null \"  )  ;", "this . locales . add (  0  ,    locale )  ;", "updateAcceptLanguageHeader (  )  ;", "}", "METHOD_END"], "methodName": ["addPreferredLocale"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . userRoles . add ( role )  ;", "}", "METHOD_END"], "methodName": ["addUserRole"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( this . session )     !  =    null )  ,     \" The   request   does   not   have   a   session \"  )  ;", "if    (  ( this . session )    instanceof   ssion )     {", "return    (  ( ssion )     ( session )  )  . changeSessionId (  )  ;", "}", "return   this . session . getId (  )  ;", "}", "METHOD_END"], "methodName": ["changeSessionId"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( this . active ,     \" Request   is   not   active   anymore \"  )  ;", "}", "METHOD_END"], "methodName": ["checkActive"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . attributes . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearAttributes"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . active    =    false ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "HeaderValueHolder   header    =    HeaderValueHolder . getByName ( this . headers ,    name )  ;", "Assert . notNull ( value ,     \" Header   value   must   not   be   null \"  )  ;", "if    (  ( header    =  =    null )     |  |    replace )     {", "header    =    new   HeaderValueHolder (  )  ;", "this . headers . put ( name ,    header )  ;", "}", "if    ( value   instanceof   Collection )     {", "header . addValues (  (  ( Collection <  ?  >  )     ( value )  )  )  ;", "} else", "if    ( value . getClass (  )  . isArray (  )  )     {", "header . addValueArray ( value )  ;", "} else    {", "header . addValue ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["doAddHeaderValue"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . content ;", "}", "METHOD_END"], "methodName": ["getContentAsByteArray"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . characterEncoding )     !  =    null )  ,     (  \" Cannot   get   content   as   a   String   for   a   null   character   encoding .     \"     +     \" Consider   setting   the   characterEncoding   in   the   request .  \"  )  )  ;", "if    (  ( this . content )     =  =    null )     {", "return   null ;", "}", "return   new   String ( this . content ,    this . characterEncoding )  ;", "}", "METHOD_END"], "methodName": ["getContentAsString"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "close (  )  ;", "clearAttribu (  )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . active ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "for    ( String   dateFormat    :    MockHttpServletRequest . DATE _ FORMATS )     {", "SimpleDateFormat   simpleDateFormat    =    new   SimpleDateFormat ( dateFormat ,    Locale . US )  ;", "simpleDateFormat . setTimeZone ( MockHttpServletRequest . GMT )  ;", "try    {", "return   simpleDateFormat . parse ( value )  . getTime (  )  ;", "}    catch    ( ParseException   ex )     {", "}", "}", "throw   new   IllegalArgumentException (  (  (  (  (  \" Cannot   parse   date   value    '  \"     +    value )     +     \"  '    for    '  \"  )     +    name )     +     \"  '    header \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseDateHeader"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . parameters . clear (  )  ;", "}", "METHOD_END"], "methodName": ["removeAllParameters"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . parameters . remove ( name )  ;", "}", "METHOD_END"], "methodName": ["removeParameter"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . asyncContext    =    asyncContext ;", "}", "METHOD_END"], "methodName": ["setAsyncContext"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . asyncStarted    =    asyncStarted ;", "}", "METHOD_END"], "methodName": ["setAsyncStarted"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . asyncSupported    =    asyncSupported ;", "}", "METHOD_END"], "methodName": ["setAsyncSupported"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . authType    =    authType ;", "}", "METHOD_END"], "methodName": ["setAuthType"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . content    =    content ;", "}", "METHOD_END"], "methodName": ["setContent"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . contentType    =    contentType ;", "if    ( contentType    !  =    null )     {", "try    {", "MediaType   mediaType    =    MediaType . parseMediaType ( contentType )  ;", "if    (  ( mediaType . getCharset (  )  )     !  =    null )     {", "this . characterEncoding    =    mediaType . getCharset (  )  . name (  )  ;", "}", "}    catch    ( IllegalArgumentException   ex )     {", "int   charsetIndex    =    contentType . toLowerCase (  )  . indexOf (  . CHARSET _ PREFIX )  ;", "if    ( charsetIndex    !  =     (  -  1  )  )     {", "this . characterEncoding    =    contentType . substring (  ( charsetIndex    +     (  . CHARSET _ PREFIX . length (  )  )  )  )  ;", "}", "}", "updateContentTypeHeader (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . contextPath    =    contextPath ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . cookies    =     ( ObjectUtils . isEmpty ( cookies )  )     ?    null    :    cookies ;", "this . headers . remove ( Headers . COOKIE )  ;", "if    (  ( this . cookies )     !  =    null )     {", "Arrays . stream ( this . cookies )  . map (  (    c )     -  >     (  ( c . getName (  )  )     +     '  =  '  )     +     (  ( c . getValue (  )  )     =  =    null    ?     \"  \"     :    c . getValue (  )  )  )  . forEach (  (    value )     -  >    doAddHeaderValue ( Headers . COOKIE ,    value ,    false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setCookies"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . dispatcherType    =    dispatcherType ;", "}", "METHOD_END"], "methodName": ["setDispatcherType"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . localAddr    =    localAddr ;", "}", "METHOD_END"], "methodName": ["setLocalAddr"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . localName    =    localName ;", "}", "METHOD_END"], "methodName": ["setLocalName"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . localPort    =    localPort ;", "}", "METHOD_END"], "methodName": ["setLocalPort"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . method    =    method ;", "}", "METHOD_END"], "methodName": ["setMethod"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "setParameter ( name ,    new   String [  ]  {    value    }  )  ;", "}", "METHOD_END"], "methodName": ["setParameter"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . parameters . put ( name ,    values )  ;", "}", "METHOD_END"], "methodName": ["setParameter"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( params ,     \" Parameter   map   must   not   be   null \"  )  ;", "for    ( String   key    :    params . keySet (  )  )     {", "Object   value    =    params . get ( key )  ;", "if    ( value   instanceof   String )     {", "setParameter ( key ,     (  ( String )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   String [  ]  )     {", "setParameter ( key ,     (  ( String [  ]  )     ( value )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  \" Parameter   map   value   must   be   single   value    \"     +     \"    or   array   of   type    [  \"  )     +     ( String . class . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setParameters"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . pathInfo    =    pathInfo ;", "}", "METHOD_END"], "methodName": ["setPathInfo"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( locales ,     \" Locale   list   must   not   be   empty \"  )  ;", "this . locales . clear (  )  ;", "this . locales . addAll ( locales )  ;", "updateAcceptLanguageHeader (  )  ;", "}", "METHOD_END"], "methodName": ["setPreferredLocales"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . protocol    =    protocol ;", "}", "METHOD_END"], "methodName": ["setProtocol"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . queryString    =    queryString ;", "}", "METHOD_END"], "methodName": ["setQueryString"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . remoteAddr    =    remoteAddr ;", "}", "METHOD_END"], "methodName": ["setRemoteAddr"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . remoteHost    =    remoteHost ;", "}", "METHOD_END"], "methodName": ["setRemoteHost"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . remotePort    =    remotePort ;", "}", "METHOD_END"], "methodName": ["setRemotePort"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . remoteUser    =    remoteUser ;", "}", "METHOD_END"], "methodName": ["setRemoteUser"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestURI    =    requestURI ;", "}", "METHOD_END"], "methodName": ["setRequestURI"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestedSessionId    =    requestedSessionId ;", "}", "METHOD_END"], "methodName": ["setRequestedSessionId"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestedSessionIdFromCookie    =    requestedSessionIdFromCookie ;", "}", "METHOD_END"], "methodName": ["setRequestedSessionIdFromCookie"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestedSessionIdFromURL    =    requestedSessionIdFromURL ;", "}", "METHOD_END"], "methodName": ["setRequestedSessionIdFromURL"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . requestedSessionIdValid    =    requestedSessionIdValid ;", "}", "METHOD_END"], "methodName": ["setRequestedSessionIdValid"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . scheme    =    scheme ;", "}", "METHOD_END"], "methodName": ["setScheme"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . secure    =    secure ;", "}", "METHOD_END"], "methodName": ["setSecure"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . serverName    =    serverName ;", "}", "METHOD_END"], "methodName": ["setServerName"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . serverPort    =    serverPort ;", "}", "METHOD_END"], "methodName": ["setServerPort"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . servletPath    =    servletPath ;", "}", "METHOD_END"], "methodName": ["setServletPath"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . session    =    session ;", "if    ( session   instanceof   ssion )     {", "ssion   mockSession    =     (  ( ssion )     ( session )  )  ;", "mockSession . access (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setSession"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . userPrincipal    =    userPrincipal ;", "}", "METHOD_END"], "methodName": ["setUserPrincipal"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setAcceptLanguageAsLocales ( this . locales )  ;", "doAddHeaderValue ( HttpHeaders . ACCEPT _ LANGUAGE ,    headers . getFirst ( HttpHeaders . ACCEPT _ LANGUAGE )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["updateAcceptLanguageHeader"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasLength ( this . contentType )  )     {", "StringBuilder   sb    =    new   StringBuilder ( this . contentType )  ;", "if    (  (  !  ( this . contentType . toLowerCase (  )  . contains (  . CHARSET _ PREFIX )  )  )     &  &     ( StringUtils . hasLength ( this . characterEncoding )  )  )     {", "sb . append (  \"  ;  \"  )  . append (  . CHARSET _ PREFIX )  . append ( this . characterEncoding )  ;", "}", "doAddHeaderValue ( HttpHeaders . CONTENT _ TYPE ,    sb . toString (  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["updateContentTypeHeader"], "fileName": "org.springframework.mock.web.test.MockHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "if    ( setSpecialHeader ( name ,    value )  )     {", "return ;", "}", "doAddHeaderValue ( name ,    value ,    false )  ;", "}", "METHOD_END"], "methodName": ["addHeaderValue"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( includedUrl ,     \" Included   URL   must   not   be   null \"  )  ;", "this . includedUrls . add ( includedUrl )  ;", "}", "METHOD_END"], "methodName": ["addIncludedUrl"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "HeaderValueHolder   header    =    HeaderValueHolder . getByName ( this . headers ,    name )  ;", "Assert . notNull ( value ,     \" Header   value   must   not   be   null \"  )  ;", "if    ( header    =  =    null )     {", "header    =    new   HeaderValueHolder (  )  ;", "this . headers . put ( name ,    header )  ;", "}", "if    ( replace )     {", "header . setValue ( value )  ;", "} else    {", "header . addValue ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["doAddHeaderValue"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   newDateFormat (  )  . format ( new   Date ( date )  )  ;", "}", "METHOD_END"], "methodName": ["formatDate"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . content . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsByteArray"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return    ( this . characterEncoding )     !  =    null    ?    this . content . toString ( this . characterEncoding )     :    this . content . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsString"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( this . contentLength )  )  ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . contentLength ;", "}", "METHOD_END"], "methodName": ["getContentLengthLong"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Cookie   name   must   not   be   null \"  )  ;", "for    ( Cookie   cookie    :    this . cookies )     {", "if    ( name . equals ( cookie . getName (  )  )  )     {", "return   cookie ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCookie"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "buf . append ( cookie . getName (  )  )  . append (  '  =  '  )  . append (  (  ( cookie . getValue (  )  )     =  =    null    ?     \"  \"     :    cookie . getValue (  )  )  )  ;", "if    ( StringUtils . hasText ( cookie . getPath (  )  )  )     {", "buf . append (  \"  ;    Path =  \"  )  . append ( cookie . getPath (  )  )  ;", "}", "if    ( StringUtils . hasText ( cookie . getDomain (  )  )  )     {", "buf . append (  \"  ;    Domain =  \"  )  . append ( cookie . getDomain (  )  )  ;", "}", "int   maxAge    =    cookie . getMaxAge (  )  ;", "if    ( maxAge    >  =     0  )     {", "buf . append (  \"  ;    Max - Age =  \"  )  . append ( maxAge )  ;", "buf . append (  \"  ;    Expires =  \"  )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setExpires (  ( maxAge    >     0     ?     ( System . currentTimeMillis (  )  )     +     (  1  0  0  0 L    *    maxAge )     :     0  )  )  ;", "buf . append ( headers . getFirst ( HttpHeaders . EXPIRES )  )  ;", "}", "if    ( cookie . getSecure (  )  )     {", "buf . append (  \"  ;    Secure \"  )  ;", "}", "if    ( cookie . isHttpOnly (  )  )     {", "buf . append (  \"  ;    HttpOnly \"  )  ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getCookieHeader"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . cookies . toArray ( new   Cookie [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getCookies"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "String   headerValue    =    getHeader ( name )  ;", "if    ( headerValue    =  =    null )     {", "return    -  1  ;", "}", "try    {", "return   newDateFormat (  )  . parse ( getHeader ( name )  )  . getTime (  )  ;", "}    catch    ( ParseException   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Value   for   header    '  \"     +    name )     +     \"  '    is   not   a   valid   Date :     \"  )     +    headerValue )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDateHeader"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . errorMessage ;", "}", "METHOD_END"], "methodName": ["getErrorMessage"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . forwardedUrl ;", "}", "METHOD_END"], "methodName": ["getForwardedUrl"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "HeaderValueHolder   header    =    HeaderValueHolder . getByName ( this . headers ,    name )  ;", "return   header    !  =    null    ?    header . getValue (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getHeaderValue"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "HeaderValueHolder   header    =    HeaderValueHolder . getByName ( this . headers ,    name )  ;", "if    ( header    !  =    null )     {", "return   header . getValues (  )  ;", "} else    {", "return   Collections . emptyList (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getHeaderValues"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "int   count    =    this . includedUrls . size (  )  ;", "Assert . state (  ( count    <  =     1  )  ,     (  )     -  >     \" More   than    1    URL   included    -    check   getIncludedUrls   instead :     \"     +     ( this . includedUrls )  )  ;", "return   count    =  =     1     ?    this . includedUrls . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getIncludedUrl"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . includedUrls ;", "}", "METHOD_END"], "methodName": ["getIncludedUrls"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   getHeader ( HttpHeaders . LOCATION )  ;", "}", "METHOD_END"], "methodName": ["getRedirectedUrl"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . charset ;", "}", "METHOD_END"], "methodName": ["isCharset"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . outputStreamAccessAllowed ;", "}", "METHOD_END"], "methodName": ["isOutputStreamAccessAllowed"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . writerAccessAllowed ;", "}", "METHOD_END"], "methodName": ["isWriterAccessAllowed"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "SimpleDateFormat   dateFormat    =    new   SimpleDateFormat ( MockHttpServletResponse . DATE _ FORMAT ,    Locale . US )  ;", "dateFormat . setTimeZone ( MockHttpServletResponse . GMT )  ;", "return   dateFormat ;", "}", "METHOD_END"], "methodName": ["newDateFormat"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . committed    =    committed ;", "}", "METHOD_END"], "methodName": ["setCommitted"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "int   bufSize    =    getBufferSize (  )  ;", "if    (  ( bufSize    >     0  )     &  &     (  ( this . content . size (  )  )     >    bufSize )  )     {", "setCommitted ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["setCommittedIfBufferSizeExceeded"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . forwardedUrl    =    forwardedUrl ;", "}", "METHOD_END"], "methodName": ["setForwardedUrl"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "if    ( setSpecialHeader ( name ,    value )  )     {", "return ;", "}", "doAddHeaderValue ( name ,    value ,    true )  ;", "}", "METHOD_END"], "methodName": ["setHeaderValue"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . includedUrls . clear (  )  ;", "if    ( includedUrl    !  =    null )     {", "this . includedUrls . add ( includedUrl )  ;", "}", "}", "METHOD_END"], "methodName": ["setIncludedUrl"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . outputStreamAccessAllowed    =    outputStreamAccessAllowed ;", "}", "METHOD_END"], "methodName": ["setOutputStreamAccessAllowed"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "if    ( HttpHeaders . CONTENT _ TYPE . equalsIgnoreCase ( name )  )     {", "setContentType ( value . toString (  )  )  ;", "return   true ;", "} else", "if    ( HttpHeaders . CONTENT _ LENGTH . equalsIgnoreCase ( name )  )     {", "setContentLength (  ( value   instanceof   Number    ?     (  ( Number )     ( value )  )  . intValue (  )     :    Integer . parseInt ( value . toString (  )  )  )  )  ;", "return   true ;", "} else", "if    ( HttpHeaders . CONTENT _ LANGUAGE . equalsIgnoreCase ( name )  )     {", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . add ( HttpHeaders . CONTENT _ LANGUAGE ,    value . toString (  )  )  ;", "Locale   language    =    headers . getContentLanguage (  )  ;", "this . locale    =     ( language    !  =    null )     ?    language    :    getDefault (  )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["setSpecialHeader"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . writerAccessAllowed    =    writerAccessAllowed ;", "}", "METHOD_END"], "methodName": ["setWriterAccessAllowed"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . contentType )     !  =    null )     {", "StringBuilder   sb    =    new   StringBuilder ( this . contentType )  ;", "if    (  (  !  ( this . contentType . toLowerCase (  )  . contains (  . CHARSET _ PREFIX )  )  )     &  &     ( this . charset )  )     {", "sb . append (  \"  ;  \"  )  . append (  . CHARSET _ PREFIX )  . append ( this . characterEncoding )  ;", "}", "doAddHeaderValue ( HttpHeaders . CONTENT _ TYPE ,    sb . toString (  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["updateContentTypeHeader"], "fileName": "org.springframework.mock.web.test.MockHttpServletResponse"}, {"methodBody": ["METHOD_START", "{", "this . lastAccessedTime    =    System . currentTimeMillis (  )  ;", "this . isNew    =    false ;", "}", "METHOD_END"], "methodName": ["access"], "fileName": "org.springframework.mock.web.test.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  !  ( isInvalid (  )  )  )  ,     \" The   session   has   already   been   invalidated \"  )  ;", "}", "METHOD_END"], "methodName": ["assertIsValid"], "fileName": "org.springframework.mock.web.test.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "this . id    =    Integer . toString (  (  ( MockHttpSession . nextId )  +  +  )  )  ;", "return   this . id ;", "}", "METHOD_END"], "methodName": ["changeSessionId"], "fileName": "org.springframework.mock.web.test.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator < Map . Entry < String ,    Object >  >    it    =    this . attributes . entrySet (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Map . Entry < String ,    Object >    entry    =    it . next (  )  ;", "String   name    =    entry . getKey (  )  ;", "Object   value    =    entry . getValue (  )  ;", "it . remove (  )  ;", "if    ( value   instanceof   BindingListener )     {", "(  ( BindingListener )     ( value )  )  . valueUnbound ( new   BindingEvent ( this ,    name ,    value )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["clearAttributes"], "fileName": "org.springframework.mock.web.test.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( state   instanceof   Map )  ,     \" Serialized   state   needs   to   be   of   type    [ Map ]  \"  )  ;", "this . attributes . putAll (  (  ( Map < St ,    Object >  )     ( state )  )  )  ;", "}", "METHOD_END"], "methodName": ["deserializeState"], "fileName": "org.springframework.mock.web.test.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "return   this . invalid ;", "}", "METHOD_END"], "methodName": ["isInvalid"], "fileName": "org.springframework.mock.web.test.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "HashMap < String ,    Serializable >    state    =    new   HashMap <  >  (  )  ;", "for    ( Iterator < Map . Entry < String ,    Object >  >    it    =    this . attributes . entrySet (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Map . Entry < String ,    Object >    entry    =    it . next (  )  ;", "String   name    =    entry . getKey (  )  ;", "Object   value    =    entry . getValue (  )  ;", "it . remove (  )  ;", "if    ( value   instanceof   Serializable )     {", "state . put ( name ,     (  ( Serializable )     ( value )  )  )  ;", "} else    {", "if    ( value   instanceof   BindingListener )     {", "(  ( BindingListener )     ( value )  )  . valueUnbound ( new   BindingEvent ( this ,    name ,    value )  )  ;", "}", "}", "}", "return   state ;", "}", "METHOD_END"], "methodName": ["serializeState"], "fileName": "org.springframework.mock.web.test.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "this . isNew    =    value ;", "}", "METHOD_END"], "methodName": ["setNew"], "fileName": "org.springframework.mock.web.test.MockHttpSession"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . targetWriter )     =  =    null )     {", "this . targetWriter    =    this . response . getWriter (  )  ;", "}", "return   this . targetWriter ;", "}", "METHOD_END"], "methodName": ["getTargetWriter"], "fileName": "org.springframework.mock.web.test.MockJspWriter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( file ,     \" MultipartFile   must   not   be   null \"  )  ;", "this . multipartFiles . add ( file . getName (  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["addFile"], "fileName": "org.springframework.mock.web.test.MockMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "return   Collections . enumeration ( new   LinkedHashSet <  >  ( this . attributes . keySet (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNames"], "fileName": "org.springframework.mock.web.test.MockPageContext"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . response )    instanceof   MockHttpServletResponse )  ,     \" MockHttpServletResponse   required \"  )  ;", "return    (  ( MockHttpServletResponse )     ( this . response )  )  . getntAsByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsByteArray"], "fileName": "org.springframework.mock.web.test.MockPageContext"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . response )    instanceof   MockHttpServletResponse )  ,     \" MockHttpServletResponse   required \"  )  ;", "return    (  ( MockHttpServletResponse )     ( this . response )  )  . getntAsString (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsString"], "fileName": "org.springframework.mock.web.test.MockPageContext"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.mock.web.test.MockPart"}, {"methodBody": ["METHOD_START", "{", "if    ( response   instanceof   MockHttpServletResponse )     {", "return    (  ( MockHttpServletResponse )     ( response )  )  ;", "}", "if    ( response   instanceof   HttpServletResponseWrapper )     {", "return   getMockHttpServletResponse (  (  ( HttpServletResponseWrapper )     ( response )  )  . getResponse (  )  )  ;", "}", "throw   new   IllegalArgumentException (  \"    requires   MockHttpServletResponse \"  )  ;", "}", "METHOD_END"], "methodName": ["getMockHttpServletResponse"], "fileName": "org.springframework.mock.web.test.MockRequestDispatcher"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . initParameters . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addInitParameter"], "fileName": "org.springframework.mock.web.test.MockServletConfig"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . initParameters . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addInitParameter"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["addJspFile"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( fileExtension ,     \"  ' fileExtension '    must   not   be   null \"  )  ;", "this . mimeTypes . put ( fileExtension ,    mimeType )  ;", "}", "METHOD_END"], "methodName": ["addMimeType"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . declaredRoles )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredRoles"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultServletName ;", "}", "METHOD_END"], "methodName": ["getDefaultServletName"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "return   this . requestCharacterEncoding ;", "}", "METHOD_END"], "methodName": ["getRequestCharacterEncoding"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( path . startsWith (  \"  /  \"  )  )  )     {", "path    =     \"  /  \"     +    path ;", "}", "return    ( this . resourceBasePath )     +    path ;", "}", "METHOD_END"], "methodName": ["getResourceLocation"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "return   this . responseCharacterEncoding ;", "}", "METHOD_END"], "methodName": ["getResponseCharacterEncoding"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionTimeout ;", "}", "METHOD_END"], "methodName": ["getSessionTimeout"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . contexts . put ( contextPath ,    context )  ;", "}", "METHOD_END"], "methodName": ["registerContext"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" RequestDispatcher   name   must   not   be   null \"  )  ;", "Assert . notNull ( requestDispatcher ,     \" RequestDispatcher   must   not   be   null \"  )  ;", "this . namedRequestDispatchers . put ( name ,    requestDispatcher )  ;", "}", "METHOD_END"], "methodName": ["registerNamedDispatcher"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . contextPath    =    contextPath ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( defaultServletName ,     \" defaultServletName   must   not   be   null   or   empty \"  )  ;", "unregisterNamedDispatcher ( this . defaultServletName )  ;", "this . defaultServletName    =    defaultServletName ;", "registerNamedDispatcher ( this . defaultServletName ,    new   MockRequestDispatcher ( this . defaultServletName )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultServletName"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . effectiveMajorVersion    =    effectiveMajorVersion ;", "}", "METHOD_END"], "methodName": ["setEffectiveMajorVersion"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . effectiveMinorVersion    =    effectiveMinorVersion ;", "}", "METHOD_END"], "methodName": ["setEffectiveMinorVersion"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . majorVersion    =    majorVersion ;", "}", "METHOD_END"], "methodName": ["setMajorVersion"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . minorVersion    =    minorVersion ;", "}", "METHOD_END"], "methodName": ["setMinorVersion"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . requestCharacterEncoding    =    requestCharacterEncoding ;", "}", "METHOD_END"], "methodName": ["setRequestCharacterEncoding"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . responseCharacterEncoding    =    responseCharacterEncoding ;", "}", "METHOD_END"], "methodName": ["setResponseCharacterEncoding"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . servletContextName    =    servletContextName ;", "}", "METHOD_END"], "methodName": ["setServletContextName"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "this . sessionTimeout    =    sessionTimeout ;", "}", "METHOD_END"], "methodName": ["setSessionTimeout"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" RequestDispatcher   name   must   not   be   null \"  )  ;", "this . namedRequestDispatchers . remove ( name )  ;", "}", "METHOD_END"], "methodName": ["unregisterNamedDispatcher"], "fileName": "org.springframework.mock.web.test.MockServletContext"}, {"methodBody": ["METHOD_START", "{", "return   new   MockServerWebExchange ( requestBuilder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.mock.web.test.server.MockServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "return   new   MockServerWebExchange ( request )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.mock.web.test.server.MockServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "return   blah _  ;", "}", "METHOD_END"], "methodName": ["getBlah"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   blah _  ;", "}", "METHOD_END"], "methodName": ["getBlahOrBuilder"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   Msg . defaultInstance ;", "}", "METHOD_END"], "methodName": ["getDefaultInstance"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   Msg . defaultInstance ;", "}", "METHOD_END"], "methodName": ["getDefaultInstanceForType"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   OuterSample . internal _ static _ Msg _ descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "Object   ref    =    foo _  ;", "if    ( ref   instanceof   St )     {", "return    (  ( St )     ( ref )  )  ;", "} else    {", "ByteSt   bs    =     (  ( ByteSt )     ( ref )  )  ;", "St   s    =    bs . toStUtf 8  (  )  ;", "if    ( bs . isValidUtf 8  (  )  )     {", "foo _     =    s ;", "}", "return   s ;", "}", "}", "METHOD_END"], "methodName": ["getFoo"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "Object   ref    =    foo _  ;", "if    ( ref   instanceof   String )     {", "ByteString   b    =    com . googleByteString . copyFromUtf 8  (  (  ( String )     ( ref )  )  )  ;", "foo _     =    b ;", "return   b ;", "} else    {", "return    (  ( ByteString )     ( ref )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFooBytes"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "int   size    =    memoizedSerializedSize ;", "if    ( size    !  =     (  -  1  )  )", "return   size ;", "size    =     0  ;", "if    (  (  ( bitField 0  _  )     &     1  )     =  =     1  )     {", "size    +  =    com . googleCodedOutputStream . computeBytesSize (  1  ,    getFooBytes (  )  )  ;", "}", "if    (  (  ( bitField 0  _  )     &     2  )     =  =     2  )     {", "size    +  =    com . googleCodedOutputStream . computeMessageSize (  2  ,    blah _  )  ;", "}", "size    +  =    getUnknownFields (  )  . getSerializedSize (  )  ;", "memoizedSerializedSize    =    size ;", "return   size ;", "}", "METHOD_END"], "methodName": ["getSerializedSize"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return    (  ( bitField 0  _  )     &     2  )     =  =     2  ;", "}", "METHOD_END"], "methodName": ["hasBlah"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return    (  ( bitField 0  _  )     &     1  )     =  =     1  ;", "}", "METHOD_END"], "methodName": ["hasFoo"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "foo _     =     \"  \"  ;", "blah _     =    Second . getDefaultInstance (  )  ;", "}", "METHOD_END"], "methodName": ["initFields"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   OuterSample . internal _ static _ Msg _ fieldAccessorTable . ensureFieldAccessorsInitialized ( Msg . class ,    Msg . Builder . class )  ;", "}", "METHOD_END"], "methodName": ["internalGetFieldAccessorTable"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "byte   isInitialized    =    memoizedIsInitialized ;", "if    ( isInitialized    !  =     (  -  1  )  )", "return   isInitialized    =  =     1  ;", "memoizedIsInitialized    =     1  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isInitialized"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   Msg . Builder . create (  )  ;", "}", "METHOD_END"], "methodName": ["newBuilder"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   Msg . newBuilder (  )  . mergeFrom ( prototype )  ;", "}", "METHOD_END"], "methodName": ["newBuilder"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   Msg . newBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["newBuilderForType"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseDelimitedFrom ( input )  ;", "}", "METHOD_END"], "methodName": ["parseDelimitedFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseDelimitedFrom ( input ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseDelimitedFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( data )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( data ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( data )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( data ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( input )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( input ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( input )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( input ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   Msg . newBuilder ( this )  ;", "}", "METHOD_END"], "methodName": ["toBuilder"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "getSerializedSize (  )  ;", "if    (  (  ( bitField 0  _  )     &     1  )     =  =     1  )     {", "output . writeBytes (  1  ,    getFooBytes (  )  )  ;", "}", "if    (  (  ( bitField 0  _  )     &     2  )     =  =     2  )     {", "output . writeMessage (  2  ,    blah _  )  ;", "}", "getUnknownFields (  )  . writeTo ( output )  ;", "}", "METHOD_END"], "methodName": ["writeTo"], "fileName": "org.springframework.protobuf.Msg"}, {"methodBody": ["METHOD_START", "{", "return   OuterSample . descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.protobuf.OuterSample"}, {"methodBody": ["METHOD_START", "{", "return   blah _  ;", "}", "METHOD_END"], "methodName": ["getBlah"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   SecondMsg . defaultInstance ;", "}", "METHOD_END"], "methodName": ["getDefaultInstance"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   SecondMsg . defaultInstance ;", "}", "METHOD_END"], "methodName": ["getDefaultInstanceForType"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   OuterSample . internal _ static _ SecondMsg _ descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "int   size    =    memoizedSerializedSize ;", "if    ( size    !  =     (  -  1  )  )", "return   size ;", "size    =     0  ;", "if    (  (  ( bitField 0  _  )     &     1  )     =  =     1  )     {", "size    +  =    com . googleCodedOutputStream . computeInt 3  2 Size (  1  ,    blah _  )  ;", "}", "size    +  =    getUnknownFields (  )  . getSerializedSize (  )  ;", "memoizedSerializedSize    =    size ;", "return   size ;", "}", "METHOD_END"], "methodName": ["getSerializedSize"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return    (  ( bitField 0  _  )     &     1  )     =  =     1  ;", "}", "METHOD_END"], "methodName": ["hasBlah"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "blah _     =     0  ;", "}", "METHOD_END"], "methodName": ["initFields"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   OuterSample . internal _ static _ SecondMsg _ fieldAccessorTable . ensureFieldAccessorsInitialized ( SecondMsg . class ,    SecondMsg . Builder . class )  ;", "}", "METHOD_END"], "methodName": ["internalGetFieldAccessorTable"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "byte   isInitialized    =    memoizedIsInitialized ;", "if    ( isInitialized    !  =     (  -  1  )  )", "return   isInitialized    =  =     1  ;", "memoizedIsInitialized    =     1  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["isInitialized"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   SecondMsg . Builder . create (  )  ;", "}", "METHOD_END"], "methodName": ["newBuilder"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   SecondMsg . newBuilder (  )  . mergeFrom ( prototype )  ;", "}", "METHOD_END"], "methodName": ["newBuilder"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   SecondMsg . newBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["newBuilderForType"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseDelimitedFrom ( input )  ;", "}", "METHOD_END"], "methodName": ["parseDelimitedFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseDelimitedFrom ( input ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseDelimitedFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( data )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( data ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( data )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( data ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( input )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( input ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( input )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   PARSER . parseFrom ( input ,    extensionRegistry )  ;", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "return   SecondMsg . newBuilder ( this )  ;", "}", "METHOD_END"], "methodName": ["toBuilder"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "getSerializedSize (  )  ;", "if    (  (  ( bitField 0  _  )     &     1  )     =  =     1  )     {", "output . writeInt 3  2  (  1  ,    blah _  )  ;", "}", "getUnknownFields (  )  . writeTo ( output )  ;", "}", "METHOD_END"], "methodName": ["writeTo"], "fileName": "org.springframework.protobuf.SecondMsg"}, {"methodBody": ["METHOD_START", "{", "HessianProxyFactoryBean   factory    =    new   HessianProxyFactoryBean (  )  ;", "factory . setServiceInterface ( ITestBean . class )  ;", "factory . setServiceUrl (  \" http :  /  / localhosta / testbean \"  )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  \" Correct   singleton   value \"  ,    factory . isSingleton (  )  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   bean    =     (  ( ITestBean )     ( factory . getObject (  )  )  )  ;", "exception . expect ( eAccessException . class )  ;", "bean . setName (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["hessianProxyFactoryBeanWithAccessError"], "fileName": "org.springframework.remoting.caucho.CauchoRemotingTests"}, {"methodBody": ["METHOD_START", "{", "HessianProxyFactoryBean   factory    =    new   HessianProxyFactoryBean (  )  ;", "factory . setServiceInterface ( ITestBean . class )  ;", "factory . setServiceUrl (  \" http :  /  / localhosta / testbean \"  )  ;", "factory . setUsername (  \" test \"  )  ;", "factory . setPassword (  \" bean \"  )  ;", "factory . setOverloadEnabled ( true )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  \" Correct   singleton   value \"  ,    factory . isSingleton (  )  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   bean    =     (  ( ITestBean )     ( factory . getObject (  )  )  )  ;", "exception . expect ( eAccessException . class )  ;", "bean . setName (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["hessianProxyFactoryBeanWithAuthenticationAndAccessError"], "fileName": "org.springframework.remoting.caucho.CauchoRemotingTests"}, {"methodBody": ["METHOD_START", "{", "HessianProxyFactoryBean   factory    =    new   HessianProxyFactoryBean (  )  ;", "exception . expect ( IllegalArgumentException . class )  ;", "factory . setServiceInterface ( Bean . class )  ;", "}", "METHOD_END"], "methodName": ["hessianProxyFactoryBeanWithClassInsteadOfInterface"], "fileName": "org.springframework.remoting.caucho.CauchoRemotingTests"}, {"methodBody": ["METHOD_START", "{", "CauchoRemotingTests . TestHessianProxyFactory   proxyFactory    =    new   CauchoRemotingTests . TestHessianProxyFactory (  )  ;", "HessianProxyFactoryBean   factory    =    new   HessianProxyFactoryBean (  )  ;", "factory . setServiceInterface ( ITestBean . class )  ;", "factory . setServiceUrl (  \" http :  /  / localhosta / testbean \"  )  ;", "factory . setProxyFactory ( proxyFactory )  ;", "factory . setUsername (  \" test \"  )  ;", "factory . setPassword (  \" bean \"  )  ;", "factory . setOverloadEnabled ( true )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  \" Correct   singleton   value \"  ,    factory . isSingleton (  )  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   bean    =     (  ( ITestBean )     ( factory . getObject (  )  )  )  ;", "assertEquals (  \" test \"  ,    proxyFactory . user )  ;", "assertEquals (  \" bean \"  ,    proxyFactory . password )  ;", "assertTrue ( proxyFactory . overloadEnabled )  ;", "exception . expect ( RemoteAccessException . class )  ;", "bean . setName (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["hessianProxyFactoryBeanWithCustomProxyFactory"], "fileName": "org.springframework.remoting.caucho.CauchoRemotingTests"}, {"methodBody": ["METHOD_START", "{", "final   int   port    =    SocketUtils . findAvailableTcpPort (  )  ;", "Bean   tb    =    new   Bean (  \" tb \"  )  ;", "SimpleHessianServiceExporter   exporter    =    new   SimpleHessianServiceExporter (  )  ;", "exporter . setService ( tb )  ;", "exporter . setServiceInterface ( IBean . class )  ;", "exporter . setDebug ( true )  ;", "exporter . prepare (  )  ;", "HttpServer   server    =    HttpServer . create ( new   InetSocketAddress ( port )  ,     (  -  1  )  )  ;", "server . createContext (  \"  / hessian \"  ,    exporter )  ;", "server . start (  )  ;", "try    {", "HessianClientInterceptor   client    =    new   HessianClientInterceptor (  )  ;", "client . setServiceUrl (  (  (  \" http :  /  / localhost :  \"     +    port )     +     \"  / hessian \"  )  )  ;", "client . setServiceInterface ( IBean . class )  ;", "client . prepare (  )  ;", "IBean   proxy    =    ProxyFactory . getProxy ( IBean . class ,    client )  ;", "assertEquals (  \" tb \"  ,    proxy . getName (  )  )  ;", "proxy . setName (  \" test \"  )  ;", "assertEquals (  \" test \"  ,    proxy . getName (  )  )  ;", "}    finally    {", "server . stop ( Integer . MAX _ VALUE )  ;", "}", "}", "METHOD_END"], "methodName": ["simpleHessianServiceExporter"], "fileName": "org.springframework.remoting.caucho.CauchoRemotingTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ex   instanceof   HessianConnectionException )     |  |     ( ex   instanceof   ConnectException )  )     {", "return   new   RemoteConnectFailureException (  (  (  \" Cannot   connect   to   Hessian   remote   service   at    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "} else    {", "return   new   RemoteAccessException (  (  (  \" Cannot   access   Hessian   remote   service   at    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["convertHessianAccessException"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( getServiceInterface (  )  ,     \"  ' serviceInterface '    is   required \"  )  ;", "return   proxyFactory . create ( getServiceInterface (  )  ,    getServiceUrl (  )  ,    getBeanClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["createHessianProxy"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . hessianProxy    =    createHessianProxy ( this . proxyFactory )  ;", "}    catch    ( MalformedURLException   ex )     {", "throw   new   RemoteLookupFailureException (  (  (  \" Service   URL    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]    is   invalid \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . getSerializerFactory (  )  . setAllowNonSerializable ( allowNonSerializable )  ;", "}", "METHOD_END"], "methodName": ["setAllowNonSerializable"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setChunkedPost ( chunkedPost )  ;", "}", "METHOD_END"], "methodName": ["setChunkedPost"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setConnectTimeout ( timeout )  ;", "}", "METHOD_END"], "methodName": ["setConnectTimeout"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setConnectionFactory ( connectionFactory )  ;", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setDebug ( debug )  ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setHessian 2 Request ( hessian 2  )  ;", "this . proxyFactory . setHessian 2 Reply ( hessian 2  )  ;", "}", "METHOD_END"], "methodName": ["setHessian2"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setHessian 2 Reply ( hessian 2  )  ;", "}", "METHOD_END"], "methodName": ["setHessian2Reply"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setHessian 2 Request ( hessian 2  )  ;", "}", "METHOD_END"], "methodName": ["setHessian2Request"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setOverloadEnabled ( overloadEnabled )  ;", "}", "METHOD_END"], "methodName": ["setOverloadEnabled"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setPassword ( password )  ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory    =     ( proxyFactory    !  =    null )     ?    proxyFactory    :    new   HessianProxyFactory (  )  ;", "}", "METHOD_END"], "methodName": ["setProxyFactory"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setReadTimeout ( timeout )  ;", "}", "METHOD_END"], "methodName": ["setReadTimeout"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . getSerializerFactory (  )  . setSendCollectionType ( sendCollectionType )  ;", "}", "METHOD_END"], "methodName": ["setSendCollectionType"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setSerializerFactory ( serializerFactory )  ;", "}", "METHOD_END"], "methodName": ["setSerializerFactory"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . proxyFactory . setUser ( username )  ;", "}", "METHOD_END"], "methodName": ["setUsername"], "fileName": "org.springframework.remoting.caucho.HessianClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   originalClassLoader    =    overrideThreadContextClassLoader (  )  ;", "try    {", "InputStream   isToUse    =    inputStream ;", "OutputStream   osToUse    =    outputStream ;", "if    (  (  ( this . debugLogger )     !  =    null )     &  &     ( this . debugLogger . isDebugEnabled (  )  )  )     {", "try    ( PrintWriter   debugWriter    =    new   PrintWriter ( new   CommonsLogWriter ( this . debugLogger )  )  )     {", "@ SuppressWarnings (  \" resource \"  )", "HessianDebugInputStream   dis    =    new   HessianDebugInputStream ( inputStream ,    debugWriter )  ;", "@ SuppressWarnings (  \" resource \"  )", "HessianDebugOutputStream   dos    =    new   HessianDebugOutputStream ( outputStream ,    debugWriter )  ;", "dis . startTop 2  (  )  ;", "dos . startTop 2  (  )  ;", "isToUse    =    dis ;", "osToUse    =    dos ;", "}", "}", "if    (  !  ( isToUse . markSupported (  )  )  )     {", "isToUse    =    new   BufferedInputStream ( isToUse )  ;", "isToUse . mark (  1  )  ;", "}", "int   code    =    isToUse . read (  )  ;", "int   major ;", "int   minor ;", "AbstractHessianInput   in ;", "AbstractHessianOutput   out ;", "if    ( code    =  =     ' H '  )     {", "major    =    isToUse . read (  )  ;", "minor    =    isToUse . read (  )  ;", "if    ( major    !  =     2  )     {", "throw   new   IOException (  (  (  (  (  \" Version    \"     +    major )     +     '  .  '  )     +    minor )     +     \"    is   not   understood \"  )  )  ;", "}", "in    =    new   Hessian 2 Input ( isToUse )  ;", "out    =    new   Hessian 2 Output ( osToUse )  ;", "in . readCall (  )  ;", "} else", "if    ( code    =  =     ' C '  )     {", "isToUse . reset (  )  ;", "in    =    new   Hessian 2 Input ( isToUse )  ;", "out    =    new   Hessian 2 Output ( osToUse )  ;", "in . readCall (  )  ;", "} else", "if    ( code    =  =     ' c '  )     {", "major    =    isToUse . read (  )  ;", "minor    =    isToUse . read (  )  ;", "in    =    new   com . caucho . hessian . iInput ( isToUse )  ;", "if    ( major    >  =     2  )     {", "out    =    new   Hessian 2 Output ( osToUse )  ;", "} else    {", "out    =    new   com . caucho . hessian . iOutput ( osToUse )  ;", "}", "} else    {", "throw   new   IOException (  (  \" Expected    ' H '  /  ' C '     ( Hessian    2  .  0  )    or    ' c '     ( Hessian    1  .  0  )    in   hessian   input   at    \"     +    code )  )  ;", "}", "in . setSerializerFactory ( this . serializerFactory )  ;", "out . setSerializerFactory ( this . serializerFactory )  ;", "if    (  ( this . remoteResolver )     !  =    null )     {", "in . setRemoteResolver ( this . remoteResolver )  ;", "}", "try    {", "skeleton . invoke ( in ,    out )  ;", "}    finally    {", "try    {", "in . close (  )  ;", "isToUse . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "try    {", "out . close (  )  ;", "osToUse . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}    finally    {", "resetThreadContextClassLoader ( originalClassLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.remoting.caucho.HessianExporter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . skeleton ,     \" Hessian   exporter   has   not   been   initialized \"  )  ;", "doInvoke ( this . skeleton ,    inputStream ,    outputStream )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.remoting.caucho.HessianExporter"}, {"methodBody": ["METHOD_START", "{", "checkService (  )  ;", "checkServiceInterface (  )  ;", "this . skeleton    =    new   comhessian . server . HessianSkeleton ( getProxyForService (  )  ,    getServiceInterface (  )  )  ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.remoting.caucho.HessianExporter"}, {"methodBody": ["METHOD_START", "{", "this . serializerFactory . setAllowNonSerializable ( allowNonSerializable )  ;", "}", "METHOD_END"], "methodName": ["setAllowNonSerializable"], "fileName": "org.springframework.remoting.caucho.HessianExporter"}, {"methodBody": ["METHOD_START", "{", "this . debugLogger    =     ( debug )     ?    logger    :    null ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "org.springframework.remoting.caucho.HessianExporter"}, {"methodBody": ["METHOD_START", "{", "this . remoteResolver    =    remoteResolver ;", "}", "METHOD_END"], "methodName": ["setRemoteResolver"], "fileName": "org.springframework.remoting.caucho.HessianExporter"}, {"methodBody": ["METHOD_START", "{", "this . serializerFactory . setSendCollectionType ( sendCollectionType )  ;", "}", "METHOD_END"], "methodName": ["setSendCollectionType"], "fileName": "org.springframework.remoting.caucho.HessianExporter"}, {"methodBody": ["METHOD_START", "{", "this . serializerFactory    =     ( serializerFactory    !  =    null )     ?    serializerFactory    :    new   SerializerFactory (  )  ;", "}", "METHOD_END"], "methodName": ["setSerializerFactory"], "fileName": "org.springframework.remoting.caucho.HessianExporter"}, {"methodBody": ["METHOD_START", "{", "return   new   CodebaseAwareObjectInputStream ( is ,    getBeanClassLoader (  )  ,    codebaseUrl )  ;", "}", "METHOD_END"], "methodName": ["createObjectInputStream"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return   is ;", "}", "METHOD_END"], "methodName": ["decorateInputStream"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return   os ;", "}", "METHOD_END"], "methodName": ["decorateOutputStream"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "Object   obj    =    ois . readObject (  )  ;", "if    (  !  ( obj   instanceof   ReInvocationResult )  )     {", "throw   new   ReException (  (  (  (  \" Deserialized   object   needs   to   be   assignable   to   type    [  \"     +     ( ReInvocationResult . class . getName (  )  )  )     +     \"  ]  :     \"  )     +     ( ClassUtils . getDescriptiveType ( obj )  )  )  )  ;", "}", "return    (  ( ReInvocationResult )     ( obj )  )  ;", "}", "METHOD_END"], "methodName": ["doReadRemoteInvocationResult"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "oos . writeObject ( invocation )  ;", "}", "METHOD_END"], "methodName": ["doWriteRemoteInvocation"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . beanClassLoader ;", "}", "METHOD_END"], "methodName": ["getBeanClassLoader"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream ( AbstractHttpInvokerRequestExecutor . SERIALIZED _ INVOCATION _ BYTE _ ARRAY _ INITIAL _ SIZE )  ;", "writeRemoteInvocation ( invocation ,    baos )  ;", "return   baos ;", "}", "METHOD_END"], "methodName": ["getByteArrayOutputStream"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . contentType ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . acceptGzipEncoding ;", "}", "METHOD_END"], "methodName": ["isAcceptGzipEncoding"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "ObjectInputStream   ois    =    createObjectInputStream ( decorateInputStream ( is )  ,    codebaseUrl )  ;", "try    {", "return   doReadReInvocationResult ( ois )  ;", "}    finally    {", "ois . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readRemoteInvocationResult"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "this . acceptGzipEncoding    =    acceptGzipEncoding ;", "}", "METHOD_END"], "methodName": ["setAcceptGzipEncoding"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( contentType ,     \"  ' contentType '    must   not   be   null \"  )  ;", "this . contentType    =    contentType ;", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( decorateOutputStream ( os )  )  ;", "try    {", "doWriteReInvocation ( invocation ,    oos )  ;", "}    finally    {", "oos . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeRemoteInvocation"], "fileName": "org.springframework.remoting.httpinvoker.AbstractHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return    ( this . requestConfig )     !  =    null    ?    RequestConfig . copy ( this . requestConfig )     :    RequestConfig . custom (  )  ;", "}", "METHOD_END"], "methodName": ["cloneRequestConfig"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "Registry < ConnectionSocketFactory >    schemeRegistry    =    RegistryBuilder .  < ConnectionSocketFactory > create (  )  . register (  \" http \"  ,    PlainConnectionSocketFactory . getSocketFactory (  )  )  . register (  \" https \"  ,    SSLConnectionSocketFactory . getSocketFactory (  )  )  . build (  )  ;", "PoolingHttpClientConnectionManager   connectionManager    =    new   PoolingHttpClientConnectionManager ( schemeRegistry )  ;", "connectionManager . setMaxTotal (  . DEFAULT _ MAX _ TOTAL _ CONNECTIONS )  ;", "connectionManager . setDefaultMaxPerRoute (  . DEFAULT _ MAX _ CONNECTIONS _ PER _ ROUTE )  ;", "return   HttpClientBuilder . create (  )  . setConnectionManager ( connectionManager )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultHttpClient"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "HttpPost   httpPost    =    new   HttpPost ( config . getServiceUrl (  )  )  ;", "RequestConfig   requestConfig    =    createRequestConfig ( config )  ;", "if    ( requestConfig    !  =    null )     {", "httpPost . setConfig ( requestConfig )  ;", "}", "LocaleContext   localeContext    =    LocaleContextHolder . getLocaleContext (  )  ;", "if    ( localeContext    !  =    null )     {", "Locale   locale    =    localeContext . getLocale (  )  ;", "if    ( locale    !  =    null )     {", "httpPost . addHeader ( Abstract . HTTP _ HEADER _ ACCEPT _ LANGUAGE ,    locale . toLanguageTag (  )  )  ;", "}", "}", "if    ( isAcceptGzipEncoding (  )  )     {", "httpPost . addHeader ( Abstract . HTTP _ HEADER _ ACCEPT _ ENCODING ,    Abstract . ENCODING _ GZIP )  ;", "}", "return   httpPost ;", "}", "METHOD_END"], "methodName": ["createHttpPost"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "HttpClient   client    =    getHttpClient (  )  ;", "if    ( client   instanceof   Configurable )     {", "Config   clientConfig    =     (  ( Configurable )     ( client )  )  . getConfig (  )  ;", "return   mergeConfig ( clientConfig )  ;", "}", "return   this . requestConfig ;", "}", "METHOD_END"], "methodName": ["createRequestConfig"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return   httpClient . execute ( httpPost )  ;", "}", "METHOD_END"], "methodName": ["executeHttpPost"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . httpClient ;", "}", "METHOD_END"], "methodName": ["getHttpClient"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "if    ( isGzipResponse ( httpResponse )  )     {", "return   new   GZIPInputStream ( httpResponse . getEntity (  )  . getContent (  )  )  ;", "} else    {", "return   httpResponse . getEntity (  )  . getContent (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getResponseBody"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "Header   encodingHeader    =    httpResponse . getFirstHeader ( AbstractHttpInvokerRequestExecutor . HTTP _ HEADER _ CONTENT _ ENCODING )  ;", "return    (  ( encodingHeader    !  =    null )     &  &     (  ( encodingHeader . getValue (  )  )     !  =    null )  )     &  &     ( encodingHeader . getValue (  )  . toLowerCase (  )  . contains ( AbstractHttpInvokerRequestExecutor . ENCODING _ GZIP )  )  ;", "}", "METHOD_END"], "methodName": ["isGzipResponse"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . requestConfig )     =  =    null )     {", "return   defaultConfig ;", "}", "Config . Builder   builder    =    Config . copy ( defaultConfig )  ;", "int   connectTimeout    =    this . requestConfig . getConnectTimeout (  )  ;", "if    ( connectTimeout    >  =     0  )     {", "builder . setConnectTimeout ( connectTimeout )  ;", "}", "int   connectionTimeout    =    this . requestConfig . getConnectionTimeout (  )  ;", "if    ( connectionTimeout    >  =     0  )     {", "builder . setConnectionTimeout ( connectionTimeout )  ;", "}", "int   socketTimeout    =    this . requestConfig . getSocketTimeout (  )  ;", "if    ( socketTimeout    >  =     0  )     {", "builder . setSocketTimeout ( socketTimeout )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["mergeRequestConfig"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( timeout    >  =     0  )  ,     \" Timeout   must   be   a   non - negative   value \"  )  ;", "this . requestConfig    =    cloneConfig (  )  . setConnectTimeout ( timeout )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setConnectTimeout"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "this . requestConfig    =    cloneRequestConfig (  )  . setConnectionRequestTimeout ( connectionRequestTimeout )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setConnectionRequestTimeout"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "this . httpClient    =    httpClient ;", "}", "METHOD_END"], "methodName": ["setHttpClient"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( timeout    >  =     0  )  ,     \" Timeout   must   be   a   non - negative   value \"  )  ;", "this . requestConfig    =    cloneConfig (  )  . setSocketTimeout ( timeout )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setReadTimeout"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "ByteArrayEntity   entity    =    new   ByteArrayEntity ( baos . toByteArray (  )  )  ;", "entity . setContentType ( getContentType (  )  )  ;", "Post . setEntity ( entity )  ;", "}", "METHOD_END"], "methodName": ["setRequestBody"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "StatusLine   status    =    response . getStatusLine (  )  ;", "if    (  ( status . getStatusCode (  )  )     >  =     3  0  0  )     {", "throw   new   NoHttpResponseException (  (  (  (  (  \" Did   not   receive   successful   HTTP   response :    status   code    =     \"     +     ( status . getStatusCode (  )  )  )     +     \"  ,    status   message    =     [  \"  )     +     ( status . getReasonPhrase (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateResponse"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "HttpComponentsHttpInvokerRequestExecutor   executor    =    new   HttpComponentsHttpInvokerRequestExecutor (  )  ;", "executor . setConnectionRequestTimeout (  7  0  0  0  )  ;", "HttpInvokerClientConfiguration   config    =    mockHttpInvokerClientConfiguration (  \" http :  /  / fake - service \"  )  ;", "HttpPost   httpPost    =    executor . createHttpPost ( config )  ;", "assertEquals (  7  0  0  0  ,    httpPost . getConfig (  )  . getConnectionRequestTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeConnectionRequestTimeout"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutorTests"}, {"methodBody": ["METHOD_START", "{", "HttpComponentsHttpInvokerRequestExecutor   executor    =    new   HttpComponentsHttpInvokerRequestExecutor (  )  ;", "executor . setConnectTimeout (  5  0  0  0  )  ;", "HttpInvokerClientConfiguration   config    =    mockHttpInvokerClientConfiguration (  \" http :  /  / fake - service \"  )  ;", "HttpPost   httpPost    =    executor . createHttpPost ( config )  ;", "assertEquals (  5  0  0  0  ,    httpPost . getConfig (  )  . getConnectTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeConnectionTimeout"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutorTests"}, {"methodBody": ["METHOD_START", "{", "HttpComponentsHttpInvokerRequestExecutor   executor    =    new   HttpComponentsHttpInvokerRequestExecutor (  )  ;", "executor . setReadTimeout (  1  0  0  0  0  )  ;", "HttpInvokerClientConfiguration   config    =    mockHttpInvokerClientConfiguration (  \" http :  /  / fake - service \"  )  ;", "HttpPost   httpPost    =    executor . createHttpPost ( config )  ;", "assertEquals (  1  0  0  0  0  ,    httpPost . getConfig (  )  . getSocketTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["customizeReadTimeout"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutorTests"}, {"methodBody": ["METHOD_START", "{", "RequestConfig   defaultConfig    =    RequestConfig . custom (  )  . setConnectTimeout (  1  2  3  4  )  . build (  )  ;", "CloseableHttpClient   client    =    mock ( CloseableHttpClient . class ,    withSettings (  )  . extraInterfaces ( Configurable . class )  )  ;", "Configurable   configurable    =     (  ( Configurable )     ( client )  )  ;", "when ( configurable . getConfig (  )  )  . thenReturn ( defaultConfig )  ;", "executor    =    new    ( client )  ;", "HttpInvokerClientConfiguration   config    =    mockHttpInvokerClientConfiguration (  \" http :  /  / fake - service \"  )  ;", "HttpPost   httpPost    =    executor . createHttpPost ( config )  ;", "assertSame (  \" Default   client   configuration   is   expected \"  ,    defaultConfig ,    httpPost . getConfig (  )  )  ;", "executor . setConnectionRequestTimeout (  4  5  6  7  )  ;", "HttpPost   httpPost 2     =    executor . createHttpPost ( config )  ;", "assertNotNull ( httpPost 2  . getConfig (  )  )  ;", "assertEquals (  4  5  6  7  ,    httpPost 2  . getConfig (  )  . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  1  2  3  4  ,    httpPost 2  . getConfig (  )  . getConnectTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultSettingsOfHttpClientMergedOnExecutorCustomization"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutorTests"}, {"methodBody": ["METHOD_START", "{", "CloseableHttpClient   httpClient    =    HttpClientBuilder . create (  )  . build (  )  ;", "executor    =    new    ( httpClient )     {", "@ Override", "protected   RequestConfig   createRequestConfig ( HttpInvokerClientConfiguration   config )     {", "return   null ;", "}", "}  ;", "HttpInvokerClientConfiguration   config    =    mockHttpInvokerClientConfiguration (  \" http :  /  / fake - service \"  )  ;", "HttpPost   httpPost    =    executor . createHttpPost ( config )  ;", "assertNull (  \" custom   request   config   should   not   be   set \"  ,    httpPost . getConfig (  )  )  ;", "}", "METHOD_END"], "methodName": ["ignoreFactorySettings"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutorTests"}, {"methodBody": ["METHOD_START", "{", "RequestConfig   defaultConfig    =    RequestConfig . custom (  )  . setConnectTimeout (  1  2  3  4  )  . setConnectionRequestTimeout (  6  7  8  9  )  . build (  )  ;", "CloseableHttpClient   client    =    mock ( CloseableHttpClient . class ,    withSettings (  )  . extraInterfaces ( Configurable . class )  )  ;", "Configurable   configurable    =     (  ( Configurable )     ( client )  )  ;", "when ( configurable . getConfig (  )  )  . thenReturn ( defaultConfig )  ;", "executor    =    new    ( client )  ;", "executor . setConnectTimeout (  5  0  0  0  )  ;", "HttpInvokerClientConfiguration   config    =    mockHttpInvokerClientConfiguration (  \" http :  /  / fake - service \"  )  ;", "HttpPost   httpPost    =    executor . createHttpPost ( config )  ;", "RequestConfig   requestConfig    =    httpPost . getConfig (  )  ;", "assertEquals (  5  0  0  0  ,    requestConfig . getConnectTimeout (  )  )  ;", "assertEquals (  6  7  8  9  ,    requestConfig . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  (  -  1  )  ,    requestConfig . getSocketTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["localSettingsOverrideClientDefaultSettings"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutorTests"}, {"methodBody": ["METHOD_START", "{", "RequestConfig   defaultConfig    =    RequestConfig . custom (  )  . setSocketTimeout (  1  2  3  4  )  . build (  )  ;", "final   CloseableHttpClient   client    =    mock ( CloseableHttpClient . class ,    withSettings (  )  . extraInterfaces ( Configurable . class )  )  ;", "Configurable   configurable    =     (  ( Configurable )     ( client )  )  ;", "when ( configurable . getConfig (  )  )  . thenReturn ( defaultConfig )  ;", "executor    =    new    (  )     {", "@ Override", "public   HttpClient   getHttpClient (  )     {", "return   client ;", "}", "}  ;", "executor . setReadTimeout (  5  0  0  0  )  ;", "HttpInvokerClientConfiguration   config    =    mockHttpInvokerClientConfiguration (  \" http :  /  / fake - service \"  )  ;", "HttpPost   httpPost    =    executor . createHttpPost ( config )  ;", "RequestConfig   requestConfig    =    httpPost . getConfig (  )  ;", "assertEquals (  (  -  1  )  ,    requestConfig . getConnectTimeout (  )  )  ;", "assertEquals (  (  -  1  )  ,    requestConfig . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  5  0  0  0  ,    requestConfig . getSocketTimeout (  )  )  ;", "RequestConfig   updatedDefaultConfig    =    RequestConfig . custom (  )  . setConnectTimeout (  1  2  3  4  )  . build (  )  ;", "when ( configurable . getConfig (  )  )  . thenReturn ( updatedDefaultConfig )  ;", "executor . setReadTimeout (  7  0  0  0  )  ;", "HttpPost   httpPost 2     =    executor . createHttpPost ( config )  ;", "RequestConfig   requestConfig 2     =    httpPost 2  . getConfig (  )  ;", "assertEquals (  1  2  3  4  ,    requestConfig 2  . getConnectTimeout (  )  )  ;", "assertEquals (  (  -  1  )  ,    requestConfig 2  . getConnectionRequestTimeout (  )  )  ;", "assertEquals (  7  0  0  0  ,    requestConfig 2  . getSocketTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeBasedOnCurrentHttpClient"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutorTests"}, {"methodBody": ["METHOD_START", "{", "HttpInvokerClientConfiguration   config    =    mock ( HttpInvokerClientConfiguration . class )  ;", "when ( config . getServiceUrl (  )  )  . thenReturn ( serviceUrl )  ;", "return   config ;", "}", "METHOD_END"], "methodName": ["mockHttpInvokerClientConfiguration"], "fileName": "org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   ConnectException )     {", "return   new   RemoteConnectFailureException (  (  (  \" Could   not   connect   to   HTTP      remote   service   at    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "if    (  (  ( ex   instanceof   ClassNotFoundException )     |  |     ( ex   instanceof   NoClassDefFoundError )  )     |  |     ( ex   instanceof   InvalidClassException )  )     {", "return   new   RemoteAccessException (  (  (  \" Could   not   deserialize   result   from   HTTP      remote   service    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "if    ( ex   instanceof   Exception )     {", "return   new   RemoteAccessException (  (  (  \" Could   not   access   HTTP      remote   service   at    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["convertHttpInvokerAccessException"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   getHttpInvokerRequestExecutor (  )  . executeRequest ( this ,    invocation )  ;", "}", "METHOD_END"], "methodName": ["executeRequest"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   executeRequest ( invocation )  ;", "}", "METHOD_END"], "methodName": ["executeRequest"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . httpInvokerRequestExecutor )     =  =    null )     {", "SimpleRequestExecutor   executor    =    new   SimpleRequestExecutor (  )  ;", "executor . setBeanClassLoader ( getBeanClassLoader (  )  )  ;", "this . httpInvokerRequestExecutor    =    executor ;", "}", "return   this . httpInvokerRequestExecutor ;", "}", "METHOD_END"], "methodName": ["getHttpInvokerRequestExecutor"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . codebaseUrl    =    codebaseUrl ;", "}", "METHOD_END"], "methodName": ["setCodebaseUrl"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . httpInvokerRequestExecutor    =    httpInvokerRequestExecutor ;", "}", "METHOD_END"], "methodName": ["setHttpInvokerRequestExecutor"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( HttpInvokerFactoryBeanIntegrationTests . InvokerAutowiringConfig . class )  ;", "HttpInvokerFactoryBeanIntegrationTests . MyBean   myBean    =    context . getBean (  \" myBean \"  ,    HttpInvokerFactoryBeanIntegrationTests . MyBean . class )  ;", "assertSame ( context . getBean (  \" myService \"  )  ,    myBean . myService )  ;", "myBean . myService . handle (  )  ;", "myBean . myService . handleAsync (  )  ;", "}", "METHOD_END"], "methodName": ["testLoadedConfigClass"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerFactoryBeanIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . InvokerAutowiringConfig . class . getName (  )  )  )  ;", "context . refresh (  )  ;", ". MyBean   myBean    =    context . getBean (  \" myBean \"  ,     . MyBean . class )  ;", "assertSame ( context . getBean (  \" myService \"  )  ,    myBean . myService )  ;", "myBean . myService . handle (  )  ;", "myBean . myService . handleAsync (  )  ;", "}", "METHOD_END"], "methodName": ["testNonLoadedConfigClass"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerFactoryBeanIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . ConfigWithPlainFactoryBean . class )  ;", "context . refresh (  )  ;", ". MyBean   myBean    =    context . getBean (  \" myBean \"  ,     . MyBean . class )  ;", "assertSame ( context . getBean (  \" myService \"  )  ,    myBean . myService )  ;", "myBean . myService . handle (  )  ;", "myBean . myService . handleAsync (  )  ;", "}", "METHOD_END"], "methodName": ["withConfigurationClassWithPlainFactoryBean"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerFactoryBeanIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   is ;", "}", "METHOD_END"], "methodName": ["decorateInputStream"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "return   os ;", "}", "METHOD_END"], "methodName": ["decorateOutputStream"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "return   readRemoteInvocation ( request ,    request . getInputStream (  )  )  ;", "}", "METHOD_END"], "methodName": ["readRemoteInvocation"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "ObjectInputStream   ois    =    createObjectInputStream ( decorateInputStream ( request ,    is )  )  ;", "try    {", "return   doReadReInvocation ( ois )  ;", "}    finally    {", "ois . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readRemoteInvocation"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "response . setContentType ( getContentType (  )  )  ;", "writeReInvocationResult ( request ,    response ,    result ,    response . getOutputStream (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeRemoteInvocationResult"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "ObjectOutputStream   oos    =    createObjectOutputStream ( new   HttpInvokerServiceExporter . FlushGuardedOutputStream ( decorateOutputStream ( request ,    response ,    os )  )  )  ;", "try    {", "doWriteRemoteInvocationResult ( result ,    oos )  ;", "}    finally    {", "oos . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeRemoteInvocationResult"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  \" myname \"  ,     9  9  )  ;", "final   ServiceExporter   exporter    =    new   ServiceExporter (  )  ;", "exporter . setServiceInterface ( ITestBean . class )  ;", "exporter . setService ( target )  ;", "exporter . afterPropertiesSet (  )  ;", "ProxyFactoryBean   pfb    =    new   ProxyFactoryBean (  )  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setServiceUrl (  \" http :  /  / myurl \"  )  ;", "pfb . setRequestExecutor ( new   AbstractRequestExecutor (  )     {", "@ Override", "protected   RemoteInvocationResult   doExecuteRequest ( ClientConfiguration   config ,    ByteArrayOutputStream   baos )    throws   Exception    {", "assertEquals (  \" http :  /  / myurl \"  ,    config . getServiceUrl (  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "request . setContent ( baos . toByteArray (  )  )  ;", "exporter . handleRequest ( request ,    response )  ;", "return   readRemoteInvocationResult ( new   ByteArrayInputStream ( response . getContentAsByteArray (  )  )  ,    config . getCodebaseUrl (  )  )  ;", "}", "}  )  ;", "if    ( explicitClassLoader )     {", "(  ( BeanClassLoaderAware )     ( pfb . getRequestExecutor (  )  )  )  . setBeanClassLoader ( getClass (  )  . getClassLoader (  )  )  ;", "}", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "assertEquals (  \" myname \"  ,    proxy . getName (  )  )  ;", "assertEquals (  9  9  ,    proxy . getAge (  )  )  ;", "proxy . setAge (  5  0  )  ;", "assertEquals (  5  0  ,    proxy . getAge (  )  )  ;", "proxy . setStringArray ( new   String [  ]  {     \" str 1  \"  ,     \" str 2  \"     }  )  ;", "assertTrue ( Arrays . equals ( new   String [  ]  {     \" str 1  \"  ,     \" str 2  \"     }  ,    proxy . getStringArray (  )  )  )  ;", "proxy . setSomeIntegerArray ( new   Integer [  ]  {     1  ,     2  ,     3     }  )  ;", "assertTrue ( Arrays . equals ( new   Integer [  ]  {     1  ,     2  ,     3     }  ,    proxy . getSomeIntegerArray (  )  )  )  ;", "proxy . setNestedIntegerArray ( new   Integer [  ]  [  ]  {    new   Integer [  ]  {     1  ,     2  ,     3     }  ,    new   Integer [  ]  {     4  ,     5  ,     6     }     }  )  ;", "Integer [  ]  [  ]    integerArray    =    proxy . getNestedIntegerArray (  )  ;", "assertTrue ( Arrays . equals ( new   Integer [  ]  {     1  ,     2  ,     3     }  ,    integerArray [  0  ]  )  )  ;", "assertTrue ( Arrays . equals ( new   Integer [  ]  {     4  ,     5  ,     6     }  ,    integerArray [  1  ]  )  )  ;", "proxy . setSomeIntArray ( new   int [  ]  {     1  ,     2  ,     3     }  )  ;", "assertTrue ( Arrays . equals ( new   int [  ]  {     1  ,     2  ,     3     }  ,    proxy . getSomeIntArray (  )  )  )  ;", "proxy . setNestedIntArray ( new   int [  ]  [  ]  {    new   int [  ]  {     1  ,     2  ,     3     }  ,    new   int [  ]  {     4  ,     5  ,     6     }     }  )  ;", "int [  ]  [  ]    intArray    =    proxy . getNestedIntArray (  )  ;", "assertTrue ( Arrays . equals ( new   int [  ]  {     1  ,     2  ,     3     }  ,    intArray [  0  ]  )  )  ;", "assertTrue ( Arrays . equals ( new   int [  ]  {     4  ,     5  ,     6     }  ,    intArray [  1  ]  )  )  ;", "try    {", "proxy . exceptional ( new   IllegalStateException (  )  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "try    {", "proxy . exceptional ( new   IllegalAccessException (  )  )  ;", "fail (  \" Should   have   thrown   IllegalAccessException \"  )  ;", "}    catch    ( IllegalAccessException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["doTestHttpInvokerProxyFactoryBeanAndServiceExporter"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "doTestHttpInvokerProxyFactoryBeanAndServiceExporter ( false )  ;", "}", "METHOD_END"], "methodName": ["httpInvokerProxyFactoryBeanAndServiceExporter"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  \" myname \"  ,     9  9  )  ;", "final   HttpInvokerServiceExporter   exporter    =    new   HttpInvokerServiceExporter (  )  ;", "exporter . setServiceInterface ( ITestBean . class )  ;", "exporter . setService ( target )  ;", "exporter . setRemoteInvocationExecutor ( new   DefaultRemoteInvocationExecutor (  )     {", "@ Override", "public   Object   invoke ( RemoteInvocation   invocation ,    Object   targetObject )    throws   IllegalAccessException ,    NoSuchMethodException ,    InvocationTargetException    {", "assertTrue (  ( invocation   instanceof    . TestRemoteInvocation )  )  ;", "assertNull ( invocation . getAttributes (  )  )  ;", "assertNull ( invocation . getAttribute (  \" myKey \"  )  )  ;", "return   super . invoke ( invocation ,    targetObject )  ;", "}", "}  )  ;", "exporter . afterPropertiesSet (  )  ;", "HttpInvokerProxyFactoryBean   pfb    =    new   HttpInvokerProxyFactoryBean (  )  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setServiceUrl (  \" http :  /  / myurl \"  )  ;", "pfb . setRemoteInvocationFactory ( new   RemoteInvocationFactory (  )     {", "@ Override", "public   RemoteInvocation   createRemoteInvocation ( MethodInvocation   methodInvocation )     {", "RemoteInvocation   invocation    =    new    . TestRemoteInvocation ( methodInvocation )  ;", "assertNull ( invocation . getAttributes (  )  )  ;", "assertNull ( invocation . getAttribute (  \" myKey \"  )  )  ;", "return   invocation ;", "}", "}  )  ;", "pfb . setHttpInvokerRequestExecutor ( new   AbstractHttpInvokerRequestExecutor (  )     {", "@ Override", "protected   RemoteInvocationResult   doExecuteRequest ( HttpInvokerClientConfiguration   config ,    ByteArrayOutputStream   baos )    throws   Exception    {", "assertEquals (  \" http :  /  / myurl \"  ,    config . getServiceUrl (  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "request . setContent ( baos . toByteArray (  )  )  ;", "exporter . handleRequest ( request ,    response )  ;", "return   readRemoteInvocationResult ( new   ByteArrayInputStream ( response . getContentAsByteArray (  )  )  ,    config . getCodebaseUrl (  )  )  ;", "}", "}  )  ;", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "assertEquals (  \" myname \"  ,    proxy . getName (  )  )  ;", "assertEquals (  9  9  ,    proxy . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpInvokerProxyFactoryBeanAndServiceExporterWithCustomInvocationObject"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "doTestHttpInvokerProxyFactoryBeanAndServiceExporter ( true )  ;", "}", "METHOD_END"], "methodName": ["httpInvokerProxyFactoryBeanAndServiceExporterWithExplicitClassLoader"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  \" myname \"  ,     9  9  )  ;", "final   ServiceExporter   exporter    =    new   ServiceExporter (  )     {", "@ Override", "protected   InputStream   decorateInputStream ( HttpServletRequest   request ,    InputStream   is )    throws   IOException    {", "if    (  \" gzip \"  . equals ( request . getHeader (  \" Compression \"  )  )  )     {", "return   new   GZIPInputStream ( is )  ;", "} else    {", "return   is ;", "}", "}", "@ Override", "protected   OutputStream   decorateOutputStream ( HttpServletRequest   request ,    HttpServletResponse   response ,    OutputStream   os )    throws   IOException    {", "if    (  \" gzip \"  . equals ( request . getHeader (  \" Compression \"  )  )  )     {", "return   new   GZIPOutputStream ( os )  ;", "} else    {", "return   os ;", "}", "}", "}  ;", "exporter . setServiceInterface ( ITestBean . class )  ;", "exporter . setService ( target )  ;", "exporter . afterPropertiesSet (  )  ;", "ProxyFactoryBean   pfb    =    new   ProxyFactoryBean (  )  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setServiceUrl (  \" http :  /  / myurl \"  )  ;", "pfb . setRequestExecutor ( new   AbstractRequestExecutor (  )     {", "@ Override", "protected   RemoteInvocationResult   doExecuteRequest ( ClientConfiguration   config ,    ByteArrayOutputStream   baos )    throws   IOException ,    ClassNotFoundException    {", "assertEquals (  \" http :  /  / myurl \"  ,    config . getServiceUrl (  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Compression \"  ,     \" gzip \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "request . setContent ( baos . toByteArray (  )  )  ;", "try    {", "exporter . handleRequest ( request ,    response )  ;", "}    catch    ( ServletException   ex )     {", "throw   new   IOException ( ex . toString (  )  )  ;", "}", "return   readRemoteInvocationResult ( new   ByteArrayInputStream ( response . getContentAsByteArray (  )  )  ,    config . getCodebaseUrl (  )  )  ;", "}", "@ Override", "protected   OutputStream   decorateOutputStream ( OutputStream   os )    throws   IOException    {", "return   new   GZIPOutputStream ( os )  ;", "}", "@ Override", "protected   InputStream   decorateInputStream ( InputStream   is )    throws   IOException    {", "return   new   GZIPInputStream ( is )  ;", "}", "}  )  ;", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "assertEquals (  \" myname \"  ,    proxy . getName (  )  )  ;", "assertEquals (  9  9  ,    proxy . getAge (  )  )  ;", "proxy . setAge (  5  0  )  ;", "assertEquals (  5  0  ,    proxy . getAge (  )  )  ;", "try    {", "proxy . exceptional ( new   IllegalStateException (  )  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "try    {", "proxy . exceptional ( new   IllegalAccessException (  )  )  ;", "fail (  \" Should   have   thrown   IllegalAccessException \"  )  ;", "}    catch    ( IllegalAccessException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["httpInvokerProxyFactoryBeanAndServiceExporterWithGzipCompression"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  \" myname \"  ,     9  9  )  ;", "final   ServiceExporter   exporter    =    new   ServiceExporter (  )  ;", "exporter . setServiceInterface ( ITestBean . class )  ;", "exporter . setService ( target )  ;", "exporter . afterPropertiesSet (  )  ;", "ProxyFactoryBean   pfb    =    new   ProxyFactoryBean (  )  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setServiceUrl (  \" http :  /  / myurl \"  )  ;", "pfb . setRequestExecutor ( new   RequestExecutor (  )     {", "@ Override", "public   RemoteInvocationResult   executeRequest ( ClientConfiguration   config ,    RemoteInvocation   invocation )    throws   IOException    {", "throw   new   IOException (  \" argh \"  )  ;", "}", "}  )  ;", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "try    {", "proxy . setAge (  5  0  )  ;", "fail (  \" Should   have   thrown   RemoteAccessException \"  )  ;", "}    catch    ( RemoteAccessException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IOException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["httpInvokerProxyFactoryBeanAndServiceExporterWithIOException"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  \" myname \"  ,     9  9  )  ;", "final   ServiceExporter   exporter    =    new   ServiceExporter (  )  ;", "exporter . setServiceInterface ( ITestBean . class )  ;", "exporter . setService ( target )  ;", "exporter . setRemoteInvocationExecutor ( new   DefaultRemoteInvocationExecutor (  )     {", "@ Override", "public   Object   invoke ( RemoteInvocation   invocation ,    Object   targetObject )    throws   IllegalAccessException ,    NoSuchMethodException ,    InvocationTargetException    {", "assertNotNull ( invocation . getAttributes (  )  )  ;", "assertEquals (  1  ,    invocation . getAttributes (  )  . size (  )  )  ;", "assertEquals (  \" myValue \"  ,    invocation . getAttributes (  )  . get (  \" myKey \"  )  )  ;", "assertEquals (  \" myValue \"  ,    invocation . getAttribute (  \" myKey \"  )  )  ;", "return   super . invoke ( invocation ,    targetObject )  ;", "}", "}  )  ;", "exporter . afterPropertiesSet (  )  ;", "ProxyFactoryBean   pfb    =    new   ProxyFactoryBean (  )  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setServiceUrl (  \" http :  /  / myurl \"  )  ;", "pfb . setRemoteInvocationFactory ( new   RemoteInvocationFactory (  )     {", "@ Override", "public   RemoteInvocation   createRemoteInvocation ( MethodInvocation   methodInvocation )     {", "RemoteInvocation   invocation    =    new   RemoteInvocation ( methodInvocation )  ;", "invocation . addAttribute (  \" myKey \"  ,     \" myValue \"  )  ;", "try    {", "invocation . addAttribute (  \" myKey \"  ,     \" myValue \"  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "assertNotNull ( invocation . getAttributes (  )  )  ;", "assertEquals (  1  ,    invocation . getAttributes (  )  . size (  )  )  ;", "assertEquals (  \" myValue \"  ,    invocation . getAttributes (  )  . get (  \" myKey \"  )  )  ;", "assertEquals (  \" myValue \"  ,    invocation . getAttribute (  \" myKey \"  )  )  ;", "return   invocation ;", "}", "}  )  ;", "pfb . setRequestExecutor ( new   AbstractRequestExecutor (  )     {", "@ Override", "protected   RemoteInvocationResult   doExecuteRequest ( ClientConfiguration   config ,    ByteArrayOutputStream   baos )    throws   Exception    {", "assertEquals (  \" http :  /  / myurl \"  ,    config . getServiceUrl (  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "request . setContent ( baos . toByteArray (  )  )  ;", "exporter . handleRequest ( request ,    response )  ;", "return   readRemoteInvocationResult ( new   ByteArrayInputStream ( response . getContentAsByteArray (  )  )  ,    config . getCodebaseUrl (  )  )  ;", "}", "}  )  ;", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "assertEquals (  \" myname \"  ,    proxy . getName (  )  )  ;", "assertEquals (  9  9  ,    proxy . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpInvokerProxyFactoryBeanAndServiceExporterWithInvocationAttributes"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  \" myname \"  ,     9  9  )  ;", "final   HttpInvokerServiceExporter   exporter    =    new   HttpInvokerServiceExporter (  )     {", "@ Override", "protected   RemoteInvocation   doReadRemoteInvocation ( ObjectInputStream   ois )    throws   IOException ,    ClassNotFoundException    {", "Object   obj    =    ois . readObject (  )  ;", "if    (  !  ( obj   instanceof    . TestRemoteInvocationWrapper )  )     {", "throw   new   IOException (  (  (  (  \" Deserialized   object   needs   to   be   assignable   to   type    [  \"     +     (  . TestRemoteInvocationWrapper . class . getName (  )  )  )     +     \"  ]  :     \"  )     +    obj )  )  ;", "}", "return    (  (  . TestRemoteInvocationWrapper )     ( obj )  )  . remoteInvocation ;", "}", "@ Override", "protected   void   doWriteRemoteInvocationResult ( RemoteInvocationResult   result ,    ObjectOutputStream   oos )    throws   IOException    {", "oos . writeObject ( new    . TestRemoteInvocationResultWrapper ( result )  )  ;", "}", "}  ;", "exporter . setServiceInterface ( ITestBean . class )  ;", "exporter . setService ( target )  ;", "exporter . afterPropertiesSet (  )  ;", "HttpInvokerProxyFactoryBean   pfb    =    new   HttpInvokerProxyFactoryBean (  )  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setServiceUrl (  \" http :  /  / myurl \"  )  ;", "pfb . setHttpInvokerRequestExecutor ( new   AbstractHttpInvokerRequestExecutor (  )     {", "@ Override", "protected   RemoteInvocationResult   doExecuteRequest ( HttpInvokerClientConfiguration   config ,    ByteArrayOutputStream   baos )    throws   Exception    {", "assertEquals (  \" http :  /  / myurl \"  ,    config . getServiceUrl (  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "request . setContent ( baos . toByteArray (  )  )  ;", "exporter . handleRequest ( request ,    response )  ;", "return   readRemoteInvocationResult ( new   ByteArrayInputStream ( response . getContentAsByteArray (  )  )  ,    config . getCodebaseUrl (  )  )  ;", "}", "@ Override", "protected   void   doWriteRemoteInvocation ( RemoteInvocation   invocation ,    ObjectOutputStream   oos )    throws   IOException    {", "oos . writeObject ( new    . TestRemoteInvocationWrapper ( invocation )  )  ;", "}", "@ Override", "protected   RemoteInvocationResult   doReadRemoteInvocationResult ( ObjectInputStream   ois )    throws   IOException ,    ClassNotFoundException    {", "Object   obj    =    ois . readObject (  )  ;", "if    (  !  ( obj   instanceof    . TestRemoteInvocationResultWrapper )  )     {", "throw   new   IOException (  (  (  (  \" Deserialized   object   needs   to   be   assignable   to   type    [  \"     +     (  . TestRemoteInvocationResultWrapper . class . getName (  )  )  )     +     \"  ]  :     \"  )     +    obj )  )  ;", "}", "return    (  (  . TestRemoteInvocationResultWrapper )     ( obj )  )  . remoteInvocationResult ;", "}", "}  )  ;", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "assertEquals (  \" myname \"  ,    proxy . getName (  )  )  ;", "assertEquals (  9  9  ,    proxy . getAge (  )  )  ;", "proxy . setAge (  5  0  )  ;", "assertEquals (  5  0  ,    proxy . getAge (  )  )  ;", "try    {", "proxy . exceptional ( new   IllegalStateException (  )  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "try    {", "proxy . exceptional ( new   IllegalAccessException (  )  )  ;", "fail (  \" Should   have   thrown   IllegalAccessException \"  )  ;", "}    catch    ( IllegalAccessException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["httpInvokerProxyFactoryBeanAndServiceExporterWithWrappedInvocations"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "String   serviceUrl    =     \" http :  /  / myurl \"  ;", "ProxyFactoryBean   pfb    =    new   ProxyFactoryBean (  )  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setServiceUrl ( serviceUrl )  ;", "pfb . setRequestExecutor ( new   RequestExecutor (  )     {", "@ Override", "public   RemoteInvocationResult   executeRequest ( ClientConfiguration   config ,    RemoteInvocation   invocation )    throws   IOException    {", "throw   new   IOException (  \" argh \"  )  ;", "}", "}  )  ;", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "assertTrue (  (  ( proxy . toString (  )  . indexOf (  \" HTTP   invoker \"  )  )     !  =     (  -  1  )  )  )  ;", "assertTrue (  (  ( proxy . toString (  )  . indexOf ( serviceUrl )  )     !  =     (  -  1  )  )  )  ;", "assertEquals ( proxy . hashCode (  )  ,    proxy . hashCode (  )  )  ;", "assertTrue ( proxy . equals ( proxy )  )  ;", "try    {", "proxy . setAge (  5  0  )  ;", "fail (  \" Should   have   thrown   RemoteAccessException \"  )  ;", "}    catch    ( RemoteAccessException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IOException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["httpInvokerWithSpecialLocalMethods"], "fileName": "org.springframework.remoting.httpinvoker.HttpInvokerTests"}, {"methodBody": ["METHOD_START", "{", "String   encodingHeader    =    con . getHeaderField ( AbstractHttpInvokerRequestExecutor . HTTP _ HEADER _ CONTENT _ ENCODING )  ;", "return    ( encodingHeader    !  =    null )     &  &     ( encodingHeader . toLowerCase (  )  . contains ( AbstractHttpInvokerRequestExecutor . ENCODING _ GZIP )  )  ;", "}", "METHOD_END"], "methodName": ["isGzipResponse"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "URLConnection   con    =    new   URL ( config . getServiceUrl (  )  )  . openConnection (  )  ;", "if    (  !  ( con   instanceof   URLConnection )  )     {", "throw   new   IOException (  (  (  \" Service   URL    [  \"     +     ( config . getServiceUrl (  )  )  )     +     \"  ]    does   not   resolve   to   an   HTTP   connection \"  )  )  ;", "}", "return    (  ( URLConnection )     ( con )  )  ;", "}", "METHOD_END"], "methodName": ["openConnection"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . connectTimeout )     >  =     0  )     {", "connection . setConnectTimeout ( this . connectTimeout )  ;", "}", "if    (  ( this . readTimeout )     >  =     0  )     {", "connection . setReadTimeout ( this . readTimeout )  ;", "}", "connection . setDoOutput ( true )  ;", "connection . setRequestMethod ( Abstract . HTTP _ METHOD _ POST )  ;", "connection . setRequestProperty ( Abstract . HTTP _ HEADER _ CONTENT _ TYPE ,    getContentType (  )  )  ;", "connection . setRequestProperty ( Abstract . HTTP _ HEADER _ CONTENT _ LENGTH ,    Integer . toString ( contentLength )  )  ;", "LocaleContext   localeContext    =    LocaleContextHolder . getLocaleContext (  )  ;", "if    ( localeContext    !  =    null )     {", "Locale   locale    =    localeContext . getLocale (  )  ;", "if    ( locale    !  =    null )     {", "connection . setRequestProperty ( Abstract . HTTP _ HEADER _ ACCEPT _ LANGUAGE ,    locale . toLanguageTag (  )  )  ;", "}", "}", "if    ( isAcceptGzipEncoding (  )  )     {", "connection . setRequestProperty ( Abstract . HTTP _ HEADER _ ACCEPT _ ENCODING ,    Abstract . ENCODING _ GZIP )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareConnection"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "if    ( isGzipResponse ( con )  )     {", "return   new   GZIPInputStream ( con . getInputStream (  )  )  ;", "} else    {", "return   con . getInputStream (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readResponseBody"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "this . connectTimeout    =    connectTimeout ;", "}", "METHOD_END"], "methodName": ["setConnectTimeout"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "this . readTimeout    =    readTimeout ;", "}", "METHOD_END"], "methodName": ["setReadTimeout"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( con . getResponseCode (  )  )     >  =     3  0  0  )     {", "throw   new   IOException (  (  (  (  (  \" Did   not   receive   successful   HTTP   response :    status   code    =     \"     +     ( con . getResponseCode (  )  )  )     +     \"  ,    status   message    =     [  \"  )     +     ( con . getResponseMessage (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateResponse"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "baos . writeTo ( con . getOutputStream (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeRequestBody"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerRequestExecutor"}, {"methodBody": ["METHOD_START", "{", "return   is ;", "}", "METHOD_END"], "methodName": ["decorateInputStream"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "return   os ;", "}", "METHOD_END"], "methodName": ["decorateOutputStream"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "return   readRemoteInvocation ( exchange ,    exchange . getRequestBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["readRemoteInvocation"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "ObjectInputStream   ois    =    createObjectInputStream ( decorateInputStream ( exchange ,    is )  )  ;", "return   doReadReInvocation ( ois )  ;", "}", "METHOD_END"], "methodName": ["readRemoteInvocation"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "exchange . getResponseHeaders (  )  . set (  \" Content - Type \"  ,    getContentType (  )  )  ;", "exchange . sendResponseHeaders (  2  0  0  ,     0  )  ;", "writeReInvocationResult ( exchange ,    result ,    exchange . getResponseBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeRemoteInvocationResult"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "ObjectOutputStream   oos    =    createObjectOutputStream ( decorateOutputStream ( exchange ,    os )  )  ;", "doWriteReInvocationResult ( result ,    oos )  ;", "oos . flush (  )  ;", "}", "METHOD_END"], "methodName": ["writeRemoteInvocationResult"], "fileName": "org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . endpointFeatures )     !  =    null    ?    Endpoint . create ( this . bindingType ,    bean ,    this . endpointFeatures )     :    Endpoint . create ( this . bindingType ,    bean )  ;", "}", "METHOD_END"], "methodName": ["createEndpoint"], "fileName": "org.springframework.remoting.jaxws.AbstractJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" No   BeanFactory   set \"  )  ;", "Set < String >    beanNames    =    new   LinkedHashSet ( this . beanFactory . getBeanDefinitionCount (  )  )  ;", "Collections . addAll ( beanNames ,    this . beanFactory . getBeanDefinitionNames (  )  )  ;", "if    (  ( this . beanFactory )    instanceof   ConfigurableBeanFactory )     {", "Collections . addAll ( beanNames ,     (  ( ConfigurableBeanFactory )     ( this . beanFactory )  )  . getSingletonNames (  )  )  ;", "}", "for    ( String   beanName    :    beanNames )     {", "try    {", "Class <  ?  >    type    =    this . beanFactory . getType ( beanName )  ;", "if    (  ( type    !  =    null )     &  &     (  !  ( type . isInterface (  )  )  )  )     {", "Web   wsAnnotation    =    type . getAnnotation ( Web . class )  ;", "WebProvider   wsProviderAnnotation    =    type . getAnnotation ( WebProvider . class )  ;", "if    (  ( wsAnnotation    !  =    null )     |  |     ( wsProviderAnnotation    !  =    null )  )     {", "Endpoint   endpoint    =    createEndpoint ( this . beanFactory . getBean ( beanName )  )  ;", "if    (  ( this . endpointProperties )     !  =    null )     {", "endpoint . setProperties ( this . endpointProperties )  ;", "}", "if    (  ( this . executor )     !  =    null )     {", "endpoint . setExecutor ( this . executor )  ;", "}", "if    ( wsAnnotation    !  =    null )     {", "publishEndpoint ( endpoint ,    wsAnnotation )  ;", "} else    {", "publishEndpoint ( endpoint ,    wsProviderAnnotation )  ;", "}", "this . publishedEndpoints . add ( endpoint )  ;", "}", "}", "}    catch    ( CannotLoadBeanClassException   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["publishEndpoints"], "fileName": "org.springframework.remoting.jaxws.AbstractJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . bindingType    =    bindingType ;", "}", "METHOD_END"], "methodName": ["setBindingType"], "fileName": "org.springframework.remoting.jaxws.AbstractJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . endpointFeatures    =    endpointFeatures ;", "}", "METHOD_END"], "methodName": ["setEndpointFeatures"], "fileName": "org.springframework.remoting.jaxws.AbstractJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . endpointProperties    =    endpointProperties ;", "}", "METHOD_END"], "methodName": ["setEndpointProperties"], "fileName": "org.springframework.remoting.jaxws.AbstractJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . executor    =    executor ;", "}", "METHOD_END"], "methodName": ["setExecutor"], "fileName": "org.springframework.remoting.jaxws.AbstractJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "getCustomProperties (  )  . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addCustomProperty"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getWsdlDocumentUrl (  )  )     =  =    null )     {", "St   wsdl    =    ann . wsdlLocation (  )  ;", "if    ( StUtils . hasText ( wsdl )  )     {", "try    {", "setWsdlDocumentUrl ( new   URL ( wsdl )  )  ;", "}    catch    ( MalformedURLException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Encountered   invalid    @ Service   wsdlLocation   value    [  \"     +    wsdl )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "if    (  ( getNamespaceUri (  )  )     =  =    null )     {", "St   ns    =    ann . targetNamespace (  )  ;", "if    ( StUtils . hasText ( ns )  )     {", "setNamespaceUri ( ns )  ;", "}", "}", "if    (  ( getServiceName (  )  )     =  =    null )     {", "St   sn    =    ann . serviceName (  )  ;", "if    ( StUtils . hasText ( sn )  )     {", "setServiceName ( sn )  ;", "}", "}", "if    (  ( getPortName (  )  )     =  =    null )     {", "St   pn    =    ann . portName (  )  ;", "if    ( StUtils . hasText ( pn )  )     {", "setPortName ( pn )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyDefaultsFromAnnotation"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   doInvoke ( invocation ,    getPortStub (  )  )  ;", "}    catch    ( SOAPFaultException   ex )     {", "throw   new   SoapFaultException ( ex )  ;", "}    catch    ( ProtocolException   ex )     {", "throw   new   RemoteConnectFailureException (  (  (  \" Could   not   connect   to   remote   service    [  \"     +     ( getEndpointAddress (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}    catch    ( WebServiceException   ex )     {", "throw   new   RemoteAccessException (  (  (  \" Could   not   access   remote   service   at    [  \"     +     ( getEndpointAddress (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    invocation . getMethod (  )  ;", "try    {", "return   method . invoke ( portStub ,    invocation . getArguments (  )  )  ;", "}    catch    ( InvocationTargetExion   ex )     {", "throw   ex . getTargetExion (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   RemoteProxyFailureExion (  (  \" Invocation   of   stub   method   failed :     \"     +    method )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . beanClassLoader ;", "}", "METHOD_END"], "methodName": ["getBeanClassLoader"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . customProperties )     =  =    null )     {", "this . customProperties    =    new   HashMap <  >  (  )  ;", "}", "return   this . customProperties ;", "}", "METHOD_END"], "methodName": ["getCustomProperties"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . endpointAddress ;", "}", "METHOD_END"], "methodName": ["getEndpointAddress"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . jaxWsService ;", "}", "METHOD_END"], "methodName": ["getJaxWsService"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . portName ;", "}", "METHOD_END"], "methodName": ["getPortName"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . portQName ;", "}", "METHOD_END"], "methodName": ["getPortQName"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . portStub ;", "}", "METHOD_END"], "methodName": ["getPortStub"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . portFeatures )     !  =    null )     {", "return   portQName    !  =    null    ?    service . getPort ( portQName ,    getServiceface (  )  ,    this . portFeatures )     :    service . getPort ( getServiceface (  )  ,    this . portFeatures )  ;", "} else    {", "return   portQName    !  =    null    ?    service . getPort ( portQName ,    getServiceface (  )  )     :    service . getPort ( getServiceface (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPortStub"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . serviceInterface ;", "}", "METHOD_END"], "methodName": ["getServiceInterface"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . soapActionUri ;", "}", "METHOD_END"], "methodName": ["getSoapActionUri"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . username ;", "}", "METHOD_END"], "methodName": ["getUsername"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . maintainSession ;", "}", "METHOD_END"], "methodName": ["isMaintainSession"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . preparationMonitor )     {", "return    ( this . portStub )     !  =    null ;", "}", "}", "METHOD_END"], "methodName": ["isPrepared"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . useSoapAction ;", "}", "METHOD_END"], "methodName": ["isUseSoapAction"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    ifc    =    getServiceInterface (  )  ;", "Assert . notNull ( ifc ,     \" Property    ' serviceInterface '    is   required \"  )  ;", "WebService   ann    =    ifc . getAnnotation ( WebService . class )  ;", "if    ( ann    !  =    null )     {", "applyDefaultsFromAnnotation ( ann )  ;", "}", "Service   serviceToUse    =    getJaxWsService (  )  ;", "if    ( serviceToUse    =  =    null )     {", "serviceToUse    =    createJaxWsService (  )  ;", "}", "this . portQName    =    getQName (  (  ( getPortName (  )  )     !  =    null    ?    getPortName (  )     :    ifc . getName (  )  )  )  ;", "Object   stub    =    getPortStub ( serviceToUse ,     (  ( getPortName (  )  )     !  =    null    ?    this . portQName    :    null )  )  ;", "preparePortStub ( stub )  ;", "this . portStub    =    stub ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    stubProperties    =    new   HashMap <  >  (  )  ;", "String   username    =    getUsername (  )  ;", "if    ( username    !  =    null )     {", "stubProperties . put ( BindingProvider . USERNAME _ PROPERTY ,    username )  ;", "}", "String   password    =    getPassword (  )  ;", "if    ( password    !  =    null )     {", "stubProperties . put ( BindingProvider . PASSWORD _ PROPERTY ,    password )  ;", "}", "String   endpointAddress    =    getEndpointAddress (  )  ;", "if    ( endpointAddress    !  =    null )     {", "stubProperties . put ( BindingProvider . ENDPOINT _ ADDRESS _ PROPERTY ,    endpointAddress )  ;", "}", "if    ( isMaintainSession (  )  )     {", "stubProperties . put ( BindingProvider . SESSION _ MAINTAIN _ PROPERTY ,    Boolean . TRUE )  ;", "}", "if    ( isUseSoapAction (  )  )     {", "stubProperties . put ( BindingProvider . SOAPACTION _ USE _ PROPERTY ,    Boolean . TRUE )  ;", "}", "String   soapActionUri    =    getSoapActionUri (  )  ;", "if    ( soapActionUri    !  =    null )     {", "stubProperties . put ( BindingProvider . SOAPACTION _ URI _ PROPERTY ,    soapActionUri )  ;", "}", "stubProperties . putAll ( getCustomProperties (  )  )  ;", "if    (  !  ( stubProperties . isEmpty (  )  )  )     {", "if    (  !  ( stub   instanceof   BindingProvider )  )     {", "throw   new   RemoteLookupFailureException (  (  (  \" Port   stub   of   class    [  \"     +     ( stub . getClass (  )  . getName (  )  )  )     +     \"  ]    is   not   a   customizable   JAX - WS   stub :    it   does   not   implement   interface    [ BindingProvider ]  \"  )  )  ;", "}", "(  ( BindingProvider )     ( stub )  )  . getRequestContext (  )  . putAll ( stubProperties )  ;", "}", "}", "METHOD_END"], "methodName": ["preparePortStub"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . customProperties    =    customProperties ;", "}", "METHOD_END"], "methodName": ["setCustomProperties"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . endpointAddress    =    endpointAddress ;", "}", "METHOD_END"], "methodName": ["setEndpointAddress"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . jaxWsService    =    jaxWsService ;", "}", "METHOD_END"], "methodName": ["setJaxWsService"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . lookupServiceOnStartup    =    lookupServiceOnStartup ;", "}", "METHOD_END"], "methodName": ["setLookupServiceOnStartup"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . maintainSession    =    maintainSession ;", "}", "METHOD_END"], "methodName": ["setMaintainSession"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . portFeatures    =    features ;", "}", "METHOD_END"], "methodName": ["setPortFeatures"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . portName    =    portName ;", "}", "METHOD_END"], "methodName": ["setPortName"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( serviceInterface    !  =    null )     {", "Assert . isTrue ( serviceInterface . isInterface (  )  ,     \"  ' serviceInterface '    must   be   an   interface \"  )  ;", "}", "this . serviceInterface    =    serviceInterface ;", "}", "METHOD_END"], "methodName": ["setServiceInterface"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . soapActionUri    =    soapActionUri ;", "}", "METHOD_END"], "methodName": ["setSoapActionUri"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . useSoapAction    =    useSoapAction ;", "}", "METHOD_END"], "methodName": ["setUseSoapAction"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . username    =    username ;", "}", "METHOD_END"], "methodName": ["setUsername"], "fileName": "org.springframework.remoting.jaxws.JaxWsPortClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( SOAPFaultException )     ( getCause (  )  )  )  . getFault (  )  ;", "}", "METHOD_END"], "methodName": ["getFault"], "fileName": "org.springframework.remoting.jaxws.JaxWsSoapFaultException"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "GenericBeanDefinition   serviceDef    =    new   GenericBeanDefinition (  )  ;", "serviceDef . setBeanClass ( OrderServiceImpl . class )  ;", "ac . registerBeanDefinition (  \" service \"  ,    serviceDef )  ;", "GenericBeanDefinition   exporterDef    =    new   GenericBeanDefinition (  )  ;", "exporterDef . setBeanClass ( SimpleJaxWsServiceExporter . class )  ;", "exporterDef . getPropertyValues (  )  . add (  \" baseAddress \"  ,     \" http :  /  / localhost :  9  9  9  9  /  \"  )  ;", "ac . registerBeanDefinition (  \" exporter \"  ,    exporterDef )  ;", "GenericBeanDefinition   clientDef    =    new   GenericBeanDefinition (  )  ;", "clientDef . setBeanClass ( JaxWsPortProxyFactoryBean . class )  ;", "clientDef . getPropertyValues (  )  . add (  \" wsdlDocumentUrl \"  ,     \" http :  /  / localhost :  9  9  9  9  / OrderService ? wsdl \"  )  ;", "clientDef . getPropertyValues (  )  . add (  \" namespaceUri \"  ,     \" http :  /  / jaxws . remotinorg /  \"  )  ;", "clientDef . getPropertyValues (  )  . add (  \" username \"  ,     \" juergen \"  )  ;", "clientDef . getPropertyValues (  )  . add (  \" password \"  ,     \" hoeller \"  )  ;", "clientDef . getPropertyValues (  )  . add (  \" serviceName \"  ,     \" OrderService \"  )  ;", "clientDef . getPropertyValues (  )  . add (  \" serviceInterface \"  ,    OrderService . class )  ;", "clientDef . getPropertyValues (  )  . add (  \" lookupServiceOnStartup \"  ,    Boolean . FALSE )  ;", "if    ( features    !  =    null )     {", "clientDef . getPropertyValues (  )  . add (  \" portFeatures \"  ,    features )  ;", "}", "ac . registerBeanDefinition (  \" client \"  ,    clientDef )  ;", "GenericBeanDefinition   serviceFactoryDef    =    new   GenericBeanDefinition (  )  ;", "serviceFactoryDef . setBeanClass ( LocalJaxWsServiceFactoryBean . class )  ;", "serviceFactoryDef . getPropertyValues (  )  . add (  \" wsdlDocumentUrl \"  ,     \" http :  /  / localhost :  9  9  9  9  / OrderService ? wsdl \"  )  ;", "serviceFactoryDef . getPropertyValues (  )  . add (  \" namespaceUri \"  ,     \" http :  /  / jaxws . remotinorg /  \"  )  ;", "serviceFactoryDef . getPropertyValues (  )  . add (  \" serviceName \"  ,     \" OrderService \"  )  ;", "ac . registerBeanDefinition (  \" orderService \"  ,    serviceFactoryDef )  ;", "ac . registerBeanDefinition (  \" accessor \"  ,    new   RootBeanDefinition ( JaxWsSupportTests . ServiceAccessor . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ac )  ;", "try    {", "ac . refresh (  )  ;", "OrderService   orderService    =    ac . getBean (  \" client \"  ,    OrderService . class )  ;", "assertTrue (  ( orderService   instanceof   BindingProvider )  )  ;", "(  ( BindingProvider )     ( orderService )  )  . getRequestContext (  )  ;", "String   order    =    orderService . getOrder (  1  0  0  0  )  ;", "assertEquals (  \" order    1  0  0  0  \"  ,    order )  ;", "try    {", "orderService . getOrder (  0  )  ;", "fail (  \" Should   have   thrown   OrderNotFoundException \"  )  ;", "}    catch    ( OrderNotFoundException   ex )     {", "}    catch    ( RemoteAccessException   ex )     {", "}", "JaxWsSupportTests . ServiceAccessor   serviceAccessor    =    ac . getBean (  \" accessor \"  ,    JaxWsSupportTests . ServiceAccessor . class )  ;", "order    =    serviceAccessor . orderService . getOrder (  1  0  0  0  )  ;", "assertEquals (  \" order    1  0  0  0  \"  ,    order )  ;", "try    {", "serviceAccessor . orderService . getOrder (  0  )  ;", "fail (  \" Should   have   thrown   OrderNotFoundException \"  )  ;", "}    catch    ( OrderNotFoundException   ex )     {", "}    catch    ( WebServiceException   ex )     {", "}", "}    catch    ( BeanCreationException   ex )     {", "if    (  (  \" exporter \"  . equals ( ex . getBeanName (  )  )  )     &  &     (  ( ex . getRootCause (  )  )    instanceof   ClassNotFoundException )  )     {", "} else    {", "throw   ex ;", "}", "}    finally    {", "ac . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestJaxWsPortAccess"], "fileName": "org.springframework.remoting.jaxws.JaxWsSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestJaxWsPortAccess (  (  ( WebServiceFeature [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["testJaxWsPortAccess"], "fileName": "org.springframework.remoting.jaxws.JaxWsSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestJaxWsPortAccess ( new   AddressingFeature (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJaxWsPortAccessWithFeature"], "fileName": "org.springframework.remoting.jaxws.JaxWsSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . serviceName ,     \" No   service   name   specified \"  )  ;", "service ;", "if    (  ( this . serviceFeatures )     !  =    null )     {", "service    =     (  ( this . wsdlDocumentUrl )     !  =    null )     ?     . create ( this . wsdlDocumentUrl ,    getQName ( this . serviceName )  ,    this . serviceFeatures )     :     . create ( getQName ( this . serviceName )  ,    this . serviceFeatures )  ;", "} else    {", "service    =     (  ( this . wsdlDocumentUrl )     !  =    null )     ?     . create ( this . wsdlDocumentUrl ,    getQName ( this . serviceName )  )     :     . create ( getQName ( this . serviceName )  )  ;", "}", "if    (  ( this . executor )     !  =    null )     {", "service . setExecutor ( this . executor )  ;", "}", "if    (  ( this . handlerResolver )     !  =    null )     {", "service . setHandlerResolver ( this . handlerResolver )  ;", "}", "return   service ;", "}", "METHOD_END"], "methodName": ["createJaxWsService"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . namespaceUri ;", "}", "METHOD_END"], "methodName": ["getNamespaceUri"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( getNamespaceUri (  )  )     !  =    null    ?    new   QName ( getNamespaceUri (  )  ,    name )     :    new   QName ( name )  ;", "}", "METHOD_END"], "methodName": ["getQName"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . serviceName ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . wsdlDocumentUrl ;", "}", "METHOD_END"], "methodName": ["getWsdlDocumentUrl"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "this . executor    =    executor ;", "}", "METHOD_END"], "methodName": ["setExecutor"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "this . handlerResolver    =    handlerResolver ;", "}", "METHOD_END"], "methodName": ["setHandlerResolver"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "this . namespaceUri    =     ( namespaceUri    !  =    null )     ?    namespaceUri . trim (  )     :    null ;", "}", "METHOD_END"], "methodName": ["setNamespaceUri"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "this . serviceFeatures    =    serviceFeatures ;", "}", "METHOD_END"], "methodName": ["setServiceFeatures"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "this . serviceName    =    serviceName ;", "}", "METHOD_END"], "methodName": ["setServiceName"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( wsdlDocumentResource ,     \" WSDL   Resource   must   not   be   null \"  )  ;", "this . wsdlDocumentUrl    =    wsdlDocumentResource . getURL (  )  ;", "}", "METHOD_END"], "methodName": ["setWsdlDocumentResource"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "this . wsdlDocumentUrl    =    wsdlDocumentUrl ;", "}", "METHOD_END"], "methodName": ["setWsdlDocumentUrl"], "fileName": "org.springframework.remoting.jaxws.LocalJaxWsServiceFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . faultInfo ;", "}", "METHOD_END"], "methodName": ["getFaultInfo"], "fileName": "org.springframework.remoting.jaxws.OrderNotFoundException"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . server )     !  =    null )  ,     \" No   HttpServer   available \"  )  ;", "String   fullPath    =    calculateEndpointPath ( endpoint ,    serviceName )  ;", "HttpContext   httpContext    =    this . server . createContext ( fullPath )  ;", "if    (  ( this . filters )     !  =    null )     {", "httpContext . getFilters (  )  . addAll ( this . filters )  ;", "}", "if    (  ( this . authenticator )     !  =    null )     {", "httpContext . setAuthenticator ( this . authenticator )  ;", "}", "return   httpContext ;", "}", "METHOD_END"], "methodName": ["buildHttpContext"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . basePath )     +    serviceName ;", "}", "METHOD_END"], "methodName": ["calculateEndpointPath"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . authenticator    =    authenticator ;", "}", "METHOD_END"], "methodName": ["setAuthenticator"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . backlog    =    backlog ;", "}", "METHOD_END"], "methodName": ["setBacklog"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . basePath    =    basePath ;", "}", "METHOD_END"], "methodName": ["setBasePath"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . filters    =    filters ;", "}", "METHOD_END"], "methodName": ["setFilters"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . hostname    =    hostname ;", "}", "METHOD_END"], "methodName": ["setHostname"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . port    =    port ;", "}", "METHOD_END"], "methodName": ["setPort"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . server    =    server ;", "}", "METHOD_END"], "methodName": ["setServer"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . shutdownDelay    =    shutdownDelay ;", "}", "METHOD_END"], "methodName": ["setShutdownDelay"], "fileName": "org.springframework.remoting.jaxws.SimpleHttpServerJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "String   fullAddress    =     ( this . baseAddress )     +    serviceName ;", "if    ( endpoint . getClass (  )  . getName (  )  . startsWith (  \" weblogic .  \"  )  )     {", "fullAddress    =    fullAddress    +     \"  /  \"  ;", "}", "return   fullAddress ;", "}", "METHOD_END"], "methodName": ["calculateEndpointAddress"], "fileName": "org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . baseAddress    =    baseAddress ;", "}", "METHOD_END"], "methodName": ["setBaseAddress"], "fileName": "org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter"}, {"methodBody": ["METHOD_START", "{", "return   this . supportedMediaTypes ;", "}", "METHOD_END"], "methodName": ["getSupportedMediaTypes"], "fileName": "org.springframework.web.HttpMediaTypeException"}, {"methodBody": ["METHOD_START", "{", "return   this . contentType ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.web.HttpMediaTypeNotSupportedException"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.web.HttpRequestMethodNotSupportedException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . supportedMethods )     =  =    null )     {", "return   null ;", "}", "List < HttpMethod >    supportedMethods    =    new   LinkedList <  >  (  )  ;", "for    ( String   value    :    this . supportedMethods )     {", "HttpMethod   resolved    =    HttpMethod . resolve ( value )  ;", "if    ( resolved    !  =    null )     {", "supportedMethods . add ( resolved )  ;", "}", "}", "return   EnumSet . copyOf ( supportedMethods )  ;", "}", "METHOD_END"], "methodName": ["getSupportedHttpMethods"], "fileName": "org.springframework.web.HttpRequestMethodNotSupportedException"}, {"methodBody": ["METHOD_START", "{", "return   this . supportedMethods ;", "}", "METHOD_END"], "methodName": ["getSupportedMethods"], "fileName": "org.springframework.web.HttpRequestMethodNotSupportedException"}, {"methodBody": ["METHOD_START", "{", "return   this . expectedAttribute ;", "}", "METHOD_END"], "methodName": ["getExpectedAttribute"], "fileName": "org.springframework.web.HttpSessionRequiredException"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isTraceEnabled (  )  )     {", "logger . e (  (  (  (  (  \" Requested   MediaType =  '  \"     +    mediaType )     +     \"  '    based   on   key =  '  \"  )     +    key )     +     \"  '  .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleMatch"], "fileName": "org.springframework.web.accept.AbstractMappingContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isUseRegisteredExtensionsOnly (  )  )  )     {", "Optional < MediaType >    mediaType    =    MediaTypeFactory . getMediaType (  (  \" file .  \"     +    key )  )  ;", "if    ( mediaType . isPresent (  )  )     {", "return   mediaType . get (  )  ;", "}", "}", "if    ( isIgnoreUnknownExtensions (  )  )     {", "return   null ;", "}", "throw   new   HttpMediaTypeNotAableException ( getAllMediaTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleNoMatch"], "fileName": "org.springframework.web.accept.AbstractMappingContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   this . ignoreUnknownExtensions ;", "}", "METHOD_END"], "methodName": ["isIgnoreUnknownExtensions"], "fileName": "org.springframework.web.accept.AbstractMappingContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   this . useRegisteredExtensionsOnly ;", "}", "METHOD_END"], "methodName": ["isUseRegisteredExtensionsOnly"], "fileName": "org.springframework.web.accept.AbstractMappingContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( key )  )     {", "MediaType   mediaType    =    lookupMediaType ( key )  ;", "if    ( mediaType    !  =    null )     {", "handleMatch ( key ,    mediaType )  ;", "return   Collections . singletonList ( mediaType )  ;", "}", "mediaType    =    handleNoMatch ( webRequest ,    key )  ;", "if    ( mediaType    !  =    null )     {", "addMapping ( key ,    mediaType )  ;", "return   Collections . singletonList ( mediaType )  ;", "}", "}", "return    . MEDIA _ TYPE _ ALL _ LIST ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypeKey"], "fileName": "org.springframework.web.accept.AbstractMappingContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "this . ignoreUnknownExtensions    =    ignoreUnknownExtensions ;", "}", "METHOD_END"], "methodName": ["setIgnoreUnknownExtensions"], "fileName": "org.springframework.web.accept.AbstractMappingContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "this . useRegisteredExtensionsOnly    =    useRegisteredExtensionsOnly ;", "}", "METHOD_END"], "methodName": ["setUseRegisteredExtensionsOnly"], "fileName": "org.springframework.web.accept.AbstractMappingContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "Collections . addAll ( this . resolvers ,    resolvers )  ;", "}", "METHOD_END"], "methodName": ["addFileExtensionResolvers"], "fileName": "org.springframework.web.accept.ContentNegotiationManager"}, {"methodBody": ["METHOD_START", "{", "return   this . strategies ;", "}", "METHOD_END"], "methodName": ["getStrategies"], "fileName": "org.springframework.web.accept.ContentNegotiationManager"}, {"methodBody": ["METHOD_START", "{", "for    ( ContentNegotiationStrategy   strategy    :    getStrategies (  )  )     {", "if    ( strategyType . isInstance ( strategy )  )     {", "return    (  ( T )     ( strategy )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getStrategy"], "fileName": "org.springframework.web.accept.ContentNegotiationManager"}, {"methodBody": ["METHOD_START", "{", "this . mediaTypes . put ( fileExtension ,    mediaType )  ;", "}", "METHOD_END"], "methodName": ["addMediaType"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( mediaTypes    !  =    null )     {", "this . mediaTypes . putAll ( mediaTypes )  ;", "}", "}", "METHOD_END"], "methodName": ["addMediaTypes"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "List < ContentNegotiationStrategy >    strategies    =    new   ArrayList <  >  (  )  ;", "if    (  ( this . strategies )     !  =    null )     {", "strategies . addAll ( this . strategies )  ;", "} else    {", "if    ( this . favorPathExtension )     {", "PathExtensionContentNegotiationStrategy   strategy ;", "if    (  (  ( this . servletContext )     !  =    null )     &  &     (  !  ( useRegisteredExtensionsOnly (  )  )  )  )     {", "strategy    =    new   ServletPathExtensionContentNegotiationStrategy ( this . servletContext ,    this . mediaTypes )  ;", "} else    {", "strategy    =    new   PathExtensionContentNegotiationStrategy ( this . mediaTypes )  ;", "}", "strategy . setIgnoreUnknownExtensions ( this . ignoreUnknownPathExtensions )  ;", "if    (  ( this . useRegisteredExtensionsOnly )     !  =    null )     {", "strategy . setUseRegisteredExtensionsOnly ( this . useRegisteredExtensionsOnly )  ;", "}", "strategies . add ( strategy )  ;", "}", "if    ( this . favorParameter )     {", "ParameterContentNegotiationStrategy   strategy    =    new   ParameterContentNegotiationStrategy ( this . mediaTypes )  ;", "strategy . setParameterName ( this . parameterName )  ;", "if    (  ( this . useRegisteredExtensionsOnly )     !  =    null )     {", "strategy . setUseRegisteredExtensionsOnly ( this . useRegisteredExtensionsOnly )  ;", "} else    {", "strategy . setUseRegisteredExtensionsOnly ( true )  ;", "}", "strategies . add ( strategy )  ;", "}", "if    (  !  ( this . ignoreAcceptHeader )  )     {", "strategies . add ( new   HeaderContentNegotiationStrategy (  )  )  ;", "}", "if    (  ( this . defaultNegotiationStrategy )     !  =    null )     {", "strategies . add ( this . defaultNegotiationStrategy )  ;", "}", "}", "this . contentNegotiationManager    =    new    ( strategies )  ;", "return   this . contentNegotiationManager ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . defaultNegotiationStrategy    =    new   FixedContentNegotiationStrategy ( contentType )  ;", "}", "METHOD_END"], "methodName": ["setDefaultContentType"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . defaultNegotiationStrategy    =    strategy ;", "}", "METHOD_END"], "methodName": ["setDefaultContentTypeStrategy"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . defaultNegotiationStrategy    =    new   FixedContentNegotiationStrategy ( contentTypes )  ;", "}", "METHOD_END"], "methodName": ["setDefaultContentTypes"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . favorParameter    =    favorParameter ;", "}", "METHOD_END"], "methodName": ["setFavorParameter"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . favorPathExtension    =    favorPathExtension ;", "}", "METHOD_END"], "methodName": ["setFavorPathExtension"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . ignoreAcceptHeader    =    ignoreAcceptHeader ;", "}", "METHOD_END"], "methodName": ["setIgnoreAcceptHeader"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . ignoreUnknownPathExtensions    =    ignore ;", "}", "METHOD_END"], "methodName": ["setIgnoreUnknownPathExtensions"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( mediaTypes )  )  )     {", "mediaTypes . forEach (  (    key ,    value )     -  >     {", "String   extension    =     (  ( String )     ( key )  )  . toLowerCase ( Locale . ENGLISH )  ;", "MediaType   mediaType    =    MediaType . valueOf (  (  ( String )     ( value )  )  )  ;", "this . mediaTypes . put ( extension ,    mediaType )  ;", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["setMediaTypes"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( parameterName ,     \" parameterName   is   required \"  )  ;", "this . parameterName    =    parameterName ;", "}", "METHOD_END"], "methodName": ["setParameterName"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . strategies    =     ( strategies    !  =    null )     ?    new   ArrayList <  >  ( strategies )     :    null ;", "}", "METHOD_END"], "methodName": ["setStrategies"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "setUseRegisteredExtensionsOnly (  (  ! useJaf )  )  ;", "}", "METHOD_END"], "methodName": ["setUseJaf"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . useRegisteredExtensionsOnly    =    useRegisteredExtensionsOnly ;", "}", "METHOD_END"], "methodName": ["setUseRegisteredExtensionsOnly"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . useRegisteredExtensionsOnly )     !  =    null )     &  &     ( this . useRegisteredExtensionsOnly )  ;", "}", "METHOD_END"], "methodName": ["useRegisteredExtensionsOnly"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "this . servletRequest . setRequestURI (  \"  / flower . gif \"  )  ;", "assertEquals (  \" Should   be   able   to   resolve   file   extensions   by   default \"  ,    Collections . singletonList ( MediaType . IMAGE _ GIF )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "this . servletRequest . setRequestURI (  \"  / flower . foobarbaz \"  )  ;", "assertEquals (  \" Should   ignore   unknown   extensions   by   default \"  ,    ContentNegotiationStrategy . MEDIA _ TYPE _ ALL _ LIST ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "this . servletRequest . setRequestURI (  \"  / flower \"  )  ;", "this . servletRequest . setParameter (  \" format \"  ,     \" gif \"  )  ;", "assertEquals (  \" Should   not   resolve   request   parameters   by   default \"  ,    ContentNegotiationStrategy . MEDIA _ TYPE _ ALL _ LIST ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "this . servletRequest . setRequestURI (  \"  / flower \"  )  ;", "this . servletRequest . addHeader (  \" Accept \"  ,    MediaType . IMAGE _ GIF _ VALUE )  ;", "assertEquals (  \" Should   resolve   Accept   header   by   default \"  ,    Collections . singletonList ( MediaType . IMAGE _ GIF )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["defaultSettings"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MediaType >    mediaTypes    =    Collections . singletonMap (  \" bar \"  ,    new   MediaType (  \" application \"  ,     \" bar \"  )  )  ;", "ParameterContentNegotiationStrategy   strategy 1     =    new   ParameterContentNegotiationStrategy ( mediaTypes )  ;", "HeaderContentNegotiationStrategy   strategy 2     =    new   HeaderContentNegotiationStrategy (  )  ;", "List < ContentNegotiationStrategy >    strategies    =    Arrays . asList ( strategy 1  ,    strategy 2  )  ;", "this . factoryBean . setStrategies ( strategies )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "assertEquals ( strategies ,    manager . getStrategies (  )  )  ;", "this . servletRequest . setRequestURI (  \"  / flower \"  )  ;", "this . servletRequest . addParameter (  \" format \"  ,     \" bar \"  )  ;", "assertEquals ( Collections . singletonList ( new   MediaType (  \" application \"  ,     \" bar \"  )  )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["explicitStrategies"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factoryBean . setFavorParameter ( true )  ;", "Map < String ,    MediaType >    mediaTypes    =    new   HashMap <  >  (  )  ;", "mediaTypes . put (  \" json \"  ,    MediaType . APPLICATION _ JSON )  ;", "this . factoryBean . addMediaTypes ( mediaTypes )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "this . servletRequest . setRequestURI (  \"  / flower \"  )  ;", "this . servletRequest . addParameter (  \" format \"  ,     \" json \"  )  ;", "assertEquals ( Collections . singletonList ( MediaType . APPLICATION _ JSON )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["favorParameter"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factoryBean . setFavorParameter ( true )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "this . servletRequest . setRequestURI (  \"  / flower \"  )  ;", "this . servletRequest . setParameter (  \" format \"  ,     \" invalid \"  )  ;", "manager . resolveMediaTypes ( this . webRequest )  ;", "}", "METHOD_END"], "methodName": ["favorParameterWithUnknownMediaType"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factoryBean . setFavorPathExtension ( true )  ;", "this . factoryBean . addMediaTypes ( Collections . singletonMap (  \" bar \"  ,    new   MediaType (  \" application \"  ,     \" bar \"  )  )  )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "this . servletRequest . setRequestURI (  \"  / flower . foo \"  )  ;", "assertEquals ( Collections . singletonList ( new   MediaType (  \" application \"  ,     \" foo \"  )  )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "this . servletRequest . setRequestURI (  \"  / flower . bar \"  )  ;", "assertEquals ( Collections . singletonList ( new   MediaType (  \" application \"  ,     \" bar \"  )  )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "this . servletRequest . setRequestURI (  \"  / flower . gif \"  )  ;", "assertEquals ( Collections . singletonList ( MediaType . IMAGE _ GIF )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["favorPath"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factoryBean . setFavorPathExtension ( true )  ;", "this . factoryBean . setIgnoreUnknownPathExtensions ( false )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "this . servletRequest . setRequestURI (  \"  / flower . foobarbaz \"  )  ;", "this . servletRequest . addParameter (  \" format \"  ,     \" json \"  )  ;", "manager . resolveMediaTypes ( this . webRequest )  ;", "}", "METHOD_END"], "methodName": ["favorPathWithIgnoreUnknownPathExtensionTurnedOff"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factoryBean . setIgnoreAcceptHeader ( true )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "this . servletRequest . setRequestURI (  \"  / flower \"  )  ;", "this . servletRequest . addHeader (  \" Accept \"  ,    MediaType . IMAGE _ GIF _ VALUE )  ;", "assertEquals ( ContentNegotiationStrategy . MEDIA _ TYPE _ ALL _ LIST ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["ignoreAcceptHeader"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factoryBean . setDefaultContentType ( MediaType . APPLICATION _ JSON )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON ,    manager . resolveMediaTypes ( this . webRequest )  . get (  0  )  )  ;", "this . servletRequest . addHeader (  \" Accept \"  ,    MediaType . ALL _ VALUE )  ;", "assertEquals ( MediaType . APPLICATION _ JSON ,    manager . resolveMediaTypes ( this . webRequest )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultContentType"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factoryBean . setDefaultContentTypeStrategy ( new   FixedContentNegotiationStrategy ( MediaType . APPLICATION _ JSON )  )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "assertEquals ( Collections . singletonList ( MediaType . APPLICATION _ JSON )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "this . servletRequest . addHeader (  \" Accept \"  ,    MediaType . ALL _ VALUE )  ;", "assertEquals ( Collections . singletonList ( MediaType . APPLICATION _ JSON )  ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultContentTypeWithStrategy"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "List < MediaType >    mediaTypes    =    Arrays . asList ( MediaType . APPLICATION _ JSON ,    MediaType . ALL )  ;", "this . factoryBean . setDefaultContentTypes ( mediaTypes )  ;", "this . factoryBean . afterPropertiesSet (  )  ;", "manager    =    this . factoryBean . getObject (  )  ;", "assertEquals ( mediaTypes ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "this . servletRequest . addHeader (  \" Accept \"  ,    MediaType . ALL _ VALUE )  ;", "assertEquals ( mediaTypes ,    manager . resolveMediaTypes ( this . webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultContentTypes"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ContentNegotiationManagerFactoryBeanTests . TestServletContext   servletContext    =    new   ContentNegotiationManagerFactoryBeanTests . TestServletContext (  )  ;", "servletContext . getMimeTypes (  )  . put (  \" foo \"  ,     \" application / foo \"  )  ;", "this . servletRequest    =    new   MockHttpServletRequest ( servletContext )  ;", "this . webRequest    =    new   ServletWebRequest ( this . servletRequest )  ;", "this . factoryBean    =    new   ContentNegotiationManagerFactoryBean (  )  ;", "this . factoryBean . setServletContext ( this . servletRequest . getServletContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.accept.ContentNegotiationManagerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   this . contentTypes ;", "}", "METHOD_END"], "methodName": ["getContentTypes"], "fileName": "org.springframework.web.accept.FixedContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . addHeader (  \" Accept \"  ,     \" text / plain ;    q =  0  .  5  ,    text / html ,    text / x - dvi ;    q =  0  .  8  ,    text / x - c \"  )  ;", "List < MediaType >    mediaTypes    =    this . s . resolveMediaTypes ( this . webRequest )  ;", "assertEquals (  4  ,    mediaTypes . size (  )  )  ;", "assertEquals (  \" text / html \"  ,    mediaTypes . get (  0  )  . toString (  )  )  ;", "assertEquals (  \" text / x - c \"  ,    mediaTypes . get (  1  )  . toString (  )  )  ;", "assertEquals (  \" text / x - dvi ; q =  0  .  8  \"  ,    mediaTypes . get (  2  )  . toString (  )  )  ;", "assertEquals (  \" text / plain ; q =  0  .  5  \"  ,    mediaTypes . get (  3  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypes"], "fileName": "org.springframework.web.accept.HeaderContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . addHeader (  \" Accept \"  ,     \" text / plain ;    q =  0  .  5  ,    text / html \"  )  ;", "this . servletRequest . addHeader (  \" Accept \"  ,     \" text / x - dvi ;    q =  0  .  8  ,    text / x - c \"  )  ;", "List < MediaType >    mediaTypes    =    this . s . resolveMediaTypes ( this . webRequest )  ;", "assertEquals (  4  ,    mediaTypes . size (  )  )  ;", "assertEquals (  \" text / html \"  ,    mediaTypes . get (  0  )  . toString (  )  )  ;", "assertEquals (  \" text / x - c \"  ,    mediaTypes . get (  1  )  . toString (  )  )  ;", "assertEquals (  \" text / x - dvi ; q =  0  .  8  \"  ,    mediaTypes . get (  2  )  . toString (  )  )  ;", "assertEquals (  \" text / plain ; q =  0  .  5  \"  ,    mediaTypes . get (  3  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesFromMultipleHeaderValues"], "fileName": "org.springframework.web.accept.HeaderContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . addHeader (  \" Accept \"  ,     \" textplain ;    q =  0  .  5  \"  )  ;", "this . s . resolveMediaTypes ( this . webRequest )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesParseError"], "fileName": "org.springframework.web.accept.HeaderContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MediaType >    mapping    =    Collections . singletonMap (  \" json \"  ,    MediaType . APPLICATION _ JSON )  ;", ". TestMappingContentNegotiationStrategy   strategy    =    new    . TestMappingContentNegotiationStrategy (  \" json \"  ,    mapping )  ;", "List < MediaType >    mediaTypes    =    strategy . resolveMediaTypes ( null )  ;", "assertEquals (  1  ,    mediaTypes . size (  )  )  ;", "assertEquals (  \" application / json \"  ,    mediaTypes . get (  0  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypes"], "fileName": "org.springframework.web.accept.MappingContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MediaType >    mapping    =    null ;", ". TestMappingContentNegotiationStrategy   strategy    =    new    . TestMappingContentNegotiationStrategy (  \" xml \"  ,    mapping )  ;", "List < MediaType >    mediaTypes    =    strategy . resolveMediaTypes ( null )  ;", "assertEquals (  1  ,    mediaTypes . size (  )  )  ;", "assertEquals (  \" application / xml \"  ,    mediaTypes . get (  0  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesHandleNoMatch"], "fileName": "org.springframework.web.accept.MappingContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MediaType >    mapping    =    Collections . singletonMap (  \" json \"  ,    MediaType . APPLICATION _ JSON )  ;", ". TestMappingContentNegotiationStrategy   strategy    =    new    . TestMappingContentNegotiationStrategy ( null ,    mapping )  ;", "List < MediaType >    mediaTypes    =    strategy . resolveMediaTypes ( null )  ;", "assertEquals ( ContentNegotiationStrategy . MEDIA _ TYPE _ ALL _ LIST ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesNoKey"], "fileName": "org.springframework.web.accept.MappingContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MediaType >    mapping    =    null ;", ". TestMappingContentNegotiationStrategy   strategy    =    new    . TestMappingContentNegotiationStrategy (  \" blah \"  ,    mapping )  ;", "List < MediaType >    mediaTypes    =    strategy . resolveMediaTypes ( null )  ;", "assertEquals ( ContentNegotiationStrategy . MEDIA _ TYPE _ ALL _ LIST ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesNoMatch"], "fileName": "org.springframework.web.accept.MappingContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   previous    =    this . mediaTypes . putIfAbsent ( extension ,    mediaType )  ;", "if    ( previous    =  =    null )     {", "this . fileExtensions . add ( mediaType ,    extension )  ;", "this . alls . add ( extension )  ;", "}", "}", "METHOD_END"], "methodName": ["addMapping"], "fileName": "org.springframework.web.accept.MappingMediaTypeFileExtensionResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  ( this . mediaTypes . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllMediaTypes"], "fileName": "org.springframework.web.accept.MappingMediaTypeFileExtensionResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . mediaTypes ;", "}", "METHOD_END"], "methodName": ["getMediaTypes"], "fileName": "org.springframework.web.accept.MappingMediaTypeFileExtensionResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . mediaTypes . get ( extension . toLowerCase ( Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["lookupMediaType"], "fileName": "org.springframework.web.accept.MappingMediaTypeFileExtensionResolver"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MediaType >    mapping    =    Collections . singletonMap (  \" json \"  ,    MediaType . APPLICATION _ JSON )  ;", "resolver    =    new    ( mapping )  ;", "MediaType   mediaType    =    resolver . lookupMediaType (  \" JSON \"  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON ,    mediaType )  ;", "}", "METHOD_END"], "methodName": ["lookupMediaTypeCaseInsensitive"], "fileName": "org.springframework.web.accept.MappingMediaTypeFileExtensionResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MediaType >    mapping    =    Collections . singletonMap (  \" json \"  ,    MediaType . APPLICATION _ JSON )  ;", "resolver    =    new    ( mapping )  ;", "List < String >    extensions    =    resolver . resolveFileExtensions ( MediaType . APPLICATION _ JSON )  ;", "assertEquals (  1  ,    extensions . size (  )  )  ;", "assertEquals (  \" json \"  ,    extensions . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveExtensions"], "fileName": "org.springframework.web.accept.MappingMediaTypeFileExtensionResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MediaType >    mapping    =    Collections . singletonMap (  \" json \"  ,    MediaType . APPLICATION _ JSON )  ;", "resolver    =    new    ( mapping )  ;", "List < String >    extensions    =    resolver . resolveFileExtensions ( MediaType . TEXT _ HTML )  ;", "assertTrue ( extensions . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveExtensionsNoMatch"], "fileName": "org.springframework.web.accept.MappingMediaTypeFileExtensionResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterName ;", "}", "METHOD_END"], "methodName": ["getParameterName"], "fileName": "org.springframework.web.accept.ParameterContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( parameterName ,     \"  ' parameterName '    is   required \"  )  ;", "this . parameterName    =    parameterName ;", "}", "METHOD_END"], "methodName": ["setParameterName"], "fileName": "org.springframework.web.accept.ParameterContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resource ,     \" Resource   must   not   be   null \"  )  ;", "MediaType   mediaType    =    null ;", "String   filename    =    resource . getFilename (  )  ;", "String   extension    =    StringUtils . getFilename ( filename )  ;", "if    ( extension    !  =    null )     {", "mediaType    =    lookupMediaType ( extension )  ;", "}", "if    ( mediaType    =  =    null )     {", "mediaType    =    MediaTypeFactory . getMediaType ( filename )  . orElse ( null )  ;", "}", "return   mediaType ;", "}", "METHOD_END"], "methodName": ["getMediaTypeForResource"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "this . urlPathHelper    =    urlPathHelper ;", "}", "METHOD_END"], "methodName": ["setUrlPathHelper"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "setUseRegisteredExtensionsOnly (  (  ! useJaf )  )  ;", "}", "METHOD_END"], "methodName": ["setUseJaf"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategy"}, {"methodBody": ["METHOD_START", "{", "PathExtensionContentNegotiationStrategy   strategy    =    new   PathExtensionContentNegotiationStrategy (  )  ;", "this . servletRequest . setContextPath (  \"  / project -  1  .  0  .  0  . M 3  \"  )  ;", "this . servletRequest . setRequestURI (  \"  / project -  1  .  0  .  0  . M 3  /  \"  )  ;", "assertEquals (  \" Context   path   should   be   excluded \"  ,    ContentNegotiationStrategy . MEDIA _ TYPE _ ALL _ LIST ,    strategy . resolveMediaTypes ( webRequest )  )  ;", "this . servletRequest . setRequestURI (  \"  / project -  1  .  0  .  0  . M 3  \"  )  ;", "assertEquals (  \" Context   path   should   be   excluded \"  ,    ContentNegotiationStrategy . MEDIA _ TYPE _ ALL _ LIST ,    strategy . resolveMediaTypes ( webRequest )  )  ;", "}", "METHOD_END"], "methodName": ["getMediaTypeFilenameWithContextPath"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setRequestURI (  \"  / quo %  2  0 vadis %  3 f . html \"  )  ;", "strategy    =    new    (  )  ;", "List < MediaType >    result    =    strategy . resolveMediaTypes ( webRequest )  ;", "assertEquals (  \" Invalid   content   type \"  ,    Collections . singletonList ( new   MediaType (  \" text \"  ,     \" html \"  )  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["getMediaTypeFilenameWithEncodedURI"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setRequestURI (  \" test . foobar \"  )  ;", "strategy    =    new    (  )  ;", "strategy . setIgnoreUnknownExtensions ( false )  ;", "strategy . resolveMediaTypes ( this . webRequest )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesDoNotIgnoreUnknownExtension"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setRequestURI (  \" test . html \"  )  ;", "strategy    =    new    (  )  ;", "List < MediaType >    mediaTypes    =    strategy . resolveMediaTypes ( this . webRequest )  ;", "assertEquals ( Arrays . asList ( new   MediaType (  \" text \"  ,     \" html \"  )  )  ,    mediaTypes )  ;", "Map < String ,    MediaType >    mapping    =    Collections . singletonMap (  \" HTML \"  ,    MediaType . APPLICATION _ XHTML _ XML )  ;", "strategy    =    new    ( mapping )  ;", "mediaTypes    =    strategy . resolveMediaTypes ( this . webRequest )  ;", "assertEquals ( Arrays . asList ( new   MediaType (  \" application \"  ,     \" xhtml + xml \"  )  )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesFromMapping"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setRequestURI (  \" test . xls \"  )  ;", "strategy    =    new    (  )  ;", "List < MediaType >    mediaTypes    =    strategy . resolveMediaTypes ( this . webRequest )  ;", "assertEquals ( Arrays . asList ( new   MediaType (  \" application \"  ,     \" vnd . ms - excel \"  )  )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesFromMediaTypeFactory"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setRequestURI (  \" test . foobar \"  )  ;", "strategy    =    new    (  )  ;", "List < MediaType >    mediaTypes    =    strategy . resolveMediaTypes ( this . webRequest )  ;", "assertEquals ( ContentNegotiationStrategy . MEDIA _ TYPE _ ALL _ LIST ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesIgnoreUnknownExtension"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest    =    new   MockHttpServletRequest (  )  ;", "thisRequest    =    new   ServletWebRequest ( servletRequest )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.accept.PathExtensionContentNegotiationStrategyTests"}, {"methodBody": ["METHOD_START", "{", "if    ( source    =  =    null )     {", "return   null ;", "}", "String   defaultMessage    =    source . getDefaultMessage (  )  ;", "if    ( defaultMessage    !  =    null )     {", "defaultMessage    =    HtmlUtils . html ( defaultMessage )  ;", "}", "if    ( source   instanceof   FieldError )     {", "FieldError   fieldError    =     (  ( FieldError )     ( source )  )  ;", "Object   value    =    fieldError . getRejectedValue (  )  ;", "if    ( value   instanceof   String )     {", "value    =    HtmlUtils . html (  (  ( String )     ( value )  )  )  ;", "}", "return    (  ( T )     ( new   FieldError ( fieldError . getObjectName (  )  ,    fieldError . getField (  )  ,    value ,    fieldError . isBindingFailure (  )  ,    fieldError . getCodes (  )  ,    fieldError . getArguments (  )  ,    defaultMessage )  )  )  ;", "} else    {", "return    (  ( T )     ( new   ObjectError ( source . getObjectName (  )  ,    source . getCodes (  )  ,    source . getArguments (  )  ,    defaultMessage )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["escapeObjectError"], "fileName": "org.springframework.web.bind.EscapedErrors"}, {"methodBody": ["METHOD_START", "{", "List < T >    escaped    =    new   ArrayList <  >  ( source . size (  )  )  ;", "for    ( T   objectError    :    source )     {", "escaped . add ( escapeObjectError ( objectError )  )  ;", "}", "return   escaped ;", "}", "METHOD_END"], "methodName": ["escapeObjectErrors"], "fileName": "org.springframework.web.bind.EscapedErrors"}, {"methodBody": ["METHOD_START", "{", "return   this . source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.web.bind.EscapedErrors"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \" empty    &  \"  )  ;", "Errors   errors    =    new   EscapedErrors ( new   validation . BindException ( tb ,     \" tb \"  )  )  ;", "errors . rejectValue (  \" name \"  ,     \" NAME _ EMPTY    &  \"  ,    null ,     \" message :     &  \"  )  ;", "errors . rejectValue (  \" age \"  ,     \" AGE _ NOT _ SET    < tag >  \"  ,    null ,     \" message :     < tag >  \"  )  ;", "errors . rejectValue (  \" age \"  ,     \" AGE _ NOT _  3  2     < tag >  \"  ,    null ,     \" message :     < tag >  \"  )  ;", "errors . reject (  \" GENERAL _ ERROR    \\  \"     \\  '  \"  ,    null ,     \" message :     \\  \"     \\  '  \"  )  ;", "assertTrue (  \" Correct   errors   flag \"  ,    errors . hasErrors (  )  )  ;", "assertTrue (  \" Correct   number   of   errors \"  ,     (  ( errors . getErrorCount (  )  )     =  =     4  )  )  ;", "assertTrue (  \" Correct   object   name \"  ,     \" tb \"  . equals ( errors . getObjectName (  )  )  )  ;", "assertTrue (  \" Correct   global   errors   flag \"  ,    errors . hasGlobalErrors (  )  )  ;", "assertTrue (  \" Correct   number   of   global   errors \"  ,     (  ( errors . getGlobalErrorCount (  )  )     =  =     1  )  )  ;", "ObjectError   globalError    =    errors . getGlobalError (  )  ;", "String   defaultMessage    =    globalError . getDefaultMessage (  )  ;", "assertTrue (  \" Global   error   message   escaped \"  ,     \" message :     & quot ;     &  #  3  9  ;  \"  . equals ( defaultMessage )  )  ;", "assertTrue (  \" Global   error   code   not   escaped \"  ,     \" GENERAL _ ERROR    \\  \"     \\  '  \"  . equals ( globalError . getCode (  )  )  )  ;", "ObjectError   globalErrorInList    =    errors . getGlobalErrors (  )  . get (  0  )  ;", "assertTrue (  \" Same   global   error   in   list \"  ,    defaultMessage . equals ( globalErrorInList . getDefaultMessage (  )  )  )  ;", "ObjectError   globalErrorInAllList    =    errors . getAllErrors (  )  . get (  3  )  ;", "assertTrue (  \" Same   global   error   in   list \"  ,    defaultMessage . equals ( globalErrorInAllList . getDefaultMessage (  )  )  )  ;", "assertTrue (  \" Correct   field   errors   flag \"  ,    errors . hasFieldErrors (  )  )  ;", "assertTrue (  \" Correct   number   of   field   errors \"  ,     (  ( errors . getFieldErrorCount (  )  )     =  =     3  )  )  ;", "assertTrue (  \" Correct   number   of   field   errors   in   list \"  ,     (  ( errors . getFieldErrors (  )  . size (  )  )     =  =     3  )  )  ;", "FieldError   fieldError    =    errors . getFieldError (  )  ;", "assertTrue (  \" Field   error   code   not   escaped \"  ,     \" NAME _ EMPTY    &  \"  . equals ( fieldError . getCode (  )  )  )  ;", "assertTrue (  \" Field   value   escaped \"  ,     \" empty    & amp ;  \"  . equals ( errors . getFieldValue (  \" name \"  )  )  )  ;", "FieldError   fieldErrorInList    =    errors . getFieldErrors (  )  . get (  0  )  ;", "assertTrue (  \" Same   field   error   in   list \"  ,    fieldError . getDefaultMessage (  )  . equals ( fieldErrorInList . getDefaultMessage (  )  )  )  ;", "assertTrue (  \" Correct   name   errors   flag \"  ,    errors . hasFieldErrors (  \" name \"  )  )  ;", "assertTrue (  \" Correct   number   of   name   errors \"  ,     (  ( errors . getFieldErrorCount (  \" name \"  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   number   of   name   errors   in   list \"  ,     (  ( errors . getFieldErrors (  \" name \"  )  . size (  )  )     =  =     1  )  )  ;", "FieldError   nameError    =    errors . getFieldError (  \" name \"  )  ;", "assertTrue (  \" Name   error   message   escaped \"  ,     \" message :     & amp ;  \"  . equals ( nameError . getDefaultMessage (  )  )  )  ;", "assertTrue (  \" Name   error   code   not   escaped \"  ,     \" NAME _ EMPTY    &  \"  . equals ( nameError . getCode (  )  )  )  ;", "assertTrue (  \" Name   value   escaped \"  ,     \" empty    & amp ;  \"  . equals ( errors . getFieldValue (  \" name \"  )  )  )  ;", "FieldError   nameErrorInList    =    errors . getFieldErrors (  \" name \"  )  . get (  0  )  ;", "assertTrue (  \" Same   name   error   in   list \"  ,    nameError . getDefaultMessage (  )  . equals ( nameErrorInList . getDefaultMessage (  )  )  )  ;", "assertTrue (  \" Correct   age   errors   flag \"  ,    errors . hasFieldErrors (  \" age \"  )  )  ;", "assertTrue (  \" Correct   number   of   age   errors \"  ,     (  ( errors . getFieldErrorCount (  \" age \"  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   number   of   age   errors   in   list \"  ,     (  ( errors . getFieldErrors (  \" age \"  )  . size (  )  )     =  =     2  )  )  ;", "FieldError   ageError    =    errors . getFieldError (  \" age \"  )  ;", "assertTrue (  \" Age   error   message   escaped \"  ,     \" message :     & lt ; tag & gt ;  \"  . equals ( ageError . getDefaultMessage (  )  )  )  ;", "assertTrue (  \" Age   error   code   not   escaped \"  ,     \" AGE _ NOT _ SET    < tag >  \"  . equals ( ageError . getCode (  )  )  )  ;", "assertTrue (  \" Age   value   not   escaped \"  ,    new   Integer (  0  )  . equals ( errors . getFieldValue (  \" age \"  )  )  )  ;", "FieldError   ageErrorInList    =    errors . getFieldErrors (  \" age \"  )  . get (  0  )  ;", "assertTrue (  \" Same   name   error   in   list \"  ,    ageError . getDefaultMessage (  )  . equals ( ageErrorInList . getDefaultMessage (  )  )  )  ;", "FieldError   ageError 2     =    errors . getFieldErrors (  \" age \"  )  . get (  1  )  ;", "assertTrue (  \" Age   error    2    message   escaped \"  ,     \" message :     & lt ; tag & gt ;  \"  . equals ( ageError 2  . getDefaultMessage (  )  )  )  ;", "assertTrue (  \" Age   error    2    code   not   escaped \"  ,     \" AGE _ NOT _  3  2     < tag >  \"  . equals ( ageError 2  . getCode (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEscapedErrors"], "fileName": "org.springframework.web.bind.EscapedErrorsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingResult ;", "}", "METHOD_END"], "methodName": ["getBindingResult"], "fileName": "org.springframework.web.bind.MethodArgumentNotValidException"}, {"methodBody": ["METHOD_START", "{", "return   this . parameter ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.springframework.web.bind.MethodArgumentNotValidException"}, {"methodBody": ["METHOD_START", "{", "return   this . parameter ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.springframework.web.bind.MissingPathVariableException"}, {"methodBody": ["METHOD_START", "{", "return   this . variableName ;", "}", "METHOD_END"], "methodName": ["getVariableName"], "fileName": "org.springframework.web.bind.MissingPathVariableException"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterName ;", "}", "METHOD_END"], "methodName": ["getParameterName"], "fileName": "org.springframework.web.bind.MissingServletRequestParameterException"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterType ;", "}", "METHOD_END"], "methodName": ["getParameterType"], "fileName": "org.springframework.web.bind.MissingServletRequestParameterException"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   mpvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "MultipartRequest   multipartRequest    =    WebUtils . getNativeRequest ( request ,    MultipartRequest . class )  ;", "if    ( multipartRequest    !  =    null )     {", "bindMultipart ( multipartRequest . getMultiFileMap (  )  ,    mpvs )  ;", "}", "addBindValues ( mpvs ,    request )  ;", "doBind ( mpvs )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.springframework.web.bind.ServletRequestDataBinder"}, {"methodBody": ["METHOD_START", "{", "if    ( getBindingResult (  )  . hasErrors (  )  )     {", "throw   new   ServletRequestBindingException (  (  (  \" Errors   binding   onto   object    '  \"     +     ( getBindingResult (  )  . getObjectName (  )  )  )     +     \"  '  \"  )  ,    new   validation . BindException ( getBindingResult (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeNoCatch"], "fileName": "org.springframework.web.bind.ServletRequestDataBinder"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Contains    3  \"  ,     (  ( pvs . getPropertyValues (  )  . length )     =  =     3  )  )  ;", "assertTrue (  \" Contains   forname \"  ,    pvs . contains (  \" forname \"  )  )  ;", "assertTrue (  \" Contains   surname \"  ,    pvs . contains (  \" surname \"  )  )  ;", "assertTrue (  \" Contains   age \"  ,    pvs . contains (  \" age \"  )  )  ;", "assertTrue (  \" Doesn ' t   contain   tory \"  ,     (  !  ( pvs . contains (  \" tory \"  )  )  )  )  ;", "PropertyValue [  ]    ps    =    pvs . getPropertyValues (  )  ;", "Map < St ,    St >    m    =    new   HashMap <  >  (  )  ;", "m . put (  \" forname \"  ,     \" Tony \"  )  ;", "m . put (  \" surname \"  ,     \" Blair \"  )  ;", "m . put (  \" age \"  ,     \"  5  0  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( ps . length )  ;    i +  +  )     {", "Object   val    =    m . get ( ps [ i ]  . getName (  )  )  ;", "assertTrue (  \" Can ' t   have   unexpected   value \"  ,     ( val    !  =    null )  )  ;", "assertTrue (  \" Val   i   st \"  ,     ( val   instanceof   St )  )  ;", "assertTrue (  \" val   matches   expected \"  ,    val . equals ( ps [ i ]  . getValue (  )  )  )  ;", "m . remove ( ps [ i ]  . getName (  )  )  ;", "}", "assertTrue (  \" Map   size   is    0  \"  ,     (  ( m . size (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestTony"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" person \"  )  ;", "binder . registerCustomEditor ( ITestBean . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  )  )  ;", "}", "}  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" spouse \"  ,     \" someValue \"  )  ;", "request . addParameter (  \" spouse . name \"  ,     \" test \"  )  ;", "binder . bind ( request )  ;", "assertNotNull ( tb . getSpouse (  )  )  ;", "assertEquals (  \" test \"  ,    tb . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithNestedObjectCreation"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" person \"  )  ;", "binder . registerCustomEditor ( ITestBean . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  )  )  ;", "}", "}  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" spouse . name \"  ,     \" test \"  )  ;", "request . addParameter (  \" spouse \"  ,     \" someValue \"  )  ;", "binder . bind ( request )  ;", "assertNotNull ( tb . getSpouse (  )  )  ;", "assertEquals (  \" test \"  ,    tb . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithNestedObjectCreationAndWrongOrder"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  ! postProcessed \"  ,     \" off \"  )  ;", "request . addParameter (  \" postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( request )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \" postProcessed \"  )  ;", "binder . bind ( request )  ;", "assertFalse ( target . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefault"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  ! name \"  ,     \" anonymous \"  )  ;", "request . addParameter (  \" name \"  ,     \" Scott \"  )  ;", "binder . bind ( request )  ;", "assertEquals (  \" Scott \"  ,    target . getName (  )  )  ;", "request . removeParameter (  \" name \"  )  ;", "binder . bind ( request )  ;", "assertEquals (  \" anonymous \"  ,    target . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefaultNonBoolean"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  ! postProcessed \"  ,     \" on \"  )  ;", "request . addParameter (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "request . addParameter (  \" postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( request )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \" postProcessed \"  )  ;", "binder . bind ( request )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \"  ! postProcessed \"  )  ;", "binder . bind ( request )  ;", "assertFalse ( target . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefaultPreemptsFieldMarker"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "request . addParameter (  \" postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( request )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \" postProcessed \"  )  ;", "binder . bind ( request )  ;", "assertFalse ( target . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldPrefixCausesFieldReset"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "binder . setIgnoreUnknownFields ( false )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "request . addParameter (  \" postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( request )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \" postProcessed \"  )  ;", "binder . bind ( request )  ;", "assertFalse ( target . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldPrefixCausesFieldResetWithIgnoreUnknownFields"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "String [  ]    original    =    new   String [  ]  {     \" Tony \"  ,     \" Rod \"     }  ;", "request . addParameter (  \" forname \"  ,    original )  ;", "ServletRequestParameterPropertyValues   pvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "assertTrue (  \" Found    1    parameter \"  ,     (  ( pvs . getPropertyValues (  )  . length )     =  =     1  )  )  ;", "assertTrue (  \" Found   array   value \"  ,     (  ( pvs . getPropertyValue (  \" forname \"  )  . getValue (  )  )    instanceof   String [  ]  )  )  ;", "String [  ]    values    =     (  ( String [  ]  )     ( pvs . getPropertyValue (  \" forname \"  )  . getValue (  )  )  )  ;", "assertEquals (  \" Correct   values \"  ,    Arrays . asList ( values )  ,    Arrays . asList ( original )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleValuesForParameter"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestParameterPropertyValues   pvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "assertTrue (  \" Found   no   parameters \"  ,     (  ( pvs . getPropertyValues (  )  . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoParameters"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" forname \"  ,     \" Tony \"  )  ;", "request . addParameter (  \" surname \"  ,     \" Blair \"  )  ;", "request . addParameter (  \" age \"  ,     (  \"  \"     +     5  0  )  )  ;", "ServletRequestParameterPropertyValues   pvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "doTestTony ( pvs )  ;", "}", "METHOD_END"], "methodName": ["testNoPrefix"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" test _ forname \"  ,     \" Tony \"  )  ;", "request . addParameter (  \" test _ surname \"  ,     \" Blair \"  )  ;", "request . addParameter (  \" test _ age \"  ,     (  \"  \"     +     5  0  )  )  ;", "ServletRequestParameterPropertyValues   pvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "assertTrue (  \" Didn ' t   fidn   normal   when   given   prefix \"  ,     (  !  ( pvs . contains (  \" forname \"  )  )  )  )  ;", "assertTrue (  \" Did   treat   prefix   as   normal   when   not   given   prefix \"  ,    pvs . contains (  \" test _ forname \"  )  )  ;", "pvs    =    new   ServletRequestParameterPropertyValues ( request ,     \" test \"  )  ;", "doTestTony ( pvs )  ;", "}", "METHOD_END"], "methodName": ["testPrefix"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" stringArray \"  ,     \" bar \"  )  ;", "request . addParameter (  \" stringArray \"  ,     \" abc \"  )  ;", "request . addParameter (  \" stringArray \"  ,     \"  1  2  3  , def \"  )  ;", "binder . bind ( request )  ;", "assertEquals (  \" Expected   all   three   items   to   be   bound \"  ,     3  ,    target . getStringArray (  )  . length )  ;", "request . removeParameter (  \" stringArray \"  )  ;", "request . addParameter (  \" stringArray \"  ,     \"  1  2  3  , def \"  )  ;", "binder . bind ( request )  ;", "assertEquals (  \" Expected   only    1    item   to   be   bound \"  ,     1  ,    target . getStringArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testWithCommaSeparatedStringArray"], "fileName": "org.springframework.web.bind.ServletRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   null ;", "}", "return    . getRequiredBooleanParameter ( request ,    name )  ;", "}", "METHOD_END"], "methodName": ["getBooleanParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   defaultVal ;", "}", "try    {", "return    . getRequiredBooleanParameter ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   defaultVal ;", "}", "}", "METHOD_END"], "methodName": ["getBooleanParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . getRequiredBooleanParameters ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   new   boolean [  0  ]  ;", "}", "}", "METHOD_END"], "methodName": ["getBooleanParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   null ;", "}", "return    . getRequiredDoubleParameter ( request ,    name )  ;", "}", "METHOD_END"], "methodName": ["getDoubleParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   defaultVal ;", "}", "try    {", "return    . getRequiredDoubleParameter ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   defaultVal ;", "}", "}", "METHOD_END"], "methodName": ["getDoubleParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . getRequiredDoubleParameters ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   new   double [  0  ]  ;", "}", "}", "METHOD_END"], "methodName": ["getDoubleParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   null ;", "}", "return    . getRequiredFloatParameter ( request ,    name )  ;", "}", "METHOD_END"], "methodName": ["getFloatParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   defaultVal ;", "}", "try    {", "return    . getRequiredFloatParameter ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   defaultVal ;", "}", "}", "METHOD_END"], "methodName": ["getFloatParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . getRequiredFloatParameters ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   new   float [  0  ]  ;", "}", "}", "METHOD_END"], "methodName": ["getFloatParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   null ;", "}", "return    . getRequiredIntParameter ( request ,    name )  ;", "}", "METHOD_END"], "methodName": ["getIntParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   defaultVal ;", "}", "try    {", "return    . getRequiredIntParameter ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   defaultVal ;", "}", "}", "METHOD_END"], "methodName": ["getIntParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . getRequiredIntParameters ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   new   int [  0  ]  ;", "}", "}", "METHOD_END"], "methodName": ["getIntParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   null ;", "}", "return    . getRequiredLongParameter ( request ,    name )  ;", "}", "METHOD_END"], "methodName": ["getLongParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   defaultVal ;", "}", "try    {", "return    . getRequiredLongParameter ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   defaultVal ;", "}", "}", "METHOD_END"], "methodName": ["getLongParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . getRequiredLongParameters ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   new   long [  0  ]  ;", "}", "}", "METHOD_END"], "methodName": ["getLongParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . BOOLEAN _ PARSER . parseBoolean ( name ,    request . getParameter ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredBooleanParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . BOOLEAN _ PARSER . parseBooleans ( name ,    request . getParameterValues ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredBooleanParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . DOUBLE _ PARSER . parseDouble ( name ,    request . getParameter ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredDoubleParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . DOUBLE _ PARSER . parseDoubles ( name ,    request . getParameterValues ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredDoubleParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . FLOAT _ PARSER . parseFloat ( name ,    request . getParameter ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredFloatParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . FLOAT _ PARSER . parseFloats ( name ,    request . getParameterValues ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredFloatParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . INT _ PARSER . parseInt ( name ,    request . getParameter ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredIntParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . INT _ PARSER . parseInts ( name ,    request . getParameterValues ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredIntParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . LONG _ PARSER . parseLong ( name ,    request . getParameter ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredLongParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . LONG _ PARSER . parseLongs ( name ,    request . getParameterValues ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredLongParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . STRING _ PARSER . validateRequiredString ( name ,    request . getParameter ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredStringParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "return   ServletRequestUtils . STRING _ PARSER . validateRequiredStrings ( name ,    request . getParameterValues ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredStringParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getParameter ( name )  )     =  =    null )     {", "return   null ;", "}", "return    . getRequiredStringParameter ( request ,    name )  ;", "}", "METHOD_END"], "methodName": ["getStringParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "String   val    =    request . getParameter ( name )  ;", "return   val    !  =    null    ?    val    :    defaultVal ;", "}", "METHOD_END"], "methodName": ["getStringParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . getRequiredStringParameters ( request ,    name )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "return   new   String [  0  ]  ;", "}", "}", "METHOD_END"], "methodName": ["getStringParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtils"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param 1  \"  ,     \" true \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" e \"  )  ;", "request . addParameter (  \" param 4  \"  ,     \" yes \"  )  ;", "request . addParameter (  \" param 5  \"  ,     \"  1  \"  )  ;", "request . addParameter (  \" paramEmpty \"  ,     \"  \"  )  ;", "assertTrue (  . getBooleanParameter ( request ,     \" param 1  \"  )  . equals ( Boolean . TRUE )  )  ;", "assertTrue (  . getBooleanParameter ( request ,     \" param 1  \"  ,    false )  )  ;", "assertTrue (  . getRequiredBooleanParameter ( request ,     \" param 1  \"  )  )  ;", "assertFalse (  . getBooleanParameter ( request ,     \" param 2  \"  ,    true )  )  ;", "assertFalse (  . getRequiredBooleanParameter ( request ,     \" param 2  \"  )  )  ;", "assertTrue (  (  (  . getBooleanParameter ( request ,     \" param 3  \"  )  )     =  =    null )  )  ;", "assertTrue (  . getBooleanParameter ( request ,     \" param 3  \"  ,    true )  )  ;", "try    {", ". getRequiredBooleanParameter ( request ,     \" param 3  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "assertTrue (  . getBooleanParameter ( request ,     \" param 4  \"  ,    false )  )  ;", "assertTrue (  . getRequiredBooleanParameter ( request ,     \" param 4  \"  )  )  ;", "assertTrue (  . getBooleanParameter ( request ,     \" param 5  \"  ,    false )  )  ;", "assertTrue (  . getRequiredBooleanParameter ( request ,     \" param 5  \"  )  )  ;", "assertFalse (  . getRequiredBooleanParameter ( request ,     \" paramEmpty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param \"  ,    new   String [  ]  {     \" true \"  ,     \" yes \"  ,     \" off \"  ,     \"  1  \"  ,     \" bogus \"     }  )  ;", "request . addParameter (  \" param 2  \"  ,     \" false \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" true \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \"  \"  )  ;", "boolean [  ]    array    =    new   boolean [  ]  {    true ,    true ,    false ,    true ,    false    }  ;", "boolean [  ]    values    =     . getRequiredBooleanParameters ( request ,     \" param \"  )  ;", "assertEquals ( array . length ,    values . length )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "assertEquals ( array [ i ]  ,    values [ i ]  )  ;", "}", "array    =    new   boolean [  ]  {    false ,    true ,    false    }  ;", "values    =     . getRequiredBooleanParameters ( request ,     \" param 2  \"  )  ;", "assertEquals ( array . length ,    values . length )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "assertEquals ( array [ i ]  ,    values [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBooleanParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param 1  \"  ,     \"  5  .  5  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" e \"  )  ;", "request . addParameter (  \" paramEmpty \"  ,     \"  \"  )  ;", "assertTrue (  . getDoubleParameter ( request ,     \" param 1  \"  )  . equals ( new   Double (  5  .  5  )  )  )  ;", "assertTrue (  (  (  . getDoubleParameter ( request ,     \" param 1  \"  ,     6  .  5  )  )     =  =     5  .  5  )  )  ;", "assertTrue (  (  (  . getRequiredDoubleParameter ( request ,     \" param 1  \"  )  )     =  =     5  .  5  )  )  ;", "assertTrue (  (  (  . getDoubleParameter ( request ,     \" param 2  \"  ,     6  .  5  )  )     =  =     6  .  5  )  )  ;", "try    {", ". getRequiredDoubleParameter ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "assertTrue (  (  (  . getDoubleParameter ( request ,     \" param 3  \"  )  )     =  =    null )  )  ;", "assertTrue (  (  (  . getDoubleParameter ( request ,     \" param 3  \"  ,     6  .  5  )  )     =  =     6  .  5  )  )  ;", "try    {", ". getRequiredDoubleParameter ( request ,     \" param 3  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "try    {", ". getRequiredDoubleParameter ( request ,     \" paramEmpty \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testDoubleParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param \"  ,    new   String [  ]  {     \"  1  .  5  \"  ,     \"  2  .  5  \"  ,     \"  3  \"     }  )  ;", "request . addParameter (  \" param 2  \"  ,     \"  1  .  5  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \"  2  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" bogus \"  )  ;", "double [  ]    array    =    new   double [  ]  {     1  .  5  ,     2  .  5  ,     3     }  ;", "double [  ]    values    =     . getRequiredDoubleParameters ( request ,     \" param \"  )  ;", "assertEquals (  3  ,    values . length )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "assertEquals ( array [ i ]  ,    values [ i ]  ,     0  )  ;", "}", "try    {", ". getRequiredDoubleParameters ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testDoubleParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param 1  \"  ,     \"  5  .  5  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" e \"  )  ;", "request . addParameter (  \" paramEmpty \"  ,     \"  \"  )  ;", "assertTrue (  . getFloatParameter ( request ,     \" param 1  \"  )  . equals ( new   Float (  5  .  5 F )  )  )  ;", "assertTrue (  (  (  . getFloatParameter ( request ,     \" param 1  \"  ,     6  .  5 F )  )     =  =     5  .  5 F )  )  ;", "assertTrue (  (  (  . getRequiredFloatParameter ( request ,     \" param 1  \"  )  )     =  =     5  .  5 F )  )  ;", "assertTrue (  (  (  . getFloatParameter ( request ,     \" param 2  \"  ,     6  .  5 F )  )     =  =     6  .  5 F )  )  ;", "try    {", ". getRequiredFloatParameter ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "assertTrue (  (  (  . getFloatParameter ( request ,     \" param 3  \"  )  )     =  =    null )  )  ;", "assertTrue (  (  (  . getFloatParameter ( request ,     \" param 3  \"  ,     6  .  5 F )  )     =  =     6  .  5 F )  )  ;", "try    {", ". getRequiredFloatParameter ( request ,     \" param 3  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "try    {", ". getRequiredFloatParameter ( request ,     \" paramEmpty \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testFloatParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param \"  ,    new   String [  ]  {     \"  1  .  5  \"  ,     \"  2  .  5  \"  ,     \"  3  \"     }  )  ;", "request . addParameter (  \" param 2  \"  ,     \"  1  .  5  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \"  2  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" bogus \"  )  ;", "float [  ]    array    =    new   float [  ]  {     1  .  5 F ,     2  .  5 F ,     3     }  ;", "float [  ]    values    =     . getRequiredFloatParameters ( request ,     \" param \"  )  ;", "assertEquals (  3  ,    values . length )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "assertEquals ( array [ i ]  ,    values [ i ]  ,     0  )  ;", "}", "try    {", ". getRequiredFloatParameters ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testFloatParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", ". getBooleanParameter ( request ,     \" nonExistingParam \"  ,    false )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . getTotalTimeMillis (  )  )  ;", "assertTrue (  (  \" getStringParameter   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     2  5  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBooleanParameterWithDefaultValueHandlingIsFastEnough"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", ". getDoubleParameter ( request ,     \" nonExistingParam \"  ,     0  .  0  )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . getTotalTimeMillis (  )  )  ;", "assertTrue (  (  \" getStringParameter   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     2  5  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetDoubleParameterWithDefaultValueHandlingIsFastEnough"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", ". getFloatParameter ( request ,     \" nonExistingParam \"  ,     0  .  0 F )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . getTotalTimeMillis (  )  )  ;", "assertTrue (  (  \" getStringParameter   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     2  5  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetFloatParameterWithDefaultValueHandlingIsFastEnough"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", ". getIntParameter ( request ,     \" nonExistingParam \"  ,     0  )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . getTotalTimeMillis (  )  )  ;", "assertTrue (  (  \" getStringParameter   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     2  5  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetIntParameterWithDefaultValueHandlingIsFastEnough"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", ". getLongParameter ( request ,     \" nonExistingParam \"  ,     0  )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . getTotalTimeMillis (  )  )  ;", "assertTrue (  (  \" getStringParameter   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     2  5  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetLongParameterWithDefaultValueHandlingIsFastEnough"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", ". getStringParameter ( request ,     \" nonExistingParam \"  ,     \" defaultValue \"  )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . getTotalTimeMillis (  )  )  ;", "assertTrue (  (  \" getStringParameter   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     2  5  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetStringParameterWithDefaultValueHandlingIsFastEnough"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param 1  \"  ,     \"  5  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" e \"  )  ;", "request . addParameter (  \" paramEmpty \"  ,     \"  \"  )  ;", "assertEquals (  . getIntParameter ( request ,     \" param 1  \"  )  ,    new   Integer (  5  )  )  ;", "assertEquals (  . getIntParameter ( request ,     \" param 1  \"  ,     6  )  ,     5  )  ;", "assertEquals (  . getRequiredIntParameter ( request ,     \" param 1  \"  )  ,     5  )  ;", "assertEquals (  . getIntParameter ( request ,     \" param 2  \"  ,     6  )  ,     6  )  ;", "try    {", ". getRequiredIntParameter ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "assertEquals (  . getIntParameter ( request ,     \" param 3  \"  )  ,    null )  ;", "assertEquals (  . getIntParameter ( request ,     \" param 3  \"  ,     6  )  ,     6  )  ;", "try    {", ". getRequiredIntParameter ( request ,     \" param 3  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "try    {", ". getRequiredIntParameter ( request ,     \" paramEmpty \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testIntParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param \"  ,    new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  )  ;", "request . addParameter (  \" param 2  \"  ,     \"  1  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \"  2  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" bogus \"  )  ;", "int [  ]    array    =    new   int [  ]  {     1  ,     2  ,     3     }  ;", "int [  ]    values    =     . getRequiredIntParameters ( request ,     \" param \"  )  ;", "assertEquals (  3  ,    values . length )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "assertEquals ( array [ i ]  ,    values [ i ]  )  ;", "}", "try    {", ". getRequiredIntParameters ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testIntParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param 1  \"  ,     \"  5  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" e \"  )  ;", "request . addParameter (  \" paramEmpty \"  ,     \"  \"  )  ;", "assertEquals (  . getLongParameter ( request ,     \" param 1  \"  )  ,    new   Long (  5 L )  )  ;", "assertEquals (  . getLongParameter ( request ,     \" param 1  \"  ,     6 L )  ,     5 L )  ;", "assertEquals (  . getRequiredIntParameter ( request ,     \" param 1  \"  )  ,     5 L )  ;", "assertEquals (  . getLongParameter ( request ,     \" param 2  \"  ,     6 L )  ,     6 L )  ;", "try    {", ". getRequiredLongParameter ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "assertEquals (  . getLongParameter ( request ,     \" param 3  \"  )  ,    null )  ;", "assertEquals (  . getLongParameter ( request ,     \" param 3  \"  ,     6 L )  ,     6 L )  ;", "try    {", ". getRequiredLongParameter ( request ,     \" param 3  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "try    {", ". getRequiredLongParameter ( request ,     \" paramEmpty \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLongParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setParameter (  \" param \"  ,    new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  )  ;", "request . setParameter (  \" param 2  \"  ,     \"  0  \"  )  ;", "request . setParameter (  \" param 2  \"  ,     \"  1  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \"  2  \"  )  ;", "request . addParameter (  \" param 2  \"  ,     \" bogus \"  )  ;", "long [  ]    array    =    new   long [  ]  {     1 L ,     2 L ,     3 L    }  ;", "long [  ]    values    =     . getRequiredLongParameters ( request ,     \" param \"  )  ;", "assertEquals (  3  ,    values . length )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "assertEquals ( array [ i ]  ,    values [ i ]  )  ;", "}", "try    {", ". getRequiredLongParameters ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "request . setParameter (  \" param 2  \"  ,    new   String [  ]  {     \"  1  \"  ,     \"  2  \"     }  )  ;", "values    =     . getRequiredLongParameters ( request ,     \" param 2  \"  )  ;", "assertEquals (  2  ,    values . length )  ;", "assertEquals (  1  ,    values [  0  ]  )  ;", "assertEquals (  2  ,    values [  1  ]  )  ;", "request . removeParameter (  \" param 2  \"  )  ;", "try    {", ". getRequiredLongParameters ( request ,     \" param 2  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLongParameters"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" param 1  \"  ,     \" str \"  )  ;", "request . addParameter (  \" paramEmpty \"  ,     \"  \"  )  ;", "assertEquals (  \" str \"  ,     . getStringParameter ( request ,     \" param 1  \"  )  )  ;", "assertEquals (  \" str \"  ,     . getStringParameter ( request ,     \" param 1  \"  ,     \" string \"  )  )  ;", "assertEquals (  \" str \"  ,     . getRequiredStringParameter ( request ,     \" param 1  \"  )  )  ;", "assertEquals ( null ,     . getStringParameter ( request ,     \" param 3  \"  )  )  ;", "assertEquals (  \" string \"  ,     . getStringParameter ( request ,     \" param 3  \"  ,     \" string \"  )  )  ;", "assertNull (  . getStringParameter ( request ,     \" param 3  \"  ,    null )  )  ;", "try    {", ". getRequiredStringParameter ( request ,     \" param 3  \"  )  ;", "fail (  \" Should   have   thrown   ServletRequestBindingException \"  )  ;", "}    catch    ( ServletRequestBindingException   ex )     {", "}", "assertEquals (  \"  \"  ,     . getStringParameter ( request ,     \" paramEmpty \"  )  )  ;", "assertEquals (  \"  \"  ,     . getRequiredStringParameter ( request ,     \" paramEmpty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringParameter"], "fileName": "org.springframework.web.bind.ServletRequestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . actualParams ;", "}", "METHOD_END"], "methodName": ["getActualParams"], "fileName": "org.springframework.web.bind.UnsatisfiedServletRequestParameterException"}, {"methodBody": ["METHOD_START", "{", "return   this . paramConditions ;", "}", "METHOD_END"], "methodName": ["getParamConditionGroups"], "fileName": "org.springframework.web.bind.UnsatisfiedServletRequestParameterException"}, {"methodBody": ["METHOD_START", "{", "return   this . paramConditions . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getParamConditions"], "fileName": "org.springframework.web.bind.UnsatisfiedServletRequestParameterException"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "for    ( Iterator < Map . Entry < String ,    String [  ]  >  >    it    =    actuals . entrySet (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Map . Entry < String ,    String [  ]  >    entry    =    it . next (  )  ;", "result . append ( entry . getKey (  )  )  . append (  '  =  '  )  . append ( ObjectUtils . nullSafeToString ( entry . getValue (  )  )  )  ;", "if    ( it . hasNext (  )  )     {", "result . append (  \"  ,     \"  )  ;", "}", "}", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["requestParameterMapToString"], "fileName": "org.springframework.web.bind.UnsatisfiedServletRequestParameterException"}, {"methodBody": ["METHOD_START", "{", "multipartFiles . forEach (  (    key ,    values )     -  >     {", "if    (  ( values . size (  )  )     =  =     1  )     {", "MultipartFile   value    =    values . get (  0  )  ;", "if    (  ( isEmptyMultipartFiles (  )  )     |  |     (  !  ( value . isEmpty (  )  )  )  )     {", "mpvs . add ( key ,    value )  ;", "}", "} else    {", "mpvs . add ( key ,    values )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["bindMultipart"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "String   fieldDefaultPrefix    =    getFieldDefaultPrefix (  )  ;", "if    ( fieldDefaultPrefix    !  =    null )     {", "PropertyValue [  ]    pvArray    =    mpvs . getPropertyValues (  )  ;", "for    ( PropertyValue   pv    :    pvArray )     {", "if    ( pv . getName (  )  . startsWith ( fieldDefaultPrefix )  )     {", "String   field    =    pv . getName (  )  . substring ( fieldDefaultPrefix . length (  )  )  ;", "if    (  ( getPropertyAccessor (  )  . isWritableProperty ( field )  )     &  &     (  !  ( mpvs . contains ( field )  )  )  )     {", "mpvs . add ( field ,    pv . getValue (  )  )  ;", "}", "mpvs . removePropertyValue ( pv )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkFieldDefaults"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "String   fieldMarkerPrefix    =    getFieldMarkerPrefix (  )  ;", "if    ( fieldMarkerPrefix    !  =    null )     {", "PropertyValue [  ]    pvArray    =    mpvs . getPropertyValues (  )  ;", "for    ( PropertyValue   pv    :    pvArray )     {", "if    ( pv . getName (  )  . startsWith ( fieldMarkerPrefix )  )     {", "String   field    =    pv . getName (  )  . substring ( fieldMarkerPrefix . length (  )  )  ;", "if    (  ( getPropertyAccessor (  )  . isWritableProperty ( field )  )     &  &     (  !  ( mpvs . contains ( field )  )  )  )     {", "Class <  ?  >    fieldType    =    getPropertyAccessor (  )  . getPropertyType ( field )  ;", "mpvs . add ( field ,    getEmptyValue ( field ,    fieldType )  )  ;", "}", "mpvs . removePropertyValue ( pv )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkFieldMarkers"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  (  ( boolean . class )     =  =    fieldType )     |  |     (  ( Boolean . class )     =  =    fieldType )  )     {", "return   Boolean . FALSE ;", "} else", "if    ( fieldType . isArray (  )  )     {", "return   newInstance ( fieldType . getComponentType (  )  ,     0  )  ;", "} else", "if    ( isAssignableFrom ( fieldType )  )     {", "return   core . CollectionFactory . createCollection ( fieldType ,     0  )  ;", "} else", "if    ( isAssignableFrom ( fieldType )  )     {", "return   core . CollectionFactory . createMap ( fieldType ,     0  )  ;", "}", "}    catch    ( IllegalArgumentException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Failed   to   create   default   value    -    falling   back   to   null :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getEmptyValue"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "return   fieldType    !  =    null    ?    getEmptyValue ( fieldType )     :    null ;", "}", "METHOD_END"], "methodName": ["getEmptyValue"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . fieldDefaultPrefix ;", "}", "METHOD_END"], "methodName": ["getFieldDefaultPrefix"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . fieldMarkerPrefix ;", "}", "METHOD_END"], "methodName": ["getFieldMarkerPrefix"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . bindEmptyMultipartFiles ;", "}", "METHOD_END"], "methodName": ["isBindEmptyMultipartFiles"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "this . bindEmptyMultipartFiles    =    bindEmptyMultipartFiles ;", "}", "METHOD_END"], "methodName": ["setBindEmptyMultipartFiles"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "this . fieldDefaultPrefix    =    fieldDefaultPrefix ;", "}", "METHOD_END"], "methodName": ["setFieldDefaultPrefix"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "this . fieldMarkerPrefix    =    fieldMarkerPrefix ;", "}", "METHOD_END"], "methodName": ["setFieldMarkerPrefix"], "fileName": "org.springframework.web.bind.WebDataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingErrorProcessor ;", "}", "METHOD_END"], "methodName": ["getBindingErrorProcessor"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "return   this . conversionService ;", "}", "METHOD_END"], "methodName": ["getConversionService"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "return   this . messageCodesResolver ;", "}", "METHOD_END"], "methodName": ["getMessageCodesResolver"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "return   this . propertyEditorRegistrars ;", "}", "METHOD_END"], "methodName": ["getPropertyEditorRegistrars"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "return   this . validator ;", "}", "METHOD_END"], "methodName": ["getValidator"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "return   this . autoGrowNestedPaths ;", "}", "METHOD_END"], "methodName": ["isAutoGrowNestedPaths"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "return   directFieldAccess ;", "}", "METHOD_END"], "methodName": ["isDirectFieldAccess"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "this . autoGrowNestedPaths    =    autoGrowNestedPaths ;", "}", "METHOD_END"], "methodName": ["setAutoGrowNestedPaths"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "this . bindingErrorProcessor    =    bindingErrorProcessor ;", "}", "METHOD_END"], "methodName": ["setBindingErrorProcessor"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "this . conversionService    =    conversionService ;", "}", "METHOD_END"], "methodName": ["setConversionService"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "this . directFieldAccess    =    directFieldAccess ;", "}", "METHOD_END"], "methodName": ["setDirectFieldAccess"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "this . messageCodesResolver    =    messageCodesResolver ;", "}", "METHOD_END"], "methodName": ["setMessageCodesResolver"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "this . propertyEditorRegistrars    =    new   PropertyEditorRegistrar [  ]  {    propertyEditorRegistrar    }  ;", "}", "METHOD_END"], "methodName": ["setPropertyEditorRegistrar"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "this . propertyEditorRegistrars    =    propertyEditorRegistrars ;", "}", "METHOD_END"], "methodName": ["setPropertyEditorRegistrars"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "this . validator    =    validator ;", "}", "METHOD_END"], "methodName": ["setValidator"], "fileName": "org.springframework.web.bind.support.ConfigurableWebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "return   new   WebRequestDataBinder ( target ,    objectName )  ;", "}", "METHOD_END"], "methodName": ["createBinderInstance"], "fileName": "org.springframework.web.bind.support.DefaultDataBinderFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( this . attributeNamePrefix )     +    attributeName ;", "}", "METHOD_END"], "methodName": ["getAttributeNameInSession"], "fileName": "org.springframework.web.bind.support.DefaultSessionAttributeStore"}, {"methodBody": ["METHOD_START", "{", "this . attributeNamePrefix    =     ( attributeNamePrefix    !  =    null )     ?    attributeNamePrefix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setAttributeNamePrefix"], "fileName": "org.springframework.web.bind.support.DefaultSessionAttributeStore"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   wac    =    ContextLoader . getCurrentWebApplicationContext (  )  ;", "if    ( wac    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   WebApplicationContext   registered   for   current   thread    -     \"     +     \" consider   overriding    . getWebApplicationContext (  )  \"  )  )  ;", "}", "return   wac ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.bind.support.SpringWebConstraintValidatorFactory"}, {"methodBody": ["METHOD_START", "{", "getWebApplicationContext (  )  . getAutowireCapableBeanFactory (  )  . destroyBean ( instance )  ;", "}", "METHOD_END"], "methodName": ["releaseInstance"], "fileName": "org.springframework.web.bind.support.SpringWebConstraintValidatorFactory"}, {"methodBody": ["METHOD_START", "{", "initBinder ( binder )  ;", "}", "METHOD_END"], "methodName": ["initBinder"], "fileName": "org.springframework.web.bind.support.WebBindingInitializer"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingResult ;", "}", "METHOD_END"], "methodName": ["getBindingResult"], "fileName": "org.springframework.web.bind.support.WebExchangeBindException"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( values )  )  )     {", "values    =    values . stream (  )  . map (  (    value )     -  >    value   instanceof   FormFieldPart    ?     (  ( FormFieldPart )     ( value )  )  . value (  )     :    value )  . collect ( Collectors . toList (  )  )  ;", "pas . put ( key ,     (  ( values . size (  )  )     =  =     1     ?    values . get (  0  )     :    values )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addBindValue"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinder"}, {"methodBody": ["METHOD_START", "{", "return   getValuesToBind ( exchange )  . doOnNext (  (    values )     -  >    doBind ( new   MutablePropertyValues ( values )  )  )  . then (  )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinder"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    queryParams    =    exchange . getRequest (  )  . getQueryParams (  )  ;", "Mono < MultiValueMap < String ,    String >  >    formData    =    exchange . getFormData (  )  ;", "Mono < MultiValueMap < String ,    Part >  >    multipartData    =    exchange . getMultipartData (  )  ;", "return   Mono . zip ( Mono . just ( queryParams )  ,    formData ,    multipartData )  . map (  (    tuple )     -  >     {", "Map < String ,    Object >    result    =    new   TreeMap <  >  (  )  ;", "tuple . getT 1  (  )  . forEach (  (    key ,    values )     -  >    addBindValue ( result ,    key ,    values )  )  ;", "tuple . getT 2  (  )  . forEach (  (    key ,    values )     -  >    addBindValue ( result ,    key ,    values )  )  ;", "tuple . getT 3  (  )  . forEach (  (    key ,    values )     -  >    addBindValue ( result ,    key ,    values )  )  ;", "return   result ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["extractValuesToBind"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinder"}, {"methodBody": ["METHOD_START", "{", "return   WebExchangeDataBinder . extractValuesToBind ( exchange )  ;", "}", "METHOD_END"], "methodName": ["getValuesToBind"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinder"}, {"methodBody": ["METHOD_START", "{", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . POST ,     \"  /  \"  )  ;", "new   FormHttpMessageWriter (  )  . write ( Mono . just ( formData )  ,    ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    String . class )  ,    MediaType . APPLICATION _ FORM _ URLENCODED ,    request ,    Collections . emptyMap (  )  )  . block (  )  ;", "return   MockServer . from ( MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( MediaType . APPLICATION _ FORM _ URLENCODED )  . body ( request . getBody (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["exchange"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . POST ,     \"  /  \"  )  ;", "new   MultipartHttpMessageWriter (  )  . write ( Mono . just ( multipartData )  ,    ResolvableType . forClass ( MultiValueMap . class )  ,    MediaType . MULTIPART _ FORM _ DATA ,    request ,    Collections . emptyMap (  )  )  . block (  )  ;", "return   MockServer . from ( MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( request . getHeaders (  )  . getContentType (  )  )  . body ( request . getBody (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["exchangeMultipart"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "this . testBean    =    new   TestBean (  )  ;", "this . binder    =    new   WebExchangeDataBinder ( this . testBean ,     \" person \"  )  ;", "this . binder . registerCustomEditor ( ITestBean . class ,    new    . TestBeanPropertyEditor (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    formData    =    new   LinkedMultiValueMap (  )  ;", "formData . add (  \" spouse \"  ,     \" someValue \"  )  ;", "formData . add (  \" spouse . name \"  ,     \" test \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertNotNull ( this . testBean . getSpouse (  )  )  ;", "assertEquals (  \" test \"  ,    testBean . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithNestedObjectCreation"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    formData    =    new   LinkedMultiValueMap (  )  ;", "formData . add (  \" spouse . name \"  ,     \" test \"  )  ;", "formData . add (  \" spouse \"  ,     \" someValue \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertNotNull ( this . testBean . getSpouse (  )  )  ;", "assertEquals (  \" test \"  ,    this . testBean . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithNestedObjectCreationAndWrongOrder"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \"  / path ? spouse = someValue & spouse . name = test \"  ;", "Server   exchange    =    MockServer . from ( MockServerHttpRequest . post ( url )  )  ;", "this . binder . bind ( exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertNotNull ( this . testBean . getSpouse (  )  )  ;", "assertEquals (  \" test \"  ,    this . testBean . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithQueryParams"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    formData    =    new   LinkedMultiValueMap (  )  ;", "formData . add (  \"  ! postProcessed \"  ,     \" off \"  )  ;", "formData . add (  \" postProcessed \"  ,     \" on \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertTrue ( this . testBean . isPostProcessed (  )  )  ;", "formData . remove (  \" postProcessed \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "TestCase . assertFalse ( this . testBean . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefault"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    formData    =    new   LinkedMultiValueMap (  )  ;", "formData . add (  \"  ! name \"  ,     \" anonymous \"  )  ;", "formData . add (  \" name \"  ,     \" Scott \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" Scott \"  ,    this . testBean . getName (  )  )  ;", "formData . remove (  \" name \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" anonymous \"  ,    this . testBean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefaultNonBoolean"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    formData    =    new   LinkedMultiValueMap (  )  ;", "formData . add (  \"  ! postProcessed \"  ,     \" on \"  )  ;", "formData . add (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "formData . add (  \" postProcessed \"  ,     \" on \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertTrue ( this . testBean . isPostProcessed (  )  )  ;", "formData . remove (  \" postProcessed \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertTrue ( this . testBean . isPostProcessed (  )  )  ;", "formData . remove (  \"  ! postProcessed \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "TestCase . assertFalse ( this . testBean . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefaultPreemptsFieldMarker"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    formData    =    new   LinkedMultiValueMap (  )  ;", "formData . add (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "formData . add (  \" postProcessed \"  ,     \" on \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertTrue ( this . testBean . isPostProcessed (  )  )  ;", "formData . remove (  \" postProcessed \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "TestCase . assertFalse ( this . testBean . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldPrefixCausesFieldReset"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "this . binder . setIgnoreUnknownFields ( false )  ;", "MultiValueMap < String ,    String >    formData    =    new   util . LinkedMultiValueMap (  )  ;", "formData . add (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "formData . add (  \" postProcessed \"  ,     \" on \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertTrue ( this . testBean . isPostProcessed (  )  )  ;", "formData . remove (  \" postProcessed \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "TestCase . assertFalse ( this . testBean . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldPrefixCausesFieldResetWithIgnoreUnknownFields"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "WebExchangeDataBinderTests . MultipartBean   bean    =    new   WebExchangeDataBinderTests . MultipartBean (  )  ;", "WebExchangeDataBinder   binder    =    new   WebExchangeDataBinder ( bean )  ;", "MultiValueMap < String ,    Object >    data    =    new   LinkedMultiValueMap (  )  ;", "data . add (  \" name \"  ,     \" bar \"  )  ;", "data . add (  \" someList \"  ,     \"  1  2  3  \"  )  ;", "data . add (  \" someList \"  ,     \" abc \"  )  ;", "data . add (  \" someArray \"  ,     \" dec \"  )  ;", "data . add (  \" someArray \"  ,     \"  4  5  6  \"  )  ;", "data . add (  \" part \"  ,    new   ClassPathResource (  \" org / springframework / http / codec / multipart / foo . txt \"  )  )  ;", "data . add (  \" somePartList \"  ,    new   ClassPathResource (  \" org / springframework / http / codec / multipart / foo . txt \"  )  )  ;", "data . add (  \" somePartList \"  ,    new   ClassPathResource (  \" org / springframework / http / server / reactive / spring . png \"  )  )  ;", "binder . bind ( exchangeMultipart ( data )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" bar \"  ,    bean . getName (  )  )  ;", "assertEquals ( Arrays . asList (  \"  1  2  3  \"  ,     \" abc \"  )  ,    bean . getSomeList (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" dec \"  ,     \"  4  5  6  \"     }  ,    bean . getSomeArray (  )  )  ;", "assertEquals (  \" foo . txt \"  ,    bean . getPart (  )  . filename (  )  )  ;", "assertEquals (  2  ,    bean . getSomePartList (  )  . size (  )  )  ;", "assertEquals (  \" foo . txt \"  ,    bean . getSomePartList (  )  . get (  0  )  . filename (  )  )  ;", "assertEquals (  \" spring . png \"  ,    bean . getSomePartList (  )  . get (  1  )  . filename (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipart"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    formData    =    new   LinkedMultiValueMap (  )  ;", "formData . add (  \" stringArray \"  ,     \" bar \"  )  ;", "formData . add (  \" stringArray \"  ,     \" abc \"  )  ;", "formData . add (  \" stringArray \"  ,     \"  1  2  3  , def \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" Expected   all   three   items   to   be   bound \"  ,     3  ,    this . testBean . getStringArray (  )  . length )  ;", "formData . remove (  \" stringArray \"  )  ;", "formData . add (  \" stringArray \"  ,     \"  1  2  3  , def \"  )  ;", "this . binder . bind ( exchange ( formData )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" Expected   only    1    item   to   be   bound \"  ,     1  ,    this . testBean . getStringArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testWithCommaSeparatedStringArray"], "fileName": "org.springframework.web.bind.support.WebExchangeDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   mpvs    =    new   MutablePropertyValues ( request . getParameterMap (  )  )  ;", "if    (  ( isMultipartRequest ( request )  )     &  &     ( request   instanceof   Native )  )     {", "MultipartRequest   multipartRequest    =     (  ( Native )     ( request )  )  . getNativeRequest ( MultipartRequest . class )  ;", "if    ( multipartRequest    !  =    null )     {", "bindMultipart ( multipartRequest . getMultiFileMap (  )  ,    mpvs )  ;", "} else    {", "HttpServletRequest   servletRequest    =     (  ( Native )     ( request )  )  . getNativeRequest ( HttpServletRequest . class )  ;", "if    ( servletRequest    !  =    null )     {", "bindParts ( servletRequest ,    mpvs )  ;", "}", "}", "}", "doBind ( mpvs )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinder"}, {"methodBody": ["METHOD_START", "{", "try    {", "MultiValueMap < String ,    Part >    map    =    new   util . LinkedMultiValueMap (  )  ;", "for    ( Part   part    :    request . getParts (  )  )     {", "map . add ( part . getName (  )  ,    part )  ;", "}", "map . forEach (  (    key ,    values )     -  >     {", "if    (  ( values . size (  )  )     =  =     1  )     {", "Part   part    =    values . get (  0  )  ;", "if    (  ( isBindEmptyMultipartFiles (  )  )     |  |     (  ( part . getSize (  )  )     >     0  )  )     {", "mpvs . add ( key ,    part )  ;", "}", "} else    {", "mpvs . add ( key ,    values )  ;", "}", "}  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   MultipartException (  \" Failed   to   get   request   parts \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["bindParts"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinder"}, {"methodBody": ["METHOD_START", "{", "if    ( getBindingResult (  )  . hasErrors (  )  )     {", "throw   new   validation . BindException ( getBindingResult (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeNoCatch"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinder"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =    request . getHeader (  \" Content - Type \"  )  ;", "return    ( contentType    !  =    null )     &  &     ( StringUtils . startsWithIgnoreCase ( contentType ,     \" multipart \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isMultipartRequest"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinder"}, {"methodBody": ["METHOD_START", "{", "WebRequestDataBinderIntegrationTests . PartListBean   bean    =    new   WebRequestDataBinderIntegrationTests . PartListBean (  )  ;", "WebRequestDataBinderIntegrationTests . partListServlet . setBean ( bean )  ;", "MultiValueMap < String ,    Object >    parts    =    new   LinkedMultiValueMap (  )  ;", "parts . add (  \" partList \"  ,     \" first   value \"  )  ;", "parts . add (  \" partList \"  ,     \" second   value \"  )  ;", "Resource   logo    =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )  ;", "parts . add (  \" partList \"  ,    logo )  ;", "template . postForLocation (  (  ( WebRequestDataBinderIntegrationTests . baseUrl )     +     \"  / partlist \"  )  ,    parts )  ;", "assertNotNull ( bean . getPartList (  )  )  ;", "assertEquals ( parts . get (  \" partList \"  )  . size (  )  ,    bean . getPartList (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["partListBinding"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "WebRequestDataBinderIntegrationTests . PartsBean   bean    =    new   WebRequestDataBinderIntegrationTests . PartsBean (  )  ;", "WebRequestDataBinderIntegrationTests . partsServlet . setBean ( bean )  ;", "MultiValueMap < String ,    Object >    parts    =    new   LinkedMultiValueMap (  )  ;", "Resource   firstPart    =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )  ;", "parts . add (  \" firstPart \"  ,    firstPart )  ;", "parts . add (  \" secondPart \"  ,     \" secondValue \"  )  ;", "template . postForLocation (  (  ( WebRequestDataBinderIntegrationTests . baseUrl )     +     \"  / parts \"  )  ,    parts )  ;", "assertNotNull ( bean . getFirstPart (  )  )  ;", "assertNotNull ( bean . getSecondPart (  )  )  ;", "}", "METHOD_END"], "methodName": ["partsBinding"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "WebRequestDataBinderIntegrationTests . jettyServer    =    new   Server (  0  )  ;", "ServletContextHandler   handler    =    new   ServletContextHandler (  )  ;", "MultipartConfigElement   multipartConfig    =    new   MultipartConfigElement (  \"  \"  )  ;", "ServletHolder   holder    =    new   ServletHolder ( WebRequestDataBinderIntegrationTests . partsServlet )  ;", "holder . getRegistration (  )  . setMultipartConfig ( multipartConfig )  ;", "handler . addServlet ( holder ,     \"  / parts \"  )  ;", "holder    =    new   ServletHolder ( WebRequestDataBinderIntegrationTests . partListServlet )  ;", "holder . getRegistration (  )  . setMultipartConfig ( multipartConfig )  ;", "handler . addServlet ( holder ,     \"  / partlist \"  )  ;", "WebRequestDataBinderIntegrationTests . jettyServer . setHandler ( handler )  ;", "WebRequestDataBinderIntegrationTests . jettyServer . start (  )  ;", "Connector [  ]    connectors    =    WebRequestDataBinderIntegrationTests . jettyServer . getConnectors (  )  ;", "NetworkConnector   connector    =     (  ( NetworkConnector )     ( connectors [  0  ]  )  )  ;", "WebRequestDataBinderIntegrationTests . baseUrl    =     \" http :  /  / localhost :  \"     +     ( connector . getLocalPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["startJettyServer"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( WebRequestDataBinderIntegrationTests . jettyServer )     !  =    null )     {", "WebRequestDataBinderIntegrationTests . jettyServer . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stopJettyServer"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Contains    3  \"  ,     (  ( pvs . getPropertyValues (  )  . length )     =  =     3  )  )  ;", "assertTrue (  \" Contains   forname \"  ,    pvs . contains (  \" forname \"  )  )  ;", "assertTrue (  \" Contains   surname \"  ,    pvs . contains (  \" surname \"  )  )  ;", "assertTrue (  \" Contains   age \"  ,    pvs . contains (  \" age \"  )  )  ;", "assertTrue (  \" Doesn ' t   contain   tory \"  ,     (  !  ( pvs . contains (  \" tory \"  )  )  )  )  ;", "PropertyValue [  ]    pvArray    =    pvs . getPropertyValues (  )  ;", "Map < St ,    St >    m    =    new   HashMap <  >  (  )  ;", "m . put (  \" forname \"  ,     \" Tony \"  )  ;", "m . put (  \" surname \"  ,     \" Blair \"  )  ;", "m . put (  \" age \"  ,     \"  5  0  \"  )  ;", "for    ( PropertyValue   pv    :    pvArray )     {", "Object   val    =    m . get ( pv . getName (  )  )  ;", "assertTrue (  \" Can ' t   have   unexpected   value \"  ,     ( val    !  =    null )  )  ;", "assertTrue (  \" Val   i   st \"  ,     ( val   instanceof   St )  )  ;", "assertTrue (  \" val   matches   expected \"  ,    val . equals ( pv . getValue (  )  )  )  ;", "m . remove ( pv . getName (  )  )  ;", "}", "assertTrue (  \" Map   size   is    0  \"  ,     (  ( m . size (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestTony"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" person \"  )  ;", "binder . registerCustomEditor ( ITestBean . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  )  )  ;", "}", "}  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" spouse \"  ,     \" someValue \"  )  ;", "request . addParameter (  \" spouse . name \"  ,     \" test \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertNotNull ( tb . getSpouse (  )  )  ;", "assertEquals (  \" test \"  ,    tb . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithNestedObjectCreation"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   WebRequestDataBinderTests . TestBeanWithConcreteSpouse (  )  ;", "WebRequestDataBinder   binder    =    new   WebRequestDataBinder ( tb ,     \" person \"  )  ;", "binder . setIgnoreUnknownFields ( false )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" concreteSpouse . name \"  ,     \" test \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertNotNull ( tb . getSpouse (  )  )  ;", "assertEquals (  \" test \"  ,    tb . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithNestedObjectCreationThroughAutoGrow"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setSomeSet ( null )  ;", "target . setSomeList ( null )  ;", "target . setSomeMap ( null )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  _ someSet \"  ,     \" visible \"  )  ;", "request . addParameter (  \"  _ someList \"  ,     \" visible \"  )  ;", "request . addParameter (  \"  _ someMap \"  ,     \" visible \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertThat ( target . getSomeSet (  )  ,    notNullValue (  )  )  ;", "assertThat ( target . getSomeSet (  )  ,    isA ( Set . class )  )  ;", "assertThat ( target . getSomeList (  )  ,    notNullValue (  )  )  ;", "assertThat ( target . getSomeList (  )  ,    isA ( List . class )  )  ;", "assertThat ( target . getSomeMap (  )  ,    notNullValue (  )  )  ;", "assertThat ( target . getSomeMap (  )  ,    isA ( Map . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionFieldsDefault"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "WebRequestDataBinderTests . EnumHolder   target    =    new   WebRequestDataBinderTests . EnumHolder (  )  ;", "WebRequestDataBinder   binder    =    new   WebRequestDataBinder ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" myEnum \"  ,     \" FOO \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertEquals ( WebRequestDataBinderTests . MyEnum . FOO ,    target . getMyEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEnumBinding"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  ! postProcessed \"  ,     \" off \"  )  ;", "request . addParameter (  \" postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \" postProcessed \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertFalse ( target . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefault"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  ! name \"  ,     \" anonymous \"  )  ;", "request . addParameter (  \" name \"  ,     \" Scott \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertEquals (  \" Scott \"  ,    target . getName (  )  )  ;", "request . removeParameter (  \" name \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertEquals (  \" anonymous \"  ,    target . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefaultNonBoolean"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  ! postProcessed \"  ,     \" on \"  )  ;", "request . addParameter (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "request . addParameter (  \" postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \" postProcessed \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \"  ! postProcessed \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertFalse ( target . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefaultPreemptsFieldMarker"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setSpouse ( new   TestBean (  )  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  ! spouse . postProcessed \"  ,     \" on \"  )  ;", "request . addParameter (  \"  _ spouse . postProcessed \"  ,     \" visible \"  )  ;", "request . addParameter (  \" spouse . postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertTrue (  (  ( TestBean )     ( target . getSpouse (  )  )  )  . isPostProcessed (  )  )  ;", "request . removeParameter (  \" spouse . postProcessed \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertTrue (  (  ( TestBean )     ( target . getSpouse (  )  )  )  . isPostProcessed (  )  )  ;", "request . removeParameter (  \"  ! spouse . postProcessed \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertFalse (  (  ( TestBean )     ( target . getSpouse (  )  )  )  . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldDefaultWithNestedProperty"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "request . addParameter (  \" postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \" postProcessed \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertFalse ( target . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldPrefixCausesFieldReset"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "binder . setIgnoreUnknownFields ( false )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \"  _ postProcessed \"  ,     \" visible \"  )  ;", "request . addParameter (  \" postProcessed \"  ,     \" on \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertTrue ( target . isPostProcessed (  )  )  ;", "request . removeParameter (  \" postProcessed \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertFalse ( target . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldPrefixCausesFieldResetWithIgnoreUnknownFields"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "binder . registerCustomEditor ( String . class ,    new   StringMultipartFileEditor (  )  )  ;", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "request . addFile ( new   MockMultipartFile (  \" name \"  ,     \" Juergen \"  . getBytes (  )  )  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertEquals (  \" Juergen \"  ,    target . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipartFileAsString"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "binder . registerCustomEditor ( String . class ,    new   StringMultipartFileEditor (  )  )  ;", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "request . addFile ( new   MockMultipartFile (  \" stringArray \"  ,     \" Juergen \"  . getBytes (  )  )  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertEquals (  1  ,    target . getStringArray (  )  . length )  ;", "assertEquals (  \" Juergen \"  ,    target . getStringArray (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testMultipartFileAsStringArray"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "binder . registerCustomEditor ( String . class ,    new   StringMultipartFileEditor (  )  )  ;", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "request . addFile ( new   MockMultipartFile (  \" stringArray \"  ,     \" Juergen \"  . getBytes (  )  )  )  ;", "request . addFile ( new   MockMultipartFile (  \" stringArray \"  ,     \" Eva \"  . getBytes (  )  )  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertEquals (  2  ,    target . getStringArray (  )  . length )  ;", "assertEquals (  \" Juergen \"  ,    target . getStringArray (  )  [  0  ]  )  ;", "assertEquals (  \" Eva \"  ,    target . getStringArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testMultipartFilesAsStringArray"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "String [  ]    original    =    new   String [  ]  {     \" Tony \"  ,     \" Rod \"     }  ;", "request . addParameter (  \" forname \"  ,    original )  ;", "ServletRequestParameterPropertyValues   pvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "assertTrue (  \" Found    1    parameter \"  ,     (  ( pvs . getPropertyValues (  )  . length )     =  =     1  )  )  ;", "assertTrue (  \" Found   array   value \"  ,     (  ( pvs . getPropertyValue (  \" forname \"  )  . getValue (  )  )    instanceof   String [  ]  )  )  ;", "String [  ]    values    =     (  ( String [  ]  )     ( pvs . getPropertyValue (  \" forname \"  )  . getValue (  )  )  )  ;", "assertEquals (  \" Correct   values \"  ,    Arrays . asList ( values )  ,    Arrays . asList ( original )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleValuesForParameter"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestParameterPropertyValues   pvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "assertTrue (  \" Found   no   parameters \"  ,     (  ( pvs . getPropertyValues (  )  . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoParameters"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" forname \"  ,     \" Tony \"  )  ;", "request . addParameter (  \" surname \"  ,     \" Blair \"  )  ;", "request . addParameter (  \" age \"  ,     (  \"  \"     +     5  0  )  )  ;", "ServletRequestParameterPropertyValues   pvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "doTestTony ( pvs )  ;", "}", "METHOD_END"], "methodName": ["testNoPrefix"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" test _ forname \"  ,     \" Tony \"  )  ;", "request . addParameter (  \" test _ surname \"  ,     \" Blair \"  )  ;", "request . addParameter (  \" test _ age \"  ,     (  \"  \"     +     5  0  )  )  ;", "ServletRequestParameterPropertyValues   pvs    =    new   ServletRequestParameterPropertyValues ( request )  ;", "assertTrue (  \" Didn ' t   fidn   normal   when   given   prefix \"  ,     (  !  ( pvs . contains (  \" forname \"  )  )  )  )  ;", "assertTrue (  \" Did   treat   prefix   as   normal   when   not   given   prefix \"  ,    pvs . contains (  \" test _ forname \"  )  )  ;", "pvs    =    new   ServletRequestParameterPropertyValues ( request ,     \" test \"  )  ;", "doTestTony ( pvs )  ;", "}", "METHOD_END"], "methodName": ["testPrefix"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "binder    =    new    ( target )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addParameter (  \" stringArray \"  ,     \" bar \"  )  ;", "request . addParameter (  \" stringArray \"  ,     \" abc \"  )  ;", "request . addParameter (  \" stringArray \"  ,     \"  1  2  3  , def \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertEquals (  \" Expected   all   three   items   to   be   bound \"  ,     3  ,    target . getStringArray (  )  . length )  ;", "request . removeParameter (  \" stringArray \"  )  ;", "request . addParameter (  \" stringArray \"  ,     \"  1  2  3  , def \"  )  ;", "binder . bind ( new   ServletWebRequest ( request )  )  ;", "assertEquals (  \" Expected   only    1    item   to   be   bound \"  ,     1  ,    target . getStringArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testWithCommaSeparatedStringArray"], "fileName": "org.springframework.web.bind.support.WebRequestDataBinderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( buffer . readUtf 8 Line (  )  . contains (  (  \"  -  -  \"     +    boundary )  )  )  ;", "St   line    =    buffer . readUtf 8 Line (  )  ;", "assertTrue ( line . contains (  (  \" Content - Disposition :     \"     +    disposition )  )  )  ;", "assertTrue ( line . contains (  (  (  \" name =  \\  \"  \"     +    name )     +     \"  \\  \"  \"  )  )  )  ;", "assertTrue ( line . contains (  (  (  \" filename =  \\  \"  \"     +    filename )     +     \"  \\  \"  \"  )  )  )  ;", "assertTrue ( buffer . readUtf 8 Line (  )  . startsWith (  (  \" Content - Type :     \"     +    contentType )  )  )  ;", "assertTrue ( buffer . readUtf 8 Line (  )  . startsWith (  \" Content - Length :     \"  )  )  ;", "assertTrue ( buffer . readUtf 8 Line (  )  . equals (  \"  \"  )  )  ;", "assertNotNull ( buffer . readUtf 8 Line (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertFilePart"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( buffer . readUtf 8 Line (  )  . contains (  (  \"  -  -  \"     +    boundary )  )  )  ;", "St   line    =    buffer . readUtf 8 Line (  )  ;", "assertTrue ( line . contains (  (  \" Content - Disposition :     \"     +    disposition )  )  )  ;", "assertTrue ( line . contains (  (  (  \" name =  \\  \"  \"     +    name )     +     \"  \\  \"  \"  )  )  )  ;", "assertTrue ( buffer . readUtf 8 Line (  )  . startsWith (  (  \" Content - Type :     \"     +    contentType )  )  )  ;", "assertTrue ( buffer . readUtf 8 Line (  )  . equals (  (  \" Content - Length :     \"     +     ( value . length (  )  )  )  )  )  ;", "assertTrue ( buffer . readUtf 8 Line (  )  . equals (  \"  \"  )  )  ;", "assertTrue ( buffer . readUtf 8 Line (  )  . equals ( value )  )  ;", "}", "METHOD_END"], "methodName": ["assertPart"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" application / x - www - form - urlencoded ; charset = UTF -  8  \"  ,    request . getHeader (  \" Content - Type \"  )  )  ;", "St   body    =    request . getBody (  )  . readUtf 8  (  )  ;", "assertThat ( body ,    Matchers . containsSt (  \" name +  1  = value +  1  \"  )  )  ;", "assertThat ( body ,    Matchers . containsSt (  \" name +  2  = value +  2  %  2 B 1  \"  )  )  ;", "assertThat ( body ,    Matchers . containsSt (  \" name +  2  = value +  2  %  2 B 2  \"  )  )  ;", "return   new   MockResponse (  )  . setResponseCode (  2  0  0  )  ;", "}", "METHOD_END"], "methodName": ["formRequest"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( request . getMethod (  )  . equals (  \" OPTIONS \"  )  )     {", "return   new   Response (  )  . setResponseCode (  2  0  0  )  . setHeader (  \" Allow \"  ,     \" GET ,    OPTIONS ,    HEAD ,    TRACE \"  )  ;", "}", "Buffer   buf    =    new   Buffer (  )  ;", "buf . write ( body )  ;", "Response   response    =    new   Response (  )  . setHeader (  \" Content - Length \"  ,    body . length )  . setBody ( buf )  . setResponseCode (  2  0  0  )  ;", "if    ( contentType    !  =    null )     {", "response    =    response . setHeader (  \" Content - Type \"  ,    contentType )  ;", "}", "return   response ;", "}", "METHOD_END"], "methodName": ["getRequest"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getBodySize (  )  )     >     0  )     {", "assertTrue (  \" Invalid   request   content - length \"  ,     (  ( Integer . parseInt ( request . getHeader (  \" Content - Length \"  )  )  )     >     0  )  )  ;", "assertNotNull (  \" No   content - type \"  ,    request . getHeader (  \" Content - Type \"  )  )  ;", "}", "return   new   Response (  )  . setHeader (  \" Location \"  ,     (  ( baseUrl )     +    location )  )  . setHeader (  \" Content - Type \"  ,    contentType )  . setHeader (  \" Content - Length \"  ,    request . getBody (  )  . size (  )  )  . setBody ( request . getBody (  )  )  . setResponseCode (  2  0  1  )  ;", "}", "METHOD_END"], "methodName": ["jsonPostRequest"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "MediaType   mediaType    =    MediaType . parseMediaType ( request . getHeader (  \" Content - Type \"  )  )  ;", "assertTrue ( mediaType . isCompatibleWith ( MediaType . MULTIPART _ FORM _ DATA )  )  ;", "St   boundary    =    mediaType . getParameter (  \" boundary \"  )  ;", "Buffer   body    =    request . getBody (  )  ;", "try    {", "assertPart ( body ,     \" form - data \"  ,    boundary ,     \" name    1  \"  ,     \" text / plain \"  ,     \" value    1  \"  )  ;", "assertPart ( body ,     \" form - data \"  ,    boundary ,     \" name    2  \"  ,     \" text / plain \"  ,     \" value    2  +  1  \"  )  ;", "assertPart ( body ,     \" form - data \"  ,    boundary ,     \" name    2  \"  ,     \" text / plain \"  ,     \" value    2  +  2  \"  )  ;", "assertFilePart ( body ,     \" form - data \"  ,    boundary ,     \" logo \"  ,     \" logo . jpg \"  ,     \" image / jpeg \"  )  ;", "}    catch    ( EOFException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "return   new   MockResponse (  )  . setResponseCode (  2  0  0  )  ;", "}", "METHOD_END"], "methodName": ["multipartRequest"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" PATCH \"  ,    request . getMethod (  )  )  ;", "assertTrue (  \" Invalid   request   content - length \"  ,     (  ( Integer . parseInt ( request . getHeader (  \" Content - Length \"  )  )  )     >     0  )  )  ;", "St   requestContentType    =    request . getHeader (  \" Content - Type \"  )  ;", "assertNotNull (  \" No   content - type \"  ,    requestContentType )  ;", "Charset   charset    =    StandardCharsets . ISO _  8  8  5  9  _  1  ;", "if    ( requestContentType . contains (  \" charset =  \"  )  )     {", "St   charsetName    =    requestContentType . split (  \" charset =  \"  )  [  1  ]  ;", "charset    =    Charset . forName ( charsetName )  ;", "}", "assertEquals (  \" Invalid   request   body \"  ,    expectedRequestContent ,    request . getBody (  )  . readSt ( charset )  )  ;", "Buffer   buf    =    new   Buffer (  )  ;", "buf . write ( responseBody )  ;", "return   new   MockResponse (  )  . setResponseCode (  2  0  1  )  . setHeader (  \" Content - Length \"  ,    responseBody . length )  . setHeader (  \" Content - Type \"  ,    contentType )  . setBody ( buf )  ;", "}", "METHOD_END"], "methodName": ["patchRequest"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    request . getHeaders (  )  . values (  \" Content - Length \"  )  . size (  )  )  ;", "assertTrue (  \" Invalid   request   content - length \"  ,     (  ( Integer . parseInt ( request . getHeader (  \" Content - Length \"  )  )  )     >     0  )  )  ;", "St   requestContentType    =    request . getHeader (  \" Content - Type \"  )  ;", "assertNotNull (  \" No   content - type \"  ,    requestContentType )  ;", "Charset   charset    =    StandardCharsets . ISO _  8  8  5  9  _  1  ;", "if    ( requestContentType . contains (  \" charset =  \"  )  )     {", "St   charsetName    =    requestContentType . split (  \" charset =  \"  )  [  1  ]  ;", "charset    =    Charset . forName ( charsetName )  ;", "}", "assertEquals (  \" Invalid   request   body \"  ,    expectedRequestContent ,    request . getBody (  )  . readSt ( charset )  )  ;", "Buffer   buf    =    new   Buffer (  )  ;", "buf . write ( responseBody )  ;", "return   new   MockResponse (  )  . setHeader (  \" Location \"  ,     (  ( baseUrl )     +    location )  )  . setHeader (  \" Content - Type \"  ,    contentType )  . setHeader (  \" Content - Length \"  ,    responseBody . length )  . setBody ( buf )  . setResponseCode (  2  0  1  )  ;", "}", "METHOD_END"], "methodName": ["postRequest"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Invalid   request   content - length \"  ,     (  ( Integer . parseInt ( request . getHeader (  \" Content - Length \"  )  )  )     >     0  )  )  ;", "St   requestContentType    =    request . getHeader (  \" Content - Type \"  )  ;", "assertNotNull (  \" No   content - type \"  ,    requestContentType )  ;", "Charset   charset    =    StandardCharsets . ISO _  8  8  5  9  _  1  ;", "if    ( requestContentType . contains (  \" charset =  \"  )  )     {", "St   charsetName    =    requestContentType . split (  \" charset =  \"  )  [  1  ]  ;", "charset    =    Charset . forName ( charsetName )  ;", "}", "assertEquals (  \" Invalid   request   body \"  ,    expectedRequestContent ,    request . getBody (  )  . readSt ( charset )  )  ;", "return   new   MockResponse (  )  . setResponseCode (  2  0  2  )  ;", "}", "METHOD_END"], "methodName": ["putRequest"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . server    =    new   MockWebServer (  )  ;", "this . server . setDispatcher ( new    . TestDispatcher (  )  )  ;", "this . server . start (  )  ;", "this . port    =    this . server . getPort (  )  ;", "this . baseUrl    =     \" http :  /  / localhost :  \"     +     ( this . port )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "this . server . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.web.client.AbstractMockWebServerTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   AsyncRestTemplate . AsyncRequestCallbackAdapter ( this . syncTemplate . acceptHeaderRequestCallback ( responseType )  )  ;", "}", "METHOD_END"], "methodName": ["acceptHeaderRequestCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   ListenableFutureAdapter < Set < HttpMethod >  ,    HttpHeaders >  ( future )     {", "@ Override", "protected   Set < HttpMethod >    adapt ( HttpHeaders   headers )    throws   ExecutionException    {", "return   headers . getAllow (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["adaptToAllowHeader"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   ListenableFutureAdapter < URI ,    HttpHeaders >  ( future )     {", "@ Override", "@ Nullable", "protected   URI   adapt ( HttpHeaders   headers )    throws   ExecutionException    {", "return   headers . getLocation (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["adaptToLocationHeader"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( url ,     \"  ' url '    must   not   be   null \"  )  ;", "Assert . notNull ( method ,     \"  ' method '    must   not   be   null \"  )  ;", "try    {", "AsyncClientHttpRequest   request    =    createAsyncRequest ( url ,    method )  ;", "if    ( requestCallback    !  =    null )     {", "requestCallback . doWithRequest ( request )  ;", "}", "ListenableFuture < ClientHttpResponse >    responseFuture    =    request . executeAsync (  )  ;", "return   new    . ResponseExtractorFuture ( method ,    url ,    responseFuture ,    responseExtractor )  ;", "}    catch    ( IOException   ex )     {", "throw   new   ResourceAccessException (  (  (  (  (  (  \" I / O   error   on    \"     +     ( method . name (  )  )  )     +     \"    request   for    \\  \"  \"  )     +    url )     +     \"  \\  \"  :  \"  )     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . syncTemplate . getErrorHandler (  )  ;", "}", "METHOD_END"], "methodName": ["getErrorHandler"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . syncTemplate . getMessageConverters (  )  ;", "}", "METHOD_END"], "methodName": ["getMessageConverters"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . syncTemplate . getUriTemplateHandler (  )  ;", "}", "METHOD_END"], "methodName": ["getUriTemplateHandler"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isWarnEnabled (  )  )     {", "try    {", "logger . warn (  (  (  (  (  (  (  (  (  \"     \"     +     ( method . name (  )  )  )     +     \"    request   for    \\  \"  \"  )     +    url )     +     \"  \\  \"    resulted   in    \"  )     +     ( response . getRawStatusCode (  )  )  )     +     \"     (  \"  )     +     ( response . getStatusText (  )  )  )     +     \"  )  ;    invoking   error   handler \"  )  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "getErrorHandler (  )  . handleError ( url ,    method ,    response )  ;", "}", "METHOD_END"], "methodName": ["handleResponseError"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . syncTemplate . headersExtractor (  )  ;", "}", "METHOD_END"], "methodName": ["headersExtractor"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   AsyncRestTemplate . AsyncRequestCallbackAdapter ( this . syncTemplate . httpEntityCallback ( requestBody )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   AsyncRestTemplate . AsyncRequestCallbackAdapter ( this . syncTemplate . httpEntityCallback ( request ,    responseType )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "try    {", "logger . debug (  (  (  (  (  (  (  (  (  \"     \"     +     ( method . name (  )  )  )     +     \"    request   for    \\  \"  \"  )     +    url )     +     \"  \\  \"    resulted   in    \"  )     +     ( response . getRawStatusCode (  )  )  )     +     \"     (  \"  )     +     ( response . getStatusText (  )  )  )     +     \"  )  \"  )  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["logResponseStatus"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . syncTemplate . responseEntityExtractor ( responseType )  ;", "}", "METHOD_END"], "methodName": ["responseEntityExtractor"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "UriTemplateHandler   handler    =    this . syncTemplate . getUriTemplateHandler (  )  ;", "if    ( handler   instanceof   DefaultUriBuilderFactory )     {", "(  ( DefaultUriBuilderFactory )     ( handler )  )  . setDefaultUriVariables ( defaultUriVariables )  ;", "} else", "if    ( handler   instanceof   util . AbstractUriTemplateHandler )     {", "(  ( util . AbstractUriTemplateHandler )     ( handler )  )  . setDefaultUriVariables ( defaultUriVariables )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" This   property   is   not   supported   with   the   configured   UriTemplateHandler .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setDefaultUriVariables"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "this . syncTemplate . setErrorHandler ( errorHandler )  ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "this . syncTemplate . setMessageConverters ( messageConverters )  ;", "}", "METHOD_END"], "methodName": ["setMessageConverters"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "this . syncTemplate . setUriTemplateHandler ( handler )  ;", "}", "METHOD_END"], "methodName": ["setUriTemplateHandler"], "fileName": "org.springframework.web.client.AsyncRestTemplate"}, {"methodBody": ["METHOD_START", "{", "Future <  ?  >    deletedFuture    =    template . delete ( new   URI (  (  ( baseUrl )     +     \"  / delete \"  )  )  )  ;", "deletedFuture . get (  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture <  ?  >    deletedFuture    =    template . delete ( new   URI (  (  ( baseUrl )     +     \"  / delete \"  )  )  )  ;", "deletedFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < Object >  (  )     {", "@ Override", "public   void   onSuccess ( Object   result )     {", "assertNull ( result )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( deletedFuture )  ;", "}", "METHOD_END"], "methodName": ["deleteCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture <  ?  >    deletedFuture    =    template . delete ( new   URI (  (  ( baseUrl )     +     \"  / delete \"  )  )  )  ;", "deletedFuture . addCallback ( Assert :  : assertNull ,     (    ex )     -  >    fail ( ex . getMessage (  )  )  )  ;", "waitTillDone ( deletedFuture )  ;", "}", "METHOD_END"], "methodName": ["deleteCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "HttpEntity <  ?  >    requestEntity    =    new   HttpEntity ( requestHeaders )  ;", "Future < ResponseEntity < String >  >    responseFuture    =    t . exchange (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    HttpMethod . GET ,    requestEntity ,    String . class ,     \" get \"  )  ;", "ResponseEntity < String >    response    =    responseFuture . get (  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    response . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["exchangeGet"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "HttpEntity <  ?  >    requestEntity    =    new   HttpEntity ( requestHeaders )  ;", "ListenableFuture < ResponseEntity < String >  >    responseFuture    =    template . exchange (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    HttpMethod . GET ,    requestEntity ,    String . class ,     \" get \"  )  ;", "responseFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < ResponseEntity < String >  >  (  )     {", "@ Override", "public   void   onSuccess ( ResponseEntity < String >    result )     {", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    result . getBody (  )  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( responseFuture )  ;", "}", "METHOD_END"], "methodName": ["exchangeGetCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "HttpEntity <  ?  >    requestEntity    =    new   HttpEntity ( requestHeaders )  ;", "ListenableFuture < ResponseEntity < String >  >    responseFuture    =    t . exchange (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    HttpMethod . GET ,    requestEntity ,    String . class ,     \" get \"  )  ;", "responseFuture . addCallback (  (    result )     -  >    assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    result . getBody (  )  )  ,     (    ex )     -  >    fail ( ex . getMessage (  )  )  )  ;", "waitTillDone ( responseFuture )  ;", "}", "METHOD_END"], "methodName": ["exchangeGetCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "requestHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "HttpEntity < String >    requestEntity    =    new   HttpEntity ( AbstractMockWebServerTestCase . helloWorld ,    requestHeaders )  ;", "Future < ResponseEntity < Void >  >    resultFuture    =    t . exchange (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    HttpMethod . POST ,    requestEntity ,    Void . class ,     \" post \"  )  ;", "ResponseEntity < Void >    result    =    resultFuture . get (  )  ;", "assertEquals (  \" Invalid   location \"  ,    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ,    result . getHeaders (  )  . getLocation (  )  )  ;", "assertFalse ( result . hasBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["exchangePost"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "requestHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "HttpEntity < String >    requestEntity    =    new   HttpEntity ( AbstractMockWebServerTestCase . helloWorld ,    requestHeaders )  ;", "ListenableFuture < ResponseEntity < Void >  >    resultFuture    =    template . exchange (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    HttpMethod . POST ,    requestEntity ,    Void . class ,     \" post \"  )  ;", "final   URI   expected    =    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ;", "resultFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < ResponseEntity < Void >  >  (  )     {", "@ Override", "public   void   onSuccess ( ResponseEntity < Void >    result )     {", "assertEquals (  \" Invalid   location \"  ,    expected ,    result . getHeaders (  )  . getLocation (  )  )  ;", "assertFalse ( result . hasBody (  )  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( resultFuture )  ;", "}", "METHOD_END"], "methodName": ["exchangePostCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "requestHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "HttpEntity < String >    requestEntity    =    new   HttpEntity ( AbstractMockWebServerTestCase . helloWorld ,    requestHeaders )  ;", "ListenableFuture < ResponseEntity < Void >  >    resultFuture    =    t . exchange (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    HttpMethod . POST ,    requestEntity ,    Void . class ,     \" post \"  )  ;", "final   URI   expected    =    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ;", "resultFuture . addCallback (  (    result )     -  >     {", "assertEquals (  \" Invalid   location \"  ,    expected ,    result . getHeaders (  )  . getLocation (  )  )  ;", "assertFalse ( result . hasBody (  )  )  ;", "}  ,     (    ex )     -  >    fail ( ex . getMessage (  )  )  )  ;", "waitTillDone ( resultFuture )  ;", "}", "METHOD_END"], "methodName": ["exchangePostCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AsyncRestTemplateIntegrationTests . RequestInterceptor   interceptor    =    new   AsyncRestTemplateIntegrationTests . RequestInterceptor (  )  ;", "template . setInterceptors ( Collections . singletonList ( interceptor )  )  ;", "template . getForEntity (  (  ( baseUrl )     +     \"  / status / notfound \"  )  ,    String . class )  ;", "interceptor . latch . await (  5  ,    TimeUnit . SECONDS )  ;", "assertNotNull ( interceptor . response )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,    interceptor . response . getStatusCode (  )  )  ;", "assertNull ( interceptor . exception )  ;", "}", "METHOD_END"], "methodName": ["getAndInterceptError"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AsyncRestTemplateIntegrationTests . RequestInterceptor   interceptor    =    new   AsyncRestTemplateIntegrationTests . RequestInterceptor (  )  ;", "template . setInterceptors ( Collections . singletonList ( interceptor )  )  ;", "ListenableFuture < ResponseEntity < String >  >    future    =    template . getForEntity (  (  ( baseUrl )     +     \"  / get \"  )  ,    String . class )  ;", "interceptor . latch . await (  5  ,    TimeUnit . SECONDS )  ;", "assertNotNull ( interceptor . response )  ;", "assertEquals ( HttpStatus . OK ,    interceptor . response . getStatusCode (  )  )  ;", "assertNull ( interceptor . exception )  ;", "assertEquals ( AbstractMockWebServerTestCase . helloWorld ,    future . get (  )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAndInterceptResponse"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Future < ResponseEntity < String >  >    future    =    template . getForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    String . class ,     \" get \"  )  ;", "ResponseEntity < String >    entity    =    future . get (  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    entity . getBody (  )  )  ;", "assertFalse (  \" No   headers \"  ,    entity . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    AbstractMockWebServerTestCase . textContentType ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    entity . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["getEntity"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < ResponseEntity < String >  >    futureEntity    =    template . getForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    String . class ,     \" get \"  )  ;", "futureEntity . addCallback ( new   util . concurrent . ListenableFutureCallback < ResponseEntity < String >  >  (  )     {", "@ Override", "public   void   onSuccess ( ResponseEntity < String >    entity )     {", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    entity . getBody (  )  )  ;", "assertFalse (  \" No   headers \"  ,    entity . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    AbstractMockWebServerTestCase . textContentType ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    entity . getStatusCode (  )  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( futureEntity )  ;", "}", "METHOD_END"], "methodName": ["getEntityCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < ResponseEntity < String >  >    futureEntity    =    template . getForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    String . class ,     \" get \"  )  ;", "futureEntity . addCallback (  (    entity )     -  >     {", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    entity . getBody (  )  )  ;", "assertFalse (  \" No   headers \"  ,    entity . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    AbstractMockWebServerTestCase . textContentType ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    entity . getStatusCode (  )  )  ;", "}  ,     (    ex )     -  >    fail ( ex . getMessage (  )  )  )  ;", "waitTillDone ( futureEntity )  ;", "}", "METHOD_END"], "methodName": ["getEntityCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < ResponseEntity < String >  >    future    =    template . getForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    String . class ,     \" get \"  )  ;", "ResponseEntity < String >    entity    =    future . completable (  )  . get (  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    entity . getBody (  )  )  ;", "assertFalse (  \" No   headers \"  ,    entity . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    AbstractMockWebServerTestCase . textContentType ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    entity . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["getEntityFromCompletable"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Future < ResponseEntity < String >  >    responseFuture    =    template . getForEntity (  (  ( baseUrl )     +     \"  / status / nocontent \"  )  ,    String . class )  ;", "ResponseEntity < String >    entity    =    responseFuture . get (  )  ;", "assertEquals (  \" Invalid   response   code \"  ,    HttpStatus . NO _ CONTENT ,    entity . getStatusCode (  )  )  ;", "assertNull (  \" Invalid   content \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNoContent"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Future < ResponseEntity < byte [  ]  >  >    futureEntity    =    template . getForEntity (  (  ( baseUrl )     +     \"  / get / nocontenttype \"  )  ,    byte [  ]  . class )  ;", "ResponseEntity < byte [  ]  >    responseEntity    =    futureEntity . get (  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld . getBytes (  \" UTF -  8  \"  )  ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNoContentTypeHeader"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Future < ResponseEntity < String >  >    futureEntity    =    template . getForEntity (  (  ( baseUrl )     +     \"  / get / nothing \"  )  ,    String . class )  ;", "ResponseEntity < String >    entity    =    futureEntity . get (  )  ;", "assertNull (  \" Invalid   content \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNoResponse"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Future < ResponseEntity < String >  >    responseFuture    =    template . getForEntity (  (  ( baseUrl )     +     \"  / status / notmodified \"  )  ,    String . class )  ;", "ResponseEntity < String >    entity    =    responseFuture . get (  )  ;", "assertEquals (  \" Invalid   response   code \"  ,    HttpStatus . NOT _ MODIFIED ,    entity . getStatusCode (  )  )  ;", "assertNull (  \" Invalid   content \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNotModified"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Future < HttpHeaders >    headersFuture    =    template . headForHeaders (  (  ( baseUrl )     +     \"  / get \"  )  )  ;", "HttpHeaders   headers    =    headersFuture . get (  )  ;", "assertTrue (  \" No   Content - Type   header \"  ,    headers . containsKey (  \" Content - Type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headForHeaders"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < HttpHeaders >    headersFuture    =    template . headForHeaders (  (  ( baseUrl )     +     \"  / get \"  )  )  ;", "headersFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < HttpHeaders >  (  )     {", "@ Override", "public   void   onSuccess ( HttpHeaders   result )     {", "assertTrue (  \" No   Content - Type   header \"  ,    result . containsKey (  \" Content - Type \"  )  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( headersFuture )  ;", "}", "METHOD_END"], "methodName": ["headForHeadersCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < HttpHeaders >    headersFuture    =    template . headForHeaders (  (  ( baseUrl )     +     \"  / get \"  )  )  ;", "headersFuture . addCallback (  (    result )     -  >    assertTrue (  \" No   Content - Type   header \"  ,    result . containsKey (  \" Content - Type \"  )  )  ,     (    ex )     -  >    fail ( ex . getMessage (  )  )  )  ;", "waitTillDone ( headersFuture )  ;", "}", "METHOD_END"], "methodName": ["headForHeadersCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "final   HttpClientErrorException [  ]    callbackException    =    new   HttpClientErrorException [  1  ]  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "ListenableFuture <  ?  >    future    =    template . execute (  (  ( baseUrl )     +     \"  / status / notfound \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "future . addCallback ( new   util . concurrent . ListenableFutureCallback < Object >  (  )     {", "@ Override", "public   void   onSuccess ( Object   result )     {", "fail (  \" onSuccess   not   expected \"  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "assertTrue (  ( ex   instanceof   HttpClientErrorException )  )  ;", "callbackException [  0  ]     =     (  ( HttpClientErrorException )     ( ex )  )  ;", "latch . countDown (  )  ;", "}", "}  )  ;", "try    {", "future . get (  )  ;", "fail (  \" Exception   expected \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "Throwable   cause    =    ex . getCause (  )  ;", "assertTrue (  ( cause   instanceof   HttpClientErrorException )  )  ;", "latch . await (  5  ,    TimeUnit . SECONDS )  ;", "assertSame ( callbackException [  0  ]  ,    cause )  ;", "}", "}", "METHOD_END"], "methodName": ["identicalExceptionThroughGetAndCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    parts    =    new   LinkedMultiValueMap (  )  ;", "parts . add (  \" name    1  \"  ,     \" value    1  \"  )  ;", "parts . add (  \" name    2  \"  ,     \" value    2  +  1  \"  )  ;", "parts . add (  \" name    2  \"  ,     \" value    2  +  2  \"  )  ;", "Resource   logo    =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )  ;", "parts . add (  \" logo \"  ,    logo )  ;", "HttpEntity < MultiValueMap < String ,    Object >  >    requestBody    =    new   HttpEntity ( parts )  ;", "Future < URI >    future    =    template . postForLocation (  (  ( baseUrl )     +     \"  / multipart \"  )  ,    requestBody )  ;", "future . get (  )  ;", "}", "METHOD_END"], "methodName": ["multipart"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Future < ResponseEntity < String >  >    future    =    template . getForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    String . class ,     \" get \"  )  ;", "future . get (  )  ;", "future . get (  )  ;", "}", "METHOD_END"], "methodName": ["multipleFutureGets"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture <  ?  >    future    =    template . execute (  (  ( baseUrl )     +     \"  / status / notfound \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "future . addCallback ( new   util . concurrent . ListenableFutureCallback < Object >  (  )     {", "@ Override", "public   void   onSuccess ( Object   result )     {", "fail (  \" onSuccess   not   expected \"  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   t )     {", "assertTrue (  ( t   instanceof   HttpClientErrorException )  )  ;", "HttpClientErrorException   ex    =     (  ( HttpClientErrorException )     ( t )  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,    ex . getStatusCode (  )  )  ;", "assertNotNull ( ex . getStatusText (  )  )  ;", "assertNotNull ( ex . getResponseBodyAsString (  )  )  ;", "}", "}  )  ;", "waitTillDone ( future )  ;", "}", "METHOD_END"], "methodName": ["notFoundCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture <  ?  >    future    =    template . execute (  (  ( baseUrl )     +     \"  / status / notfound \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "future . addCallback (  (    result )     -  >    fail (  \" onSuccess   not   expected \"  )  ,     (    ex )     -  >     {", "assertTrue (  ( ex   instanceof   HttpClientErrorException )  )  ;", "HttpClientErrorException   hcex    =     (  ( HttpClientErrorException )     ( ex )  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,    hcex . getStatusCode (  )  )  ;", "assertNotNull ( hcex . getStatusText (  )  )  ;", "assertNotNull ( hcex . getResponseBodyAsString (  )  )  ;", "}  )  ;", "waitTillDone ( future )  ;", "}", "METHOD_END"], "methodName": ["notFoundCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Future <  ?  >    future    =    t . execute (  (  ( baseUrl )     +     \"  / status / notfound \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "future . get (  )  ;", "fail (  \" HttpClientErrorException   expected \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   HttpClientErrorException )  )  ;", "HttpClientErrorException   cause    =     (  ( HttpClientErrorException )     ( ex . getCause (  )  )  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,    cause . getStatusCode (  )  )  ;", "assertNotNull ( cause . getStatusText (  )  )  ;", "assertNotNull ( cause . getResponseBodyAsString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["notFoundGet"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Future < Set < HttpMethod >  >    allowedFuture    =    template . optionsForAllow ( new   URI (  (  ( baseUrl )     +     \"  / get \"  )  )  )  ;", "Set < HttpMethod >    allowed    =    allowedFuture . get (  )  ;", "assertEquals (  \" Invalid   response \"  ,    EnumSet . of ( HttpMethod . GET ,    HttpMethod . OPTIONS ,    HttpMethod . HEAD ,    HttpMethod . TRACE )  ,    allowed )  ;", "}", "METHOD_END"], "methodName": ["optionsForAllow"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < Set < HttpMethod >  >    allowedFuture    =    template . optionsForAllow ( new   URI (  (  ( baseUrl )     +     \"  / get \"  )  )  )  ;", "allowedFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < Set < HttpMethod >  >  (  )     {", "@ Override", "public   void   onSuccess ( Set < HttpMethod >    result )     {", "assertEquals (  \" Invalid   response \"  ,    EnumSet . of ( HttpMethod . GET ,    HttpMethod . OPTIONS ,    HttpMethod . HEAD ,    HttpMethod . TRACE )  ,    result )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( allowedFuture )  ;", "}", "METHOD_END"], "methodName": ["optionsForAllowCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < Set < HttpMethod >  >    allowedFuture    =    template . optionsForAllow ( new   URI (  (  ( baseUrl )     +     \"  / get \"  )  )  )  ;", "allowedFuture . addCallback (  (    result )     -  >    assertEquals (  \" Invalid   response \"  ,    EnumSet . of ( HttpMethod . GET ,    HttpMethod . OPTIONS ,    HttpMethod . HEAD ,    HttpMethod . TRACE )  ,    result )  ,     (    ex )     -  >    fail ( ex . getMessage (  )  )  )  ;", "waitTillDone ( allowedFuture )  ;", "}", "METHOD_END"], "methodName": ["optionsForAllowCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpEntity < String >    requestEntity    =    new   HttpEntity <  >  ( AbstractMockWebServerTestCase . helloWorld )  ;", "Future < ResponseEntity < String >  >    responseEntityFuture    =    t . postForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    requestEntity ,    String . class ,     \" post \"  )  ;", "ResponseEntity < String >    responseEntity    =    responseEntityFuture . get (  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["postForEntity"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpEntity < String >    requestEntity    =    new   HttpEntity <  >  ( AbstractMockWebServerTestCase . helloWorld )  ;", "ListenableFuture < ResponseEntity < String >  >    responseEntityFuture    =    template . postForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    requestEntity ,    String . class ,     \" post \"  )  ;", "responseEntityFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < ResponseEntity < String >  >  (  )     {", "@ Override", "public   void   onSuccess ( ResponseEntity < String >    result )     {", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    result . getBody (  )  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( responseEntityFuture )  ;", "}", "METHOD_END"], "methodName": ["postForEntityCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpEntity < String >    requestEntity    =    new   HttpEntity <  >  ( AbstractMockWebServerTestCase . helloWorld )  ;", "ListenableFuture < ResponseEntity < String >  >    responseEntityFuture    =    t . postForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    requestEntity ,    String . class ,     \" post \"  )  ;", "responseEntityFuture . addCallback (  (    result )     -  >    assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    result . getBody (  )  )  ,     (    ex )     -  >    fail ( ex . getMessage (  )  )  )  ;", "waitTillDone ( responseEntityFuture )  ;", "}", "METHOD_END"], "methodName": ["postForEntityCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "HttpEntity < String >    entity    =    new   HttpEntity ( AbstractMockWebServerTestCase . helloWorld ,    entityHeaders )  ;", "Future < URI >    locationFuture    =    t . postForLocation (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    entity ,     \" post \"  )  ;", "URI   location    =    locationFuture . get (  )  ;", "assertEquals (  \" Invalid   location \"  ,    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ,    location )  ;", "}", "METHOD_END"], "methodName": ["postForLocation"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "HttpEntity < String >    entity    =    new   HttpEntity ( AbstractMockWebServerTestCase . helloWorld ,    entityHeaders )  ;", "final   URI   expected    =    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ;", "ListenableFuture < URI >    locationFuture    =    template . postForLocation (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    entity ,     \" post \"  )  ;", "locationFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < URI >  (  )     {", "@ Override", "public   void   onSuccess ( URI   result )     {", "assertEquals (  \" Invalid   location \"  ,    expected ,    result )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( locationFuture )  ;", "}", "METHOD_END"], "methodName": ["postForLocationCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "HttpEntity < String >    entity    =    new   HttpEntity ( AbstractMockWebServerTestCase . helloWorld ,    entityHeaders )  ;", "final   URI   expected    =    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ;", "ListenableFuture < URI >    locationFuture    =    t . postForLocation (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    entity ,     \" post \"  )  ;", "locationFuture . addCallback (  (    result )     -  >    assertEquals (  \" Invalid   location \"  ,    expected ,    result )  ,     (    ex )     -  >    fail ( ex . getMessage (  )  )  )  ;", "waitTillDone ( locationFuture )  ;", "}", "METHOD_END"], "methodName": ["postForLocationCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpEntity < String >    requestEntity    =    new   HttpEntity <  >  ( AbstractMockWebServerTestCase . helloWorld )  ;", "Future <  ?  >    responseEntityFuture    =    t . put (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    requestEntity ,     \" put \"  )  ;", "responseEntityFuture . get (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpEntity < String >    requestEntity    =    new   HttpEntity <  >  ( AbstractMockWebServerTestCase . helloWorld )  ;", "ListenableFuture <  ?  >    responseEntityFuture    =    template . put (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    requestEntity ,     \" put \"  )  ;", "responseEntityFuture . addCallback ( new   util . concurrent . ListenableFutureCallback < Object >  (  )     {", "@ Override", "public   void   onSuccess ( Object   result )     {", "assertNull ( result )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "waitTillDone ( responseEntityFuture )  ;", "}", "METHOD_END"], "methodName": ["putCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Future < Void >    future    =    t . execute (  (  ( baseUrl )     +     \"  / status / server \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "future . get (  )  ;", "fail (  \" HttpServerErrorException   expected \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   HttpServerErrorException )  )  ;", "HttpServerErrorException   cause    =     (  ( HttpServerErrorException )     ( ex . getCause (  )  )  )  ;", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    cause . getStatusCode (  )  )  ;", "assertNotNull ( cause . getStatusText (  )  )  ;", "assertNotNull ( cause . getResponseBodyAsString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["serverError"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < Void >    future    =    template . execute (  (  ( baseUrl )     +     \"  / status / server \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "future . addCallback ( new   util . concurrent . ListenableFutureCallback < Void >  (  )     {", "@ Override", "public   void   onSuccess ( Void   result )     {", "fail (  \" onSuccess   not   expected \"  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "assertTrue (  ( ex   instanceof   HttpServerErrorException )  )  ;", "HttpServerErrorException   hsex    =     (  ( HttpServerErrorException )     ( ex )  )  ;", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    hsex . getStatusCode (  )  )  ;", "assertNotNull ( hsex . getStatusText (  )  )  ;", "assertNotNull ( hsex . getResponseBodyAsString (  )  )  ;", "}", "}  )  ;", "waitTillDone ( future )  ;", "}", "METHOD_END"], "methodName": ["serverErrorCallback"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFuture < Void >    future    =    template . execute (  (  ( baseUrl )     +     \"  / status / server \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "future . addCallback (  (    result )     -  >    fail (  \" onSuccess   not   expected \"  )  ,     (    ex )     -  >     {", "assertTrue (  ( ex   instanceof   HttpServerErrorException )  )  ;", "HttpServerErrorException   hsex    =     (  ( HttpServerErrorException )     ( ex )  )  ;", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    hsex . getStatusCode (  )  )  ;", "assertNotNull ( hsex . getStatusText (  )  )  ;", "assertNotNull ( hsex . getResponseBodyAsString (  )  )  ;", "}  )  ;", "waitTillDone ( future )  ;", "}", "METHOD_END"], "methodName": ["serverErrorCallbackWithLambdas"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "while    (  !  ( future . isDone (  )  )  )     {", "}", "}", "METHOD_END"], "methodName": ["waitTillDone"], "fileName": "org.springframework.web.client.AsyncRestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    response . getHeaders (  )  ;", "MediaType   contentType    =    headers . getContentType (  )  ;", "return   contentType    !  =    null    ?    contentType . getCharset (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   statusCode    =    HttpStatus . resolve ( response . getRawStatusCode (  )  )  ;", "if    ( statusCode    =  =    null )     {", "throw   new   UnknownHttpStatusCodeException ( response . getRawStatusCode (  )  ,    response . getStatusText (  )  ,    response . getHeaders (  )  ,    geBody ( response )  ,    getCharset ( response )  )  ;", "}", "return   statusCode ;", "}", "METHOD_END"], "methodName": ["getHttpStatusCode"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   FileCopyUtils . copyToByteArray ( r . getBody (  )  )  ;", "}    catch    ( IOException   ex )     {", "}", "return   new   byte [  0  ]  ;", "}", "METHOD_END"], "methodName": ["getResponseBody"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "switch    ( statusCode . series (  )  )     {", "case   CLIENT _ ERROR    :", "throw   new   HttpClientErrorException ( statusCode ,    response . getStatusText (  )  ,    response . getHeaders (  )  ,    geBody ( response )  ,    getCharset ( response )  )  ;", "case   SERVER _ ERROR    :", "throw   new   HttpServerErrorException ( statusCode ,    response . getStatusText (  )  ,    response . getHeaders (  )  ,    geBody ( response )  ,    getCharset ( response )  )  ;", "default    :", "throw   new   UnknownHttpStatusCodeException ( statusCode . value (  )  ,    response . getStatusText (  )  ,    response . getHeaders (  )  ,    geBody ( response )  ,    getCharset ( response )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "return    (  ( statusCode . series (  )  )     =  =     ( HttpStatus . Series . CLIENT _ ERROR )  )     |  |     (  ( statusCode . series (  )  )     =  =     ( HttpStatus . Series . SERVER _ ERROR )  )  ;", "}", "METHOD_END"], "methodName": ["hasError"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", ". TestByteArrayInputStream   body    =    new    . TestByteArrayInputStream (  \" Hello   World \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn (  9  9  9  )  ;", "given ( response . getStatusText (  )  )  . willReturn (  \" Custom   status   code \"  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( headers )  ;", "given ( response . getBody (  )  )  . willReturn ( body )  ;", "assertFalse ( handler . hasError ( response )  )  ;", "assertFalse ( body . isClosed (  )  )  ;", "assertEquals (  \" Hello   World \"  ,    StreamUtils . copyToString ( response . getBody (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyAvailableAfterHasErrorForUnknownStatusCode"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NOT _ FOUND . value (  )  )  ;", "given ( response . getStatusText (  )  )  . willReturn (  \" Not   Found \"  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( headers )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream (  \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  )  )  ;", "try    {", "handler . handleError ( response )  ;", "fail (  \" expected   HttpClientErrorException \"  )  ;", "}    catch    ( HttpClientErrorException   ex )     {", "assertSame ( headers ,    ex . geHeaders (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", "given ( r . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NOT _ FOUND . value (  )  )  ;", "given ( r . getStatusText (  )  )  . willReturn (  \" Not   Found \"  )  ;", "given ( r . getHeaders (  )  )  . willReturn ( headers )  ;", "given ( r . getBody (  )  )  . willThrow ( new   IOException (  )  )  ;", "handler . handleError ( r )  ;", "}", "METHOD_END"], "methodName": ["handleErrorIOException"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", "given ( r . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NOT _ FOUND . value (  )  )  ;", "given ( r . getStatusText (  )  )  . willReturn (  \" Not   Found \"  )  ;", "given ( r . getHeaders (  )  )  . willReturn ( headers )  ;", "handler . handleError ( r )  ;", "}", "METHOD_END"], "methodName": ["handleErrorNullResponse"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "assertFalse ( handler . hasError ( response )  )  ;", "}", "METHOD_END"], "methodName": ["hasErrorFalse"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", "given ( r . getRawStatusCode (  )  )  . willReturn (  9  9  9  )  ;", "given ( r . getStatusText (  )  )  . willReturn (  \" Custom   status   code \"  )  ;", "given ( r . getHeaders (  )  )  . willReturn ( headers )  ;", "assertFalse ( handler . hasError ( r )  )  ;", "}", "METHOD_END"], "methodName": ["hasErrorForUnknownStatusCode"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NOT _ FOUND . value (  )  )  ;", "assertTrue ( handler . hasError ( response )  )  ;", "}", "METHOD_END"], "methodName": ["hasErrorTrue"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . TEXT _ PLAIN )  ;", "given ( r . getRawStatusCode (  )  )  . willReturn (  9  9  9  )  ;", "given ( r . getStatusText (  )  )  . willReturn (  \" Custom   status   code \"  )  ;", "given ( r . getHeaders (  )  )  . willReturn ( headers )  ;", "handler . handleError ( r )  ;", "}", "METHOD_END"], "methodName": ["unknownStatusCode"], "fileName": "org.springframework.web.client.DefaultResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( exceptionClass    =  =    null )     {", "return ;", "}", "HttpMessageConverteror <  ?    extends   RestClientException >    extractor    =    new   HttpMessageConverteror <  >  ( exceptionClass ,    this . messageConverters )  ;", "RestClientException   exception    =    extractor . extractData ( response )  ;", "if    ( exception    !  =    null )     {", "throw   exception ;", "}", "}", "METHOD_END"], "methodName": ["extract"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "this . messageConverters    =    messageConverters ;", "}", "METHOD_END"], "methodName": ["setMessageConverters"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( seriesMapping )  )  )     {", "this . seriesMapping . putAll ( seriesMapping )  ;", "}", "}", "METHOD_END"], "methodName": ["setSeriesMapping"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( statusMapping )  )  )     {", "this . statusMapping . putAll ( statusMapping )  ;", "}", "}", "METHOD_END"], "methodName": ["setStatusMapping"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . INTERNAL _ SERVER _ ERROR . value (  )  )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( MediaType . APPLICATION _ JSON )  ;", "given ( this . response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "byte [  ]    body    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "responseHeaders . setContentLength ( body . length )  ;", "given ( this . response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream ( body )  )  ;", "try    {", "this . errorHandler . handleError ( this . response )  ;", "fail (  \" MyRestClientException   expected \"  )  ;", "}    catch    (  . MyRestClientException   ex )     {", "assertEquals (  \" bar \"  ,    ex . getFoo (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleErrorSeriesMatch"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . I _ AM _ A _ TEAPOT . value (  )  )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( MediaType . APPLICATION _ JSON )  ;", "given ( this . response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "byte [  ]    body    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "responseHeaders . setContentLength ( body . length )  ;", "given ( this . response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream ( body )  )  ;", "try    {", "this . errorHandler . handleError ( this . response )  ;", "fail (  \" MyRestClientException   expected \"  )  ;", "}    catch    (  . MyRestClientException   ex )     {", "assertEquals (  \" bar \"  ,    ex . getFoo (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleErrorStatusMatch"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NOT _ FOUND . value (  )  )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( MediaType . APPLICATION _ JSON )  ;", "given ( this . response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "byte [  ]    body    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "responseHeaders . setContentLength ( body . length )  ;", "given ( this . response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream ( body )  )  ;", "try    {", "this . e . handleError ( this . response )  ;", "fail (  \" HttpClientErrorException   expected \"  )  ;", "}    catch    ( HttpClientErrorException   ex )     {", "assertEquals ( HttpStatus . NOT _ FOUND ,    ex . getStatusCode (  )  )  ;", "assertArrayEquals ( body ,    ex . getResponseBodyAsByteArray (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleNoMatch"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler . setSeriesMapping ( Collections . singletonMap ( HttpStatus . Series . CLIENT _ ERROR ,    null )  )  ;", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NOT _ FOUND . value (  )  )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( MediaType . APPLICATION _ JSON )  ;", "given ( this . response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "byte [  ]    body    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "responseHeaders . setContentLength ( body . length )  ;", "given ( this . response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream ( body )  )  ;", "this . errorHandler . handleError ( this . response )  ;", "}", "METHOD_END"], "methodName": ["handleNoMatchOverride"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . I _ AM _ A _ TEAPOT . value (  )  )  ;", "assertTrue ( this . e . hasError ( this . response )  )  ;", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . INTERNAL _ SERVER _ ERROR . value (  )  )  ;", "assertTrue ( this . e . hasError ( this . response )  )  ;", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "assertFalse ( this . e . hasError ( this . response )  )  ;", "}", "METHOD_END"], "methodName": ["hasError"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler . setSeriesMapping ( Collections . singletonMap ( HttpStatus . Series . CLIENT _ ERROR ,    null )  )  ;", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . I _ AM _ A _ TEAPOT . value (  )  )  ;", "assertTrue ( this . errorHandler . hasError ( this . response )  )  ;", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NOT _ FOUND . value (  )  )  ;", "assertFalse ( this . errorHandler . hasError ( this . response )  )  ;", "given ( this . response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "assertFalse ( this . errorHandler . hasError ( this . response )  )  ;", "}", "METHOD_END"], "methodName": ["hasErrorOverride"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter < Object >    converter    =    new   MappingJackson 2 HttpMessageConverter (  )  ;", "this . errorHandler    =    new   ExtractingResponseErrorHandler ( Collections . singletonList ( converter )  )  ;", "this . errorHandler . setStatusMapping ( Collections . singletonMap ( HttpStatus . I _ AM _ A _ TEAPOT ,     . MyRestClientException . class )  )  ;", "this . errorHandler . setSeriesMapping ( Collections . singletonMap ( HttpStatus . Series . SERVER _ ERROR ,     . MyRestClientException . class )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.client.ExtractingResponseErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    response . getHeaders (  )  . getContentType (  )  ;", "if    ( contentType    =  =    null )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . e (  \" No   Content - Type   header   found ,    defaulting   to   application / octet - stream \"  )  ;", "}", "contentType    =    MediaType . APPLICATION _ OCTET _ STREAM ;", "}", "return   contentType ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractor"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter < String >    converter    =    mock ( HttpMessageConverter . class )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "responseHeaders . setContentType ( contentType )  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream (  \" Foobar \"  . getBytes (  )  )  )  ;", "given ( converter . canRead ( String . class ,    contentType )  )  . willReturn ( false )  ;", "exception . expect ( RestClientException . class )  ;", "extractor . extractData ( response )  ;", "}", "METHOD_END"], "methodName": ["cannotRead"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter < String >    converter    =    mock ( HttpMessageConverter . class )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "responseHeaders . setContentType ( contentType )  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream (  \" Foobar \"  . getBytes (  )  )  )  ;", "given ( converter . canRead ( String . class ,    contentType )  )  . willThrow ( HttpMessageNotReadableException . class )  ;", "exception . expect ( RestClientException . class )  ;", "exception . expectMessage (  (  \" Error   while   extracting   response   for   type    \"     +     \"  [ class   String ]    and   content   type    [ text / plain ]  \"  )  )  ;", "exception . expectCause ( Matchers . instanceOf ( HttpMessageNotReadableException . class )  )  ;", "extractor . extractData ( response )  ;", "}", "METHOD_END"], "methodName": ["converterThrowsHttpMessageNotReadableException"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter < String >    converter    =    mock ( HttpMessageConverter . class )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "responseHeaders . setContentType ( contentType )  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream (  \" Foobar \"  . getBytes (  )  )  )  ;", "given ( converter . canRead ( String . class ,    contentType )  )  . willReturn ( true )  ;", "given ( converter . read ( eq ( String . class )  ,    any ( HttpInputMessage . class )  )  )  . willThrow ( IOException . class )  ;", "exception . expect ( RestClientException . class )  ;", "exception . expectMessage (  (  \" Error   while   extracting   response   for   type    \"     +     \"  [ class   String ]    and   content   type    [ text / plain ]  \"  )  )  ;", "exception . expectCause ( Matchers . instanceOf ( IOException . class )  )  ;", "extractor . extractData ( response )  ;", "}", "METHOD_END"], "methodName": ["converterThrowsIOException"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageConverter <  ?  >  >    converters    =    new   ArrayList <  >  (  1  )  ;", "converters . add ( converter )  ;", "return   converters ;", "}", "METHOD_END"], "methodName": ["createConverterList"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter < String >    converter    =    mock ( HttpMessageConverter . class )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream (  \"  \"  . getBytes (  )  )  )  ;", "Object   result    =    extractor . extractData ( response )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["emptyMessageBody"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "GenericHttpMessageConverter < String >    converter    =    mock ( GenericHttpMessageConverter . class )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "responseHeaders . setContentType ( contentType )  ;", "String   expected    =     \" Foo \"  ;", "ParameterizedTypeReference < List < String >  >    reference    =    new   ParameterizedTypeReference < List < String >  >  (  )     {  }  ;", "Type   type    =    reference . getType (  )  ;", "extractor    =    new    < List < String >  >  ( type ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream ( expected . getBytes (  )  )  )  ;", "given ( converter . canRead ( type ,    null ,    contentType )  )  . willReturn ( true )  ;", "given ( converter . read ( eq ( type )  ,    eq ( null )  ,    any ( HttpInputMessage . class )  )  )  . willReturn ( expected )  ;", "Object   result    =    extractor . extractData ( response )  ;", "assertEquals ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["generics"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter <  ?  >    converter    =    mock ( HttpMessageConverter . class )  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . CONTINUE . value (  )  )  ;", "Object   result    =    extractor . extractData ( response )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["informational"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter <  ?  >    converter    =    mock ( HttpMessageConverter . class )  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NO _ CONTENT . value (  )  )  ;", "Object   result    =    extractor . extractData ( response )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["noContent"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter < String >    converter    =    mock ( HttpMessageConverter . class )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "responseHeaders . setContentType ( contentType )  ;", "String   expected    =     \" Foo \"  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream ( expected . getBytes (  )  )  )  ;", "given ( converter . canRead ( String . class ,    contentType )  )  . willReturn ( true )  ;", "given ( converter . read ( eq ( String . class )  ,    any ( HttpInputMessage . class )  )  )  . willReturn ( expected )  ;", "Object   result    =    extractor . extractData ( response )  ;", "assertEquals ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter <  ?  >    converter    =    mock ( HttpMessageConverter . class )  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . NOT _ MODIFIED . value (  )  )  ;", "Object   result    =    extractor . extractData ( response )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["notModified"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter <  ?  >    converter    =    mock ( HttpMessageConverter . class )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentLength (  0  )  ;", "extractor    =    new    <  >  ( String . class ,    createConverterList ( converter )  )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( HttpStatus . OK . value (  )  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "Object   result    =    extractor . extractData ( response )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["zeroContentLength"], "fileName": "org.springframework.web.client.HttpMessageConverterExtractorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . statusCode ;", "}", "METHOD_END"], "methodName": ["getStatusCode"], "fileName": "org.springframework.web.client.HttpStatusCodeException"}, {"methodBody": ["METHOD_START", "{", "HttpStatusCodeException   ex 1     =    new   HttpClientErrorException ( HttpStatus . BAD _ REQUEST ,    null ,    null ,    StandardCharsets . US _ ASCII )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "new   ObjectOutputStream ( out )  . writeObject ( ex 1  )  ;", "ByteArrayInputStream   in    =    new   ByteArrayInputStream ( out . toByteArray (  )  )  ;", "HttpStatusCodeException   ex 2     =     (  ( HttpStatusCodeException )     ( new   ObjectInputStream ( in )  . readObject (  )  )  )  ;", "assertThat ( ex 2  . getResponseBodyAsString (  )  ,    equalTo ( ex 1  . getResponseBodyAsString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializability"], "fileName": "org.springframework.web.client.HttpStatusCodeExceptionTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   body    =    this . response . getBody (  )  ;", "if    ( body . markSupported (  )  )     {", "body . mark (  1  )  ;", "if    (  ( body . read (  )  )     =  =     (  -  1  )  )     {", "return   true ;", "} else    {", "body . reset (  )  ;", "return   false ;", "}", "} else    {", "this . pushbackInputStream    =    new   PushbackInputStream ( body )  ;", "int   b    =    this . pushbackInputStream . read (  )  ;", "if    ( b    =  =     (  -  1  )  )     {", "return   true ;", "} else    {", "this . pushbackInputStream . unread ( b )  ;", "return   false ;", "}", "}", "}", "METHOD_END"], "methodName": ["hasEmptyMessageBody"], "fileName": "org.springframework.web.client.MessageBodyClientHttpResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   status    =    HttpStatus . resolve ( getRawStatusCode (  )  )  ;", "if    (  ( status    !  =    null )     &  &     (  (  ( status . is 1 xxInformational (  )  )     |  |     ( status    =  =     ( HttpStatus . NO _ CONTENT )  )  )     |  |     ( status    =  =     ( HttpStatus . NOT _ MODIFIED )  )  )  )     {", "return   false ;", "}", "if    (  ( getHeaders (  )  . getContentLength (  )  )     =  =     0  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["hasMessageBody"], "fileName": "org.springframework.web.client.MessageBodyClientHttpResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "handleError ( response )  ;", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.springframework.web.client.ResponseErrorHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . rawStatusCode ;", "}", "METHOD_END"], "methodName": ["getRawStatusCode"], "fileName": "org.springframework.web.client.RestClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   this . responseBody ;", "}", "METHOD_END"], "methodName": ["getResponseBodyAsByteArray"], "fileName": "org.springframework.web.client.RestClientResponseException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . responseCharset )     =  =    null )     {", "return   new   String ( this . responseBody ,     . DEFAULT _ CHARSET )  ;", "}", "try    {", "return   new   String ( this . responseBody ,    this . responseCharset )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getResponseBodyAsString"], "fileName": "org.springframework.web.client.RestClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   this . responseHeaders ;", "}", "METHOD_END"], "methodName": ["getResponseHeaders"], "fileName": "org.springframework.web.client.RestClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   this . statusText ;", "}", "METHOD_END"], "methodName": ["getStatusText"], "fileName": "org.springframework.web.client.RestClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   new   RestTemplate . AcceptHeaderRequestCallback ( responseType )  ;", "}", "METHOD_END"], "methodName": ["acceptHeaderRequestCallback"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( url ,     \"  ' url '    must   not   be   null \"  )  ;", "Assert . notNull ( method ,     \"  ' method '    must   not   be   null \"  )  ;", "CHttpResponse   response    =    null ;", "try    {", "CHttpRequest   request    =    createRequest ( url ,    method )  ;", "if    ( requestCallback    !  =    null )     {", "requestCallback . doWithRequest ( request )  ;", "}", "response    =    request . execute (  )  ;", "handleResponse ( url ,    method ,    response )  ;", "if    ( responseExtractor    !  =    null )     {", "return   responseExtractor . extractData ( response )  ;", "} else    {", "return   null ;", "}", "}    catch    ( IOException   ex )     {", "String   resource    =    url . toString (  )  ;", "String   query    =    url . getRawQuery (  )  ;", "resource    =     ( query    !  =    null )     ?    resource . substring (  0  ,    resource . indexOf (  '  ?  '  )  )     :    resource ;", "throw   new   ResourceAccessException (  (  (  (  (  (  \" I / O   error   on    \"     +     ( method . name (  )  )  )     +     \"    request   for    \\  \"  \"  )     +    resource )     +     \"  \\  \"  :     \"  )     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}    finally    {", "if    ( response    !  =    null )     {", "response . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . errorHandler ;", "}", "METHOD_END"], "methodName": ["getErrorHandler"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . messageConverters ;", "}", "METHOD_END"], "methodName": ["getMessageConverters"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . uriTemplateHandler ;", "}", "METHOD_END"], "methodName": ["getUriTemplateHandler"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "ResponseErrorHandler   errorHandler    =    getErrorHandler (  )  ;", "boolean   hasError    =    errorHandler . hasError ( response )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "try    {", "logger . debug (  (  (  (  (  (  (  (  (  ( method . name (  )  )     +     \"    request   for    \\  \"  \"  )     +    url )     +     \"  \\  \"    resulted   in    \"  )     +     ( response . getRawStatusCode (  )  )  )     +     \"     (  \"  )     +     ( response . getStatusText (  )  )  )     +     \"  )  \"  )     +     ( hasError    ?     \"  ;    invoking   error   handler \"     :     \"  \"  )  )  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "if    ( hasError )     {", "errorHandler . handleError ( url ,    method ,    response )  ;", "}", "}", "METHOD_END"], "methodName": ["handleResponse"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . headersExtractor ;", "}", "METHOD_END"], "methodName": ["headersExtractor"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   RestTemplate . HttpEntityRequestCallback ( requestBody )  ;", "}", "METHOD_END"], "methodName": ["httpEntityCallback"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   RestTemplate . HttpEntityRequestCallback ( requestBody ,    responseType )  ;", "}", "METHOD_END"], "methodName": ["httpEntityCallback"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  ( result    !  =    null )  ,     \" No   result \"  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["nonNull"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   RestTemplate . ResponseEntityResponseExtractor <  >  ( responseType )  ;", "}", "METHOD_END"], "methodName": ["responseEntityExtractor"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . uriTemplateHandler )    instanceof   DefaultUriBuilderFactory )     {", "(  ( DefaultUriBuilderFactory )     ( this . uriTemplateHandler )  )  . setDefaultUriVariables ( uriVars )  ;", "} else", "if    (  ( this . uriTemplateHandler )    instanceof   util . AbstractUriTemplateHandler )     {", "(  ( util . AbstractUriTemplateHandler )     ( this . uriTemplateHandler )  )  . setDefaultUriVariables ( uriVars )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" This   property   is   not   supported   with   the   configured   UriTemplateHandler .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setDefaultUriVariables"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( errorHandler ,     \" ResponseErrorHandler   must   not   be   null \"  )  ;", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( messageConverters ,     \" At   least   one   HttpMessageConverter   required \"  )  ;", "if    (  ( this . messageConverters )     !  =    messageConverters )     {", "this . messageConvertersear (  )  ;", "this . messageConverters . addAll ( messageConverters )  ;", "}", "}", "METHOD_END"], "methodName": ["setMessageConverters"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( handler ,     \" UriTemplateHandler   must   not   be   null \"  )  ;", "this . uriTemplateHandler    =    handler ;", "}", "METHOD_END"], "methodName": ["setUriTemplateHandler"], "fileName": "org.springframework.web.client.RestTemplate"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( new   SimpleClientHttpRequestFactory (  )  ,    new   HttpComponentsClientHttpRequestFactory (  )  ,    new   Netty 4 ClientHttpRequestFactory (  )  ,    new   OkHttp 3 ClientHttpRequestFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["data"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "HttpEntity < String >    requestEntity    =    new   HttpEntity ( requestHeaders )  ;", "ResponseEntity < String >    response    =    t . exchange (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    HttpMethod . GET ,    requestEntity ,    String . class ,     \" get \"  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    response . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["exchangeGet"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "requestHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "HttpEntity < String >    entity    =    new   HttpEntity ( AbstractMockWebServerTestCase . helloWorld ,    requestHeaders )  ;", "HttpEntity < Void >    result    =    t . exchange (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    HttpMethod . POST ,    entity ,    Void . class ,     \" post \"  )  ;", "assertEquals (  \" Invalid   location \"  ,    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ,    result . getHeaders (  )  . getLocation (  )  )  ;", "assertFalse ( result . hasBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["exchangePost"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    form    =    new   LinkedMultiValueMap (  )  ;", "form . add (  \" name    1  \"  ,     \" value    1  \"  )  ;", "form . add (  \" name    2  \"  ,     \" value    2  +  1  \"  )  ;", "form . add (  \" name    2  \"  ,     \" value    2  +  2  \"  )  ;", "template . postForLocation (  (  ( baseUrl )     +     \"  / form \"  )  ,    form )  ;", "}", "METHOD_END"], "methodName": ["form"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    template . getForEntity (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    String . class ,     \" get \"  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    entity . getBody (  )  )  ;", "assertFalse (  \" No   headers \"  ,    entity . getHeaders (  )  . isEmpty (  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    AbstractMockWebServerTestCase . textContentType ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    entity . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["getEntity"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =    template . getForObject (  (  ( baseUrl )     +     \"  / status / nocontent \"  )  ,    String . class )  ;", "assertNull (  \" Invalid   content \"  ,    s )  ;", "ResponseEntity < String >    entity    =    template . getForEntity (  (  ( baseUrl )     +     \"  / status / nocontent \"  )  ,    String . class )  ;", "assertEquals (  \" Invalid   response   code \"  ,    HttpStatus . NO _ CONTENT ,    entity . getStatusCode (  )  )  ;", "assertNull (  \" Invalid   content \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNoContent"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    template . getForObject (  (  ( baseUrl )     +     \"  / get / nocontenttype \"  )  ,    byte [  ]  . class )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld . getBytes (  \" UTF -  8  \"  )  ,    bytes )  ;", "}", "METHOD_END"], "methodName": ["getNoContentTypeHeader"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =    template . getForObject (  (  ( baseUrl )     +     \"  / get / nothing \"  )  ,    String . class )  ;", "assertNull (  \" Invalid   content \"  ,    s )  ;", "}", "METHOD_END"], "methodName": ["getNoResponse"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =    template . getForObject (  (  ( baseUrl )     +     \"  / status / notmodified \"  )  ,    String . class )  ;", "assertNull (  \" Invalid   content \"  ,    s )  ;", "ResponseEntity < String >    entity    =    template . getForEntity (  (  ( baseUrl )     +     \"  / status / notmodified \"  )  ,    String . class )  ;", "assertEquals (  \" Invalid   response   code \"  ,    HttpStatus . NOT _ MODIFIED ,    entity . getStatusCode (  )  )  ;", "assertNull (  \" Invalid   content \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNotModified"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =    template . getForObject (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    String . class ,     \" get \"  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    s )  ;", "}", "METHOD_END"], "methodName": ["getString"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  8  )  )  ;", ". MySampleBean   bean    =    new    . MySampleBean (  )  ;", "bean . setWith 1  (  \" with \"  )  ;", "bean . setWith 2  (  \" with \"  )  ;", "bean . setWithout (  \" without \"  )  ;", "HttpEntity <  . MySampleBean >    entity    =    new   HttpEntity ( bean ,    entityHeaders )  ;", "String   s    =    template . postForObject (  (  ( baseUrl )     +     \"  / jsonpost \"  )  ,    entity ,    String . class )  ;", "assertTrue ( s . contains (  \"  \\  \" with 1  \\  \"  :  \\  \" with \\  \"  \"  )  )  ;", "assertTrue ( s . contains (  \"  \\  \" with 2  \\  \"  :  \\  \" with \\  \"  \"  )  )  ;", "assertTrue ( s . contains (  \"  \\  \" without \\  \"  :  \\  \" without \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonPostForObject"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < RestTemplateIntegrationTests . ParentClass >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new   RestTemplateIntegrationTests . Foo (  \" foo \"  )  )  ;", "list . add ( new   RestTemplateIntegrationTests . Bar (  \" bar \"  )  )  ;", "ParameterizedTypeReference <  ?  >    typeReference    =    new   ParameterizedTypeReference < List < RestTemplateIntegrationTests . ParentClass >  >  (  )     {  }  ;", "RequestEntity < List < RestTemplateIntegrationTests . ParentClass >  >    entity    =    RequestEntity . post ( new   URI (  (  ( baseUrl )     +     \"  / jsonpost \"  )  )  )  . contentType ( new   MediaType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  8  )  )  . body ( list ,    typeReference . getType (  )  )  ;", "String   content    =    template . exchange ( entity ,    String . class )  . getBody (  )  ;", "assertTrue ( content . contains (  \"  \\  \" type \\  \"  :  \\  \" foo \\  \"  \"  )  )  ;", "assertTrue ( content . contains (  \"  \\  \" type \\  \"  :  \\  \" bar \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonPostForObjectWithJacksonTypeInfoList"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( new   MediaType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  8  )  )  ;", ". MySampleBean   bean    =    new    . MySampleBean (  \" with \"  ,     \" with \"  ,     \" without \"  )  ;", "MappingJacksonValue   jacksonValue    =    new   MappingJacksonValue ( bean )  ;", "jacksonValue . setSerializationView (  . MyJacksonView 1  . class )  ;", "HttpEntity < MappingJacksonValue >    entity    =    new   HttpEntity ( jacksonValue ,    entityHeaders )  ;", "String   s    =    template . postForObject (  (  ( baseUrl )     +     \"  / jsonpost \"  )  ,    entity ,    String . class )  ;", "assertTrue ( s . contains (  \"  \\  \" with 1  \\  \"  :  \\  \" with \\  \"  \"  )  )  ;", "assertFalse ( s . contains (  \"  \\  \" with 2  \\  \"  :  \\  \" with \\  \"  \"  )  )  ;", "assertFalse ( s . contains (  \"  \\  \" without \\  \"  :  \\  \" without \\  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonPostForObjectWithJacksonView"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    parts    =    new   LinkedMultiValueMap (  )  ;", "parts . add (  \" name    1  \"  ,     \" value    1  \"  )  ;", "parts . add (  \" name    2  \"  ,     \" value    2  +  1  \"  )  ;", "parts . add (  \" name    2  \"  ,     \" value    2  +  2  \"  )  ;", "Resource   logo    =    new   ClassPathResource (  \"  / org / springframework / http / converter / logo . jpg \"  )  ;", "parts . add (  \" logo \"  ,    logo )  ;", "template . postForLocation (  (  ( baseUrl )     +     \"  / multipart \"  )  ,    parts )  ;", "}", "METHOD_END"], "methodName": ["multipart"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "t . execute (  (  ( baseUrl )     +     \"  / status / notfound \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "fail (  \" HttpClientErrorException   expected \"  )  ;", "}    catch    ( HttpClientErrorException   ex )     {", "assertEquals ( HttpStatus . NOT _ FOUND ,    ex . getStatusCode (  )  )  ;", "assertNotNull ( ex . getStatusText (  )  )  ;", "assertNotNull ( ex . getResponseBodyAsString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Set < HttpMethod >    allowed    =    template . optionsForAllow ( new   URI (  (  ( baseUrl )     +     \"  / get \"  )  )  )  ;", "assertEquals (  \" Invalid   response \"  ,    EnumSet . of ( HttpMethod . GET ,    HttpMethod . OPTIONS ,    HttpMethod . HEAD ,    HttpMethod . TRACE )  ,    allowed )  ;", "}", "METHOD_END"], "methodName": ["optionsForAllow"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assume . assumeThat ( this . clientHttpRequestFactory ,    Matchers . not ( Matchers . instanceOf ( SimpleClientHttpRequestFactory . class )  )  )  ;", "String   s    =    template . patchForObject (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    AbstractMockWebServerTestCase . helloWorld ,    String . class ,     \" patch \"  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    s )  ;", "}", "METHOD_END"], "methodName": ["patchForObject"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    template . postForLocation (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    AbstractMockWebServerTestCase . helloWorld ,     \" post \"  )  ;", "assertEquals (  \" Invalid   location \"  ,    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ,    location )  ;", "}", "METHOD_END"], "methodName": ["postForLocation"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "HttpEntity < String >    entity    =    new   HttpEntity ( AbstractMockWebServerTestCase . helloWorld ,    entityHeaders )  ;", "URI   location    =    t . postForLocation (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    entity ,     \" post \"  )  ;", "assertEquals (  \" Invalid   location \"  ,    new   URI (  (  ( baseUrl )     +     \"  / post /  1  \"  )  )  ,    location )  ;", "}", "METHOD_END"], "methodName": ["postForLocationEntity"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =    template . postForObject (  (  ( baseUrl )     +     \"  /  { method }  \"  )  ,    AbstractMockWebServerTestCase . helloWorld ,    String . class ,     \" post \"  )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    s )  ;", "}", "METHOD_END"], "methodName": ["postForObject"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( template . postForObject (  (  ( baseUrl )     +     \"  / jsonpost \"  )  ,    null ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["postWithoutBody"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "t . execute (  (  ( baseUrl )     +     \"  / status / server \"  )  ,    HttpMethod . GET ,    null ,    null )  ;", "fail (  \" HttpServerErrorException   expected \"  )  ;", "}    catch    ( HttpServerErrorException   ex )     {", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    ex . getStatusCode (  )  )  ;", "assertNotNull ( ex . getStatusText (  )  )  ;", "assertNotNull ( ex . getResponseBodyAsString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["serverError"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =    template . getForObject (  \" http :  /  / localhost :  { port }  / get \"  ,    String . class ,    port )  ;", "assertEquals (  \" Invalid   content \"  ,    AbstractMockWebServerTestCase . helloWorld ,    s )  ;", "}", "METHOD_END"], "methodName": ["serverPort"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . template    =    new   RestTemplate ( this . clientHttpRequestFactory )  ;", "}", "METHOD_END"], "methodName": ["setupClient"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =    template . getForObject (  (  ( baseUrl )     +     \"  / uri /  { query }  \"  )  ,    String . class ,     \" Z \\ u 0  0 fcrich \"  )  ;", "assertEquals (  \" Invalid   request   URI \"  ,     \"  / uri / Z % C 3  % BCrich \"  ,    result )  ;", "result    =    template . getForObject (  (  ( baseUrl )     +     \"  / uri / query =  { query }  \"  )  ,    String . class ,     \" foo @ bar \"  )  ;", "assertEquals (  \" Invalid   request   URI \"  ,     \"  / uri / query = foo @ bar \"  ,    result )  ;", "result    =    template . getForObject (  (  ( baseUrl )     +     \"  / uri / query =  { query }  \"  )  ,    String . class ,     \" T \\ u 0  1  4 dky \\ u 0  1  4 d \"  )  ;", "assertEquals (  \" Invalid   request   URI \"  ,     \"  / uri / query = T % C 5  %  8 Dky % C 5  %  8 D \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["uri"], "fileName": "org.springframework.web.client.RestTemplateIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . DELETE ,     \" http :  /  / example . com \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "t . delete (  \" http :  /  / example . com \"  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / example . com \"  ;", "mockSentRequest ( HttpMethod . GET ,    url )  ;", "mockResponseStatus ( HttpStatus . INTERNAL _ SERVER _ ERROR )  ;", "willThrow ( new   HttpServerErrorException ( HttpStatus . INTERNAL _ SERVER _ ERROR )  )  . given ( errorHandler )  . handleError ( new   URI ( url )  ,    HttpMethod . GET ,    response )  ;", "try    {", "t . execute ( url ,    HttpMethod . GET ,    null ,    null )  ;", "fail (  \" HttpServerErrorException   expected \"  )  ;", "}    catch    ( HttpServerErrorException   ex )     {", "}", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["errorHandling"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockTextPlainHttpMessageConverter (  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "String   expected    =     \"  4  2  \"  ;", "mockResponseBody ( expected ,    MediaType . TEXT _ PLAIN )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "HttpEntity < String >    entity    =    new   HttpEntity (  \" Hello   World \"  ,    entityHeaders )  ;", "ResponseEntity < String >    result    =    t . exchange (  \" http :  /  / example . com \"  ,    HttpMethod . POST ,    entity ,    String . class )  ;", "assertEquals (  \" Invalid   POST   result \"  ,    expected ,    result . getBody (  )  )  ;", "assertEquals (  \" Invalid   Content - Type \"  ,    MediaType . TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    MediaType . TEXT _ PLAIN _ VALUE ,    requestHeaders . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \" Invalid   custom   header \"  ,     \" MyValue \"  ,    requestHeaders . getFirst (  \" MyHeader \"  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    result . getStatusCode (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["exchange"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "GenericHttpMessageConverter   converter    =    mock ( GenericHttpMessageConverter . class )  ;", "t . setMessageConverters ( Collections .  < HttpMessageConverter <  ?  >  > singletonList ( converter )  )  ;", "ParameterizedTypeReference < List < Integer >  >    intList    =    new   ParameterizedTypeReference < List < Integer >  >  (  )     {  }  ;", "given ( converter . canRead ( intList . getType (  )  ,    null ,    null )  )  . willReturn ( true )  ;", "given ( converter . getSupportedMediaTypes (  )  )  . willReturn ( Collections . singletonList ( MediaType . TEXT _ PLAIN )  )  ;", "given ( converter . canWrite ( String . class ,    String . class ,    null )  )  . willReturn ( true )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "List < Integer >    expected    =    Collections . singletonList (  4  2  )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "responseHeaders . setContentLength (  1  0  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream ( Integer . toString (  4  2  )  . getBytes (  )  )  )  ;", "given ( converter . canRead ( intList . getType (  )  ,    null ,    MediaType . TEXT _ PLAIN )  )  . willReturn ( true )  ;", "given ( converter . read ( eq ( intList . getType (  )  )  ,    eq ( null )  ,    any ( HttpInputMessage . class )  )  )  . willReturn ( expected )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "HttpEntity < String >    requestEntity    =    new   HttpEntity (  \" Hello   World \"  ,    entityHeaders )  ;", "ResponseEntity < List < Integer >  >    result    =    t . exchange (  \" http :  /  / example . com \"  ,    HttpMethod . POST ,    requestEntity ,    intList )  ;", "assertEquals (  \" Invalid   POST   result \"  ,    expected ,    result . getBody (  )  )  ;", "assertEquals (  \" Invalid   Content - Type \"  ,    MediaType . TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    MediaType . TEXT _ PLAIN _ VALUE ,    requestHeaders . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \" Invalid   custom   header \"  ,     \" MyValue \"  ,    requestHeaders . getFirst (  \" MyHeader \"  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    result . getStatusCode (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["exchangeParameterizedType"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockTextPlainHttpMessageConverter (  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "String   expected    =     \" Hello   World \"  ;", "mockTextResponseBody ( expected )  ;", "ResponseEntity < String >    result    =    t . getForEntity (  \" http :  /  / example . com \"  ,    String . class )  ;", "assertEquals (  \" Invalid   GET   result \"  ,    expected ,    result . getBody (  )  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    MediaType . TEXT _ PLAIN _ VALUE ,    requestHeaders . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \" Invalid   Content - Type   header \"  ,    MediaType . TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    result . getStatusCode (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getForEntity"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" Hello   World \"  ;", "mockTextPlainHttpMessageConverter (  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "mockTextResponseBody (  \" Hello   World \"  )  ;", "String   result    =    t . getForObject (  \" http :  /  / example . com \"  ,    String . class )  ;", "assertEquals (  \" Invalid   GET   result \"  ,    expected ,    result )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    MediaType . TEXT _ PLAIN _ VALUE ,    requestHeaders . getFirst (  \" Accept \"  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getForObject"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   uriTemplateHandler    =    new   DefaultUriBuilderFactory (  )  ;", "template . setUriTemplateHandler ( uriTemplateHandler )  ;", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com / hotels /  1  / pic / pics %  2 Flogo . png / size /  1  5  0 x 1  5  0  \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "given ( response . getHeaders (  )  )  . willReturn ( new   HttpHeaders (  )  )  ;", "given ( response . getBody (  )  )  . willReturn ( StreamUtils . emptyInput (  )  )  ;", "Map < String ,    String >    uriVariables    =    new   HashMap <  >  (  2  )  ;", "uriVariables . put (  \" hotel \"  ,     \"  1  \"  )  ;", "uriVariables . put (  \" publicpath \"  ,     \" pics / logo . png \"  )  ;", "uriVariables . put (  \" scale \"  ,     \"  1  5  0 x 1  5  0  \"  )  ;", "String   url    =     \" http :  /  / example . com / hotels /  { hotel }  / pic /  { publicpath }  / size /  { scale }  \"  ;", "template . getForObject ( url ,    String . class ,    uriVariables )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getForObjectWithCustomUriTemplateHandler"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com / resource \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "given ( converter . canRead ( String . class ,    null )  )  . willReturn ( true )  ;", "MediaType   supportedMediaType    =    new   MediaType (  \" foo \"  ,     \" bar \"  )  ;", "given ( converter . getSupportedMediaTypes (  )  )  . willReturn ( Collections . singletonList ( supportedMediaType )  )  ;", "MediaType   barBaz    =    new   MediaType (  \" bar \"  ,     \" baz \"  )  ;", "mockResponseBody (  \" Foo \"  ,    new   MediaType (  \" bar \"  ,     \" baz \"  )  )  ;", "given ( converter . canRead ( String . class ,    barBaz )  )  . willReturn ( false )  ;", "try    {", "t . getForObject (  \" http :  /  / example . com /  { p }  \"  ,    String . class ,     \" resource \"  )  ;", "fail (  \" UnsupportedMediaTypeException   expected \"  )  ;", "}    catch    ( RestClientException   ex )     {", "}", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["getUnsupportedMediaType"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . HEAD ,     \" http :  /  / example . com \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "HttpHeaders   result    =    t . headForHeaders (  \" http :  /  / example . com \"  )  ;", "assertSame (  \" Invalid   headers   returned \"  ,    responseHeaders ,    result )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["headForHeaders"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / example . com / resource ? access _ token =  1  2  3  \"  ;", "mockSentRequest ( HttpMethod . GET ,    url )  ;", "mockHttpMessageConverter ( new   MediaType (  \" foo \"  ,     \" bar \"  )  ,    String . class )  ;", "given ( request . execute (  )  )  . willThrow ( new   IOException (  \" Socket   failure \"  )  )  ;", "try    {", "t . getForObject ( url ,    String . class )  ;", "fail (  \" RestClientException   expected \"  )  ;", "}    catch    ( ResourceAccessException   ex )     {", "assertEquals (  (  \" I / O   error   on   GET   request   for    \\  \" http :  /  / example . com / resource \\  \"  :     \"     +     \" Socket   failure ;    nested   exception   is   IOException :    Socket   failure \"  )  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ioException"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" http \"  ,     \" example . com \"  ,     \"  / resource \"  ,     \"  \"  ,    null )  ;", "given ( converter . canRead ( String . class ,    null )  )  . willReturn ( true )  ;", "given ( converter . getSupportedMediaTypes (  )  )  . willReturn ( Collections . singletonList ( MediaType . parseMediaType (  \" foo / bar \"  )  )  )  ;", "given ( requestFactory . createRequest ( uri ,    HttpMethod . GET )  )  . willReturn ( request )  ;", "given ( request . getHeaders (  )  )  . willReturn ( new   HttpHeaders (  )  )  ;", "given ( request . execute (  )  )  . willThrow ( new   IOException (  \" Socket   failure \"  )  )  ;", "try    {", "t . getForObject ( uri ,    String . class )  ;", "fail (  \" RestClientException   expected \"  )  ;", "}    catch    ( ResourceAccessException   ex )     {", "assertEquals (  (  \" I / O   error   on   GET   request   for    \\  \" http :  /  / example . com / resource \\  \"  :     \"     +     \" Socket   failure ;    nested   exception   is   IOException :    Socket   failure \"  )  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ioExceptionWithEmptyQueryString"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com /  - foo \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "Map < String ,    String >    vars    =    new   HashMap <  >  (  2  )  ;", "vars . put (  \" first \"  ,    null )  ;", "vars . put (  \" last \"  ,     \" foo \"  )  ;", "t . execute (  \" http :  /  / example . com /  { first }  -  { last }  \"  ,    HttpMethod . GET ,    null ,    null ,    vars )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["mapNullTemplateVariable"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com / hotels /  4  2  / bookings /  4  2  \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "Map < String ,    String >    vars    =    Collections . singletonMap (  \" hotel \"  ,     \"  4  2  \"  )  ;", "t . execute (  \" http :  /  / example . com / hotels /  { hotel }  / bookings /  { hotel }  \"  ,    HttpMethod . GET ,    null ,    null ,    vars )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["mapTemplateVariables"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( converter . canRead ( type ,    null )  )  . willReturn ( true )  ;", "given ( converter . canRead ( type ,    mediaType )  )  . willReturn ( true )  ;", "given ( converter . getSupportedMediaTypes (  )  )  . willReturn ( Collections . sletonList ( mediaType )  )  ;", "given ( converter . canRead ( type ,    mediaType )  )  . willReturn ( true )  ;", "given ( converter . canWrite ( type ,    null )  )  . willReturn ( true )  ;", "given ( converter . canWrite ( type ,    mediaType )  )  . willReturn ( true )  ;", "}", "METHOD_END"], "methodName": ["mockHttpMessageConverter"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( mediaType )  ;", "responseHeaders . setContentLength ( expectedBody . length (  )  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( new   ByteArrayInputStream ( expectedBody . getBytes (  )  )  )  ;", "given ( converter . read ( eq ( St . class )  ,    any ( HttpInputMessage . class )  )  )  . willReturn ( expectedBody )  ;", "}", "METHOD_END"], "methodName": ["mockResponseBody"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( request . execute (  )  )  . willReturn ( response )  ;", "given ( errorHandler . hasError ( response )  )  . willReturn ( responseStatus . isError (  )  )  ;", "given ( response . getStatusCode (  )  )  . willReturn ( responseStatus )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( responseStatus . value (  )  )  ;", "given ( response . getStatusText (  )  )  . willReturn ( responseStatus . getReasonPhrase (  )  )  ;", "}", "METHOD_END"], "methodName": ["mockResponseStatus"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( method ,    uri ,    new   HttpHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["mockSentRequest"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( requestFactory . createRequest ( new   URI ( uri )  ,    method )  )  . willReturn ( request )  ;", "given ( request . getHeaders (  )  )  . willReturn ( requestHeaders )  ;", "}", "METHOD_END"], "methodName": ["mockSentRequest"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockHttpMessageConverter ( MediaType . TEXT _ PLAIN ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["mockTextPlainHttpMessageConverter"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockResponseBody ( expectedBody ,    MediaType . TEXT _ PLAIN )  ;", "}", "METHOD_END"], "methodName": ["mockTextResponseBody"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . OPTIONS ,     \" http :  /  / example . com \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "EnumSet < HttpMethod >    expected    =    EnumSet . of ( HttpMethod . GET ,    HttpMethod . POST )  ;", "responseHeaders . setAllow ( expected )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "Set < HttpMethod >    result    =    t . optionsForAllow (  \" http :  /  / example . com \"  )  ;", "assertEquals (  \" Invalid   OPTIONS   result \"  ,    expected ,    result )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["optionsForAllow"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockTextPlainHttpMessageConverter (  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . PATCH ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "String   expected    =     \"  4  2  \"  ;", "mockResponseBody (  \"  4  2  \"  ,    MediaType . TEXT _ PLAIN )  ;", "String   result    =    t . patchForObject (  \" http :  /  / example . com \"  ,     \" Hello   World \"  ,    String . class )  ;", "assertEquals (  \" Invalid   POST   result \"  ,    expected ,    result )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    MediaType . TEXT _ PLAIN _ VALUE ,    requestHeaders . getFirst (  \" Accept \"  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["patchForObject"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockTextPlainHttpMessageConverter (  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . PATCH ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "responseHeaders . setContentLength (  1  0  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( StreamUtils . emptyInput (  )  )  ;", "String   result    =    t . patchForObject (  \" http :  /  / example . com \"  ,    null ,    String . class )  ;", "assertNull (  \" Invalid   POST   result \"  ,    result )  ;", "assertEquals (  \" Invalid   content   length \"  ,     0  ,    requestHeaders . getContentLength (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["patchForObjectNull"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockTextPlainHttpMessageConverter (  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "String   expected    =     \"  4  2  \"  ;", "mockResponseBody ( expected ,    MediaType . TEXT _ PLAIN )  ;", "ResponseEntity < String >    result    =    t . postForEntity (  \" http :  /  / example . com \"  ,     \" Hello   World \"  ,    String . class )  ;", "assertEquals (  \" Invalid   POST   result \"  ,    expected ,    result . getBody (  )  )  ;", "assertEquals (  \" Invalid   Content - Type \"  ,    MediaType . TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    MediaType . TEXT _ PLAIN _ VALUE ,    requestHeaders . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    result . getStatusCode (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForEntity"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockTextPlainHttpMessageConverter (  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "responseHeaders . setContentLength (  1  0  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( StreamUtils . emptyInput (  )  )  ;", "given ( converter . read ( String . class ,    response )  )  . willReturn ( null )  ;", "ResponseEntity < String >    result    =    t . postForEntity (  \" http :  /  / example . com \"  ,    null ,    String . class )  ;", "assertFalse (  \" Invalid   POST   result \"  ,    result . hasBody (  )  )  ;", "assertEquals (  \" Invalid   Content - Type \"  ,    MediaType . TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  \" Invalid   content   length \"  ,     0  ,    requestHeaders . getContentLength (  )  )  ;", "assertEquals (  \" Invalid   status   code \"  ,    HttpStatus . OK ,    result . getStatusCode (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForEntityNull"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  )  ;", "mockTextPlainHttpMessageConverter (  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "String   helloWorld    =     \" Hello   World \"  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "URI   expected    =    new   URI (  \" http :  /  / example . com / hotels \"  )  ;", "responseHeaders . setLocation ( expected )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "URI   result    =    t . postForLocation (  \" http :  /  / example . com \"  ,    helloWorld )  ;", "assertEquals (  \" Invalid   POST   result \"  ,    expected ,    result )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForLocation"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  )  ;", "mockTextPlainHttpMessageConverter (  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "String   helloWorld    =     \" Hello   World \"  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "URI   expected    =    new   URI (  \" http :  /  / example . com / hotels \"  )  ;", "responseHeaders . setLocation ( expected )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "HttpEntity < String >    entity    =    new   HttpEntity ( helloWorld ,    entityHeaders )  ;", "URI   result    =    t . postForLocation (  \" http :  /  / example . com \"  ,    entity )  ;", "assertEquals (  \" Invalid   POST   result \"  ,    expected ,    result )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForLocationEntityContentType"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockTextPlainHttpMessageConverter (  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "URI   expected    =    new   URI (  \" http :  /  / example . com / hotels \"  )  ;", "responseHeaders . setLocation ( expected )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . set (  \" MyHeader \"  ,     \" MyValue \"  )  ;", "HttpEntity < String >    entity    =    new   HttpEntity (  \" Hello   World \"  ,    entityHeaders )  ;", "URI   result    =    t . postForLocation (  \" http :  /  / example . com \"  ,    entity )  ;", "assertEquals (  \" Invalid   POST   result \"  ,    expected ,    result )  ;", "assertEquals (  \" No   custom   header   set \"  ,     \" MyValue \"  ,    requestHeaders . getFirst (  \" MyHeader \"  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForLocationEntityCustomHeader"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  )  ;", "mockTextPlainHttpMessageConverter (  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "URI   result    =    t . postForLocation (  \" http :  /  / example . com \"  ,     \" Hello   World \"  )  ;", "assertNull (  \" Invalid   POST   result \"  ,    result )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForLocationNoLocation"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "t . postForLocation (  \" http :  /  / example . com \"  ,    null )  ;", "assertEquals (  \" Invalid   content   length \"  ,     0  ,    requestHeaders . getContentLength (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForLocationNull"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockTextPlainHttpMessageConverter (  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "String   expected    =     \"  4  2  \"  ;", "mockResponseBody ( expected ,    MediaType . TEXT _ PLAIN )  ;", "String   result    =    t . postForObject (  \" http :  /  / example . com \"  ,     \" Hello   World \"  ,    String . class )  ;", "assertEquals (  \" Invalid   POST   result \"  ,    expected ,    result )  ;", "assertEquals (  \" Invalid   Accept   header \"  ,    MediaType . TEXT _ PLAIN _ VALUE ,    requestHeaders . getFirst (  \" Accept \"  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForObject"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockTextPlainHttpMessageConverter (  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "responseHeaders . setContentType ( MediaType . TEXT _ PLAIN )  ;", "responseHeaders . setContentLength (  1  0  )  ;", "given ( response . getHeaders (  )  )  . willReturn ( responseHeaders )  ;", "given ( response . getBody (  )  )  . willReturn ( StreamUtils . emptyInput (  )  )  ;", "given ( converter . read ( String . class ,    response )  )  . willReturn ( null )  ;", "String   result    =    t . postForObject (  \" http :  /  / example . com \"  ,    null ,    String . class )  ;", "assertNull (  \" Invalid   POST   result \"  ,    result )  ;", "assertEquals (  \" Invalid   content   length \"  ,     0  ,    requestHeaders . getContentLength (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["postForObjectNull"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockTextPlainHttpMessageConverter (  )  ;", "mockSentRequest ( HttpMethod . PUT ,     \" http :  /  / example . com \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "t . put (  \" http :  /  / example . com \"  ,     \" Hello   World \"  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . PUT ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "t . put (  \" http :  /  / example . com \"  ,    null )  ;", "assertEquals (  \" Invalid   content   length \"  ,     0  ,    requestHeaders . getContentLength (  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["putNull"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "HttpMessageConverter   firstConverter    =    mock ( HttpMessageConverter . class )  ;", "given ( firstConverter . canRead ( any (  )  ,    any (  )  )  )  . willReturn ( true )  ;", "given ( firstConverter . getSupportedMediaTypes (  )  )  . willReturn ( Collections . singletonList ( MediaType . TEXT _ PLAIN )  )  ;", "HttpMessageConverter   secondConverter    =    mock ( HttpMessageConverter . class )  ;", "given ( secondConverter . canRead ( any (  )  ,    any (  )  )  )  . willReturn ( true )  ;", "given ( secondConverter . getSupportedMediaTypes (  )  )  . willReturn ( Collections . singletonList ( MediaType . TEXT _ PLAIN )  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com /  \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "mockTextResponseBody (  \" Hello   World \"  )  ;", "t . setMessageConverters ( Arrays . asList ( firstConverter ,    secondConverter )  )  ;", "t . getForObject (  \" http :  /  / example . com /  \"  ,    String . class )  ;", "assertEquals (  \" Sent   duplicate   Accept   header   values \"  ,     1  ,    requestHeaders . getAccept (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestAvoidsDuplicateAcceptHeaderValues"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ClientHttpRequestInterceptor   interceptor    =     (    request ,    body ,    execution )     -  >     {", "request . getHeaders (  )  . add (  \" MyHeader \"  ,     \" MyInterceptorValue \"  )  ;", "return   execution . execute ( request ,    body )  ;", "}  ;", "t . setInterceptors ( Collections . singletonList ( interceptor )  )  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "given ( converter . canWrite ( String . class ,    contentType )  )  . willReturn ( true )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . setContentType ( contentType )  ;", "entityHeaders . add (  \" MyHeader \"  ,     \" MyEntityValue \"  )  ;", "HttpEntity < String >    entity    =    new   HttpEntity (  \" Hello   World \"  ,    entityHeaders )  ;", "t . exchange (  \" http :  /  / example . com \"  ,    HttpMethod . POST ,    entity ,    Void . class )  ;", "assertThat ( requestHeaders . get (  \" MyHeader \"  )  ,    contains (  \" MyEntityValue \"  ,     \" MyInterceptorValue \"  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["requestInterceptorCanAddExistingHeaderValueWithBody"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ClientHttpRequestInterceptor   interceptor    =     (    request ,    body ,    execution )     -  >     {", "request . getHeaders (  )  . add (  \" MyHeader \"  ,     \" MyInterceptorValue \"  )  ;", "return   execution . execute ( request ,    body )  ;", "}  ;", "t . setInterceptors ( Collections . singletonList ( interceptor )  )  ;", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "mockSentRequest ( HttpMethod . POST ,     \" http :  /  / example . com \"  ,    requestHeaders )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "HttpHeaders   entityHeaders    =    new   HttpHeaders (  )  ;", "entityHeaders . add (  \" MyHeader \"  ,     \" MyEntityValue \"  )  ;", "HttpEntity < Void >    entity    =    new   HttpEntity ( null ,    entityHeaders )  ;", "t . exchange (  \" http :  /  / example . com \"  ,    HttpMethod . POST ,    entity ,    Void . class )  ;", "assertThat ( requestHeaders . get (  \" MyHeader \"  )  ,    contains (  \" MyEntityValue \"  ,     \" MyInterceptorValue \"  )  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["requestInterceptorCanAddExistingHeaderValueWithoutBody"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "requestFactory    =    mock ( ClientHttpRequestFactory . class )  ;", "request    =    mock ( ClientHttpRequest . class )  ;", "response    =    mock ( ClientHttpResponse . class )  ;", "errorHandler    =    mock ( ResponseErrorHandler . class )  ;", "converter    =    mock ( HttpMessageConverter . class )  ;", "template    =    new    ( Collections . singletonList ( converter )  )  ;", "template . setRequestFactory ( requestFactory )  ;", "template . setErrorHandler ( errorHandler )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / example . com / spring /  \"  ;", "mockSentRequest ( HttpMethod . GET ,    url )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "t . execute ( url ,    HttpMethod . GET ,    null ,    null )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["uriTemplateWithTrailingSlash"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com /  - foo \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "t . execute (  \" http :  /  / example . com /  { first }  -  { last }  \"  ,    HttpMethod . GET ,    null ,    null ,    null ,     \" foo \"  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["varArgsNullTemplateVariable"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "mockSentRequest ( HttpMethod . GET ,     \" http :  /  / example . com / hotels /  4  2  / bookings /  2  1  \"  )  ;", "mockResponseStatus ( HttpStatus . OK )  ;", "t . execute (  \" http :  /  / example . com / hotels /  { hotel }  / bookings /  { booking }  \"  ,    HttpMethod . GET ,    null ,    null ,     \"  4  2  \"  ,     \"  2  1  \"  )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["varArgsTemplateVariables"], "fileName": "org.springframework.web.client.RestTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   this . restTemplate ;", "}", "METHOD_END"], "methodName": ["getRestTemplate"], "fileName": "org.springframework.web.client.support.RestGatewaySupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( restTemplate ,     \"  ' restTemplate '    must   not   be   null \"  )  ;", "this . restTemplate    =    restTemplate ;", "}", "METHOD_END"], "methodName": ["setRestTemplate"], "fileName": "org.springframework.web.client.support.RestGatewaySupport"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getRootApplicationContextInitializers"], "fileName": "org.springframework.web.context.AbstractContextLoaderInitializer"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   rootAppContext    =    createRootApplicationContext (  )  ;", "if    ( rootAppContext    !  =    null )     {", "Listener   listener    =    new   Listener ( rootAppContext )  ;", "listener . setContextInitializers ( getRootApplicationContextInitializers (  )  )  ;", "servletContext . addListener ( listener )  ;", "} else    {", "logger . debug (  (  \" No   Listener   registered ,    as    \"     +     \" createRootApplicationContext (  )    did   not   return   an   application   context \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerContextLoaderListener"], "fileName": "org.springframework.web.context.AbstractContextLoaderInitializer"}, {"methodBody": ["METHOD_START", "{", "Enumeration < String >    attrNames    =    sc . getAttributeNames (  )  ;", "while    ( attrNames . hasMoreElements (  )  )     {", "String   attrName    =    attrNames . nextElement (  )  ;", "if    ( attrName . startsWith (  \" \"  )  )     {", "Object   attrValue    =    sc . getAttribute ( attrName )  ;", "if    ( attrValue   instanceof   DisposableBean )     {", "try    {", "(  ( DisposableBean )     ( attrValue )  )  . destroy (  )  ;", "}    catch    ( Throwable   ex )     {", ". logger . error (  (  (  \" Couldn ' t   invoke   destroy   method   of   attribute   with   name    '  \"     +    attrName )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["cleanupAttributes"], "fileName": "org.springframework.web.context.ContextCleanupListener"}, {"methodBody": ["METHOD_START", "{", "servletContext . log (  \" Closing   Spring   root   WebApplicationContext \"  )  ;", "try    {", "if    (  ( this . context )    instanceof   ConfigurableWebApplicationContext )     {", "(  ( ConfigurableWebApplicationContext )     ( this . context )  )  . close (  )  ;", "}", "}    finally    {", "ClassLoader   ccl    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "if    ( ccl    =  =     (  . class . getClassLoader (  )  )  )     {", ". currentContext    =    null ;", "} else", "if    ( ccl    !  =    null )     {", ". currentContextPerThread . remove ( ccl )  ;", "}", "servletContext . removeAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  ;", "}", "}", "METHOD_END"], "methodName": ["closeWebApplicationContext"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . identityToString ( wac )  . equals ( wac . getId (  )  )  )     {", "String   idParam    =    sc . getInitParameter (  . CONTEXT _ ID _ PARAM )  ;", "if    ( idParam    !  =    null )     {", "wac . setId ( idParam )  ;", "} else    {", "wac . setId (  (  ( ConfigurableWebApplicationContext . APPLICATION _ CONTEXT _ ID _ PREFIX )     +     ( ObjectUtils . getDisplayString ( sc . getContextPath (  )  )  )  )  )  ;", "}", "}", "wac . setServletContext ( sc )  ;", "String   configLocationParam    =    sc . getInitParameter (  . CONFIG _ LOCATION _ PARAM )  ;", "if    ( configLocationParam    !  =    null )     {", "wac . setConfigLocation ( configLocationParam )  ;", "}", "ConfigurableEnvironment   env    =    wac . getEnvironment (  )  ;", "if    ( env   instanceof   ConfigurableWebEnvironment )     {", "(  ( ConfigurableWebEnvironment )     ( env )  )  . initPropertySources ( sc ,    null )  ;", "}", "customizeContext ( sc ,    wac )  ;", "wac . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["configureAndRefreshWebApplicationContext"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    contextClass    =    determineContextClass ( sc )  ;", "if    (  !  ( ConfigurableWebApplicationContext . class . isAssignableFrom ( contextClass )  )  )     {", "throw   new   ApplicationContextException (  (  (  (  (  \" Custom   context   class    [  \"     +     ( contextClass . getName (  )  )  )     +     \"  ]    is   not   of   type    [  \"  )     +     ( ConfigurableWebApplicationContext . class . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return    (  ( ConfigurableWebApplicationContext )     ( BeanUtils . instantiateClass ( contextClass )  )  )  ;", "}", "METHOD_END"], "methodName": ["createWebApplicationContext"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "List < Class < ApplicationContextInitializer < ConfigurableApplicationContext >  >  >    initializerClasses    =    determineContextInitializerClasses ( sc )  ;", "for    ( Class < ApplicationContextInitializer < ConfigurableApplicationContext >  >    initializerClass    :    initializerClasses )     {", "Class <  ?  >    initializerContextClass    =    GenericTypeResolver . resolveTypeArgument ( initializerClass ,    ApplicationContextInitializer . class )  ;", "if    (  ( initializerContextClass    !  =    null )     &  &     (  !  ( initializerContextClass . isInstance ( wac )  )  )  )     {", "throw   new   context . ApplicationContextException ( String . format (  (  \" Could   not   apply   context   initializer    [  % s ]    since   its   generic   parameter    [  % s ]     \"     +     (  \" is   not   assignable   from   the   type   of   application   context   used   by   this    \"     +     \" context   loader :     [  % s ]  \"  )  )  ,    initializerClass . getName (  )  ,    initializerContextClass . getName (  )  ,    wac . getClass (  )  . getName (  )  )  )  ;", "}", "this . contextInitializers . add ( BeanUtils . instantiateClass ( initializerClass )  )  ;", "}", "AnnotationAwareOrderComparator . sort ( this . contextInitializers )  ;", "for    ( ApplicationContextInitializer < ConfigurableApplicationContext >    initializer    :    this . contextInitializers )     {", "initializer . initialize ( wac )  ;", "}", "}", "METHOD_END"], "methodName": ["customizeContext"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "String   contextClassName    =    servletContext . getInitParameter ( ContextLoader . CONTEXT _ CLASS _ PARAM )  ;", "if    ( contextClassName    !  =    null )     {", "try    {", "return   ClassUtils . forName ( contextClassName ,    ClassUtils . getDefaultClassLoader (  )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   ApplicationContextException (  (  (  \" Failed   to   load   custom   context   class    [  \"     +    contextClassName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "} else    {", "contextClassName    =    ContextLoader . defaultStrategies . getProperty ( WebApplicationContext . class . getName (  )  )  ;", "try    {", "return   ClassUtils . forName ( contextClassName ,    ContextLoader . class . getClassLoader (  )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   ApplicationContextException (  (  (  \" Failed   to   load   default   context   class    [  \"     +    contextClassName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["determineContextClass"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "List < Class < ApplicationContextInitializer < ConfigurableApplicationContext >  >  >    classes    =    new   ArrayList <  >  (  )  ;", "String   globalClassNames    =    servletContext . getInitParameter (  . GLOBAL _ INITIALIZER _ CLASSES _ PARAM )  ;", "if    ( globalClassNames    !  =    null )     {", "for    ( String   className    :    StringUtils . tokenizeToStringArray ( globalClassNames ,     . INIT _ PARAM _ DELIMITERS )  )     {", "classes . add ( loadInitializerClass ( className )  )  ;", "}", "}", "String   localClassNames    =    servletContext . getInitParameter (  . CONTEXT _ INITIALIZER _ CLASSES _ PARAM )  ;", "if    ( localClassNames    !  =    null )     {", "for    ( String   className    :    StringUtils . tokenizeToStringArray ( localClassNames ,     . INIT _ PARAM _ DELIMITERS )  )     {", "classes . add ( loadInitializerClass ( className )  )  ;", "}", "}", "return   classes ;", "}", "METHOD_END"], "methodName": ["determineContextInitializerClasses"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   ccl    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "if    ( ccl    !  =    null )     {", "WebApplicationContext   ccpt    =     . currentContextPerThread . get ( ccl )  ;", "if    ( ccpt    !  =    null )     {", "return   ccpt ;", "}", "}", "return    . currentContext ;", "}", "METHOD_END"], "methodName": ["getCurrentWebApplicationContext"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( servletContext . getAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )     !  =    null )     {", "throw   new   IllegalStateException (  (  \" Cannot   initialize   context   because   there   is   already   a   root   application   context   present    -     \"     +     \" check   whether   you   have   multiple    *    definitions   in   your   web . xml !  \"  )  )  ;", "}", "Log   logger    =    LogFactory . getLog (  . class )  ;", "servletContext . log (  \" Initializing   Spring   root   WebApplicationContext \"  )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  \" Root   WebApplicationContext :    initialization   started \"  )  ;", "}", "long   startTime    =    System . currentTimeMillis (  )  ;", "try    {", "if    (  ( this . context )     =  =    null )     {", "this . context    =    createWebApplicationContext ( servletContext )  ;", "}", "if    (  ( this . context )    instanceof   ConfigurableWebApplicationContext )     {", "ConfigurableWebApplicationContext   cwac    =     (  ( ConfigurableWebApplicationContext )     ( this . context )  )  ;", "if    (  !  ( cwac . isActive (  )  )  )     {", "if    (  ( cwac . getParent (  )  )     =  =    null )     {", "ApplicationContext   parent    =    loadParentContext ( servletContext )  ;", "cwac . setParent ( parent )  ;", "}", "configureAndRefreshWebApplicationContext ( cwac ,    servletContext )  ;", "}", "}", "servletContext . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    this . context )  ;", "ClassLoader   ccl    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "if    ( ccl    =  =     (  . class . getClassLoader (  )  )  )     {", ". currentContext    =    this . context ;", "} else", "if    ( ccl    !  =    null )     {", ". currentContextPerThread . put ( ccl ,    this . context )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Published   root   WebApplicationContext   as   ServletContext   attribute   with   name    [  \"     +     ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  )     +     \"  ]  \"  )  )  ;", "}", "if    ( logger . isInfoEnabled (  )  )     {", "long   elapsedTime    =     ( System . currentTimeMillis (  )  )     -    startTime ;", "logger . info (  (  (  \" Root   WebApplicationContext :    initialization   completed   in    \"     +    elapsedTime )     +     \"    ms \"  )  )  ;", "}", "return   this . context ;", "}    catch    ( RuntimeException   ex )     {", "logger . error (  \" Context   initialization   failed \"  ,    ex )  ;", "servletContext . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    ex )  ;", "throw   ex ;", "}    catch    ( Error   err )     {", "logger . error (  \" Context   initialization   failed \"  ,    err )  ;", "servletContext . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    err )  ;", "throw   err ;", "}", "}", "METHOD_END"], "methodName": ["initWebApplicationContext"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >    clazz    =    ClassUtils . forName ( className ,    ClassUtils . getDefaultClassLoader (  )  )  ;", "if    (  !  ( ApplicationInitializer . class . isAssignableFrom ( clazz )  )  )     {", "throw   new   ApplicationException (  (  \" Initializer   class   does   not   implement   ApplicationInitializer   interface :     \"     +    clazz )  )  ;", "}", "return    (  ( Class < ApplicationInitializer < ConfigurableApplication >  >  )     ( clazz )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   ApplicationException (  (  (  \" Failed   to   load   context   initializer   class    [  \"     +    className )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["loadInitializerClass"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["loadParentContext"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( initializers    !  =    null )     {", "for    ( ApplicationContextInitializer <  ?  >    initializer    :    initializers )     {", "thisInitializers . add (  (  ( ApplicationContextInitializer < ConfigurableApplicationContext >  )     ( initializer )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setContextInitializers"], "fileName": "org.springframework.web.context.ContextLoader"}, {"methodBody": ["METHOD_START", "{", "initializer . onStartup ( servletContext )  ;", "assertTrue (  (  ( eventListener )    instanceof   ContextLoaderListener )  )  ;", "ContextLoaderListener   cll    =     (  ( ContextLoaderListener )     ( eventListener )  )  ;", "cll . contextInitialized ( new   ServletContextEvent ( servletContext )  )  ;", "WebApplicationContext   applicationContext    =    WebApplicationContextUtils . getRequiredWebApplicationContext ( servletContext )  ;", "assertTrue ( applicationContext . containsBean (  . BEAN _ NAME )  )  ;", "assertTrue (  (  ( applicationContext . getBean (  . BEAN _ NAME )  )    instanceof    . MyBean )  )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.springframework.web.context.ContextLoaderInitializerTests"}, {"methodBody": ["METHOD_START", "{", "servletContext    =    new   ContextLoaderInitializerTests . MyMockServletContext (  )  ;", "initializer    =    new   ContextLoaderInitializerTests . MyContextLoaderInitializer (  )  ;", "eventListener    =    null ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.context.ContextLoaderInitializerTests"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . requestDestructionCallbacks )     {", "for    ( Runnable   runnable    :    this . requestDestructionCallbacks . values (  )  )     {", "runnable . run (  )  ;", "}", "this . requestDestructionCallbacks . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["executeRequestDestructionCallbacks"], "fileName": "org.springframework.web.context.request.AbstractRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . requestActive ;", "}", "METHOD_END"], "methodName": ["isRequestActive"], "fileName": "org.springframework.web.context.request.AbstractRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Name   must   not   be   null \"  )  ;", "Assert . notNull ( callback ,     \" Callback   must   not   be   null \"  )  ;", "synchronized ( thisDestructionCallbacks )     {", "thisDestructionCallbacks . put ( name ,    callback )  ;", "}", "}", "METHOD_END"], "methodName": ["registerRequestDestructionCallback"], "fileName": "org.springframework.web.context.request.AbstractRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Name   must   not   be   null \"  )  ;", "synchronized ( thisDestructionCallbacks )     {", "thisDestructionCallbacks . remove ( name )  ;", "}", "}", "METHOD_END"], "methodName": ["removeRequestDestructionCallback"], "fileName": "org.springframework.web.context.request.AbstractRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "executeRequestDestructionCallbacks (  )  ;", "updateAccessedSession (  )  ;", "this . requestActive    =    false ;", "}", "METHOD_END"], "methodName": ["requestCompleted"], "fileName": "org.springframework.web.context.request.AbstractRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "if    ( scope    =  =     ( RequestAttributes . SCOPE _ REQUEST )  )     {", "return   getExternalContext (  )  . getRequestMap (  )  ;", "} else    {", "return   getExternalContext (  )  . getSessionMap (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAttributeMap"], "fileName": "org.springframework.web.context.request.FacesRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getFacesContext (  )  . getExternalContext (  )  ;", "}", "METHOD_END"], "methodName": ["getExternalContext"], "fileName": "org.springframework.web.context.request.FacesRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . facesContext ;", "}", "METHOD_END"], "methodName": ["getFacesContext"], "fileName": "org.springframework.web.context.request.FacesRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "String   targetBeanName    =     \" target \"  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setScope ( WebApplicationContext . SCOPE _ REQUEST )  ;", "bd . getPropertyValues (  )  . add (  \" name \"  ,     \" abc \"  )  ;", "wac . registerBeanDefinition ( targetBeanName ,    bd )  ;", "wac . refresh (  )  ;", "HttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "RequestContextHolder . setttributes ( new   Servletttributes ( request )  )  ;", "TestBean   target    =     (  ( TestBean )     ( wac . getBean ( targetBeanName )  )  )  ;", "assertEquals (  \" abc \"  ,    target . getName (  )  )  ;", "assertSame ( target ,    request . getAttribute ( targetBeanName )  )  ;", "TestBean   target 2     =     (  ( TestBean )     ( wac . getBean ( targetBeanName )  )  )  ;", "assertEquals (  \" abc \"  ,    target 2  . getName (  )  )  ;", "assertSame ( target 2  ,    target )  ;", "assertSame ( target 2  ,    request . getAttribute ( targetBeanName )  )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "RequestContextHolder . setttributes ( new   Servletttributes ( request )  )  ;", "TestBean   target 3     =     (  ( TestBean )     ( wac . getBean ( targetBeanName )  )  )  ;", "assertEquals (  \" abc \"  ,    target 3  . getName (  )  )  ;", "assertSame ( target 3  ,    request . getAttribute ( targetBeanName )  )  ;", "assertNotSame ( target 3  ,    target )  ;", "RequestContextHolder . setttributes ( null )  ;", "try    {", "wac . getBean ( targetBeanName )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testPutBeanInRequest"], "fileName": "org.springframework.web.context.request.RequestAndSessionScopedBeanTests"}, {"methodBody": ["METHOD_START", "{", "String   targetBeanName    =     \" target \"  ;", "HttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "RequestContextHolder . setttributes ( new   Servletttributes ( request )  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setScope ( WebApplicationContext . SCOPE _ SESSION )  ;", "bd . getPropertyValues (  )  . add (  \" name \"  ,     \" abc \"  )  ;", "wac . registerBeanDefinition ( targetBeanName ,    bd )  ;", "wac . refresh (  )  ;", "TestBean   target    =     (  ( TestBean )     ( wac . getBean ( targetBeanName )  )  )  ;", "assertEquals (  \" abc \"  ,    target . getName (  )  )  ;", "assertSame ( target ,    request . getSession (  )  . getAttribute ( targetBeanName )  )  ;", "RequestContextHolder . setttributes ( null )  ;", "try    {", "wac . getBean ( targetBeanName )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testPutBeanInSession"], "fileName": "org.springframework.web.context.request.RequestAndSessionScopedBeanTests"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   attributes    =    RequestContextHolder . getRequestAttributes (  )  ;", "if    ( attributes    =  =    null )     {", "if    ( RequestContextHolder . jsfPresent )     {", "attributes    =    RequestContextHolder . FacesRequestAttributesFactory . getFacesRequestAttributes (  )  ;", "}", "if    ( attributes    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   thread - bound   request   found :     \"     +     (  (  (  (  \" Are   you   referring   to   request   attributes   outside   of   an   actual   web   request ,     \"     +     \" or   processing   a   request   outside   of   the   originally   receiving   thread ?     \"  )     +     \" If   you   are   actually   operating   within   a   web   request   and   still   receive   this   message ,     \"  )     +     \" your   code   is   probably   running   outside   of   DispatcherServlet / DispatcherPortlet :     \"  )     +     \" In   this   case ,    use   RequestContextListener   or   RequestContextFilter   to   expose   the   current   request .  \"  )  )  )  ;", "}", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["currentRequestAttributes"], "fileName": "org.springframework.web.context.request.RequestContextHolder"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   attributes    =    RequestContextHolder . requestAttributesHolder . get (  )  ;", "if    ( attributes    =  =    null )     {", "attributes    =    RequestContextHolder . inheritableRequestAttributesHolder . get (  )  ;", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["getRequestAttributes"], "fileName": "org.springframework.web.context.request.RequestContextHolder"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolder . requestAttributesHolder . remove (  )  ;", "RequestContextHolder . inheritableRequestAttributesHolder . remove (  )  ;", "}", "METHOD_END"], "methodName": ["resetRequestAttributes"], "fileName": "org.springframework.web.context.request.RequestContextHolder"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolder . setRequestAttributes ( attributes ,    false )  ;", "}", "METHOD_END"], "methodName": ["setRequestAttributes"], "fileName": "org.springframework.web.context.request.RequestContextHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    =  =    null )     {", ". resetRequestAttributes (  )  ;", "} else    {", "if    ( inheritable )     {", ". inheritableRequestAttributesHolder . set ( attributes )  ;", ". requestAttributesHolder . remove (  )  ;", "} else    {", ". requestAttributesHolder . set ( attributes )  ;", ". inheritableRequestAttributesHolder . remove (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRequestAttributes"], "fileName": "org.springframework.web.context.request.RequestContextHolder"}, {"methodBody": ["METHOD_START", "{", "final   RequestContextListener   listener    =    new   RequestContextListener (  )  ;", "final   MockServletContext   context    =    new   MockServletContext (  )  ;", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest ( context )  ;", "request . setAttribute (  \" test \"  ,     \" value \"  )  ;", "assertNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "listener . requestInitialized ( new   ServletRequestEvent ( context ,    request )  )  ;", "assertNotNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "assertEquals (  \" value \"  ,    RequestContextHolder . getRequestAttributes (  )  . getAttribute (  \" test \"  ,    RequestAttributes . SCOPE _ REQUEST )  )  ;", "MockRunnable   runnable    =    new   MockRunnable (  )  ;", "RequestContextHolder . getRequestAttributes (  )  . registerDestructionCallback (  \" test \"  ,    runnable ,    RequestAttributes . SCOPE _ REQUEST )  ;", "Thread   thread    =    new   Thread (  )     {", "@ Override", "public   void   run (  )     {", "listener . requestDestroyed ( new   ServletRequestEvent ( context ,    request )  )  ;", "}", "}  ;", "thread . start (  )  ;", "try    {", "thread . join (  )  ;", "}    catch    ( InterruptedException   ex )     {", "}", "assertNotNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "assertTrue ( runnable . wasExecuted (  )  )  ;", "listener . requestInitialized ( new   ServletRequestEvent ( context ,    request )  )  ;", "listener . requestDestroyed ( new   ServletRequestEvent ( context ,    request )  )  ;", "assertNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestContextListenerWithDifferentThread"], "fileName": "org.springframework.web.context.request.RequestContextListenerTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextListener   listener    =    new   RequestContextListener (  )  ;", "MockServletContext   context    =    new   MockServletContext (  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( context )  ;", "request . setAttribute (  \" test \"  ,     \" value \"  )  ;", "assertNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "listener . requestInitialized ( new   ServletRequestEvent ( context ,    request )  )  ;", "assertNotNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "assertEquals (  \" value \"  ,    RequestContextHolder . getRequestAttributes (  )  . getAttribute (  \" test \"  ,    RequestAttributes . SCOPE _ REQUEST )  )  ;", "MockRunnable   runnable    =    new   MockRunnable (  )  ;", "RequestContextHolder . getRequestAttributes (  )  . registerDestructionCallback (  \" test \"  ,    runnable ,    RequestAttributes . SCOPE _ REQUEST )  ;", "listener . requestDestroyed ( new   ServletRequestEvent ( context ,    request )  )  ;", "assertNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "assertTrue ( runnable . wasExecuted (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestContextListenerWithSameThread"], "fileName": "org.springframework.web.context.request.RequestContextListenerTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextListener   listener    =    new   RequestContextListener (  )  ;", "MockServletContext   context    =    new   MockServletContext (  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( context )  ;", "request . setAttribute (  \" test \"  ,     \" value \"  )  ;", "assertNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "listener . requestInitialized ( new   ServletRequestEvent ( context ,    request )  )  ;", "assertNotNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "assertEquals (  \" value \"  ,    RequestContextHolder . getRequestAttributes (  )  . getAttribute (  \" test \"  ,    RequestAttributes . SCOPE _ REQUEST )  )  ;", "MockRunnable   runnable    =    new   MockRunnable (  )  ;", "RequestContextHolder . getRequestAttributes (  )  . registerDestructionCallback (  \" test \"  ,    runnable ,    RequestAttributes . SCOPE _ REQUEST )  ;", "request . clearAttributes (  )  ;", "listener . requestDestroyed ( new   ServletRequestEvent ( context ,    request )  )  ;", "assertNull ( RequestContextHolder . getRequestAttributes (  )  )  ;", "assertTrue ( runnable . wasExecuted (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestContextListenerWithSameThreadAndAttributesGone"], "fileName": "org.springframework.web.context.request.RequestContextListenerTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "RequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "try    {", "String   name    =     \" rdObjectCircle 1  \"  ;", "assertNull ( request . getAttribute ( name )  )  ;", "this . beanFactory . getBean ( name )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . contains ( BeanCurrentlyInCreationException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["circleLeadsToException"], "fileName": "org.springframework.web.context.request.RequestScopeTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "String   name    =     \" rdDisposableObject \"  ;", "assertNull ( request . getAttribute ( name )  )  ;", "DerivedTestBean   bean    =     (  ( DerivedTestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertSame ( bean ,    request . getAttribute ( name )  )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "requestAttributes . requestCompleted (  )  ;", "assertTrue ( bean . wasDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["destructionAtRequestCompletion"], "fileName": "org.springframework.web.context.request.RequestScopeTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "RequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "String   name    =     \" rdFactoryBean \"  ;", "assertNull ( request . getAttribute ( name )  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertTrue (  (  ( request . getAttribute ( name )  )    instanceof   FactoryBean )  )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getFromFactoryBeanInScope"], "fileName": "org.springframework.web.context.request.RequestScopeTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setContextPath (  \"  / path \"  )  ;", "RequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "String   name    =     \" rdObject \"  ;", "assertNull ( request . getAttribute ( name )  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertEquals (  \"  / path \"  ,    bean . getName (  )  )  ;", "assertSame ( bean ,    request . getAttribute ( name )  )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getFromScope"], "fileName": "org.springframework.web.context.request.RequestScopeTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "String   outerBeanName    =     \" rdOuterBean \"  ;", "assertNull ( request . getAttribute ( outerBeanName )  )  ;", "TestBean   outer 1     =     (  ( TestBean )     ( this . beanFactory . getBean ( outerBeanName )  )  )  ;", "assertNotNull ( request . getAttribute ( outerBeanName )  )  ;", "TestBean   inner 1     =     (  ( TestBean )     ( outer 1  . getSpouse (  )  )  )  ;", "assertSame ( outer 1  ,    this . beanFactory . getBean ( outerBeanName )  )  ;", "requestAttributes . requestCompleted (  )  ;", "assertTrue ( outer 1  . wasDestroyed (  )  )  ;", "assertTrue ( inner 1  . wasDestroyed (  )  )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "TestBean   outer 2     =     (  ( TestBean )     ( this . beanFactory . getBean ( outerBeanName )  )  )  ;", "assertNotSame ( outer 1  ,    outer 2  )  ;", "assertNotSame ( inner 1  ,    outer 2  . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["innerBeanInheritsContainingBeanScopeByDefault"], "fileName": "org.springframework.web.context.request.RequestScopeTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest    =    new   MockHttpServletRequest (  )  ;", "ServletRequestAttributes   ttributes    =    new   ServletRequestAttributes (  ;", "RequestContextHolder . setRequestAttributes ( ttributes )  ;", "String   outerBeanName    =     \" singletonOuterBean \"  ;", "TestBean   outer 1     =     (  ( TestBean )     ( this . beanFactory . getBean ( outerBeanName )  )  )  ;", "assertNull ( getAttribute ( outerBeanName )  )  ;", "TestBean   inner 1     =     (  ( TestBean )     ( outer 1  . getSpouse (  )  )  )  ;", "TestBean   outer 2     =     (  ( TestBean )     ( this . beanFactory . getBean ( outerBeanName )  )  )  ;", "assertSame ( outer 1  ,    outer 2  )  ;", "assertSame ( inner 1  ,    outer 2  . getSpouse (  )  )  ;", "ttributes . ompleted (  )  ;", "assertTrue ( inner 1  . wasDestroyed (  )  )  ;", "assertFalse ( outer 1  . wasDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestScopedInnerBeanDestroyedWhileContainedBySingleton"], "fileName": "org.springframework.web.context.request.RequestScopeTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "METHOD_END"], "methodName": ["resetRequestAttributes"], "fileName": "org.springframework.web.context.request.RequestScopeTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . registerScope (  \" request \"  ,    new   RequestScope (  )  )  ;", "this . beanFactory . setBeanExpressionResolver ( new   StandardBeanExpressionResolver (  )  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" r . xml \"  ,    getClass (  )  )  )  ;", "this . beanFactory . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.RequestScopeTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . registerScope (  \" request \"  ,    new   RequestScope (  )  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" r . xml \"  ,    getClass (  )  )  )  ;", "this . beanFactory . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.RequestScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" requestScopedDisposableObject \"  ;", "DerivedTestBean   bean    =     (  ( DerivedTestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "try    {", "assertNull ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals (  \" scoped \"  ,    bean . getName (  )  )  ;", "assertNotNull ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals ( DerivedTestBean . class ,    request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  . getClass (  )  )  ;", "assertEquals (  \" scoped \"  ,     (  ( TestBean )     ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  )  . getName (  )  )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "requestAttributes . requestCompleted (  )  ;", "assertTrue (  (  ( TestBean )     ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  )  . wasDestroyed (  )  )  ;", "}    finally    {", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testDestructionAtRequestCompletion"], "fileName": "org.springframework.web.context.request.RequestScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" outerBean \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( bean )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean . getSpouse (  )  )  )  ;", "BeanDefinition   beanDef    =    this . beanFactory . getBeanDefinition (  \" outerBean \"  )  ;", "BeanDefinitionHolder   innerBeanDef    =     (  ( BeanDefinitionHolder )     ( beanDef . getPropertyValues (  )  . getPropertyValue (  \" spouse \"  )  . getValue (  )  )  )  ;", "String   name    =    innerBeanDef . getBeanName (  )  ;", "MockHttpServletRequest    =    new   MockHttpServletRequest (  )  ;", "RequestAttributes   ttributes    =    new   ServletRequestAttributes (  ;", "RequestContextHolder . setRequestAttributes ( ttributes )  ;", "try    {", "assertNull ( getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals (  \" scoped \"  ,    bean . getSpouse (  )  . getName (  )  )  ;", "assertNotNull ( getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals ( TestBean . class ,    getAttribute (  (  \" scopedTarget .  \"     +    name )  )  . getClass (  )  )  ;", "assertEquals (  \" scoped \"  ,     (  ( TestBean )     ( getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  )  . getName (  )  )  ;", "}    finally    {", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetAnonymousInnerBeanFromScope"], "fileName": "org.springframework.web.context.request.RequestScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" requestScopedFactoryBean \"  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "RequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "try    {", "assertNull ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals ( SINGLETON _ NAME ,    bean . getName (  )  )  ;", "assertNotNull ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals ( DummyFactory . class ,    request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  . getClass (  )  )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "}    finally    {", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetFromFactoryBeanInScope"], "fileName": "org.springframework.web.context.request.RequestScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" requestScopedObject \"  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "RequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "try    {", "assertNull ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals (  \" scoped \"  ,    bean . getName (  )  )  ;", "assertNotNull ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "TestBean   target    =     (  ( TestBean )     ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  )  ;", "assertEquals ( TestBean . class ,    target . getClass (  )  )  ;", "assertEquals (  \" scoped \"  ,    target . getName (  )  )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "assertEquals ( bean . toString (  )  ,    target . toString (  )  )  ;", "}    finally    {", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetFromScope"], "fileName": "org.springframework.web.context.request.RequestScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" requestScopedProxy \"  ;", "ITestBean   bean    =     (  ( ITestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "RequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "try    {", "assertNull ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals (  \" scoped \"  ,    bean . getName (  )  )  ;", "assertNotNull ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "TestBean   target    =     (  ( TestBean )     ( request . getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  )  ;", "assertEquals ( TestBean . class ,    target . getClass (  )  )  ;", "assertEquals (  \" scoped \"  ,    target . getName (  )  )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "assertEquals ( bean . toString (  )  ,    target . toString (  )  )  ;", "}    finally    {", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetFromScopeThroughDynamicProxy"], "fileName": "org.springframework.web.context.request.RequestScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" outerBean \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( bean )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean . getSpouse (  )  )  )  ;", "String   name    =     \" scopedInnerBean \"  ;", "MockHttpServletRequest    =    new   MockHttpServletRequest (  )  ;", "RequestAttributes   ttributes    =    new   ServletRequestAttributes (  ;", "RequestContextHolder . setRequestAttributes ( ttributes )  ;", "try    {", "assertNull ( getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals (  \" scoped \"  ,    bean . getSpouse (  )  . getName (  )  )  ;", "assertNotNull ( getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  ;", "assertEquals ( TestBean . class ,    getAttribute (  (  \" scopedTarget .  \"     +    name )  )  . getClass (  )  )  ;", "assertEquals (  \" scoped \"  ,     (  ( TestBean )     ( getAttribute (  (  \" scopedTarget .  \"     +    name )  )  )  )  . getName (  )  )  ;", "}    finally    {", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetInnerBeanFromScope"], "fileName": "org.springframework.web.context.request.RequestScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "return   this . request ;", "}", "METHOD_END"], "methodName": ["getRequest"], "fileName": "org.springframework.web.context.request.ServletRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . response ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.springframework.web.context.request.ServletRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "if    ( isRequestActive (  )  )     {", "HttpSession   session    =    thisgetSession ( allowCreate )  ;", "this . session    =    session ;", "return   session ;", "} else    {", "HttpSession   session    =    this . session ;", "if    ( session    =  =    null )     {", "if    ( allowCreate )     {", "throw   new   IllegalStateException (  \" No   session   found   andalready   completed    -    cannot   create   new   session !  \"  )  ;", "} else    {", "session    =    thisgetSession ( false )  ;", "this . session    =    session ;", "}", "}", "return   session ;", "}", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.web.context.request.ServletRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "return    ( value    =  =    null )     |  |     ( ServletRequestAttributes . immutableValueTypes . contains ( value . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isImmutableSessionAttribute"], "fileName": "org.springframework.web.context.request.ServletRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "HttpSession   session    =    getSession ( true )  ;", "Assert . state (  ( session    !  =    null )  ,     \" No   HttpSession \"  )  ;", "return   session ;", "}", "METHOD_END"], "methodName": ["obtainSession"], "fileName": "org.springframework.web.context.request.ServletRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "HttpSession   session    =    obtainSession (  )  ;", "session . setAttribute (  (  (  . DESTRUCTION _ CALLBACK _ NAME _ PREFIX )     +    name )  ,    new   DestructionCallbackBindingListener ( callback )  )  ;", "}", "METHOD_END"], "methodName": ["registerSessionDestructionCallback"], "fileName": "org.springframework.web.context.request.ServletRequestAttributes"}, {"methodBody": ["METHOD_START", "{", "new   ServletRequestAttributes ( null )  ;", "}", "METHOD_END"], "methodName": ["ctorRejectsNullArg"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "HttpSession   session    =    mock ( HttpSession . class )  ;", "given ( request . getSession ( anyBoolean (  )  )  )  . willReturn ( session )  ;", "given ( session . getAttribute (  . KEY )  )  . willReturn ( immutableValue )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "attrs . getAttribute (  . KEY ,    RequestAttributes . SCOPE _ SESSION )  ;", "attrs . requestCompleted (  )  ;", "verify ( session ,    times (  2  )  )  . getAttribute (  . KEY )  ;", "verifyNoMoreInteractions ( session )  ;", "}", "METHOD_END"], "methodName": ["doSkipImmutableValue"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "Object   value    =    attrs . getAttribute (  . KEY ,    RequestAttributes . SCOPE _ SESSION )  ;", "assertNull ( value )  ;", "verify ( request )  . getSession ( false )  ;", "}", "METHOD_END"], "methodName": ["getSessionScopedAttributeDoesNotForceCreationOfSession"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpSession   session    =    new   MockHttpSession (  )  ;", "session . setAttribute (  . KEY ,     . VALUE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setSession ( session )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "attrs . removeAttribute (  . KEY ,    RequestAttributes . SCOPE _ SESSION )  ;", "Object   value    =    session . getAttribute (  . KEY )  ;", "assertNull ( value )  ;", "}", "METHOD_END"], "methodName": ["removeSessionScopedAttribute"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "attrs . removeAttribute (  . KEY ,    RequestAttributes . SCOPE _ SESSION )  ;", "verify ( request )  . getSession ( false )  ;", "}", "METHOD_END"], "methodName": ["removeSessionScopedAttributeDoesNotForceCreationOfSession"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "attrs . setAttribute (  . KEY ,     . VALUE ,    RequestAttributes . SCOPE _ REQUEST )  ;", "Object   value    =    request . getAttribute (  . KEY )  ;", "assertSame (  . VALUE ,    value )  ;", "}", "METHOD_END"], "methodName": ["setRequestScopedAttribute"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "request . close (  )  ;", "try    {", "attrs . setAttribute (  . KEY ,     . VALUE ,    RequestAttributes . SCOPE _ REQUEST )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["setRequestScopedAttributeAfterCompletion"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpSession   session    =    new   MockHttpSession (  )  ;", "session . setAttribute (  . KEY ,     . VALUE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setSession ( session )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "attrs . setAttribute (  . KEY ,     . VALUE ,    RequestAttributes . SCOPE _ SESSION )  ;", "assertSame (  . VALUE ,    session . getAttribute (  . KEY )  )  ;", "}", "METHOD_END"], "methodName": ["setSessionScopedAttribute"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpSession   session    =    new   MockHttpSession (  )  ;", "session . setAttribute (  . KEY ,     . VALUE )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setSession ( session )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "assertSame (  . VALUE ,    attrs . getAttribute (  . KEY ,    RequestAttributes . SCOPE _ SESSION )  )  ;", "attrs . requestCompleted (  )  ;", "request . close (  )  ;", "attrs . setAttribute (  . KEY ,     . VALUE ,    RequestAttributes . SCOPE _ SESSION )  ;", "assertSame (  . VALUE ,    session . getAttribute (  . KEY )  )  ;", "}", "METHOD_END"], "methodName": ["setSessionScopedAttributeAfterCompletion"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "doSkipImmutableValue ( new   BigInteger (  \"  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["skipImmutableBigInteger"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "doSkipImmutableValue ( Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["skipImmutableBoolean"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "doSkipImmutableValue ( new   Character (  ' x '  )  )  ;", "}", "METHOD_END"], "methodName": ["skipImmutableCharacter"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "doSkipImmutableValue ( new   Float (  1  .  1  )  )  ;", "}", "METHOD_END"], "methodName": ["skipImmutableFloat"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "doSkipImmutableValue ( new   Integer (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["skipImmutableInteger"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "doSkipImmutableValue (  \" someString \"  )  ;", "}", "METHOD_END"], "methodName": ["skipImmutableString"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "HttpSession   session    =    mock ( HttpSession . class )  ;", "given ( request . getSession ( anyBoolean (  )  )  )  . willReturn ( session )  ;", "given ( session . getAttribute (  . KEY )  )  . willReturn (  . VALUE )  ;", "ServletRequestAttributes   attrs    =    new   ServletRequestAttributes ( request )  ;", "assertSame (  . VALUE ,    attrs . getAttribute (  . KEY ,    RequestAttributes . SCOPE _ SESSION )  )  ;", "attrs . requestCompleted (  )  ;", "verify ( session ,    times (  2  )  )  . getAttribute (  . KEY )  ;", "verify ( session )  . setAttribute (  . KEY ,     . VALUE )  ;", "verifyNoMoreInteractions ( session )  ;", "}", "METHOD_END"], "methodName": ["updateAccessedAttributes"], "fileName": "org.springframework.web.context.request.ServletRequestAttributesTests"}, {"methodBody": ["METHOD_START", "{", "return   HttpMethod . resolve ( getRequest (  )  . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHttpMethod"], "fileName": "org.springframework.web.context.request.ServletWebRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . notModified ;", "}", "METHOD_END"], "methodName": ["isNotModified"], "fileName": "org.springframework.web.context.request.ServletWebRequest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( etag )  )  )     {", "return   etag ;", "}", "if    (  (  ( etag . startsWith (  \"  \\  \"  \"  )  )     |  |     ( etag . startsWith (  \" W /  \\  \"  \"  )  )  )     &  &     ( etag . endsWith (  \"  \\  \"  \"  )  )  )     {", "return   etag ;", "}", "return    (  \"  \\  \"  \"     +    etag )     +     \"  \\  \"  \"  ;", "}", "METHOD_END"], "methodName": ["padEtagIfNecessary"], "fileName": "org.springframework.web.context.request.ServletWebRequest"}, {"methodBody": ["METHOD_START", "{", "long   dateValue    =     -  1  ;", "try    {", "dateValue    =    get (  )  . getDateHeader ( headerName )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "String   headerValue    =    getHeader ( headerName )  ;", "if    ( headerValue    !  =    null )     {", "int   separatorIndex    =    headerValue . indexOf (  '  ;  '  )  ;", "if    ( separatorIndex    !  =     (  -  1  )  )     {", "String   datePart    =    headerValue . substring (  0  ,    separatorIndex )  ;", "dateValue    =    parseDateValue ( datePart )  ;", "}", "}", "}", "return   dateValue ;", "}", "METHOD_END"], "methodName": ["parseDateHeader"], "fileName": "org.springframework.web.context.request.ServletWebRequest"}, {"methodBody": ["METHOD_START", "{", "if    ( headerValue    =  =    null )     {", "return    -  1  ;", "}", "if    (  ( headerValue . length (  )  )     >  =     3  )     {", "for    ( String   dateFormat    :     . DATE _ FORMATS )     {", "SimpleDateFormat   simpleDateFormat    =    new   SimpleDateFormat ( dateFormat ,    Locale . US )  ;", "simpleDateFormat . setTimeZone (  . GMT )  ;", "try    {", "return   simpleDateFormat . parse ( headerValue )  . getTime (  )  ;", "}    catch    ( ParseException   ex )     {", "}", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["parseDateValue"], "fileName": "org.springframework.web.context.request.ServletWebRequest"}, {"methodBody": ["METHOD_START", "{", "if    ( lastModifiedTimestamp    <     0  )     {", "return   false ;", "}", "long   ifModifiedSince    =    parseDateHeader (  . IF _ MODIFIED _ SINCE )  ;", "if    ( ifModifiedSince    =  =     (  -  1  )  )     {", "return   false ;", "}", "this . notModified    =    ifModifiedSince    >  =     (  ( lastModifiedTimestamp    /     1  0  0  0  )     *     1  0  0  0  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["validateIfModifiedSince"], "fileName": "org.springframework.web.context.request.ServletWebRequest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( etag )  )  )     {", "return   false ;", "}", "Enumeration < String >    ifNoneMatch ;", "try    {", "ifNoneMatch    =    getRequest (  )  . getHeaders (  . IF _ NONE _ MATCH )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "return   false ;", "}", "if    (  !  ( ifNoneMatch . hasMoreElements (  )  )  )     {", "return   false ;", "}", "etag    =    padEtagIfNecessary ( etag )  ;", "while    ( ifNoneMatch . hasMoreElements (  )  )     {", "String   clientETags    =    ifNoneMatch . nextElement (  )  ;", "Matcher   etagMatcher    =     . ETAG _ HEADER _ VALUE _ PATTERN . matcher ( clientETags )  ;", "while    ( etagMatcher . find (  )  )     {", "if    (  ( StringUtils . hasLength ( etagMatcher . group (  )  )  )     &  &     ( etag . replaceFirst (  \"  ^ W /  \"  ,     \"  \"  )  . equals ( etagMatcher . group (  3  )  )  )  )     {", "this . notModified    =    true ;", "break ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["validateIfNoneMatch"], "fileName": "org.springframework.web.context.request.ServletWebRequest"}, {"methodBody": ["METHOD_START", "{", "if    ( lastModifiedTimestamp    <     0  )     {", "return   false ;", "}", "long   ifUnmodifiedSince    =    parseDateHeader (  . IF _ UNMODIFIED _ SINCE )  ;", "if    ( ifUnmodifiedSince    =  =     (  -  1  )  )     {", "return   false ;", "}", "this . notModified    =    ifUnmodifiedSince    <     (  ( lastModifiedTimestamp    /     1  0  0  0  )     *     1  0  0  0  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["validateIfUnmodifiedSince"], "fileName": "org.springframework.web.context.request.ServletWebRequest"}, {"methodBody": ["METHOD_START", "{", "String   currentETag    =     \"  \\  \" Foo \\  \"  \"  ;", "String   oldETag    =     \" Bar \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    oldETag )  ;", "assertFalse ( checkNotModified ( currentETag )  )  ;", "assertEquals (  2  0  0  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( currentETag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedETag"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   currentETag    =     \"  \\  \" Foo \\  \"  \"  ;", "String   oldETag    =     \"  \\  \" Bar \\  \"  \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    oldETag )  ;", "long   epochTime    =    currentDate . getTime (  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,    epochTime )  ;", "assertFalse ( checkNotModified ( currentETag ,    epochTime )  )  ;", "assertEquals (  2  0  0  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( currentETag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "assertEquals (  (  ( currentDate . getTime (  )  )     /     1  0  0  0  )  ,     (  ( servletResponse . getDateHeader (  \" Last - Modified \"  )  )     /     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedETagAndNotModifiedTimestamp"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   oneMinuteAgo    =     ( currentDate . getTime (  )  )     -     (  1  0  0  0     *     6  0  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,    oneMinuteAgo )  ;", "assertFalse ( checkNotModified ( currentDate . getTime (  )  )  )  ;", "assertEquals (  2  0  0  ,    servletResponse . getStatus (  )  )  ;", "assertEquals (  (  ( currentDate . getTime (  )  )     /     1  0  0  0  )  ,     (  ( servletResponse . getDateHeader (  \" Last - Modified \"  )  )     /     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedTimestamp"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   epochTime    =    ZonedDateTime . parse ( ServletWebRequestHttpMethodsTests . CURRENT _ TIME ,    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME )  . toInstant (  )  . toEpochMilli (  )  ;", "servletRequest . setMethod (  \" GET \"  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,     \" Wed ,     0  8    Apr    2  0  1  4     0  9  :  5  7  :  4  2    GMT ;    length =  1  3  7  7  4  \"  )  ;", "assertFalse ( request . checkNotModified ( epochTime )  )  ;", "assertEquals (  2  0  0  ,    servletResponse . getStatus (  )  )  ;", "assertEquals (  ( epochTime    /     1  0  0  0  )  ,     (  ( servletResponse . getDateHeader (  \" Last - Modified \"  )  )     /     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedTimestampWithLengthPart"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   currentETag    =     \" Foo \"  ;", "String   oldETag    =     \" Bar \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    oldETag )  ;", "assertFalse ( checkNotModified ( currentETag )  )  ;", "assertEquals (  2  0  0  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( String . format (  \"  \\  \"  % s \\  \"  \"  ,    currentETag )  ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedUnpaddedETag"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" Foo \\  \"  \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    etag )  ;", "assertTrue ( checkNotModified ( etag )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( etag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETag"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" Foo \\  \"  \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    etag )  ;", "long   currentEpoch    =    currentDate . getTime (  )  ;", "long   oneMinuteAgo    =    currentEpoch    -     (  1  0  0  0     *     6  0  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,    oneMinuteAgo )  ;", "assertTrue ( checkNotModified ( etag ,    currentEpoch )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( etag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "assertEquals (  (  ( currentDate . getTime (  )  )     /     1  0  0  0  )  ,     (  ( servletResponse . getDateHeader (  \" Last - Modified \"  )  )     /     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagAndModifiedTimestamp"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" Foo \\  \"  \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    etag )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,    currentDate . getTime (  )  )  ;", "assertTrue ( checkNotModified ( etag ,    currentDate . getTime (  )  )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( etag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "assertEquals (  (  ( currentDate . getTime (  )  )     /     1  0  0  0  )  ,     (  ( servletResponse . getDateHeader (  \" Last - Modified \"  )  )     /     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagAndTimestamp"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" Foo \\  \"  \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    String . format (  \" W /  % s \"  ,    etag )  )  ;", "assertTrue ( checkNotModified ( etag )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( etag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagStrongWeak"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" Foo \\  \"  \"  ;", "String   weakETag    =    String . format (  \" W /  % s \"  ,    etag )  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    etag )  ;", "assertTrue ( checkNotModified ( weakETag )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( weakETag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagWeakStrong"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" Foo ,    Bar \\  \"  \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    etag )  ;", "assertTrue ( checkNotModified ( etag )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( etag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagWithSeparatorChars"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   epochTime    =    currentDate . getTime (  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,    epochTime )  ;", "servletResponse . addHeader (  \" Last - Modified \"  ,     . CURRENT _ TIME )  ;", "assertTrue ( request . checkNotModified ( epochTime )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals (  1  ,    servletResponse . getHeaders (  \" Last - Modified \"  )  . size (  )  )  ;", "assertEquals (  . CURRENT _ TIME ,    servletResponse . getHeader (  \" Last - Modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedHeaderAlreadySet"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" etagvalue \\  \"  \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,     \" missingquotes \"  )  ;", "assertFalse ( checkNotModified ( etag )  )  ;", "assertEquals (  2  0  0  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( etag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedInvalidIfNoneMatchHeader"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   epochTime    =    currentDate . getTime (  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,    epochTime )  ;", "servletResponse . setStatus (  0  )  ;", "assertFalse ( checkNotModified ( epochTime )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedInvalidStatus"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" Bar \\  \"  \"  ;", "String   multipleETags    =    String . format (  \"  \\  \" Foo \\  \"  ,     % s \"  ,    etag )  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    multipleETags )  ;", "assertTrue ( checkNotModified ( etag )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( etag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedMultipleETags"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   epochTime    =    currentDate . getTime (  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,    epochTime )  ;", "servletResponse . setStatus (  3  0  4  )  ;", "assertFalse ( checkNotModified ( epochTime )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertNull ( servletResponse . getHeader (  \" Last - Modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedNon2xxStatus"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   epochTime    =    currentDate . getTime (  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,    epochTime )  ;", "assertTrue ( checkNotModified ( epochTime )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals (  (  ( currentDate . getTime (  )  )     /     1  0  0  0  )  ,     (  ( servletResponse . getDateHeader (  \" Last - Modified \"  )  )     /     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedTimestamp"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   currentEpoch    =    currentDate . getTime (  )  ;", "long   oneMinuteAgo    =    currentEpoch    -     (  1  0  0  0     *     6  0  )  ;", "servletRequest . setMethod (  \" PUT \"  )  ;", "servletRequest . addHeader (  \" If - UnModified - Since \"  ,    currentEpoch )  ;", "assertFalse ( checkNotModified ( oneMinuteAgo )  )  ;", "assertEquals (  2  0  0  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( null ,    servletResponse . getHeader (  \" Last - Modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedTimestampConditionalPut"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   currentEpoch    =    currentDate . getTime (  )  ;", "long   oneMinuteAgo    =    currentEpoch    -     (  1  0  0  0     *     6  0  )  ;", "servletRequest . setMethod (  \" PUT \"  )  ;", "servletRequest . addHeader (  \" If - UnModified - Since \"  ,    oneMinuteAgo )  ;", "assertTrue ( checkNotModified ( currentEpoch )  )  ;", "assertEquals (  4  1  2  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( null ,    servletResponse . getHeader (  \" Last - Modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedTimestampConditionalPutConflict"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "long   epochTime    =    ZonedDateTime . parse ( ServletWebRequestHttpMethodsTests . CURRENT _ TIME ,    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME )  . toInstant (  )  . toEpochMilli (  )  ;", "servletRequest . setMethod (  \" GET \"  )  ;", "servletRequest . addHeader (  \" If - Modified - Since \"  ,     \" Wed ,     0  9    Apr    2  0  1  4     0  9  :  5  7  :  4  2    GMT ;    length =  1  3  7  7  4  \"  )  ;", "assertTrue ( request . checkNotModified ( epochTime )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals (  ( epochTime    /     1  0  0  0  )  ,     (  ( servletResponse . getDateHeader (  \" Last - Modified \"  )  )     /     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedTimestampWithLengthPart"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \" Foo \"  ;", "String   paddedETag    =    String . format (  \"  \\  \"  % s \\  \"  \"  ,    etag )  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,    paddedETag )  ;", "assertTrue ( checkNotModified ( etag )  )  ;", "assertEquals (  3  0  4  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( paddedETag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedUnpaddedETag"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" Foo \\  \"  \"  ;", "servletRequest . addHeader (  \" If - None - Match \"  ,     \"  *  \"  )  ;", "assertFalse ( checkNotModified ( etag )  )  ;", "assertEquals (  2  0  0  ,    servletResponse . getStatus (  )  )  ;", "assertEquals ( etag ,    servletResponse . getHeader (  \" ETag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedWildcardIsIgnored"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( new   Object [  ]  [  ]  {    new   Object [  ]  {     \" GET \"     }  ,    new   Object [  ]  {     \" HEAD \"     }     }  )  ;", "}", "METHOD_END"], "methodName": ["safeMethods"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "currentDate    =    new   Date (  )  ;", "servletRequest    =    new   MockHttpServletRequest ( method ,     \" http :  /  / example . org \"  )  ;", "servletResponse    =    new   MockHttpServletResponse (  )  ;", "request    =    new    ( servletRequest ,    servletResponse )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.ServletWebRequestHttpMethodsTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   decoratedRequest    =    new   HttpServletRequestWrapper ( servletRequest )  ;", "HttpServletResponse   decoratedResponse    =    new   HttpServletResponseWrapper ( servletResponse )  ;", "request    =    new    ( decoratedRequest ,    decoratedResponse )  ;", "assertSame ( decoratedRequest ,    request . getNativeRequest (  )  )  ;", "assertSame ( decoratedRequest ,    request . getNativeRequest ( ServletRequest . class )  )  ;", "assertSame ( decoratedRequest ,    request . getNativeRequest ( HttpServletRequest . class )  )  ;", "assertSame ( servletRequest ,    request . getNativeRequest ( MockHttpServletRequest . class )  )  ;", "assertNull ( request . getNativeRequest ( MultipartRequest . class )  )  ;", "assertSame ( decoratedResponse ,    request . getNativeResponse (  )  )  ;", "assertSame ( decoratedResponse ,    request . getNativeResponse ( ServletResponse . class )  )  ;", "assertSame ( decoratedResponse ,    request . getNativeResponse ( HttpServletResponse . class )  )  ;", "assertSame ( servletResponse ,    request . getNativeResponse ( MockHttpServletResponse . class )  )  ;", "assertNull ( request . getNativeResponse ( MultipartRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["decoratedNativeRequest"], "fileName": "org.springframework.web.context.request.ServletWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "servletRequest . addPreferredLocale ( Locale . UK )  ;", "assertEquals ( Locale . UK ,    getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["locale"], "fileName": "org.springframework.web.context.request.ServletWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( servletRequest ,    request . getNativeRequest (  )  )  ;", "assertSame ( servletRequest ,    request . getNativeRequest ( ServletRequest . class )  )  ;", "assertSame ( servletRequest ,    request . getNativeRequest ( HttpServletRequest . class )  )  ;", "assertSame ( servletRequest ,    request . getNativeRequest ( MockHttpServletRequest . class )  )  ;", "assertNull ( request . getNativeRequest ( MultipartRequest . class )  )  ;", "assertSame ( servletResponse ,    request . getNativeResponse (  )  )  ;", "assertSame ( servletResponse ,    request . getNativeResponse ( ServletResponse . class )  )  ;", "assertSame ( servletResponse ,    request . getNativeResponse ( HttpServletResponse . class )  )  ;", "assertSame ( servletResponse ,    request . getNativeResponse ( MockHttpServletResponse . class )  )  ;", "assertNull ( request . getNativeResponse ( MultipartRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["nativeRequest"], "fileName": "org.springframework.web.context.request.ServletWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "servletRequest . addParameter (  \" param 1  \"  ,     \" value 1  \"  )  ;", "servletRequest . addParameter (  \" param 2  \"  ,     \" value 2  \"  )  ;", "servletRequest . addParameter (  \" param 2  \"  ,     \" value 2 a \"  )  ;", "assertEquals (  \" value 1  \"  ,    getParameter (  \" param 1  \"  )  )  ;", "assertEquals (  1  ,    getParameterValues (  \" param 1  \"  )  . length )  ;", "assertEquals (  \" value 1  \"  ,    getParameterValues (  \" param 1  \"  )  [  0  ]  )  ;", "assertEquals (  \" value 2  \"  ,    getParameter (  \" param 2  \"  )  )  ;", "assertEquals (  2  ,    getParameterValues (  \" param 2  \"  )  . length )  ;", "assertEquals (  \" value 2  \"  ,    getParameterValues (  \" param 2  \"  )  [  0  ]  )  ;", "assertEquals (  \" value 2 a \"  ,    getParameterValues (  \" param 2  \"  )  [  1  ]  )  ;", "Map < String ,    String [  ]  >    paramMap    =    getParameterMap (  )  ;", "assertEquals (  2  ,    paramMap . size (  )  )  ;", "assertEquals (  1  ,    paramMap . get (  \" param 1  \"  )  . length )  ;", "assertEquals (  \" value 1  \"  ,    paramMap . get (  \" param 1  \"  )  [  0  ]  )  ;", "assertEquals (  2  ,    paramMap . get (  \" param 2  \"  )  . length )  ;", "assertEquals (  \" value 2  \"  ,    paramMap . get (  \" param 2  \"  )  [  0  ]  )  ;", "assertEquals (  \" value 2 a \"  ,    paramMap . get (  \" param 2  \"  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["parameters"], "fileName": "org.springframework.web.context.request.ServletWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "servletRequest    =    new   MockHttpServletRequest (  )  ;", "servletResponse    =    new   MockHttpServletResponse (  )  ;", "request    =    new    ( servletRequest ,    servletResponse )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.ServletWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpSession   session    =    new   MockHttpSession (  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setSession ( session )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "String   name    =     \" sdDisposableObject \"  ;", "assertNull ( session . getAttribute ( name )  )  ;", "DerivedTestBean   bean    =     (  ( DerivedTestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertEquals ( session . getAttribute ( name )  ,    bean )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "requestAttributes . requestCompleted (  )  ;", "session . invalidate (  )  ;", "assertTrue ( bean . wasDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["destructionAtSessionTermination"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "doTestDestructionWithSessionSerialization ( false )  ;", "}", "METHOD_END"], "methodName": ["destructionWithSessionSerialization"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . addBeanPostProcessor ( new   SessionScopeTests . CustomDestructionAwareBeanPostProcessor (  )  )  ;", "doTestDestructionWithSessionSerialization ( false )  ;", "}", "METHOD_END"], "methodName": ["destructionWithSessionSerializationAndBeanPostProcessor"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . addBeanPostProcessor ( new   SessionScopeTests . CustomSerializableDestructionAwareBeanPostProcessor (  )  )  ;", "doTestDestructionWithSessionSerialization ( true )  ;", "}", "METHOD_END"], "methodName": ["destructionWithSessionSerializationAndSerializableBeanPostProcessor"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "Serializable   serializedState    =    null ;", "MockHttpSession   session    =    new   MockHttpSession (  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setSession ( session )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "String   name    =     \" sdDisposableObject \"  ;", "assertNull ( session . getAttribute ( name )  )  ;", "DerivedTestBean   bean    =     (  ( DerivedTestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertEquals ( session . getAttribute ( name )  ,    bean )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "requestAttributes . requestCompleted (  )  ;", "serializedState    =    session . serializeState (  )  ;", "assertFalse ( bean . wasDestroyed (  )  )  ;", "serializedState    =     (  ( Serializable )     ( SerializationTestUtils . serializeAndDeserialize ( serializedState )  )  )  ;", "session    =    new   MockHttpSession (  )  ;", "session . deserializeState ( serializedState )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "request . setSession ( session )  ;", "requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "name    =     \" sdDisposableObject \"  ;", "assertNotNull ( session . getAttribute ( name )  )  ;", "bean    =     (  ( DerivedTestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertEquals ( session . getAttribute ( name )  ,    bean )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "requestAttributes . requestCompleted (  )  ;", "session . invalidate (  )  ;", "assertTrue ( bean . wasDestroyed (  )  )  ;", "if    ( beanNameReset )     {", "assertNull ( bean . getBeanName (  )  )  ;", "} else    {", "assertNotNull ( bean . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestDestructionWithSessionSerialization"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "AtomicInteger   count    =    new   AtomicInteger (  )  ;", "MockHttpSession   session    =    new   MockHttpSession (  )     {", "@ Override", "public   void   setAttribute ( String   name ,    Object   value )     {", "super . setAttribute ( name ,    value )  ;", "count . incrementAndGet (  )  ;", "}", "}  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setSession ( session )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "String   name    =     \" sdObject \"  ;", "assertNull ( session . getAttribute ( name )  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertEquals (  1  ,    count . intValue (  )  )  ;", "assertEquals ( session . getAttribute ( name )  ,    bean )  ;", "assertSame ( bean ,    this . beanFactory . getBean ( name )  )  ;", "assertEquals (  1  ,    count . intValue (  )  )  ;", "requestAttributes . requestCompleted (  )  ;", "assertEquals ( session . getAttribute ( name )  ,    bean )  ;", "assertEquals (  2  ,    count . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFromScope"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "AtomicInteger   count    =    new   AtomicInteger (  )  ;", "MockHttpSession   session    =    new   MockHttpSession (  )     {", "@ Override", "public   void   setAttribute ( String   name ,    Object   value )     {", "super . setAttribute ( name ,    value )  ;", "count . incrementAndGet (  )  ;", "}", "}  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setSession ( session )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "String   name    =     \" sdObject \"  ;", "assertNull ( session . getAttribute ( name )  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean ( name )  )  )  ;", "assertEquals (  1  ,    count . intValue (  )  )  ;", "requestAttributes . requestCompleted (  )  ;", "assertEquals ( session . getAttribute ( name )  ,    bean )  ;", "assertEquals (  2  ,    count . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFromScopeWithSingleAccess"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "METHOD_END"], "methodName": ["resetRequestAttributes"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . registerScope (  \" session \"  ,    new   SessionScope (  )  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" s . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.SessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "GenericWebApplicationContext   ac    =    new   GenericWebApplicationContext ( sc )  ;", "GenericBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setBeanClass ( DerivedTestBean . class )  ;", "bd . setScope ( scope )  ;", "ac . registerBeanDefinition (  . NAME ,    bd )  ;", "ac . refresh (  )  ;", "return   ac ;", "}", "METHOD_END"], "methodName": ["initApplicationContext"], "fileName": "org.springframework.web.context.request.WebApplicationContextScopeTests"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   ac    =    initApplicationContext ( WebApplicationContext . SCOPE _ APPLICATION )  ;", "assertNull ( ac . getServletContext (  )  . getAttribute (  . NAME )  )  ;", "DerivedTestBean   bean    =    ac . getBean (  . NAME ,    DerivedTestBean . class )  ;", "assertSame ( bean ,    ac . getServletContext (  )  . getAttribute (  . NAME )  )  ;", "assertSame ( bean ,    ac . getBean (  . NAME )  )  ;", "new   ContextCleanupListener (  )  . contextDestroyed ( new   ServletContextEvent ( ac . getServletContext (  )  )  )  ;", "assertTrue ( bean . wasDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplicationScope"], "fileName": "org.springframework.web.context.request.WebApplicationContextScopeTests"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   ac    =    initApplicationContext ( WebApplicationContext . SCOPE _ REQUEST )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "try    {", "assertNull ( request . getAttribute (  . NAME )  )  ;", "DerivedTestBean   bean    =    ac . getBean (  . NAME ,    DerivedTestBean . class )  ;", "assertSame ( bean ,    request . getAttribute (  . NAME )  )  ;", "assertSame ( bean ,    ac . getBean (  . NAME )  )  ;", "requestAttributes . requestCompleted (  )  ;", "assertTrue ( bean . wasDestroyed (  )  )  ;", "}    finally    {", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testRequestScope"], "fileName": "org.springframework.web.context.request.WebApplicationContextScopeTests"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   ac    =    initApplicationContext ( WebApplicationContext . SCOPE _ SESSION )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "ServletRequestAttributes   requestAttributes    =    new   ServletRequestAttributes ( request )  ;", "RequestContextHolder . setRequestAttributes ( requestAttributes )  ;", "try    {", "assertNull ( request . getSession (  )  . getAttribute (  . NAME )  )  ;", "DerivedTestBean   bean    =    ac . getBean (  . NAME ,    DerivedTestBean . class )  ;", "assertSame ( bean ,    request . getSession (  )  . getAttribute (  . NAME )  )  ;", "assertSame ( bean ,    ac . getBean (  . NAME )  )  ;", "request . getSession (  )  . invalidate (  )  ;", "assertTrue ( bean . wasDestroyed (  )  )  ;", "}    finally    {", "RequestContextHolder . setRequestAttributes ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["testSessionScope"], "fileName": "org.springframework.web.context.request.WebApplicationContextScopeTests"}, {"methodBody": ["METHOD_START", "{", "for    ( CallableProcessingInterceptor   interceptor    :    this . interceptors )     {", "interceptor . beforeConcurrentHandling ( request ,    task )  ;", "}", "}", "METHOD_END"], "methodName": ["applyBeforeConcurrentHandling"], "fileName": "org.springframework.web.context.request.async.CallableInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "Throwable   exceptionResult    =    null ;", "for    ( int   i    =    this . preProcessIndex ;    i    >  =     0  ;    i -  -  )     {", "try    {", "this . interceptors . get ( i )  . postProcess ( request ,    task ,    concurrentResult )  ;", "}    catch    ( Throwable   t )     {", "if    ( exceptionResult    !  =    null )     {", ". logger . error (  \" postProcess   error \"  ,    t )  ;", "} else    {", "exceptionResult    =    t ;", "}", "}", "}", "return   exceptionResult    !  =    null    ?    exceptionResult    :    concurrentResult ;", "}", "METHOD_END"], "methodName": ["applyPostProcess"], "fileName": "org.springframework.web.context.request.async.CallableInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "for    ( CallableProcessingInterceptor   interceptor    :    this . interceptors )     {", "interceptor . preProcess ( request ,    task )  ;", "( this . preProcessIndex )  +  +  ;", "}", "}", "METHOD_END"], "methodName": ["applyPreProcess"], "fileName": "org.springframework.web.context.request.async.CallableInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "Future <  ?  >    future    =    this . taskFuture ;", "if    ( future    !  =    null )     {", "try    {", "future . cancel ( true )  ;", "}    catch    ( Throw   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["cancelTask"], "fileName": "org.springframework.web.context.request.async.CallableInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "this . taskFuture    =    taskFuture ;", "}", "METHOD_END"], "methodName": ["setTaskFuture"], "fileName": "org.springframework.web.context.request.async.CallableInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( this . interceptors . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "try    {", "this . interceptors . get ( i )  . afterCompletion ( request ,    task )  ;", "}    catch    ( Throwable   t )     {", ". logger . error (  \" afterCompletion   error \"  ,    t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["triggerAfterCompletion"], "fileName": "org.springframework.web.context.request.async.CallableInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "cancelTask (  )  ;", "for    ( CallableProcessing   interceptor    :    this . interceptors )     {", "try    {", "Object   result    =    interceptor . handleError ( request ,    task ,    throwable )  ;", "if    ( result    =  =     ( CallableProcessing . RESPONSE _ HANDLED )  )     {", "break ;", "} else", "if    ( result    !  =     ( CallableProcessing . RESULT _ NONE )  )     {", "return   result ;", "}", "}    catch    ( Throwable   t )     {", "return   t ;", "}", "}", "return   CallableProcessing . RESULT _ NONE ;", "}", "METHOD_END"], "methodName": ["triggerAfterError"], "fileName": "org.springframework.web.context.request.async.CallableInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "cancelTask (  )  ;", "for    ( CallableProcessing   interceptor    :    this . interceptors )     {", "try    {", "Object   result    =    interceptor . handleTimeout ( request ,    task )  ;", "if    ( result    =  =     ( CallableProcessing . RESPONSE _ HANDLED )  )     {", "break ;", "} else", "if    ( result    !  =     ( CallableProcessing . RESULT _ NONE )  )     {", "return   result ;", "}", "}    catch    ( Throwable   t )     {", "return   t ;", "}", "}", "return   CallableProcessing . RESULT _ NONE ;", "}", "METHOD_END"], "methodName": ["triggerAfterTimeout"], "fileName": "org.springframework.web.context.request.async.CallableInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "return   CallableProcessingInterceptor . RESULT _ NONE ;", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.springframework.web.context.request.async.CallableProcessingInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   CallableProcessingInterceptor . RESULT _ NONE ;", "}", "METHOD_END"], "methodName": ["handleTimeout"], "fileName": "org.springframework.web.context.request.async.CallableProcessingInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   DeferredResultProcessingInterceptor (  )     {", "@ Override", "public    < S >    boolean   handleTimeout ( NativeWebRequest   request ,    DeferredResult < S >    deferredResult )     {", "boolean   continueProcessing    =    true ;", "try    {", "if    (  ( timeoutCallback )     !  =    null )     {", "timeoutCallback . run (  )  ;", "}", "}    finally    {", "if    (  ( timeoutResult )     !  =     ( DeferredResult . RESULT _ NONE )  )     {", "continueProcessing    =    false ;", "try    {", "setResultInternal ( timeoutResult )  ;", "}    catch    ( Throwable   ex )     {", "DeferredResult . logger . debug (  \" Failed   to   handle   timeout   result \"  ,    ex )  ;", "}", "}", "}", "return   continueProcessing ;", "}", "@ Override", "public    < S >    boolean   handleError ( NativeWebRequest   request ,    DeferredResult < S >    deferredResult ,    Throwable   t )     {", "try    {", "if    (  ( errorCallback )     !  =    null )     {", "errorCallback . accept ( t )  ;", "}", "}    finally    {", "try    {", "setResultInternal ( t )  ;", "}    catch    ( Throwable   ex )     {", "DeferredResult . logger . debug (  \" Failed   to   handle   error   result \"  ,    ex )  ;", "}", "}", "return   false ;", "}", "@ Override", "public    < S >    void   afterCompletion ( NativeWebRequest   request ,    DeferredResult < S >    deferredResult )     {", "expired    =    true ;", "if    (  ( completionCallback )     !  =    null )     {", "completionCallback . run (  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getInterceptor"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "Object   resultToCheck    =    this . result ;", "return   resultToCheck    !  =     (  . RESULT _ NONE )     ?    resultToCheck    :    null ;", "}", "METHOD_END"], "methodName": ["getResult"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "return   this . timeout ;", "}", "METHOD_END"], "methodName": ["getTimeoutValue"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "return    ( this . result )     !  =     ( DeferredResult . RESULT _ NONE )  ;", "}", "METHOD_END"], "methodName": ["hasResult"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . result )     !  =     ( DeferredResult . RESULT _ NONE )  )     |  |     ( this . expired )  ;", "}", "METHOD_END"], "methodName": ["isSetOrExpired"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "this . completionCallback    =    callback ;", "}", "METHOD_END"], "methodName": ["onCompletion"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "this . errorCallback    =    callback ;", "}", "METHOD_END"], "methodName": ["onError"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "this . timeoutCallback    =    callback ;", "}", "METHOD_END"], "methodName": ["onTimeout"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "return   setResultInternal ( result )  ;", "}", "METHOD_END"], "methodName": ["setErrorResult"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "return   setResultInternal ( result )  ;", "}", "METHOD_END"], "methodName": ["setResult"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resultHandler ,     \" DeferredResultHandler   is   required \"  )  ;", "if    ( this . expired )     {", "return ;", "}", "Object   resultToHandle ;", "synchronized ( this )     {", "if    ( this . expired )     {", "return ;", "}", "resultToHandle    =    this . result ;", "if    ( resultToHandle    =  =     ( DeferredResult . RESULT _ NONE )  )     {", "this . resultHandler    =    resultHandler ;", "return ;", "}", "}", "try    {", "resultHandler . handleResult ( resultToHandle )  ;", "}    catch    ( Throwable   ex )     {", "DeferredResult . logger . debug (  \" Failed   to   handle   existing   result \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["setResultHandler"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "if    ( isSetOrExpired (  )  )     {", "return   false ;", "}", "Handler   resultHandlerToUse ;", "synchronized ( this )     {", "if    ( isSetOrExpired (  )  )     {", "return   false ;", "}", "this . result    =    result ;", "resultHandlerToUse    =    this . resultHandler ;", "if    ( resultHandlerToUse    =  =    null )     {", "return   true ;", "}", "this . resultHandler    =    null ;", "}", "resultHandlerToUse . handleResult ( result )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["setResultInternal"], "fileName": "org.springframework.web.context.request.async.DeferredResult"}, {"methodBody": ["METHOD_START", "{", "for    ( DeferredResultProcessingInterceptor   interceptor    :    this . interceptors )     {", "interceptor . beforeConcurrentHandling ( request ,    deferredResult )  ;", "}", "}", "METHOD_END"], "methodName": ["applyBeforeConcurrentHandling"], "fileName": "org.springframework.web.context.request.async.DeferredResultInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "try    {", "for    ( int   i    =    this . preProcessingIndex ;    i    >  =     0  ;    i -  -  )     {", "this . interceptors . get ( i )  . postProcess ( request ,    d ,    concurrentResult )  ;", "}", "}    catch    ( Throwable   t )     {", "return   t ;", "}", "return   concurrentResult ;", "}", "METHOD_END"], "methodName": ["applyPostProcess"], "fileName": "org.springframework.web.context.request.async.DeferredResultInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "for    ( DeferredResultProcessingInterceptor   interceptor    :    this . interceptors )     {", "interceptor . preProcess ( request ,    deferredResult )  ;", "( this . preProcessingIndex )  +  +  ;", "}", "}", "METHOD_END"], "methodName": ["applyPreProcess"], "fileName": "org.springframework.web.context.request.async.DeferredResultInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    this . preProcessingIndex ;    i    >  =     0  ;    i -  -  )     {", "try    {", "this . interceptors . get ( i )  . afterCompletion ( request ,    deferredResult )  ;", "}    catch    ( Throwable   t )     {", ". logger . error (  \" afterCompletion   error \"  ,    t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["triggerAfterCompletion"], "fileName": "org.springframework.web.context.request.async.DeferredResultInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "for    ( DeferredResultProcessingInterceptor   interceptor    :    this . interceptors )     {", "if    ( deferredResult . isSetOrExpired (  )  )     {", "return   false ;", "}", "if    (  !  ( interceptor . handleError ( request ,    deferredResult ,    ex )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["triggerAfterError"], "fileName": "org.springframework.web.context.request.async.DeferredResultInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "for    ( DeferredResultProcessingInterceptor   interceptor    :    this . interceptors )     {", "if    ( deferredResult . isSetOrExpired (  )  )     {", "return ;", "}", "if    (  !  ( interceptor . handleTimeout ( request ,    deferredResult )  )  )     {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["triggerAfterTimeout"], "fileName": "org.springframework.web.context.request.async.DeferredResultInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.springframework.web.context.request.async.DeferredResultProcessingInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["handleTimeout"], "fileName": "org.springframework.web.context.request.async.DeferredResultProcessingInterceptor"}, {"methodBody": ["METHOD_START", "{", "DeferredResult . DeferredResultHandler   handler    =    mock ( DeferredResult . DeferredResultHandler . class )  ;", "DeferredResult < String >    result    =    new   DeferredResult <  >  (  )  ;", "result . setResultHandler ( handler )  ;", "assertFalse ( result . hasResult (  )  )  ;", "assertNull ( result . getResult (  )  )  ;", "result . setResult (  \" hello \"  )  ;", "assertEquals (  \" hello \"  ,    result . getResult (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasResult"], "fileName": "org.springframework.web.context.request.async.DeferredResultTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult . DeferredResultHandler   handler    =    mock ( DeferredResult . DeferredResultHandler . class )  ;", "DeferredResult < String >    result    =    new   DeferredResult <  >  (  )  ;", "result . setResultHandler ( handler )  ;", "assertFalse ( result . isSetOrExpired (  )  )  ;", "result . setResult (  \" hello \"  )  ;", "assertTrue ( result . isSetOrExpired (  )  )  ;", "verify ( handler )  . handleResult (  \" hello \"  )  ;", "}", "METHOD_END"], "methodName": ["isSetOrExpired"], "fileName": "org.springframework.web.context.request.async.DeferredResultTests"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   sb    =    new   StringBuilder (  )  ;", "< String >    result    =    new    <  >  (  )  ;", "result . onCompletion ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "sb . append (  \" completion   event \"  )  ;", "}", "}  )  ;", "result . getInterceptor (  )  . afterCompletion ( null ,    null )  ;", "assertTrue ( result . isSetOrExpired (  )  )  ;", "assertEquals (  \" completion   event \"  ,    sb . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["onCompletion"], "fileName": "org.springframework.web.context.request.async.DeferredResultTests"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   sb    =    new   StringBuilder (  )  ;", "Handler   handler    =    mockHandler . class )  ;", "< String >    result    =    new <  >  ( null ,     \" error   result \"  )  ;", "result . setResultHandler ( handler )  ;", "Exception   e    =    new   Exception (  )  ;", "result . onError ( new   Consumer < Throwable >  (  )     {", "@ Override", "public   void   accept ( Throwable   t )     {", "sb . append (  \" error   event \"  )  ;", "}", "}  )  ;", "result . getInterceptor (  )  . handleError ( null ,    null ,    e )  ;", "assertEquals (  \" error   event \"  ,    sb . toString (  )  )  ;", "assertFalse (  \" Should   not   be   able   to   set   result   a   second   time \"  ,    result . setResult (  \" hello \"  )  )  ;", "verify ( handler )  . handleResult ( e )  ;", "}", "METHOD_END"], "methodName": ["onError"], "fileName": "org.springframework.web.context.request.async.DeferredResultTests"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   sb    =    new   StringBuilder (  )  ;", "Handler   handler    =    mockHandler . class )  ;", "< String >    result    =    new <  >  ( null ,     \" timeout   result \"  )  ;", "result . setResultHandler ( handler )  ;", "result . onTimeout ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "sb . append (  \" timeout   event \"  )  ;", "}", "}  )  ;", "result . getInterceptor (  )  . handleTimeout ( null ,    null )  ;", "assertEquals (  \" timeout   event \"  ,    sb . toString (  )  )  ;", "assertFalse (  \" Should   not   be   able   to   set   result   a   second   time \"  ,    result . setResult (  \" hello \"  )  )  ;", "verify ( handler )  . handleResult (  \" timeout   result \"  )  ;", "}", "METHOD_END"], "methodName": ["onTimeout"], "fileName": "org.springframework.web.context.request.async.DeferredResultTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult . DeferredResultHandler   handler    =    mock ( DeferredResult . DeferredResultHandler . class )  ;", "DeferredResult < String >    result    =    new   DeferredResult <  >  (  )  ;", "result . setResultHandler ( handler )  ;", "assertTrue ( result . setResult (  \" hello \"  )  )  ;", "verify ( handler )  . handleResult (  \" hello \"  )  ;", "}", "METHOD_END"], "methodName": ["setResult"], "fileName": "org.springframework.web.context.request.async.DeferredResultTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult . DeferredResultHandler   handler    =    mock ( DeferredResult . DeferredResultHandler . class )  ;", "DeferredResult < String >    result    =    new   DeferredResult <  >  (  )  ;", "result . setResultHandler ( handler )  ;", "assertTrue ( result . setResult (  \" hello \"  )  )  ;", "assertFalse ( result . setResult (  \" hi \"  )  )  ;", "verify ( handler )  . handleResult (  \" hello \"  )  ;", "}", "METHOD_END"], "methodName": ["setResultTwice"], "fileName": "org.springframework.web.context.request.async.DeferredResultTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . asyncRequest . isAsyncStarted (  )  )  ;", "this . asyncRequest . startAsync (  )  ;", "assertTrue ( this . asyncRequest . isAsyncStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["isAsyncStarted"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   handler    =    mock ( Runnable . class )  ;", "this . asyncRequest . addCompletionHandler ( handler )  ;", "this . asyncRequest . startAsync (  )  ;", "this . asyncRequest . onComplete ( new   AsyncEvent ( thisgetAsyncContext (  )  )  )  ;", "verify ( handler )  . run (  )  ;", "assertTrue ( this . asyncRequest . isAsyncComplete (  )  )  ;", "}", "METHOD_END"], "methodName": ["onCompletionHandler"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   handler    =    mock ( Runnable . class )  ;", "this . asyncRequest . addCompletionHandler ( handler )  ;", "this . asyncRequest . startAsync (  )  ;", "this . asyncRequest . onComplete ( new   AsyncEvent ( thisgetAsyncContext (  )  )  )  ;", "verify ( handler )  . run (  )  ;", "assertTrue ( this . asyncRequest . isAsyncComplete (  )  )  ;", "}", "METHOD_END"], "methodName": ["onCompletionHandlerAfterOnCompleteEvent"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "Consumer < Throwable >    errorHandler    =    mock ( Consumer . class )  ;", "this . asyncRddErrorHandler ( errorHandler )  ;", "Exception   e    =    new   Exception (  )  ;", "this . asyncRequest . onError ( new   AsyncEvent ( new   MockAsyncContext ( this . request ,    this . response )  ,    e )  )  ;", "verify ( errorHandler )  . accept ( e )  ;", "}", "METHOD_END"], "methodName": ["onErrorHandler"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "Consumer < Throwable >    handler    =    mock ( Consumer . class )  ;", "this . asyncRequest . addErrorHandler ( handler )  ;", "this . asyncRequest . startAsync (  )  ;", "Exception   e    =    new   Exception (  )  ;", "this . asyncRequest . onError ( new   AsyncEvent ( thisgetAsyncContext (  )  ,    e )  )  ;", "verify ( handler )  . accept ( e )  ;", "}", "METHOD_END"], "methodName": ["onErrorHandlerAfterOnErrorEvent"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . asyncRequest . onTimeout ( new   AsyncEvent ( new   MockAsyncContext ( this . request ,    this . response )  )  )  ;", "assertEquals (  2  0  0  ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["onTimeoutDefaultBehavior"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   timeoutHandler    =    mock ( Runnable . class )  ;", "this . asyncRddTimeoutHandler ( timeoutHandler )  ;", "this . asyncRequest . onTimeout ( new   AsyncEvent ( new   MockAsyncContext ( this . request ,    this . response )  )  )  ;", "verify ( timeoutHandler )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["onTimeoutHandler"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . asyncRequest . startAsync (  )  ;", "this . asyncRequest . setTimeout (  2  5 L )  ;", "}", "METHOD_END"], "methodName": ["setTimeoutDuringConcurrentHandling"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . request    =    new   MockHttpServletRequest (  )  ;", "this . request . setAsyncSupported ( true )  ;", "this . response    =    new   MockHttpServletResponse (  )  ;", "this . asyncRequest    =    new    ( this . request ,    this . response )  ;", "this . asyncRequest . setTimeout (  (  4  4     *     1  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . asyncRequest . startAsync (  )  ;", "MockAsyncContext   context    =     (  ( MockAsyncContext )     ( thisgetAsyncContext (  )  )  )  ;", "assertNotNull ( context )  ;", "assertEquals (  \" Timeout   value   not   set \"  ,     (  4  4     *     1  0  0  0  )  ,    context . getTimeout (  )  )  ;", "assertEquals (  1  ,    context . getListeners (  )  . size (  )  )  ;", "assertSame ( this . asyncRequest ,    context . getListeners (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["startAsync"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . asyncRequest . onComplete ( new   AsyncEvent ( new   MockAsyncContext ( this . request ,    this . response )  )  )  ;", "try    {", "this . asyncRequest . startAsync (  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" Async   processing   has   already   completed \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["startAsyncAfterCompleted"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . asyncRequest . startAsync (  )  ;", "this . asyncRequest . startAsync (  )  ;", "this . asyncRequest . startAsync (  )  ;", "this . asyncRequest . startAsync (  )  ;", "MockAsyncContext   context    =     (  ( MockAsyncContext )     ( thisgetAsyncContext (  )  )  )  ;", "assertNotNull ( context )  ;", "assertEquals (  1  ,    context . getListeners (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["startAsyncMultipleTimes"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setAsyncSupported ( false )  ;", "try    {", "this . asyncRequest . startAsync (  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertThat ( ex . getMessage (  )  ,    containsString (  \" Async   support   must   be   enabled \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["startAsyncNotSupported"], "fileName": "org.springframework.web.context.request.async.StandardServletAsyncWebRequestTests"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "this . concurrentResult    =     . RESULT _ NONE ;", "this . concurrentResultContext    =    null ;", "}", "}", "METHOD_END"], "methodName": ["clearConcurrentResult"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "return   this . callableInterceptors . get ( key )  ;", "}", "METHOD_END"], "methodName": ["getCallableInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "return   this . concurrentResult ;", "}", "METHOD_END"], "methodName": ["getConcurrentResult"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "return   this . concurrentResultContext ;", "}", "METHOD_END"], "methodName": ["getConcurrentResultContext"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "return   this . deferredResultInterceptors . get ( key )  ;", "}", "METHOD_END"], "methodName": ["getDeferredResultInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "return    ( this . concurrentResult )     !  =     ( WebAsyncManager . RESULT _ NONE )  ;", "}", "METHOD_END"], "methodName": ["hasConcurrentResult"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . asyncWebRequest )     !  =    null )     &  &     ( this . asyncWebRequest . isAsyncStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["isConcurrentHandlingStarted"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( key ,     \" Key   is   required \"  )  ;", "Assert . notNull ( interceptor ,     \" CallableProcessingInterceptor      is   required \"  )  ;", "this . callableInterceptors . put ( key ,    interceptor )  ;", "}", "METHOD_END"], "methodName": ["registerCallableInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( interceptors ,     \" A   CallableProcessingInterceptor   is   required \"  )  ;", "for    ( CallableProcessingInterceptor   interceptor    :    interceptors )     {", "String   key    =     (  ( interceptor . getClass (  )  . getName (  )  )     +     \"  :  \"  )     +     ( interceptor . hashCode (  )  )  ;", "this . callableInterceptors . put ( key ,    interceptor )  ;", "}", "}", "METHOD_END"], "methodName": ["registerCallableInterceptors"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( key ,     \" Key   is   required \"  )  ;", "Assert . notNull ( interceptor ,     \" DeferredResultProcessingInterceptor   is   required \"  )  ;", "this . deferredResultInterceptors . put ( key ,    interceptor )  ;", "}", "METHOD_END"], "methodName": ["registerDeferredResultInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( interceptors ,     \" A   DeferredResultProcessingInterceptor   is   required \"  )  ;", "for    ( DeferredResultProcessingInterceptor   interceptor    :    interceptors )     {", "String   key    =     (  ( interceptor . getClass (  )  . getName (  )  )     +     \"  :  \"  )     +     ( interceptor . hashCode (  )  )  ;", "this . deferredResultInterceptors . put ( key ,    interceptor )  ;", "}", "}", "METHOD_END"], "methodName": ["registerDeferredResultInterceptors"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( asyncWebRequest ,     \" AsyncWebRequest   must   not   be   null \"  )  ;", "this . asyncWebRequest    =    asyncWebRequest ;", "this . asyncWebRddCompletionHandler (  (  )     -  >    asyncWebRequest . removeAttribute ( WebAsyncUtils . WEB _ ASYNC _ MANAGER _ ATTRIBUTE ,    RequestAttributes . SCOPE _ REQUEST )  )  ;", "}", "METHOD_END"], "methodName": ["setAsyncWebRequest"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  ( this . concurrentResult )     !  =     (  . RESULT _ NONE )  )     {", "return ;", "}", "this . concurrentResult    =    result ;", "}", "if    ( this . asyncWebRequest . isAsyncComplete (  )  )     {", ". logger . error (  \" Could   not   complete   async   processing   due   to   timeout   or   network   error \"  )  ;", "return ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Concurrent   result   value    [  \"     +     ( this . concurrentResult )  )     +     \"  ]     -    dispatching   request   to   resume   processing \"  )  )  ;", "}", "this . asyncWebRequest . dispatch (  )  ;", "}", "METHOD_END"], "methodName": ["setConcurrentResultAndDispatch"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "this . concurrentResult    =     . RESULT _ NONE ;", "this . concurrentResultContext    =    processingContext ;", "}", "this . asyncWebRequest . startAsync (  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", "HttpServletRequest   request    =    this . asyncWebRequest . getNativeRequest ( HttpServletRequest . class )  ;", "if    ( request    !  =    null )     {", "String   requestUri    =     . urlPathHelper . getRequestUri ( request )  ;", ". logger . debug (  (  (  (  (  \" Concurrent   handling   starting   for    \"     +     ( request . getMethod (  )  )  )     +     \"     [  \"  )     +    requestUri )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["startAsyncProcessing"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( callable ,     \" Callable   must   not   be   null \"  )  ;", "startCallableProcessing ( new   Task ( callable )  ,    processingContext )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessing"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( webAsyncTask ,     \" WebAsyncTask   must   not   be   null \"  )  ;", "Assert . state (  (  ( this . asyncWebRequest )     !  =    null )  ,     \" AsyncWebRequest   must   not   be   null \"  )  ;", "Long   timeout    =    webAsyncTask . getTimeout (  )  ;", "if    ( timeout    !  =    null )     {", "this . asyncWebRequest . setTimeout ( timeout )  ;", "}", "AsyncTaskExecutor   executor    =    webAsyncTask . getExecutor (  )  ;", "if    ( executor    !  =    null )     {", "this . taskExecutor    =    executor ;", "}", "List < CallableProcessingInterceptor >    interceptors    =    new   ArrayList <  >  (  )  ;", "interceptors . add ( webAsyncTask . getInterceptor (  )  )  ;", "interceptors . addAll ( this . callableInterceptors . values (  )  )  ;", "interceptors . add (  . timeoutCallableInterceptor )  ;", "final   Callable <  ?  >    callable    =    webAsyncTask . getCallable (  )  ;", "final   CallableInterceptorChain   interceptorChain    =    new   CallableInterceptorChain ( interceptors )  ;", "this . asyncWebRequest . addTimeoutHandler (  (  )     -  >     {", ". logger . debug (  \" Processing   timeout \"  )  ;", "Object   result    =    interceptorChain . triggerAfterTimeout ( this . asyncWebRequest ,    callable )  ;", "if    ( result    !  =     ( CallableProcessingInterceptor . RESULT _ NONE )  )     {", "setConcurrentResultAndDispatch ( result )  ;", "}", "}  )  ;", "this . asyncWebRequest . addErrorHandler (  (    ex )     -  >     {", ". logger . debug (  \" Processing   error \"  )  ;", "Object   result    =    interceptorChain . triggerAfterError ( this . asyncWebRequest ,    callable ,    ex )  ;", "result    =     ( result    !  =     ( CallableProcessingInterceptor . RESULT _ NONE )  )     ?    result    :    ex ;", "setConcurrentResultAndDispatch ( result )  ;", "}  )  ;", "this . asyncWebRequest . addCompletionHandler (  (  )     -  >    interceptorChain . triggerAfterCompletion ( this . asyncWebRequest ,    callable )  )  ;", "interceptorChain . applyBeforeConcurrentHandling ( this . asyncWebRequest ,    callable )  ;", "startAsyncProcessing ( processingContext )  ;", "try    {", "Future <  ?  >    future    =    this . taskExecutor . submit (  (  )     -  >     {", "Object   result    =    null ;", "try    {", "interceptorChain . applyPreProcess ( this . asyncWebRequest ,    callable )  ;", "result    =    callable . call (  )  ;", "}    catch    (    ex )     {", "result    =    ex ;", "}    finally    {", "result    =    interceptorChain . applyPostProcess ( this . asyncWebRequest ,    callable ,    result )  ;", "}", "setConcurrentResultAndDispatch ( result )  ;", "}  )  ;", "interceptorChain . setTaskFuture ( future )  ;", "}    catch    ( RejectedExecutionException   ex )     {", "Object   result    =    interceptorChain . applyPostProcess ( this . asyncWebRequest ,    callable ,    ex )  ;", "setConcurrentResultAndDispatch ( result )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["startCallableProcessing"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( deferredResult ,     \" DeferredResult   must   not   be   null \"  )  ;", "Assert . state (  (  ( this . asyncWebRequest )     !  =    null )  ,     \" AsyncWebRequest   must   not   be   null \"  )  ;", "Long   timeout    =    deferredResult . getTimeoutValue (  )  ;", "if    ( timeout    !  =    null )     {", "this . asyncWebRequest . setTimeout ( timeout )  ;", "}", "List < DeferredResultProcessingInterceptor >    interceptors    =    new   ArrayList <  >  (  )  ;", "interceptors . add ( deferredResult . getInterceptor (  )  )  ;", "interceptors . addAll ( this . deferredResultInterceptors . values (  )  )  ;", "interceptors . add (  . timeoutDeferredResultInterceptor )  ;", "final   DeferredResultInterceptorChain   interceptorChain    =    new   DeferredResultInterceptorChain ( interceptors )  ;", "this . asyncWebRequest . addTimeoutHandler (  (  )     -  >     {", "try    {", "interceptorChain . triggerAfterTimeout ( this . asyncWebRequest ,    deferredResult )  ;", "}    catch    ( Throwable   ex )     {", "setConcurrentResultAndDispatch ( ex )  ;", "}", "}  )  ;", "this . asyncWebRequest . addErrorHandler (  (    ex )     -  >     {", "try    {", "if    (  !  ( interceptorChain . triggerAfterError ( this . asyncWebRequest ,    deferredResult ,    ex )  )  )     {", "return ;", "}", "deferredResult . setErrorResult ( ex )  ;", "}    catch    ( Throwable   interceptorEx )     {", "setConcurrentResultAndDispatch ( interceptorEx )  ;", "}", "}  )  ;", "this . asyncWebRequest . addCompletionHandler (  (  )     -  >    interceptorChain . triggerAfterCompletion ( this . asyncWebRequest ,    deferredResult )  )  ;", "interceptorChain . applyBeforeConcurrentHandling ( this . asyncWebRequest ,    deferredResult )  ;", "startAsyncProcessing ( processingContext )  ;", "try    {", "interceptorChain . applyPreProcess ( this . asyncWebRequest ,    deferredResult )  ;", "deferredResult . setResultHandler (  (    result )     -  >     {", "result    =    interceptorChain . applyPostProcess ( this . asyncWebRequest ,    deferredResult ,    result )  ;", "setConcurrentResultAndDispatch ( result )  ;", "}  )  ;", "}    catch    ( Throwable   ex )     {", "setConcurrentResultAndDispatch ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessing"], "fileName": "org.springframework.web.context.request.async.WebAsyncManager"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / test \"  )  ;", "this . servletRequest . setAsyncSupported ( true )  ;", "this . servletResponse    =    new   MockHttpServletResponse (  )  ;", "this . asyncWebRequest    =    new   StandardServletAsyncWebRequest ( servletRequest ,    servletResponse )  ;", "AsyncTaskExecutor   executor    =    mock ( AsyncTaskExecutor . class )  ;", "this . asyncManager    =    WebAsyncUtils . get ( servletRequest )  ;", "this . asyncManager . setTaskExecutor ( executor )  ;", "this . asyncManager . setAsyncWebRequest ( this . asyncWebRequest )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerErrorTests . StubCallable   callable    =    new   WebAsyncManagerErrorTests . StubCallable (  )  ;", "Exception   exception    =    new   Exception (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "Exception   e    =    new   Exception (  )  ;", "given ( interceptor . handleError ( this . asyncWebRequest ,    callable ,    e )  )  . willThrow ( exception )  ;", "this . asyncManager . registerCallableInterceptor (  \" errorInterceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( callable )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( exception ,    this . asyncManager . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    callable )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingAfterException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerErrorTests . StubCallable   callable    =    new   WebAsyncManagerErrorTests . StubCallable (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "Exception   e    =    new   Exception (  )  ;", "given ( interceptor . handleError ( this . asyncWebRequest ,    callable ,    e )  )  . willReturn ( CallableProcessingInterceptor . RESULT _ NONE )  ;", "this . asyncManager . registerCallableInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( callable )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "this . asyncWebRequest . onComplete ( event )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( e ,    this . asyncManager . getConcurrentResult (  )  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    callable )  ;", "verify ( interceptor )  . afterCompletion ( this . asyncWebRequest ,    callable )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingErrorAndComplete"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerErrorTests . StubCallable   callable    =    new   WebAsyncManagerErrorTests . StubCallable (  )  ;", "WebAsyncTask < Object >    webAsyncTask    =    new   WebAsyncTask <  >  ( callable )  ;", "webAsyncTask . onError ( new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return    7  ;", "}", "}  )  ;", "this . asyncManager . startCallableProcessing ( webAsyncTask )  ;", "Exception   e    =    new   Exception (  )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals (  7  ,    this . asyncManager . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingErrorAndResumeThroughCallback"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerErrorTests . StubCallable   callable    =    new   WebAsyncManagerErrorTests . StubCallable (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "Exception   e    =    new   Exception (  )  ;", "given ( interceptor . handleError ( this . asyncWebRequest ,    callable ,    e )  )  . willReturn (  2  2  )  ;", "this . asyncManager . registerCallableInterceptor (  \" errorInterceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( callable )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals (  2  2  ,    this . asyncManager . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    callable )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingErrorAndResumeThroughInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "final   Exception   exception    =    new   Exception (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    new   DeferredResultProcessingInterceptor (  )     {", "@ Override", "public    < T >    boolean   handleError ( NativeWebRequest   request ,    DeferredResult < T >    result ,    Throwable   t )    throws   Exception    {", "throw   exception ;", "}", "}  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "Exception   e    =    new   Exception (  )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals ( e ,    this . a . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingAfterException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    mock ( DeferredResultProcessingInterceptor . class )  ;", "Exception   e    =    new   Exception (  )  ;", "given ( interceptor . handleError ( this . asyncWebRequest ,    deferredResult ,    e )  )  . willReturn ( true )  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "this . asyncWebRequest . onComplete ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals ( e ,    this . a . getConcurrentResult (  )  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    deferredResult )  ;", "verify ( interceptor )  . preProcess ( this . asyncWebRequest ,    deferredResult )  ;", "verify ( interceptor )  . afterCompletion ( this . asyncWebRequest ,    deferredResult )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingErrorAndComplete"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "final   DeferredResult < Throwable >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "deferredResult . onError ( new   Consumer < Throwable >  (  )     {", "@ Override", "public   void   accept ( Throwable   t )     {", "deferredResult . setResult ( t )  ;", "}", "}  )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "Exception   e    =    new   Exception (  )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals ( e ,    this . a . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingErrorAndResumeThroughCallback"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    new   DeferredResultProcessingInterceptor (  )     {", "@ Override", "public    < T >    boolean   handleError ( NativeWebRequest   request ,    DeferredResult < T >    result ,    Throwable   t )    throws   Exception    {", "result . setErrorResult ( t )  ;", "return   true ;", "}", "}  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "Exception   e    =    new   Exception (  )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals ( e ,    this . a . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingErrorAndResumeThroughInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "Exception   e    =    new   Exception (  )  ;", "DeferredResult < Throwable >    deferredResult    =    new   DeferredResult <  >  ( null ,    e )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "AsyncEvent   event    =    new   AsyncEvent ( new   MockAsyncContext ( this . servletRequest ,    this . servletResponse )  ,    e )  ;", "this . asyncWebRequest . onError ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals ( e ,    this . a . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingErrorAndResumeWithDefaultResult"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerErrorTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . asyncWebRequest . isAsyncStarted (  )  )  . willReturn ( false )  ;", "assertFalse ( this . a . isConcurrentHandlingStarted (  )  )  ;", "reset ( this . asyncWebRequest )  ;", "given ( this . asyncWebRequest . isAsyncStarted (  )  )  . willReturn ( true )  ;", "assertTrue ( this . a . isConcurrentHandlingStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["isConcurrentHandlingStarted"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . asyncWebRequest . startAsync (  )  ;", "this . a . setAsyncWebRequest ( null )  ;", "}", "METHOD_END"], "methodName": ["setAsyncWebRequestAfterAsyncStarted"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest    =    new   MockHttpServletRequest (  )  ;", "this . asyncManager    =    WebAsyncUtils . getAsyncManager ( servletRequest )  ;", "this . asyncManager . setTaskExecutor ( new    . SyncTaskExecutor (  )  )  ;", "this . asyncWebRequest    =    mock ( AsyncWebRequest . class )  ;", "this . asyncManager . setAsyncWebRequest ( this . asyncWebRequest )  ;", "verify ( this . asyncWebRequest )  . addCompletionHandler (  (  ( Runnable )     ( notNull (  )  )  )  )  ;", "reset ( this . asyncWebRequest )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . asyncWebRequest . getNativeRequest ( HttpServletRequest . class )  )  . willReturn ( this . servletRequest )  ;", "given ( this . asyncWebRequest . isAsyncComplete (  )  )  . willReturn ( false )  ;", "}", "METHOD_END"], "methodName": ["setupDefaultAsyncScenario"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManager   manager    =    WebAsyncUtils . getAsyncManager ( new   MockHttpServletRequest (  )  )  ;", "try    {", "manager . startCallableProcessing ( new    . StubCallable (  1  )  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" AsyncWebRequest   must   not   be   null \"  ,    ex . getMessage (  )  )  ;", "}", "try    {", "manager . startDeferredResultProcessing ( new   DeferredResult < String >  (  )  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" AsyncWebRequest   must   not   be   null \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["startAsyncProcessingWithoutAsyncWebRequest"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "int   concurrentResult    =     2  1  ;", "Callable < Object >    task    =    new    . StubCallable ( concurrentResult )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "setupDefaultAsyncScenario (  )  ;", "this . asyncManager . registerCallableInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( task )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( concurrentResult ,    this . asyncManager . getConcurrentResult (  )  )  ;", "verifyDefaultAsyncScenario (  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    task )  ;", "verify ( interceptor )  . preProcess ( this . asyncWebRequest ,    task )  ;", "verify ( interceptor )  . postProcess ( this . asyncWebRequest ,    task ,    new   Integer ( concurrentResult )  )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessing"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "Callable < Object >    task    =    new   WebAsyncManagerTests . StubCallable (  2  1  )  ;", "Exception   exception    =    new   Exception (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "willThrow ( exception )  . given ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    task )  ;", "this . asyncManager . registerCallableInterceptor (  \" interceptor \"  ,    interceptor )  ;", "try    {", "this . asyncManager . startCallableProcessing ( task )  ;", "fail (  \" Expected   Exception \"  )  ;", "}    catch    ( Exception   ex )     {", "assertEquals ( exception ,    ex )  ;", "}", "assertFalse ( this . asyncManager . hasConcurrentResult (  )  )  ;", "verify ( this . asyncWebRequest )  . addTimeoutHandler (  (  ( Runnable )     ( notNull (  )  )  )  )  ;", "verify ( this . asyncWebRequest )  . addErrorHandler (  (  ( Consumer < Throwable >  )     ( notNull (  )  )  )  )  ;", "verify ( this . asyncWebRequest )  . addCompletionHandler (  (  ( Runnable )     ( notNull (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingBeforeConcurrentHandlingException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "Exception   concurrentResult    =    new   Exception (  )  ;", "Callable < Object >    task    =    new    . StubCallable ( concurrentResult )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "setupDefaultAsyncScenario (  )  ;", "this . asyncManager . registerCallableInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( task )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( concurrentResult ,    this . asyncManager . getConcurrentResult (  )  )  ;", "verifyDefaultAsyncScenario (  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    task )  ;", "verify ( interceptor )  . preProcess ( this . asyncWebRequest ,    task )  ;", "verify ( interceptor )  . postProcess ( this . asyncWebRequest ,    task ,    concurrentResult )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingCallableException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . a . startCallableProcessing (  (  ( Callable <  ?  >  )     ( null )  )  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertEquals (  \" Callable   must   not   be   null \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["startCallableProcessingNullInput"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "Callable < Object >    task    =    new   WebAsyncManagerTests . StubCallable (  2  1  )  ;", "Exception   exception    =    new   Exception (  )  ;", "CallableProcessingInterceptor   interceptor 1     =    mock ( CallableProcessingInterceptor . class )  ;", "CallableProcessingInterceptor   interceptor 2     =    mock ( CallableProcessingInterceptor . class )  ;", "willThrow ( exception )  . given ( interceptor 2  )  . postProcess ( this . asyncWebRequest ,    task ,     2  1  )  ;", "setupDefaultAsyncScenario (  )  ;", "this . asyncManager . registerCallableInterceptors ( interceptor 1  ,    interceptor 2  )  ;", "this . asyncManager . startCallableProcessing ( task )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( exception ,    this . asyncManager . getConcurrentResult (  )  )  ;", "verifyDefaultAsyncScenario (  )  ;", "verify ( interceptor 1  )  . beforeConcurrentHandling ( this . asyncWebRequest ,    task )  ;", "verify ( interceptor 1  )  . preProcess ( this . asyncWebRequest ,    task )  ;", "verify ( interceptor 1  )  . postProcess ( this . asyncWebRequest ,    task ,     2  1  )  ;", "verify ( interceptor 2  )  . beforeConcurrentHandling ( this . asyncWebRequest ,    task )  ;", "verify ( interceptor 2  )  . preProcess ( this . asyncWebRequest ,    task )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingPostProcessContinueAfterException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "Callable < Object >    task    =    new   WebAsyncManagerTests . StubCallable (  2  1  )  ;", "Exception   exception    =    new   Exception (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "willThrow ( exception )  . given ( interceptor )  . postProcess ( this . asyncWebRequest ,    task ,     2  1  )  ;", "setupDefaultAsyncScenario (  )  ;", "this . asyncManager . registerCallableInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( task )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( exception ,    this . asyncManager . getConcurrentResult (  )  )  ;", "verifyDefaultAsyncScenario (  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    task )  ;", "verify ( interceptor )  . preProcess ( this . asyncWebRequest ,    task )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingPostProcessException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "Callable < Object >    task    =    new   WebAsyncManagerTests . StubCallable (  2  1  )  ;", "Exception   exception    =    new   Exception (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "willThrow ( exception )  . given ( interceptor )  . preProcess ( this . asyncWebRequest ,    task )  ;", "setupDefaultAsyncScenario (  )  ;", "this . asyncManager . registerCallableInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( task )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( exception ,    this . asyncManager . getConcurrentResult (  )  )  ;", "verifyDefaultAsyncScenario (  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    task )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingPreProcessException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "AsyncTaskExecutor   executor    =    mock ( AsyncTaskExecutor . class )  ;", "given ( this . asyncWebRequest . getNativeRequest ( HttpServletRequest . class )  )  . willReturn ( this . servletRequest )  ;", "WebAsyncTask < Object >    asyncTask    =    new   WebAsyncTask (  1  0  0  0 L ,    executor ,    mock ( Callable . class )  )  ;", "this . a . startCallableProcessing ( asyncTask )  ;", "verify ( executor )  . submit (  (  ( Runnable )     ( notNull (  )  )  )  )  ;", "verify ( this . asyncWebRequest )  . setTimeout (  1  0  0  0 L )  ;", "verify ( this . asyncWebRequest )  . addTimeoutHandler ( any ( Runnable . class )  )  ;", "verify ( this . asyncWebRequest )  . addErrorHandler ( any ( Consumer . class )  )  ;", "verify ( this . asyncWebRequest )  . addCompletionHandler ( any ( Runnable . class )  )  ;", "verify ( this . asyncWebRequest )  . startAsync (  )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingWithAsyncTask"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < String >    deferredResult    =    new   DeferredResult <  >  (  1  0  0  0 L )  ;", "String   concurrentResult    =     \" abc \"  ;", "DeferredResultProcessingInterceptor   interceptor    =    mock ( DeferredResultProcessingInterceptor . class )  ;", "setupDefaultAsyncScenario (  )  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "deferredResult . setResult ( concurrentResult )  ;", "assertEquals ( concurrentResult ,    this . a . getConcurrentResult (  )  )  ;", "verifyDefaultAsyncScenario (  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    deferredResult )  ;", "verify ( interceptor )  . preProcess ( this . asyncWebRequest ,    deferredResult )  ;", "verify ( interceptor )  . postProcess ( asyncWebRequest ,    deferredResult ,    concurrentResult )  ;", "verify ( this . asyncWebRequest )  . setTimeout (  1  0  0  0 L )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessing"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "Exception   exception    =    new   Exception (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    mock ( DeferredResultProcessingInterceptor . class )  ;", "willThrow ( exception )  . given ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    deferredResult )  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "try    {", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "fail (  \" Expected   Exception \"  )  ;", "}    catch    ( Exception   success )     {", "assertEquals ( exception ,    success )  ;", "}", "assertFalse ( this . a . hasConcurrentResult (  )  )  ;", "verify ( this . asyncWebRequest )  . addTimeoutHandler (  (  ( Runnable )     ( notNull (  )  )  )  )  ;", "verify ( this . asyncWebRequest )  . addErrorHandler (  (  ( Consumer < Throwable >  )     ( notNull (  )  )  )  )  ;", "verify ( this . asyncWebRequest )  . addCompletionHandler (  (  ( Runnable )     ( notNull (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingBeforeConcurrentHandlingException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . a . startDeferredResultProcessing (  (  ( DeferredResult <  ?  >  )     ( null )  )  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertEquals (  \" DeferredResult   must   not   be   null \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingNullInput"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "Exception   exception    =    new   Exception (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    mock ( DeferredResultProcessingInterceptor . class )  ;", "willThrow ( exception )  . given ( interceptor )  . postProcess ( this . asyncWebRequest ,    deferredResult ,     2  5  )  ;", "setupDefaultAsyncScenario (  )  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "deferredResult . setResult (  2  5  )  ;", "assertEquals ( exception ,    this . a . getConcurrentResult (  )  )  ;", "verifyDefaultAsyncScenario (  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    deferredResult )  ;", "verify ( interceptor )  . preProcess ( this . asyncWebRequest ,    deferredResult )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingPostProcessException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "Exception   exception    =    new   Exception (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    mock ( DeferredResultProcessingInterceptor . class )  ;", "willThrow ( exception )  . given ( interceptor )  . preProcess ( this . asyncWebRequest ,    deferredResult )  ;", "setupDefaultAsyncScenario (  )  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "deferredResult . setResult (  2  5  )  ;", "assertEquals ( exception ,    this . a . getConcurrentResult (  )  )  ;", "verifyDefaultAsyncScenario (  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    deferredResult )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingPreProcessException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "verify ( this . asyncWebRequest )  . addTimeoutHandler (  (  ( Runnable )     ( notNull (  )  )  )  )  ;", "verify ( this . asyncWebRequest )  . addErrorHandler (  (  ( Consumer < Throwable >  )     ( notNull (  )  )  )  )  ;", "verify ( this . asyncWebRequest )  . addCompletionHandler (  (  ( Runnable )     ( notNull (  )  )  )  )  ;", "verify ( this . asyncWebRequest )  . startAsync (  )  ;", "verify ( this . asyncWebRequest )  . dispatch (  )  ;", "}", "METHOD_END"], "methodName": ["verifyDefaultAsyncScenario"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / test \"  )  ;", "this . servletRequest . setAsyncSupported ( true )  ;", "this . servletResponse    =    new   MockHttpServletResponse (  )  ;", "this . asyncWebRequest    =    new   StandardServletAsyncWebRequest ( servletRequest ,    servletResponse )  ;", "AsyncTaskExecutor   executor    =    mock ( AsyncTaskExecutor . class )  ;", "this . asyncManager    =    WebAsyncUtils . get ( servletRequest )  ;", "this . asyncManager . setTaskExecutor ( executor )  ;", "this . asyncManager . setAsyncWebRequest ( this . asyncWebRequest )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerTimeoutTests . StubCallable   callable    =    new   WebAsyncManagerTimeoutTests . StubCallable (  )  ;", "Exception   exception    =    new   Exception (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "given ( interceptor . handleTimeout ( this . asyncWebRequest ,    callable )  )  . willThrow ( exception )  ;", "this . asyncManager . registerCallableInterceptor (  \" timeoutInterceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( callable )  ;", "this . asyncWebRequest . onTimeout ( WebAsyncManagerTimeoutTests . ASYNC _ EVENT )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( exception ,    this . asyncManager . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    callable )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingAfterTimeoutException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerTimeoutTests . StubCallable   callable    =    new   WebAsyncManagerTimeoutTests . StubCallable (  )  ;", "Future   future    =    mock ( Future . class )  ;", "AsyncTaskExecutor   executor    =    mock ( AsyncTaskExecutor . class )  ;", "when ( executor . submit ( any ( Runnable . class )  )  )  . thenReturn ( future )  ;", "this . asyncManager . setTaskExecutor ( executor )  ;", "this . asyncManager . startCallableProcessing ( callable )  ;", "this . asyncWebRequest . onTimeout ( WebAsyncManagerTimeoutTests . ASYNC _ EVENT )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "verify ( future )  . cancel ( true )  ;", "verifyNoMoreInteractions ( future )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingTimeoutAndCheckThreadInterrupted"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerTimeoutTests . StubCallable   callable    =    new   WebAsyncManagerTimeoutTests . StubCallable (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "given ( interceptor . handleTimeout ( this . asyncWebRequest ,    callable )  )  . willReturn ( CallableProcessingInterceptor . RESULT _ NONE )  ;", "this . asyncManager . registerCallableInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( callable )  ;", "this . asyncWebRequest . onTimeout ( WebAsyncManagerTimeoutTests . ASYNC _ EVENT )  ;", "this . asyncWebRequest . onComplete ( WebAsyncManagerTimeoutTests . ASYNC _ EVENT )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( AsyncRequestTimeoutException . class ,    this . asyncManager . getConcurrentResult (  )  . getClass (  )  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    callable )  ;", "verify ( interceptor )  . afterCompletion ( this . asyncWebRequest ,    callable )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingTimeoutAndComplete"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerTimeoutTests . StubCallable   callable    =    new   WebAsyncManagerTimeoutTests . StubCallable (  )  ;", "WebAsyncTask < Object >    webAsyncTask    =    new   WebAsyncTask <  >  ( callable )  ;", "webAsyncTask . onTimeout ( new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return    7  ;", "}", "}  )  ;", "this . asyncManager . startCallableProcessing ( webAsyncTask )  ;", "this . asyncWebRequest . onTimeout ( WebAsyncManagerTimeoutTests . ASYNC _ EVENT )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals (  7  ,    this . asyncManager . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingTimeoutAndResumeThroughCallback"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManagerTimeoutTests . StubCallable   callable    =    new   WebAsyncManagerTimeoutTests . StubCallable (  )  ;", "CallableProcessingInterceptor   interceptor    =    mock ( CallableProcessingInterceptor . class )  ;", "given ( interceptor . handleTimeout ( this . asyncWebRequest ,    callable )  )  . willReturn (  2  2  )  ;", "this . asyncManager . registerCallableInterceptor (  \" timeoutInterceptor \"  ,    interceptor )  ;", "this . asyncManager . startCallableProcessing ( callable )  ;", "this . asyncWebRequest . onTimeout ( WebAsyncManagerTimeoutTests . ASYNC _ EVENT )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals (  2  2  ,    this . asyncManager . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    callable )  ;", "}", "METHOD_END"], "methodName": ["startCallableProcessingTimeoutAndResumeThroughInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "final   Exception   exception    =    new   Exception (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    new   DeferredResultProcessingInterceptor (  )     {", "@ Override", "public    < T >    boolean   handleTimeout ( NativeWebRequest   request ,    DeferredResult < T >    result )    throws   Exception    {", "throw   exception ;", "}", "}  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "AsyncEvent   event    =    null ;", "this . asyncWebRequest . onTimeout ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals ( exception ,    this . a . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingAfterTimeoutException"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    mock ( DeferredResultProcessingInterceptor . class )  ;", "given ( interceptor . handleTimeout ( this . asyncWebRequest ,    deferredResult )  )  . willReturn ( true )  ;", "this . asyncManager . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . asyncManager . startDeferredResultProcessing ( deferredResult )  ;", "this . asyncWebRequest . onTimeout (  . ASYNC _ EVENT )  ;", "this . asyncWebRequest . onComplete (  . ASYNC _ EVENT )  ;", "assertTrue ( this . asyncManager . hasConcurrentResult (  )  )  ;", "assertEquals ( AsyncRequestTimeoutException . class ,    this . asyncManager . getConcurrentResult (  )  . getClass (  )  )  ;", "verify ( interceptor )  . beforeConcurrentHandling ( this . asyncWebRequest ,    deferredResult )  ;", "verify ( interceptor )  . preProcess ( this . asyncWebRequest ,    deferredResult )  ;", "verify ( interceptor )  . afterCompletion ( this . asyncWebRequest ,    deferredResult )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingTimeoutAndComplete"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "final   DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "deferredResult . onTimeout ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "deferredResult . setResult (  2  3  )  ;", "}", "}  )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "AsyncEvent   event    =    null ;", "this . asyncWebRequest . onTimeout ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals (  2  3  ,    this . a . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingTimeoutAndResumeThroughCallback"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  (  )  ;", "DeferredResultProcessingInterceptor   interceptor    =    new   DeferredResultProcessingInterceptor (  )     {", "@ Override", "public    < T >    boolean   handleTimeout ( NativeWebRequest   request ,    DeferredResult < T >    result )    throws   Exception    {", "result . setErrorResult (  2  3  )  ;", "return   true ;", "}", "}  ;", "this . a . registerDeferredResultInterceptor (  \" interceptor \"  ,    interceptor )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "AsyncEvent   event    =    null ;", "this . asyncWebRequest . onTimeout ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals (  2  3  ,    this . a . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingTimeoutAndResumeThroughInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "DeferredResult < Integer >    deferredResult    =    new   DeferredResult <  >  ( null ,     2  3  )  ;", "this . a . startDeferredResultProcessing ( deferredResult )  ;", "AsyncEvent   event    =    null ;", "this . asyncWebRequest . onTimeout ( event )  ;", "assertTrue ( this . a . hasConcurrentResult (  )  )  ;", "assertEquals (  2  3  ,    this . a . getConcurrentResult (  )  )  ;", "assertEquals (  \"  / test \"  ,     (  ( MockAsyncContext )     ( this . servletRequest . getAsyncContext (  )  )  )  . getDispatchedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["startDeferredResultProcessingTimeoutAndResumeWithDefaultResult"], "fileName": "org.springframework.web.context.request.async.WebAsyncManagerTimeoutTests"}, {"methodBody": ["METHOD_START", "{", "return   this . callable ;", "}", "METHOD_END"], "methodName": ["getCallable"], "fileName": "org.springframework.web.context.request.async.WebAsyncTask"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . executor )     !  =    null )     {", "return   this . executor ;", "} else", "if    (  ( this . executorName )     !  =    null )     {", "util . Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" BeanFactory   is   required   to   look   up   an   executor   bean   by   name \"  )  ;", "return   this . beanFactory . getBean ( this . executorName ,    core . task . AsyncTaskExecutor . class )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getExecutor"], "fileName": "org.springframework.web.context.request.async.WebAsyncTask"}, {"methodBody": ["METHOD_START", "{", "return   new   CallableProcessingInterceptor (  )     {", "@ Override", "public    < T >    Object   handleTimeout ( NativeWebRequest    ,    Callable < T >    task )    throws   Exception    {", "return    ( timeoutCallback )     !  =    null    ?    timeoutCallback . call (  )     :    CallableProcessingInterceptor . RESULT _ NONE ;", "}", "@ Override", "public    < T >    Object   handleError ( NativeWebRequest    ,    Callable < T >    task ,    Throwable   t )    throws   Exception    {", "return    ( errorCallback )     !  =    null    ?    errorCallback . call (  )     :    CallableProcessingInterceptor . RESULT _ NONE ;", "}", "@ Override", "public    < T >    void   afterCompletion ( NativeWebRequest    ,    Callable < T >    task )    throws   Exception    {", "if    (  ( completionCallback )     !  =    null )     {", "completionCallback . run (  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getInterceptor"], "fileName": "org.springframework.web.context.request.async.WebAsyncTask"}, {"methodBody": ["METHOD_START", "{", "return   this . timeout ;", "}", "METHOD_END"], "methodName": ["getTimeout"], "fileName": "org.springframework.web.context.request.async.WebAsyncTask"}, {"methodBody": ["METHOD_START", "{", "this . completionCallback    =    callback ;", "}", "METHOD_END"], "methodName": ["onCompletion"], "fileName": "org.springframework.web.context.request.async.WebAsyncTask"}, {"methodBody": ["METHOD_START", "{", "this . errorCallback    =    callback ;", "}", "METHOD_END"], "methodName": ["onError"], "fileName": "org.springframework.web.context.request.async.WebAsyncTask"}, {"methodBody": ["METHOD_START", "{", "this . timeoutCallback    =    callback ;", "}", "METHOD_END"], "methodName": ["onTimeout"], "fileName": "org.springframework.web.context.request.async.WebAsyncTask"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    beanFactory ;", "}", "METHOD_END"], "methodName": ["setBeanFactory"], "fileName": "org.springframework.web.context.request.async.WebAsyncTask"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardServletAsyncWebRequest ( request ,    response )  ;", "}", "METHOD_END"], "methodName": ["createAsyncWebRequest"], "fileName": "org.springframework.web.context.request.async.WebAsyncUtils"}, {"methodBody": ["METHOD_START", "{", "WebAsyncManager   asyncManager    =    null ;", "Object   asyncManagerAttr    =    servletRequest . getAttribute (  . WEB _ ASYNC _ MANAGER _ ATTRIBUTE )  ;", "if    ( asyncManagerAttr   instanceof   WebAsyncManager )     {", "asyncManager    =     (  ( WebAsyncManager )     ( asyncManagerAttr )  )  ;", "}", "if    ( asyncManager    =  =    null )     {", "asyncManager    =    new   WebAsyncManager (  )  ;", "servletRequest . setAttribute (  . WEB _ ASYNC _ MANAGER _ ATTRIBUTE ,    asyncManager )  ;", "}", "return   asyncManager ;", "}", "METHOD_END"], "methodName": ["getAsyncManager"], "fileName": "org.springframework.web.context.request.async.WebAsyncUtils"}, {"methodBody": ["METHOD_START", "{", "int   scope    =    RequestAttributes . SCOPE _ REQUEST ;", "WebAsyncManager   asyncManager    =    null ;", "Object   asyncManagerAttr    =    webRequest . getAttribute (  . WEB _ ASYNC _ MANAGER _ ATTRIBUTE ,    scope )  ;", "if    ( asyncManagerAttr   instanceof   WebAsyncManager )     {", "asyncManager    =     (  ( WebAsyncManager )     ( asyncManagerAttr )  )  ;", "}", "if    ( asyncManager    =  =    null )     {", "asyncManager    =    new   WebAsyncManager (  )  ;", "webRequest . setAttribute (  . WEB _ ASYNC _ MANAGER _ ATTRIBUTE ,    asyncManager ,    scope )  ;", "}", "return   asyncManager ;", "}", "METHOD_END"], "methodName": ["getAsyncManager"], "fileName": "org.springframework.web.context.request.async.WebAsyncUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotatedBeanDefinitionReader ( beanFactory ,    getEnvironment (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotatedBeanDefinitionReader"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . beanNameGenerator ;", "}", "METHOD_END"], "methodName": ["getBeanNameGenerator"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathBeanDefinitionScanner ( beanFactory ,    true ,    getEnvironment (  )  )  ;", "}", "METHOD_END"], "methodName": ["getClassPathBeanDefinitionScanner"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . scopeMetadataResolver ;", "}", "METHOD_END"], "methodName": ["getScopeMetadataResolver"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( annotatedClasses ,     \" At   least   one   annotated   class   must   be   specified \"  )  ;", "Collections . addAll ( this . annotatedClasses ,    annotatedClasses )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( basePackages ,     \" At   least   one   base   package   must   be   specified \"  )  ;", "Collecs . addAll ( this . basePackages ,    basePackages )  ;", "}", "METHOD_END"], "methodName": ["scan"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . beanNameGenerator    =    beanNameGenerator ;", "}", "METHOD_END"], "methodName": ["setBeanNameGenerator"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . scopeMetadataResolver    =    scopeMetadataResolver ;", "}", "METHOD_END"], "methodName": ["setScopeMetadataResolver"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigWebApplicationContext   ctx    =    new   AnnotationConfigWebApplicationContext (  )  ;", "ctx . setConfigLocation (  \" support \"  )  ;", "ctx . refresh (  )  ;", ". TestBean   bean    =    ctx . getBean (  . TestBean . class )  ;", "assertNotNull ( bean )  ;", "}", "METHOD_END"], "methodName": ["configLocationWithBasePackage"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigWebApplicationContext   ctx    =    new   AnnotationConfigWebApplicationContext (  )  ;", "ctx . setConfigLocation (  . Config . class . getName (  )  )  ;", "ctx . refresh (  )  ;", ". TestBean   bean    =    ctx . getBean (  . TestBean . class )  ;", "assertNotNull ( bean )  ;", "}", "METHOD_END"], "methodName": ["configLocationWithSingleClass"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigWebApplicationContext   ctx    =    new   AnnotationConfigWebApplicationContext (  )  ;", "ctx . register (  . Config . class )  ;", "ctx . refresh (  )  ;", ". TestBean   bean    =    ctx . getBean (  . TestBean . class )  ;", "assertNotNull ( bean )  ;", "}", "METHOD_END"], "methodName": ["registerSingleClass"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigWebApplicationContext   ctx    =    new   AnnotationConfigWebApplicationContext (  )  ;", "ctx . setBeanNameGenerator ( new   AnnotationBeanNameGenerator (  )     {", "@ Override", "public   String   generateBeanName ( BeanDefinition   definition ,    BeanDefinitionRegistry   registry )     {", "return    \" custom -  \"     +     ( super . generateBeanName ( definition ,    registry )  )  ;", "}", "}  )  ;", "ctx . setConfigLocation (  . Config . class . getName (  )  )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" custom - myConfig \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withBeanNameGenerator"], "fileName": "org.springframework.web.context.support.AnnotationConfigWebApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "return   this . webApplicationContext ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.context.support.ContextExposingHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . metaClass ;", "}", "METHOD_END"], "methodName": ["getMetaClass"], "fileName": "org.springframework.web.context.support.GroovyWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    ( containsBean ( property )  )     {", "return   getBean ( property )  ;", "} else", "if    ( thisWrapper . isReadableProperty ( property )  )     {", "return   thisWrapper . getPropertyValue ( property )  ;", "}", "throw   new   NoSuchBeanDefinitionException ( property )  ;", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.springframework.web.context.support.GroovyWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . metaClass . invokeMethod ( this ,    name ,    args )  ;", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.springframework.web.context.support.GroovyWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "String [  ]    configLocations    =    getConfigLocations (  )  ;", "if    ( configLocations    !  =    null )     {", "for    ( String   configLocation    :    configLocations )     {", "reader . loadBeanDefinitions ( configLocation )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.web.context.support.GroovyWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . metaClass    =    metaClass ;", "}", "METHOD_END"], "methodName": ["setMetaClass"], "fileName": "org.springframework.web.context.support.GroovyWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . metaClass . setProperty ( this ,    property ,    newValue )  ;", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.web.context.support.GroovyWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   new   ServletContextLiveBeansView ( getServletContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildLiveBeansView"], "fileName": "org.springframework.web.context.support.LiveBeansViewServlet"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \" session =  [  \"  )  . append ( this . sessionId )  . append (  \"  ]  ;     \"  )  ;", "sb . append (  \" user =  [  \"  )  . append ( this . userName )  . append (  \"  ]  ;     \"  )  ;", "sb . append (  \" time =  [  \"  )  . append ( this . processingTimeMillis )  . append (  \" ms ]  ;     \"  )  ;", "sb . append (  \" status =  [  \"  )  ;", "if    (  !  ( wasFailure (  )  )  )     {", "sb . append (  \" OK \"  )  ;", "} else    {", "sb . append (  \" failed :     \"  )  . append ( this . failureCause )  ;", "}", "sb . append (  '  ]  '  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.springframework.web.context.support.RequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . failureCause ;", "}", "METHOD_END"], "methodName": ["getFailureCause"], "fileName": "org.springframework.web.context.support.RequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . processingTimeMillis ;", "}", "METHOD_END"], "methodName": ["getProcessingTimeMillis"], "fileName": "org.springframework.web.context.support.RequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionId ;", "}", "METHOD_END"], "methodName": ["getSessionId"], "fileName": "org.springframework.web.context.support.RequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \" session =  [  \"  )  . append ( this . sessionId )  . append (  \"  ]  ;     \"  )  ;", "sb . append (  \" user =  [  \"  )  . append ( this . userName )  . append (  \"  ]  ;     \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getShortDescription"], "fileName": "org.springframework.web.context.support.RequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . userName ;", "}", "METHOD_END"], "methodName": ["getUserName"], "fileName": "org.springframework.web.context.support.RequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return    ( this . failureCause )     !  =    null ;", "}", "METHOD_END"], "methodName": ["wasFailure"], "fileName": "org.springframework.web.context.support.RequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Resource . class \"  ,    resource . getFilename (  )  )  ;", "assertTrue ( resource . getURL (  )  . getFile (  )  . endsWith (  \" Resource . class \"  )  )  ;", "Resource   relative 1     =    resource . createRelative (  \" ClassPathResource . class \"  )  ;", "assertEquals (  \" ClassPathResource . class \"  ,    relative 1  . getFilename (  )  )  ;", "assertTrue ( relative 1  . getURL (  )  . getFile (  )  . endsWith (  \" ClassPathResource . class \"  )  )  ;", "assertTrue ( relative 1  . exists (  )  )  ;", "Resource   relative 2     =    resource . createRelative (  \" support / ResourcePatternResolver . class \"  )  ;", "assertEquals (  \" ResourcePatternResolver . class \"  ,    relative 2  . getFilename (  )  )  ;", "assertTrue ( relative 2  . getURL (  )  . getFile (  )  . endsWith (  \" ResourcePatternResolver . class \"  )  )  ;", "assertTrue ( relative 2  . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestResource"], "fileName": "org.springframework.web.context.support.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "Resource   resource    =    new   ServletContextResource ( sc ,     \" org /  / core / io / Resource . class \"  )  ;", "doTestResource ( resource )  ;", "assertEquals ( resource ,    new   ServletContextResource ( sc ,     \" org /  / core /  .  .  / core / io /  .  / Resource . class \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testServletContextResource"], "fileName": "org.springframework.web.context.support.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "resource    =    new   ServletContext ( sc ,     \" dir /  \"  )  ;", "relative    =    resource . createRelative (  \" subdir \"  )  ;", "assertEquals ( new   ServletContext ( sc ,     \" dir / subdir \"  )  ,    relative )  ;", "}", "METHOD_END"], "methodName": ["testServletContextResourceWithRelativePath"], "fileName": "org.springframework.web.context.support.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "this . attributes    =    attributes ;", "}", "METHOD_END"], "methodName": ["setAttributes"], "fileName": "org.springframework.web.context.support.ServletContextAttributeExporter"}, {"methodBody": ["METHOD_START", "{", "this . attributeName    =    attributeName ;", "}", "METHOD_END"], "methodName": ["setAttributeName"], "fileName": "org.springframework.web.context.support.ServletContextAttributeFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . servletConfig ;", "}", "METHOD_END"], "methodName": ["getServletConfig"], "fileName": "org.springframework.web.context.support.ServletContextAwareProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . servletContext )     =  =    null )     &  &     (  ( getServletConfig (  )  )     !  =    null )  )     {", "return   getServletConfig (  )  . get (  )  ;", "}", "return   this . servletContext ;", "}", "METHOD_END"], "methodName": ["getServletContext"], "fileName": "org.springframework.web.context.support.ServletContextAwareProcessor"}, {"methodBody": ["METHOD_START", "{", "this . initParamName    =    initParamName ;", "}", "METHOD_END"], "methodName": ["setInitParamName"], "fileName": "org.springframework.web.context.support.ServletContextParameterFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.springframework.web.context.support.ServletContextResource"}, {"methodBody": ["METHOD_START", "{", "return   this . servletContext ;", "}", "METHOD_END"], "methodName": ["getServletContext"], "fileName": "org.springframework.web.context.support.ServletContextResource"}, {"methodBody": ["METHOD_START", "{", "if    ( ServletContextResourcePatternResolver . logger . isDebugEnabled (  )  )     {", "ServletContextResourcePatternResolver . logger . debug (  (  (  (  (  \" Searching   jar   file    [  \"     +    jarFilePath )     +     \"  ]    for   entries   matching    [  \"  )     +    entryPattern )     +     \"  ]  \"  )  )  ;", "}", "try    {", "JarFile   jarFile    =    new   JarFile ( jarFilePath )  ;", "try    {", "for    ( Enumeration < JarEntry >    entries    =    jarFile . entries (  )  ;    entries . hasMoreElements (  )  ;  )     {", "JarEntry   entry    =    entries . nextElement (  )  ;", "String   entryPath    =    entry . getName (  )  ;", "if    ( getPathMatcher (  )  . match ( entryPattern ,    entryPath )  )     {", "result . add ( new   UrlResource ( ResourceUtils . URL _ PROTOCOL _ JAR ,     (  (  (  ( ResourceUtils . FILE _ URL _ PREFIX )     +    jarFilePath )     +     ( ResourceUtils . JAR _ URL _ SEPARATOR )  )     +    entryPath )  )  )  ;", "}", "}", "}    finally    {", "jarFile . close (  )  ;", "}", "}    catch    ( IOException   ex )     {", "if    ( ServletContextResourcePatternResolver . logger . isWarnEnabled (  )  )     {", "ServletContextResourcePatternResolver . logger . warn (  (  (  \" Cannot   search   for   matching   resources   in   jar   file    [  \"     +    jarFilePath )     +     \"  ]    because   the   jar   cannot   be   opened   through   the   file   system \"  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doRetrieveMatchingJarEntries"], "fileName": "org.springframework.web.context.support.ServletContextResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "Set < String >    candidates    =    servletContext . getResourcePaths ( dir )  ;", "if    ( candidates    !  =    null )     {", "boolean   dirDepthNotFixed    =    fullPattern . contains (  \"  *  *  \"  )  ;", "int   jarFileSep    =    fullPattern . indexOf ( JAR _ URL _ SEPARATOR )  ;", "String   jarFilePath    =    null ;", "String   pathInJarFile    =    null ;", "if    (  ( jarFileSep    >     0  )     &  &     (  ( jarFileSep    +     ( JAR _ URL _ SEPARATOR . length (  )  )  )     <     ( fullPattern . length (  )  )  )  )     {", "jarFilePath    =    fullPattern . substring (  0  ,    jarFileSep )  ;", "pathInJarFile    =    fullPattern . substring (  ( jarFileSep    +     ( JAR _ URL _ SEPARATOR . length (  )  )  )  )  ;", "}", "for    ( String   currPath    :    candidates )     {", "if    (  !  ( currPath . startsWith ( dir )  )  )     {", "int   dirIndex    =    currPath . indexOf ( dir )  ;", "if    ( dirIndex    !  =     (  -  1  )  )     {", "currPath    =    currPath . substring ( dirIndex )  ;", "}", "}", "if    (  ( currPath . endsWith (  \"  /  \"  )  )     &  &     ( dirDepthNotFixed    |  |     (  ( StringUtils . countOccurrencesOf ( currPath ,     \"  /  \"  )  )     <  =     ( StringUtils . countOccurrencesOf ( fullPattern ,     \"  /  \"  )  )  )  )  )     {", "doRetrieveMatchings ( servletContext ,    fullPattern ,    currPath ,    result )  ;", "}", "if    (  ( jarFilePath    !  =    null )     &  &     ( getPathMatcher (  )  . match ( jarFilePath ,    currPath )  )  )     {", "String   absoluteJarPath    =    servletContext . getRealPath ( currPath )  ;", "if    ( absoluteJarPath    !  =    null )     {", "doRetrieveMatchingJarEntries ( absoluteJarPath ,    pathInJarFile ,    result )  ;", "}", "}", "if    ( getPathMatcher (  )  . match ( fullPattern ,    currPath )  )     {", "result . add ( new    ( servletContext ,    currPath )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["doRetrieveMatchingServletContextResources"], "fileName": "org.springframework.web.context.support.ServletContextResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . clientAddress ;", "}", "METHOD_END"], "methodName": ["getClientAddress"], "fileName": "org.springframework.web.context.support.ServletRequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.web.context.support.ServletRequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . requestUrl ;", "}", "METHOD_END"], "methodName": ["getRequestUrl"], "fileName": "org.springframework.web.context.support.ServletRequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . servletName ;", "}", "METHOD_END"], "methodName": ["getServletName"], "fileName": "org.springframework.web.context.support.ServletRequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . statusCode ;", "}", "METHOD_END"], "methodName": ["getStatusCode"], "fileName": "org.springframework.web.context.support.ServletRequestHandledEvent"}, {"methodBody": ["METHOD_START", "{", "XmlWebApplicationContext   ctx    =    new   XmlWebApplicationContext (  )  ;", "ContextLoaderListener   cll    =    new   ContextLoaderListener ( ctx )  ;", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "try    {", "cllInitialized ( new   ServletContextEvent ( sc )  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( Throwable   t )     {", "System . out . println ( t . getMessage (  )  )  ;", "assertTrue ( t . getMessage (  )  . endsWith (  \" Could   not   open   ServletContext   resource    [  / WEB - INF / applicationContext . xml ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["abstractRefreshableWAC_fallsBackToConventionBasedNaming"], "fileName": "org.springframework.web.context.support.Spr8510Tests"}, {"methodBody": ["METHOD_START", "{", "XmlWebApplicationContext   ctx    =    new   XmlWebApplicationContext (  )  ;", "ContextLoaderListener   cll    =    new   ContextLoaderListener ( ctx )  ;", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "sc . addInitParameter ( ContextLoader . CONFIG _ LOCATION _ PARAM ,     \" from - init - param . xml \"  )  ;", "try    {", "cllInitialized ( new   ServletContextEvent ( sc )  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( Throwable   t )     {", "assertTrue ( t . getMessage (  )  . endsWith (  \" Could   not   open   ServletContext   resource    [  / from - init - param . xml ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["abstractRefreshableWAC_fallsBackToInitParam"], "fileName": "org.springframework.web.context.support.Spr8510Tests"}, {"methodBody": ["METHOD_START", "{", "XmlWebApplicationContext   ctx    =    new   XmlWebApplicationContext (  )  ;", "ctx . setConfigLocation (  \" programmatic . xml \"  )  ;", "ContextLoaderListener   cll    =    new   ContextLoaderListener ( ctx )  ;", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "sc . addInitParameter ( ContextLoader . CONFIG _ LOCATION _ PARAM ,     \" from - init - param . xml \"  )  ;", "try    {", "cllInitialized ( new   ServletContextEvent ( sc )  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( Throwable   t )     {", "assertTrue ( t . getMessage (  )  ,    t . getMessage (  )  . endsWith (  \" Could   not   open   ServletContext   resource    [  / from - init - param . xml ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["abstractRefreshableWAC_respectsInitParam_overProgrammaticConfigLocations"], "fileName": "org.springframework.web.context.support.Spr8510Tests"}, {"methodBody": ["METHOD_START", "{", "XmlWebApplicationContext   ctx    =    new   XmlWebApplicationContext (  )  ;", "ctx . setConfigLocation (  \" programmatic . xml \"  )  ;", "ContextLoaderListener   cll    =    new   ContextLoaderListener ( ctx )  ;", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "try    {", "cllInitialized ( new   ServletContextEvent ( sc )  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( Throwable   t )     {", "assertTrue ( t . getMessage (  )  ,    t . getMessage (  )  . endsWith (  \" Could   not   open   ServletContext   resource    [  / programmatic . xml ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["abstractRefreshableWAC_respectsProgrammaticConfigLocations"], "fileName": "org.springframework.web.context.support.Spr8510Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigWebApplicationContext   ctx    =    new   AnnotationConfigWebApplicationContext (  )  ;", "ctx . scan (  \" does . not . matter \"  )  ;", "ContextLoaderListener   cll    =    new   ContextLoaderListener ( ctx )  ;", "cllInitialized ( new   ServletContextEvent ( new   MockServletContext (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["annotationConfigWAC"], "fileName": "org.springframework.web.context.support.Spr8510Tests"}, {"methodBody": ["METHOD_START", "{", "XmlWebApplicationContext   ctx    =    new   XmlWebApplicationContext (  )     {", "@ Override", "protected   String [  ]    getDefaultConfigLocations (  )     {", "return   new   String [  ]  {     \"  / WEB - INF / custom . xml \"     }  ;", "}", "}  ;", "ContextLoaderListener   cll    =    new   ContextLoaderListener ( ctx )  ;", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "sc . addInitParameter ( ContextLoader . CONFIG _ LOCATION _ PARAM ,     \" from - init - param . xml \"  )  ;", "try    {", "cllInitialized ( new   ServletContextEvent ( sc )  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( Throwable   t )     {", "System . out . println ( t . getMessage (  )  )  ;", "assertTrue ( t . getMessage (  )  . endsWith (  \" Could   not   open   ServletContext   resource    [  / from - init - param . xml ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["customAbstractRefreshableWAC_fallsBackToInitParam"], "fileName": "org.springframework.web.context.support.Spr8510Tests"}, {"methodBody": ["METHOD_START", "{", "GenericWebApplicationContext   ctx    =    new   GenericWebApplicationContext (  )  ;", "ContextLoaderListener   cll    =    new   ContextLoaderListener ( ctx )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( ctx )  ;", "scanner . scan (  \" bogus . pkg \"  )  ;", "cllInitialized ( new   ServletContextEvent ( new   MockServletContext (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericWAC"], "fileName": "org.springframework.web.context.support.Spr8510Tests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( target ,     \" Target   object   must   not   be   null \"  )  ;", "WebApplicationContext   cc    =    ContextLoader . getCurrentWebApplicationContext (  )  ;", "if    ( cc    !  =    null )     {", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( cc . getAutowireCapableBeanFactory (  )  )  ;", "bpp . processInjection ( target )  ;", "} else    {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Current   WebApplicationContext   is   not   available   for   processing   of    \"     +     ( ClassUtils . getShortName ( target . getClass (  )  )  )  )     +     \"  :     \"  )     +     \" Make   sure   this   class   gets   constructed   in   a   Spring   web   application .    Proceeding   without   injection .  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processInjectionBasedOnCurrentContext"], "fileName": "org.springframework.web.context.support.SpringBeanAutowiringSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( target ,     \" Target   object   must   not   be   null \"  )  ;", "WebApplicationContext   cc    =    WebApplicationContextUtils . getRequiredWebApplicationContext ( servletContext )  ;", "edAnnotationBeanPostProcessor   bpp    =    new   edAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( cc . geteCapableBeanFactory (  )  )  ;", "bpp . processInjection ( target )  ;", "}", "METHOD_END"], "methodName": ["processInjectionBasedOnServletContext"], "fileName": "org.springframework.web.context.support.SpringBeanAutowiringSupport"}, {"methodBody": ["METHOD_START", "{", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( wac )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" tb \"  )  ;", "wac . registerSingleton (  \" testBean \"  ,    TestBean . class ,    pvs )  ;", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . refresh (  )  ;", "sc . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", ". InjectionTarget   target    =    new    . InjectionTarget (  )  ;", "SpringBeanAutowiringSupport . processInjectionBasedOnServletContext ( target ,    sc )  ;", "assertTrue (  (  ( target . testBean )    instanceof   TestBean )  )  ;", "assertEquals (  \" tb \"  ,    target . name )  ;", "}", "METHOD_END"], "methodName": ["testProcessInjectionBasedOnServletContext"], "fileName": "org.springframework.web.context.support.SpringBeanAutowiringSupportTests"}, {"methodBody": ["METHOD_START", "{", "SimpleNamingContextBuilder . emptyActivatedContextBuilder (  )  ;", "ConfigurableEnvironment   env    =    new    (  )  ;", "MutablePropertySources   sources    =    env . getPropertySources (  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  . SERVLET _ CONFIG _ PROPERTY _ SOURCE _ NAME )  )  ,    equalTo (  0  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  . SERVLET _ CONTEXT _ PROPERTY _ SOURCE _ NAME )  )  ,    equalTo (  1  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  . JNDI _ PROPERTY _ SOURCE _ NAME )  )  ,    equalTo (  2  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named ( SYSTEM _ PROPERTIES _ PROPERTY _ SOURCE _ NAME )  )  ,    equalTo (  3  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named ( SYSTEM _ ENVIRONMENT _ PROPERTY _ SOURCE _ NAME )  )  ,    equalTo (  4  )  )  ;", "assertThat ( sources . size (  )  ,    is (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["propertySourceOrder"], "fileName": "org.springframework.web.context.support.StandardServletEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "RequestAttributes   requestAttr    =    RequestContextHolder . currentRequestAttributes (  )  ;", "if    (  !  ( requestAttr   instanceof   ServletRequestAttributes )  )     {", "throw   new   IllegalStateException (  \" Current   request   is   not   a   servlet   request \"  )  ;", "}", "return    (  ( ServletRequestAttributes )     ( requestAttr )  )  ;", "}", "METHOD_END"], "methodName": ["currentRequestAttributes"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   wac    =    WebApplicationContextUtils . getWebApplicationContext ( sc )  ;", "if    ( wac    =  =    null )     {", "Enumeration < String >    attrNames    =    sc . getAttributeNames (  )  ;", "while    ( attrNames . hasMoreElements (  )  )     {", "String   attrName    =    attrNames . nextElement (  )  ;", "Object   attrValue    =    sc . getAttribute ( attrName )  ;", "if    ( attrValue   instanceof   WebApplicationContext )     {", "if    ( wac    !  =    null )     {", "throw   new   IllegalStateException (  (  \" No   unique   WebApplicationContext   found :    more   than   one    \"     +     \" DispatcherServlet   registered   with   publishContext = true ?  \"  )  )  ;", "}", "wac    =     (  ( WebApplicationContext )     ( attrValue )  )  ;", "}", "}", "}", "return   wac ;", "}", "METHOD_END"], "methodName": ["findWebApplicationContext"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   wac    =    WebApplicationContextUtils . getWebApplicationContext ( sc )  ;", "if    ( wac    =  =    null )     {", "throw   new   IllegalStateException (  \" No   WebApplicationContext   found :    no   ContextLoaderListener   registered ?  \"  )  ;", "}", "return   wac ;", "}", "METHOD_END"], "methodName": ["getRequiredWebApplicationContext"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "return   WebApplicationContextUtils . getWebApplicationContext ( sc ,    WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( sc ,     \" ServletContext   must   not   be   null \"  )  ;", "Object   attr    =    sc . getAttribute ( attrName )  ;", "if    ( attr    =  =    null )     {", "return   null ;", "}", "if    ( attr   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( attr )  )  ;", "}", "if    ( attr   instanceof   Error )     {", "throw    (  ( Error )     ( attr )  )  ;", "}", "if    ( attr   instanceof   Exception )     {", "throw   new   IllegalStateException (  (  ( Exception )     ( attr )  )  )  ;", "}", "if    (  !  ( attr   instanceof    )  )     {", "throw   new   IllegalStateException (  (  \" Context   attribute   is   not   of   type    :     \"     +    attr )  )  ;", "}", "return    (  (  )     ( attr )  )  ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContextUtils . initServletPropertySources ( propertySources ,    servletContext ,    null )  ;", "}", "METHOD_END"], "methodName": ["initServletPropertySources"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( sources ,     \"  ' propertySources '    must   not   be   null \"  )  ;", "String   name    =    StandardServletEnvironment . SERVLET _ CONTEXT _ PROPERTY _ SOURCE _ NAME ;", "if    (  (  ( servlet    !  =    null )     &  &     ( sources . contains ( name )  )  )     &  &     (  ( sources . get ( name )  )    instanceof   StubPropertySource )  )     {", "sources . replace ( name ,    new   ServletPropertySource ( name ,    servlet )  )  ;", "}", "name    =    StandardServletEnvironment . SERVLET _ CONFIG _ PROPERTY _ SOURCE _ NAME ;", "if    (  (  ( servletConfig    !  =    null )     &  &     ( sources . contains ( name )  )  )     &  &     (  ( sources . get ( name )  )    instanceof   StubPropertySource )  )     {", "sources . replace ( name ,    new   ServletConfigPropertySource ( name ,    servletConfig )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initServletPropertySources"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContextUtils . registerEnvironmentBeans ( bf ,    sc ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerEnvironmentBeans"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( servletContext    !  =    null )     &  &     (  !  ( bf . containsBean ( WebApplicationContext . SERVLET _ CONTEXT _ BEAN _ NAME )  )  )  )     {", "bf . registerSingleton ( WebApplicationContext . SERVLET _ CONTEXT _ BEAN _ NAME ,    servletContext )  ;", "}", "if    (  ( servletConfig    !  =    null )     &  &     (  !  ( bf . containsBean ( ConfigurableWebApplicationContext . SERVLET _ CONFIG _ BEAN _ NAME )  )  )  )     {", "bf . registerSingleton ( ConfigurableWebApplicationContext . SERVLET _ CONFIG _ BEAN _ NAME ,    servletConfig )  ;", "}", "if    (  !  ( bf . containsBean ( WebApplicationContext . CONTEXT _ PARAMETERS _ BEAN _ NAME )  )  )     {", "Map < String ,    String >    parameterMap    =    new   HashMap <  >  (  )  ;", "if    ( servletContext    !  =    null )     {", "Enumeration <  ?  >    paramNameEnum    =    servletContext . getInitParameterNames (  )  ;", "while    ( paramNameEnum . hasMoreElements (  )  )     {", "String   paramName    =     (  ( String )     ( paramNameEnum . nextElement (  )  )  )  ;", "parameterMap . put ( paramName ,    servletContext . getInitParameter ( paramName )  )  ;", "}", "}", "if    ( servletConfig    !  =    null )     {", "Enumeration <  ?  >    paramNameEnum    =    servletConfig . getInitParameterNames (  )  ;", "while    ( paramNameEnum . hasMoreElements (  )  )     {", "String   paramName    =     (  ( String )     ( paramNameEnum . nextElement (  )  )  )  ;", "parameterMap . put ( paramName ,    servletConfig . getInitParameter ( paramName )  )  ;", "}", "}", "bf . registerSingleton ( WebApplicationContext . CONTEXT _ PARAMETERS _ BEAN _ NAME ,    Collections . unmodifiableMap ( parameterMap )  )  ;", "}", "if    (  !  ( bf . containsBean ( WebApplicationContext . CONTEXT _ ATTRIBUTES _ BEAN _ NAME )  )  )     {", "Map < String ,    Object >    attributeMap    =    new   HashMap <  >  (  )  ;", "if    ( servletContext    !  =    null )     {", "Enumeration <  ?  >    attrNameEnum    =    servletContext . getAttributeNames (  )  ;", "while    ( attrNameEnum . hasMoreElements (  )  )     {", "String   attrName    =     (  ( String )     ( attrNameEnum . nextElement (  )  )  )  ;", "attributeMap . put ( attrName ,    servletContext . getAttribute ( attrName )  )  ;", "}", "}", "bf . registerSingleton ( WebApplicationContext . CONTEXT _ ATTRIBUTES _ BEAN _ NAME ,    Collections . unmodifiableMap ( attributeMap )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerEnvironmentBeans"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContextUtils . registerWebApplicationScopes ( beanFactory ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerWebApplicationScopes"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerScope ( WebApplicationContext . SCOPE _ REQUEST ,    new   RequestScope (  )  )  ;", "beanFactory . registerScope ( WebApplicationContext . SCOPE _ SESSION ,    new   SessionScope (  )  )  ;", "if    ( sc    !  =    null )     {", "ServletContextScope   appScope    =    new   ServletContextScope ( sc )  ;", "beanFactory . registerScope ( WebApplicationContext . SCOPE _ APPLICATION ,    appScope )  ;", "sc . setAttribute ( ServletContextScope . class . getName (  )  ,    appScope )  ;", "}", "beanFactory . registerResolvableDependency ( ServletRequest . class ,    new    . RequestObjectFactory (  )  )  ;", "beanFactory . registerResolvableDependency ( ServletResponse . class ,    new    . ResponseObjectFactory (  )  )  ;", "beanFactory . registerResolvableDependency ( HttpSession . class ,    new    . SessionObjectFactory (  )  )  ;", "beanFactory . registerResolvableDependency ( WebRequest . class ,    new    . WebRequestObjectFactory (  )  )  ;", "if    (  . jsfPresent )     {", ". FacesDependencyRegistrar . registerFacesDependencies ( beanFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["registerWebApplicationScopes"], "fileName": "org.springframework.web.context.support.WebApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . servletContext )     !  =    null )     {", "return   this . servletContext ;", "}", "ServletContext   servletContext    =    null ;", "WebApplicationContext   wac    =    getWebApplicationContext (  )  ;", "if    ( wac    !  =    null )     {", "servletContext    =    wac . getServletContext (  )  ;", "}", "if    (  ( servletContext    =  =    null )     &  &     ( isContextRequired (  )  )  )     {", "throw   new   IllegalStateException (  (  (  \"    instance    [  \"     +     ( this )  )     +     \"  ]    does   not   run   within   a   ServletContext .    Make   sure   the   object   is   fully   configured !  \"  )  )  ;", "}", "return   servletContext ;", "}", "METHOD_END"], "methodName": ["getServletContext"], "fileName": "org.springframework.web.context.support.WebApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "ServletContext   servletContext    =    getServletContext (  )  ;", "Assert . state (  ( servletContext    !  =    null )  ,     \" ServletContext   is   required \"  )  ;", "return   WebUtils . getTempDir ( servletContext )  ;", "}", "METHOD_END"], "methodName": ["getTempDir"], "fileName": "org.springframework.web.context.support.WebApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    getApplicationContext (  )  ;", "if    ( ctx   instanceof   WebApplicationContext )     {", "return    (  ( WebApplicationContext )     ( getApplicationContext (  )  )  )  ;", "} else", "if    ( isContextRequired (  )  )     {", "throw   new   IllegalStateException (  (  (  (  \"    instance    [  \"     +     ( this )  )     +     \"  ]    does   not   run   in   a   WebApplicationContext   but   in :     \"  )     +    ctx )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.context.support.WebApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "String [  ]    configLocations    =    getConfigLocations (  )  ;", "if    ( configLocations    !  =    null )     {", "for    ( String   configLocation    :    configLocations )     {", "reader . loadBeanDefinitions ( configLocation )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.web.context.support.XmlWebApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . allowedHeaders )     =  =    null )     {", "this . allowedHeaders    =    new   ArrayList <  >  (  4  )  ;", "} else", "if    (  ( this . allowedHeaders )     =  =     (  . DEFAULT _ PERMIT _ ALL )  )     {", "setAllowedHeaders (  . DEFAULT _ PERMIT _ ALL )  ;", "}", "this . allowedHeaders . add ( allowedHeader )  ;", "}", "METHOD_END"], "methodName": ["addAllowedHeader"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( method )  )     {", "if    (  ( this . allowedMethods )     =  =    null )     {", "this . allowedMethods    =    new   ArrayList <  >  (  4  )  ;", "this . resolvedMethods    =    new   ArrayList <  >  (  4  )  ;", "} else", "if    (  ( this . allowedMethods )     =  =     (  . DEFAULT _ PERMIT _ METHODS )  )     {", "setAllowedMethods (  . DEFAULT _ PERMIT _ METHODS )  ;", "}", "this . allowedMethods . add ( method )  ;", "if    (  . ALL . equals ( method )  )     {", "this . resolvedMethods    =    null ;", "} else", "if    (  ( this . resolvedMethods )     !  =    null )     {", "this . resolvedMethods . add ( HttpMethod . resolve ( method )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addAllowedMethod"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "addAllowedMethod ( method . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["addAllowedMethod"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . allowedOrigins )     =  =    null )     {", "this . allowedOrigins    =    new   ArrayList <  >  (  4  )  ;", "} else", "if    (  ( this . allowedOrigins )     =  =     (  . DEFAULT _ PERMIT _ ALL )  )     {", "setAllowedOrigins (  . DEFAULT _ PERMIT _ ALL )  ;", "}", "this . allowedOrigins . add ( origin )  ;", "}", "METHOD_END"], "methodName": ["addAllowedOrigin"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( CorsConfiguration . ALL . equals ( exposedHeader )  )     {", "throw   new   IllegalArgumentException (  \"  '  *  '    is   not   a   valid   exposed   header   value \"  )  ;", "}", "if    (  ( this . exposedHeaders )     =  =    null )     {", "this . exposedHeaders    =    new   ArrayList <  >  (  4  )  ;", "}", "this . exposedHeaders . add ( exposedHeader )  ;", "}", "METHOD_END"], "methodName": ["addExposedHeader"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . allowedOrigins )     =  =    null )     {", "this . allowedOrigins    =     . DEFAULT _ PERMIT _ ALL ;", "}", "if    (  ( this . allowedMethods )     =  =    null )     {", "this . allowedMethods    =     . DEFAULT _ PERMIT _ METHODS ;", "this . resolvedMethods    =     . DEFAULT _ PERMIT _ METHODS . stream (  )  . map ( HttpMethod :  : resolve )  . collect ( Collectors . toList (  )  )  ;", "}", "if    (  ( this . allowedHeaders )     =  =    null )     {", "this . allowedHeaders    =     . DEFAULT _ PERMIT _ ALL ;", "}", "if    (  ( this . maxAge )     =  =    null )     {", "this . maxAge    =     1  8  0  0 L ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["applyPermitDefaultValues"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( requestHeaders    =  =    null )     {", "return   null ;", "}", "if    ( requestHeaders . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "}", "if    ( ObjectUtils . isEmpty ( this . allowedHeaders )  )     {", "return   null ;", "}", "boolean   allowAnyHeader    =    this . allowedHeaders . contains (  . ALL )  ;", "List < String >    result    =    new   ArrayList <  >  ( requestHeaders . size (  )  )  ;", "for    ( String   requestHeader    :    requestHeaders )     {", "if    ( StringUtils . hasText ( requestHeader )  )     {", "requestHeader    =    requestHeader . trim (  )  ;", "if    ( allowAnyHeader )     {", "result . add ( requestHeader )  ;", "} else    {", "for    ( String   allowedHeader    :    this . allowedHeaders )     {", "if    ( requestHeader . equalsIgnoreCase ( allowedHeader )  )     {", "result . add ( requestHeader )  ;", "break ;", "}", "}", "}", "}", "}", "return   result . isEmpty (  )     ?    null    :    result ;", "}", "METHOD_END"], "methodName": ["checkHeaders"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( requestMethod    =  =    null )     {", "return   null ;", "}", "if    (  ( this . resolvedMethods )     =  =    null )     {", "return   Collecs . singletonList ( requestMethod )  ;", "}", "return   this . resolvedMethods . contains ( requestMethod )     ?    this . resolvedMethods    :    null ;", "}", "METHOD_END"], "methodName": ["checkHttpMethod"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasText ( requestOrigin )  )  )     {", "return   null ;", "}", "if    ( ObjectUtils . isEmpty ( this . allowedOrigins )  )     {", "return   null ;", "}", "if    ( this . allowedOrigins . contains (  . ALL )  )     {", "if    (  ( this . allowCredentials )     !  =     ( Boolean . TRUE )  )     {", "return    . ALL ;", "} else    {", "return   requestOrigin ;", "}", "}", "for    ( String   allowedOrigin    :    this . allowedOrigins )     {", "if    ( requestOrigin . equalsIgnoreCase ( allowedOrigin )  )     {", "return   requestOrigin ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["checkOrigin"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( other    =  =    null )     {", "return   source    !  =    null    ?    source    :    Collections . emptyList (  )  ;", "}", "if    ( source    =  =    null )     {", "return   other ;", "}", "if    (  ( source    =  =     (  . DEFAULT _ PERMIT _ ALL )  )     |  |     ( source    =  =     (  . DEFAULT _ PERMIT _ METHODS )  )  )     {", "return   other ;", "}", "if    (  ( other    =  =     (  . DEFAULT _ PERMIT _ ALL )  )     |  |     ( other    =  =     (  . DEFAULT _ PERMIT _ METHODS )  )  )     {", "return   source ;", "}", "if    (  ( source . contains (  . ALL )  )     |  |     ( other . contains (  . ALL )  )  )     {", "return   new   ArrayList <  >  ( Collections . singletonList (  . ALL )  )  ;", "}", "Set < String >    combined    =    new   LinkedHashSet <  >  ( source )  ;", "combined . addAll ( other )  ;", "return   new   ArrayList <  >  ( combined )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( other    =  =    null )     {", "return   this ;", "}", "config    =    new    ( this )  ;", "config . setAllowedOrigins ( combine ( getAllowedOrigins (  )  ,    other . getAllowedOrigins (  )  )  )  ;", "config . setAllowedMethods ( combine ( getAllowedMethods (  )  ,    other . getAllowedMethods (  )  )  )  ;", "config . setAllowedHeaders ( combine ( getAllowedHeaders (  )  ,    other . getAllowedHeaders (  )  )  )  ;", "config . setExposedHeaders ( combine ( getExposedHeaders (  )  ,    other . getExposedHeaders (  )  )  )  ;", "Boolean   allowCredentials    =    other . getAllowCredentials (  )  ;", "if    ( allowCredentials    !  =    null )     {", "config . setAllowCredentials ( allowCredentials )  ;", "}", "Long   maxAge    =    other . getMaxAge (  )  ;", "if    ( maxAge    !  =    null )     {", "config . setMaxAge ( maxAge )  ;", "}", "return   config ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . allowCredentials ;", "}", "METHOD_END"], "methodName": ["getAllowCredentials"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . allowedHeaders ;", "}", "METHOD_END"], "methodName": ["getAllowedHeaders"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . allowedMethods ;", "}", "METHOD_END"], "methodName": ["getAllowedMethods"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . allowedOrigins ;", "}", "METHOD_END"], "methodName": ["getAllowedOrigins"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . exposedHeaders ;", "}", "METHOD_END"], "methodName": ["getExposedHeaders"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . maxAge ;", "}", "METHOD_END"], "methodName": ["getMaxAge"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . allowCredentials    =    allowCredentials ;", "}", "METHOD_END"], "methodName": ["setAllowCredentials"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . allowedHeaders    =     ( allowedHeaders    !  =    null )     ?    new   ArrayList <  >  ( allowedHeaders )     :    null ;", "}", "METHOD_END"], "methodName": ["setAllowedHeaders"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . allowedMethods    =     ( allowedMethods    !  =    null )     ?    new   ArrayList <  >  ( allowedMethods )     :    null ;", "if    (  !  ( CollectionUtils . isEmpty ( allowedMethods )  )  )     {", "this . resolvedMethods    =    new   ArrayList <  >  ( allowedMethods . size (  )  )  ;", "for    ( String   method    :    allowedMethods )     {", "if    (  . ALL . equals ( method )  )     {", "this . resolvedMethods    =    null ;", "break ;", "}", "this . resolvedMethods . add ( HttpMethod . resolve ( method )  )  ;", "}", "} else    {", "this . resolvedMethods    =     . DEFAULT _ METHODS ;", "}", "}", "METHOD_END"], "methodName": ["setAllowedMethods"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . allowedOrigins    =     ( allowedOrigins    !  =    null )     ?    new   ArrayList <  >  ( allowedOrigins )     :    null ;", "}", "METHOD_END"], "methodName": ["setAllowedOrigins"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( exposedHeaders    !  =    null )     &  &     ( exposedHeaders . contains ( CorsConfiguration . ALL )  )  )     {", "throw   new   IllegalArgumentException (  \"  '  *  '    is   not   a   valid   exposed   header   value \"  )  ;", "}", "this . exposedHeaders    =     ( exposedHeaders    !  =    null )     ?    new   ArrayList <  >  ( exposedHeaders )     :    null ;", "}", "METHOD_END"], "methodName": ["setExposedHeaders"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . maxAge    =    maxAge ;", "}", "METHOD_END"], "methodName": ["setMaxAge"], "fileName": "org.springframework.web.cors.CorsConfiguration"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . addExposedHeader (  \"  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["asteriskWildCardOnAddExposedHeader"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . setExposedHeaders ( Arrays . asList (  \"  *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asteriskWildCardOnSetExposedHeaders"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  . applyPermitDefaultValues (  )  ;", "config . addAllowedOrigin (  \" http :  /  / domain . com \"  )  ;", "config . addAllowedHeader (  \" header 1  \"  )  ;", "config . addAllowedMethod (  \" PATCH \"  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  ,     \" http :  /  / domain . com \"  )  ,    config . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  ,     \" header 1  \"  )  ,    config . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList (  \" GET \"  ,     \" HEAD \"  ,     \" POST \"  ,     \" PATCH \"  )  ,    config . getAllowedMethods (  )  )  ;", "}", "METHOD_END"], "methodName": ["changePermitDefaultValues"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "assertEquals ( Collections . emptyList (  )  ,    config . checkHeaders ( Collections . emptyList (  )  )  )  ;", "config . addAllowedHeader (  \" header 1  \"  )  ;", "config . addAllowedHeader (  \" header 2  \"  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  )  ,    config . checkHeaders ( Arrays . asList (  \" header 1  \"  )  )  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  ,    config . checkHeaders ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  ,    config . checkHeaders ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  ,     \" header 3  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkHeadersAllowed"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "assertNull ( config . checkHeaders ( null )  )  ;", "assertNull ( config . checkHeaders ( Arrays . asList (  \" header 1  \"  )  )  )  ;", "config . setAllowedHeaders ( Collections . emptyList (  )  )  ;", "assertNull ( config . checkHeaders ( Arrays . asList (  \" header 1  \"  )  )  )  ;", "config . addAllowedHeader (  \" header 2  \"  )  ;", "config . addAllowedHeader (  \" header 3  \"  )  ;", "assertNull ( config . checkHeaders ( Arrays . asList (  \" header 1  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkHeadersNotAllowed"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET ,    HttpMethod . HEAD )  ,    config . checkHttpMethod ( HttpMethod . GET )  )  ;", "config . addAllowedMethod (  \" GET \"  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET )  ,    config . checkHttpMethod ( HttpMethod . GET )  )  ;", "config . addAllowedMethod (  \" POST \"  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET ,    HttpMethod . POST )  ,    config . checkHttpMethod ( HttpMethod . GET )  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET ,    HttpMethod . POST )  ,    config . checkHttpMethod ( HttpMethod . POST )  )  ;", "}", "METHOD_END"], "methodName": ["checkMethodAllowed"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "assertNull ( config . checkHttpMethod ( null )  )  ;", "assertNull ( config . checkHttpMethod ( HttpMethod . DELETE )  )  ;", "config . setAllowedMethods ( new   ArrayList <  >  (  )  )  ;", "assertNull ( config . checkHttpMethod ( HttpMethod . POST )  )  ;", "}", "METHOD_END"], "methodName": ["checkMethodNotAllowed"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . setAllowedOrigins ( Arrays . asList (  \"  *  \"  )  )  ;", "assertEquals (  \"  *  \"  ,    config . checkOrigin (  \" http :  /  / domain . com \"  )  )  ;", "config . setAllowCredentials ( true )  ;", "assertEquals (  \" http :  /  / domain . com \"  ,    config . checkOrigin (  \" http :  /  / domain . com \"  )  )  ;", "config . setAllowedOrigins ( Arrays . asList (  \" http :  /  / domain . com \"  )  )  ;", "assertEquals (  \" http :  /  / domain . com \"  ,    config . checkOrigin (  \" http :  /  / domain . com \"  )  )  ;", "config . setAllowCredentials ( false )  ;", "assertEquals (  \" http :  /  / domain . com \"  ,    config . checkOrigin (  \" http :  /  / domain . com \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkOriginAllowed"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "assertNull ( config . checkOrigin ( null )  )  ;", "assertNull ( config . checkOrigin (  \" http :  /  / domain . com \"  )  )  ;", "config . addAllowedOrigin (  \"  *  \"  )  ;", "assertNull ( config . checkOrigin ( null )  )  ;", "config . setAllowedOrigins ( Arrays . asList (  \" http :  /  / domain 1  . com \"  )  )  ;", "assertNull ( config . checkOrigin (  \" http :  /  / domain 2  . com \"  )  )  ;", "config . setAllowedOrigins ( new   ArrayList <  >  (  )  )  ;", "assertNull ( config . checkOrigin (  \" http :  /  / domain . com \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkOriginNotAllowed"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "config . addAllowedHeader (  \" header 1  \"  )  ;", "config . addExposedHeader (  \" header 3  \"  )  ;", "config . addAllowedMethod ( HttpMethod . GET . name (  )  )  ;", "config . setMaxAge (  1  2  3 L )  ;", "config . setAllowCredentials ( true )  ;", "CorsConfiguration   other    =    new   CorsConfiguration (  )  ;", "other . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "other . addAllowedHeader (  \" header 2  \"  )  ;", "other . addExposedHeader (  \" header 4  \"  )  ;", "other . addAllowedMethod ( HttpMethod . PUT . name (  )  )  ;", "other . setMaxAge (  4  5  6 L )  ;", "other . setAllowCredentials ( false )  ;", "config    =    config . combine ( other )  ;", "assertEquals ( Arrays . asList (  \" http :  /  / domain 1  . com \"  ,     \" http :  /  / domain 2  . com \"  )  ,    config . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  ,    config . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 3  \"  ,     \" header 4  \"  )  ,    config . getExposedHeaders (  )  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET . name (  )  ,    HttpMethod . PUT . name (  )  )  ,    config . getAllowedMethods (  )  )  ;", "assertEquals ( new   Long (  4  5  6  )  ,    config . getMaxAge (  )  )  ;", "assertFalse ( config . getAllowCredentials (  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . addAllowedOrigin (  \"  *  \"  )  ;", "config . addAllowedHeader (  \"  *  \"  )  ;", "config . addAllowedMethod (  \"  *  \"  )  ;", "CorsConfiguration   other    =    new   CorsConfiguration (  )  ;", "other . addAllowedOrigin (  \" http :  /  / domain . com \"  )  ;", "other . addAllowedHeader (  \" header 1  \"  )  ;", "other . addExposedHeader (  \" header 2  \"  )  ;", "other . addAllowedMethod ( HttpMethod . PUT . name (  )  )  ;", "CorsConfiguration   combinedConfig    =    config . combine ( other )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    combinedConfig . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    combinedConfig . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    combinedConfig . getAllowedMethods (  )  )  ;", "combinedConfig    =    other . combine ( config )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    combinedConfig . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    combinedConfig . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    combinedConfig . getAllowedMethods (  )  )  ;", "}", "METHOD_END"], "methodName": ["combineWithAsteriskWildCard"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  . applyPermitDefaultValues (  )  ;", "CorsConfiguration   other    =    new   CorsConfiguration (  )  ;", "other . addAllowedOrigin (  \" http :  /  / domain . com \"  )  ;", "other . addAllowedHeader (  \" header 1  \"  )  ;", "other . addAllowedMethod ( HttpMethod . PUT . name (  )  )  ;", "CorsConfiguration   combinedConfig    =    config . combine ( other )  ;", "assertEquals ( Arrays . asList (  \" http :  /  / domain . com \"  )  ,    combinedConfig . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  )  ,    combinedConfig . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . PUT . name (  )  )  ,    combinedConfig . getAllowedMethods (  )  )  ;", "combinedConfig    =    other . combine ( config )  ;", "assertEquals ( Arrays . asList (  \" http :  /  / domain . com \"  )  ,    combinedConfig . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  )  ,    combinedConfig . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . PUT . name (  )  )  ,    combinedConfig . getAllowedMethods (  )  )  ;", "combinedConfig    =    config . combine ( new   CorsConfiguration (  )  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET . name (  )  ,    HttpMethod . HEAD . name (  )  ,    HttpMethod . POST . name (  )  )  ,    combinedConfig . getAllowedMethods (  )  )  ;", "combinedConfig    =    new   CorsConfiguration (  )  . combine ( config )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET . name (  )  ,    HttpMethod . HEAD . name (  )  ,    HttpMethod . POST . name (  )  )  ,    combinedConfig . getAllowedMethods (  )  )  ;", "}", "METHOD_END"], "methodName": ["combineWithDefaultPermitValues"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "config . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "config . addAllowedHeader (  \" header 1  \"  )  ;", "config . addAllowedHeader (  \" header 2  \"  )  ;", "config . addExposedHeader (  \" header 3  \"  )  ;", "config . addExposedHeader (  \" header 4  \"  )  ;", "config . addAllowedMethod ( HttpMethod . GET . name (  )  )  ;", "config . addAllowedMethod ( HttpMethod . PUT . name (  )  )  ;", "CorsConfiguration   other    =    new   CorsConfiguration (  )  ;", "other . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "other . addAllowedHeader (  \" header 1  \"  )  ;", "other . addExposedHeader (  \" header 3  \"  )  ;", "other . addAllowedMethod ( HttpMethod . GET . name (  )  )  ;", "CorsConfiguration   combinedConfig    =    config . combine ( other )  ;", "assertEquals ( Arrays . asList (  \" http :  /  / domain 1  . com \"  ,     \" http :  /  / domain 2  . com \"  )  ,    combinedConfig . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  ,    combinedConfig . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 3  \"  ,     \" header 4  \"  )  ,    combinedConfig . getExposedHeaders (  )  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET . name (  )  ,    HttpMethod . PUT . name (  )  )  ,    combinedConfig . getAllowedMethods (  )  )  ;", "}", "METHOD_END"], "methodName": ["combineWithDuplicatedElements"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . setAllowedOrigins ( Arrays . asList (  \"  *  \"  )  )  ;", "config . combine ( null )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedOrigins (  )  )  ;", "}", "METHOD_END"], "methodName": ["combineWithNull"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . addAllowedOrigin (  \"  *  \"  )  ;", "config . addAllowedHeader (  \" header 1  \"  )  ;", "config . addExposedHeader (  \" header 3  \"  )  ;", "config . addAllowedMethod ( HttpMethod . GET . name (  )  )  ;", "config . setMaxAge (  1  2  3 L )  ;", "config . setAllowCredentials ( true )  ;", "CorsConfiguration   other    =    new   CorsConfiguration (  )  ;", "config    =    config . combine ( other )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  )  ,    config . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 3  \"  )  ,    config . getExposedHeaders (  )  )  ;", "assertEquals ( Arrays . asList ( HttpMethod . GET . name (  )  )  ,    config . getAllowedMethods (  )  )  ;", "assertEquals ( new   Long (  1  2  3  )  ,    config . getMaxAge (  )  )  ;", "assertTrue ( config . getAllowCredentials (  )  )  ;", "}", "METHOD_END"], "methodName": ["combineWithNullProperties"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . setAllowedOrigins ( null )  ;", "assertNull ( config . getAllowedOrigins (  )  )  ;", "config . setAllowedHeaders ( null )  ;", "assertNull ( config . getAllowedHeaders (  )  )  ;", "config . setAllowedMethods ( null )  ;", "assertNull ( config . getAllowedMethods (  )  )  ;", "config . setExposedHeaders ( null )  ;", "assertNull ( config . getExposedHeaders (  )  )  ;", "config . setAllowCredentials ( null )  ;", "assertNull ( config . getAllowCredentials (  )  )  ;", "config . setMaxAge ( null )  ;", "assertNull ( config . getMaxAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["setNullValues"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "config . addAllowedOrigin (  \"  *  \"  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedOrigins (  )  )  ;", "config . addAllowedHeader (  \"  *  \"  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedHeaders (  )  )  ;", "config . addAllowedMethod (  \"  *  \"  )  ;", "assertEquals ( Arrays . asList (  \"  *  \"  )  ,    config . getAllowedMethods (  )  )  ;", "config . addExposedHeader (  \" header 1  \"  )  ;", "config . addExposedHeader (  \" header 2  \"  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  ,    config . getExposedHeaders (  )  )  ;", "config . setAllowCredentials ( true )  ;", "assertTrue ( config . getAllowCredentials (  )  )  ;", "config . setMaxAge (  1  2  3 L )  ;", "assertEquals ( new   Long (  1  2  3  )  ,    config . getMaxAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "org.springframework.web.cors.CorsConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "return    ( request . getHeader ( HttpHeaders . ORIGIN )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isCorsRequest"], "fileName": "org.springframework.web.cors.CorsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( CorsUtils . isCorsRequest ( request )  )     &  &     ( HttpMethod . OPTIONS . matches ( request . getMethod (  )  )  )  )     &  &     (  ( request . getHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isPreFlightRequest"], "fileName": "org.springframework.web.cors.CorsUtils"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain . com \"  )  ;", "assertTrue (  . isCorsRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isCorsRequest"], "fileName": "org.springframework.web.cors.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "assertFalse (  . isCorsRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isNotCorsRequest"], "fileName": "org.springframework.web.cors.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "assertFalse (  . isPreFlightRequest ( request )  )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain . com \"  )  ;", "assertFalse (  . isPreFlightRequest ( request )  )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "assertFalse (  . isPreFlightRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isNotPreFlightRequest"], "fileName": "org.springframework.web.cors.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain . com \"  )  ;", "request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "assertTrue (  . isPreFlightRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isPreFlightRequest"], "fileName": "org.springframework.web.cors.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   config . checkHeaders ( requestHeaders )  ;", "}", "METHOD_END"], "methodName": ["checkHeaders"], "fileName": "org.springframework.web.cors.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   config . checkHttpMethod ( requestMethod )  ;", "}", "METHOD_END"], "methodName": ["checkMethods"], "fileName": "org.springframework.web.cors.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   config . checkOrigin ( requestOrigin )  ;", "}", "METHOD_END"], "methodName": ["checkOrigin"], "fileName": "org.springframework.web.cors.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "return   isPreFlight    ?    headers . getAcControlRequestHeaders (  )     :    new   ArrayList <  >  ( headers . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHeadersToUse"], "fileName": "org.springframework.web.cors.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   isPreFlight    ?    request . getHeaders (  )  . getAccessControlRequestMethod (  )     :    request . getMethod (  )  ;", "}", "METHOD_END"], "methodName": ["getMethodToUse"], "fileName": "org.springframework.web.cors.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "String   requestOrigin    =    request . getHeaders (  )  . getOrigin (  )  ;", "String   allowOrigin    =    checkOrigin ( config ,    requestOrigin )  ;", "HttpHeaders   responseHeaders    =    response . getHeaders (  )  ;", "responseHeaders . addAll ( HttpHeaders . VARY ,    Arrays . asList ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "if    ( allowOrigin    =  =    null )     {", ". logger . debug (  (  (  \" Rejecting   CORS   request   because    '  \"     +    requestOrigin )     +     \"  '    origin   is   not   allowed \"  )  )  ;", "rejectRequest ( response )  ;", "return   false ;", "}", "HttpMethod   requestMethod    =    getMethodToUse ( request ,    preFlightRequest )  ;", "List < HttpMethod >    allowMethods    =    checkMethods ( config ,    requestMethod )  ;", "if    ( allowMethods    =  =    null )     {", ". logger . debug (  (  (  \" Rejecting   CORS   request   because    '  \"     +    requestMethod )     +     \"  '    request   method   is   not   allowed \"  )  )  ;", "rejectRequest ( response )  ;", "return   false ;", "}", "List < String >    requestHeaders    =    getHeadersToUse ( request ,    preFlightRequest )  ;", "List < String >    allowHeaders    =    checkHeaders ( config ,    requestHeaders )  ;", "if    ( preFlightRequest    &  &     ( allowHeaders    =  =    null )  )     {", ". logger . debug (  (  (  \" Rejecting   CORS   request   because    '  \"     +    requestHeaders )     +     \"  '    request   headers   are   not   allowed \"  )  )  ;", "rejectRequest ( response )  ;", "return   false ;", "}", "responseHeaders . setAccessControlAllowOrigin ( allowOrigin )  ;", "if    ( preFlightRequest )     {", "responseHeaders . setAccessControlAllowMethods ( allowMethods )  ;", "}", "if    ( preFlightRequest    &  &     (  !  ( allowHeaders . isEmpty (  )  )  )  )     {", "responseHeaders . setAccessControlAllowHeaders ( allowHeaders )  ;", "}", "if    (  !  ( CollectionUtils . isEmpty ( config . getExposedHeaders (  )  )  )  )     {", "responseHeaders . setAccessControlExposeHeaders ( config . getExposedHeaders (  )  )  ;", "}", "if    ( Boolean . TRUE . equals ( config . getAllowCredentials (  )  )  )     {", "responseHeaders . setAccessControlAllowCredentials ( true )  ;", "}", "if    ( preFlightRequest    &  &     (  ( config . getMaxAge (  )  )     !  =    null )  )     {", "responseHeaders . setAccessControlMaxAge ( config . getMaxAge (  )  )  ;", "}", "response . flush (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["handleInternal"], "fileName": "org.springframework.web.cors.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "response . setStatusCode ( HttpStatus . FORBIDDEN )  ;", "response . getBody (  )  . write (  \" Invalid   CORS   request \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["rejectRequest"], "fileName": "org.springframework.web.cors.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    ( response . getHeaders (  )  . getAcControlAllowOrigin (  )  )     !  =    null ;", "}    catch    ( NullPointerException   npe )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["responseHasCors"], "fileName": "org.springframework.web.cors.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . GET . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / DOMAIN 2  . com \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestCaseInsensitiveOriginMatch"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . GET . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 3  . com \"  )  ;", "this . conf . setAllowCredentials ( true )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertEquals (  \" true \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestCredentials"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . GET . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . conf . setAllowCredentials ( true )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertEquals (  \" true \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestCredentialsWithOriginWildcard"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . GET . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addExposedHeader (  \" header 1  \"  )  ;", "this . conf . addExposedHeader (  \" header 2  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  )  ;", "assertTrue ( this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  . contains (  \" header 1  \"  )  )  ;", "assertTrue ( this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  . contains (  \" header 2  \"  )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestExposedHeaders"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . GET . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ FORBIDDEN ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithOriginHeader"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . GET . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \"  *  \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ MAX _ AGE )  )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithOriginHeaderAndAllowedOrigin"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . GET . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . p . processRequest ( null ,    this . request ,    this . response )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithOriginHeaderAndNullConfig"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestAllOriginsAllowed"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  ,    Header 2  \"  )  ;", "this . conf . addAllowedHeader (  \" Header 1  \"  )  ;", "this . conf . addAllowedHeader (  \" Header 2  \"  )  ;", "this . conf . addAllowedHeader (  \" Header 3  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  )  ;", "assertTrue ( this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 1  \"  )  )  ;", "assertTrue ( this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 2  \"  )  )  ;", "assertFalse ( this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 3  \"  )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestAllowedHeaders"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  ,    Header 2  \"  )  ;", "this . conf . addAllowedHeader (  \"  *  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  )  ;", "assertTrue ( this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 1  \"  )  )  ;", "assertTrue ( this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 2  \"  )  )  ;", "assertFalse ( this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \"  *  \"  )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestAllowsAllHeaders"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 3  . com \"  )  ;", "this . conf . addAllowedHeader (  \" Header 1  \"  )  ;", "this . conf . setAllowCredentials ( true )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertEquals (  \" true \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestCredentials"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 3  . com \"  )  ;", "this . conf . addAllowedHeader (  \" Header 1  \"  )  ;", "this . conf . setAllowCredentials ( true )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestCredentialsWithOriginWildcard"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "assertEquals (  \" GET , HEAD \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ METHODS )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestMatchedAllowedMethod"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ FORBIDDEN ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestTestWithOriginButWithoutOtherHeaders"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . conf . addAllowedMethod (  \" GET \"  )  ;", "this . conf . addAllowedMethod (  \" PUT \"  )  ;", "this . conf . addAllowedHeader (  \" header 1  \"  )  ;", "this . conf . addAllowedHeader (  \" header 2  \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \"  *  \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ METHODS )  )  ;", "assertEquals (  \" GET , PUT \"  ,    this . response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ METHODS )  )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ MAX _ AGE )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestValidRequestAndConfig"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \"  \"  )  ;", "this . conf . addAllowedHeader (  \"  *  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertTrue ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ OK ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithEmptyHeaders"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . processRequest ( null ,    this . request ,    this . response )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals ( SC _ FORBIDDEN ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithNullConfig"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ FORBIDDEN ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithRequestAndMethodHeaderButNoConfig"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertFalse ( this . response . containsHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ FORBIDDEN ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithoutRequestMethod"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod ( HttpMethod . OPTIONS . name (  )  )  ;", "this . request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "this . request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" DELETE \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . processRequest ( this . conf ,    this . request ,    this . response )  ;", "assertThat ( this . response . getHeaders ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( SC _ FORBIDDEN ,    this . response . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWrongAllowedMethod"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request    =    new   MockHttpServletRequest (  )  ;", "this . request . setRequestURI (  \"  / test . html \"  )  ;", "this . request . setRemoteHost (  \" domain 1  . com \"  )  ;", "this . conf    =    new   CorsConfiguration (  )  ;", "this . response    =    new   MockHttpServletResponse (  )  ;", "this . response . setStatus ( SC _ OK )  ;", "this . processor    =    new    (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.cors.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . corsConfigurations )  ;", "}", "METHOD_END"], "methodName": ["getCorsConfigurations"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "this . corsConfigurations . put ( path ,    config )  ;", "}", "METHOD_END"], "methodName": ["registerCorsConfiguration"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "this . urlPathHelper . setAlwaysUseFullPath ( alwaysUseFullPath )  ;", "}", "METHOD_END"], "methodName": ["setAlwaysUseFullPath"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "this . corsConfigurations . clear (  )  ;", "if    ( corsConfigurations    !  =    null )     {", "this . corsConfigurations . putAll ( corsConfigurations )  ;", "}", "}", "METHOD_END"], "methodName": ["setCorsConfigurations"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pathMatcher ,     \" PathMatcher   must   not   be   null \"  )  ;", "this . pathMatcher    =    pathMatcher ;", "}", "METHOD_END"], "methodName": ["setPathMatcher"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "this . urlPathHelper . setRemoveSemicolonContent ( removeSemicolonContent )  ;", "}", "METHOD_END"], "methodName": ["setRemoveSemicolonContent"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "this . urlPathHelper . setUrlDecode ( urlDecode )  ;", "}", "METHOD_END"], "methodName": ["setUrlDecode"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( urlPathHelper ,     \" UrlPathHelper   must   not   be   null \"  )  ;", "this . urlPathHelper    =    urlPathHelper ;", "}", "METHOD_END"], "methodName": ["setUrlPathHelper"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( HttpMethod . GET . name (  )  ,     \"  / bar / test . html \"  )  ;", "assertNull ( this . configSource . get ( request )  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "this . configSource . registerCorsConfiguration (  \"  / bar /  *  *  \"  ,    config )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / foo / test . html \"  )  ;", "assertNull ( this . configSource . getCorsConfiguration ( request )  )  ;", "request . setRequestURI (  \"  / bar / test . html \"  )  ;", "assertEquals ( config ,    this . configSource . getCorsConfiguration ( request )  )  ;", "}", "METHOD_END"], "methodName": ["registerAndMatch"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . configSource . getCorsConfigurations (  )  . put (  \"  /  *  *  \"  ,    new   CorsConfiguration (  )  )  ;", "}", "METHOD_END"], "methodName": ["unmodifiableConfigurationsMap"], "fileName": "org.springframework.web.cors.UrlBasedCorsConfigurationSourceTests"}, {"methodBody": ["METHOD_START", "{", "if    ( port    =  =     (  -  1  )  )     {", "if    (  (  \" http \"  . equals ( scheme )  )     |  |     (  \" ws \"  . equals ( scheme )  )  )     {", "port    =     8  0  ;", "} else", "if    (  (  \" https \"  . equals ( scheme )  )     |  |     (  \" wss \"  . equals ( scheme )  )  )     {", "port    =     4  4  3  ;", "}", "}", "return   port ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.springframework.web.cors.reactive.CorsUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( request . getHeaders (  )  . get ( HttpHeaders . ORIGIN )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isCorsRequest"], "fileName": "org.springframework.web.cors.reactive.CorsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( request . getMethod (  )  )     =  =     ( HttpMethod . OPTIONS )  )     &  &     ( CorsUtils . isCorsRequest ( request )  )  )     &  &     (  ( request . getHeaders (  )  . get ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isPreFlightRequest"], "fileName": "org.springframework.web.cors.reactive.CorsUtils"}, {"methodBody": ["METHOD_START", "{", "String   origin    =    request . getHeaders (  )  . getOrigin (  )  ;", "if    ( origin    =  =    null )     {", "return   true ;", "}", "UriComponents   actualUrl    =    UriComponentsBuilder . fromHttpRequest ( request )  . build (  )  ;", "String   actualHost    =    actualUrl . getHost (  )  ;", "int   actualPort    =     . getPort ( actualUrl . getScheme (  )  ,    actualUrl . getPort (  )  )  ;", "Assert . notNull ( actualHost ,     \" Actual   request   host   must   not   be   null \"  )  ;", "Assert . isTrue (  ( actualPort    !  =     (  -  1  )  )  ,     \" Actual   request   port   must   not   be   undefined \"  )  ;", "UriComponents   originUrl    =    UriComponentsBuilder . fromOriginHeader ( origin )  . build (  )  ;", "return    ( actualHost . equals ( originUrl . getHost (  )  )  )     &  &     ( actualPort    =  =     (  . getPort ( originUrl . getScheme (  )  ,    originUrl . getPort (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameOrigin"], "fileName": "org.springframework.web.cors.reactive.CorsUtils"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  /  \"     +    serverName ;", "if    ( port    !  =     (  -  1  )  )     {", "url    =     ( url    +     \"  :  \"  )     +    port ;", "}", "MockServerHttpRequest . BaseBuilder <  ?  >    builder    =    MockServerHttpRequest . get ( url )  . header (  \" Forwarded \"  ,    forwardedHeader )  . header ( HttpHeaders . ORIGIN ,    originHeader )  ;", "return    . isSameOrigin ( builder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkSameOriginWithForwardedHeader"], "fileName": "org.springframework.web.cors.reactive.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  /  \"     +    serverName ;", "if    ( port    !  =     (  -  1  )  )     {", "url    =     ( url    +     \"  :  \"  )     +    port ;", "}", "MockServerHttpRequest . BaseBuilder <  ?  >    builder    =    MockServerHttpRequest . get ( url )  . header ( HttpHeaders . ORIGIN ,    originHeader )  ;", "if    ( forwardedProto    !  =    null )     {", "builder . header (  \" X - Forwarded - Proto \"  ,    forwardedProto )  ;", "}", "if    ( forwardedHost    !  =    null )     {", "builder . header (  \" X - Forwarded - Host \"  ,    forwardedHost )  ;", "}", "if    ( forwardedPort    !  =     (  -  1  )  )     {", "builder . header (  \" X - Forwarded - Port \"  ,    String . valueOf ( forwardedPort )  )  ;", "}", "return    . isSameOrigin ( builder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkSameOriginWithXForwardedHeaders"], "fileName": "org.springframework.web.cors.reactive.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header ( HttpHeaders . ORIGIN ,     \" http :  /  / domain . com \"  )  . build (  )  ;", "assertTrue (  . isCorsRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isCorsRequest"], "fileName": "org.springframework.web.cors.reactive.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "assertFalse (  . isCorsRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isNotCorsRequest"], "fileName": "org.springframework.web.cors.reactive.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "assertFalse (  . isPreFlightRequest ( request )  )  ;", "request    =    MockServerHttpRequest . options (  \"  /  \"  )  . header ( HttpHeaders . ORIGIN ,     \" http :  /  / domain . com \"  )  . build (  )  ;", "assertFalse (  . isPreFlightRequest ( request )  )  ;", "request    =    MockServerHttpRequest . options (  \"  /  \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . build (  )  ;", "assertFalse (  . isPreFlightRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isNotPreFlightRequest"], "fileName": "org.springframework.web.cors.reactive.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . options (  \"  /  \"  )  . header ( HttpHeaders . ORIGIN ,     \" http :  /  / domain . com \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . build (  )  ;", "assertTrue (  . isPreFlightRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isPreFlightRequest"], "fileName": "org.springframework.web.cors.reactive.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" proto = https \"  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" proto = https \"  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" proto = https ;    host = mydomain 2  . com \"  ,     \" https :  /  / mydomain 2  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" proto = https ;    host = mydomain 2  . com \"  ,     \" https :  /  / mydomain 2  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" proto = https ;    host = mydomain 2  . com :  4  5  6  \"  ,     \" https :  /  / mydomain 2  . com :  4  5  6  \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" proto = https ;    host = mydomain 2  . com :  4  5  6  \"  ,     \" https :  /  / mydomain 2  . com :  4  5  6  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameOriginWithForwardedHeader"], "fileName": "org.springframework.web.cors.reactive.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" https \"  ,    null ,     (  -  1  )  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" https \"  ,    null ,     (  -  1  )  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" https \"  ,     \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" https :  /  / mydomain 2  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" https \"  ,     \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" https :  /  / mydomain 2  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" https \"  ,     \" mydomain 2  . com \"  ,     4  5  6  ,     \" https :  /  / mydomain 2  . com :  4  5  6  \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" https \"  ,     \" mydomain 2  . com \"  ,     4  5  6  ,     \" https :  /  / mydomain 2  . com :  4  5  6  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameOriginWithXForwardedHeaders"], "fileName": "org.springframework.web.cors.reactive.CorsUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . delete (  \" http :  /  / domain 1  . com / test . html \"  )  . header ( HttpHeaders . HOST ,     \" domain 1  . com \"  )  . header ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  . header (  \" header 2  \"  ,     \" foo \"  )  )  ;", "Chain   filterChain    =     (    filterExchange )     -  >    Mono . error ( new   AssertionError (  \" Invalid   requests   must   not   be   forwarded   to   the   filter   chain \"  )  )  ;", "filter . filter ( exchange ,    filterChain )  ;", "assertNull ( exchange . getResponse (  )  . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["invalidActualRequest"], "fileName": "org.springframework.web.cors.reactive.CorsWebFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . options (  \" http :  /  / domain 1  . com / test . html \"  )  . header ( HttpHeaders . HOST ,     \" domain 1  . com \"  )  . header ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpMethod . DELETE . name (  )  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" header 1  ,    header 2  \"  )  )  ;", "Chain   filterChain    =     (    filterExchange )     -  >    Mono . error ( new   AssertionError (  \" Preflight   requests   must   not   be   forwarded   to   the   filter   chain \"  )  )  ;", "filter . filter ( exchange ,    filterChain )  ;", "assertNull ( exchange . getResponse (  )  . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["invalidPreFlightRequest"], "fileName": "org.springframework.web.cors.reactive.CorsWebFilterTests"}, {"methodBody": ["METHOD_START", "{", "config . setAllowedOrigins ( Arrays . asList (  \" http :  /  / domain 1  . com \"  ,     \" http :  /  / domain 2  . com \"  )  )  ;", "config . setAllowedMethods ( Arrays . asList (  \" GET \"  ,     \" POST \"  )  )  ;", "config . setAllowedHeaders ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  ;", "config . setExposedHeaders ( Arrays . asList (  \" header 3  \"  ,     \" header 4  \"  )  )  ;", "config . setMaxAge (  1  2  3 L )  ;", "config . setAllowCredentials ( false )  ;", "filter    =    new    (  (    r )     -  >    config )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.cors.reactive.CorsWebFilterTests"}, {"methodBody": ["METHOD_START", "{", "WebFilterChain   filterChain    =     (    filterExchange )     -  >     {", "try    {", "HttpHeaders   headers    =    filterExchange . getResponse (  )  . getHeaders (  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    headers . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" header 3  ,    header 4  \"  ,    headers . getFirst ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  )  ;", "}    catch    ( AssertionError   ex )     {", "return   Mono . error ( ex )  ;", "}", "return   Mono . empty (  )  ;", "}  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / domain 1  . com / test . html \"  )  . header ( HttpHeaders . HOST ,     \" domain 1  . com \"  )  . header ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  . header (  \" header 2  \"  ,     \" foo \"  )  )  ;", "this . filter . filter ( exchange ,    filterChain )  ;", "}", "METHOD_END"], "methodName": ["validActualRequest"], "fileName": "org.springframework.web.cors.reactive.CorsWebFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . options (  \" http :  /  / domain 1  . com / test . html \"  )  . header ( HttpHeaders . HOST ,     \" domain 1  . com \"  )  . header ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpMethod . GET . name (  )  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" header 1  ,    header 2  \"  )  )  ;", "Chain   filterChain    =     (    filterExchange )     -  >    Mono . error ( new   AssertionError (  \" Preflight   requests   must   not   be   forwarded   to   the   filter   chain \"  )  )  ;", "filter . filter ( exchange ,    filterChain )  ;", "HttpHeaders   headers    =    exchange . getResponse (  )  . getHeaders (  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    headers . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" header 1  ,    header 2  \"  ,    headers . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  )  ;", "assertEquals (  \" header 3  ,    header 4  \"  ,    headers . getFirst ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  )  ;", "assertEquals (  1  2  3 L ,    Long . parseLong ( headers . getFirst ( HttpHeaders . ACCESS _ CONTROL _ MAX _ AGE )  )  )  ;", "}", "METHOD_END"], "methodName": ["validPreFlightRequest"], "fileName": "org.springframework.web.cors.reactive.CorsWebFilterTests"}, {"methodBody": ["METHOD_START", "{", "return   config . checkHeaders ( requestHeaders )  ;", "}", "METHOD_END"], "methodName": ["checkHeaders"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   config . checkHttpMethod ( requestMethod )  ;", "}", "METHOD_END"], "methodName": ["checkMethods"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   config . checkOrigin ( requestOrigin )  ;", "}", "METHOD_END"], "methodName": ["checkOrigin"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "return   isPreFlight    ?    headers . getAcControlRequestHeaders (  )     :    new   ArrayList <  >  ( headers . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHeadersToUse"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   isPreFlight    ?    request . getHeaders (  )  . getAccessControlRequestMethod (  )     :    request . getMethod (  )  ;", "}", "METHOD_END"], "methodName": ["getMethodToUse"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    exchange . getRequest (  )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "HttpHeaders   responseHeaders    =    response . getHeaders (  )  ;", "response . getHeaders (  )  . addAll ( HttpHeaders . VARY ,    Arrays . asList ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "String   requestOrigin    =    request . getHeaders (  )  . getOrigin (  )  ;", "String   allowOrigin    =    checkOrigin ( config ,    requestOrigin )  ;", "if    ( allowOrigin    =  =    null )     {", ". logger . debug (  (  (  \" Rejecting   CORS   request   because    '  \"     +    requestOrigin )     +     \"  '    origin   is   not   allowed \"  )  )  ;", "rejectRequest ( response )  ;", "return   false ;", "}", "HttpMethod   requestMethod    =    getMethodToUse ( request ,    preFlightRequest )  ;", "List < HttpMethod >    allowMethods    =    checkMethods ( config ,    requestMethod )  ;", "if    ( allowMethods    =  =    null )     {", ". logger . debug (  (  (  \" Rejecting   CORS   request   because    '  \"     +    requestMethod )     +     \"  '    request   method   is   not   allowed \"  )  )  ;", "rejectRequest ( response )  ;", "return   false ;", "}", "List < String >    requestHeaders    =    getHeadersToUse ( request ,    preFlightRequest )  ;", "List < String >    allowHeaders    =    checkHeaders ( config ,    requestHeaders )  ;", "if    ( preFlightRequest    &  &     ( allowHeaders    =  =    null )  )     {", ". logger . debug (  (  (  \" Rejecting   CORS   request   because    '  \"     +    requestHeaders )     +     \"  '    request   headers   are   not   allowed \"  )  )  ;", "rejectRequest ( response )  ;", "return   false ;", "}", "responseHeaders . setAccessControlAllowOrigin ( allowOrigin )  ;", "if    ( preFlightRequest )     {", "responseHeaders . setAccessControlAllowMethods ( allowMethods )  ;", "}", "if    ( preFlightRequest    &  &     (  !  ( allowHeaders . isEmpty (  )  )  )  )     {", "responseHeaders . setAccessControlAllowHeaders ( allowHeaders )  ;", "}", "if    (  !  ( CollectionUtils . isEmpty ( config . getExposedHeaders (  )  )  )  )     {", "responseHeaders . setAccessControlExposeHeaders ( config . getExposedHeaders (  )  )  ;", "}", "if    ( Boolean . TRUE . equals ( config . getAllowCredentials (  )  )  )     {", "responseHeaders . setAccessControlAllowCredentials ( true )  ;", "}", "if    ( preFlightRequest    &  &     (  ( config . getMaxAge (  )  )     !  =    null )  )     {", "responseHeaders . setAccessControlMaxAge ( config . getMaxAge (  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["handleInternal"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "response . setStatusCode ( HttpStatus . FORBIDDEN )  ;", ". logger . debug (  \" Invalid   CORS   request \"  )  ;", "}", "METHOD_END"], "methodName": ["rejectRequest"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( response . getHeaders (  )  . getAccessControlAllowOrigin (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["responseHasCors"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessor"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( corsRequest ( HttpMethod . GET )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequest"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    actualRequest (  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / DOMAIN 2  . com \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestCaseInsensitiveOriginMatch"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    actualRequest (  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 3  . com \"  )  ;", "this . conf . setAllowCredentials ( true )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertEquals (  \" true \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestCredentials"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    actualRequest (  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . conf . setAllowCredentials ( true )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertEquals (  \" true \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestCredentialsWithOriginWildcard"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    actualRequest (  )  ;", "this . conf . addExposedHeader (  \" header 1  \"  )  ;", "this . conf . addExposedHeader (  \" header 2  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  )  ;", "assertTrue ( response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  . contains (  \" header 1  \"  )  )  ;", "assertTrue ( response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  . contains (  \" header 2  \"  )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestExposedHeaders"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    actualRequest (  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( HttpStatus . FORBIDDEN ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithOriginHeader"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    actualRequest (  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \"  *  \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ MAX _ AGE )  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithOriginHeaderAndAllowedOrigin"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    actualRequest (  )  ;", "this . p . process ( null ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithOriginHeaderAndNullConfig"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerHttpRequest . method ( method ,     \" http :  /  / localhost / test . html \"  )  . header ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "}", "METHOD_END"], "methodName": ["corsRequest"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   corsRequest ( HttpMethod . OPTIONS )  ;", "}", "METHOD_END"], "methodName": ["preFlightRequest"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestAllOriginsAllowed"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  ,    Header 2  \"  )  )  ;", "this . conf . addAllowedHeader (  \" Header 1  \"  )  ;", "this . conf . addAllowedHeader (  \" Header 2  \"  )  ;", "this . conf . addAllowedHeader (  \" Header 3  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  )  ;", "assertTrue ( response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 1  \"  )  )  ;", "assertTrue ( response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 2  \"  )  )  ;", "assertFalse ( response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 3  \"  )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestAllowedHeaders"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  ,    Header 2  \"  )  )  ;", "this . conf . addAllowedHeader (  \"  *  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  )  ;", "assertTrue ( response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 1  \"  )  )  ;", "assertTrue ( response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \" Header 2  \"  )  )  ;", "assertFalse ( response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  . contains (  \"  *  \"  )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestAllowsAllHeaders"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 3  . com \"  )  ;", "this . conf . addAllowedHeader (  \" Header 1  \"  )  ;", "this . conf . setAllowCredentials ( true )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertEquals (  \" true \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestCredentials"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 1  . com \"  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 3  . com \"  )  ;", "this . conf . addAllowedHeader (  \" Header 1  \"  )  ;", "this . conf . setAllowCredentials ( true )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestCredentialsWithOriginWildcard"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals (  \" GET , HEAD \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ METHODS )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestMatchedAllowedMethod"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( HttpStatus . FORBIDDEN ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestTestWithOriginButWithoutOtherHeaders"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . conf . addAllowedMethod (  \" GET \"  )  ;", "this . conf . addAllowedMethod (  \" PUT \"  )  ;", "this . conf . addAllowedHeader (  \" header 1  \"  )  ;", "this . conf . addAllowedHeader (  \" header 2  \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \"  *  \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ METHODS )  )  ;", "assertEquals (  \" GET , PUT \"  ,    response . getHeaders (  )  . getFirst ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ METHODS )  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ MAX _ AGE )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestValidRequestAndConfig"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \"  \"  )  )  ;", "this . conf . addAllowedHeader (  \"  *  \"  )  ;", "this . conf . addAllowedOrigin (  \" http :  /  / domain 2  . com \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertNull ( response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithEmptyHeaders"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . process ( null ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals ( HttpStatus . FORBIDDEN ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithNullConfig"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( HttpStatus . FORBIDDEN ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithRequestAndMethodHeaderButNoConfig"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Header 1  \"  )  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertFalse ( response . getHeaders (  )  . containsKey ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( HttpStatus . FORBIDDEN ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithoutRequestMethod"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( preFlightRequest (  )  . header ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" DELETE \"  )  )  ;", "this . conf . addAllowedOrigin (  \"  *  \"  )  ;", "this . p . process ( this . conf ,    exchange )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertThat ( response . getHeaders (  )  . get ( HttpHeaders . VARY )  ,    contains ( HttpHeaders . ORIGIN ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "assertEquals ( HttpStatus . FORBIDDEN ,    response . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWrongAllowedMethod"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . conf    =    new   CorsConfiguration (  )  ;", "this . processor    =    new    (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.cors.reactive.DefaultCorsProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . corsConfigurations . put ( this . patternParser . parse ( path )  ,    config )  ;", "}", "METHOD_END"], "methodName": ["registerCorsConfiguration"], "fileName": "org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "this . corsConfigurations . clear (  )  ;", "if    ( corsConfigurations    !  =    null )     {", "corsConfigurations . forEach ( this :  : register )  ;", "}", "}", "METHOD_END"], "methodName": ["setCorsConfigurations"], "fileName": "org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / bar / test . html \"  )  )  ;", "assertNull ( this . configSource . get ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   config    =    new   CorsConfiguration (  )  ;", "this . configSource . registerCorsConfiguration (  \"  / bar /  *  *  \"  ,    config )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / foo / test . html \"  )  )  ;", "assertNull ( this . configSource . getCorsConfiguration ( exchange )  )  ;", "exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / bar / test . html \"  )  )  ;", "assertEquals ( config ,    this . configSource . getCorsConfiguration ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["registerAndMatch"], "fileName": "org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSourceTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   msg    =    new   StringBuilder (  )  ;", "msg . append ( prefix )  ;", "msg . append (  \" uri =  \"  )  . append ( request . geURI (  )  )  ;", "if    ( isIncludeQueryString (  )  )     {", "String   queryString    =    request . getQueryString (  )  ;", "if    ( queryString    !  =    null )     {", "msg . append (  '  ?  '  )  . append ( queryString )  ;", "}", "}", "if    ( isIncludeClientInfo (  )  )     {", "String   client    =    request . getRemoteAddr (  )  ;", "if    ( StringUtils . hasLength ( client )  )     {", "msg . append (  \"  ; client =  \"  )  . append ( client )  ;", "}", "HttpSession   session    =    request . getSession ( false )  ;", "if    ( session    !  =    null )     {", "msg . append (  \"  ; session =  \"  )  . append ( session . getId (  )  )  ;", "}", "String   user    =    request . getRemoteUser (  )  ;", "if    ( user    !  =    null )     {", "msg . append (  \"  ; user =  \"  )  . append ( user )  ;", "}", "}", "if    ( isIncludeHeaders (  )  )     {", "msg . append (  \"  ; headers =  \"  )  . append ( new   ServletServerHttpRequest ( request )  . getHeaders (  )  )  ;", "}", "if    ( isIncludePayload (  )  )     {", "String   payload    =    getMessagePayload ( request )  ;", "if    ( payload    !  =    null )     {", "msg . append (  \"  ; payload =  \"  )  . append ( payload )  ;", "}", "}", "msg . append ( suffix )  ;", "return   msg . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   createMessage ( request ,    this . afterMessagePrefix ,    this . afterMessageSuffix )  ;", "}", "METHOD_END"], "methodName": ["getAfterMessage"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   createMessage ( request ,    this . beforeMessagePrefix ,    this . beforeMessageSuffix )  ;", "}", "METHOD_END"], "methodName": ["getBeforeMessage"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . maxPayloadLength ;", "}", "METHOD_END"], "methodName": ["getMaxPayloadLength"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "ContentCachingRequestWrapper   wrapper    =    WebUtils . getNativeRequest ( request ,    ContentCachingRequestWrapper . class )  ;", "if    ( wrapper    !  =    null )     {", "byte [  ]    buf    =    wrapper . getContentAsByteArray (  )  ;", "if    (  ( buf . length )     >     0  )     {", "int   length    =    Math . min ( buf . length ,    getMaxPayloadLength (  )  )  ;", "try    {", "return   new   String ( buf ,     0  ,    length ,    wrapper . getCharacterEncoding (  )  )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "return    \"  [ unknown ]  \"  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMessagePayload"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . includeClientInfo ;", "}", "METHOD_END"], "methodName": ["isIncludeClientInfo"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . includeHeaders ;", "}", "METHOD_END"], "methodName": ["isIncludeHeaders"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . includePayload ;", "}", "METHOD_END"], "methodName": ["isIncludePayload"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . includeQueryString ;", "}", "METHOD_END"], "methodName": ["isIncludeQueryString"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "this . afterMessagePrefix    =    afterMessagePrefix ;", "}", "METHOD_END"], "methodName": ["setAfterMessagePrefix"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "this . afterMessageSuffix    =    afterMessageSuffix ;", "}", "METHOD_END"], "methodName": ["setAfterMessageSuffix"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "this . beforeMessagePrefix    =    beforeMessagePrefix ;", "}", "METHOD_END"], "methodName": ["setBeforeMessagePrefix"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "this . beforeMessageSuffix    =    beforeMessageSuffix ;", "}", "METHOD_END"], "methodName": ["setBeforeMessageSuffix"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "this . includeClientInfo    =    includeClientInfo ;", "}", "METHOD_END"], "methodName": ["setIncludeClientInfo"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "this . includeHeaders    =    includeHeaders ;", "}", "METHOD_END"], "methodName": ["setIncludeHeaders"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "this . includePayload    =    includePayload ;", "}", "METHOD_END"], "methodName": ["setIncludePayload"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "this . includeQueryString    =    includeQueryString ;", "}", "METHOD_END"], "methodName": ["setIncludeQueryString"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( maxPayloadLength    >  =     0  )  ,     \"  ' maxPayloadLength '    should   be   larger   than   or   equal   to    0  \"  )  ;", "this . maxPayloadLength    =    maxPayloadLength ;", "}", "METHOD_END"], "methodName": ["setMaxPayloadLength"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldLog"], "fileName": "org.springframework.web.filter.AbstractRequestLoggingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . encoding ;", "}", "METHOD_END"], "methodName": ["getEncoding"], "fileName": "org.springframework.web.filter.CharacterEncodingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . forceRequestEncoding ;", "}", "METHOD_END"], "methodName": ["isForceRequestEncoding"], "fileName": "org.springframework.web.filter.CharacterEncodingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . forceResponseEncoding ;", "}", "METHOD_END"], "methodName": ["isForceResponseEncoding"], "fileName": "org.springframework.web.filter.CharacterEncodingFilter"}, {"methodBody": ["METHOD_START", "{", "this . encoding    =    encoding ;", "}", "METHOD_END"], "methodName": ["setEncoding"], "fileName": "org.springframework.web.filter.CharacterEncodingFilter"}, {"methodBody": ["METHOD_START", "{", "this . forceRequestEncoding    =    forceEncoding ;", "this . forceResponseEncoding    =    forceEncoding ;", "}", "METHOD_END"], "methodName": ["setForceEncoding"], "fileName": "org.springframework.web.filter.CharacterEncodingFilter"}, {"methodBody": ["METHOD_START", "{", "this . forceRequestEncoding    =    forceRequestEncoding ;", "}", "METHOD_END"], "methodName": ["setForceRequestEncoding"], "fileName": "org.springframework.web.filter.CharacterEncodingFilter"}, {"methodBody": ["METHOD_START", "{", "this . forceResponseEncoding    =    forceResponseEncoding ;", "}", "METHOD_END"], "methodName": ["setForceResponseEncoding"], "fileName": "org.springframework.web.filter.CharacterEncodingFilter"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "given ( request . getCharacterEncoding (  )  )  . willReturn (  . ENCODING )  ;", "given ( request . getAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( filteredName (  . FILTER _ NAME )  )  )  . willReturn ( null )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   filterChain    =    mock ( FilterChain . class )  ;", "CharacterEncodingFilter   filter    =    new   CharacterEncodingFilter (  . ENCODING )  ;", "filter . init ( new   MockFilterConfig (  . FILTER _ NAME )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "verify ( request )  . setAttribute ( filteredName (  . FILTER _ NAME )  ,    Boolean . TRUE )  ;", "verify ( request )  . removeAttribute ( filteredName (  . FILTER _ NAME )  )  ;", "verify ( filterChain )  . doFilter ( request ,    response )  ;", "}", "METHOD_END"], "methodName": ["doesNotIfEncodingIsNotEmptyAndNotForced"], "fileName": "org.springframework.web.filter.CharacterEncodingFilterTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "given ( request . getCharacterEncoding (  )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( filteredName (  . FILTER _ NAME )  )  )  . willReturn ( null )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   filterChain    =    mock ( FilterChain . class )  ;", "CharacterEncodingFilter   filter    =    new   CharacterEncodingFilter (  . ENCODING )  ;", "filter . init ( new   MockFilterConfig (  . FILTER _ NAME )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "verify ( request )  . setCharacterEncoding (  . ENCODING )  ;", "verify ( request )  . setAttribute ( filteredName (  . FILTER _ NAME )  ,    Boolean . TRUE )  ;", "verify ( request )  . removeAttribute ( filteredName (  . FILTER _ NAME )  )  ;", "verify ( filterChain )  . doFilter ( request ,    response )  ;", "}", "METHOD_END"], "methodName": ["encodingIfEmptyAndNotForced"], "fileName": "org.springframework.web.filter.CharacterEncodingFilterTests"}, {"methodBody": ["METHOD_START", "{", "return   prefix    +     ( OncePerRequestFilter . ALREADY _ FILTERED _ SUFFIX )  ;", "}", "METHOD_END"], "methodName": ["filteredName"], "fileName": "org.springframework.web.filter.CharacterEncodingFilterTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "request . setCharacterEncoding (  . ENCODING )  ;", "given ( request . getAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( filteredName (  . FILTER _ NAME )  )  )  . willReturn ( null )  ;", "HttpServletResponse   response    =    mock ( HttpServletResponse . class )  ;", "FilterChain   filterChain    =    mock ( FilterChain . class )  ;", "CharacterEncodingFilter   filter    =    new   CharacterEncodingFilter (  . ENCODING ,    true )  ;", "filter . init ( new   MockFilterConfig (  . FILTER _ NAME )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "verify ( request )  . setAttribute ( filteredName (  . FILTER _ NAME )  ,    Boolean . TRUE )  ;", "verify ( request )  . removeAttribute ( filteredName (  . FILTER _ NAME )  )  ;", "verify ( response )  . setCharacterEncoding (  . ENCODING )  ;", "verify ( filterChain )  . doFilter ( request ,    response )  ;", "}", "METHOD_END"], "methodName": ["forceEncodingAlwaysSetsEncoding"], "fileName": "org.springframework.web.filter.CharacterEncodingFilterTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "request . setCharacterEncoding (  . ENCODING )  ;", "given ( request . getAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( filteredName (  . FILTER _ NAME )  )  )  . willReturn ( null )  ;", "HttpServletResponse   response    =    mock ( HttpServletResponse . class )  ;", "FilterChain   filterChain    =    mock ( FilterChain . class )  ;", "CharacterEncodingFilter   filter    =    new   CharacterEncodingFilter (  . ENCODING ,    true ,    false )  ;", "filter . init ( new   MockFilterConfig (  . FILTER _ NAME )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "verify ( request )  . setAttribute ( filteredName (  . FILTER _ NAME )  ,    Boolean . TRUE )  ;", "verify ( request )  . removeAttribute ( filteredName (  . FILTER _ NAME )  )  ;", "verify ( request ,    times (  2  )  )  . setCharacterEncoding (  . ENCODING )  ;", "verify ( response ,    never (  )  )  . setCharacterEncoding (  . ENCODING )  ;", "verify ( filterChain )  . doFilter ( request ,    response )  ;", "}", "METHOD_END"], "methodName": ["setForceEncodingOnRequestOnly"], "fileName": "org.springframework.web.filter.CharacterEncodingFilterTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "given ( request . getCharacterEncoding (  )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( filteredName (  . FILTER _ NAME )  )  )  . willReturn ( null )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   filterChain    =    mock ( FilterChain . class )  ;", "CharacterEncodingFilter   filter    =    new   CharacterEncodingFilter (  )  ;", "filter . setEncoding (  . ENCODING )  ;", "filter . setBeanName (  . FILTER _ NAME )  ;", "filter . setServletContext ( new   MockServletContext (  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "verify ( request )  . setCharacterEncoding (  . ENCODING )  ;", "verify ( request )  . setAttribute ( filteredName (  . FILTER _ NAME )  ,    Boolean . TRUE )  ;", "verify ( request )  . removeAttribute ( filteredName (  . FILTER _ NAME )  )  ;", "verify ( filterChain )  . doFilter ( request ,    response )  ;", "}", "METHOD_END"], "methodName": ["withBeanInitialization"], "fileName": "org.springframework.web.filter.CharacterEncodingFilterTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    mock ( HttpServletRequest . class )  ;", "given ( request . getCharacterEncoding (  )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  )  . willReturn ( null )  ;", "given ( request . getAttribute ( filteredName ( CharacterEncodingFilter . class . getName (  )  )  )  )  . willReturn ( null )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   filterChain    =    mock ( FilterChain . class )  ;", "CharacterEncodingFilter   filter    =    new   CharacterEncodingFilter (  . ENCODING )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "verify ( request )  . setCharacterEncoding (  . ENCODING )  ;", "verify ( request )  . setAttribute ( filteredName ( CharacterEncodingFilter . class . getName (  )  )  ,    Boolean . TRUE )  ;", "verify ( request )  . removeAttribute ( filteredName ( CharacterEncodingFilter . class . getName (  )  )  )  ;", "verify ( filterChain )  . doFilter ( request ,    response )  ;", "}", "METHOD_END"], "methodName": ["withIncompleteInitialization"], "fileName": "org.springframework.web.filter.CharacterEncodingFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . filters    =    new   ArrayList ( filters )  ;", "}", "METHOD_END"], "methodName": ["setFilters"], "fileName": "org.springframework.web.filter.CompositeFilter"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", ". MockFilter   targetFilter    =    new    . MockFilter (  )  ;", "MockFilterConfig   proxyConfig    =    new   MockFilterConfig ( sc )  ;", "CompositeFilter   filterProxy    =    new   CompositeFilter (  )  ;", "filterProxy . setFilters ( Arrays . asList ( targetFilter )  )  ;", "filterProxy . init ( proxyConfig )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNotNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testCompositeFilter"], "fileName": "org.springframework.web.filter.CompositeFilterTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( processor ,     \" CorsProcessor   must   not   be   null \"  )  ;", "this . processor    =    processor ;", "}", "METHOD_END"], "methodName": ["setCorsProcessor"], "fileName": "org.springframework.web.filter.CorsFilter"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( HttpMethod . DELETE . name (  )  ,     \"  / test . html \"  )  ;", "request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "request . addHeader (  \" header 2  \"  ,     \" foo \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "fail (  \" Invalid   requests   must   not   be   forwarded   to   the   chain \"  )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertNull ( response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["invalidActualRequest"], "fileName": "org.springframework.web.filter.CorsFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( HttpMethod . OPTIONS . name (  )  ,     \"  / test . html \"  )  ;", "request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpMethod . DELETE . name (  )  )  ;", "request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" header 1  ,    header 2  \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >    fail (  \" Preflight   requests   must   not   be   forwarded   to   the   chain \"  )  ;", "doFilter ( request ,    response ,    hain )  ;", "assertNull ( response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["invalidPreFlightRequest"], "fileName": "org.springframework.web.filter.CorsFilterTests"}, {"methodBody": ["METHOD_START", "{", "config . setAllowedOrigins ( Arrays . asList (  \" http :  /  / domain 1  . com \"  ,     \" http :  /  / domain 2  . com \"  )  )  ;", "config . setAllowedMethods ( Arrays . asList (  \" GET \"  ,     \" POST \"  )  )  ;", "config . setAllowedHeaders ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  )  ;", "config . setExposedHeaders ( Arrays . asList (  \" header 3  \"  ,     \" header 4  \"  )  )  ;", "config . setMaxAge (  1  2  3 L )  ;", "config . setAllowCredentials ( false )  ;", "filter    =    new    (  (    r )     -  >    config )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.filter.CorsFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( HttpMethod . GET . name (  )  ,     \"  / test . html \"  )  ;", "request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "request . addHeader (  \" header 2  \"  ,     \" foo \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" header 3  ,    header 4  \"  ,    response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "}", "METHOD_END"], "methodName": ["validActualRequest"], "fileName": "org.springframework.web.filter.CorsFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest ( HttpMethod . OPTIONS . name (  )  ,     \"  / test . html \"  )  ;", "request . addHeader ( HttpHeaders . ORIGIN ,     \" http :  /  / domain 2  . com \"  )  ;", "request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ METHOD ,    HttpMethod . GET . name (  )  )  ;", "request . addHeader ( HttpHeaders . ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" header 1  ,    header 2  \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >    fail (  \" Preflight   requests   must   not   be   forwarded   to   the   chain \"  )  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" http :  /  / domain 2  . com \"  ,    response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertEquals (  \" header 1  ,    header 2  \"  ,    response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ ALLOW _ HEADERS )  )  ;", "assertEquals (  \" header 3  ,    header 4  \"  ,    response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ EXPOSE _ HEADERS )  )  ;", "assertEquals (  1  2  3 L ,    Long . parseLong ( response . getHeader ( HttpHeaders . ACCESS _ CONTROL _ MAX _ AGE )  )  )  ;", "}", "METHOD_END"], "methodName": ["validPreFlightRequest"], "fileName": "org.springframework.web.filter.CorsFilterTests"}, {"methodBody": ["METHOD_START", "{", "if    ( isTargetFilterLifecycle (  )  )     {", "delegate . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["destroyDelegate"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . webApplicationContext )     !  =    null )     {", "if    (  ( this . webApplicationContext )    instanceof   ConfigurableApplicationContext )     {", "ConfigurableApplicationContext   cac    =     (  ( ConfigurableApplicationContext )     ( this . webApplicationContext )  )  ;", "if    (  !  ( cac . isActive (  )  )  )     {", "cac . refresh (  )  ;", "}", "}", "return   this . webApplicationContext ;", "}", "String   attrName    =    getContextAttribute (  )  ;", "if    ( attrName    !  =    null )     {", "return   WebApplicationContextUtils . getWebApplicationContext ( getServletContext (  )  ,    attrName )  ;", "} else    {", "return   WebApplicationContextUtils . findWebApplicationContext ( getServletContext (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["findWebApplicationContext"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . contextAttribute ;", "}", "METHOD_END"], "methodName": ["getContextAttribute"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . targetBeanName ;", "}", "METHOD_END"], "methodName": ["getTargetBeanName"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "String   targetBeanName    =    getTargetBeanName (  )  ;", "Assert . state (  ( targetBeanName    !  =    null )  ,     \" No   target   bean   name   set \"  )  ;", "Fdelegate    =    wac . getBean ( targetBeanName ,    Fclass )  ;", "if    ( isTargetFifecycle (  )  )     {", "delegate . init ( getFonfig (  )  )  ;", "}", "return   delegate ;", "}", "METHOD_END"], "methodName": ["initDelegate"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "delegate . doFilter ( request ,    response ,    filterChain )  ;", "}", "METHOD_END"], "methodName": ["invokeDelegate"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . targetFilterLifecycle ;", "}", "METHOD_END"], "methodName": ["isTargetFilterLifecycle"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "this . contextAttribute    =    contextAttribute ;", "}", "METHOD_END"], "methodName": ["setContextAttribute"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    targetBeanName ;", "}", "METHOD_END"], "methodName": ["setTargetBeanName"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "this . targetFilterLifecycle    =    targetFilterLifecycle ;", "}", "METHOD_END"], "methodName": ["setTargetFilterLifecycle"], "fileName": "org.springframework.web.filter.DelegatingFilterProxy"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . registerSingleton (  \" targetFilter \"  ,     . MockFilter . class )  ;", "wac . refresh (  )  ;", "sc . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wac . getBean (  \" targetFilter \"  )  )  )  ;", "MockFilterConfig   proxyConfig    =    new   MockFilterConfig ( sc )  ;", "proxyConfig . addInitParameter (  \" targetBeanName \"  ,     \" targetFilter \"  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy (  )  ;", "filterProxy . init ( proxyConfig )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxy"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . registerSingleton (  \" targetFilter \"  ,     . MockFilter . class )  ;", "wac . refresh (  )  ;", "sc . setAttribute (  \" CUSTOM _ ATTR \"  ,    wac )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wac . getBean (  \" targetFilter \"  )  )  )  ;", "MockFilterConfig   proxyConfig    =    new   MockFilterConfig ( sc )  ;", "proxyConfig . addInitParameter (  \" targetBeanName \"  ,     \" targetFilter \"  )  ;", "proxyConfig . addInitParameter (  \" contextAttribute \"  ,     \" CUSTOM _ ATTR \"  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy (  )  ;", "filterProxy . init ( proxyConfig )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyAndCustomContextAttribute"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . refresh (  )  ;", "sc . setAttribute (  \" dispatcher \"  ,    wac )  ;", "StaticWebApplicationContext   injectedWac    =    new   StaticWebApplicationContext (  )  ;", "injectedWac . setServletContext ( sc )  ;", "String   beanName    =     \" targetFilter \"  ;", "injectedWac . registerSingleton ( beanName ,     . MockFilter . class )  ;", "injectedWac . refresh (  )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( injectedWac . getBean ( beanName )  )  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy ( beanName ,    injectedWac )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyInjectedPreferred"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . refresh (  )  ;", "sc . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", "sc . setAttribute (  \" dispatcher \"  ,    wac )  ;", "StaticWebApplicationContext   wacToUse    =    new   StaticWebApplicationContext (  )  ;", "wacToUse . setServletContext ( sc )  ;", "String   beanName    =     \" targetFilter \"  ;", "String   attrName    =     \" customAttrName \"  ;", "wacToUse . registerSingleton ( beanName ,     . MockFilter . class )  ;", "wacToUse . refresh (  )  ;", "sc . setAttribute ( attrName ,    wacToUse )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wacToUse . getBean ( beanName )  )  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy ( beanName )  ;", "filterProxy . setContextAttribute ( attrName )  ;", "filterProxy . setServletContext ( sc )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyNotInjectedWacServletAttrPreferred"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . refresh (  )  ;", "sc . setAttribute (  \" dispatcher \"  ,    wac )  ;", "sc . setAttribute (  \" another \"  ,    wac )  ;", "StaticWebApplicationContext   wacToUse    =    new   StaticWebApplicationContext (  )  ;", "wacToUse . setServletContext ( sc )  ;", "String   beanName    =     \" targetFilter \"  ;", "wacToUse . registerSingleton ( beanName ,     . MockFilter . class )  ;", "wacToUse . refresh (  )  ;", "sc . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wacToUse )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wacToUse . getBean ( beanName )  )  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy ( beanName )  ;", "filterProxy . setServletContext ( sc )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyNotInjectedWithRootPreferred"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "DelegatingFilterProxyTests . MockFilter   targetFilter    =    new   DelegatingFilterProxyTests . MockFilter (  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy ( targetFilter )  ;", "filterProxy . init ( new   MockFilterConfig ( new   MockServletContext (  )  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyWithFilterDelegateInstance"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . registerSingleton (  \" targetFilter \"  ,     . MockFilter . class )  ;", "wac . refresh (  )  ;", "sc . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wac . getBean (  \" targetFilter \"  )  )  )  ;", "MockFilterConfig   proxyConfig    =    new   MockFilterConfig ( sc ,     \" targetFilter \"  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy (  )  ;", "filterProxy . init ( proxyConfig )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyWithFilterName"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . registerSingleton (  \" targetFilter \"  ,     . MockFilter . class )  ;", "wac . refresh (  )  ;", "sc . setAttribute (  \" dispatcher \"  ,    wac )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wac . getBean (  \" targetFilter \"  )  )  )  ;", "MockFilterConfig   proxyConfig    =    new   MockFilterConfig ( sc )  ;", "proxyConfig . addInitParameter (  \" targetBeanName \"  ,     \" targetFilter \"  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy (  )  ;", "filterProxy . init ( proxyConfig )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyWithFrameworkServletContext"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "MockFilterConfig   proxyConfig    =    new   MockFilterConfig ( sc )  ;", "proxyConfig . addInitParameter (  \" targetBeanName \"  ,     \" targetFilter \"  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy (  )  ;", "filterProxy . init ( proxyConfig )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . registerSingleton (  \" targetFilter \"  ,     . MockFilter . class )  ;", "wac . refresh (  )  ;", "sc . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wac . getBean (  \" targetFilter \"  )  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyWithLazyContextStartup"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . registerSingleton (  \" targetFilter \"  ,     . MockFilter . class )  ;", "wac . refresh (  )  ;", "sc . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wac . getBean (  \" targetFilter \"  )  )  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy (  \" targetFilter \"  )  ;", "filterProxy . init ( new   MockFilterConfig ( sc )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyWithTargetBeanName"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "filterProxy    =    new    (  \" targetFilter \"  ,    null )  ;", "filterProxy . init ( new   MockFilterConfig ( sc )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyWithTargetBeanNameAndNoApplicationContext"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . registerSingleton (  \" targetFilter \"  ,     . MockFilter . class )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy (  \" targetFilter \"  ,    wac )  ;", "filterProxy . init ( new   MockFilterConfig ( sc )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wac . getBean (  \" targetFilter \"  )  )  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyWithTargetBeanNameAndNotYetRefreshedApplicationContext"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "ServletContext   sc    =    new   MockServletContext (  )  ;", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( sc )  ;", "wac . registerSingleton (  \" targetFilter \"  ,     . MockFilter . class )  ;", "wac . refresh (  )  ;", "sc . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", ". MockFilter   targetFilter    =     (  (  . MockFilter )     ( wac . getBean (  \" targetFilter \"  )  )  )  ;", "MockFilterConfig   proxyConfig    =    new   MockFilterConfig ( sc )  ;", "proxyConfig . addInitParameter (  \" targetBeanName \"  ,     \" targetFilter \"  )  ;", "proxyConfig . addInitParameter (  \" targetFilterLifecycle \"  ,     \" true \"  )  ;", "DelegatingFilterProxy   filterProxy    =    new   DelegatingFilterProxy (  )  ;", "filterProxy . init ( proxyConfig )  ;", "assertEquals ( proxyConfig ,    targetFilter . filterConfig )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filterProxy . doFilter ( request ,    response ,    null )  ;", "assertEquals ( proxyConfig ,    targetFilter . filterConfig )  ;", "assertEquals ( Boolean . TRUE ,    request . getAttribute (  \" called \"  )  )  ;", "filterProxy . destroy (  )  ;", "assertNull ( targetFilter . filterConfig )  ;", "}", "METHOD_END"], "methodName": ["testDelegatingFilterProxyWithTargetFilterLifecycle"], "fileName": "org.springframework.web.filter.DelegatingFilterProxyTests"}, {"methodBody": ["METHOD_START", "{", "this . relativeRedirects    =    relativeRedirects ;", "}", "METHOD_END"], "methodName": ["setRelativeRedirects"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "this . removeOnly    =    removeOnly ;", "}", "METHOD_END"], "methodName": ["setRemoveOnly"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "this . request    =    new   MockHttpServletRequest (  )     {", "@ Override", "public   String   getHeader ( String   header )     {", "Enumeration < String >    names    =    getHeaderNames (  )  ;", "while    ( names . hasMoreElements (  )  )     {", "String   name    =    names . nextElement (  )  ;", "if    ( name . equals ( header )  )     {", "return   super . getHeader ( header )  ;", "}", "}", "return   null ;", "}", "}  ;", "this . request . addHeader (  . X _ FORWARDED _ PREFIX ,     \"  / prefix \"  )  ;", "this . request . setRequestURI (  \"  / path \"  )  ;", "HttpServletRequest   actual    =    filterAndGetWrappedRequest (  )  ;", "assertEquals (  \"  / prefix / path \"  ,    actual . getRequestURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["caseInsensitiveForwardedPrefix"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  \"  )  ;", "assertEquals (  \"  \"  ,    filterAndGetContextPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathEmpty"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setContextPath (  \"  / app %  2  0  \"  )  ;", "this . request . setRequestURI (  \"  / app %  2  0  / path /  \"  )  ;", "HttpServletRequest   actual    =    AndGetWrappedRequest (  )  ;", "assertEquals (  \"  / app %  2  0  \"  ,    actual . getContextPath (  )  )  ;", "assertEquals (  \"  / app %  2  0  / path /  \"  ,    actual . getRequestURI (  )  )  ;", "assertEquals (  \" http :  /  / localhost / app %  2  0  / path /  \"  ,    actual . getRequestURL (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathPreserveEncoding"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  / prefix \"  )  ;", "this . request . setContextPath (  \"  / mvc - showcase \"  )  ;", "String   actual    =    filterAndGetContextPath (  )  ;", "assertEquals (  \"  / prefix \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["contextPathWithForwardedPrefix"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  / prefix /  \"  )  ;", "this . request . setContextPath (  \"  / mvc - showcase \"  )  ;", "String   actual    =    filterAndGetContextPath (  )  ;", "assertEquals (  \"  / prefix \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["contextPathWithForwardedPrefixTrailingSlash"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  / foo / bar /  \"  )  ;", "assertEquals (  \"  / foo / bar \"  ,    filterAndGetContextPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathWithTrailingSlash"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  / foo / bar / baz /  /  /  \"  )  ;", "assertEquals (  \"  / foo / bar / baz \"  ,    filterAndGetContextPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextPathWithTrailingSlashes"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   Chain    =    new   MockFilterChain ( new   HttpServlet (  )     {  }  ,    s )  ;", "Chain . doFilter ( request ,    response )  ;", "return   response ;", "}", "METHOD_END"], "methodName": ["doWithFiltersAndGetResponse"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "return   filterAndGetWrappedRequest (  )  . getContextPath (  )  ;", "}", "METHOD_END"], "methodName": ["filterAndGetContextPath"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "thisdoFilterInternal ( this . request ,    response ,    thishain )  ;", "return    (  ( HttpServletRequest )     ( thishain . getRequest (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["filterAndGetWrappedRequest"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "this . request . addHeader (  . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader (  . X _ FORWARDED _ HOST ,     \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  )  ;", "this . request . addHeader (  . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "this . request . addHeader (  \" foo \"  ,     \" bar \"  )  ;", "this . filter . doFilter ( this . request ,    new   MockHttpServletResponse (  )  ,    this . filterChain )  ;", "HttpServletRequest   actual    =     (  ( HttpServletRequest )     ( this . filterChain . getRequest (  )  )  )  ;", "assertEquals (  \" https :  /  /  8  4  .  1  9  8  .  5  8  .  1  9  9  / mvc - showcase \"  ,    actual . getRequestURL (  )  . toString (  )  )  ;", "assertEquals (  \" https \"  ,    actual . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    actual . getServerName (  )  )  ;", "assertEquals (  4  4  3  ,    actual . getServerPort (  )  )  ;", "assertTrue ( actual . isSecure (  )  )  ;", "assertNull ( actual . getHeader (  . X _ FORWARDED _ PROTO )  )  ;", "assertNull ( actual . getHeader (  . X _ FORWARDED _ HOST )  )  ;", "assertNull ( actual . getHeader (  . X _ FORWARDED _ PORT )  )  ;", "assertEquals (  \" bar \"  ,    actual . getHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forwardedRequest"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "this . request . addHeader (  . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader (  . X _ FORWARDED _ HOST ,     \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  )  ;", "this . request . addHeader (  . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "this . request . addHeader (  \" foo \"  ,     \" bar \"  )  ;", "this . filter . setRemoveOnly ( true )  ;", "this . filter . doFilter ( this . request ,    new   MockHttpServletResponse (  )  ,    this . filterChain )  ;", "HttpServletRequest   actual    =     (  ( HttpServletRequest )     ( this . filterChain . getRequest (  )  )  )  ;", "assertEquals (  \" http :  /  / localhost / mvc - showcase \"  ,    actual . getRequestURL (  )  . toString (  )  )  ;", "assertEquals (  \" http \"  ,    actual . getScheme (  )  )  ;", "assertEquals (  \" localhost \"  ,    actual . getServerName (  )  )  ;", "assertEquals (  8  0  ,    actual . getServerPort (  )  )  ;", "assertFalse ( actual . isSecure (  )  )  ;", "assertNull ( actual . getHeader (  . X _ FORWARDED _ PROTO )  )  ;", "assertNull ( actual . getHeader (  . X _ FORWARDED _ HOST )  )  ;", "assertNull ( actual . getHeader (  . X _ FORWARDED _ PORT )  )  ;", "assertEquals (  \" bar \"  ,    actual . getHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forwardedRequestInRemoveOnlyMode"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  / prefix /  \"  )  ;", "this . request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "HttpServletRequest   actual    =    filterAndGetWrappedRequest (  )  ;", "actual . getRequestURL (  )  . append (  \"  ? key = value \"  )  ;", "assertEquals (  \" http :  /  / localhost / prefix / mvc - showcase \"  ,    actual . getRequestURL (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestURLNewStringBuffer"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  /  \"  )  ;", "this . request . setContextPath (  \"  / app \"  )  ;", "this . request . setRequestURI (  \"  / app / path \"  )  ;", "HttpServletRequest   actual    =    filterAndGetWrappedRequest (  )  ;", "assertEquals (  \"  \"  ,    actual . getContextPath (  )  )  ;", "assertEquals (  \"  / path \"  ,    actual . getRequestURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUri"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  /  \"  )  ;", "this . request . setContextPath (  \"  / app \"  )  ;", "this . request . setRequestURI (  \"  / app \"  )  ;", "HttpServletRequest   actual    =    filterAndGetWrappedRequest (  )  ;", "assertEquals (  \"  \"  ,    actual . getContextPath (  )  )  ;", "assertEquals (  \"  /  \"  ,    actual . getRequestURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriEqualsContextPath"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setContextPath (  \"  / app \"  )  ;", "this . request . setRequestURI (  \"  / app / path %  2  0 with %  2  0 spaces /  \"  )  ;", "HttpServletRequest   actual    =    AndGetWrappedRequest (  )  ;", "assertEquals (  \"  / app \"  ,    actual . getContextPath (  )  )  ;", "assertEquals (  \"  / app / path %  2  0 with %  2  0 spaces /  \"  ,    actual . getRequestURI (  )  )  ;", "assertEquals (  \" http :  /  / localhost / app / path %  2  0 with %  2  0 spaces /  \"  ,    actual . getRequestURL (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriPreserveEncoding"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setContextPath (  \"  \"  )  ;", "this . request . setRequestURI (  \"  / path ; a = b / with / semicolon \"  )  ;", "HttpServletRequest   actual    =    AndGetWrappedRequest (  )  ;", "assertEquals (  \"  \"  ,    actual . getContextPath (  )  )  ;", "assertEquals (  \"  / path ; a = b / with / semicolon \"  ,    actual . getRequestURI (  )  )  ;", "assertEquals (  \" http :  /  / localhost / path ; a = b / with / semicolon \"  ,    actual . getRequestURL (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriPreserveSemicolonContent"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  /  \"  )  ;", "this . request . setContextPath (  \"  / app \"  )  ;", "this . request . setRequestURI (  \"  / app /  \"  )  ;", "HttpServletRequest   actual    =    filterAndGetWrappedRequest (  )  ;", "assertEquals (  \"  \"  ,    actual . getContextPath (  )  )  ;", "assertEquals (  \"  /  \"  ,    actual . getRequestURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriRootUrl"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  / prefix \"  )  ;", "this . request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "HttpServletRequest   actual    =    filterAndGetWrappedRequest (  )  ;", "assertEquals (  \" http :  /  / localhost / prefix / mvc - showcase \"  ,    actual . getRequestURL (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriWithForwardedPrefix"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  / prefix /  \"  )  ;", "this . request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "HttpServletRequest   actual    =    filterAndGetWrappedRequest (  )  ;", "assertEquals (  \" http :  /  / localhost / prefix / mvc - showcase \"  ,    actual . getRequestURL (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriWithForwardedPrefixTrailingSlash"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PREFIX ,     \"  /  \"  )  ;", "this . request . setContextPath (  \"  / app \"  )  ;", "this . request . setRequestURI (  \"  / app / path /  \"  )  ;", "HttpServletRequest   actual    =    filterAndGetWrappedRequest (  )  ;", "assertEquals (  \"  \"  ,    actual . getContextPath (  )  )  ;", "assertEquals (  \"  / path /  \"  ,    actual . getRequestURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestUriWithTrailingSlash"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "Filter    =    new   OncePerRequestFilter (  )     {", "@ Override", "protected   void   doFilterInternal ( HttpServletRequest   req ,    HttpServletResponse   res ,    FilterChain   chain )    throws   IOException    {", "res . sendRedirect ( location )  ;", "}", "}  ;", "MockHttpServletResponse   response    =    doWithFiltersAndGetResponse ( this ,  )  ;", "return   response . getRedirectedUrl (  )  ;", "}", "METHOD_END"], "methodName": ["sendRedirect"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . filter . setRelativeRedirects ( true )  ;", "String   location    =    sendRedirect (  \"  / a \"  )  ;", "assertEquals (  \"  / a \"  ,    location )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWhenRequestOnlyAndNoXForwardedThenUsesRelativeRedirects"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "this . filter . setRelativeRedirects ( true )  ;", "String   location    =    sendRedirect (  \"  / a \"  )  ;", "assertEquals (  \"  / a \"  ,    location )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWhenRequestOnlyAndXForwardedThenUsesRelativeRedirects"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "String   redirectedUrl    =    sendRedirect (  \"  / foo / bar \"  )  ;", "assertEquals (  \" https :  /  / example . com / foo / bar \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithAbsolutePath"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "this . request . setQueryString (  \" oldqp =  1  \"  )  ;", "String   redirectedUrl    =    sendRedirect (  \"  / foo / bar ? newqp =  2  # fragment \"  )  ;", "assertEquals (  \" https :  /  / example . com / foo / bar ? newqp =  2  # fragment \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithAbsolutePathQueryParamAndFragment"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "this . request . setContextPath (  \"  / context \"  )  ;", "String   redirectedUrl    =    sendRedirect (  \"  / context / foo / bar \"  )  ;", "assertEquals (  \" https :  /  / example . com / context / foo / bar \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithContextPath"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "this . request . setRequestURI (  \"  / context / a \"  )  ;", "String   redirectedUrl    =    sendRedirect (  \" foo / bar \"  )  ;", "assertEquals (  \" https :  /  / example . com / context / foo / bar \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithFileInPathAndRelativeRedirect"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "String   redirectedUrl    =    sendRedirect (  \" parent /  .  .  / foo / bar \"  )  ;", "assertEquals (  \" https :  /  / example . com / foo / bar \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithLocationDotDotPath"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "String   location    =     \" http :  /  / other . info / foo / bar \"  ;", "String   redirectedUrl    =    sendRedirect ( location )  ;", "assertEquals ( location ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithLocationHasScheme"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "String   location    =     \"  /  / other . info / foo / bar \"  ;", "String   redirectedUrl    =    sendRedirect ( location )  ;", "assertEquals (  (  \" https :  \"     +    location )  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithLocationSlashSlash"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "String   location    =     \"  /  / other . info / parent /  .  .  / foo / bar \"  ;", "String   redirectedUrl    =    sendRedirect ( location )  ;", "assertEquals (  (  \" https :  \"     +    location )  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithLocationSlashSlashParentDotDot"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "String   redirectedUrl    =    sendRedirect (  \"  / foo / bar \"  )  ;", "assertEquals (  \"  / foo / bar \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithNoXForwardedAndAbsolutePath"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "String   redirectedUrl    =    sendRedirect (  \"  .  .  / foo / bar \"  )  ;", "assertEquals (  \"  .  .  / foo / bar \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithNoXForwardedAndDotDotPath"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "this . request . setRequestURI (  \"  / parent /  \"  )  ;", "String   redirectedUrl    =    sendRedirect (  \" foo / bar \"  )  ;", "assertEquals (  \" https :  /  / example . com / parent / foo / bar \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithRelativePath"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PROTO ,     \" https \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ HOST ,     \" example . com \"  )  ;", "this . request . addHeader ( ForwardedHeaderFilterTests . X _ FORWARDED _ PORT ,     \"  4  4  3  \"  )  ;", "this . request . setRequestURI (  \"  / parent \"  )  ;", "String   redirectedUrl    =    sendRedirect (  \" foo / bar \"  )  ;", "assertEquals (  \" https :  /  / example . com / foo / bar \"  ,    redirectedUrl )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectWithRelativePathIgnoresFile"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . request    =    new   MockHttpServletRequest (  )  ;", "this . request . setScheme (  \" http \"  )  ;", "this . request . setServerName (  \" localhost \"  )  ;", "this . request . setServerPort (  8  0  )  ;", "thisChain    =    new   MockFilterChain ( new   HttpServlet (  )     {  }  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "testShouldFilter (  \" Forwarded \"  )  ;", "testShouldFilter (  . X _ FORWARDED _ HOST )  ;", "testShouldFilter (  . X _ FORWARDED _ PORT )  ;", "testShouldFilter (  . X _ FORWARDED _ PROTO )  ;", "}", "METHOD_END"], "methodName": ["shouldFilter"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . filter . shouldNotFilter ( new   MockHttpServletRequest (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldNotFilter"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader ( headerName ,     \"  1  \"  )  ;", "assertFalse ( thisshouldNotFilter ( request )  )  ;", "}", "METHOD_END"], "methodName": ["testShouldFilter"], "fileName": "org.springframework.web.filter.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . requiredProperties . add ( property )  ;", "}", "METHOD_END"], "methodName": ["addRequiredProperty"], "fileName": "org.springframework.web.filter.GenericFilterBean"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardServletEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["createEnvironment"], "fileName": "org.springframework.web.filter.GenericFilterBean"}, {"methodBody": ["METHOD_START", "{", "return   this . filterConfig ;", "}", "METHOD_END"], "methodName": ["getFilterConfig"], "fileName": "org.springframework.web.filter.GenericFilterBean"}, {"methodBody": ["METHOD_START", "{", "return    ( this . filterConfig )     !  =    null    ?    this . filterConfig . getFilterName (  )     :    this . beanName ;", "}", "METHOD_END"], "methodName": ["getFilterName"], "fileName": "org.springframework.web.filter.GenericFilterBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . filterConfig )     !  =    null )     {", "return   this . filterConfig . getServletContext (  )  ;", "} else", "if    (  ( this . servletContext )     !  =    null )     {", "return   this . servletContext ;", "} else    {", "throw   new   IllegalStateException (  \" No   ServletContext \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["getServletContext"], "fileName": "org.springframework.web.filter.GenericFilterBean"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( methodParam ,     \"  ' methodParam '    must   not   be   empty \"  )  ;", "this . methodParam    =    methodParam ;", "}", "METHOD_END"], "methodName": ["setMethodParam"], "fileName": "org.springframework.web.filter.HiddenHttpMethodFilter"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =    new   FilterChain (  )     {", "@ Override", "public   void   doFilter ( ServletRequest   equest ,    ServletResponse   esponse )    throws   IOException ,    ServletException    {", "assertEquals (  \" Invalid   method \"  ,     \" POST \"  ,     (  ( HttpServletRequest )     ( equest )  )  . getMethod (  )  )  ;", "}", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "}", "METHOD_END"], "methodName": ["filterWithNoParameter"], "fileName": "org.springframework.web.filter.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "request . addParameter (  \"  _ method \"  ,     \" delete \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =    new   FilterChain (  )     {", "@ Override", "public   void   doFilter ( ServletRequest   equest ,    ServletResponse   esponse )    throws   IOException ,    ServletException    {", "assertEquals (  \" Invalid   method \"  ,     \" DELETE \"  ,     (  ( HttpServletRequest )     ( equest )  )  . getMethod (  )  )  ;", "}", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "}", "METHOD_END"], "methodName": ["filterWithParameter"], "fileName": "org.springframework.web.filter.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . formConverter ;", "}", "METHOD_END"], "methodName": ["getFormConverter"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilter"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =    request . getContentType (  )  ;", "if    ( contentType    !  =    null )     {", "try    {", "MediaType   mediaType    =    MediaType . parseMediaType ( contentType )  ;", "return   MediaType . APPLICATION _ FORM _ URLENCODED . includes ( mediaType )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "return   false ;", "}", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isFormContentType"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilter"}, {"methodBody": ["METHOD_START", "{", "this . formConverter . setCharset ( charset )  ;", "}", "METHOD_END"], "methodName": ["setCharset"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( converter ,     \" FormHttpMessageConverter   is   required .  \"  )  ;", "this . fverter    =    converter ;", "}", "METHOD_END"], "methodName": ["setFormConverter"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilter"}, {"methodBody": ["METHOD_START", "{", "request . setContent (  \" name = value \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertEquals (  \" value \"  ,    filterChain . getRequest (  )  . getParameter (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . addParameter (  \" name \"  ,     \" value 1  \"  )  ;", "request . set (  \" name = value 2  \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertNotSame (  \" Request   not   wrapped \"  ,    request ,    filterChain . getRequest (  )  )  ;", "assertEquals (  \" Query   string   parameters   should   be   listed   ahead   of   form   parameters \"  ,     \" value 1  \"  ,    filterChain . getRequest (  )  . getParameter (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getParameterFromQueryString"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . setQueryString (  \" name = value 1  & name = value 2  \"  )  ;", "request . addParameter (  \" name \"  ,     \" value 1  \"  )  ;", "request . addParameter (  \" name \"  ,     \" value 2  \"  )  ;", "request . set (  \" name = value 3  & name 4  = value 4  \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "Map < String ,    String [  ]  >    parameters    =    filterChain . getRequest (  )  . getParameterMap (  )  ;", "assertNotSame (  \" Request   not   wrapped \"  ,    request ,    filterChain . getRequest (  )  )  ;", "assertEquals (  2  ,    parameters . size (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" value 1  \"  ,     \" value 2  \"  ,     \" value 3  \"     }  ,    parameters . get (  \" name \"  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" value 4  \"     }  ,    parameters . get (  \" name 4  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getParameterMap"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . addParameter (  \" name 1  \"  ,     \" value 1  \"  )  ;", "request . addParameter (  \" name 2  \"  ,     \" value 2  \"  )  ;", "request . set (  \" name 1  = value 1  & name 3  = value 3  & name 4  = value 4  \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "List < String >    names    =    Collections . list ( filterChain . getRequest (  )  . getParameterNames (  )  )  ;", "assertNotSame (  \" Request   not   wrapped \"  ,    request ,    filterChain . getRequest (  )  )  ;", "assertEquals ( Arrays . asList (  \" name 1  \"  ,     \" name 2  \"  ,     \" name 3  \"  ,     \" name 4  \"  )  ,    names )  ;", "}", "METHOD_END"], "methodName": ["getParameterNames"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . setContent (  \" name = value \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertNotSame (  \" Request   not   wrapped \"  ,    request ,    filterChain . getRequest (  )  )  ;", "assertNull ( filterChain . getRequest (  )  . getParameter (  \" noSuchParam \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getParameterNullValue"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . setQueryString (  \" name = value 1  & name = value 2  \"  )  ;", "request . addParameter (  \" name \"  ,     \" value 1  \"  )  ;", "request . addParameter (  \" name \"  ,     \" value 2  \"  )  ;", "request . set (  \" name = value 3  & name = value 4  \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "String [  ]    values    =    filterChain . getRequest (  )  . getParameterValues (  \" name \"  )  ;", "assertNotSame (  \" Request   not   wrapped \"  ,    request ,    filterChain . getRequest (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" value 1  \"  ,     \" value 2  \"  ,     \" value 3  \"  ,     \" value 4  \"     }  ,    values )  ;", "}", "METHOD_END"], "methodName": ["getParameterValues"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . addParameter (  \" name \"  ,     \" value 1  \"  )  ;", "request . addParameter (  \" name \"  ,     \" value 2  \"  )  ;", "request . set (  \" anotherName = anotherValue \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "String [  ]    values    =    filterChain . getRequest (  )  . getParameterValues (  \" anotherName \"  )  ;", "assertNotSame (  \" Request   not   wrapped \"  ,    request ,    filterChain . getRequest (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" anotherValue \"     }  ,    values )  ;", "}", "METHOD_END"], "methodName": ["getParameterValuesFromFormContent"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . setQueryString (  \" name = value 1  & name = value 2  \"  )  ;", "request . addParameter (  \" name \"  ,     \" value 1  \"  )  ;", "request . addParameter (  \" name \"  ,     \" value 2  \"  )  ;", "request . set (  \" anotherName = anotherValue \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "String [  ]    values    =    filterChain . getRequest (  )  . getParameterValues (  \" name \"  )  ;", "assertNotSame (  \" Request   not   wrapped \"  ,    request ,    filterChain . getRequest (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" value 1  \"  ,     \" value 2  \"     }  ,    values )  ;", "}", "METHOD_END"], "methodName": ["getParameterValuesFromQueryString"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . addParameter (  \" name \"  ,     \" value 1  \"  )  ;", "request . addParameter (  \" name \"  ,     \" value 2  \"  )  ;", "request . set (  \" anotherName = anotherValue \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "String [  ]    values    =    filterChain . getRequest (  )  . getParameterValues (  \" noSuchParameter \"  )  ;", "assertNotSame (  \" Request   not   wrapped \"  ,    request ,    filterChain . getRequest (  )  )  ;", "assertNull ( values )  ;", "}", "METHOD_END"], "methodName": ["getParameterValuesInvalidName"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . addParameter (  \"  _ method \"  ,     \" PUT \"  )  ;", "request . addParameter (  \" hiddenField \"  ,     \" testHidden \"  )  ;", "doFilter ( request ,    response ,    hain )  ;", "assertArrayEquals ( new   String [  ]  {     \" testHidden \"     }  ,    hain . getRequest (  )  . getParameterValues (  \" hiddenField \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hiddenHttpMethodFilterFollowedByHttpPutFormContentFilter"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . setContent (  \"  \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "request . setContentType (  \" foo \"  )  ;", "filterChain    =    new   MockFilterChain (  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertSame ( request ,    filterChain . getRequest (  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidMediaType"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "filter    =    new   HttpPutFormContentFilter (  )  ;", "request    =    new   MockHttpServletRequest (  \" PUT \"  ,     \"  /  \"  )  ;", "request . addHeader (  \" Content - Type \"  ,     \" application / x - www - form - urlencoded ;    charset = ISO -  8  8  5  9  -  1  \"  )  ;", "request . setContentType (  \" application / x - www - form - urlencoded ;    charset = ISO -  8  8  5  9  -  1  \"  )  ;", "response    =    new   MockHttpServletResponse (  )  ;", "filterChain    =    new   MockFilterChain (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . setContent (  \"  \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "String [  ]    contentTypes    =    new   String [  ]  {     \" text / plain \"  ,     \" multipart / form - data \"     }  ;", "for    ( String   contentType    :    contentTypes )     {", "request . setContentType ( contentType )  ;", "filterChain    =    new   MockFilterChain (  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertSame (  (  \" Should   not   wrap   for   content   type    \"     +    contentType )  ,    request ,    filterChain . getRequest (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["wrapFormEncodedOnly"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "request . setContent (  \" foo = bar \"  . getBytes (  \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "for    ( HttpMethod   method    :    HttpMethod . values (  )  )     {", "request . setMethod ( method . name (  )  )  ;", "filterChain    =    new   MockFilterChain (  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "if    (  ( method    =  =     ( HttpMethod . PUT )  )     |  |     ( method    =  =     ( HttpMethod . PATCH )  )  )     {", "assertNotSame (  (  \" Should   wrap   HTTP   method    \"     +    method )  ,    request ,    filterChain . getRequest (  )  )  ;", "} else    {", "assertSame (  (  \" Should   not   wrap   for   HTTP   method    \"     +    method )  ,    request ,    filterChain . getRequest (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["wrapPutAndPatchOnly"], "fileName": "org.springframework.web.filter.HttpPutFormContentFilterTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =    getFilterName (  )  ;", "if    ( name    =  =    null )     {", "name    =    getClass (  )  . getName (  )  ;", "}", "return   name    +     (  . ALREADY _ FILTERED _ SUFFIX )  ;", "}", "METHOD_END"], "methodName": ["getAlreadyFilteredAttributeName"], "fileName": "org.springframework.web.filter.OncePerRequestFilter"}, {"methodBody": ["METHOD_START", "{", "return   WebAsyncUtils . getAsyncManager ( request )  . hasConcurrentResult (  )  ;", "}", "METHOD_END"], "methodName": ["isAsyncDispatch"], "fileName": "org.springframework.web.filter.OncePerRequestFilter"}, {"methodBody": ["METHOD_START", "{", "return   WebAsyncUtils . getAsyncManager ( request )  . isConcurrentHandlingStarted (  )  ;", "}", "METHOD_END"], "methodName": ["isAsyncStarted"], "fileName": "org.springframework.web.filter.OncePerRequestFilter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldNotFilter"], "fileName": "org.springframework.web.filter.OncePerRequestFilter"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldNotFilterAsyncDispatch"], "fileName": "org.springframework.web.filter.OncePerRequestFilter"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldNotFilterErrorDispatch"], "fileName": "org.springframework.web.filter.OncePerRequestFilter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isAsyncDispatch ( request )  )     &  &     ( shouldNotFilterAsyncDispatch (  )  )  )     {", "return   true ;", "}", "if    (  (  ( request . getAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  )     !  =    null )     &  &     ( shouldNotFilterErrorDispatch (  )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["skipDispatch"], "fileName": "org.springframework.web.filter.OncePerRequestFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . redirectStatus ;", "}", "METHOD_END"], "methodName": ["getRedirectStatus"], "fileName": "org.springframework.web.filter.RelativeRedirectFilter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( status ,     \" Property    ' redirectStatus '    is   required \"  )  ;", "Assert . isTrue ( status . is 3 xxion (  )  ,     \" Not   a   redirect   status   code \"  )  ;", "this . redirectStatus    =    status ;", "}", "METHOD_END"], "methodName": ["setRedirectStatus"], "fileName": "org.springframework.web.filter.RelativeRedirectFilter"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \"  / foo \"  ;", "HttpStatus   status    =    HttpStatus . MOVED _ PERMANENTLY ;", "thissetRedirectStatus ( status )  ;", "sendRedirect ( location )  ;", "InOrder   inOrder    =    Mockito . inOrder ( this . response )  ;", "inOrder . verify ( this . response )  . setStatus ( status . value (  )  )  ;", "inOrder . verify ( this . response )  . setHeader ( HttpHeaders . LOCATION ,    location )  ;", "}", "METHOD_END"], "methodName": ["doFilterSendRedirectWhenCustomSendRedirectHttpStatusThenLocationAnd301"], "fileName": "org.springframework.web.filter.RelativeRedirectFilterTests"}, {"methodBody": ["METHOD_START", "{", "String   location    =     \"  / foo \"  ;", "send ( location )  ;", "InOrder   inOrder    =    Mockito . inOrder ( this . response )  ;", "inOrder . verify ( this . response )  . setStatus ( HttpStatus . SEE _ OTHER . value (  )  )  ;", "inOrder . verify ( this . response )  . setHeader ( HttpHeaders . LOCATION ,    location )  ;", "}", "METHOD_END"], "methodName": ["doFilterSendRedirectWhenDefaultsThenLocationAnd303"], "fileName": "org.springframework.web.filter.RelativeRedirectFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockFilterChain   chain    =    new   MockFilterChain (  )  ;", "thisdoFilterInternal ( new   MockHttpServletRequest (  )  ,    this . response ,    chain )  ;", "HttpServletResponse   wrappedResponse    =     (  ( HttpServletResponse )     ( chain . getResponse (  )  )  )  ;", "wrappedResponse . sendRedirect ( location )  ;", "}", "METHOD_END"], "methodName": ["sendRedirect"], "fileName": "org.springframework.web.filter.RelativeRedirectFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . filter . setRedirectStatus ( HttpStatus . OK )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectHttpStatusWhenNot3xxThenIllegalArgumentException"], "fileName": "org.springframework.web.filter.RelativeRedirectFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . filter . setRedirectStatus ( null )  ;", "}", "METHOD_END"], "methodName": ["sendRedirectHttpStatusWhenNullThenIllegalArgumentException"], "fileName": "org.springframework.web.filter.RelativeRedirectFilterTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletResponse   original    =    new   MockHttpServletResponse (  )  ;", "MockFilterChain   chain    =    new   MockFilterChain (  )  ;", "thisdoFilterInternal ( new   MockHttpServletRequest (  )  ,    original ,    chain )  ;", "HttpServletResponse   wrapped 1     =     (  ( HttpServletResponse )     ( chain . getResponse (  )  )  )  ;", "assertNotSame ( original ,    wrapped 1  )  ;", "chain . reset (  )  ;", "thisdoFilterInternal ( new   MockHttpServletRequest (  )  ,    wrapped 1  ,    chain )  ;", "HttpServletResponse   current    =     (  ( HttpServletResponse )     ( chain . getResponse (  )  )  )  ;", "assertSame ( wrapped 1  ,    current )  ;", "chain . reset (  )  ;", "HttpServletResponse   wrapped 2     =    new   HttpServletResponseWrapper ( wrapped 1  )  ;", "thisdoFilterInternal ( new   MockHttpServletRequest (  )  ,    wrapped 2  ,    chain )  ;", "current    =     (  ( HttpServletResponse )     ( chain . getResponse (  )  )  )  ;", "assertSame ( wrapped 2  ,    current )  ;", "}", "METHOD_END"], "methodName": ["wrapOnceOnly"], "fileName": "org.springframework.web.filter.RelativeRedirectFilterTests"}, {"methodBody": ["METHOD_START", "{", "RelativeRedirectResponseWrapper   wrapper    =    WebUtils . getNativeResponse ( response ,    RelativeRedirectResponseWrapper . class )  ;", "return   wrapper    !  =    null    ?    response    :    new   RelativeRedirectResponseWrapper ( response ,    redirectStatus )  ;", "}", "METHOD_END"], "methodName": ["wrapIfNecessary"], "fileName": "org.springframework.web.filter.RelativeRedirectResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( request . getLocale (  )  ,    this . threadContextInheritable )  ;", "Holder . setRequestAttributes ( requestAttributes ,    this . threadContextInheritable )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Bound   request   context   to   thread :     \"     +    request )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initContextHolders"], "fileName": "org.springframework.web.filter.RequestContextFilter"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . resetLocaleContext (  )  ;", "Holder . resetRequestAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["resetContextHolders"], "fileName": "org.springframework.web.filter.RequestContextFilter"}, {"methodBody": ["METHOD_START", "{", "this . threadContextInheritable    =    threadContextInheritable ;", "}", "METHOD_END"], "methodName": ["setThreadContextInheritable"], "fileName": "org.springframework.web.filter.RequestContextFilter"}, {"methodBody": ["METHOD_START", "{", "testFilterInvocation ( null )  ;", "}", "METHOD_END"], "methodName": ["happyPath"], "fileName": "org.springframework.web.filter.RequestContextFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   req    =    new   MockHttpServletRequest (  )  ;", "req . setAttribute (  \" myAttr \"  ,     \" myValue \"  )  ;", "final   MockHttpServletResponse   resp    =    new   MockHttpServletResponse (  )  ;", "class   DummyFilterChain   implements   FilterChain    {", "public   int   invocations    =     0  ;", "@ Override", "public   void   doFilter ( ServletRequest   req ,    ServletResponse   resp )    throws   IOException ,    ServletException    {", "+  +  ( invocations )  ;", "if    (  ( invocations )     =  =     1  )     {", "assertSame (  \" myValue \"  ,    RequestContextHolder . currentRequestAttributes (  )  . getAttribute (  \" myAttr \"  ,    RequestAttributes . SCOPE _ REQUEST )  )  ;", "if    ( sex    !  =    null )     {", "throw   sex ;", "}", "} else    {", "throw   new   IllegalStateException (  \" Too   many   invocations \"  )  ;", "}", "}", "}", "DummyFilterChain   fc    =    new   DummyFilterChain (  )  ;", "MockFilterConfig   mfc    =    new   MockFilterConfig ( new   MockServletContext (  )  ,     \" foo \"  )  ;", "rbf    =    new    (  )  ;", "rbf . init ( mfc )  ;", "try    {", "rbf . doFilter ( req ,    resp ,    fc )  ;", "if    ( sex    !  =    null )     {", "fail (  )  ;", "}", "}    catch    ( ServletException   ex )     {", "assertNotNull ( sex )  ;", "}", "try    {", "RequestContextHolder . currentRequestAttributes (  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "assertEquals (  1  ,    fc . invocations )  ;", "}", "METHOD_END"], "methodName": ["testFilterInvocation"], "fileName": "org.springframework.web.filter.RequestContextFilterTests"}, {"methodBody": ["METHOD_START", "{", "testFilterInvocation ( new   ServletException (  )  )  ;", "}", "METHOD_END"], "methodName": ["withException"], "fileName": "org.springframework.web.filter.RequestContextFilterTests"}, {"methodBody": ["METHOD_START", "{", "filter . setIncludeQueryString ( true )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   filterChain    =    new    . NoOpFilterChain (  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertNotNull ( filter . beforeRequestMessage )  ;", "assertTrue ( filter . beforeRequestMessage . contains (  \"  [ uri =  / hotels ]  \"  )  )  ;", "assertNotNull ( filter . afterRequestMessage )  ;", "assertTrue ( filter . afterRequestMessage . contains (  \"  [ uri =  / hotels ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["noQueryStringAvailable"], "fileName": "org.springframework.web.filter.RequestLoggingFilterTests"}, {"methodBody": ["METHOD_START", "{", "filter . setIncludePayload ( true )  ;", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    requestBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "request . setContent ( requestBody )  ;", "FilterChain   filterChain    =    new   FilterChain (  )     {", "@ Override", "public   void   doFilter ( ServletRequest   filterRequest ,    ServletResponse   filterResponse )    throws   IOException ,    ServletException    {", "(  ( HttpServletResponse )     ( filterResponse )  )  . setStatus ( SC _ OK )  ;", "byte [  ]    buf    =    FileCopyUtils . copyToByteArray ( filterRequest . getInputStream (  )  )  ;", "assertArrayEquals ( requestBody ,    buf )  ;", "}", "}  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertNotNull ( filter . afterRequestMessage )  ;", "assertTrue ( filter . afterRequestMessage . contains (  \" Hello   World \"  )  )  ;", "}", "METHOD_END"], "methodName": ["payloadInputStream"], "fileName": "org.springframework.web.filter.RequestLoggingFilterTests"}, {"methodBody": ["METHOD_START", "{", "filter . setIncludePayload ( true )  ;", "filter . setMaxPayloadLength (  3  )  ;", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    requestBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "request . setContent ( requestBody )  ;", "FilterChain   filterChain    =    new   FilterChain (  )     {", "@ Override", "public   void   doFilter ( ServletRequest   filterRequest ,    ServletResponse   filterResponse )    throws   IOException ,    ServletException    {", "(  ( HttpServletResponse )     ( filterResponse )  )  . setStatus ( SC _ OK )  ;", "byte [  ]    buf    =    FileCopyUtils . copyToByteArray ( filterRequest . getInputStream (  )  )  ;", "assertArrayEquals ( requestBody ,    buf )  ;", "ContentCachingRequestWrapper   wrapper    =    WebUtils . getNativeRequest ( filterRequest ,    ContentCachingRequestWrapper . class )  ;", "assertArrayEquals (  \" Hel \"  . getBytes (  \" UTF -  8  \"  )  ,    wrapper . getContentAsByteArray (  )  )  ;", "}", "}  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertNotNull ( filter . afterRequestMessage )  ;", "assertTrue ( filter . afterRequestMessage . contains (  \" Hel \"  )  )  ;", "assertFalse ( filter . afterRequestMessage . contains (  \" Hello   World \"  )  )  ;", "}", "METHOD_END"], "methodName": ["payloadMaxLength"], "fileName": "org.springframework.web.filter.RequestLoggingFilterTests"}, {"methodBody": ["METHOD_START", "{", "filter . setIncludePayload ( true )  ;", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   String   requestBody    =     \" Hello   World \"  ;", "request . setContent ( requestBody . getBytes (  \" UTF -  8  \"  )  )  ;", "FilterChain   filterChain    =    new   FilterChain (  )     {", "@ Override", "public   void   doFilter ( ServletRequest   filterRequest ,    ServletResponse   filterResponse )    throws   IOException ,    ServletException    {", "(  ( HttpServletResponse )     ( filterResponse )  )  . setStatus ( SC _ OK )  ;", "String   buf    =    FileCopyUtils . copyToString ( filterRequest . getReader (  )  )  ;", "assertEquals ( requestBody ,    buf )  ;", "}", "}  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertNotNull ( filter . afterRequestMessage )  ;", "assertTrue ( filter . afterRequestMessage . contains ( requestBody )  )  ;", "}", "METHOD_END"], "methodName": ["payloadReader"], "fileName": "org.springframework.web.filter.RequestLoggingFilterTests"}, {"methodBody": ["METHOD_START", "{", "filter . setIncludeQueryString ( true )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "request . setQueryString (  \" booking =  4  2  \"  )  ;", "FilterChain   filterChain    =    new    . NoOpFilterChain (  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertNotNull ( filter . beforeRequestMessage )  ;", "assertTrue ( filter . beforeRequestMessage . contains (  \"  [ uri =  / hotels ? booking =  4  2  ]  \"  )  )  ;", "assertNotNull ( filter . afterRequestMessage )  ;", "assertTrue ( filter . afterRequestMessage . contains (  \"  [ uri =  / hotels ? booking =  4  2  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryStringIncluded"], "fileName": "org.springframework.web.filter.RequestLoggingFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "request . setQueryString (  \" booking =  4  2  \"  )  ;", "FilterChain   filterChain    =    new    . NoOpFilterChain (  )  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertNotNull ( filter . beforeRequestMessage )  ;", "assertTrue ( filter . beforeRequestMessage . contains (  \" uri =  / hotel \"  )  )  ;", "assertFalse ( filter . beforeRequestMessage . contains (  \" booking =  4  2  \"  )  )  ;", "assertNotNull ( filter . afterRequestMessage )  ;", "assertTrue ( filter . afterRequestMessage . contains (  \" uri =  / hotel \"  )  )  ;", "assertFalse ( filter . afterRequestMessage . contains (  \" booking =  4  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["uri"], "fileName": "org.springframework.web.filter.RequestLoggingFilterTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" ServletRequest   must   not   be   null \"  )  ;", "request . setAttribute (  . STREAMING _ ATTRIBUTE ,    true )  ;", "}", "METHOD_END"], "methodName": ["disableContentCaching"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  3  7  )  ;", "if    ( isWeak )     {", "builder . append (  \" W /  \"  )  ;", "}", "builder . append (  \"  \\  \"  0  \"  )  ;", "DigestUtils . appendMd 5 DigestAsHex ( inputStream ,    builder )  ;", "builder . append (  '  \"  '  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateETagHeaderValue"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "return    ( request . getAttribute ( ShallowEtagHeaderFilter . STREAMING _ ATTRIBUTE )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isContentCachingDisabled"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "String   method    =    request . getMethod (  )  ;", "if    (  (  ( responseStatusCode    >  =     2  0  0  )     &  &     ( responseStatusCode    <     3  0  0  )  )     &  &     ( HttpMethod . GET . matches ( method )  )  )     {", "String   cacheControl    =    response . getHeader (  . HEADER _ CACHE _ CONTROL )  ;", "return    ( cacheControl    =  =    null )     |  |     (  !  ( cacheControl . contains (  . DIRECTIVE _ NO _ STORE )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isEligibleForEtag"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . writeWeakETag ;", "}", "METHOD_END"], "methodName": ["isWriteWeakETag"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "this . writeWeakETag    =    writeWeakETag ;", "}", "METHOD_END"], "methodName": ["setWriteWeakETag"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "ContentCachingResponseWrapper   responseWrapper    =    WebUtils . getNativeResponse ( response ,    ContentCachingResponseWrapper . class )  ;", "Assert . notNull ( responseWrapper ,     \" ContentCachingResponseWrapper   not   found \"  )  ;", "HttpServletResponse   rawResponse    =     (  ( HttpServletResponse )     ( responseWrapper . getResponse (  )  )  )  ;", "int   statusCode    =    responseWrapper . getStatusCode (  )  ;", "if    ( rawResponse . isCommitted (  )  )     {", "responseWrapper . copyBodyToResponse (  )  ;", "} else", "if    ( isEligibleForEtag ( request ,    responseWrapper ,    statusCode ,    responseWrapper . getContentInputStream (  )  )  )     {", "String   responseETag    =    generateETagHeaderValue ( responseWrapper . getContentInputStream (  )  ,    this . writeWeakETag )  ;", "rawResponse . setHeader (  . HEADER _ ETAG ,    responseETag )  ;", "String   requestETag    =    request . getHeader (  . HEADER _ IF _ NONE _ MATCH )  ;", "if    (  ( requestETag    !  =    null )     &  &     (  (  (  \"  *  \"  . equals ( requestETag )  )     |  |     ( responseETag . equals ( requestETag )  )  )     |  |     ( responseETag . replaceFirst (  \"  ^ W /  \"  ,     \"  \"  )  . equals ( requestETag . replaceFirst (  \"  ^ W /  \"  ,     \"  \"  )  )  )  )  )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" ETag    [  \"     +    responseETag )     +     \"  ]    equal   to   If - None - Match ,    sending    3  0  4  \"  )  )  ;", "}", "rawResponse . setStatus ( HttpServletResponse . SC _ NOT _ MODIFIED )  ;", "} else    {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  \" ETag    [  \"     +    responseETag )     +     \"  ]    not   equal   to   If - None - Match    [  \"  )     +    requestETag )     +     \"  ]  ,    sending   normal   response \"  )  )  ;", "}", "responseWrapper . copyBodyToResponse (  )  ;", "}", "} else    {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" Response   with   status   code    [  \"     +    statusCode )     +     \"  ]    not   eligible   for   ETag \"  )  )  ;", "}", "responseWrapper . copyBodyToResponse (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateResponse"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    equest )  ;", "(  ( HttpServletResponse )     ( esponse )  )  . setStatus ( HttpServletResponse . SC _ OK )  ;", "FileCopyUtils . copy ( responseBody ,    esponse . getOutputStream (  )  )  ;", "esponse . flushBuffer (  )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" Invalid   status \"  ,     2  0  0  ,    response . getStatus (  )  )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,     \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertTrue (  \" Invalid   Content - Length   header \"  ,     (  ( response . getContentLength (  )  )     >     0  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    responseBody ,    response . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterFlushResponse"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "String   etag    =     \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ;", "request . addHeader (  \" If - None - Match \"  ,    etag )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    equest )  ;", "byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FileCopyUtils . copy ( responseBody ,    esponse . getOutputStream (  )  )  ;", "esponse . setContentLength ( responseBody . length )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" Invalid   status \"  ,     3  0  4  ,    response . getStatus (  )  )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,     \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertFalse (  \" Response   has   Content - Length   header \"  ,    response . containsHeader (  \" Content - Length \"  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    new   byte [  0  ]  ,    response . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterMatch"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "String   etag    =     \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ;", "request . addHeader (  \" If - None - Match \"  ,     (  \" W /  \"     +    etag )  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    equest )  ;", "byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FileCopyUtils . copy ( responseBody ,    esponse . getOutputStream (  )  )  ;", "esponse . setContentLength ( responseBody . length )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" Invalid   status \"  ,     3  0  4  ,    response . getStatus (  )  )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,     \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertFalse (  \" Response   has   Content - Length   header \"  ,    response . containsHeader (  \" Content - Length \"  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    new   byte [  0  ]  ,    response . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterMatchWeakEtag"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    equest )  ;", "(  ( HttpServletResponse )     ( esponse )  )  . setStatus ( HttpServletResponse . SC _ OK )  ;", "FileCopyUtils . copy ( responseBody ,    esponse . getOutputStream (  )  )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" Invalid   status \"  ,     2  0  0  ,    response . getStatus (  )  )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,     \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertTrue (  \" Invalid   Content - Length   header \"  ,     (  ( response . getContentLength (  )  )     >     0  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    responseBody ,    response . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterNoMatch"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "this . filter . setWriteWeakETag ( true )  ;", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FilterChain   filterChain    =     (    filterRequest ,    filterResponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    filterRequest )  ;", "(  ( HttpServletResponse )     ( filterResponse )  )  . setStatus ( HttpServletResponse . SC _ OK )  ;", "FileCopyUtils . copy ( responseBody ,    filterResponse . getOutputStream (  )  )  ;", "}  ;", "filter . doFilter ( request ,    response ,    filterChain )  ;", "assertEquals (  \" Invalid   status \"  ,     2  0  0  ,    response . getStatus (  )  )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,     \" W /  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertTrue (  \" Invalid   Content - Length   header \"  ,     (  ( response . getContentLength (  )  )     >     0  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    responseBody ,    response . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterNoMatchWeakETag"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    equest )  ;", "response . setContentLength (  1  0  0  )  ;", "FileCopyUtils . copy ( responseBody ,    esponse . getOutputStream (  )  )  ;", "(  ( HttpServletResponse )     ( esponse )  )  . sendError ( HttpServletResponse . SC _ FORBIDDEN )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" Invalid   status \"  ,     4  0  3  ,    response . getStatus (  )  )  ;", "assertNull (  \" Invalid   ETag   header \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertEquals (  \" Invalid   Content - Length   header \"  ,     1  0  0  ,    response . getContentLength (  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    responseBody ,    response . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterSendError"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    equest )  ;", "response . setContentLength (  1  0  0  )  ;", "FileCopyUtils . copy ( responseBody ,    esponse . getOutputStream (  )  )  ;", "(  ( HttpServletResponse )     ( esponse )  )  . sendError ( HttpServletResponse . SC _ FORBIDDEN ,     \" ERROR \"  )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" Invalid   status \"  ,     4  0  3  ,    response . getStatus (  )  )  ;", "assertNull (  \" Invalid   ETag   header \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertEquals (  \" Invalid   Content - Length   header \"  ,     1  0  0  ,    response . getContentLength (  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    responseBody ,    response . getContentAsByteArray (  )  )  ;", "assertEquals (  \" Invalid   error   message \"  ,     \" ERROR \"  ,    response . getErrorMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterSendErrorMessage"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    equest )  ;", "response . setContentLength (  1  0  0  )  ;", "FileCopyUtils . copy ( responseBody ,    esponse . getOutputStream (  )  )  ;", "(  ( HttpServletResponse )     ( esponse )  )  . sendRedirect (  \" http :  /  / www . google . com \"  )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" Invalid   status \"  ,     3  0  2  ,    response . getStatus (  )  )  ;", "assertNull (  \" Invalid   ETag   header \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertEquals (  \" Invalid   Content - Length   header \"  ,     1  0  0  ,    response . getContentLength (  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    responseBody ,    response . getContentAsByteArray (  )  )  ;", "assertEquals (  \" Invalid   redirect   URL \"  ,     \" http :  /  / www . google . com \"  ,    response . getRedirectedUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterSendRedirect"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "String   etag    =     \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ;", "request . addHeader (  \" If - None - Match \"  ,    etag )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "FilterChain   hain    =     (    equest ,    esponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    equest )  ;", "(  ( HttpServletResponse )     ( esponse )  )  . setStatus ( HttpServletResponse . SC _ OK )  ;", "String   responseBody    =     \" Hello   World \"  ;", "FileCopyUtils . copy ( responseBody ,    esponse . getWriter (  )  )  ;", "}  ;", "doFilter ( request ,    response ,    hain )  ;", "assertEquals (  \" Invalid   status \"  ,     3  0  4  ,    response . getStatus (  )  )  ;", "assertEquals (  \" Invalid   ETag   header \"  ,     \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ,    response . getHeader (  \" ETag \"  )  )  ;", "assertFalse (  \" Response   has   Content - Length   header \"  ,    response . containsHeader (  \" Content - Length \"  )  )  ;", "assertArrayEquals (  \" Invalid   content \"  ,    new   byte [  0  ]  ,    response . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWriter"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "final   MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "final   byte [  ]    responseBody    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "FilterChain   filterChain    =     (    filterRequest ,    filterResponse )     -  >     {", "assertEquals (  \" Invalid   request   passed \"  ,    request ,    filterRequest )  ;", "(  ( HttpServletResponse )     ( filterResponse )  )  . setStatus ( HttpServletResponse . SC _ OK )  ;", "FileCopyUtils . copy ( responseBody ,    filterResponse . getOutputStream (  )  )  ;", "}  ;", ". disableContentCaching ( request )  ;", "this . filter . doFilter ( request ,    response ,    filterChain )  ;", "assertEquals (  2  0  0  ,    response . getStatus (  )  )  ;", "assertNull ( response . getHeader (  \" ETag \"  )  )  ;", "assertArrayEquals ( responseBody ,    response . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWriterWithDisabledCaching"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  \" GET \"  ,     \"  / hotels \"  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "assertTrue ( isEligibleForEtag ( request ,    response ,     2  0  0  ,    StreamUtils . emptyInput (  )  )  )  ;", "assertFalse ( isEligibleForEtag ( request ,    response ,     3  0  0  ,    StreamUtils . emptyInput (  )  )  )  ;", "request    =    new   MockHttpServletRequest (  \" HEAD \"  ,     \"  / hotels \"  )  ;", "assertFalse ( isEligibleForEtag ( request ,    response ,     2  0  0  ,    StreamUtils . emptyInput (  )  )  )  ;", "request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "assertFalse ( isEligibleForEtag ( request ,    response ,     2  0  0  ,    StreamUtils . emptyInput (  )  )  )  ;", "request    =    new   MockHttpServletRequest (  \" POST \"  ,     \"  / hotels \"  )  ;", "request . addHeader (  \" Cache - Control \"  ,     \" must - revalidate ,    no - store \"  )  ;", "assertFalse ( isEligibleForEtag ( request ,    response ,     2  0  0  ,    StreamUtils . emptyInput (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEligibleForEtag"], "fileName": "org.springframework.web.filter.ShallowEtagHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =    headers . getFirst (  \" X - Forwarded - Prefix \"  )  ;", "if    ( prefix    !  =    null )     {", "while    ( prefix . endsWith (  \"  /  \"  )  )     {", "prefix    =    prefix . substring (  0  ,     (  ( prefix . length (  )  )     -     1  )  )  ;", "}", "}", "return   prefix ;", "}", "METHOD_END"], "methodName": ["getForwardedPrefix"], "fileName": "org.springframework.web.filter.reactive.ForwardedHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "this . removeOnly    =    removeOnly ;", "}", "METHOD_END"], "methodName": ["setRemoveOnly"], "fileName": "org.springframework.web.filter.reactive.ForwardedHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "for    ( String   headerName    :     . FORWARDED _ HEADER _ NAMES )     {", "if    ( headers . containsKey ( headerName )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldNotFilter"], "fileName": "org.springframework.web.filter.reactive.ForwardedHeaderFilter"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / example . com / path \"  )  . header (  \" Forwarded \"  ,     \" host =  8  4  .  1  9  8  .  5  8  .  1  9  9  ; proto = https \"  )  )  ;", "this . filter . filter ( exchange ,    this . filterChain )  . block ( Duration . ZERO )  ;", "URI   uri    =    this . filterChain . uri ;", "assertEquals ( new   URI (  \" https :  /  /  8  4  .  1  9  8  .  5  8  .  1  9  9  / path \"  )  ,    uri )  ;", "}", "METHOD_END"], "methodName": ["forwardedRequest"], "fileName": "org.springframework.web.filter.reactive.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" Forwarded \"  ,     \" for =  1  9  2  .  0  .  2  .  6  0  ; proto = http ; by =  2  0  3  .  0  .  1  1  3  .  4  3  \"  )  . header (  \" X - Forwarded - Host \"  ,     \" example . com \"  )  . header (  \" X - Forwarded - Port \"  ,     \"  8  0  8  0  \"  )  . header (  \" X - Forwarded - Proto \"  ,     \" http \"  )  . header (  \" X - Forwarded - Prefix \"  ,     \" prefix \"  )  )  ;", "this . filter . setRemoveOnly ( true )  ;", "this . filter . filter ( exchange ,    this . filterChain )  . block ( Duration . ZERO )  ;", "HttpHeaders   result    =    this . filterChain . getHeaders (  )  ;", "assertNotNull ( result )  ;", "assertFalse ( result . containsKey (  \" Forwarded \"  )  )  ;", "assertFalse ( result . containsKey (  \" X - Forwarded - Host \"  )  )  ;", "assertFalse ( result . containsKey (  \" X - Forwarded - Port \"  )  )  ;", "assertFalse ( result . containsKey (  \" X - Forwarded - Proto \"  )  )  ;", "assertFalse ( result . containsKey (  \" X - Forwarded - Prefix \"  )  )  ;", "}", "METHOD_END"], "methodName": ["removeOnly"], "fileName": "org.springframework.web.filter.reactive.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / example . com / path \"  )  . header (  \" X - Forwarded - Prefix \"  ,     \"  / prefix \"  )  )  ;", "this . filter . filter ( exchange ,    this . filterChain )  . block ( Duration . ZERO )  ;", "URI   uri    =    this . filterChain . uri ;", "assertEquals ( new   URI (  \" http :  /  / example . com / prefix / path \"  )  ,    uri )  ;", "}", "METHOD_END"], "methodName": ["requestUriWithForwardedPrefix"], "fileName": "org.springframework.web.filter.reactive.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / example . com / path \"  )  . header (  \" X - Forwarded - Prefix \"  ,     \"  / prefix /  \"  )  )  ;", "this . filter . filter ( exchange ,    this . filterChain )  . block ( Duration . ZERO )  ;", "URI   uri    =    this . filterChain . uri ;", "assertEquals ( new   URI (  \" http :  /  / example . com / prefix / path \"  )  ,    uri )  ;", "}", "METHOD_END"], "methodName": ["requestUriWithForwardedPrefixTrailingSlash"], "fileName": "org.springframework.web.filter.reactive.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / example . com / path \"  )  . header (  \" X - Forwarded - Host \"  ,     \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  )  . header (  \" X - Forwarded - Port \"  ,     \"  4  4  3  \"  )  . header (  \" X - Forwarded - Proto \"  ,     \" https \"  )  )  ;", "this . filter . filter ( exchange ,    this . filterChain )  . block ( Duration . ZERO )  ;", "URI   uri    =    this . filterChain . uri ;", "assertEquals ( new   URI (  \" https :  /  /  8  4  .  1  9  8  .  5  8  .  1  9  9  / path \"  )  ,    uri )  ;", "}", "METHOD_END"], "methodName": ["xForwardedRequest"], "fileName": "org.springframework.web.filter.reactive.ForwardedHeaderFilterTests"}, {"methodBody": ["METHOD_START", "{", "HttpMethod   httpMethod    =    HttpMethod . resolve ( methodParamValue . toUpperCase ( Locale . ENGLISH )  )  ;", "Assert . notNull ( httpMethod ,     (  )     -  >     (  \" HttpMethod    '  \"     +    methodParamValue )     +     \"  '    not   supported \"  )  ;", "return   exchange . mutate (  )  . request (  (    builder )     -  >    builder . method ( httpMethod )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["mapExchange"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilter"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( methodParamName ,     \"  ' methodParamName '    must   not   be   empty \"  )  ;", "this . methodParamName    =    methodParamName ;", "}", "METHOD_END"], "methodName": ["setMethodParamName"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilter"}, {"methodBody": ["METHOD_START", "{", "this . filter . setMethodParamName (  \"  _ foo \"  )  ;", "postForm (  \"  _ foo = DELETE \"  )  . block ( Duration . ZERO )  ;", "assertEquals (  . DELETE ,    this . filterChain . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWithDifferentMethodParam"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "postForm (  \"  _ method =  \"  )  . block ( Duration . ZERO )  ;", "assertEquals (  . POST ,    this . filterChain . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWithEmptyStringParameter"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . put (  \"  /  \"  )  . header ( HttpHeaders . CONTENT _ TYPE ,    MediaType . APPLICATION _ FORM _ URLENCODED _ VALUE )  . body (  \"  _ method = DELETE \"  )  )  ;", "this . filter . filter ( exchange ,    this . filterChain )  . block ( Duration . ZERO )  ;", "assertEquals (  . PUT ,    this . filterChain . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWithHttpPut"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( postForm (  \"  _ method = INVALID \"  )  )  . consumeErrorWith (  (    error )     -  >     {", "assertThat ( error ,    Matchers . instanceOf (  . class )  )  ;", "assertEquals (  \"     ' INVALID '    not   supported \"  ,    error . getMessage (  )  )  ;", "}  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["filterWithInvalidMethodValue"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "postForm (  \"  \"  )  . block ( Duration . ZERO )  ;", "assertEquals (  . POST ,    this . filterChain . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWithNoParameter"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "postForm (  \"  _ method = DELETE \"  )  . block ( Duration . ZERO )  ;", "assertEquals (  . DELETE ,    this . filterChain . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["filterWithParameter"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . post (  \"  /  \"  )  . header ( HttpHeaders . CONTENT _ TYPE ,    MediaType . APPLICATION _ FORM _ URLENCODED _ VALUE )  . body ( body )  )  ;", "return   thisfilter ( exchange ,    thishain )  ;", "}", "METHOD_END"], "methodName": ["postForm"], "fileName": "org.springframework.web.filter.reactive.HiddenHttpMethodFilterTests"}, {"methodBody": ["METHOD_START", "{", "NavigationHandler   decoratedNavigationHandler    =    getDecoratedNavigationHandler (  )  ;", "if    ( decoratedNavigationHandler   instanceof    )     {", "decHandler    =     (  (  )     ( decoratedNavigationHandler )  )  ;", "decHandler . handleNavigation ( facesContext ,    fromAction ,    outcome ,    originalNavigationHandler )  ;", "} else", "if    ( decoratedNavigationHandler    !  =    null )     {", "decoratedNavigationHandler . handleNavigation ( facesContext ,    fromAction ,    outcome )  ;", "} else", "if    ( originalNavigationHandler    !  =    null )     {", "originalNavigationHandler . handleNavigation ( facesContext ,    fromAction ,    outcome )  ;", "}", "}", "METHOD_END"], "methodName": ["callNextHandlerInChain"], "fileName": "org.springframework.web.jsf.DecoratingNavigationHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . decoratedNavigationHandler ;", "}", "METHOD_END"], "methodName": ["getDecoratedNavigationHandler"], "fileName": "org.springframework.web.jsf.DecoratingNavigationHandler"}, {"methodBody": ["METHOD_START", "{", "return   getWebApplicationContext ( facesContext )  ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.web.jsf.DelegatingNavigationHandlerProxy"}, {"methodBody": ["METHOD_START", "{", "String   targetBeanName    =    getTargetBeanName ( facesContext )  ;", "return   getBeanFactory ( facesContext )  . getBean ( targetBeanName ,     . class )  ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.web.jsf.DelegatingNavigationHandlerProxy"}, {"methodBody": ["METHOD_START", "{", "return   DelegatingNavigationHandlerProxy . DEFAULT _ TARGET _ BEAN _ NAME ;", "}", "METHOD_END"], "methodName": ["getTargetBeanName"], "fileName": "org.springframework.web.jsf.DelegatingNavigationHandlerProxy"}, {"methodBody": ["METHOD_START", "{", "return   FacesContextUtils . getRequiredWebApplicationContext ( facesContext )  ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.jsf.DelegatingNavigationHandlerProxy"}, {"methodBody": ["METHOD_START", "{", "DelegatingNavigationHandlerTests . TestDecoratingNavigationHandler   targetHandler    =    new   DelegatingNavigationHandlerTests . TestDecoratingNavigationHandler (  )  ;", "beanFactory . addBean (  \" jsfNavigationHandler \"  ,    targetHandler )  ;", "delNavHandler . handleNavigation ( facesContext ,     \" fromAction \"  ,     \" myViewId \"  )  ;", "assertEquals (  \" fromAction \"  ,    targetHandler . lastFromAction )  ;", "assertEquals (  \" myViewId \"  ,    targetHandler . lastOutcome )  ;", "assertEquals (  \" fromAction \"  ,    origNavHandler . lastFromAction )  ;", "assertEquals (  \" myViewId \"  ,    origNavHandler . lastOutcome )  ;", "}", "METHOD_END"], "methodName": ["handleNavigationWithDecoration"], "fileName": "org.springframework.web.jsf.DelegatingNavigationHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DelegatingNavigationHandlerTests . TestNavigationHandler   targetHandler    =    new   DelegatingNavigationHandlerTests . TestNavigationHandler (  )  ;", "beanFactory . addBean (  \" jsfNavigationHandler \"  ,    targetHandler )  ;", "delNavHandler . handleNavigation ( facesContext ,     \" fromAction \"  ,     \" myViewId \"  )  ;", "assertEquals (  \" fromAction \"  ,    targetHandler . lastFromAction )  ;", "assertEquals (  \" myViewId \"  ,    targetHandler . lastOutcome )  ;", "}", "METHOD_END"], "methodName": ["handleNavigationWithoutDecoration"], "fileName": "org.springframework.web.jsf.DelegatingNavigationHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   getWebApplicationContext ( facesContext )  ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.web.jsf.DelegatingPhaseListenerMulticaster"}, {"methodBody": ["METHOD_START", "{", "ListableBeanFactory   bf    =    getBeanFactory ( facesContext )  ;", "return   BeanFactoryUtils . beansOfTypeIncludingAncestors ( bf ,     . class ,    true ,    false )  . values (  )  ;", "}", "METHOD_END"], "methodName": ["getDelegates"], "fileName": "org.springframework.web.jsf.DelegatingPhaseListenerMulticaster"}, {"methodBody": ["METHOD_START", "{", "return   FacesContextUtils . getRequiredWebApplicationContext ( facesContext )  ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.jsf.DelegatingPhaseListenerMulticaster"}, {"methodBody": ["METHOD_START", "{", "DelegatingPhaseListenerTests . TestListener   target 1     =    new   DelegatingPhaseListenerTests . TestListener (  )  ;", "DelegatingPhaseListenerTests . TestListener   target 2     =    new   DelegatingPhaseListenerTests . TestListener (  )  ;", "beanFactory . addBean (  \" testListener 1  \"  ,    target 1  )  ;", "beanFactory . addBean (  \" testListener 2  \"  ,    target 2  )  ;", "assertEquals ( ANY _ PHASE ,    delPhaseListener . getPhaseId (  )  )  ;", "PhaseEvent   event    =    new   PhaseEvent ( facesContext ,    PhaseId . INVOKE _ APPLICATION ,    new   MockLifecycle (  )  )  ;", "delPhaseListener . beforePhase ( event )  ;", "assertTrue ( target 1  . beforeCalled )  ;", "assertTrue ( target 2  . beforeCalled )  ;", "delPhaseListener . afterPhase ( event )  ;", "assertTrue ( target 1  . afterCalled )  ;", "assertTrue ( target 2  . afterCalled )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterPhaseWithMultipleTargets"], "fileName": "org.springframework.web.jsf.DelegatingPhaseListenerTests"}, {"methodBody": ["METHOD_START", "{", "DelegatingPhaseListenerTests . TestListener   target    =    new   DelegatingPhaseListenerTests . TestListener (  )  ;", "beanFactory . addBean (  \" testListener \"  ,    target )  ;", "assertEquals ( ANY _ PHASE ,    delPhaseListener . getPhaseId (  )  )  ;", "PhaseEvent   event    =    new   PhaseEvent ( facesContext ,    PhaseId . INVOKE _ APPLICATION ,    new   MockLifecycle (  )  )  ;", "delPhaseListener . beforePhase ( event )  ;", "assertTrue ( target . beforeCalled )  ;", "delPhaseListener . afterPhase ( event )  ;", "assertTrue ( target . afterCalled )  ;", "}", "METHOD_END"], "methodName": ["beforeAndAfterPhaseWithSingleTarget"], "fileName": "org.springframework.web.jsf.DelegatingPhaseListenerTests"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   wac    =    FacesContextUtils . getWebApplicationContext ( fc )  ;", "if    ( wac    =  =    null )     {", "throw   new   IllegalStateException (  \" No   WebApplicationContext   found :    no   ContextLoaderListener   registered ?  \"  )  ;", "}", "return   wac ;", "}", "METHOD_END"], "methodName": ["getRequiredWebApplicationContext"], "fileName": "org.springframework.web.jsf.FacesContextUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( fc ,     \" FacesContext   must   not   be   null \"  )  ;", "ExternalContext   ec    =    fc . getExternalContext (  )  ;", "Object   mutex    =    ec . getSessionMap (  )  . get ( WebUtils . SESSION _ MUTEX _ ATTRIBUTE )  ;", "if    ( mutex    =  =    null )     {", "mutex    =    ec . getSession ( true )  ;", "}", "return   mutex ;", "}", "METHOD_END"], "methodName": ["getSessionMutex"], "fileName": "org.springframework.web.jsf.FacesContextUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( fc ,     \" FacesContext   must   not   be   null \"  )  ;", "Object   attr    =    fc . getExternalContext (  )  . getApplicationMap (  )  . get ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE )  ;", "if    ( attr    =  =    null )     {", "return   null ;", "}", "if    ( attr   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( attr )  )  ;", "}", "if    ( attr   instanceof   Error )     {", "throw    (  ( Error )     ( attr )  )  ;", "}", "if    (  !  ( attr   instanceof   WebApplicationContext )  )     {", "throw   new   IllegalStateException (  (  \" Root   context   attribute   is   not   of   type   WebApplicationContext :     \"     +    attr )  )  ;", "}", "return    (  ( WebApplicationContext )     ( attr )  )  ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.jsf.FacesContextUtils"}, {"methodBody": ["METHOD_START", "{", "this . application    =    application ;", "}", "METHOD_END"], "methodName": ["setApplication"], "fileName": "org.springframework.web.jsf.MockFacesContext"}, {"methodBody": ["METHOD_START", "{", "this . externalContext    =    externalContext ;", "}", "METHOD_END"], "methodName": ["setExternalContext"], "fileName": "org.springframework.web.jsf.MockFacesContext"}, {"methodBody": ["METHOD_START", "{", "FacesContext   facesContext    =    FacesContext . getCurrentInstance (  )  ;", "return   FacesContextUtils . getRequiredWebApplicationContext ( facesContext )  ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.jsf.el.SpringBeanFacesELResolver"}, {"methodBody": ["METHOD_START", "{", "FacesContext   facesContext    =    FacesContext . getCurrentInstance (  )  ;", "return   FacesContextUtils . getRequired ( facesContext )  ;", "}", "METHOD_END"], "methodName": ["getWebApplicationContext"], "fileName": "org.springframework.web.jsf.el.WebApplicationContextFacesELResolver"}, {"methodBody": ["METHOD_START", "{", "return   basePackage . endsWith (  \"  .  \"  )     ?    basePackage    :    basePackage    +     \"  .  \"  ;", "}", "METHOD_END"], "methodName": ["adaptBasePackage"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "List < ControllerAdviceBean >    beans    =    new   ArrayList <  >  (  )  ;", "for    ( String   name    :    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( applicationContext ,    Object . class )  )     {", "if    (  ( applicationContext . findAnnotationOnBean ( name ,    ControllerAdvice . class )  )     !  =    null )     {", "beans . add ( new   ControllerAdviceBean ( name ,    applicationContext )  )  ;", "}", "}", "return   beans ;", "}", "METHOD_END"], "methodName": ["findAnnotatedBeans"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    beanType    =     (  ( this . bean )    instanceof   String )     ?    obtainBeanFactory (  )  . getType (  (  ( String )     ( this . bean )  )  )     :    this . bean . getClass (  )  ;", "return   beanType    !  =    null    ?    ClassUtils . getUserClass ( beanType )     :    null ;", "}", "METHOD_END"], "methodName": ["getBeanType"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "return    (  (  !  ( this . basePackages . isEmpty (  )  )  )     |  |     (  !  ( this . assignableTypes . isEmpty (  )  )  )  )     |  |     (  !  ( this . annotations . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasSelectors"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "Set < String >    basePackages    =    new   LinkedHashSet <  >  (  )  ;", "for    ( String   basePackage    :    annotation . basePackages (  )  )     {", "if    ( StringUtils . hasText ( basePackage )  )     {", "basePackages . add (  . adaptBasePackage ( basePackage )  )  ;", "}", "}", "for    ( Class <  ?  >    markerClass    :    annotation . basePackageClasses (  )  )     {", "basePackages . add (  . adaptBasePackage ( ClassUtils . getPackageName ( markerClass )  )  )  ;", "}", "return   basePackages ;", "}", "METHOD_END"], "methodName": ["initBasePackages"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "return   bean   instanceof   Ordered    ?     (  ( Ordered )     ( bean )  )  . getOrder (  )     :    ControllerAdviceBean . initOrderFromBeanType ( bean . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["initOrderFromBean"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "Integer   order    =    null ;", "if    ( bType    !  =    null )     {", "order    =    OrderUtils . getOrder ( bType )  ;", "}", "return   order    !  =    null    ?    order    :    Ordered . LOWEST _ PRECEDENCE ;", "}", "METHOD_END"], "methodName": ["initOrderFromBeanType"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( hasSelectors (  )  )  )     {", "return   true ;", "} else", "if    ( beanType    !  =    null )     {", "for    ( String   basePackage    :    this . basePackages )     {", "if    ( beanType . getName (  )  . startsWith ( basePackage )  )     {", "return   true ;", "}", "}", "for    ( Class <  ?  >    clazz    :    this . assignableTypes )     {", "if    ( util . ClassUtils . isAssignable ( clazz ,    beanType )  )     {", "return   true ;", "}", "}", "for    ( Class <  ?    extends   Annotation >    annotationClass    :    this . annotations )     {", "if    (  ( core . annotation . AnnotationUtils . findAnnotation ( beanType ,    annotationClass )  )     !  =    null )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isApplicableToBeanType"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" No   BeanFactory   set \"  )  ;", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["obtainBeanFactory"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "return    ( this . bean )    instanceof   String    ?    obtainBeanFactory (  )  . getBean (  (  ( String )     ( this . bean )  )  )     :    this . bean ;", "}", "METHOD_END"], "methodName": ["resolveBean"], "fileName": "org.springframework.web.method.ControllerAdviceBean"}, {"methodBody": ["METHOD_START", "{", "ControllerAdviceBean   bean    =    new   ControllerAdviceBean ( new   ControllerAdviceBeanTests . AnnotationSupport (  )  )  ;", "assertApplicable (  \" annotation   support \"  ,    bean ,    ControllerAdviceBeanTests . AnnotatedController . class )  ;", "assertNotApplicable (  \" this   bean   is   not   annotated \"  ,    bean ,    ControllerAdviceBeanTests . InheritanceController . class )  ;", "}", "METHOD_END"], "methodName": ["annotationSupport"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( controllerAdvice )  ;", "assertTrue ( message ,    controllerAdvice . isApplicableToBeanType ( controllerBeanType )  )  ;", "}", "METHOD_END"], "methodName": ["assertApplicable"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( controllerAdvice )  ;", "assertFalse ( message ,    controllerAdvice . isApplicableToBeanType ( controllerBeanType )  )  ;", "}", "METHOD_END"], "methodName": ["assertNotApplicable"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "ControllerAdviceBean   bean    =    new   ControllerAdviceBean ( new   ControllerAdviceBeanTests . AssignableTypesSupport (  )  )  ;", "assertApplicable (  \" controller   implements   assignable \"  ,    bean ,    ControllerAdviceBeanTests . ImplementationController . class )  ;", "assertApplicable (  \" controller   inherits   assignable \"  ,    bean ,    ControllerAdviceBeanTests . InheritanceController . class )  ;", "assertNotApplicable (  \" not   assignable \"  ,    bean ,    ControllerAdviceBeanTests . AnnotatedController . class )  ;", "assertNotApplicable (  \" not   assignable \"  ,    bean ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["assignableTypesSupport"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "ControllerAdviceBean   bean    =    new   ControllerAdviceBean ( new   ControllerAdviceBeanTests . BasePackageSupport (  )  )  ;", "assertApplicable (  \" base   package   support \"  ,    bean ,    ControllerAdviceBeanTests . AnnotatedController . class )  ;", "assertApplicable (  \" base   package   support \"  ,    bean ,    ControllerAdviceBeanTests . ImplementationController . class )  ;", "assertApplicable (  \" base   package   support \"  ,    bean ,    ControllerAdviceBeanTests . InheritanceController . class )  ;", "assertNotApplicable (  \" bean   not   in   package \"  ,    bean ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["basePackageSupport"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "ControllerAdviceBean   bean    =    new   ControllerAdviceBean ( new   ControllerAdviceBeanTests . BasePackageValueSupport (  )  )  ;", "assertApplicable (  \" base   package   support \"  ,    bean ,    ControllerAdviceBeanTests . AnnotatedController . class )  ;", "assertApplicable (  \" base   package   support \"  ,    bean ,    ControllerAdviceBeanTests . ImplementationController . class )  ;", "assertApplicable (  \" base   package   support \"  ,    bean ,    ControllerAdviceBeanTests . InheritanceController . class )  ;", "assertNotApplicable (  \" bean   not   in   package \"  ,    bean ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["basePackageValueSupport"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "ControllerAdviceBean   bean    =    new   ControllerAdviceBean ( new   ControllerAdviceBeanTests . MarkerClassSupport (  )  )  ;", "assertApplicable (  \" base   package   class   support \"  ,    bean ,    ControllerAdviceBeanTests . AnnotatedController . class )  ;", "assertApplicable (  \" base   package   class   support \"  ,    bean ,    ControllerAdviceBeanTests . ImplementationController . class )  ;", "assertApplicable (  \" base   package   class   support \"  ,    bean ,    ControllerAdviceBeanTests . InheritanceController . class )  ;", "assertNotApplicable (  \" bean   not   in   package \"  ,    bean ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["markerClassSupport"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "ControllerAdviceBean   bean    =    new   ControllerAdviceBean ( new   ControllerAdviceBeanTests . MultipleSelectorsSupport (  )  )  ;", "assertApplicable (  \" controller   implements   assignable \"  ,    bean ,    ControllerAdviceBeanTests . ImplementationController . class )  ;", "assertApplicable (  \" controller   is   annotated \"  ,    bean ,    ControllerAdviceBeanTests . AnnotatedController . class )  ;", "assertNotApplicable (  \" should   not   match \"  ,    bean ,    ControllerAdviceBeanTests . InheritanceController . class )  ;", "}", "METHOD_END"], "methodName": ["multipleMatch"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "ControllerAdviceBean   bean    =    new   ControllerAdviceBean ( new   ControllerAdviceBeanTests . SimpleControllerAdvice (  )  )  ;", "assertApplicable (  \" should   match   all \"  ,    bean ,    ControllerAdviceBeanTests . AnnotatedController . class )  ;", "assertApplicable (  \" should   match   all \"  ,    bean ,    ControllerAdviceBeanTests . ImplementationController . class )  ;", "assertApplicable (  \" should   match   all \"  ,    bean ,    ControllerAdviceBeanTests . InheritanceController . class )  ;", "assertApplicable (  \" should   match   all \"  ,    bean ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["shouldMatchAll"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "ControllerAdviceBean   bean    =    new   ControllerAdviceBean ( new   ControllerAdviceBeanTests . ShouldNotMatch (  )  )  ;", "assertNotApplicable (  \" should   not   match \"  ,    bean ,    ControllerAdviceBeanTests . AnnotatedController . class )  ;", "assertNotApplicable (  \" should   not   match \"  ,    bean ,    ControllerAdviceBeanTests . ImplementationController . class )  ;", "assertNotApplicable (  \" should   not   match \"  ,    bean ,    ControllerAdviceBeanTests . InheritanceController . class )  ;", "assertNotApplicable (  \" should   not   match \"  ,    bean ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["shouldNotMatch"], "fileName": "org.springframework.web.method.ControllerAdviceBeanTests"}, {"methodBody": ["METHOD_START", "{", "Object   handler    =    this . bean ;", "if    (  ( this . bean )    instanceof   String )     {", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" Cannot   resolve   bean   name   without   BeanFactory \"  )  ;", "String   beanName    =     (  ( String )     ( this . bean )  )  ;", "handler    =    this . beanFactory . getBean ( beanName )  ;", "}", "return   new    ( this ,    handler )  ;", "}", "METHOD_END"], "methodName": ["createWithResolvedBean"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "ResponseStatus   annotation    =    getMethodAnnotation ( ResponseStatus . class )  ;", "if    ( annotation    =  =    null )     {", "annotation    =    AnnotatedElementUtils . findMergedAnnotation ( getBeanType (  )  ,    ResponseStatus . class )  ;", "}", "if    ( annotation    !  =    null )     {", "this . responseStatus    =    annotation . code (  )  ;", "this . responseStatusReason    =    annotation . reason (  )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluateResponseStatus"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . bean ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . beanType ;", "}", "METHOD_END"], "methodName": ["getBeanType"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . bridgedMethod ;", "}", "METHOD_END"], "methodName": ["getBridgedMethod"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . findMergedAnnotation ( this . method ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["getMethodAnnotation"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . parameters ;", "}", "METHOD_END"], "methodName": ["getMethodParameters"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . resolvedFromHandlerMethod ;", "}", "METHOD_END"], "methodName": ["getResolvedFromHandlerMethod"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . responseStatus ;", "}", "METHOD_END"], "methodName": ["getResponseStatus"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . responseStatusReason ;", "}", "METHOD_END"], "methodName": ["getResponseStatusReason"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerMethod . HandlerMethodParameter (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerMethod . ReturnValueMethodParameter ( returnValue )  ;", "}", "METHOD_END"], "methodName": ["getReturnValueType"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "int   args    =    this . method . getParameterCount (  )  ;", "return    (  (  (  (  ( getBeanType (  )  . getName (  )  )     +     \"  #  \"  )     +     ( this . method . getName (  )  )  )     +     \"  [  \"  )     +    args )     +     \"    args ]  \"  ;", "}", "METHOD_END"], "methodName": ["getShortLogMessage"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . hasAnnotation ( this . method ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["hasMethodAnnotation"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "int   count    =    this . bridgedMethod . getParameterCount (  )  ;", "MethodParameter [  ]    result    =    new   MethodParameter [ count ]  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "HandlerMParameter   parameter    =    new   HandlerMParameter ( i )  ;", "GenericTypeResolver . resolveParameterType ( parameter ,    this . beanType )  ;", "result [ i ]     =    parameter ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["initMethodParameters"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   Void . TYPE . equals ( getReturnType (  )  . getParameterType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isVoid"], "fileName": "org.springframework.web.method.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestMappingPredicate ( path )  . method ( RequestMethod . DELETE )  ;", "}", "METHOD_END"], "methodName": ["deleteMapping"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestMappingPredicate ( path )  . method ( RequestMethod . GET )  ;", "}", "METHOD_END"], "methodName": ["getMapping"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestMappingPredicate ( path )  . method ( RequestMethod . HEAD )  ;", "}", "METHOD_END"], "methodName": ["headMapping"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . MatrixVariablePredicate (  )  ;", "}", "METHOD_END"], "methodName": ["matrixAttribute"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . ModelAttributePredicate (  )  ;", "}", "METHOD_END"], "methodName": ["modelAttribute"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . ModelAttributeMethodPredicate (  )  ;", "}", "METHOD_END"], "methodName": ["modelMethod"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestMappingPredicate ( path )  . method ( RequestMethod . OPTIONS )  ;", "}", "METHOD_END"], "methodName": ["optionsMapping"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestMappingPredicate ( path )  . method ( RequestMethod . POST )  ;", "}", "METHOD_END"], "methodName": ["postMapping"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestMappingPredicate ( path )  . method ( RequestMethod . PUT )  ;", "}", "METHOD_END"], "methodName": ["putMapping"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestAttributePredicate (  )  ;", "}", "METHOD_END"], "methodName": ["requestAttribute"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestBodyPredicate (  )  ;", "}", "METHOD_END"], "methodName": ["requestBody"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestMappingPredicate ( path )  ;", "}", "METHOD_END"], "methodName": ["requestMapping"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestParamPredicate (  )  ;", "}", "METHOD_END"], "methodName": ["requestParam"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . RequestPartPredicate (  )  ;", "}", "METHOD_END"], "methodName": ["requestPart"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . ResponseStatusPredicate (  )  ;", "}", "METHOD_END"], "methodName": ["responseStatus"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   MvcAnnotationPredicates . ResponseStatusPredicate ( code )  ;", "}", "METHOD_END"], "methodName": ["responseStatus"], "fileName": "org.springframework.web.method.MvcAnnotationPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableMethod . ArgResolver ( filter )  ;", "}", "METHOD_END"], "methodName": ["annot"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableMethod . ArgResolver (  )  . annotNotPresent ( annotationTypes )  ;", "}", "METHOD_END"], "methodName": ["annotNotPresent"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableMethod . ArgResolver (  )  . annotPresent ( annotationTypes )  ;", "}", "METHOD_END"], "methodName": ["annotPresent"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableMethod . ArgResolver (  )  . arg ( type ,    generics )  ;", "}", "METHOD_END"], "methodName": ["arg"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableMethod . ArgResolver (  )  . arg ( type ,    generic ,    generics )  ;", "}", "METHOD_END"], "methodName": ["arg"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableMethod . ArgResolver (  )  . arg ( type )  ;", "}", "METHOD_END"], "methodName": ["arg"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    AnnotationUtils . getAnnotationAttributes ( annotation )  ;", "map . forEach (  (    key ,    value )     -  >     {", "if    ( value . equals ( ValueConstants . DEFAULT _ NONE )  )     {", "map . put ( key ,     \" NONE \"  )  ;", "}", "}  )  ;", "return    ( annotation . annotationType (  )  . getName (  )  )     +    map ;", "}", "METHOD_END"], "methodName": ["formatAnnotation"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return    ( this . method (  )  . getName (  )  )     +     ( Arrays . stream ( this . method . getParameters (  )  )  . map ( this :  : formatParameter )  . collect ( Collectors . joining (  \"  ,  \\ n \\ t \"  ,     \"  (  \\ n \\ t \"  ,     \"  \\ n )  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["formatMethod"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annot    =    param . getAnnotations (  )  ;", "return    ( annot . length )     >     0     ?     (  ( Arrays . stream ( annot )  . map ( this :  : formatAnnotation )  . collect ( Collectors . joining (  \"  ,  \"  ,     \"  [  \"  ,     \"  ]  \"  )  )  )     +     \"     \"  )     +    param    :    param . toSt (  )  ;", "}", "METHOD_END"], "methodName": ["formatParameter"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( type ,     \"  ' type '    must   not   be   null \"  )  ;", "if    ( type . isInterface (  )  )     {", "ProxyFactory   factory    =    new   ProxyFactory ( EmptyTargetSource . INSTANCE )  ;", "factory . addInterface ( type )  ;", "factory . addInterface ( Supplier . class )  ;", "factory . addAdvice ( interceptor )  ;", "return    (  ( T )     ( factory . getProxy (  )  )  )  ;", "} else    {", "Enhancer   enhancer    =    new   Enhancer (  )  ;", "enhancer . setSuperclass ( type )  ;", "enhancer . setInterfaces ( new   Class <  ?  >  [  ]  {    Supplier . class    }  )  ;", "enhancer . setNamingPolicy ( INSTANCE )  ;", "enhancer . setCallbackType ( MethodInterceptor . class )  ;", "Class <  ?  >    proxyClass    =    enhancer . createClass (  )  ;", "Object   proxy    =    null ;", "if    (  . objenesis . isWorthTrying (  )  )     {", "try    {", "proxy    =     . objenesis . newInstance ( proxyClass ,    enhancer . getUseCache (  )  )  ;", "}    catch    ( ObjenesisException   ex )     {", ". logger . debug (  \" Objenesis   failed ,    falling   back   to   default   constructor \"  ,    ex )  ;", "}", "}", "if    ( proxy    =  =    null )     {", "try    {", "proxy    =    ReflectionUtils . accessibleConstructor ( proxyClass )  . newInstance (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  \" Unable   to   instantiate   proxy    \"     +     \" via   both   Objenesis   and   default   constructor   fails   as   well \"  )  ,    ex )  ;", "}", "}", "(  ( Factory )     ( proxy )  )  . setCallbacks ( new   Callback [  ]  {    interceptor    }  )  ;", "return    (  ( T )     ( proxy )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initProxy"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableMethod . Builder <  >  ( objectClass )  ;", "}", "METHOD_END"], "methodName": ["on"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   SynthesizingMethodParameter ( this . method ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["returnType"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "return   ObjectUtils . isEmpty ( generics )     ?    ResolvableType . forClass ( type )     :    ResolvableType . forClassWithGenerics ( type ,    generics )  ;", "}", "METHOD_END"], "methodName": ["toResolvableType"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "ResolvableType [  ]    genericTypes    =    new   ResolvableType [  ( generics . length )     +     1  ]  ;", "genericTypes [  0  ]     =    generic ;", "System . arraycopy ( generics ,     0  ,    genericTypes ,     1  ,    generics . length )  ;", "return   ResolvableType . forClassWithGenerics ( type ,    genericTypes )  ;", "}", "METHOD_END"], "methodName": ["toResolvableType"], "fileName": "org.springframework.web.method.ResolvableMethod"}, {"methodBody": ["METHOD_START", "{", "AbstractNamedValueMethodArgumentResolver . NamedValueInfo   namedValueInfo    =    this . namedValueInfoCache . get ( parameter )  ;", "if    ( namedValueInfo    =  =    null )     {", "namedValueInfo    =    createNamedValueInfo ( parameter )  ;", "namedValueInfo    =    updateNamedValueInfo ( parameter ,    namedValueInfo )  ;", "this . namedValueInfoCache . put ( parameter ,    namedValueInfo )  ;", "}", "return   namedValueInfo ;", "}", "METHOD_END"], "methodName": ["getNamedValueInfo"], "fileName": "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "throw   new   ServletRequestBindingException (  (  (  (  \" Missing   argument    '  \"     +    name )     +     \"  '    for   method   parameter   of   type    \"  )     +     ( parameter . getNestedParameterType (  )  . getSimpleName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMissingValue"], "fileName": "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "handleMissingValue ( name ,    parameter )  ;", "}", "METHOD_END"], "methodName": ["handleMissingValue"], "fileName": "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "if    ( Boolean . TYPE . equals ( paramType )  )     {", "return   Boolean . FALSE ;", "} else", "if    ( paramType . isPrimitive (  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" Optional    \"     +     ( paramType . getSimpleName (  )  )  )     +     \"    parameter    '  \"  )     +    name )     +     \"  '    is   present   but   c   be   translated   into   a   null   value   due   to   being   declared   as   a    \"  )     +     \" primitive   type .    Consider   declaring   it   as   object   wrapper   for   the   corresponding   primitive   type .  \"  )  )  ;", "}", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["handleNullValue"], "fileName": "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . configurableBeanFactory )     =  =    null )     {", "return   value ;", "}", "String   placeholdersResolved    =    this . configurableBeanFactory . resolveEmbeddedValue ( value )  ;", "BeanExpression   expr    =    this . configurableBeanFactory . getBeanExpression (  )  ;", "if    (  ( expr    =  =    null )     |  |     (  ( this . expressionContext )     =  =    null )  )     {", "return   value ;", "}", "return   expr . evaluate ( placeholdersResolved ,    this . expressionContext )  ;", "}", "METHOD_END"], "methodName": ["resolveStringValue"], "fileName": "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "String   name    =    info . name ;", "if    ( info . name . isEmpty (  )  )     {", "name    =    parameter . getParameterName (  )  ;", "if    ( name    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  \" Name   for   argument   type    [  \"     +     ( parameter . getNestedParameterType (  )  . getName (  )  )  )     +     \"  ]    not   available ,    and   parameter   name   information   not   found   in   class   file   either .  \"  )  )  ;", "}", "}", "String   defaultValue    =     ( ValueConstants . DEFAULT _ NONE . equals ( info . defaultValue )  )     ?    null    :    info . defaultValue ;", "return   new    . NamedValueInfo ( name ,    info . required ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["updateNamedValueInfo"], "fileName": "org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "resolver . resolveArgument ( paramNamedCookie ,    null ,    webRequest ,    null )  ;", "fail (  \" Expected   exception \"  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    resolver . resolveArgument ( paramNamedDefaultValueString ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveCookieDefaultValue"], "fileName": "org.springframework.web.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver    =    new   CookieValueMethodArgumentResolverTests . TestCookieValueMethodArgumentResolver (  )  ;", "Method   method    =    getClass (  )  . getMethod (  \" params \"  ,    Cookie . class ,    String . class ,    String . class )  ;", "paramNamedCookie    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "paramNamedDefaultValueString    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "paramString    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "webRequest    =    new   ServletWebRequest ( request ,    new   MockHttpServletResponse (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Cookie   parameter   not   supported \"  ,    resolver . supportsParameter ( paramNamedCookie )  )  ;", "assertTrue (  \" Cookie   string   parameter   not   supported \"  ,    resolver . supportsParameter ( paramNamedDefaultValueString )  )  ;", "assertFalse (  \" non -  @    parameter   supported \"  ,    resolver . supportsParameter ( paramString )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ModelAndViewContainer   mavContainer    =    new   ModelAndViewContainer (  )  ;", "mavContainer . addAttribute (  \" ignore 1  \"  ,     \" value 1  \"  )  ;", "mavContainer . addAttribute (  \" ignore 2  \"  ,     \" value 2  \"  )  ;", "mavContainer . addAttribute (  \" ignore 3  \"  ,     \" value 3  \"  )  ;", "mavContainer . addAttribute (  \" ignore 4  \"  ,     \" value 4  \"  )  ;", "mavContainer . addAttribute (  \" ignore 5  \"  ,     \" value 5  \"  )  ;", "mavContainer . addAllAttributes ( bindingResult . getModel (  )  )  ;", "Object   actual    =    resolver . resolve ( paramErrors ,    mavContainer ,    webRequest ,    null )  ;", "assertSame ( actual ,    bindingResult )  ;", "}", "METHOD_END"], "methodName": ["bindingResult"], "fileName": "org.springframework.web.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ModelAndViewContainer   mavContainer    =    new   ModelAndViewContainer (  )  ;", "mavContainer . addAllAttributes ( bindingResult . getModel (  )  )  ;", "mavContainer . addAttribute (  \" ignore 1  \"  ,     \" value 1  \"  )  ;", "resolver . resolve ( paramErrors ,    mavContainer ,    webRequest ,    null )  ;", "}", "METHOD_END"], "methodName": ["bindingResultNotFound"], "fileName": "org.springframework.web.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . resolveArgument ( paramErrors ,    new   ModelAndViewContainer (  )  ,    webRequest ,    null )  ;", "}", "METHOD_END"], "methodName": ["noBindingResult"], "fileName": "org.springframework.web.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "paramErrors    =    new   MethodParameter ( getClass (  )  . getDeclaredMethod (  \" handle \"  ,    Errors . class )  ,     0  )  ;", "bindingResult    =    new   WebDataBinder ( new   Object (  )  ,     \" attr \"  )  . getBindingResult (  )  ;", "webRequest    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . supportsParameter ( paramErrors )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.web.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   oldMethod    =    this . mappedMethods . put ( exceptionType ,    method )  ;", "if    (  ( oldMethod    !  =    null )     &  &     (  !  ( oldMethod . equals ( method )  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Ambiguous    @    method   mapped   for    [  \"     +    exceptionType )     +     \"  ]  :     {  \"  )     +    oldMethod )     +     \"  ,     \"  )     +    method )     +     \"  }  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addExceptionMapping"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "ExceptionHandler   ann    =    AnnotationUtils . findAnnotation ( method ,    ExceptionHandler . class )  ;", "Assert . state (  ( ann    !  =    null )  ,     \" No   ExceptionHandler   annotation \"  )  ;", "result . addAll ( Arrays . asList ( ann . value (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["detectAnnotationExceptionMappings"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?    extends   Throwable >  >    result    =    new   ArrayList <  >  (  )  ;", "detectAExceptionMappings ( method ,    result )  ;", "if    ( result . isEmpty (  )  )     {", "for    ( Class <  ?  >    paramType    :    method . getParameterTypes (  )  )     {", "if    ( Throwable . class . isAssignableFrom ( paramType )  )     {", "result . add (  (  ( Class <  ?    extends   Throwable >  )     ( paramType )  )  )  ;", "}", "}", "}", "if    ( result . isEmpty (  )  )     {", "throw   new   IllegalStateException (  (  \" No   exception   types   mapped   to    \"     +    method )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["detectExceptionMappings"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?    extends   Throwable >  >    matches    =    new   ArrayList <  >  (  )  ;", "for    ( Class <  ?    extends   Throwable >    mapped    :    this . mappedMethods . keySet (  )  )     {", "if    ( mapped . isAssignableFrom ( exceptionType )  )     {", "matches . add ( mapped )  ;", "}", "}", "if    (  !  ( matches . isEmpty (  )  )  )     {", "matches . sort ( new   DepthComparator ( exceptionType )  )  ;", "return   this . mappedMethods . get ( matches . get (  0  )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getMappedMethod"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . mappedMethods . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasExceptionMappings"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "return   resolveMethodByThrowable ( exception )  ;", "}", "METHOD_END"], "methodName": ["resolveMethod"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    this . exceptionLookupCache . get ( exceptionType )  ;", "if    ( method    =  =    null )     {", "method    =    getMappedMethod ( exceptionType )  ;", "this . exceptionLookupCache . put ( exceptionType ,    method )  ;", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["resolveMethodByExceptionType"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    resolveMethodByExceptionType ( exception . getClass (  )  )  ;", "if    ( method    =  =    null )     {", "Throwable   cause    =    exception . getCause (  )  ;", "if    ( cause    !  =    null )     {", "method    =    resolveMethodByExceptionType ( cause . getClass (  )  )  ;", "}", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["resolveMethodByThrowable"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "new   ExceptionHandlerMethodResolver ( ExceptionHandlerMethodResolverTests . AmbiguousController . class )  ;", "}", "METHOD_END"], "methodName": ["ambiguousExceptionMapping"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   ExceptionHandlerMethodResolver ( ExceptionHandlerMethodResolverTests . NoExceptionController . class )  ;", "}", "METHOD_END"], "methodName": ["noExceptionMapping"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "ExceptionHandlerMethodResolver   resolver    =    new   ExceptionHandlerMethodResolver ( ExceptionHandlerMethodResolverTests . ExceptionController . class )  ;", "SocketException   exception    =    new   SocketException (  )  ;", "assertEquals (  \" handleSocketException \"  ,    resolver . resolveMethod ( exception )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodBestMatch"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "ExceptionHandlerMethodResolver   resolver    =    new   ExceptionHandlerMethodResolver ( ExceptionHandlerMethodResolverTests . ExceptionController . class )  ;", "IOException   ioException    =    new   FileNotFoundException (  )  ;", "assertEquals (  \" handleIOException \"  ,    resolver . resolveMethod ( ioException )  . getName (  )  )  ;", "SocketException   bindException    =    new   BindException (  )  ;", "assertEquals (  \" handleSocketException \"  ,    resolver . resolveMethod ( bindException )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodExceptionSubType"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "ExceptionHandlerMethodResolver   resolver    =    new   ExceptionHandlerMethodResolver ( ExceptionHandlerMethodResolverTests . ExceptionController . class )  ;", "IOException   exception    =    new   IOException (  )  ;", "assertEquals (  \" handleIOException \"  ,    resolver . resolveMethod ( exception )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodFromAnnotation"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "ExceptionHandlerMethodResolver   resolver    =    new   ExceptionHandlerMethodResolver ( ExceptionHandlerMethodResolverTests . ExceptionController . class )  ;", "IllegalArgumentException   exception    =    new   IllegalArgumentException (  )  ;", "assertEquals (  \" handleIllegalArgumentException \"  ,    resolver . resolveMethod ( exception )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodFromArgument"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "ExceptionHandlerMethodResolver   resolver    =    new   ExceptionHandlerMethodResolver ( ExceptionHandlerMethodResolverTests . InheritedController . class )  ;", "IOException   exception    =    new   IOException (  )  ;", "assertEquals (  \" handleIOException \"  ,    resolver . resolveMethod ( exception )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodInherited"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "ExceptionHandlerMethodResolver   resolver    =    new   ExceptionHandlerMethodResolver ( ExceptionHandlerMethodResolverTests . ExceptionController . class )  ;", "Exception   exception    =    new   Exception (  )  ;", "assertNull (  \"  1 st   lookup \"  ,    resolver . resolveMethod ( exception )  )  ;", "assertNull (  \"  2 nd   lookup   from   cache \"  ,    resolver . resolveMethod ( exception )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodNoMatch"], "fileName": "org.springframework.web.method.annotation.ExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "webRequest . getNativeRequest ( MockHttpServletRequest . class )  . setContextPath (  \"  / contextPath \"  )  ;", "Object   value    =    resolver . resolve ( paramContextPath ,    null ,    webRequest ,    null )  ;", "assertEquals (  \"  / contextPath \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["resolveContextPath"], "fileName": "org.springframework.web.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" systemProperty \"  ,     \"  2  2  \"  )  ;", "Object   value    =    resolver . resolve ( paramSystemProperty ,    null ,    webRequest ,    null )  ;", "System . clearProperty (  \" systemProperty \"  )  ;", "assertEquals (  \"  2  2  \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["resolveSystemProperty"], "fileName": "org.springframework.web.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "GenericWebApplicationContext   context    =    new   GenericWebApplicationContext (  )  ;", "context . refresh (  )  ;", "resolver    =    new    ( context . getBeanFactory (  )  )  ;", "Method   method    =    getClass (  )  . getMethod (  \" params \"  ,    int . class ,    String . class ,    String . class )  ;", "paramSystemProperty    =    new   MethodParameter ( method ,     0  )  ;", "paramContextPath    =    new   MethodParameter ( method ,     1  )  ;", "paramNotSupported    =    new   MethodParameter ( method ,     2  )  ;", "webRequest    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  ,    new   MockHttpServletResponse (  )  )  ;", "RequestContextHolder . setRequestAttributes ( webRequest )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( resolver . supportsParameter ( paramSystemProperty )  )  ;", "assertTrue ( resolver . supportsParameter ( paramContextPath )  )  ;", "assertFalse ( resolver . supportsParameter ( paramNotSupported )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolder . resetRequestAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.springframework.web.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "InitBinder   ann    =    binderMethod . getMethodAnnotation ( InitBinder . class )  ;", "Assert . state (  ( ann    !  =    null )  ,     \" No   InitBinder   annotation \"  )  ;", "Collection < String >    names    =    Arrays . asList ( ann . value (  )  )  ;", "return    ( names . isEmpty (  )  )     |  |     ( names . contains ( binder . getObjectName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isBinderMethodApplicable"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactory"}, {"methodBody": ["METHOD_START", "{", "WebDataBinderFactory   factory    =    createFactory (  \" initBinder \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    factory . createBinder ( this . webRequest ,    null ,    null )  ;", "assertNotNull ( dataBinder . getDisallowedFields (  )  )  ;", "assertEquals (  \" id \"  ,    dataBinder . getDisallowedFields (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["createBinder"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "WebDataBinderFactory   factory    =    createFactory (  \" initBinderWithAttributeName \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    factory . createBinder ( this . webRequest ,    null ,    null )  ;", "assertNull ( dataBinder . getDisallowedFields (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBinderNullAttrName"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "this . webRequest . getNativeRequest ( MockHttpServletRequest . class )  . setParameter (  \" requestParam \"  ,     \"  2  2  \"  )  ;", "this . argumentResolvers . addResolver ( new   RequestParamMethodArgumentResolver ( null ,    false )  )  ;", "Web   factory    =    createFactory (  \" initBinderTypeConversion \"  ,    WebDataBinder . class ,    int . class )  ;", "WebDataBinder   dataBinder    =    factory . createBinder ( this . webRequest ,    null ,     \" foo \"  )  ;", "assertNotNull ( dataBinder . getDisallowedFields (  )  )  ;", "assertEquals (  \" requestParam -  2  2  \"  ,    dataBinder . getDisallowedFields (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["createBinderTypeConversion"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "WebDataBinderFactory   factory    =    createFactory (  \" initBinderWithAttributeName \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    factory . createBinder ( this . webRequest ,    null ,     \" foo \"  )  ;", "assertNotNull ( dataBinder . getDisallowedFields (  )  )  ;", "assertEquals (  \" id \"  ,    dataBinder . getDisallowedFields (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["createBinderWithAttrName"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "WebDataBinderFactory   factory    =    createFactory (  \" initBinderWithAttributeName \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    factory . createBinder ( this . webRequest ,    null ,     \" invalidName \"  )  ;", "assertNull ( dataBinder . getDisallowedFields (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBinderWithAttrNameNoMatch"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConversionService   conversionService    =    new   DefaultFormattingConversionService (  )  ;", "bindingInitializer . setConversionService ( conversionService )  ;", "Web   factory    =    createFactory (  \" initBinder \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    factory . createBinder ( this . webRequest ,    null ,    null )  ;", "assertSame ( conversionService ,    dataBinder . getConversionService (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBinderWithGlobalInitialization"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Object   handler    =    new   InitBinderDataBinderFactoryTests . InitBinderHandler (  )  ;", "Method   method    =    handler . getClass (  )  . getMethod ( methodName ,    parameterTypes )  ;", "InvocableHandlerMethod   handlerMethod    =    new   InvocableHandlerMethod ( handler ,    method )  ;", "handlerMethod . setHandlerMethodArgumentResolvers ( this . argumentResolvers )  ;", "handlerMethod . setDataBinderFactory ( new   DefaultDataBinderFactory ( null )  )  ;", "handlerMethod . setParameterNameDiscoverer ( new   LocalVariableTableParameterNameDiscoverer (  )  )  ;", "return   new   InitBinderDataBinderFactory ( Collections . singletonList ( handlerMethod )  ,    this . bindingInitializer )  ;", "}", "METHOD_END"], "methodName": ["createFactory"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "WebDataBinderFactory   factory    =    createFactory (  \" initBinderReturnValue \"  ,    WebDataBinder . class )  ;", "factory . createBinder ( this . webRequest ,    null ,     \" invalidName \"  )  ;", "}", "METHOD_END"], "methodName": ["returnValueNotExpected"], "fileName": "org.springframework.web.method.annotation.InitBinderDataBinderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "mavContainer . addAttribute (  \" attr 1  \"  ,     \" value 1  \"  )  ;", "Map < String ,    Object >    returnValue    =    new   ModelMap (  \" attr 2  \"  ,     \" value 2  \"  )  ;", "p . handleReturnValue ( returnValue ,    returnParamMap ,    mavContainer ,    webRequest )  ;", "assertEquals (  \" value 1  \"  ,    mavContainer . getModel (  )  . get (  \" attr 1  \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    mavContainer . getModel (  )  . get (  \" attr 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMapReturnValue"], "fileName": "org.springframework.web.method.annotation.MapMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.springframework.web.method.annotation.MapMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( mavContainer . getModel (  )  ,    processor . resolveArgument ( paramMap ,    mavContainer ,    webRequest ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentValue"], "fileName": "org.springframework.web.method.annotation.MapMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "processor    =    new   MapMethodProcessor (  )  ;", "mavContainer    =    new   ModelAndViewContainer (  )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" map \"  ,    Map . class )  ;", "paramMap    =    new   MethodParameter ( method ,     0  )  ;", "returnParamMap    =    new   MethodParameter ( method ,     0  )  ;", "webRequest    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.MapMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( processor . supportsParameter ( paramMap )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.MapMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( processor . supportsReturnType ( returnParamMap )  )  ;", "}", "METHOD_END"], "methodName": ["supportsReturnType"], "fileName": "org.springframework.web.method.annotation.MapMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.web.method.annotation.MethodArgumentConversionNotSupportedException"}, {"methodBody": ["METHOD_START", "{", "return   this . parameter ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.springframework.web.method.annotation.MethodArgumentConversionNotSupportedException"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.web.method.annotation.MethodArgumentTypeMismatchException"}, {"methodBody": ["METHOD_START", "{", "return   this . parameter ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.springframework.web.method.annotation.MethodArgumentTypeMismatchException"}, {"methodBody": ["METHOD_START", "{", "(  ( WebRequestDataBinder )     ( binder )  )  . bind ( request )  ;", "}", "METHOD_END"], "methodName": ["bindRequestParameters"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ctor . getParameterCount (  )  )     =  =     0  )     {", "return   BeanUtils . instantiateClass ( ctor )  ;", "}", "ConstructorProperties   cp    =    ctor . getAnnotation ( ConstructorProperties . class )  ;", "String [  ]    paramNames    =     ( cp    !  =    null )     ?    cp . value (  )     :     . parameterNameDiscoverer . getParameterNames ( ctor )  ;", "Assert . state (  ( paramNames    !  =    null )  ,     (  )     -  >     \" Cannot   resolve   parameter   names   for   constructor    \"     +    ctor )  ;", "Class <  ?  >  [  ]    paramTypes    =    ctor . getParameterTypes (  )  ;", "Assert . state (  (  ( paramNames . length )     =  =     ( paramTypes . length )  )  ,     (  )     -  >     (  (  \" Invalid   number   of   parameter   names :     \"     +    paramNames . length )     +     \"    for   constructor    \"  )     +    ctor )  ;", "Object [  ]    args    =    new   Object [ paramTypes . length ]  ;", "WebDataBinder   binder    =    binderFactory . createBinder ( webRequest ,    null ,    attributeName )  ;", "String   fieldDefaultPrefix    =    binder . getFieldDefaultPrefix (  )  ;", "String   fieldMarkerPrefix    =    binder . getFieldMarkerPrefix (  )  ;", "boolean   bindingFailure    =    false ;", "for    ( int   i    =     0  ;    i    <     ( paramNames . length )  ;    i +  +  )     {", "String   paramName    =    paramNames [ i ]  ;", "Class <  ?  >    paramType    =    paramTypes [ i ]  ;", "Object   value    =    webRequest . getParameterValues ( paramName )  ;", "if    ( value    =  =    null )     {", "if    ( fieldDefaultPrefix    !  =    null )     {", "value    =    webRequest . getParameter (  ( fieldDefaultPrefix    +    paramName )  )  ;", "}", "if    (  ( value    =  =    null )     &  &     ( fieldMarkerPrefix    !  =    null )  )     {", "if    (  ( webRequest . getParameter (  ( fieldMarkerPrefix    +    paramName )  )  )     !  =    null )     {", "value    =    binder . getEmptyValue ( paramType )  ;", "}", "}", "}", "try    {", "MethodParameter   methodParam    =    new   MethodParameter ( ctor ,    i )  ;", "if    (  ( value    =  =    null )     &  &     ( methodParam . isOptional (  )  )  )     {", "args [ i ]     =     (  ( methodParam . getParameterType (  )  )     =  =     ( Optional . class )  )     ?    Optional . empty (  )     :    null ;", "} else    {", "args [ i ]     =    binder . convertIfNecessary ( value ,    paramType ,    methodParam )  ;", "}", "}    catch    ( TypeMismatchException   ex )     {", "ex . initPropertyName ( paramName )  ;", "binder . getBindingErrorProcessor (  )  . processPropertyAccessException ( ex ,    binder . getBindingResult (  )  )  ;", "bindingFailure    =    true ;", "args [ i ]     =    value ;", "}", "}", "if    ( bindingFailure )     {", "if    (  ( binder . getBindingResult (  )  )    instanceof   AbstractBindingResult )     {", "AbstractBindingResult   result    =     (  ( AbstractBindingResult )     ( binder . getBindingResult (  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( paramNames . length )  ;    i +  +  )     {", "result . recordFieldValue ( paramNames [ i ]  ,    paramTypes [ i ]  ,    args [ i ]  )  ;", "}", "}", "throw   new   BindException ( binder . getBindingResult (  )  )  ;", "}", "return   BeanUtils . instantiateClass ( ctor ,    args )  ;", "}", "METHOD_END"], "methodName": ["constructAttribute"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   nestedParameter    =    parameter . nestedIfOptional (  )  ;", "Class <  ?  >    clazz    =    nestedParameter . getNestedParameterType (  )  ;", "Constructor <  ?  >    ctor    =    BeanUtils . findPrimaryConstructor ( clazz )  ;", "if    ( ctor    =  =    null )     {", "Constructor <  ?  >  [  ]    ctors    =    clazz . getConstructors (  )  ;", "if    (  ( ctors . length )     =  =     1  )     {", "ctor    =    ctors [  0  ]  ;", "} else    {", "try    {", "ctor    =    clazz . getDeclaredConstructor (  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   IllegalStateException (  (  \" No   primary   or   default   constructor   found   for    \"     +    clazz )  ,    ex )  ;", "}", "}", "}", "Object   attribute    =    construct ( ctor ,    attributeName ,    binderFactory ,    webRequest )  ;", "if    ( parameter    !  =    nestedParameter )     {", "attribute    =    Optional . of ( attribute )  ;", "}", "return   attribute ;", "}", "METHOD_END"], "methodName": ["createAttribute"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "int   i    =    parameter . getParameterIndex (  )  ;", "Class <  ?  >  [  ]    paramTypes    =    parameter . getExecutable (  )  . getParameterTypes (  )  ;", "boolean   hasBindingResult    =     (  ( paramTypes . length )     >     ( i    +     1  )  )     &  &     ( Errors . class . isAssignableFrom ( paramTypes [  ( i    +     1  )  ]  )  )  ;", "return    ! hasBindingResult ;", "}", "METHOD_END"], "methodName": ["isBindExceptionRequired"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "return   isBindExceptionRequired ( parameter )  ;", "}", "METHOD_END"], "methodName": ["isBindExceptionRequired"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ] s    =    parameter . getParameterAnnotations (  )  ;", "for    ( Annotation   ann    : s )     {", "Validated   validatedAnn    =    AnnotationUtils . getAnnotation ( ann ,    Validated . class )  ;", "if    (  ( validatedAnn    !  =    null )     |  |     ( annType (  )  . getSimpleName (  )  . startsWith (  \" Valid \"  )  )  )     {", "Object   hints    =     ( validatedAnn    !  =    null )     ?    validatedAnn . value (  )     :    AnnotationUtils . getValue ( ann )  ;", "Object [  ]    validationHints    =     ( hints   instanceof   Object [  ]  )     ?     (  ( Object [  ]  )     ( hints )  )     :    new   Object [  ]  {    hints    }  ;", "binder . validate ( validationHints )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateIfApplicable"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["annotatedReturnValue"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . processor . isBindExceptionRequired ( null ,    this . paramNonSimpleType )  )  ;", "assertFalse ( this . processor . isBindExceptionRequired ( null ,    this . paramNamedValid )  )  ;", "}", "METHOD_END"], "methodName": ["bindExceptionRequired"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . processor . handleReturnValue (  \" expected \"  ,    this . returnParamNamedModelAttr ,    this . container ,    this . request )  ;", "assertEquals (  \" expected \"  ,    this . container . getModel (  )  . get (  \" modelAttrName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleAnnotatedReturnValue"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  \" expected \"  )  ;", "this . p . handleReturnValue ( testBean ,    this . returnParamNonSimpleType ,    this . container ,    this . request )  ;", "assertSame ( testBean ,    this . container . getModel (  )  . get (  \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleNotAnnotatedReturnValue"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["notAnnotatedReturnValue"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" testBean \"  ;", "Object   target    =    new   TestBean (  )  ;", "this . container . getModel (  )  . addAttribute ( target )  ;", ". StubRequestDataBinder   dataBinder    =    new    . StubRequestDataBinder ( target ,    name )  ;", "dataBinder . getBindingResult (  )  . reject (  \" error \"  )  ;", "WebDataBinderFactory   binderFactory    =    mock ( WebDataBinderFactory . class )  ;", "given ( binderFactory . createBinder ( this . request ,    target ,    name )  )  . willReturn ( dataBinder )  ;", "this . processor . resolveArgument ( this . paramNonSimpleType ,    this . container ,    this . request ,    binderFactory )  ;", "verify ( binderFactory )  . createBinder ( this . request ,    target ,    name )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentBindException"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" noBindAttr \"  ;", "Object   target    =    new   TestBean (  )  ;", "this . container . addAttribute ( name ,    target )  ;", ". StubRequestDataBinder   dataBinder    =    new    . StubRequestDataBinder ( target ,    name )  ;", "WebDataBinderFactory   factory    =    mock ( WebDataBinderFactory . class )  ;", "given ( factory . createBinder ( this . request ,    target ,    name )  )  . willReturn ( dataBinder )  ;", "this . processor . resolveArgument ( this . paramBindingDisabledAttr ,    this . container ,    this . request ,    factory )  ;", "assertFalse ( dataBinder . isBindInvoked (  )  )  ;", "assertTrue ( dataBinder . isValidateInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentBindingDisabled"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" attrName \"  ;", "Object   target    =    new   TestBean (  )  ;", "this . container . addAttribute ( name ,    target )  ;", "this . container . setBindingDisabled ( name )  ;", ". StubRequestDataBinder   dataBinder    =    new    . StubRequestDataBinder ( target ,    name )  ;", "WebDataBinderFactory   factory    =    mock ( WebDataBinderFactory . class )  ;", "given ( factory . createBinder ( this . request ,    target ,    name )  )  . willReturn ( dataBinder )  ;", "this . processor . resolveArgument ( this . paramNamedValidModelAttr ,    this . container ,    this . request ,    factory )  ;", "assertFalse ( dataBinder . isBindInvoked (  )  )  ;", "assertTrue ( dataBinder . isValidateInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentBindingDisabledPreviously"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "testGetAttributeFromModel (  \" attrName \"  ,    this . paramNamedValidModelAttr )  ;", "testGetAttributeFromModel (  \" testBean \"  ,    this . paramModelAttr )  ;", "testGetAttributeFromModel (  \" testBean \"  ,    this . paramNonSimpleType )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentFromModel"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" testBean \"  ;", "Object   testBean    =    new   TestBean ( name )  ;", "this . container . addAttribute ( name ,    testBean )  ;", "this . container . addAttribute (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +    name )  ,    testBean )  ;", "Object   anotherTestBean    =    new   TestBean (  )  ;", "this . container . addAttribute (  \" anotherTestBean \"  ,    anotherTestBean )  ;", ". StubRequestDataBinder   dataBinder    =    new    . StubRequestDataBinder ( testBean ,    name )  ;", "WebDataBinderFactory   binderFactory    =    mock ( WebDataBinderFactory . class )  ;", "given ( binderFactory . createBinder ( this . request ,    testBean ,    name )  )  . willReturn ( dataBinder )  ;", "this . processor . resolveArgument ( this . paramModelAttr ,    this . container ,    this . request ,    binderFactory )  ;", "Object [  ]    values    =    this . container . getModel (  )  . values (  )  . toArray (  )  ;", "assertSame (  \" Resolved   attribute   should   be   updated   to   be   last \"  ,    testBean ,    values [  1  ]  )  ;", "assertSame (  \" BindingResult   of   resolved   attr   should   be   last \"  ,    dataBinder . getBindingResult (  )  ,    values [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentOrdering"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" attrName \"  ;", "Object   target    =    new   TestBean (  )  ;", "this . container . addAttribute ( name ,    target )  ;", ". StubRequestDataBinder   dataBinder    =    new    . StubRequestDataBinder ( target ,    name )  ;", "WebDataBinderFactory   factory    =    mock ( WebDataBinderFactory . class )  ;", "given ( factory . createBinder ( this . request ,    target ,    name )  )  . willReturn ( dataBinder )  ;", "this . processor . resolveArgument ( this . paramNamedValidModelAttr ,    this . container ,    this . request ,    factory )  ;", "assertTrue ( dataBinder . isBindInvoked (  )  )  ;", "assertTrue ( dataBinder . isValidateInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentValidation"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "WebDataBinder   dataBinder    =    new   WebRequestDataBinder ( null )  ;", "WebDataBinderFactory   factory    =    mock ( WebDataBinderFactory . class )  ;", "given ( factory . createBinder ( any (  )  ,    notNull (  )  ,    eq (  \" attrName \"  )  )  )  . willReturn ( dataBinder )  ;", "this . processor . resolveArgument ( this . paramNamedValid ,    this . container ,    this . request ,    factory )  ;", "verify ( factory )  . createBinder ( any (  )  ,    notNull (  )  ,    eq (  \" attrName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentViaDefaultConstructor"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . request    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  )  ;", "this . container    =    new   ModelAndViewContainer (  )  ;", "this . processor    =    new   ModelAttributeMethodProcessor ( false )  ;", "Method   method    =     . ModelAttributeHandler . class . getDeclaredMethod (  \" modelAttribute \"  ,    TestBean . class ,    Errors . class ,    int . class ,    TestBean . class ,    TestBean . class ,    TestBean . class )  ;", "this . paramNamedValidModelAttr    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "this . paramErrors    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "this . paramInt    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "this . paramModelAttr    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "this . paramBindingDisabledAttr    =    new   SynthesizingMethodParameter ( method ,     4  )  ;", "this . paramNonSimpleType    =    new   SynthesizingMethodParameter ( method ,     5  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" annotatedReturnValue \"  )  ;", "this . returnParamNamedModelAttr    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" notAnnotatedReturnValue \"  )  ;", "this . returnParamNonSimpleType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . processor . supportsParameter ( this . paramNamedValidModelAttr )  )  ;", "assertTrue ( this . processor . supportsParameter ( this . paramModelAttr )  )  ;", "assertFalse ( this . processor . supportsParameter ( this . paramErrors )  )  ;", "assertFalse ( this . processor . supportsParameter ( this . paramInt )  )  ;", "assertFalse ( this . processor . supportsParameter ( this . paramNonSimpleType )  )  ;", "}", "METHOD_END"], "methodName": ["supportedParameters"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "processor    =    new   ModelAttributeMethodProcessor ( true )  ;", "assertTrue ( this . processor . supportsParameter ( this . paramNamedValidModelAttr )  )  ;", "assertTrue ( this . processor . supportsParameter ( this . paramErrors )  )  ;", "assertTrue ( this . processor . supportsParameter ( this . paramModelAttr )  )  ;", "assertTrue ( this . processor . supportsParameter ( this . paramNonSimpleType )  )  ;", "assertFalse ( this . processor . supportsParameter ( this . paramInt )  )  ;", "}", "METHOD_END"], "methodName": ["supportedParametersInDefaultResolutionMode"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "processor    =    new   ModelAttributeMethodProcessor ( false )  ;", "assertTrue ( this . processor . supportsReturnType ( returnParamNamedModelAttr )  )  ;", "assertFalse ( this . processor . supportsReturnType ( returnParamNonSimpleType )  )  ;", "}", "METHOD_END"], "methodName": ["supportedReturnTypes"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "processor    =    new   ModelAttributeMethodProcessor ( true )  ;", "assertTrue ( this . processor . supportsReturnType ( returnParamNamedModelAttr )  )  ;", "assertTrue ( this . processor . supportsReturnType ( returnParamNonSimpleType )  )  ;", "}", "METHOD_END"], "methodName": ["supportedReturnTypesInDefaultResolutionMode"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Object   target    =    new   TestBean (  )  ;", "this . container . add ( expectedAttrName ,    target )  ;", "WebDataBinder   dataBinder    =    new   WebRequestDataBinder ( target )  ;", "WebDataBinderFactory   factory    =    mock ( WebDataBinderFactory . class )  ;", "given ( factory . createBinder ( this . request ,    target ,    expectedAttrName )  )  . willReturn ( dataBinder )  ;", "this . processor . resolveArgument ( param ,    this . container ,    this . request ,    factory )  ;", "verify ( factory )  . createBinder ( this . request ,    target ,    expectedAttrName )  ;", "}", "METHOD_END"], "methodName": ["testGetAttributeFromModel"], "fileName": "org.springframework.web.method.annotation.ModelAttributeMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "for    ( MethodParameter   parameter    :    handlerMethod . getMethodParameters (  )  )     {", "if    ( parameter . hasParameterAnnotation ( ModelAttribute . class )  )     {", "String   name    =     . getNameForParameter ( parameter )  ;", "Class <  ?  >    paramType    =    parameter . getParameterType (  )  ;", "if    ( this . sessionAttributesHandler . isHandlerSessionAttribute ( name ,    paramType )  )     {", "result . add ( name )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findSessionAttributeArguments"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "ModelAttribute   ann    =    parameter . getParameterAnnotation ( ModelAttribute . class )  ;", "String   name    =     ( ann    !  =    null )     ?    ann . value (  )     :    null ;", "return   StringUtils . hasText ( name )     ?    name    :    Conventions . getVariableNameForParameter ( parameter )  ;", "}", "METHOD_END"], "methodName": ["getNameForParameter"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "ModelAttribute   ann    =    returnType . getMethodAnnotation ( ModelAttribute . class )  ;", "if    (  ( ann    !  =    null )     &  &     ( StringUtils . hasText ( ann . value (  )  )  )  )     {", "return   ann . value (  )  ;", "} else    {", "Method   method    =    returnType . getMethod (  )  ;", "Assert . state (  ( method    !  =    null )  ,     \" No   handler   method \"  )  ;", "Class <  ?  >    containingClass    =    returnType . getContainingClass (  )  ;", "Class <  ?  >    resolvedType    =    GenericTypeResolver . resolveReturnType ( method ,    containingClass )  ;", "return   Conventions . getVariableNameForReturnType ( method ,    resolvedType ,    returnValue )  ;", "}", "}", "METHOD_END"], "methodName": ["getNameForReturnValue"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelFactory . ModelMethod   modelMethod    :    this . modelMethods )     {", "if    ( modelMethod . checkDependencies ( container )  )     {", "if    ( ModelFactory . logger . isTraceEnabled (  )  )     {", "ModelFactory . logger . trace (  (  \" Selected    @ ModelAttribute   method    \"     +    modelMethod )  )  ;", "}", "this . modelMethods . remove ( modelMethod )  ;", "return   modelMethod ;", "}", "}", "ModelFactory . ModelMethod   modelMethod    =    this . modelMethods . get (  0  )  ;", "if    ( ModelFactory . logger . isTraceEnabled (  )  )     {", "ModelFactory . logger . trace (  (  (  (  \" Selected    @ ModelAttribute   method    ( not   present :     \"     +     ( modelMethod . getUnresolvedDependencies ( container )  )  )     +     \"  )     \"  )     +    modelMethod )  )  ;", "}", "this . modelMethods . remove ( modelMethod )  ;", "return   modelMethod ;", "}", "METHOD_END"], "methodName": ["getNextModelMethod"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "Map < String ,     ?  >    sessionAttributes    =    this . sessionAttributesHandler . retrieveAttributes ( request )  ;", "container . mergeAttributes ( sessionAttributes )  ;", "invokeAttributeMethods ( request ,    container )  ;", "for    ( String   name    :    findSessionAttributeArguments ( handlerMethod )  )     {", "if    (  !  ( container . containsAttribute ( name )  )  )     {", "Object   value    =    this . sessionAttributesHandler . retrieveAttribute ( request ,    name )  ;", "if    ( value    =  =    null )     {", "throw   new   HttpSessionRequiredException (  (  (  \" Expected   session   attribute    '  \"     +    name )     +     \"  '  \"  )  ,    name )  ;", "}", "container . addAttribute ( name ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initModel"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "while    (  !  ( this . modelMethods . isEmpty (  )  )  )     {", "InvocableHandlerMethod   modelMethod    =    getNextModelMethod ( container )  . getHandlerMethod (  )  ;", "ModelAttribute   ann    =    modelMethod . getMethodAnnotation ( ModelAttribute . class )  ;", "Assert . state (  ( ann    !  =    null )  ,     \" No   ModelAttribute   annotation \"  )  ;", "if    ( container . containsAttribute ( ann . name (  )  )  )     {", "if    (  !  ( ann . binding (  )  )  )     {", "container . setBindingDisabled ( ann . name (  )  )  ;", "}", "continue ;", "}", "Object   returnValue    =    modelMethod . invokeForRequest ( request ,    container )  ;", "if    (  !  ( modelMethod . isVoid (  )  )  )     {", "String   returnValueName    =     . getNameForReturnValue ( returnValue ,    modelMethod . getReturnType (  )  )  ;", "if    (  !  ( ann . binding (  )  )  )     {", "container . setBindingDisabled ( returnValueName )  ;", "}", "if    (  !  ( container . containsAttribute ( returnValueName )  )  )     {", "container . addAttribute ( returnValueName ,    returnValue )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["invokeModelAttributeMethods"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeName . startsWith ( MODEL _ KEY _ PREFIX )  )     {", "return   false ;", "}", "if    ( this . sessionAttributesHandler . isHandlerSessionAttribute ( attributeName ,    value . getClass (  )  )  )     {", "return   true ;", "}", "return    (  (  (  !  ( value . getClass (  )  . isArray (  )  )  )     &  &     (  !  ( value   instanceof   Collec )  )  )     &  &     (  !  ( value   instanceof   Map )  )  )     &  &     (  !  ( BeanUtils . isSimpleValueType ( value . getClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isBindingCandidate"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "List < String >    keyNames    =    new   ArrayList ( model . keySet (  )  )  ;", "for    ( String   name    :    keyNames )     {", "Object   value    =    model . get ( name )  ;", "if    (  ( value    !  =    null )     &  &     ( isBindingCandidate ( name ,    value )  )  )     {", "String   bindingResultKey    =     ( BindingResult . MODEL _ KEY _ PREFIX )     +    name ;", "if    (  !  ( model . containsAttribute ( bindingResultKey )  )  )     {", "WebDataBinder   dataBinder    =    this . dataBinder . createBinder ( request ,    value ,    name )  ;", "model . put ( bindingResultKey ,    dataBinder . getBindingResult (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["updateBindingResult"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "ModelMap   defaultModel    =    container . getDefaultModel (  )  ;", "if    ( container . getSessionStatus (  )  . isComplete (  )  )     {", "this . sessionAttributesHandler . cleanupAttributes ( request )  ;", "} else    {", "this . sessionAttributesHandler . storeAttributes ( request ,    defaultModel )  ;", "}", "if    (  (  !  ( container . isRequestHandled (  )  )  )     &  &     (  ( container . getModel (  )  )     =  =    defaultModel )  )     {", "updateBindingResult ( request ,    defaultModel )  ;", "}", "}", "METHOD_END"], "methodName": ["updateModel"], "fileName": "org.springframework.web.method.annotation.ModelFactory"}, {"methodBody": ["METHOD_START", "{", "runTest ( new   ModelFactoryOrderingTests . InvertedTreeDependencyController (  )  )  ;", "assertInvokedBefore (  \" getC 1  \"  ,     \" getA \"  ,     \" getB 1  \"  )  ;", "assertInvokedBefore (  \" getC 2  \"  ,     \" getA \"  ,     \" getB 1  \"  )  ;", "assertInvokedBefore (  \" getC 3  \"  ,     \" getA \"  ,     \" getB 2  \"  )  ;", "assertInvokedBefore (  \" getC 4  \"  ,     \" getA \"  ,     \" getB 2  \"  )  ;", "assertInvokedBefore (  \" getB 1  \"  ,     \" getA \"  )  ;", "assertInvokedBefore (  \" getB 2  \"  ,     \" getA \"  )  ;", "}", "METHOD_END"], "methodName": ["InvertedTreeDependency"], "fileName": "org.springframework.web.method.annotation.ModelFactoryOrderingTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    actual    =    getInvokedMethods (  )  ;", "for    ( String   afterMethod    :    afterMethods )     {", "assertTrue (  (  (  (  ( beforeMethod    +     \"    should   be   before    \"  )     +    afterMethod )     +     \"  .    Actual   order :     \"  )     +     ( actual . toString (  )  )  )  ,     (  ( actual . indexOf ( beforeMethod )  )     <     ( actual . indexOf ( afterMethod )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertInvokedBefore"], "fileName": "org.springframework.web.method.annotation.ModelFactoryOrderingTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( List < String >  )     ( this . mavContainer . getModel (  )  . get (  \" methods \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInvokedMethods"], "fileName": "org.springframework.web.method.annotation.ModelFactoryOrderingTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodArgumentResolverComposite   resolvers    =    new   HandlerMethodArgumentResolverComposite (  )  ;", "resolvers . addResolver ( new   ModelAttributeMethodProcessor ( false )  )  ;", "resolvers . addResolver ( new   ModelMethodProcessor (  )  )  ;", "WebDataBinderFactory   dataBinderFactory    =    new   DefaultDataBinderFactory ( null )  ;", "Class <  ?  >    type    =    controller . getClass (  )  ;", "Set < Method >    methods    =    MethodIntrospector . selectMethods ( type ,     . METHOD _ FILTER )  ;", "List < InvocableHandlerMethod >    modelMethods    =    new   ArrayList <  >  (  )  ;", "for    ( Method   method    :    methods )     {", "InvocableHandlerMethod   modelMethod    =    new   InvocableHandlerMethod ( controller ,    method )  ;", "modelMethod . setHandlerMethodArgumentResolvers ( resolvers )  ;", "modelMethod . setDataBinderFactory ( dataBinderFactory )  ;", "modelMethods . add ( modelMethod )  ;", "}", "Collections . shuffle ( modelMethods )  ;", "SessionAttributesHandler   sessionHandler    =    new   SessionAttributesHandler ( type ,    this . sessionAttributeStore )  ;", "ModelFactory   factory    =    new   ModelFactory ( modelMethods ,    dataBinderFactory ,    sessionHandler )  ;", "factory . initModel ( this . webRequest ,    this . mavContainer ,    new   HandlerMethod ( controller ,     \" handle \"  )  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( String   name    :    getInvokedMethods (  )  )     {", "sb . append (  \"     >  >     \"  )  . append ( name )  ;", "}", ". logger . debug ( sb )  ;", "}", "}", "METHOD_END"], "methodName": ["runTest"], "fileName": "org.springframework.web.method.annotation.ModelFactoryOrderingTests"}, {"methodBody": ["METHOD_START", "{", "this . sessionAttributeStore    =    new   DefaultSessionAttributeStore (  )  ;", "this . webRequest    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  ,    new   MockHttpServletResponse (  )  )  ;", "this . mavContainer    =    new   ModelAndViewContainer (  )  ;", "this . mavContainer . addAttribute (  \" s \"  ,    new   ArrayList < String >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.method.annotation.ModelFactoryOrderingTests"}, {"methodBody": ["METHOD_START", "{", "runTest ( new   ModelFactoryOrderingTests . StraightLineDependencyController (  )  )  ;", "assertInvokedBefore (  \" getA \"  ,     \" getB 1  \"  ,     \" getB 2  \"  ,     \" getC 1  \"  ,     \" getC 2  \"  ,     \" getC 3  \"  ,     \" getC 4  \"  )  ;", "assertInvokedBefore (  \" getB 1  \"  ,     \" getB 2  \"  ,     \" getC 1  \"  ,     \" getC 2  \"  ,     \" getC 3  \"  ,     \" getC 4  \"  )  ;", "assertInvokedBefore (  \" getB 2  \"  ,     \" getC 1  \"  ,     \" getC 2  \"  ,     \" getC 3  \"  ,     \" getC 4  \"  )  ;", "assertInvokedBefore (  \" getC 1  \"  ,     \" getC 2  \"  ,     \" getC 3  \"  ,     \" getC 4  \"  )  ;", "assertInvokedBefore (  \" getC 2  \"  ,     \" getC 3  \"  ,     \" getC 4  \"  )  ;", "assertInvokedBefore (  \" getC 3  \"  ,     \" getC 4  \"  )  ;", "}", "METHOD_END"], "methodName": ["straightLineDependency"], "fileName": "org.springframework.web.method.annotation.ModelFactoryOrderingTests"}, {"methodBody": ["METHOD_START", "{", "runTest ( new   ModelFactoryOrderingTests . TreeDependencyController (  )  )  ;", "assertInvokedBefore (  \" getA \"  ,     \" getB 1  \"  ,     \" getB 2  \"  ,     \" getC 1  \"  ,     \" getC 2  \"  ,     \" getC 3  \"  ,     \" getC 4  \"  )  ;", "assertInvokedBefore (  \" getB 1  \"  ,     \" getC 1  \"  ,     \" getC 2  \"  )  ;", "assertInvokedBefore (  \" getB 2  \"  ,     \" getC 3  \"  ,     \" getC 4  \"  )  ;", "}", "METHOD_END"], "methodName": ["treeDependency"], "fileName": "org.springframework.web.method.annotation.ModelFactoryOrderingTests"}, {"methodBody": ["METHOD_START", "{", "runTest ( new   ModelFactoryOrderingTests . UnresolvedDependencyController (  )  )  ;", "assertInvokedBefore (  \" getA \"  ,     \" getC 1  \"  ,     \" getC 2  \"  ,     \" getC 3  \"  ,     \" getC 4  \"  )  ;", "}", "METHOD_END"], "methodName": ["unresolvedDependency"], "fileName": "org.springframework.web.method.annotation.ModelFactoryOrderingTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    this . controller . getClass (  )  . getMethod ( methodName ,    paramTypes )  ;", "return   new   InvocableHandlerMethod ( this . controller ,    method )  ;", "}", "METHOD_END"], "methodName": ["createHandlerMethod"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodArgumentResolverComposite   resolvers    =    new   HandlerMethodArgumentResolverComposite (  )  ;", "resolvers . addResolver ( new   ModelMethodProcessor (  )  )  ;", "InvocableHandlerMethod   modelMethod    =    createHandlerMethod ( methodName ,    parameterTypes )  ;", "modelMethod . setHandlerMethodArgumentResolvers ( resolvers )  ;", "modelMethod . setDataBinderFactory ( null )  ;", "modelMethod . setParameterNameDiscoverer ( new   LocalVariableTableParameterNameDiscoverer (  )  )  ;", "return   new    ( Collections . singletonList ( modelMethod )  ,    null ,    this . attributeHandler )  ;", "}", "METHOD_END"], "methodName": ["createModelFactory"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ModelFactoryTests . Foo   foo    =    new   ModelFactoryTests . Foo (  )  ;", "this . attributeStore . storeAttribute ( this . webRequest ,     \" foo \"  ,    foo )  ;", "ModelFactory   modelFactory    =    createModelFactory (  \" modelAttrWithBindingDisabled \"  )  ;", "HandlerMethod   handlerMethod    =    createHandlerMethod (  \" handle \"  )  ;", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "assertTrue ( this . mavContainer . containsAttribute (  \" foo \"  )  )  ;", "assertSame ( foo ,    this . mavContainer . getModel (  )  . get (  \" foo \"  )  )  ;", "assertTrue ( this . mavContainer . isBindingDisabled (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeFromSessionWithBindingDisabled"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ModelFactory   modelFactory    =    createModelFactory (  \" modelAttr \"  ,    Model . class )  ;", "HandlerMethod   handlerMethod    =    createHandlerMethod (  \" handle \"  )  ;", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "assertEquals ( Boolean . TRUE ,    this . mavContainer . getModel (  )  . get (  \" modelAttr \"  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeMethod"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ModelFactory   modelFactory    =    createModelFactory (  \" modelAttrWithName \"  )  ;", "HandlerMethod   handlerMethod    =    createHandlerMethod (  \" handle \"  )  ;", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "assertEquals ( Boolean . TRUE ,    this . mavContainer . getModel (  )  . get (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeMethodWithExplicitName"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ModelFactory   modelFactory    =    createModelFactory (  \" modelAttrConvention \"  )  ;", "HandlerMethod   handlerMethod    =    createHandlerMethod (  \" handle \"  )  ;", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "assertEquals ( Boolean . TRUE ,    this . mavContainer . getModel (  )  . get (  \" boolean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeMethodWithNameByConvention"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ModelFactory   modelFactory    =    createModelFactory (  \" nullModelAttr \"  )  ;", "HandlerMethod   handlerMethod    =    createHandlerMethod (  \" handle \"  )  ;", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "assertTrue ( this . mavContainer . containsAttribute (  \" name \"  )  )  ;", "assertNull ( this . mavContainer . getModel (  )  . get (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeMethodWithNullReturnValue"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ModelFactory   modelFactory    =    createModelFactory (  \" modelAttrWithBindingDisabled \"  )  ;", "HandlerMethod   handlerMethod    =    createHandlerMethod (  \" handle \"  )  ;", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "assertTrue ( this . mavContainer . containsAttribute (  \" foo \"  )  )  ;", "assertTrue ( this . mavContainer . isBindingDisabled (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeWithBindingDisabled"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "this . attributeStore . storeAttribute ( this . webRequest ,     \" sessionAttr \"  ,     \" sessionAttrValue \"  )  ;", "modelFactory    =    create (  \" modelAttr \"  ,    Model . class )  ;", "HandlerMethod   handlerMethod    =    createHandlerMethod (  \" handle \"  )  ;", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "assertEquals (  \" sessionAttrValue \"  ,    this . mavContainer . getModel (  )  . get (  \" sessionAttr \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sessionAttribute"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ModelFactory   modelFactory    =    new   ModelFactory ( null ,    null ,    this . attributeHandler )  ;", "HandlerMethod   handlerMethod    =    createHandlerMethod (  \" handleSessionAttr \"  ,    String . class )  ;", "try    {", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "fail (  \" Expected   HttpSessionRequiredException \"  )  ;", "}    catch    ( HttpSessionRequiredException   ex )     {", "}", "this . attributeStore . storeAttribute ( this . webRequest ,     \" sessionAttr \"  ,     \" sessionAttrValue \"  )  ;", "modelFactory . initModel ( this . webRequest ,    this . mavContainer ,    handlerMethod )  ;", "assertEquals (  \" sessionAttrValue \"  ,    this . mavContainer . getModel (  )  . get (  \" sessionAttr \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sessionAttributeNotPresent"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "this . webRequest    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  )  ;", "this . attributeStore    =    new   DefaultSessionAttributeStore (  )  ;", "this . attributeHandler    =    new   SessionAttributesHandler (  . TestController . class ,    this . attributeStore )  ;", "this . controller    =    new    . TestController (  )  ;", "this . mavContainer    =    new   ModelAndViewContainer (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   commandName    =     \" attr 1  \"  ;", "Object   command    =    new   Object (  )  ;", "ModelAndViewContainer   container    =    new   ModelAndViewContainer (  )  ;", "container . addAttribute ( commandName ,    command )  ;", "WebDataBinder   dataBinder    =    new   WebDataBinder ( command ,    commandName )  ;", "WebDataBinderFactory   binderFactory    =    mock ( WebDataBinderFactory . class )  ;", "given ( binderFactory . createBinder ( this . webRequest ,    command ,    commandName )  )  . willReturn ( dataBinder )  ;", "modelFactory    =    new    ( null ,    binderFactory ,    this . attributeHandler )  ;", "modelFactory . updateModel ( this . webRequest ,    container )  ;", "assertEquals ( command ,    container . getModel (  )  . get ( commandName )  )  ;", "String   bindingResultKey    =     ( BindingResult . MODEL _ KEY _ PREFIX )     +    commandName ;", "assertSame ( dataBinder . getBindingResult (  )  ,    container . getModel (  )  . get ( bindingResultKey )  )  ;", "assertEquals (  2  ,    container . getModel (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["updateModelBindingResult"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   attributeName    =     \" sessionAttr \"  ;", "String   attribute    =     \" value \"  ;", "ModelAndViewContainer   container    =    new   ModelAndViewContainer (  )  ;", "container . addAttribute ( attributeName ,    attribute )  ;", "this . attributeStore . storeAttribute ( this . webRequest ,    attributeName ,    attribute )  ;", "WebDataBinder   dataBinder    =    new   WebDataBinder ( attribute ,    attributeName )  ;", "WebDataBinderFactory   binderFactory    =    mock ( WebDataBinderFactory . class )  ;", "given ( binderFactory . createBinder ( this . webRequest ,    attribute ,    attributeName )  )  . willReturn ( dataBinder )  ;", "container . getSessionStatus (  )  . setComplete (  )  ;", "modelFactory    =    new    ( null ,    binderFactory ,    this . attributeHandler )  ;", "modelFactory . updateModel ( this . webRequest ,    container )  ;", "assertEquals ( attribute ,    container . getModel (  )  . get ( attributeName )  )  ;", "assertNull ( this . attributeStore . retrieveAttribute ( this . webRequest ,    attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["updateModelSessionAttributesRemoved"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   attributeName    =     \" sessionAttr \"  ;", "String   attribute    =     \" value \"  ;", "ModelAndViewContainer   container    =    new   ModelAndViewContainer (  )  ;", "container . addAttribute ( attributeName ,    attribute )  ;", "WebDataBinder   dataBinder    =    new   WebDataBinder ( attribute ,    attributeName )  ;", "WebDataBinderFactory   binderFactory    =    mock ( WebDataBinderFactory . class )  ;", "given ( binderFactory . createBinder ( this . webRequest ,    attribute ,    attributeName )  )  . willReturn ( dataBinder )  ;", "modelFactory    =    new    ( null ,    binderFactory ,    this . attributeHandler )  ;", "modelFactory . updateModel ( this . webRequest ,    container )  ;", "assertEquals ( attribute ,    container . getModel (  )  . get ( attributeName )  )  ;", "assertEquals ( attribute ,    this . attributeStore . retrieveAttribute ( this . webRequest ,    attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["updateModelSessionAttributesSaved"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   attributeName    =     \" sessionAttr \"  ;", "String   attribute    =     \" value \"  ;", "ModelAndViewContainer   container    =    new   ModelAndViewContainer (  )  ;", "container . addAttribute ( attributeName ,    attribute )  ;", "String   queryParam    =     \"  1  2  3  \"  ;", "String   queryParamName    =     \" q \"  ;", "container . setRedirectModel ( new   ModelMap ( queryParamName ,    queryParam )  )  ;", "container . setRedirectModelScenario ( true )  ;", "WebDataBinder   dataBinder    =    new   WebDataBinder ( attribute ,    attributeName )  ;", "WebDataBinderFactory   binderFactory    =    mock ( WebDataBinderFactory . class )  ;", "given ( binderFactory . createBinder ( this . webRequest ,    attribute ,    attributeName )  )  . willReturn ( dataBinder )  ;", "modelFactory    =    new    ( null ,    binderFactory ,    this . attributeHandler )  ;", "modelFactory . updateModel ( this . webRequest ,    container )  ;", "assertEquals ( queryParam ,    container . getModel (  )  . get ( queryParamName )  )  ;", "assertEquals (  1  ,    container . getModel (  )  . size (  )  )  ;", "assertEquals ( attribute ,    this . attributeStore . retrieveAttribute ( this . webRequest ,    attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["updateModelWhenRedirecting"], "fileName": "org.springframework.web.method.annotation.ModelFactoryTests"}, {"methodBody": ["METHOD_START", "{", "mavContainer . addAttribute (  \" attr 1  \"  ,     \" value 1  \"  )  ;", "Model   returnValue    =    new   ExtendedModelMap (  )  ;", "returnValue . addAttribute (  \" attr 2  \"  ,     \" value 2  \"  )  ;", "p . handleReturnValue ( returnValue ,    returnParamModel ,    mavContainer ,    webRequest )  ;", "assertEquals (  \" value 1  \"  ,    mavContainer . getModel (  )  . get (  \" attr 1  \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    mavContainer . getModel (  )  . get (  \" attr 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleModelReturnValue"], "fileName": "org.springframework.web.method.annotation.ModelMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["model"], "fileName": "org.springframework.web.method.annotation.ModelMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( mavContainer . getModel (  )  ,    processor . resolveArgument ( paramModel ,    mavContainer ,    webRequest ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentValue"], "fileName": "org.springframework.web.method.annotation.ModelMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "processor    =    new   ModelMethodProcessor (  )  ;", "mavContainer    =    new   ModelAndViewContainer (  )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" model \"  ,    Model . class )  ;", "paramModel    =    new   MethodParameter ( method ,     0  )  ;", "returnParamModel    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "webRequest    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.ModelMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( processor . supportsParameter ( paramModel )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.ModelMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( processor . supportsReturnType ( returnParamModel )  )  ;", "}", "METHOD_END"], "methodName": ["supportsReturnType"], "fileName": "org.springframework.web.method.annotation.ModelMethodProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value 1     =     \" bar \"  ;", "String   value 2     =     \" baz \"  ;", "request . addHeader ( name ,    value 1  )  ;", "request . addHeader ( name ,    value 2  )  ;", "HttpHeaders   expected    =    new   HttpHeaders (  )  ;", "expected . add ( name ,    value 1  )  ;", "expected . add ( name ,    value 2  )  ;", "Object   result    =    resolver . resolve ( paramHttpHeaders ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   HttpHeaders )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveHttpHeadersArgument"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value    =     \" bar \"  ;", "Map < String ,    String >    expected    =    Collections . singletonMap ( name ,    value )  ;", "request . addHeader ( name ,    value )  ;", "Object   result    =    resolver . resolve ( paramMap ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   Map )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMapArgument"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value 1     =     \" bar \"  ;", "String   value 2     =     \" baz \"  ;", "request . addHeader ( name ,    value 1  )  ;", "request . addHeader ( name ,    value 2  )  ;", "MultiValueMap < String ,    String >    expected    =    new   util . LinkedMultiValueMap (  1  )  ;", "expected . add ( name ,    value 1  )  ;", "expected . add ( name ,    value 2  )  ;", "Object   result    =    resolver . resolveArgument ( paramMultiValueMap ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   MultiValueMap )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMultiValueMapArgument"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver    =    new   RequestHeaderMapMethodArgumentResolver (  )  ;", "Method   method    =    getClass (  )  . getMethod (  \" params \"  ,    Map . class ,    MultiValueMap . class ,    HttpHeaders . class ,    Map . class )  ;", "paramMap    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "paramMultiValueMap    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "paramHttpHeaders    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "paramUnsupported    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "webRequest    =    new   ServletWebRequest ( request ,    new   MockHttpServletResponse (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Map   parameter   not   supported \"  ,    resolver . supportsParameter ( paramMap )  )  ;", "assertTrue (  \" MultiValueMap   parameter   not   supported \"  ,    resolver . supportsParameter ( paramMultiValueMap )  )  ;", "assertTrue (  \" HttpHeaders   parameter   not   supported \"  ,    resolver . supportsParameter ( paramHttpHeaders )  )  ;", "assertFalse (  \" non -  @ RequestParam   map   supported \"  ,    resolver . supportsParameter ( paramUnsupported )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   rfc 1  1  2  3 val    =     \" Thu ,     2  1    Apr    2  0  1  6     1  7  :  1  1  :  0  8     +  0  1  0  0  \"  ;", "servletRequest . addHeader (  \" name \"  ,    rfc 1  1  2  3 val )  ;", "ConfigurableWebBindingInitializer   bindingInitializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "bindingInitializer . setConversionService ( new   DefaultFormattingConversionService (  )  )  ;", "Object   result    =    resolver . resolve ( paramDate ,    null ,    webRequest ,    new   DefaultDataBinderFactory ( bindingInitializer )  )  ;", "assertTrue (  ( result   instanceof   Date )  )  ;", "assertEquals ( new   Date ( rfc 1  1  2  3 val )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["dateConversion"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   rfc 1  1  2  3 val    =     \" Thu ,     2  1    Apr    2  0  1  6     1  7  :  1  1  :  0  8     +  0  1  0  0  \"  ;", "servletRequest . addHeader (  \" name \"  ,    rfc 1  1  2  3 val )  ;", "ConfigurableWebBindingInitializer   bindingInitializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "bindingInitializer . setConversionService ( new   DefaultFormattingConversionService (  )  )  ;", "Object   result    =    resolver . resolve ( paramInstant ,    null ,    webRequest ,    new   DefaultDataBinderFactory ( bindingInitializer )  )  ;", "assertTrue (  ( result   instanceof   Instant )  )  ;", "assertEquals ( Instant . from ( DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME . parse ( rfc 1  1  2  3 val )  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["instantConversion"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . resolveArgument ( paramNamedValueStringArray ,    null ,    webRequest ,    null )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    resolver . resolveArgument ( paramNamedDefaultValueStringHeader ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultValue"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "servletRequest . setContextPath (  \"  / bar \"  )  ;", "Object   result    =    resolver . resolve ( paramContextPath ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \"  / bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultValueFromRequest"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" systemProperty \"  ,     \" bar \"  )  ;", "try    {", "Object   result    =    resolver . resolve ( paramSystemProperty ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveDefaultValueFromSystemProperty"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" foo \"  ;", "servletRequest . addHeader (  \" bar \"  ,    expected )  ;", "System . setProperty (  \" systemProperty \"  ,     \" bar \"  )  ;", "try    {", "Object   result    =    resolver . resolve ( paramResolvedNameWithExpression ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals ( expected ,    result )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveNameFromSystemPropertyThroughExpression"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" foo \"  ;", "servletRequest . addHeader (  \" bar \"  ,    expected )  ;", "System . setProperty (  \" systemProperty \"  ,     \" bar \"  )  ;", "try    {", "Object   result    =    resolver . resolve ( paramResolvedNameWithPlaceholder ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals ( expected ,    result )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveNameFromSystemPropertyThroughPlaceholder"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" foo \"  ;", "servletRequest . addHeader (  \" name \"  ,    expected )  ;", "Object   result    =    resolver . resolve ( paramNamedDefaultValueStringHeader ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveStringArgument"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    expected    =    new   String [  ]  {     \" foo \"  ,     \" bar \"     }  ;", "servletRequest . addHeader (  \" name \"  ,    expected )  ;", "Object   result    =    resolver . resolve ( paramNamedValueStringArray ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String [  ]  )  )  ;", "assertArrayEquals ( expected ,     (  ( String [  ]  )     ( result )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveStringArrayArgument"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "GenericWebApplicationContext   context    =    new   GenericWebApplicationContext (  )  ;", "context . refresh (  )  ;", "resolver    =    new    ( context . getBeanFactory (  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" params \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "paramNamedDefaultValueStringHeader    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "paramNamedValueStringArray    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "paramSystemProperty    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "paramContextPath    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "paramResolvedNameWithExpression    =    new   SynthesizingMethodParameter ( method ,     4  )  ;", "paramResolvedNameWithPlaceholder    =    new   SynthesizingMethodParameter ( method ,     5  )  ;", "paramNamedValueMap    =    new   SynthesizingMethodParameter ( method ,     6  )  ;", "paramDate    =    new   SynthesizingMethodParameter ( method ,     7  )  ;", "paramInstant    =    new   SynthesizingMethodParameter ( method ,     8  )  ;", "servletRequest    =    new   MockHttpServletRequest (  )  ;", "webRequest    =    new   ServletWebRequest ( servletRequest ,    new   MockHttpServletResponse (  )  )  ;", "RequestContextHolder . setRequestAttributes ( webRequest )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" String   parameter   not   supported \"  ,    resolver . supportsParameter ( paramNamedDefaultValueStringHeader )  )  ;", "assertTrue (  \" String   array   parameter   not   supported \"  ,    resolver . supportsParameter ( paramNamedValueStringArray )  )  ;", "assertFalse (  \" non -  @ RequestParam   parameter   supported \"  ,    resolver . supportsParameter ( paramNamedValueMap )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolder . resetRequestAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.springframework.web.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value    =     \" bar \"  ;", "request . addParameter ( name ,    value )  ;", "Map < String ,    String >    expected    =    Collections . singletonMap ( name ,    value )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . requestParam (  )  . noName (  )  )  . arg ( Map . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   Map )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMapArgument"], "fileName": "org.springframework.web.method.annotation.RequestParamMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value 1     =     \" bar \"  ;", "String   value 2     =     \" baz \"  ;", "request . addParameter ( name ,    value 1  ,    value 2  )  ;", "MultiValueMap < String ,    String >    expected    =    new   util . LinkedMultiValueMap (  1  )  ;", "expected . add ( name ,    value 1  )  ;", "expected . add ( name ,    value 2  )  ;", "MethodParameter   param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( MultiValueMap . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   MultiValueMap )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMultiValueMapArgument"], "fileName": "org.springframework.web.method.annotation.RequestParamMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver    =    new   RequestParamMapMethodArgumentResolver (  )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "webRequest    =    new   ServletWebRequest ( request ,    new   MockHttpServletResponse (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.RequestParamMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . noName (  )  )  . arg ( Map . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent (  . class )  . arg ( MultiValueMap . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . name (  \" name \"  )  )  . arg ( Map . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent (  . class )  . arg ( Map . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.RequestParamMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   null ;", "} else", "if    ( value   instanceof   String )     {", "return    (  ( String )     ( value )  )  ;", "} else", "if    ( cs    !  =    null )     {", "return    (  ( String )     ( cs . convert ( value ,    sourceType ,     . STRING _ TYPE _ DESCRIPTOR )  )  )  ;", "} else    {", "return   value . toString (  )  ;", "}", "}", "METHOD_END"], "methodName": ["formatUriValue"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( MultipartFile . class )  ;", "resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "fail (  \" Expected   exception :    request   is   not   a   multipart   request \"  )  ;", "}", "METHOD_END"], "methodName": ["isMultipartRequest"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "MultipartFile   expected    =    new   MockMultipartFile (  \" multipartFileList \"  ,     \" Hello   World \"  . getBytes (  )  )  ;", "request . addFile ( expected )  ;", "request . setMethod (  \" PUT \"  )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent (  . class )  . arg ( List . class ,    MultipartFile . class )  ;", "Object   actual    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( actual   instanceof   List )  )  ;", "assertEquals ( expected ,     (  ( List <  ?  >  )     ( actual )  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["isMultipartRequestHttpPut"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "request . setMethod (  \" POST \"  )  ;", "request . setContentType (  \" multipart / form - data \"  )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( MultipartFile . class )  ;", "resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "fail (  \" Expected   exception :    no   such   part   found \"  )  ;", "}", "METHOD_END"], "methodName": ["missingMultipartFile"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "request . setMethod (  \" POST \"  )  ;", "request . setContentType (  \" multipart / form - data \"  )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    MultipartFile . class )  ;", "Object   actual    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . empty (  )  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["missingOptionalMultipartFile"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    Integer [  ]  . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . empty (  )  ,    result )  ;", "result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . class ,    result . getClass (  )  )  ;", "assertFalse (  (  ( Optional )     ( result )  )  . isPresent (  )  )  ;", "}", "METHOD_END"], "methodName": ["missingOptionalParamArray"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    List . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . empty (  )  ,    result )  ;", "result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . class ,    result . getClass (  )  )  ;", "assertFalse (  (  ( Optional )     ( result )  )  . isPresent (  )  )  ;", "}", "METHOD_END"], "methodName": ["missingOptionalParamList"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    Integer . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . empty (  )  ,    result )  ;", "result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . class ,    result . getClass (  )  )  ;", "assertFalse (  (  ( Optional )     ( result )  )  . isPresent (  )  )  ;", "}", "METHOD_END"], "methodName": ["missingOptionalParamValue"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( String [  ]  . class )  ;", "resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "fail (  \" Expected   exception \"  )  ;", "}", "METHOD_END"], "methodName": ["missingRequestParam"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "WebDataBinder   binder    =    new   WebRequestDataBinder ( null )  ;", "binder . registerCustomEditor ( String . class ,    new   StringTrimmerEditor ( true )  )  ;", "WebDataBinderFactory   binderFactory    =    mock ( WebDataBinderFactory . class )  ;", "given ( binderFactory . createBinder ( webRequest ,    null ,     \" stringNotAnnot \"  )  )  . willReturn ( binder )  ;", "this . request . addParameter (  \" stringNotAnnot \"  ,     \"  \"  )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent (  . class )  . arg ( String . class )  ;", "Object   arg    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertNull ( arg )  ;", "}", "METHOD_END"], "methodName": ["missingRequestParamEmptyValueConvertedToNull"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "WebDataBinder   binder    =    new   WebRequestDataBinder ( null )  ;", "binder . registerCustomEditor ( String . class ,    new   StringTrimmerEditor ( true )  )  ;", "WebDataBinderFactory   binderFactory    =    mock ( WebDataBinderFactory . class )  ;", "given ( binderFactory . createBinder ( webRequest ,    null ,     \" name \"  )  )  . willReturn ( binder )  ;", "this . request . addParameter (  \" name \"  ,     \"  \"  )  ;", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  )  )  . arg ( String . class )  ;", "Object   arg    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertNull ( arg )  ;", "}", "METHOD_END"], "methodName": ["missingRequestParamEmptyValueNotRequired"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "request . setMethod (  \" POST \"  )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( MultipartFile . class )  ;", "resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "fail (  \" Expected   exception :    no   multipart   content \"  )  ;", "}", "METHOD_END"], "methodName": ["noMultipartContent"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    MultipartFile . class )  ;", "Object   actual    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . empty (  )  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["optionalMultipartFileWithoutMultipartRequest"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  \" bar \"  )  )  . arg ( String . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultValue"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addParameter (  \" name \"  ,     \"  \"  )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  )  )  . arg ( String . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertEquals (  \"  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveEmptyValueRequiredWithoutDefault"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addParameter (  \" name \"  ,     \"  \"  )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  \" bar \"  )  )  . arg ( String . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveEmptyValueToDefault"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . request . addParameter (  \" stringNotAnnot \"  ,     \"  \"  )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent (  . class )  . arg ( String . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertEquals (  \"  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveEmptyValueWithoutDefault"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "MultipartFile   expected    =    new   MockMultipartFile (  \" mfile \"  ,     \" Hello   World \"  . getBytes (  )  )  ;", "request . addFile ( expected )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( MultipartFile . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   MultipartFile )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMultipartFile"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "MultipartFile   expected 1     =    new   MockMultipartFile (  \" mfilearray \"  ,     \" Hello   World    1  \"  . getBytes (  )  )  ;", "MultipartFile   expected 2     =    new   MockMultipartFile (  \" mfilearray \"  ,     \" Hello   World    2  \"  . getBytes (  )  )  ;", "request . addFile ( expected 1  )  ;", "request . addFile ( expected 2  )  ;", "request . addFile ( new   MockMultipartFile (  \" other \"  ,     \" Hello   World    3  \"  . getBytes (  )  )  )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( MultipartFile [  ]  . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   MultipartFile [  ]  )  )  ;", "MultipartFile [  ]    parts    =     (  ( MultipartFile [  ]  )     ( result )  )  ;", "assertEquals (  2  ,    parts . length )  ;", "assertEquals ( parts [  0  ]  ,    expected 1  )  ;", "assertEquals ( parts [  1  ]  ,    expected 2  )  ;", "}", "METHOD_END"], "methodName": ["resolveMultipartFileArray"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "MultipartFile   expected 1     =    new   MockMultipartFile (  \" mfilelist \"  ,     \" Hello   World    1  \"  . getBytes (  )  )  ;", "MultipartFile   expected 2     =    new   MockMultipartFile (  \" mfilelist \"  ,     \" Hello   World    2  \"  . getBytes (  )  )  ;", "request . addFile ( expected 1  )  ;", "request . addFile ( expected 2  )  ;", "request . addFile ( new   MockMultipartFile (  \" other \"  ,     \" Hello   World    3  \"  . getBytes (  )  )  )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( List . class ,    MultipartFile . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   List )  )  ;", "assertEquals ( Arrays . asList ( expected 1  ,    expected 2  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMultipartFileList"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "MultipartFile   expected 1     =    new   MockMultipartFile (  \" multipartFileList \"  ,     \" Hello   World    1  \"  . getBytes (  )  )  ;", "MultipartFile   expected 2     =    new   MockMultipartFile (  \" multipartFileList \"  ,     \" Hello   World    2  \"  . getBytes (  )  )  ;", "request . addFile ( expected 1  )  ;", "request . addFile ( expected 2  )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent (  . class )  . arg ( List . class ,    MultipartFile . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   List )  )  ;", "assertEquals ( Arrays . asList ( expected 1  ,    expected 2  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMultipartFileListNotannot"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "MultipartFile   expected    =    new   MockMultipartFile (  \" multipartFileNotAnnot \"  ,     \" Hello   World \"  . getBytes (  )  )  ;", "request . addFile ( expected )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMNotPresent (  )  . arg ( MultipartFile . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   MultipartFile )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMultipartFileNotAnnot"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "MockMultipartHttpServletRequest   request    =    new   MockMultipartHttpServletRequest (  )  ;", "MultipartFile   expected    =    new   MockMultipartFile (  \" mfile \"  ,     \" Hello   World \"  . getBytes (  )  )  ;", "request . addFile ( expected )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    MultipartFile . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertTrue (  ( result   instanceof   Optional )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,     (  ( Optional <  ?  >  )     ( result )  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveOptionalMultipartFile"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    Integer [  ]  . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . empty (  )  ,    result )  ;", "this . request . addParameter (  \" name \"  ,     \"  1  2  3  \"  ,     \"  4  5  6  \"  )  ;", "result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . class ,    result . getClass (  )  )  ;", "assertArrayEquals ( new   Integer [  ]  {     1  2  3  ,     4  5  6     }  ,     (  ( Integer [  ]  )     (  (  ( Optional )     ( result )  )  . get (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveOptionalParamArray"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    List . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . empty (  )  ,    result )  ;", "this . request . addParameter (  \" name \"  ,     \"  1  2  3  \"  ,     \"  4  5  6  \"  )  ;", "result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . class ,    result . getClass (  )  )  ;", "assertEquals ( Arrays . asList (  \"  1  2  3  \"  ,     \"  4  5  6  \"  )  ,     (  ( Optional )     ( result )  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveOptionalParamList"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultConversionService (  )  )  ;", "WebDataBinderFactory   binderFactory    =    new   DefaultDataBinderFactory ( initializer )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Optional . class ,    Integer . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . empty (  )  ,    result )  ;", "this . request . addParameter (  \" name \"  ,     \"  1  2  3  \"  )  ;", "result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    binderFactory )  ;", "assertEquals ( Optional . class ,    result . getClass (  )  )  ;", "assertEquals (  1  2  3  ,     (  ( Optional )     ( result )  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveOptionalParamValue"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockPart   expected    =    new   MockPart (  \" pfile \"  ,     \" Hello   World \"  . getBytes (  )  )  ;", "request . setMethod (  \" POST \"  )  ;", "request . setContentType (  \" multipart / form - data \"  )  ;", "request . addPart ( expected )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Part . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   Part )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolvePart"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockPart   expected 1     =    new   MockPart (  \" pfilearray \"  ,     \" Hello   World    1  \"  . getBytes (  )  )  ;", "MockPart   expected 2     =    new   MockPart (  \" pfilearray \"  ,     \" Hello   World    2  \"  . getBytes (  )  )  ;", "request . setMethod (  \" POST \"  )  ;", "request . setContentType (  \" multipart / form - data \"  )  ;", "request . addPart ( expected 1  )  ;", "request . addPart ( expected 2  )  ;", "request . addPart ( new   MockPart (  \" other \"  ,     \" Hello   World    3  \"  . getBytes (  )  )  )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( Part [  ]  . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   Part [  ]  )  )  ;", "Part [  ]    parts    =     (  ( Part [  ]  )     ( result )  )  ;", "assertEquals (  2  ,    parts . length )  ;", "assertEquals ( parts [  0  ]  ,    expected 1  )  ;", "assertEquals ( parts [  1  ]  ,    expected 2  )  ;", "}", "METHOD_END"], "methodName": ["resolvePartArray"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setMethod (  \" POST \"  )  ;", "request . setContentType (  \" multipart / form - data \"  )  ;", "MockPart   expected 1     =    new   MockPart (  \" pfilelist \"  ,     \" Hello   World    1  \"  . getBytes (  )  )  ;", "MockPart   expected 2     =    new   MockPart (  \" pfilelist \"  ,     \" Hello   World    2  \"  . getBytes (  )  )  ;", "request . addPart ( expected 1  )  ;", "request . addPart ( expected 2  )  ;", "request . addPart ( new   MockPart (  \" other \"  ,     \" Hello   World    3  \"  . getBytes (  )  )  )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( List . class ,    Part . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   List )  )  ;", "assertEquals ( Arrays . asList ( expected 1  ,    expected 2  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolvePartList"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockPart   expected    =    new   MockPart (  \" part \"  ,     \" Hello   World \"  . getBytes (  )  )  ;", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setMethod (  \" POST \"  )  ;", "request . setContentType (  \" multipart / form - data \"  )  ;", "request . addPart ( expected )  ;", "webRequest    =    new   ServletWebRequest ( request )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent (  . class )  . arg ( Part . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   Part )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolvePartNotAnnot"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "request . setParameter (  \" stringNotAnnot \"  ,     \" plainValue \"  )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent (  . class )  . arg ( String . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" plainValue \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveSimpleTypeParam"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( String . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["resolveSimpleTypeParamToNull"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" foo \"  ;", "request . addParameter (  \" name \"  ,    expected )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  \" bar \"  )  )  . arg ( String . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveString"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    expected    =    new   String [  ]  {     \" foo \"  ,     \" bar \"     }  ;", "request . addParameter (  \" name \"  ,    expected )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( String [  ]  . class )  ;", "Object   result    =    resolver . resolveArgument ( param ,    null ,    webRequest ,    null )  ;", "assertTrue (  ( result   instanceof   String [  ]  )  )  ;", "assertArrayEquals (  \" Invalid   result \"  ,    expected ,     (  ( String [  ]  )     ( result )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveStringArray"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver    =    new   RequestParamMethodArgumentResolver ( null ,    true )  ;", "request    =    new   MockHttpServletRequest (  )  ;", "webRequest    =    new   ServletWebRequest ( request ,    new   MockHttpServletResponse (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver    =    new   RequestParamMethodArgumentResolver ( null ,    true )  ;", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  \" bar \"  )  )  . arg ( String . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( String [  ]  . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . name (  \" name \"  )  )  . arg ( Map . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( MultipartFile . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( List . class ,    MultipartFile . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( MultipartFile [  ]  . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( Part . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( List . class ,    Part . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( Part [  ]  . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . noName (  )  )  . arg ( Map . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( String . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent (  )  . arg ( MultipartFile . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( List . class ,    MultipartFile . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( Part . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestPart (  )  )  . arg ( MultipartFile . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  )  . arg ( String . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  )  )  . arg ( String . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( Optional . class ,    Integer . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( Optional . class ,    MultipartFile . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "resolver    =    new   RequestParamMethodArgumentResolver ( null ,    false )  ;", "param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( String . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestPart . class )  . arg ( MultipartFile . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "for    ( String   attributeName    :    this . knownAttributeNames )     {", "this . sStore . cleanupAttribute ( request ,    attributeName )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupAttributes"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( this . attributeNames . isEmpty (  )  )  )     |  |     (  !  ( this . attributeTypes . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasSessionAttributes"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeName ,     \" Attribute   name   must   not   be   null \"  )  ;", "if    (  ( this . attributeNames . contains ( attributeName )  )     |  |     ( this . attributeTypes . contains ( attributeType )  )  )     {", "this . knowNames . add ( attributeName )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isHandlerSessionAttribute"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionAttributeStore . retrieveAttribute ( request ,    attributeName )  ;", "}", "METHOD_END"], "methodName": ["retrieveAttribute"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "for    ( String   name    :    this . knownAttributeNames )     {", "Object   value    =    this . sStore . retrieveAttribute ( request ,    name )  ;", "if    ( value    !  =    null )     {", "attributes . put ( name ,    value )  ;", "}", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["retrieveAttributes"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "attributes . forEach (  (    name ,    value )     -  >     {", "if    (  ( value    !  =    null )     &  &     ( isHandler ( name ,    value . getClass (  )  )  )  )     {", "this . sessionAttributeStore . storeAttribute ( request ,    name ,    value )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["storeAttributes"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "sessionAttributeStore . storeAttribute ( request ,     \" attr 1  \"  ,     \" value 1  \"  )  ;", "sessionAttributeStore . storeAttribute ( request ,     \" attr 2  \"  ,     \" value 2  \"  )  ;", "sessionAttributeStore . storeAttribute ( request ,     \" attr 3  \"  ,    new   TestBean (  )  )  ;", "s . cleanupAttributes ( request )  ;", "assertNull ( sessionAttributeStore . retrieveAttribute ( request ,     \" attr 1  \"  )  )  ;", "assertNull ( sessionAttributeStore . retrieveAttribute ( request ,     \" attr 2  \"  )  )  ;", "assertNotNull ( sessionAttributeStore . retrieveAttribute ( request ,     \" attr 3  \"  )  )  ;", "s . isHandlerSessionAttribute (  \" attr 3  \"  ,    TestBean . class )  ;", "s . cleanupAttributes ( request )  ;", "assertNull ( sessionAttributeStore . retrieveAttribute ( request ,     \" attr 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cleanupAttributes"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( sessionAttributesHandler . isHandlerSessionAttribute (  \" attr 1  \"  ,    String . class )  )  ;", "assertTrue ( sessionAttributesHandler . isHandlerSessionAttribute (  \" attr 2  \"  ,    String . class )  )  ;", "assertTrue ( sessionAttributesHandler . isHandlerSessionAttribute (  \" simple \"  ,    TestBean . class )  )  ;", "assertFalse ( sessionAttributesHandler . isHandlerSessionAttribute (  \" simple \"  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["isSessionAttribute"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandlerTests"}, {"methodBody": ["METHOD_START", "{", "sessionAttributeStore . storeAttribute ( request ,     \" attr 1  \"  ,     \" value 1  \"  )  ;", "sessionAttributeStore . storeAttribute ( request ,     \" attr 2  \"  ,     \" value 2  \"  )  ;", "sessionAttributeStore . storeAttribute ( request ,     \" attr 3  \"  ,    new   TestBean (  )  )  ;", "sessionAttributeStore . storeAttribute ( request ,     \" attr 4  \"  ,    new   TestBean (  )  )  ;", "assertEquals (  \" Named   attributes    ( attr 1  ,    attr 2  )    should   be    ' known '    right   away \"  ,    new   HashSet ( Arrays . asList (  \" attr 1  \"  ,     \" attr 2  \"  )  )  ,    s . retrieveAttributes ( request )  . keySet (  )  )  ;", "s . isHandlerSessionAttribute (  \" attr 3  \"  ,    TestBean . class )  ;", "assertEquals (  \" Named   attributes    ( attr 1  ,    attr 2  )    and   resolved   attribute    ( att 3  )    should   be    ' known '  \"  ,    new   HashSet ( Arrays . asList (  \" attr 1  \"  ,     \" attr 2  \"  ,     \" attr 3  \"  )  )  ,    s . retrieveAttributes ( request )  . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["retrieveAttributes"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  )  ;", "model . put (  \" attr 1  \"  ,     \" value 1  \"  )  ;", "model . put (  \" attr 2  \"  ,     \" value 2  \"  )  ;", "model . put (  \" attr 3  \"  ,    new   TestBean (  )  )  ;", "s . storeAttributes ( request ,    model )  ;", "assertEquals (  \" value 1  \"  ,    sessionAttributeStore . retrieveAttribute ( request ,     \" attr 1  \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    sessionAttributeStore . retrieveAttribute ( request ,     \" attr 2  \"  )  )  ;", "assertTrue (  (  ( sessionAttributeStore . retrieveAttribute ( request ,     \" attr 3  \"  )  )    instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["storeAttributes"], "fileName": "org.springframework.web.method.annotation.SessionAttributesHandlerTests"}, {"methodBody": ["METHOD_START", "{", "RequestContextHolder . resetRequestAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["resetRequestContextHolder"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =     4  2  ;", "given ( adaptee . resolve ( parameter ,    webRequest )  )  . willReturn ( expected )  ;", "Object   result    =    adapter . resolve ( parameter ,    null ,    webRequest ,    null )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . resolveArgument ( parameter ,    webRequest )  )  . willThrow ( new   Exception (  )  )  ;", "adapter . resolveArgument ( parameter ,    null ,    webRequest ,    null )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentThrowsException"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . resolveArgument ( parameter ,    webRequest )  )  . willReturn ( WebArgumentResolver . UNRESOLVED )  ;", "adapter . resolveArgument ( parameter ,    null ,    webRequest ,    null )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentUnresolved"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . resolveArgument ( parameter ,    webRequest )  )  . willReturn (  \" Foo \"  )  ;", "adapter . resolveArgument ( parameter ,    null ,    webRequest ,    null )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentWrongType"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "adaptee    =    mock ( WebArgumentResolver . class )  ;", "adapter    =    new    . TestWebArgumentResolverAdapter ( adaptee )  ;", "parameter    =    new   MethodParameter ( getClass (  )  . getMethod (  \" handle \"  ,    Integer . TYPE )  ,     0  )  ;", "webRequest    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  )  ;", "RequestContextHolder . setRequestAttributes ( webRequest )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . resolveArgument ( parameter ,    webRequest )  )  . willReturn (  4  2  )  ;", "assertTrue (  \" Parameter   not   supported \"  ,    adapter . supportsParameter ( parameter )  )  ;", "verify ( adaptee )  . resolveArgument ( parameter ,    webRequest )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . resolveArgument ( parameter ,    webRequest )  )  . willThrow ( new   Exception (  )  )  ;", "assertFalse (  \" Parameter   supported \"  ,    adapter . supportsParameter ( parameter )  )  ;", "verify ( adaptee )  . resolveArgument ( parameter ,    webRequest )  ;", "}", "METHOD_END"], "methodName": ["supportsParameterThrowsException"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . resolveArgument ( parameter ,    webRequest )  )  . willReturn ( WebArgumentResolver . UNRESOLVED )  ;", "assertFalse (  \" Parameter   supported \"  ,    adapter . supportsParameter ( parameter )  )  ;", "verify ( adaptee )  . resolveArgument ( parameter ,    webRequest )  ;", "}", "METHOD_END"], "methodName": ["supportsParameterUnresolved"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . resolveArgument ( parameter ,    webRequest )  )  . willReturn (  \" Foo \"  )  ;", "assertFalse (  \" Parameter   supported \"  ,    adapter . supportsParameter ( parameter )  )  ;", "verify ( adaptee )  . resolveArgument ( parameter ,    webRequest )  ;", "}", "METHOD_END"], "methodName": ["supportsParameterWrongType"], "fileName": "org.springframework.web.method.annotation.WebArgumentResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "this . contributeMethodArgument ( parameter ,    value ,    builder ,    uriVariables ,    this . conversionService )  ;", "}", "METHOD_END"], "methodName": ["contributeMethodArgument"], "fileName": "org.springframework.web.method.support.CompositeUriComponentsContributor"}, {"methodBody": ["METHOD_START", "{", "return   this . contributors . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["hasContributors"], "fileName": "org.springframework.web.method.support.CompositeUriComponentsContributor"}, {"methodBody": ["METHOD_START", "{", "List < HandlerMethodArgumentResolver >    resolvers    =    new   ArrayList <  >  (  )  ;", "resolvers . add ( new   RequestParamMethodArgumentResolver ( false )  )  ;", "resolvers . add ( new   RequestHeaderMethodArgumentResolver ( null )  )  ;", "resolvers . add ( new   RequestParamMethodArgumentResolver ( true )  )  ;", "Method   method    =    ClassUtils . getMethod ( this . getClass (  )  ,     \" handleRequest \"  ,    String . class ,    String . class ,    String . class )  ;", "contributor    =    new    ( resolvers )  ;", "assertTrue ( contributor . supportsParameter ( new   MethodParameter ( method ,     0  )  )  )  ;", "assertTrue ( contributor . supportsParameter ( new   MethodParameter ( method ,     1  )  )  )  ;", "assertFalse ( contributor . supportsParameter ( new   MethodParameter ( method ,     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.support.CompositeUriComponentsContributorTests"}, {"methodBody": ["METHOD_START", "{", "this . argumentResolvers . add ( resolver )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addResolver"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "if    ( resolvers    !  =    null )     {", "for    (    resolver    :    resolvers )     {", "this . argumentResolvers . add ( resolver )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addResolvers"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "if    ( resolvers    !  =    null )     {", "for    (    resolver    :    resolvers )     {", "this . argumentResolvers . add ( resolver )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addResolvers"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "this . argumentResolvers . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodArgumentResolver   result    =    this . argumentResolverCache . get ( parameter )  ;", "if    ( result    =  =    null )     {", "for    ( HandlerMethodArgumentResolver   methodArgumentResolver    :    this . argumentResolvers )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  \" Testing   if   argument   resolver    [  \"     +    methodArgumentResolver )     +     \"  ]    supports    [  \"  )     +     ( parameter . getGenericParameterType (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "if    ( methodArgumentResolver . supportsParameter ( parameter )  )     {", "result    =    methodArgumentResolver ;", "this . argumentResolverCache . put ( parameter ,    result )  ;", "break ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getArgumentResolver"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . argumentResolvers )  ;", "}", "METHOD_END"], "methodName": ["getResolvers"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "registerResolver ( Integer . class ,    Integer . valueOf (  1  )  )  ;", "registerResolver ( Integer . class ,    Integer . valueOf (  2  )  )  ;", "Object   resolvedValue    =    this . resolvers . resolveArgument ( paramInt ,    null ,    null ,    null )  ;", "assertEquals (  \" Didn ' t   use   the   first   registered   resolver \"  ,    Integer . valueOf (  1  )  ,    resolvedValue )  ;", "}", "METHOD_END"], "methodName": ["checkArgumentResolverOrder"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverCompositeTests"}, {"methodBody": ["METHOD_START", "{", "this . resolvers . resolveArgument ( paramStr ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["noSuitableArgumentResolver"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverCompositeTests"}, {"methodBody": ["METHOD_START", "{", "StubArgumentResolver   resolver    =    new   StubArgumentResolver ( supportedType ,    stubValue )  ;", "this . resolvers . addResolver ( resolver )  ;", "return   resolver ;", "}", "METHOD_END"], "methodName": ["registerResolver"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverCompositeTests"}, {"methodBody": ["METHOD_START", "{", "registerResolver ( Integer . class ,    Integer . valueOf (  5  5  )  )  ;", "Object   resolvedValue    =    this . resolvers . resolveArgument ( paramInt ,    null ,    null ,    null )  ;", "assertEquals ( Integer . valueOf (  5  5  )  ,    resolvedValue )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverCompositeTests"}, {"methodBody": ["METHOD_START", "{", "resolvers    =    new   HandlerMethodArgumentResolverComposite (  )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" handle \"  ,    Integer . class ,    String . class )  ;", "paramInt    =    new   MethodParameter ( method ,     0  )  ;", "paramStr    =    new   MethodParameter ( method ,     1  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverCompositeTests"}, {"methodBody": ["METHOD_START", "{", "registerResolver ( Integer . class ,    null )  ;", "assertTrue ( this . resolvers . supportsParameter ( paramInt )  )  ;", "assertFalse ( this . resolvers . supportsParameter ( paramStr )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.method.support.HandlerMethodArgumentResolverCompositeTests"}, {"methodBody": ["METHOD_START", "{", "this . returnValueHandlers . add ( handler )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addHandler"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "if    ( handlers    !  =    null )     {", "this . rs . addAll ( handlers )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addHandlers"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . returnValueHandlers )  ;", "}", "METHOD_END"], "methodName": ["getHandlers"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "for    ( HandlerMethodReturnValueHandler   handler    :    this . returnValueHandlers )     {", "if    ( handler . supportsReturnType ( returnType )  )     {", "return   handler ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getReturnValueHandler"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "for    ( HandlerMethodReturnValueHandler   handler    :    this . returnValueHandlers )     {", "if    (  ( handler   instanceof   AsyncHandlerMethodReturnValueHandler )     &  &     (  (  ( AsyncHandlerMethodReturnValueHandler )     ( handler )  )  . isAsyncReturnValue ( value ,    returnType )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAsyncReturnValue"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "boolean   isAsyncValue    =    isAsyncReturnValue ( value ,    returnType )  ;", "for    (    handler    :    this . returnValueHandlers )     {", "if    ( isAsyncValue    &  &     (  !  ( handler   instanceof   Async )  )  )     {", "continue ;", "}", "if    ( handler . supportsReturnType ( returnType )  )     {", "return   handler ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["selectHandler"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["handleInteger"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["handlePromise"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "this . handlers . handleReturnValue (  5  5  ,    this . integerType ,    this . mavContainer ,    null )  ;", "verify ( this . integerHandler )  . handleReturnValue (  5  5  ,    this . integerType ,    this . mavContainer ,    null )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValue"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodReturnValueHandlerCompositeTests . Promise < Integer >    promise    =    new   HandlerMethodReturnValueHandlerCompositeTests . Promise <  >  (  )  ;", "MethodParameter   promiseType    =    new   MethodParameter ( getClass (  )  . getDeclaredMethod (  \" handlePromise \"  )  ,     (  -  1  )  )  ;", "HandlerMethodReturnValueHandler   responseBodyHandler    =    mock ( HandlerMethodReturnValueHandler . class )  ;", "when ( responseBodyHandler . supportsReturnType ( promiseType )  )  . thenReturn ( true )  ;", "this . handlers . addHandler ( responseBodyHandler )  ;", "AsyncHandlerMethodReturnValueHandler   promiseHandler    =    mock ( AsyncHandlerMethodReturnValueHandler . class )  ;", "when ( promiseHandler . supportsReturnType ( promiseType )  )  . thenReturn ( true )  ;", "when ( promiseHandler . isAsyncReturnValue ( promise ,    promiseType )  )  . thenReturn ( true )  ;", "this . handlers . addHandler ( promiseHandler )  ;", "this . handlers . handleReturnValue ( promise ,    promiseType ,    this . mavContainer ,    null )  ;", "verify ( promiseHandler )  . isAsyncReturnValue ( promise ,    promiseType )  ;", "verify ( promiseHandler )  . supportsReturnType ( promiseType )  ;", "verify ( promiseHandler )  . handleReturnValue ( promise ,    promiseType ,    this . mavContainer ,    null )  ;", "verifyNoMoreInteractions ( promiseHandler )  ;", "verifyNoMoreInteractions ( responseBodyHandler )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValueWithAsyncHandler"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodReturnValueHandler   anotherIntegerHandler    =    mock ( HandlerMethodReturnValueHandler . class )  ;", "when ( anotherIntegerHandler . supportsReturnType ( this . integerType )  )  . thenReturn ( true )  ;", "this . handlers . handleReturnValue (  5  5  ,    this . integerType ,    this . mavContainer ,    null )  ;", "verify ( this . integerHandler )  . handleReturnValue (  5  5  ,    this . integerType ,    this . mavContainer ,    null )  ;", "verifyNoMoreInteractions ( anotherIntegerHandler )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValueWithMultipleHandlers"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["handleString"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "this . handlers . handleReturnValue (  \" value \"  ,    this . stringType ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["noSuitableReturnValueHandler"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "this . integerType    =    new   MethodParameter ( getClass (  )  . getDeclaredMethod (  \" handleInteger \"  )  ,     (  -  1  )  )  ;", "this . stringType    =    new   MethodParameter ( getClass (  )  . getDeclaredMethod (  \" handleString \"  )  ,     (  -  1  )  )  ;", "this . integerHandler    =    mock ( HandlerMethodReturnValueHandler . class )  ;", "when ( this . integerHandler . supportsReturnType ( this . integerType )  )  . thenReturn ( true )  ;", "this . handlers    =    new    (  )  ;", "this . handlers . addHandler ( this . integerHandler )  ;", "mavContainer    =    new   ModelAndViewContainer (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . handlers . supportsReturnType ( this . integerType )  )  ;", "assertFalse ( this . handlers . supportsReturnType ( this . stringType )  )  ;", "}", "METHOD_END"], "methodName": ["supportsReturnType"], "fileName": "org.springframework.web.method.support.HandlerMethodReturnValueHandlerCompositeTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    methodDeclaringClass    =    method . getDeclaringClass (  )  ;", "Class <  ?  >    targetBeanClass    =    targetBean . getClass (  )  ;", "if    (  !  ( methodDeclaringClass . isAssignableFrom ( targetBeanClass )  )  )     {", "String   text    =     (  (  (  (  \" The   mapped   handler   method   class    '  \"     +     ( methodDeclaringClass . getName (  )  )  )     +     \"  '    is   not   an   instance   of   the   actual   controller   bean   class    '  \"  )     +     ( targetBeanClass . getName (  )  )  )     +     \"  '  .    If   the   controller   requires   proxying    \"  )     +     \"  ( e . g .    due   to    @ Transactional )  ,    please   use   class - based   proxying .  \"  ;", "throw   new   IllegalStateException ( getInvocationErrorMessage ( text ,    args )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertTargetBean"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtils . makeAccessible ( getBridgedMethod (  )  )  ;", "try    {", "return   getBridgedMethod (  )  . invoke ( getBean (  )  ,    args )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTargetBean ( getBridgedMethod (  )  ,    getBean (  )  ,    args )  ;", "String   text    =     (  ( ex . getMessage (  )  )     !  =    null )     ?    ex . getMessage (  )     :     \" Illegal   argument \"  ;", "throw   new   IllegalStateException ( getInvocationErrorMessage ( text ,    args )  ,    ex )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   targetException    =    ex . getTargetException (  )  ;", "if    ( targetException   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( targetException )  )  ;", "} else", "if    ( targetException   instanceof   Error )     {", "throw    (  ( Error )     ( targetException )  )  ;", "} else", "if    ( targetException   instanceof   Exception )     {", "throw    (  ( Exception )     ( targetException )  )  ;", "} else    {", "String   text    =    getInvocationErrorMessage (  \" Failed   to   invoke   handler   method \"  ,    args )  ;", "throw   new   IllegalStateException ( text ,    targetException )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    paramType    =    getMethodParameters (  )  [ index ]  . getParameterType (  )  ;", "return    (  (  (  ( text    +     \"    argument    \"  )     +    index )     +     \"    of   type    '  \"  )     +     ( paramType . getName (  )  )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getArgumentResolutionErrorMessage"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( text )  . append (  \"  \\ n \"  )  ;", "sb . append (  \"    details :     \\ n \"  )  ;", "sb . append (  \" Controller    [  \"  )  . append ( getBeanType (  )  . getName (  )  )  . append (  \"  ]  \\ n \"  )  ;", "sb . append (  \" Method    [  \"  )  . append ( getBridgedMethod (  )  . toGenericString (  )  )  . append (  \"  ]  \\ n \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDetailedErrorMessage"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( getDetailedErrorMessage ( text )  )  ;", "sb . append (  \" Resolved   arguments :     \\ n \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( resolvedArgs . length )  ;    i +  +  )     {", "sb . append (  \"  [  \"  )  . append ( i )  . append (  \"  ]     \"  )  ;", "if    (  ( resolvedArgs [ i ]  )     =  =    null )     {", "sb . append (  \"  [ null ]     \\ n \"  )  ;", "} else    {", "sb . append (  \"  [ type =  \"  )  . append ( resolvedArgs [ i ]  . getClass (  )  . getName (  )  )  . append (  \"  ]     \"  )  ;", "sb . append (  \"  [ value =  \"  )  . append ( resolvedArgs [ i ]  )  . append (  \"  ]  \\ n \"  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getInvocationErrorMessage"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "MethodParameter [  ]    parameters    =    getMethodParameters (  )  ;", "Object [  ]    args    =    new   Object [ parameters . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( parameters . length )  ;    i +  +  )     {", "MethodParameter   parameter    =    parameters [ i ]  ;", "parameter . initParameterNameDiscovery ( this . parameterNameDiscoverer )  ;", "args [ i ]     =    resolveProvidedArgument ( parameter ,    providedArgs )  ;", "if    (  ( args [ i ]  )     !  =    null )     {", "continue ;", "}", "if    ( this . argumentResolverssParameter ( parameter )  )     {", "try    {", "args [ i ]     =    this . argumentResolvers . resolveArgument ( parameter ,    mavContainer ,    request ,    this . dataBinderFactory )  ;", "continue ;", "}    catch    ( Exception   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug ( getArgumentResolutionErrorMessage (  \" Failed   to   resolve \"  ,    i )  ,    ex )  ;", "}", "throw   ex ;", "}", "}", "if    (  ( args [ i ]  )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" Could   not   resolve   method   parameter   at   index    \"     +     ( parameter . getParameterIndex (  )  )  )     +     \"    in    \"  )     +     ( parameter . getExecutable (  )  . toGenericString (  )  )  )     +     \"  :     \"  )     +     ( getArgumentResolutionErrorMessage (  \" No   suitable   resolver   for \"  ,    i )  )  )  )  ;", "}", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["getMethodArgumentValues"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    args    =    getMethodArgumentValues ( request ,    mavContainer ,    providedArgs )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Invoking    '  \"     +     ( ClassUtils . getQualifiedMethodName ( getMethod (  )  ,    getBeanType (  )  )  )  )     +     \"  '    with   arguments    \"  )     +     ( Arrays . toString ( args )  )  )  )  ;", "}", "Object   returnValue    =    doInvoke ( args )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  \" Method    [  \"     +     ( ClassUtils . getQualifiedMethodName ( getMethod (  )  ,    getBeanType (  )  )  )  )     +     \"  ]    returned    [  \"  )     +    returnValue )     +     \"  ]  \"  )  )  ;", "}", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["invokeForRequest"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "if    ( providedArgs    =  =    null )     {", "return   null ;", "}", "for    ( Object   providedArg    :    providedArgs )     {", "if    ( pater . getPaterType (  )  . isInstance ( providedArg )  )     {", "return   providedArg ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveProvidedArgument"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . dataBinderFactory    =    dataBinderFactory ;", "}", "METHOD_END"], "methodName": ["setDataBinderFactory"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . argumentResolvers    =    argumentResolvers ;", "}", "METHOD_END"], "methodName": ["setHandlerMethodArgumentResolvers"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameDiscoverer    =    parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["setParameterNameDiscoverer"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "try    {", "h . invokeForRequest ( webRequest ,    null )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" No   suitable   resolver   for   argument    0    of   type    ' Integer '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cannotResolveArg"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodArgumentResolverComposite   composite    =    new   HandlerMethodArgumentResolverComposite (  )  ;", "composite . addResolver ( new    . ExceptionRaisingArgumentResolver (  )  )  ;", "handlerMethod . setHandlerMethodArgumentResolvers ( composite )  ;", "try    {", "handlerMethod . invokeForRequest ( webRequest ,    null )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( HttpMessageNotReadableException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["exceptionInResolvingArg"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "StubArgumentResolver   intResolver    =    new   StubArgumentResolver ( Integer . class ,     \"  _  _ invalid _  _  \"  )  ;", "StubArgumentResolver   stringResolver    =    new   StubArgumentResolver ( String . class ,     \" value \"  )  ;", "ArgumentResolverComposite   composite    =    new   ArgumentResolverComposite (  )  ;", "composite . addResolver ( intResolver )  ;", "composite . addResolver ( stringResolver )  ;", "handlerMethod . setArgumentResolvers ( composite )  ;", "try    {", "handlerMethod . invokeForRequest ( webRequest ,    null )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertNotNull (  \" Exception   not   wrapped \"  ,    ex . getCause (  )  )  ;", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" Controller    [  \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" Method    [  \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" Resolved   arguments :     \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \"  [  0  ]     [ type = String ]     [ value =  _  _ invalid _  _  ]  \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \"  [  1  ]     [ type = String ]     [ value = value \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["illegalArgumentException"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodArgumentResolverComposite   composite    =    new   HandlerMethodArgumentResolverComposite (  )  ;", "composite . addResolver ( new   StubArgumentResolver ( double . class ,    null )  )  ;", "Method   method    =     . Handler . class . getDeclaredMethod (  \" handle \"  ,    double . class )  ;", "Object   handler    =    new    . Handler (  )  ;", "InvocableHandlerMethod   hm    =    new   InvocableHandlerMethod ( handler ,    method )  ;", "hm . setHandlerMethodArgumentResolvers ( composite )  ;", "try    {", "hm . invokeForRequest ( this . webRequest ,    new   ModelAndViewContainer (  )  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertThat ( ex . getMessage (  )  ,    containsString (  \" Illegal   argument \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invocationErrorMessage"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   expected    =    new   RuntimeException (  \" error \"  )  ;", "try    {", "invokeExceptionRaising ( expected )  ;", "}    catch    ( RuntimeException   actual )     {", "assertSame ( expected ,    actual )  ;", "}", "expected    =    new   Error (  \" error \"  )  ;", "try    {", "invokeExceptionRaising ( expected )  ;", "}    catch    ( Error   actual )     {", "assertSame ( expected ,    actual )  ;", "}", "expected    =    new   Exception (  \" error \"  )  ;", "try    {", "invokeExceptionRaising ( expected )  ;", "}    catch    ( Exception   actual )     {", "assertSame ( expected ,    actual )  ;", "}", "expected    =    new   Throwable (  \" error \"  )  ;", "try    {", "invokeExceptionRaising ( expected )  ;", "}    catch    ( IllegalStateException   actual )     {", "assertNotNull ( actual . getCause (  )  )  ;", "assertSame ( expected ,    actual . getCause (  )  )  ;", "assertTrue ( actual . getMessage (  )  . contains (  \" Failed   to   invoke   handler   method \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invocationTargetException"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    InvocableHandlerMethodTests . ExceptionRaisingHandler . class . getDeclaredMethod (  \" raiseException \"  )  ;", "Object   handler    =    new   InvocableHandlerMethodTests . ExceptionRaisingHandler ( expected )  ;", "new   InvocableHandlerMethod ( handler ,    method )  . invokeForRequest ( webRequest ,    null )  ;", "fail (  \" Expected   exception \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeExceptionRaisingHandler"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "StubArgumentResolver   intResolver    =    new   StubArgumentResolver ( Integer . class ,     9  9  )  ;", "StubArgumentResolver   stringResolver    =    new   StubArgumentResolver ( String . class ,     \" value \"  )  ;", "ArgumentResolverComposite   composite    =    new   ArgumentResolverComposite (  )  ;", "composite . addResolver ( intResolver )  ;", "composite . addResolver ( stringResolver )  ;", "handlerMethod . setArgumentResolvers ( composite )  ;", "Object   returnValue    =    handlerMethod . invokeForRequest ( webRequest ,    null )  ;", "assertEquals (  1  ,    intResolver . getResolvedParameters (  )  . size (  )  )  ;", "assertEquals (  1  ,    stringResolver . getResolvedParameters (  )  . size (  )  )  ;", "assertEquals (  \"  9  9  - value \"  ,    returnValue )  ;", "assertEquals (  \" intArg \"  ,    intResolver . getResolvedParameters (  )  . get (  0  )  . getParameterName (  )  )  ;", "assertEquals (  \" stringArg \"  ,    stringResolver . getResolvedParameters (  )  . get (  0  )  . getParameterName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArg"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "StubArgumentResolver   intResolver    =    new   StubArgumentResolver ( Integer . class ,    null )  ;", "StubArgumentResolver   stringResolver    =    new   StubArgumentResolver ( String . class ,    null )  ;", "ArgumentResolverComposite   composite    =    new   ArgumentResolverComposite (  )  ;", "composite . addResolver ( intResolver )  ;", "composite . addResolver ( stringResolver )  ;", "handlerMethod . setArgumentResolvers ( composite )  ;", "Object   returnValue    =    handlerMethod . invokeForRequest ( webRequest ,    null )  ;", "assertEquals (  1  ,    intResolver . getResolvedParameters (  )  . size (  )  )  ;", "assertEquals (  1  ,    stringResolver . getResolvedParameters (  )  . size (  )  )  ;", "assertEquals (  \" null - null \"  ,    returnValue )  ;", "}", "METHOD_END"], "methodName": ["resolveNullArg"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Object   returnValue    =    handlerMethod . invokeForRequest ( webRequest ,    null ,     9  9  ,     \" value \"  )  ;", "assertEquals ( String . class ,    returnValue . getClass (  )  )  ;", "assertEquals (  \"  9  9  - value \"  ,    returnValue )  ;", "}", "METHOD_END"], "methodName": ["resolveProvidedArg"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "StubArgumentResolver   intResolver    =    new   StubArgumentResolver ( Integer . class ,     1  )  ;", "StubArgumentResolver   stringResolver    =    new   StubArgumentResolver ( String . class ,     \" value 1  \"  )  ;", "ArgumentResolverComposite   composite    =    new   ArgumentResolverComposite (  )  ;", "composite . addResolver ( intResolver )  ;", "composite . addResolver ( stringResolver )  ;", "handlerMethod . setArgumentResolvers ( composite )  ;", "Object   returnValue    =    handlerMethod . invokeForRequest ( webRequest ,    null ,     2  ,     \" value 2  \"  )  ;", "assertEquals (  \"  2  - value 2  \"  ,    returnValue )  ;", "}", "METHOD_END"], "methodName": ["resolveProvidedArgFirst"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    InvocableHandlerMethodTests . Handler . class . getDeclaredMethod (  \" handle \"  ,    Integer . class ,    String . class )  ;", "this . handlerMethod    =    new   InvocableHandlerMethod ( new   InvocableHandlerMethodTests . Handler (  )  ,    method )  ;", "this . webRequest    =    new   ServletWebRequest ( new   MockHttpServletRequest (  )  ,    new   MockHttpServletResponse (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.method.support.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "getModel (  )  . addAllAttributes ( attributes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAllAttributes"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "getModel (  )  . addAttribute ( value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAttribute"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "getModel (  )  . addAttribute ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAttribute"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return   getModel (  )  . containsAttribute ( name )  ;", "}", "METHOD_END"], "methodName": ["containsAttribute"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultModel ;", "}", "METHOD_END"], "methodName": ["getDefaultModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( useDefaultModel (  )  )     {", "return   this . defaultModel ;", "} else    {", "if    (  ( this . redirectModel )     =  =    null )     {", "this . redirectModel    =    new   ModelMap (  )  ;", "}", "return   this . redirectModel ;", "}", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionStatus ;", "}", "METHOD_END"], "methodName": ["getSessionStatus"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . status ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . view ;", "}", "METHOD_END"], "methodName": ["getView"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . view )    instanceof   String    ?     (  ( String )     ( this . view )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getViewName"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . bindingDisabled . contains ( name )  )     |  |     ( this . noBinding . contains ( name )  )  ;", "}", "METHOD_END"], "methodName": ["isBindingDisabled"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . requestHandled ;", "}", "METHOD_END"], "methodName": ["isRequestHandled"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . view )    instanceof   String ;", "}", "METHOD_END"], "methodName": ["isViewReference"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "getModel (  )  . mergeAttributes ( attributes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mergeAttributes"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    !  =    null )     {", "for    ( String   key    :    attributes . keySet (  )  )     {", "get (  )  . remove ( key )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["removeAttributes"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ! enabled )     {", "this . noBind . add ( attributeName )  ;", "} else    {", "this . noBind . remove ( attributeName )  ;", "}", "}", "METHOD_END"], "methodName": ["setBinding"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . bindingDisabled . add ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["setBindingDisabled"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . ignoreDefaultModelOnRedirect    =    ignoreDefaultModelOnRedirect ;", "}", "METHOD_END"], "methodName": ["setIgnoreDefaultModelOnRedirect"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . redirectModel    =    redirectModel ;", "}", "METHOD_END"], "methodName": ["setRedirectModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . redirectModelScenario    =    redirectModelScenario ;", "}", "METHOD_END"], "methodName": ["setRedirectModelScenario"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . requestHandled    =    requestHandled ;", "}", "METHOD_END"], "methodName": ["setRequestHandled"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . status    =    status ;", "}", "METHOD_END"], "methodName": ["setStatus"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . view    =    view ;", "}", "METHOD_END"], "methodName": ["setView"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . view    =    viewName ;", "}", "METHOD_END"], "methodName": ["setViewName"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( this . redirectModelScenario )  )     |  |     (  (  ( this . redirectModel )     =  =    null )     &  &     (  !  ( this . ignoreDefaultModelOnRedirect )  )  )  ;", "}", "METHOD_END"], "methodName": ["useDefaultModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainer"}, {"methodBody": ["METHOD_START", "{", "this . mavContainer . addAttribute (  \" name \"  ,     \" value \"  )  ;", "assertEquals (  1  ,    this . mavContainer . getModel (  )  . size (  )  )  ;", "assertEquals (  \" value \"  ,    this . mavContainer . getModel (  )  . get (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . mavContainer . setIgnoreDefaultModelOnRedirect ( true )  ;", "this . mavContainer . addAttribute (  \" name \"  ,     \" value \"  )  ;", "this . mavContainer . setRedirectModelScenario ( true )  ;", "assertTrue ( this . mavContainer . getModel (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["ignoreDefaultModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . mavContainer . setIgnoreDefaultModelOnRedirect ( true )  ;", "this . mavContainer . setRedirectModelScenario ( true )  ;", "this . mavContainer . addAttribute (  \" name \"  ,     \" value \"  )  ;", "assertEquals (  1  ,    this . mavContainer . getModel (  )  . size (  )  )  ;", "assertEquals (  \" value \"  ,    this . mavContainer . getModel (  )  . get (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ignoreDefaultModelAndWithoutRedirectModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . mavContainer . addAttribute (  \" name 1  \"  ,     \" value 1  \"  )  ;", "this . mavContainer . setRedirectModel ( new   ModelMap (  \" name 2  \"  ,     \" value 2  \"  )  )  ;", "this . mavContainer . setRedirectModelScenario ( true )  ;", "assertEquals (  1  ,    this . mavContainer . getModel (  )  . size (  )  )  ;", "assertEquals (  \" value 2  \"  ,    this . mavContainer . getModel (  )  . get (  \" name 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectScenarioWithRedirectModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . mavContainer . addAttribute (  \" name \"  ,     \" value \"  )  ;", "this . mavContainer . setRedirectModelScenario ( true )  ;", "assertEquals (  1  ,    this . mavContainer . getModel (  )  . size (  )  )  ;", "assertEquals (  \" value \"  ,    this . mavContainer . getModel (  )  . get (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectScenarioWithoutRedirectModel"], "fileName": "org.springframework.web.method.support.ModelAndViewContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . mavContainer    =    new   ModelAndViewContainer (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.method.support.ModelAndViewContainerTests"}, {"methodBody": ["METHOD_START", "{", "return   resolvedParameters ;", "}", "METHOD_END"], "methodName": ["getResolvedParameters"], "fileName": "org.springframework.web.method.support.StubArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . maxUploadSize ;", "}", "METHOD_END"], "methodName": ["getMaxUploadSize"], "fileName": "org.springframework.web.multipart.MaxUploadSizeExceededException"}, {"methodBody": ["METHOD_START", "{", "for    ( List < MultipartFile >    files    :    multipartFiles . values (  )  )     {", "for    ( MultipartFile   file    :    files )     {", "if    ( file   instanceof   CommonsMultipartFile )     {", "CommonsMultipartFile   cmf    =     (  ( CommonsMultipartFile )     ( file )  )  ;", "cmf . getFileItem (  )  . delete (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  \" Cleaning   up   multipart   file    [  \"     +     ( cmf . getName (  )  )  )     +     \"  ]    with   original   filename    [  \"  )     +     ( cmf . getOriginalFilename (  )  )  )     +     \"  ]  ,    stored    \"  )     +     ( cmf . getStorageDescription (  )  )  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["cleanupFileItems"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "CommonsMultipartFile   multipartFile    =    new   CommonsMultipartFile ( fileItem )  ;", "multipartFile . setPreserveFilename ( this . preserveFilename )  ;", "return   multipartFile ;", "}", "METHOD_END"], "methodName": ["createMultipartFile"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasText ( contentTypeHeader )  )  )     {", "return   defaultEncoding ;", "}", "MediaType   contentType    =    MediaType . parseMediaType ( contentTypeHeader )  ;", "Charset   charset    =    contentType . getCharset (  )  ;", "return   charset    !  =    null    ?    charset . name (  )     :    defaultEncoding ;", "}", "METHOD_END"], "methodName": ["determineEncoding"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "String   encoding    =    getFileUpload (  )  . getHeaderEncoding (  )  ;", "if    ( encoding    =  =    null )     {", "encoding    =    WebUtils . DEFAULT _ CHARACTER _ ENCODING ;", "}", "return   encoding ;", "}", "METHOD_END"], "methodName": ["getDefaultEncoding"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . fileItemFactory ;", "}", "METHOD_END"], "methodName": ["getFileItemFactory"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . fileUpload ;", "}", "METHOD_END"], "methodName": ["getFileUpload"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . uploadTempDirSpecified ;", "}", "METHOD_END"], "methodName": ["isUploadTempDirSpecified"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   DiskFileItemFactory (  )  ;", "}", "METHOD_END"], "methodName": ["newFileItemFactory"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    MultipartFile >    multipartFiles    =    new   LinkedMultiValueMap (  )  ;", "Map < String ,    String [  ]  >    multipartParameters    =    new   HashMap <  >  (  )  ;", "Map < String ,    String >    multipartParameterContentTypes    =    new   HashMap <  >  (  )  ;", "for    ( FileItem   fileItem    :    fileItems )     {", "if    ( fileItem . isFormField (  )  )     {", "String   value ;", "String   partEncoding    =    determineEncoding ( fileItem . getContentType (  )  ,    encoding )  ;", "try    {", "value    =    fileItem . getString ( partEncoding )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  (  (  \" Could   not   decode   multipart   item    '  \"     +     ( fileItem . getFieldName (  )  )  )     +     \"  '    with   encoding    '  \"  )     +    partEncoding )     +     \"  '  :    using   platform   default \"  )  )  ;", "}", "value    =    fileItem . getString (  )  ;", "}", "String [  ]    curParam    =    multipartParameters . get ( fileItem . getFieldName (  )  )  ;", "if    ( curParam    =  =    null )     {", "multipartParameters . put ( fileItem . getFieldName (  )  ,    new   String [  ]  {    value    }  )  ;", "} else    {", "String [  ]    newParam    =    StringUtils . addStringToArray ( curParam ,    value )  ;", "multipartParameters . put ( fileItem . getFieldName (  )  ,    newParam )  ;", "}", "multipartParameterContentTypes . put ( fileItem . getFieldName (  )  ,    fileItem . getContentType (  )  )  ;", "} else    {", "CommonsMultipartFile   file    =    createMultipartFile ( fileItem )  ;", "multipartFiles . add ( file . getName (  )  ,    file )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  (  (  \" Found   multipart   file    [  \"     +     ( file . getName (  )  )  )     +     \"  ]    of   size    \"  )     +     ( file . getSize (  )  )  )     +     \"    bytes   with   original   filename    [  \"  )     +     ( file . getOriginalFilename (  )  )  )     +     \"  ]  ,    stored    \"  )     +     ( file . getStorageDescription (  )  )  )  )  ;", "}", "}", "}", "return   new    . MultipartParsingResult ( multipartFiles ,    multipartParameters ,    multipartParameterContentTypes )  ;", "}", "METHOD_END"], "methodName": ["parseFileItems"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "FileUpload   fileUpload    =    getFileUpload (  )  ;", "FileUpload   actualFileUpload    =    fileUpload ;", "if    (  ( encoding    !  =    null )     &  &     (  !  ( encoding . equals ( fileUpload . getHeaderEncoding (  )  )  )  )  )     {", "actualFileUpload    =    newFileUpload ( getFileItemFactory (  )  )  ;", "actualFileUpload . setSizeMax ( fileUpload . getSizeMax (  )  )  ;", "actualFileUpload . setFileSizeMax ( fileUpload . getFileSizeMax (  )  )  ;", "actualFileUpload . setHeaderEncoding ( encoding )  ;", "}", "return   actualFileUpload ;", "}", "METHOD_END"], "methodName": ["prepareFileUpload"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "this . fileUpload . setHeaderEncoding ( defaultEncoding )  ;", "}", "METHOD_END"], "methodName": ["setDefaultEncoding"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "this . fileItemFactory . setSizeThreshold ( maxInMemorySize )  ;", "}", "METHOD_END"], "methodName": ["setMaxInMemorySize"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "this . fileUpload . setSizeMax ( maxUploadSize )  ;", "}", "METHOD_END"], "methodName": ["setMaxUploadSize"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "this . fileUpload . setFileSizeMax ( maxUploadSizePerFile )  ;", "}", "METHOD_END"], "methodName": ["setMaxUploadSizePerFile"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "this . preserveFilename    =    preserveFilename ;", "}", "METHOD_END"], "methodName": ["setPreserveFilename"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( uploadTempDir . exists (  )  )  )     &  &     (  !  ( uploadTempDir . getFile (  )  . mkdirs (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Given   uploadTempDir    [  \"     +    uploadTempDir )     +     \"  ]    could   not   be   created \"  )  )  ;", "}", "this . fileItemFactory . setRepository ( uploadTempDir . getFile (  )  )  ;", "this . uploadTempDirSpecified    =    true ;", "}", "METHOD_END"], "methodName": ["setUploadTempDir"], "fileName": "org.springframework.web.multipart.commons.CommonsFileUploadSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . fileItem ;", "}", "METHOD_END"], "methodName": ["getFileItem"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartFile"}, {"methodBody": ["METHOD_START", "{", "if    ( this . fileItem . isInMemory (  )  )     {", "return    \" in   memory \"  ;", "} else", "if    (  ( this . fileItem )    instanceof   DiskFileItem )     {", "return    (  \" at    [  \"     +     (  (  ( DiskFileItem )     ( this . fileItem )  )  . getStoreLocation (  )  . getAbsolutePath (  )  )  )     +     \"  ]  \"  ;", "} else    {", "return    \" on   disk \"  ;", "}", "}", "METHOD_END"], "methodName": ["getStorageDescription"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartFile"}, {"methodBody": ["METHOD_START", "{", "if    ( this . fileItem . isInMemory (  )  )     {", "return   true ;", "}", "if    (  ( this . fileItem )    instanceof   DiskItem )     {", "return    (  ( DiskItem )     ( this . fileItem )  )  . getStoreLocation (  )  . exists (  )  ;", "}", "return    ( this . fileItem . getSize (  )  )     =  =     ( this . size )  ;", "}", "METHOD_END"], "methodName": ["isAvailable"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartFile"}, {"methodBody": ["METHOD_START", "{", "this . preserveFilename    =    preserveFilename ;", "}", "METHOD_END"], "methodName": ["setPreserveFilename"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartFile"}, {"methodBody": ["METHOD_START", "{", "String   encoding    =    request . getCharacterEncoding (  )  ;", "if    ( encoding    =  =    null )     {", "encoding    =    getDefaultEncoding (  )  ;", "}", "return   encoding ;", "}", "METHOD_END"], "methodName": ["determineEncoding"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolver"}, {"methodBody": ["METHOD_START", "{", "String   encoding    =    determineEncoding ( request )  ;", "FileUpload   fileUpload    =    prepareFileUpload ( encoding )  ;", "try    {", "List < FileItem >    fileItems    =     (  ( ServletFileUpload )     ( fileUpload )  )  . parseRequest ( request )  ;", "return   parseFileItems ( fileItems ,    encoding )  ;", "}    catch    ( FileUploadBase   ex )     {", "throw   new   MaxUploadSizeExceededException ( fileUpload . getSizeMax (  )  ,    ex )  ;", "}    catch    ( FileUploadBase   ex )     {", "throw   new   MaxUploadSizeExceededException ( fileUpload . getFileSizeMax (  )  ,    ex )  ;", "}    catch    ( FileUploadException   ex )     {", "throw   new   MultipartException (  \" Failed   to   parse   multipart   servlet   request \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["parseRequest"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolver"}, {"methodBody": ["METHOD_START", "{", "this . resolveLazily    =    resolveLazily ;", "}", "METHOD_END"], "methodName": ["setResolveLazily"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolver"}, {"methodBody": ["METHOD_START", "{", "CommonsMultipartResolverTests . MultipartTestBean 1    mtb 1     =    new   CommonsMultipartResolverTests . MultipartTestBean 1  (  )  ;", "assertArrayEquals ( null ,    mtb 1  . getField 1  (  )  )  ;", "assertEquals ( null ,    mtb 1  . getField 2  (  )  )  ;", "ServletRequestDataBinder   binder    =    new   ServletRequestDataBinder ( mtb 1  ,     \" mybean \"  )  ;", "binder . registerCustomEditor ( byte [  ]  . class ,    new   ByteArrayMultipartFileEditor (  )  )  ;", "binder . bind ( request )  ;", "List < MultipartFile >    file 1 List    =    request . getFiles (  \" field 1  \"  )  ;", "CommonsMultipartFile   file 1 a    =     (  ( CommonsMultipartFile )     ( file 1 List . get (  0  )  )  )  ;", "CommonsMultipartFile   file 1 b    =     (  ( CommonsMultipartFile )     ( file 1 List . get (  1  )  )  )  ;", "CommonsMultipartFile   file 2     =     (  ( CommonsMultipartFile )     ( request . getFile (  \" field 2  \"  )  )  )  ;", "assertEquals ( file 1 a ,    mtb 1  . getField 1  (  )  [  0  ]  )  ;", "assertEquals ( file 1 b ,    mtb 1  . getField 1  (  )  [  1  ]  )  ;", "assertEquals ( new   String ( file 2  . getBytes (  )  )  ,    new   String ( mtb 1  . getField 2  (  )  )  )  ;", "CommonsMultipartResolverTests . MultipartTestBean 2    mtb 2     =    new   CommonsMultipartResolverTests . MultipartTestBean 2  (  )  ;", "assertArrayEquals ( null ,    mtb 2  . getField 1  (  )  )  ;", "assertEquals ( null ,    mtb 2  . getField 2  (  )  )  ;", "binder    =    new   ServletRequestDataBinder ( mtb 2  ,     \" mybean \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" field 1  \"  ,    new   StringMultipartFileEditor (  )  )  ;", "binder . registerCustomEditor ( String . class ,     \" field 2  \"  ,    new   StringMultipartFileEditor (  \" UTF -  1  6  \"  )  )  ;", "binder . bind ( request )  ;", "assertEquals ( new   String ( file 1 a . getBytes (  )  )  ,    mtb 2  . getField 1  (  )  [  0  ]  )  ;", "assertEquals ( new   String ( file 1 b . getBytes (  )  )  ,    mtb 2  . getField 1  (  )  [  1  ]  )  ;", "assertEquals ( new   String ( file 2  . getBytes (  )  ,     \" UTF -  1  6  \"  )  ,    mtb 2  . getField 2  (  )  )  ;", "resolver . cleanupMultipart ( request )  ;", "assertTrue (  (  ( CommonsMultipartResolverTests . MockFileItem )     ( file 1 a . getFileItem (  )  )  )  . deleted )  ;", "assertTrue (  (  ( CommonsMultipartResolverTests . MockFileItem )     ( file 1 b . getFileItem (  )  )  )  . deleted )  ;", "assertTrue (  (  ( CommonsMultipartResolverTests . MockFileItem )     ( file 2  . getFileItem (  )  )  )  . deleted )  ;", "resolver . setEmpty ( true )  ;", "request    =    resolver . resolveMultipart ( originalRequest )  ;", "binder . setBindEmptyMultipartFiles ( false )  ;", "String   firstBound    =    mtb 2  . getField 2  (  )  ;", "binder . bind ( request )  ;", "assertFalse ( mtb 2  . getField 2  (  )  . isEmpty (  )  )  ;", "assertEquals ( firstBound ,    mtb 2  . getField 2  (  )  )  ;", "request    =    resolver . resolveMultipart ( originalRequest )  ;", "binder . setBindEmptyMultipartFiles ( true )  ;", "binder . bind ( request )  ;", "assertTrue ( mtb 2  . getField 2  (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestBinding"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolverTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    fileNames    =    new   HashSet <  >  (  )  ;", "Iterator < String >    fileIter    =    request . getFileNames (  )  ;", "while    ( fileIter . hasNext (  )  )     {", "fileNames . add ( fileIter . next (  )  )  ;", "}", "assertEquals (  3  ,    fileNames . size (  )  )  ;", "assertTrue ( fileNames . contains (  \" field 1  \"  )  )  ;", "assertTrue ( fileNames . contains (  \" field 2  \"  )  )  ;", "assertTrue ( fileNames . contains (  \" field 2 x \"  )  )  ;", "CommonsMultipartFile   file 1     =     (  ( CommonsMultipartFile )     ( request . getFile (  \" field 1  \"  )  )  )  ;", "CommonsMultipartFile   file 2     =     (  ( CommonsMultipartFile )     ( request . getFile (  \" field 2  \"  )  )  )  ;", "CommonsMultipartFile   file 2 x    =     (  ( CommonsMultipartFile )     ( request . getFile (  \" field 2 x \"  )  )  )  ;", "Map < String ,    MultipartFile >    fileMap    =    request . getFileMap (  )  ;", "assertEquals (  3  ,    fileMap . size (  )  )  ;", "assertTrue ( fileMap . containsKey (  \" field 1  \"  )  )  ;", "assertTrue ( fileMap . containsKey (  \" field 2  \"  )  )  ;", "assertTrue ( fileMap . containsKey (  \" field 2 x \"  )  )  ;", "assertEquals ( file 1  ,    fileMap . get (  \" field 1  \"  )  )  ;", "assertEquals ( file 2  ,    fileMap . get (  \" field 2  \"  )  )  ;", "assertEquals ( file 2 x ,    fileMap . get (  \" field 2 x \"  )  )  ;", "MultiValueMap < String ,    MultipartFile >    multiFileMap    =    request . getMultiFileMap (  )  ;", "assertEquals (  3  ,    multiFileMap . size (  )  )  ;", "assertTrue ( multiFileMap . containsKey (  \" field 1  \"  )  )  ;", "assertTrue ( multiFileMap . containsKey (  \" field 2  \"  )  )  ;", "assertTrue ( multiFileMap . containsKey (  \" field 2 x \"  )  )  ;", "List < MultipartFile >    field 1 Files    =    multiFileMap . get (  \" field 1  \"  )  ;", "assertEquals (  2  ,    field 1 Files . size (  )  )  ;", "assertTrue ( field 1 Files . contains ( file 1  )  )  ;", "assertEquals ( file 1  ,    multiFileMap . getFirst (  \" field 1  \"  )  )  ;", "assertEquals ( file 2  ,    multiFileMap . getFirst (  \" field 2  \"  )  )  ;", "assertEquals ( file 2 x ,    multiFileMap . getFirst (  \" field 2 x \"  )  )  ;", "assertEquals (  \" type 1  \"  ,    file 1  . getContentType (  )  )  ;", "assertEquals (  \" type 2  \"  ,    file 2  . getContentType (  )  )  ;", "assertEquals (  \" type 2  \"  ,    file 2 x . getContentType (  )  )  ;", "assertEquals (  \" field 1  . txt \"  ,    file 1  . getOriginalFilename (  )  )  ;", "assertEquals (  \" field 2  . txt \"  ,    file 2  . getOriginalFilename (  )  )  ;", "assertEquals (  \" field 2 x . txt \"  ,    file 2 x . getOriginalFilename (  )  )  ;", "assertEquals (  \" text 1  \"  ,    new   String ( file 1  . getBytes (  )  )  )  ;", "assertEquals (  \" text 2  \"  ,    new   String ( file 2  . getBytes (  )  )  )  ;", "assertEquals (  5  ,    file 1  . getSize (  )  )  ;", "assertEquals (  5  ,    file 2  . getSize (  )  )  ;", "assertTrue (  (  ( file 1  . getInputStream (  )  )    instanceof   ByteArrayInputStream )  )  ;", "assertTrue (  (  ( file 2  . getInputStream (  )  )    instanceof   ByteArrayInputStream )  )  ;", "File   transfer 1     =    new   File (  \" C :  / transfer 1  \"  )  ;", "file 1  . transferTo ( transfer 1  )  ;", "File   transfer 2     =    new   File (  \" C :  / transfer 2  \"  )  ;", "file 2  . transferTo ( transfer 2  )  ;", "assertEquals ( transfer 1  ,     (  (  . MockFileItem )     ( file 1  . getFileItem (  )  )  )  . writtenFile )  ;", "assertEquals ( transfer 2  ,     (  (  . MockFileItem )     ( file 2  . getFileItem (  )  )  )  . writtenFile )  ;", "}", "METHOD_END"], "methodName": ["doTestFiles"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolverTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    parameterNames    =    new   HashSet <  >  (  )  ;", "Enumeration < String >    parameterEnum    =    request . getParameterNames (  )  ;", "while    ( parameterEnum . hasMoreElements (  )  )     {", "parameterNames . add ( parameterEnum . nextElement (  )  )  ;", "}", "assertEquals (  3  ,    parameterNames . size (  )  )  ;", "assertTrue ( parameterNames . contains (  \" field 3  \"  )  )  ;", "assertTrue ( parameterNames . contains (  \" field 4  \"  )  )  ;", "assertTrue ( parameterNames . contains (  \" getField \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    request . getParameter (  \" field 3  \"  )  )  ;", "List < String >    parameterValues    =    Arrays . asList ( request . getParameterValues (  \" field 3  \"  )  )  ;", "assertEquals (  1  ,    parameterValues . size (  )  )  ;", "assertTrue ( parameterValues . contains (  \" value 3  \"  )  )  ;", "assertEquals (  \" value 4  \"  ,    request . getParameter (  \" field 4  \"  )  )  ;", "parameterValues    =    Arrays . asList ( request . getParameterValues (  \" field 4  \"  )  )  ;", "assertEquals (  2  ,    parameterValues . size (  )  )  ;", "assertTrue ( parameterValues . contains (  \" value 4  \"  )  )  ;", "assertTrue ( parameterValues . contains (  \" value 5  \"  )  )  ;", "assertEquals (  \" value 4  \"  ,    request . getParameter (  \" field 4  \"  )  )  ;", "assertEquals (  \" getValue \"  ,    request . getParameter (  \" getField \"  )  )  ;", "List < String >    parameterMapKeys    =    new   ArrayList <  >  (  )  ;", "List < Object >    parameterMapValues    =    new   ArrayList <  >  (  )  ;", "for    ( Object   o    :    request . getParameterMap (  )  . keySet (  )  )     {", "String   key    =     (  ( String )     ( o )  )  ;", "parameterMapKeys . add ( key )  ;", "parameterMapValues . add ( request . getParameterMap (  )  . get ( key )  )  ;", "}", "assertEquals (  3  ,    parameterMapKeys . size (  )  )  ;", "assertEquals (  3  ,    parameterMapValues . size (  )  )  ;", "int   field 3 Index    =    parameterMapKeys . indexOf (  \" field 3  \"  )  ;", "int   field 4 Index    =    parameterMapKeys . indexOf (  \" field 4  \"  )  ;", "int   getFieldIndex    =    parameterMapKeys . indexOf (  \" getField \"  )  ;", "assertTrue (  ( field 3 Index    !  =     (  -  1  )  )  )  ;", "assertTrue (  ( field 4 Index    !  =     (  -  1  )  )  )  ;", "assertTrue (  ( getFieldIndex    !  =     (  -  1  )  )  )  ;", "parameterValues    =    Arrays . asList (  (  ( String [  ]  )     ( parameterMapValues . get ( field 3 Index )  )  )  )  ;", "assertEquals (  1  ,    parameterValues . size (  )  )  ;", "assertTrue ( parameterValues . contains (  \" value 3  \"  )  )  ;", "parameterValues    =    Arrays . asList (  (  ( String [  ]  )     ( parameterMapValues . get ( field 4 Index )  )  )  )  ;", "assertEquals (  2  ,    parameterValues . size (  )  )  ;", "assertTrue ( parameterValues . contains (  \" value 4  \"  )  )  ;", "assertTrue ( parameterValues . contains (  \" value 5  \"  )  )  ;", "parameterValues    =    Arrays . asList (  (  ( String [  ]  )     ( parameterMapValues . get ( getFieldIndex )  )  )  )  ;", "assertEquals (  1  ,    parameterValues . size (  )  )  ;", "assertTrue ( parameterValues . contains (  \" getValue \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestParameters"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolverTests"}, {"methodBody": ["METHOD_START", "{", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( new   MockServletContext (  )  )  ;", "wac . getServletContext (  )  . setAttribute ( WebUtils . TEMP _ DIR _ CONTEXT _ ATTRIBUTE ,    new   File (  \" mytemp \"  )  )  ;", "wac . refresh (  )  ;", ". MockCommonsMultipartResolver   resolver    =    new    . MockCommonsMultipartResolver (  )  ;", "resolver . setMaxUploadSize (  1  0  0  0  )  ;", "resolver . setMaxInMemorySize (  1  0  0  )  ;", "resolver . setDefaultEncoding (  \" enc \"  )  ;", "if    ( lazy )     {", "resolver . setResolveLazily ( false )  ;", "}", "resolver . setServletContext ( wac . getServletContext (  )  )  ;", "assertEquals (  1  0  0  0  ,    resolver . getFileUpload (  )  . getSizeMax (  )  )  ;", "assertEquals (  1  0  0  ,    resolver . getFileItemFactory (  )  . getSizeThreshold (  )  )  ;", "assertEquals (  \" enc \"  ,    resolver . getFileUpload (  )  . getHeaderEncoding (  )  )  ;", "assertTrue ( resolver . getFileItemFactory (  )  . getRepository (  )  . getAbsolutePath (  )  . endsWith (  \" mytemp \"  )  )  ;", "MockHttpServletRequest   originalRequest    =    new   MockHttpServletRequest (  )  ;", "originalRequest . setMethod (  \" POST \"  )  ;", "originalRequest . setContentType (  \" multipart / form - data \"  )  ;", "originalRequest . addHeader (  \" Content - type \"  ,     \" multipart / form - data \"  )  ;", "originalRequest . addParameter (  \" getField \"  ,     \" getValue \"  )  ;", "assertTrue ( resolver . isMultipart ( originalRequest )  )  ;", "MultipartHttpServletRequest   request    =    resolver . resolveMultipart ( originalRequest )  ;", "doTestParameters ( request )  ;", "doTestFiles ( request )  ;", "doTestBinding ( resolver ,    originalRequest ,    request )  ;", "wac . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestWithApplicationContext"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolverTests"}, {"methodBody": ["METHOD_START", "{", "doTestWithApplicationContext ( false )  ;", "}", "METHOD_END"], "methodName": ["withApplicationContext"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolverTests"}, {"methodBody": ["METHOD_START", "{", "doTestWithApplicationContext ( true )  ;", "}", "METHOD_END"], "methodName": ["withApplicationContextAndLazyResolution"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolverTests"}, {"methodBody": ["METHOD_START", "{", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( new   MockServletContext (  )  )  ;", "wac . registerSingleton (  \" filterMultipartResolver \"  ,     . MockCommonsMultipartResolver . class ,    new   MutablePropertyValues (  )  )  ;", "wac . getServletContext (  )  . setAttribute ( WebUtils . TEMP _ DIR _ CONTEXT _ ATTRIBUTE ,    new   File (  \" mytemp \"  )  )  ;", "wac . refresh (  )  ;", "wac . getServletContext (  )  . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", "CommonsMultipartResolver   resolver    =    new   CommonsMultipartResolver ( wac . getServletContext (  )  )  ;", "assertTrue ( resolver . getFileItemFactory (  )  . getRepository (  )  . getAbsolutePath (  )  . endsWith (  \" mytemp \"  )  )  ;", "MockFilterConfig   filterConfig    =    new   MockFilterConfig ( wac . getServletContext (  )  ,     \" filter \"  )  ;", "filterConfig . addInitParameter (  \" class \"  ,     \" notWritable \"  )  ;", "filterConfig . addInitParameter (  \" unknownParam \"  ,     \" someValue \"  )  ;", "final   MultipartFilter   filter    =    new   MultipartFilter (  )  ;", "filter . init ( filterConfig )  ;", "final   List < MultipartFile >    files    =    new   ArrayList <  >  (  )  ;", "final   FilterChain   filterChain    =    new   FilterChain (  )     {", "@ Override", "public   void   doFilter ( ServletRequest   servletRequest ,    ServletResponse   servletResponse )     {", "MultipartHttpServletRequest   request    =     (  ( MultipartHttpServletRequest )     ( servletRequest )  )  ;", "files . addAll ( request . getFileMap (  )  . values (  )  )  ;", "}", "}  ;", "FilterChain   filterChain 2     =    new   PassThroughFilterChain ( filter ,    filterChain )  ;", "MockHttpServletRequest   originalRequest    =    new   MockHttpServletRequest (  )  ;", "MockHttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "originalRequest . setMethod (  \" POST \"  )  ;", "originalRequest . setContentType (  \" multipart / form - data \"  )  ;", "originalRequest . addHeader (  \" Content - type \"  ,     \" multipart / form - data \"  )  ;", "filter . doFilter ( originalRequest ,    response ,    filterChain 2  )  ;", "CommonsMultipartFile   file 1     =     (  ( CommonsMultipartFile )     ( files . get (  0  )  )  )  ;", "CommonsMultipartFile   file 2     =     (  ( CommonsMultipartFile )     ( files . get (  1  )  )  )  ;", "assertTrue (  (  (  . MockFileItem )     ( file 1  . getFileItem (  )  )  )  . deleted )  ;", "assertTrue (  (  (  . MockFileItem )     ( file 2  . getFileItem (  )  )  )  . deleted )  ;", "}", "METHOD_END"], "methodName": ["withServletContextAndFilter"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolverTests"}, {"methodBody": ["METHOD_START", "{", "StaticWebApplicationContext   wac    =    new   StaticWebApplicationContext (  )  ;", "wac . setServletContext ( new   MockServletContext (  )  )  ;", "wac . refresh (  )  ;", "wac . registerSingleton (  \" myMultipartResolver \"  ,     . MockCommonsMultipartResolver . class ,    new   MutablePropertyValues (  )  )  ;", "wac . getServletContext (  )  . setAttribute ( WebUtils . TEMP _ DIR _ CONTEXT _ ATTRIBUTE ,    new   File (  \" mytemp \"  )  )  ;", "wac . getServletContext (  )  . setAttribute ( WebApplicationContext . ROOT _ WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ,    wac )  ;", "CommonsMultipartResolver   resolver    =    new   CommonsMultipartResolver ( wac . getServletContext (  )  )  ;", "assertTrue ( resolver . getFileItemFactory (  )  . getRepository (  )  . getAbsolutePath (  )  . endsWith (  \" mytemp \"  )  )  ;", "MockFilterConfig   filterConfig    =    new   MockFilterConfig ( wac . getServletContext (  )  ,     \" filter \"  )  ;", "filterConfig . addInitParameter (  \" multipartResolverBeanName \"  ,     \" myMultipartResolver \"  )  ;", "final   List < MultipartFile >    files    =    new   ArrayList <  >  (  )  ;", "FilterChain   filterChain    =    new   FilterChain (  )     {", "@ Override", "public   void   doFilter ( ServletRequest   originalRequest ,    ServletResponse   response )     {", "if    ( originalRequest   instanceof   MultipartHttpServletRequest )     {", "MultipartHttpServletRequest   request    =     (  ( MultipartHttpServletRequest )     ( originalRequest )  )  ;", "files . addAll ( request . getFileMap (  )  . values (  )  )  ;", "}", "}", "}  ;", "MultipartFilter   filter    =    new   MultipartFilter (  )     {", "private   boolean   invoked    =    false ;", "@ Override", "protected   void   doFilterInternal ( HttpServletRequest   request ,    HttpServletResponse   response ,    FilterChain   filterChain )    throws   IOException ,    ServletException    {", "super . doFilterInternal ( request ,    response ,    filterChain )  ;", "super . doFilterInternal ( request ,    response ,    filterChain )  ;", "if    ( invoked )     {", "throw   new   ServletException (  \" Should   not   have   been   invoked   twice \"  )  ;", "}", "invoked    =    true ;", "}", "}  ;", "filter . init ( filterConfig )  ;", "MockHttpServletRequest   originalRequest    =    new   MockHttpServletRequest (  )  ;", "originalRequest . setMethod (  \" POST \"  )  ;", "originalRequest . setContentType (  \" multipart / form - data \"  )  ;", "originalRequest . addHeader (  \" Content - type \"  ,     \" multipart / form - data \"  )  ;", "HttpServletResponse   response    =    new   MockHttpServletResponse (  )  ;", "filter . doFilter ( originalRequest ,    response ,    filterChain )  ;", "CommonsMultipartFile   file 1     =     (  ( CommonsMultipartFile )     ( files . get (  0  )  )  )  ;", "CommonsMultipartFile   file 2     =     (  ( CommonsMultipartFile )     ( files . get (  1  )  )  )  ;", "assertTrue (  (  (  . MockFileItem )     ( file 1  . getFileItem (  )  )  )  . deleted )  ;", "assertTrue (  (  (  . MockFileItem )     ( file 2  . getFileItem (  )  )  )  . deleted )  ;", "}", "METHOD_END"], "methodName": ["withServletContextAndFilterWithCustomBeanName"], "fileName": "org.springframework.web.multipart.commons.CommonsMultipartResolverTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . multipartFiles )     =  =    null )     {", "initializeMultipart (  )  ;", "}", "return   this . multipartFiles ;", "}", "METHOD_END"], "methodName": ["getMultipartFiles"], "fileName": "org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "throw   new   IllegalStateException (  \" Multipart   request   not   initialized \"  )  ;", "}", "METHOD_END"], "methodName": ["initializeMultipart"], "fileName": "org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "return    ( this . multipartFiles )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isResolved"], "fileName": "org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . multipartFiles    =    new   LinkedMultiValueMap ( Collections . unmodifiableMap ( multipartFiles )  )  ;", "}", "METHOD_END"], "methodName": ["setMultipartFiles"], "fileName": "org.springframework.web.multipart.support.AbstractMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "String   expectedValue    =     \" Shumwere ,    shumhow ,    a   shuck   ish   washing   you .     -    Drunken   Far   Side \"  ;", "e . setValue ( expectedValue . getBytes (  )  )  ;", "assertEquals ( expectedValue ,    e . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValueAsByteArray"], "fileName": "org.springframework.web.multipart.support.ByteArrayMultipartFileEditorTests"}, {"methodBody": ["METHOD_START", "{", "final   String   expectedValue    =     \"  ' Green   Wing '     -    classic   British   comedy \"  ;", "Object   object    =    new   Object (  )     {", "@ Override", "public   String   toString (  )     {", "return   expectedValue ;", "}", "}  ;", "e . setValue ( object )  ;", "assertEquals ( expectedValue ,    e . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValueAsCustomObjectInvokesToString"], "fileName": "org.springframework.web.multipart.support.ByteArrayMultipartFileEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedValue    =     \" That   is   comforting   to   know \"  ;", "file    =    mock (  . class )  ;", "given ( file . getBytes (  )  )  . willReturn ( expectedValue . getBytes (  )  )  ;", "editor . setValue ( file )  ;", "assertEquals ( expectedValue ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValueAsMultipartFile"], "fileName": "org.springframework.web.multipart.support.ByteArrayMultipartFileEditorTests"}, {"methodBody": ["METHOD_START", "{", "MultipartFile   file    =    mock ( MultipartFile . class )  ;", "given ( file . getBytes (  )  )  . willThrow ( new   IOException (  )  )  ;", "editor . setValue ( file )  ;", "}", "METHOD_END"], "methodName": ["setValueAsMultipartFileWithBadBytes"], "fileName": "org.springframework.web.multipart.support.ByteArrayMultipartFileEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setValue ( null )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValueAsNullGetsBackEmptyString"], "fileName": "org.springframework.web.multipart.support.ByteArrayMultipartFileEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedValue    =     \"  ' Green   Wing '     -    classic   British   comedy \"  ;", "e . setValue ( expectedValue )  ;", "assertEquals ( expectedValue ,    e . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValueAsString"], "fileName": "org.springframework.web.multipart.support.ByteArrayMultipartFileEditorTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . multipartParameterContentTypes )     =  =    null )     {", "initializeMultipart (  )  ;", "}", "return   this . multipartParameterContentTypes ;", "}", "METHOD_END"], "methodName": ["getMultipartParameterContentTypes"], "fileName": "org.springframework.web.multipart.support.DefaultMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . multipartParameters )     =  =    null )     {", "initializeMultipart (  )  ;", "}", "return   this . multipartParameters ;", "}", "METHOD_END"], "methodName": ["getMultipartParameters"], "fileName": "org.springframework.web.multipart.support.DefaultMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . multipartParameterContentTypes    =    multipartParameterContentTypes ;", "}", "METHOD_END"], "methodName": ["setMultipartParameterContentTypes"], "fileName": "org.springframework.web.multipart.support.DefaultMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "this . multipartParameters    =    multipartParameters ;", "}", "METHOD_END"], "methodName": ["setMultipartParameters"], "fileName": "org.springframework.web.multipart.support.DefaultMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . partName ;", "}", "METHOD_END"], "methodName": ["getRequestPartName"], "fileName": "org.springframework.web.multipart.support.MissingServletRequestPartException"}, {"methodBody": ["METHOD_START", "{", "return   this . multipartResolverBeanName ;", "}", "METHOD_END"], "methodName": ["getMultipartResolverBeanName"], "fileName": "org.springframework.web.multipart.support.MultipartFilter"}, {"methodBody": ["METHOD_START", "{", "WebApplicationContext   wac    =    WebApplicationContextUtils . getWebApplicationContext ( getServletContext (  )  )  ;", "String   beanName    =    getMultipartResolverBeanName (  )  ;", "if    (  ( wac    !  =    null )     &  &     ( wac . containsBean ( beanName )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Using   MultipartResolver    '  \"     +    beanName )     +     \"  '    for    \"  )  )  ;", "}", "return   wac . getBean ( beanName ,    MultipartResolver . class )  ;", "} else    {", "return   this . defaultMultipartResolver ;", "}", "}", "METHOD_END"], "methodName": ["lookupMultipartResolver"], "fileName": "org.springframework.web.multipart.support.MultipartFilter"}, {"methodBody": ["METHOD_START", "{", "return   lookupMultipartResolver (  )  ;", "}", "METHOD_END"], "methodName": ["lookupMultipartResolver"], "fileName": "org.springframework.web.multipart.support.MultipartFilter"}, {"methodBody": ["METHOD_START", "{", "this . multipartResolverBeanName    =    multipartResolverBeanName ;", "}", "METHOD_END"], "methodName": ["setMultipartResolverBeanName"], "fileName": "org.springframework.web.multipart.support.MultipartFilter"}, {"methodBody": ["METHOD_START", "{", "MultipartHttpServletRequest   unwrapped    =    WebUtils . getNativeRequest ( request ,    MultipartHttpServletRequest . class )  ;", "if    ( unwrapped    !  =    null )     {", "return   unwrapped ;", "}", "return   new   StandardMultipartHttpServletRequest ( request )  ;", "}", "METHOD_END"], "methodName": ["asMultipartHttpServletRequest"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    paramType    =    methodParam . getNestedParameterType (  )  ;", "if    (  (  ( Collection . class )     =  =    paramType )     |  |     ( List . class . isAssignableFrom ( paramType )  )  )     {", "Class <  ?  >    valueType    =    vableType . forMethodParameter ( methodParam )  . asCollection (  )  . resolveGeneric (  )  ;", "if    ( valueType    !  =    null )     {", "return   valueType ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCollectionParameterType"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    paramType    =    parameter . getNestedParameterType (  )  ;", "return    (  (  (  ( MultipartFile . class )     =  =    paramType )     |  |     (  . isMultipartFileCollection ( parameter )  )  )     |  |     (  . isMultipartFileArray ( parameter )  )  )     |  |     (  (  (  ( Part . class )     =  =    paramType )     |  |     (  . isPartCollection ( parameter )  )  )     |  |     (  . isPartArray ( parameter )  )  )  ;", "}", "METHOD_END"], "methodName": ["isMultipartArgument"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =    request . getContentType (  )  ;", "return    ( contentType    !  =    null )     &  &     ( contentType . toLowerCase (  )  . startsWith (  \"  /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isMultipartContent"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "return    ( MultipartFile . class )     =  =     ( methodParam . getNestedParameterType (  )  . getComponentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isMultipartFileArray"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "return    ( MultipartFile . class )     =  =     ( MultipartResolutionDelegate . getCollectionParameterType ( methodParam )  )  ;", "}", "METHOD_END"], "methodName": ["isMultipartFileCollection"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "return    (  ( WebUtils . getNativeRequest ( request ,    MultipartHttpServletRequest . class )  )     !  =    null )     |  |     ( MultipartResolutionDelegate . isMultipartContent ( request )  )  ;", "}", "METHOD_END"], "methodName": ["isMultipartRequest"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "return    ( Part . class )     =  =     ( methodParam . getNestedParameterType (  )  . getComponentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPartArray"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "return    ( Part . class )     =  =     ( MultipartResolutionDelegate . getCollectionParameterType ( methodParam )  )  ;", "}", "METHOD_END"], "methodName": ["isPartCollection"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "MultipartHttpServletRequest   multipartRequest    =    WebUtils . getNativeRequest ( request ,    MultipartHttpServletRequest . class )  ;", "boolean   isMultipart    =     ( multipartRequest    !  =    null )     |  |     (  . isMultipartContent ( request )  )  ;", "if    (  ( MultipartFile . class )     =  =     ( parameter . getNestedParameterType (  )  )  )     {", "if    (  ( multipartRequest    =  =    null )     &  &    isMultipart )     {", "multipartRequest    =    new   StandardMultipartHttpServletRequest ( request )  ;", "}", "return   multipartRequest    !  =    null    ?    multipartRequest . getFile ( name )     :    null ;", "} else", "if    (  . isMultipartFileCollection ( parameter )  )     {", "if    (  ( multipartRequest    =  =    null )     &  &    isMultipart )     {", "multipartRequest    =    new   StandardMultipartHttpServletRequest ( request )  ;", "}", "return   multipartRequest    !  =    null    ?    multipartRequest . getFiles ( name )     :    null ;", "} else", "if    (  . isMultipartFileArray ( parameter )  )     {", "if    (  ( multipartRequest    =  =    null )     &  &    isMultipart )     {", "multipartRequest    =    new   StandardMultipartHttpServletRequest ( request )  ;", "}", "if    ( multipartRequest    !  =    null )     {", "List < MultipartFile >    multipartFiles    =    multipartRequest . getFiles ( name )  ;", "return   multipartFiles . toArray ( new   MultipartFile [  0  ]  )  ;", "} else    {", "return   null ;", "}", "} else", "if    (  ( class )     =  =     ( parameter . getNestedParameterType (  )  )  )     {", "return   isMultipart    ?     . resolvePart ( request ,    name )     :    null ;", "} else", "if    (  . isPartCollection ( parameter )  )     {", "return   isMultipart    ?     . resolvePartList ( request ,    name )     :    null ;", "} else", "if    (  . isPartArray ( parameter )  )     {", "return   isMultipart    ?     . resolvePartArray ( request ,    name )     :    null ;", "} else    {", "return    . UNRESOLVABLE ;", "}", "}", "METHOD_END"], "methodName": ["resolveMultipartArgument"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "return   servletRequest . getPart ( name )  ;", "}", "METHOD_END"], "methodName": ["resolvePart"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "Collection < Part >        =    servletRequest . getParts (  )  ;", "List < Part >    result    =    new   ArrayList (  . size (  )  )  ;", "for    ( Part    :     )     {", "if    ( getName (  )  . equals ( name )  )     {", "result . add (  ;", "}", "}", "return   result . toArray ( new   Part [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["resolvePartArray"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "Collection < Part >        =    servletRequest . getParts (  )  ;", "List < Part >    result    =    new   ArrayList (  . size (  )  )  ;", "for    ( Part    :     )     {", "if    ( getName (  )  . equals ( name )  )     {", "result . add (  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["resolvePartList"], "fileName": "org.springframework.web.multipart.support.MultipartResolutionDelegate"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    getHeaders (  )  . getContentType (  )  ;", "if    ( contentType    !  =    null )     {", "Charset   charset    =    contentType . getCharset (  )  ;", "if    ( charset    !  =    null )     {", "return   charset ;", "}", "}", "String   encoding    =    this . multipartRequest . getCharacterEncoding (  )  ;", "return   encoding    !  =    null    ?    Charset . forName ( encoding )     :     . FORM _ CHARSET ;", "}", "METHOD_END"], "methodName": ["determineCharset"], "fileName": "org.springframework.web.multipart.support.RequestPartServletServerHttpRequest"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =     \" content \"  . getBytes (  \" UTF -  8  \"  )  ;", "MultipartFile   part    =    new   MockMultipartFile (  \" part \"  ,     \"  \"  ,     \" application / json \"  ,    bytes )  ;", "this . mockRequest . addFile ( part )  ;", "ServerHttpRequest   request    =    new    ( this . mockRequest ,     \" part \"  )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( request . getBody (  )  )  ;", "assertArrayEquals ( bytes ,    result )  ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.springframework.web.multipart.support.RequestPartServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   mockRequest    =    new   MockMultipartHttpServletRequest (  )     {", "@ Override", "public   HttpHeaders   getMultipartHeaders ( String   paramOrFileName )     {", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( new   MediaType (  \" application \"  ,     \" octet - stream \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "return   headers ;", "}", "}  ;", "byte [  ]    bytes    =    new   byte [  ]  {     (  ( byte )     (  1  9  6  )  )     }  ;", "mockRequest . setParameter (  \" part \"  ,    new   String ( bytes ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "ServerHttpRequest   request    =    new    ( mockRequest ,     \" part \"  )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( request . getBody (  )  )  ;", "assertArrayEquals ( bytes ,    result )  ;", "}", "METHOD_END"], "methodName": ["getBodyViaRequestParameter"], "fileName": "org.springframework.web.multipart.support.RequestPartServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockMultipartHttpServletRequest   mockRequest    =    new   MockMultipartHttpServletRequest (  )     {", "@ Override", "public   HttpHeaders   getMultipartHeaders ( String   paramOrFileName )     {", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( MediaType . APPLICATION _ OCTET _ STREAM )  ;", "return   headers ;", "}", "}  ;", "byte [  ]    bytes    =    new   byte [  ]  {     (  ( byte )     (  1  9  6  )  )     }  ;", "mockRequest . setParameter (  \" part \"  ,    new   String ( bytes ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  ;", "mockRequest . setCharacterEncoding (  \" iso -  8  8  5  9  -  1  \"  )  ;", "ServerHttpRequest   request    =    new    ( mockRequest ,     \" part \"  )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( request . getBody (  )  )  ;", "assertArrayEquals ( bytes ,    result )  ;", "}", "METHOD_END"], "methodName": ["getBodyViaRequestParameterWithRequestEncoding"], "fileName": "org.springframework.web.multipart.support.RequestPartServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =     \" content \"  . getBytes (  \" UTF -  8  \"  )  ;", "MultipartFile   part    =    new   MockMultipartFile (  \" part \"  ,     \"  \"  ,     \" application / json \"  ,    bytes )  ;", "this . mockRequest . addFile ( part )  ;", "HttpServletRequest   wrapped    =    new   HttpServletRequestWrapper ( this . mockRequest )  ;", "ServerHttpRequest   request    =    new    ( wrapped ,     \" part \"  )  ;", "byte [  ]    result    =    FileCopyUtils . copyToByteArray ( request . getBody (  )  )  ;", "assertArrayEquals ( bytes ,    result )  ;", "}", "METHOD_END"], "methodName": ["getBodyWithWrappedRequest"], "fileName": "org.springframework.web.multipart.support.RequestPartServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "MultipartFile   part    =    new   MockMultipartFile (  \" part \"  ,     \"  \"  ,     \" application / json \"  ,     \" content \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "this . mockRequest . addFile ( part )  ;", "ServerHttpRequest   request    =    new    ( this . mockRequest ,     \" part \"  )  ;", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "assertNotNull ( headers )  ;", "assertEquals ( MediaType . APPLICATION _ JSON ,    headers . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.web.multipart.support.RequestPartServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . mockRequest . addFile ( new   MockMultipartFile (  \" part \"  ,     \"  \"  ,     \"  \"  ,     \" content \"  . getBytes (  \" UTF -  8  \"  )  )  )  ;", "ServerHttpRequest   request    =    new    ( this . mockRequest ,     \" part \"  )  ;", "this . mockRequest . setMethod (  \" POST \"  )  ;", "assertEquals ( HttpMethod . POST ,    request . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.web.multipart.support.RequestPartServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . mockRequest . addFile ( new   MockMultipartFile (  \" part \"  ,     \"  \"  ,     \" application / json \"  ,     \" content \"  . getBytes (  \" UTF -  8  \"  )  )  )  ;", "ServerHttpRequest   request    =    new    ( this . mockRequest ,     \" part \"  )  ;", "URI   uri    =    new   URI (  \" http :  /  / example . com / path ? query \"  )  ;", "this . mockRequest . setServerName ( uri . getHost (  )  )  ;", "this . mockRequest . setServerPort ( uri . getPort (  )  )  ;", "this . mockRequest . setRequestURI ( uri . getPath (  )  )  ;", "this . mockRequest . setQueryString ( uri . getQuery (  )  )  ;", "assertEquals ( uri ,    request . getURI (  )  )  ;", "}", "METHOD_END"], "methodName": ["getURI"], "fileName": "org.springframework.web.multipart.support.RequestPartServletServerHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    ex . getMessage (  )  ;", "if    (  (  ( msg    !  =    null )     &  &     ( msg . contains (  \" size \"  )  )  )     &  &     ( msg . contains (  \" exceed \"  )  )  )     {", "throw   new   MaxUploadSizeExceededException (  (  -  1  )  ,    ex )  ;", "}", "throw   new   MultipartException (  \" Failed   to   parse      servlet   request \"  ,    ex )  ;", "}", "METHOD_END"], "methodName": ["handleParseFailure"], "fileName": "org.springframework.web.multipart.support.StandardMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "try    {", "Collection < Part >    parts    =    request . getParts (  )  ;", "this . multipartParameterNames    =    new   LinkedHashSet ( parts . size (  )  )  ;", "MultiValueMap < String ,    MultipartFile >    files    =    new   LinkedMultiValueMap ( parts . size (  )  )  ;", "for    ( Part   part    :    parts )     {", "String   headerValue    =    part . getHeader ( HttpHeaders . CONTENT _ DISPOSITION )  ;", "ContentDisposition   disposition    =    ContentDisposition . parse ( headerValue )  ;", "String   filename    =    disposition . getFilename (  )  ;", "if    ( filename    !  =    null )     {", "if    (  ( filename . startsWith (  \"  =  ?  \"  )  )     &  &     ( filename . endsWith (  \"  ?  =  \"  )  )  )     {", "filename    =     . MimeDelegate . decode ( filename )  ;", "}", "files . add ( part . getName (  )  ,    new    . StandardMultipartFile ( part ,    filename )  )  ;", "} else    {", "this . multipartParameterNames . add ( part . getName (  )  )  ;", "}", "}", "setMultipartFiles ( files )  ;", "}    catch    ( Throwable   ex )     {", "handleParseFailure ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["parseRequest"], "fileName": "org.springframework.web.multipart.support.StandardMultipartHttpServletRequest"}, {"methodBody": ["METHOD_START", "{", "StandardMultipartHttpServletRequest   request    =    getRequest (  \" file \"  ,     \" form - data ;    name =  \\  \" file \\  \"  ;    filename =  \\  \" myFile . txt \\  \"  \"  )  ;", "MultipartFile   multipartFile    =    request . getFile (  \" file \"  )  ;", "assertNotNull ( multipartFile )  ;", "assertEquals (  \" myFile . txt \"  ,    multipartFile . getOriginalFilename (  )  )  ;", "}", "METHOD_END"], "methodName": ["filename"], "fileName": "org.springframework.web.multipart.support.StandardMultipartHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "StandardMultipartHttpServletRequest   request    =    getRequest (  \" file \"  ,     \" form - data ;    name =  \\  \" file \\  \"  ;    filename =  \\  \"  =  ? UTF -  8  ? Q ? Declara = C 3  = A 7  = C 3  = A 3 o . pdf ?  =  \\  \"  \"  )  ;", "MultipartFile   multipartFile    =    request . getFile (  \" file \"  )  ;", "assertNotNull ( multipartFile )  ;", "assertEquals (  \" Declara ?  ? o . pdf \"  ,    multipartFile . getOriginalFilename (  )  )  ;", "}", "METHOD_END"], "methodName": ["filenameRfc2047"], "fileName": "org.springframework.web.multipart.support.StandardMultipartHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "StandardMultipartHttpServletRequest   request    =    getRequest (  \" file \"  ,     \" form - data ;    name =  \\  \" file \\  \"  ;    filename *  =  \\  \" UTF -  8  \\  '  \\  ' foo -  % c 3  % a 4  -  % e 2  %  8  2  % ac . html \\  \"  \"  )  ;", "MultipartFile   multipartFile    =    request . getFile (  \" file \"  )  ;", "assertNotNull ( multipartFile )  ;", "assertEquals (  \" foo -  ?  -  \u00a2\u00e3  . html \"  ,    multipartFile . getOriginalFilename (  )  )  ;", "}", "METHOD_END"], "methodName": ["filenameRfc5987"], "fileName": "org.springframework.web.multipart.support.StandardMultipartHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "MockPart   part    =    new   MockPart ( name ,    null )  ;", "part . getHeaders (  )  . set (  \" Content - Disposition \"  ,    dispositionValue )  ;", "request . addPart ( part )  ;", "return   new    ( request )  ;", "}", "METHOD_END"], "methodName": ["getRequest"], "fileName": "org.springframework.web.multipart.support.StandardMultipartHttpServletRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . resolveLazily    =    resolveLazily ;", "}", "METHOD_END"], "methodName": ["setResolveLazily"], "fileName": "org.springframework.web.multipart.support.StandardServletMultipartResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . supportedMediaTypes ;", "}", "METHOD_END"], "methodName": ["getSupportedMediaTypes"], "fileName": "org.springframework.web.server.MediaTypeNotSupportedStatusException"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getHttpMethod"], "fileName": "org.springframework.web.server.MethodNotAllowedException"}, {"methodBody": ["METHOD_START", "{", "return   supportedMethods ;", "}", "METHOD_END"], "methodName": ["getSupportedMethods"], "fileName": "org.springframework.web.server.MethodNotAllowedException"}, {"methodBody": ["METHOD_START", "{", "return   this . supportedMediaTypes ;", "}", "METHOD_END"], "methodName": ["getSupportedMediaTypes"], "fileName": "org.springframework.web.server.NotAcceptableStatusException"}, {"methodBody": ["METHOD_START", "{", "return   this . reason ;", "}", "METHOD_END"], "methodName": ["getReason"], "fileName": "org.springframework.web.server.ResponseStatusException"}, {"methodBody": ["METHOD_START", "{", "return   this . status ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.springframework.web.server.ResponseStatusException"}, {"methodBody": ["METHOD_START", "{", "return   this . handlerMethod ;", "}", "METHOD_END"], "methodName": ["getHandlerMethod"], "fileName": "org.springframework.web.server.ServerErrorException"}, {"methodBody": ["METHOD_START", "{", "return   this . parameter ;", "}", "METHOD_END"], "methodName": ["getMethodParameter"], "fileName": "org.springframework.web.server.ServerErrorException"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( getAttributes (  )  . get ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.springframework.web.server.ServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( getAttributes (  )  . getOrDefault ( name ,    defaultValue )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeOrDefault"], "fileName": "org.springframework.web.server.ServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "T   value    =    getAttribute ( name )  ;", "Assert . notNull ( value ,     (  (  \" Required   attribute    '  \"     +    name )     +     \"  '    is   missing .  \"  )  )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["getRequiredAttribute"], "fileName": "org.springframework.web.server.ServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServerWebExchangeBuilder ( this )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.springframework.web.server.ServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.web.server.ServerWebExchangeDecorator"}, {"methodBody": ["METHOD_START", "{", "return   this . parameter ;", "}", "METHOD_END"], "methodName": ["getMethodParameter"], "fileName": "org.springframework.web.server.ServerWebInputException"}, {"methodBody": ["METHOD_START", "{", "return   this . contentType ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.web.server.UnsupportedMediaTypeStatusException"}, {"methodBody": ["METHOD_START", "{", "return   this . supportedMediaTypes ;", "}", "METHOD_END"], "methodName": ["getSupportedMediaTypes"], "fileName": "org.springframework.web.server.UnsupportedMediaTypeStatusException"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( getAttributes (  )  . get ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.springframework.web.server.WebSession"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( getAttributes (  )  . getOrDefault ( name ,    defaultValue )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeOrDefault"], "fileName": "org.springframework.web.server.WebSession"}, {"methodBody": ["METHOD_START", "{", "T   value    =    getAttribute ( name )  ;", "Assert . notNull ( value ,     (  (  \" Required   attribute    '  \"     +    name )     +     \"  '    is   missing .  \"  )  )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["getRequiredAttribute"], "fileName": "org.springframework.web.server.WebSession"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "Class <  ?  >  [  ]    configClasses    =    getConfigClasses (  )  ;", "Assert . notEmpty ( configClasses ,     \" No   S   configuration   provided   through   getConfigClasses (  )  \"  )  ;", "context . register ( configClasses )  ;", "return   context ;", "}", "METHOD_END"], "methodName": ["createApplicationContext"], "fileName": "org.springframework.web.server.adapter.AbstractReactiveWebInitializer"}, {"methodBody": ["METHOD_START", "{", "return    \"  /  \"  ;", "}", "METHOD_END"], "methodName": ["getServletMapping"], "fileName": "org.springframework.web.server.adapter.AbstractReactiveWebInitializer"}, {"methodBody": ["METHOD_START", "{", "return   AbstractReactiveWebInitializer . DEFAULT _ SERVLET _ NAME ;", "}", "METHOD_END"], "methodName": ["getServletName"], "fileName": "org.springframework.web.server.adapter.AbstractReactiveWebInitializer"}, {"methodBody": ["METHOD_START", "{", "if    ( context   instanceof   ConfigurableApplicationContext )     {", "ConfigurableApplicationContext   cac    =     (  ( ConfigurableApplicationContext )     ( context )  )  ;", "if    (  !  ( cac . isA (  )  )  )     {", "cac . refresh (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["refreshApplicationContext"], "fileName": "org.springframework.web.server.adapter.AbstractReactiveWebInitializer"}, {"methodBody": ["METHOD_START", "{", "if    ( applicationContext   instanceof   ConfigurableApplicationContext )     {", "ConfigurableApplicationContext   cac    =     (  ( ConfigurableApplicationContext )     ( applicationContext )  )  ;", ". ServletContextDestroyedListener   listener    =    new    . ServletContextDestroyedListener ( cac )  ;", "servletContext . addListener ( listener )  ;", "}", "}", "METHOD_END"], "methodName": ["registerCloseListener"], "fileName": "org.springframework.web.server.adapter.AbstractReactiveWebInitializer"}, {"methodBody": ["METHOD_START", "{", "return   getRequest (  )  . getHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["getRequestHeaders"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "return   getResponse (  )  . getHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["getResponseHeaders"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "try    {", "MediaType   contentType    =    request . getHeaders (  )  . getContentType (  )  ;", "if    ( MediaType . APPLICATION _ FORM _ URLENCODED . isCompatibleWith ( contentType )  )     {", "return    (  ( HttpMessageReader < MultiValueMap < String ,    String >  >  )     ( configurer . getReaders (  )  . stream (  )  . filter (  (    reader )     -  >    reader . canRead (  . FORM _ DATA _ TYPE ,    MediaType . APPLICATION _ FORM _ URLENCODED )  )  . findFirst (  )  . orElseThrow (  (  )     -  >    new   IllegalStateException (  \" No   form   data   HttpMessageReader .  \"  )  )  )  )  . readMono (  . FORM _ DATA _ TYPE ,    request ,    Collections . emptyMap (  )  )  . switchIfEmpty (  . EMPTY _ FORM _ DATA )  . cache (  )  ;", "}", "}    catch    ( InvalidMediaTypeException   ex )     {", "}", "return    . EMPTY _ FORM _ DATA ;", "}", "METHOD_END"], "methodName": ["initFormData"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "try    {", "MediaType   contentType    =    request . getHeaders (  )  . getContentType (  )  ;", "if    ( MediaType . MULTIPART _ FORM _ DATA . isCompatibleWith ( contentType )  )     {", "return    (  ( HttpMessageReader < MultiValueMap < String ,    Part >  >  )     ( configurer . getReaders (  )  . stream (  )  . filter (  (    reader )     -  >    reader . canRead (  . MULTIPART _ DATA _ TYPE ,    MediaType . MULTIPART _ FORM _ DATA )  )  . findFirst (  )  . orElseThrow (  (  )     -  >    new   IllegalStateException (  \" No   multipart   HttpMessageReader .  \"  )  )  )  )  . readMono (  . MULTIPART _ DATA _ TYPE ,    request ,    Collections . emptyMap (  )  )  . switchIfEmpty (  . EMPTY _ MULTIPART _ DATA )  . cache (  )  ;", "}", "}    catch    ( InvalidMediaTypeException   ex )     {", "}", "return    . EMPTY _ MULTIPART _ DATA ;", "}", "METHOD_END"], "methodName": ["initMultipartData"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( etag )  )  )     {", "return   etag ;", "}", "if    (  (  ( etag . startsWith (  \"  \\  \"  \"  )  )     |  |     ( etag . startsWith (  \" W /  \\  \"  \"  )  )  )     &  &     ( etag . endsWith (  \"  \\  \"  \"  )  )  )     {", "return   etag ;", "}", "return    (  \"  \\  \"  \"     +    etag )     +     \"  \\  \"  \"  ;", "}", "METHOD_END"], "methodName": ["padEtagIfNecessary"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "if    ( lastModified . isBefore ( Instant . EPOCH )  )     {", "return   false ;", "}", "long   ifModifiedSince    =    getRequestHeaders (  )  . getIfModifiedSince (  )  ;", "if    ( ifModifiedSince    =  =     (  -  1  )  )     {", "return   false ;", "}", "this . notModified    =     ( ChronoUnit . SECONDS . between ( lastModified ,    Instant . ofEpochMilli ( ifModifiedSince )  )  )     >  =     0  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["validateIfModifiedSince"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( etag )  )  )     {", "return   false ;", "}", "List < String >    ifNoneMatch ;", "try    {", "ifNoneMatch    =    getRequestHeaders (  )  . getIfNoneMatch (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "return   false ;", "}", "if    ( ifNoneMatch . isEmpty (  )  )     {", "return   false ;", "}", "etag    =    padEtagIfNecessary ( etag )  ;", "for    ( String   clientETag    :    ifNoneMatch )     {", "if    (  ( StringUtils . hasLength ( clientETag )  )     &  &     ( clientETag . replaceFirst (  \"  ^ W /  \"  ,     \"  \"  )  . equals ( etag . replaceFirst (  \"  ^ W /  \"  ,     \"  \"  )  )  )  )     {", "this . notModified    =    true ;", "break ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["validateIfNoneMatch"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "if    ( lastModified . isBefore ( Instant . EPOCH )  )     {", "return   false ;", "}", "long   ifUnmodifiedSince    =    getRequestHeaders (  )  . getIfUnmodifiedSince (  )  ;", "if    ( ifUnmodifiedSince    =  =     (  -  1  )  )     {", "return   false ;", "}", "Instant   sinceInstant    =    Instant . ofEpochMilli ( ifUnmodifiedSince )  ;", "this . notModified    =    sinceInstant . isBefore ( lastModified . truncatedTo ( ChronoUnit . SECONDS )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["validateIfUnmodifiedSince"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchange"}, {"methodBody": ["METHOD_START", "{", "String   currentETag    =     \"  \\  \" Foo \\  \"  \"  ;", "String   oldEtag    =     \" Bar \"  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( oldEtag )  )  ;", "assertFalse ( exchange . checkNotModified ( currentETag )  )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( currentETag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedETag"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   currentETag    =     \"  \\  \" Foo \\  \"  \"  ;", "String   oldEtag    =     \"  \\  \" Bar \\  \"  \"  ;", "long   time    =    currentDate . toEpochMilli (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( oldEtag )  . ifModifiedSince ( time )  . build (  )  ;", "Mock   exchange    =    Mock . from ( request )  ;", "assertFalse ( exchange . checkNotModified ( currentETag ,    currentDate )  )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( currentETag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "assertEquals ( time ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedETagAndNotModifiedTimestamp"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "Instant   oneMinuteAgo    =    currentDate . minusSeconds (  6  0  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . ifModifiedSince ( oneMinuteAgo . toEpochMilli (  )  )  . build (  )  ;", "Mock   exchange    =    Mock . from ( request )  ;", "assertFalse ( exchange . checkNotModified ( currentDate )  )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( currentDate . toEpochMilli (  )  ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedTimestamp"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "long   epochTime    =    dateFormat . parse ( DefaultServerWebExchangeCheckNotModifiedTests . CURRENT _ TIME )  . getTime (  )  ;", "String   header    =     \" Tue ,     0  8    Apr    2  0  1  4     0  9  :  5  7  :  4  2    GMT ;    length =  1  3  7  7  4  \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" If - Modified - Since \"  ,    header )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertFalse ( exchange . checkNotModified ( Instant . ofEpochMilli ( epochTime )  )  )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( epochTime ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedTimestampWithLengthPart"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   currentETag    =     \" Foo \"  ;", "String   oldEtag    =     \" Bar \"  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( oldEtag )  )  ;", "assertFalse ( exchange . checkNotModified ( currentETag )  )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( String . format (  \"  \\  \"  % s \\  \"  \"  ,    currentETag )  ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkModifiedUnpaddedETag"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" Foo \\  \"  \"  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( eTag )  )  ;", "assertTrue ( exchange . checkNotModified ( eTag )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( eTag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETag"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" Foo \\  \"  \"  ;", "Instant   oneMinuteAgo    =    currentDate . minusSeconds (  6  0  )  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( eTag )  . ifModifiedSince ( oneMinuteAgo . toEpochMilli (  )  )  )  ;", "assertTrue ( exchange . checkNotModified ( eTag ,    currentDate )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( eTag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "assertEquals ( currentDate . toEpochMilli (  )  ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagAndModifiedTimestamp"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" Foo \\  \"  \"  ;", "long   time    =    currentDate . toEpochMilli (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( eTag )  . ifModifiedSince ( time )  . build (  )  ;", "Mock   exchange    =    Mock . from ( request )  ;", "assertTrue ( exchange . checkNotModified ( eTag ,    currentDate )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( eTag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "assertEquals ( time ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagAndTimestamp"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" Foo \\  \"  \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( String . format (  \" W /  % s \"  ,    eTag )  )  . build (  )  ;", "Mock   exchange    =    Mock . from ( request )  ;", "assertTrue ( exchange . checkNotModified ( eTag )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( eTag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagStrongWeak"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" Foo \\  \"  \"  ;", "String   weakEtag    =    String . format (  \" W /  % s \"  ,    eTag )  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( eTag )  )  ;", "assertTrue ( exchange . checkNotModified ( weakEtag )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( weakEtag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagWeakStrong"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" Foo ,    Bar \\  \"  \"  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( eTag )  )  ;", "assertTrue ( exchange . checkNotModified ( eTag )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( eTag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedETagWithSeparatorChars"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . ifModifiedSince ( currentDate . toEpochMilli (  )  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "exchange . getResponse (  )  . getHeaders (  )  . add (  \" Last - Modified \"  ,     . CURRENT _ TIME )  ;", "assertTrue ( exchange . checkNotModified ( currentDate )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get (  \" Last - Modified \"  )  . size (  )  )  ;", "assertEquals (  . CURRENT _ TIME ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Last - Modified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedHeaderAlreadySet"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" etagvalue \\  \"  \"  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch (  \" missingquotes \"  )  )  ;", "assertFalse ( exchange . checkNotModified ( eTag )  )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( eTag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedInvalidIfNoneMatchHeader"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" Bar \\  \"  \"  ;", "String   multipleETags    =    String . format (  \"  \\  \" Foo \\  \"  ,     % s \"  ,    eTag )  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( multipleETags )  )  ;", "assertTrue ( exchange . checkNotModified ( eTag )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( eTag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedMultipleETags"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . ifModifiedSince ( this . currentDate . toEpochMilli (  )  )  . build (  )  ;", "Mock   exchange    =    Mock . from ( request )  ;", "exchange . getResponse (  )  . setStatusCode ( HttpStatus . NOT _ MODIFIED )  ;", "assertFalse ( exchange . checkNotModified ( this . currentDate )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals (  (  -  1  )  ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedNon2xxStatus"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . ifModifiedSince ( currentDate . toEpochMilli (  )  )  . build (  )  ;", "Mock   exchange    =    Mock . from ( request )  ;", "assertTrue ( exchange . checkNotModified ( currentDate )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( currentDate . toEpochMilli (  )  ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedTimestamp"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "Instant   oneMinuteAgo    =    currentDate . minusSeconds (  6  0  )  ;", "long   millis    =    currentDate . toEpochMilli (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . put (  \"  /  \"  )  . ifUnmodifiedSince ( millis )  . build (  )  ;", "Mock   exchange    =    Mock . from ( request )  ;", "assertFalse ( exchange . checkNotModified ( oneMinuteAgo )  )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  (  -  1  )  ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedTimestampConditionalPut"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "Instant   oneMinuteAgo    =    currentDate . minusSeconds (  6  0  )  ;", "long   millis    =    oneMinuteAgo . toEpochMilli (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . put (  \"  /  \"  )  . ifUnmodifiedSince ( millis )  . build (  )  ;", "Mock   exchange    =    Mock . from ( request )  ;", "assertTrue ( exchange . checkNotModified ( currentDate )  )  ;", "assertEquals (  4  1  2  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals (  (  -  1  )  ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedTimestampConditionalPutConflict"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "long   epochTime    =    dateFormat . parse ( DefaultServerWebExchangeCheckNotModifiedTests . CURRENT _ TIME )  . getTime (  )  ;", "String   header    =     \" Wed ,     0  9    Apr    2  0  1  4     0  9  :  5  7  :  4  2    GMT ;    length =  1  3  7  7  4  \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" If - Modified - Since \"  ,    header )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertTrue ( exchange . checkNotModified ( Instant . ofEpochMilli ( epochTime )  )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( epochTime ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedTimestampWithLengthPart"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \" Foo \"  ;", "String   paddedEtag    =    String . format (  \"  \\  \"  % s \\  \"  \"  ,    eTag )  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch ( paddedEtag )  )  ;", "assertTrue ( exchange . checkNotModified ( eTag )  )  ;", "assertEquals (  3  0  4  ,    exchange . getResponse (  )  . getStatusCode (  )  . value (  )  )  ;", "assertEquals ( paddedEtag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedUnpaddedETag"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" Foo \\  \"  \"  ;", "Mock   exchange    =    Mock . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifNoneMatch (  \"  *  \"  )  )  ;", "assertFalse ( exchange . checkNotModified ( eTag )  )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( eTag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkNotModifiedWildcardIsIgnored"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( new   Object [  ]  [  ]  {    new   Object [  ]  {    HttpMethod . GET    }  ,    new   Object [  ]  {    HttpMethod . HEAD    }     }  )  ;", "}", "METHOD_END"], "methodName": ["safeMethods"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "this . currentDate    =    Instant . now (  )  . truncatedTo ( ChronoUnit . SECONDS )  ;", "this . dateFormat    =    new   SimpleDateFormat (  \" EEE ,    dd   MMM   yyyy   HH : mm : ss   z \"  ,    Locale . US )  ;", "this . dateFormat . setTimeZone ( TimeZone . getTimeZone (  \" GMT \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeCheckNotModifiedTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . build (  )  ;", "return   create ( request )  ;", "}", "METHOD_END"], "methodName": ["createExchange"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServerWebExchange ( request ,    new   MockServerHttpResponse (  )  ,    new   DefaultWebSessionManager (  )  ,    ServerCodecConfigurer . create (  )  ,    new   AcceptHeaderLocaleContextResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["createExchange"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    createExchange (  )  ;", "assertEquals (  \"  / foo \"  ,    exchange . transformUrl (  \"  / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["transformUrlDefault"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    createExchange (  )  ;", "exchange . addUrlTransformer (  (    s )     -  >    s    +     \"  ? nonce =  1  2  3  \"  )  ;", "assertEquals (  \"  / foo ? nonce =  1  2  3  \"  ,    exchange . transformUrl (  \"  / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["transformUrlWithEncoder"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    createExchange (  )  ;", "exchange . addUrlTransformer (  (    s )     -  >    s    +     \"  ; p = abc \"  )  ;", "exchange . addUrlTransformer (  (    s )     -  >    s    +     \"  ? q =  1  2  3  \"  )  ;", "assertEquals (  \"  / foo ; p = abc ? q =  1  2  3  \"  ,    exchange . transformUrl (  \"  / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["transformUrlWithMultipleEncoders"], "fileName": "org.springframework.web.server.adapter.DefaultServerWebExchangeTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServerWebExchange ( request ,    response ,    this . sessionManager ,    getCodecConfigurer (  )  ,    getLocaleContextResolver (  )  ,    this . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["createExchange"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . codecConfigurer )     !  =    null    ?    this . codecConfigurer    :    ServerCodecConfigurer . create (  )  ;", "}", "METHOD_END"], "methodName": ["getCodecConfigurer"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . localeContextResolver )     !  =    null    ?    this . localeContextResolver    :    new   AcceptHeaderLocaleContextResolver (  )  ;", "}", "METHOD_END"], "methodName": ["getLocaleContextResolver"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionManager ;", "}", "METHOD_END"], "methodName": ["getSessionManager"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    ( isDisconnectedClientError ( ex )  )     {", "if    (  . disconnectedClientLogger . isTraceEnabled (  )  )     {", ". disconnectedClientLogger . trace (  \" Looks   like   the   client   has   gone   away \"  ,    ex )  ;", "} else", "if    (  . disconnectedClientLogger . isDebugEnabled (  )  )     {", ". disconnectedClientLogger . debug (  (  (  (  (  \" Looks   like   the   client   has   gone   away :     \"     +    ex )     +     \"     ( For   a   full   stack   trace ,    set   the   log   category    '  \"  )     +     (  . DISCONNECTED _ CLIENT _ LOG _ CATEGORY )  )     +     \"  '    to   TRACE   level .  )  \"  )  )  ;", "}", "return   Mono . empty (  )  ;", "}", "if    ( response . setStatusCode ( HttpStatus . INTERNAL _ SERVER _ ERROR )  )     {", ". logger . error (  (  (  (  (  \" Failed   to   handle   request    [  \"     +     ( request . getMethod (  )  )  )     +     \"     \"  )     +     ( request . getURI (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "return   Mono . empty (  )  ;", "}", "HttpStatus   status    =    response . getStatusCode (  )  ;", ". logger . error (  (  (  (  (  \" Unhandled   failure :     \"     +     ( ex . getMessage (  )  )  )     +     \"  ,    response   already   set    ( status =  \"  )     +    status )     +     \"  )  \"  )  )  ;", "return   Mono . error ( ex )  ;", "}", "METHOD_END"], "methodName": ["handleFailure"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "String   message    =    NestedExceptionUtils . getMostSpecificCause ( ex )  . getMessage (  )  ;", "message    =     ( message    !  =    null )     ?    message . toLowerCase (  )     :     \"  \"  ;", "String   className    =    ex . getClass (  )  . getSimpleName (  )  ;", "return    ( message . contains (  \" broken   pipe \"  )  )     |  |     (  . DISCONNECTED _ CLIENT _ EXCEPTIONS . contains ( className )  )  ;", "}", "METHOD_END"], "methodName": ["isDisconnectedClientError"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . applicationContext    =    applicationContext ;", "}", "METHOD_END"], "methodName": ["setApplicationContext"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( codecConfigurer ,     \" ServerCodecConfigurer   must   not   be   null \"  )  ;", "this . codecConfigurer    =    codecConfigurer ;", "}", "METHOD_END"], "methodName": ["setCodecConfigurer"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . localeContextResolver    =    localeContextResolver ;", "}", "METHOD_END"], "methodName": ["setLocaleContextResolver"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( sessionManager ,     \" WebSessionManager   must   not   be   null \"  )  ;", "this . sessionManager    =    sessionManager ;", "}", "METHOD_END"], "methodName": ["setSessionManager"], "fileName": "org.springframework.web.server.adapter.HttpWebHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "WebHttpHandlerBuilder   builder    =    new   WebHttpHandlerBuilder ( context . getBean ( WebHttpHandlerBuilder . WEB _ HANDLER _ BEAN _ NAME ,    WebHandler . class )  ,    context )  ;", "WebHttpHandlerBuilder . SortedBeanContainer   container    =    new   WebHttpHandlerBuilder . SortedBeanContainer (  )  ;", "context . getAutowireCapableBeanFactory (  )  . autowireBean ( container )  ;", "builder . filters (  (    filters )     -  >    filters . addAll ( container . getFilters (  )  )  )  ;", "builder . exceptionHandlers (  (    handlers )     -  >    handlers . addAll ( container . getExceptionHandlers (  )  )  )  ;", "try    {", "builder . sessionManager ( context . getBean ( WebHttpHandlerBuilder . WEB _ SESSION _ MANAGER _ BEAN _ NAME ,    WebSessionManager . class )  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "try    {", "builder . codecConfigurer ( context . getBean ( WebHttpHandlerBuilder . SERVER _ CODEC _ CONFIGURER _ BEAN _ NAME ,    ServerCodecConfigurer . class )  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "try    {", "builder . localeContextResolver ( context . getBean ( WebHttpHandlerBuilder . LOCALE _ CONTEXT _ RESOLVER _ BEAN _ NAME ,    LocaleContextResolver . class )  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "return   builder ;", "}", "METHOD_END"], "methodName": ["applicationContext"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "WebHandler   decorated ;", "decorated    =    new   FilteringWebHandler ( this . webHandler ,    this . filters )  ;", "decorated    =    new   ExceptionHandlingWebHandler ( decorated ,    this . exceptionHandlers )  ;", "HttpWebHandlerAdapter   adapted    =    new   HttpWebHandlerAdapter ( decorated )  ;", "if    (  ( this . sessionManager )     !  =    null )     {", "adapted . setSessionManager ( this . sessionManager )  ;", "}", "if    (  ( this . codecConfigurer )     !  =    null )     {", "adapted . setCodecConfigurer ( this . codecConfigurer )  ;", "}", "if    (  ( this . localeContextResolver )     !  =    null )     {", "adapted . setLocaleContextResolver ( this . localeContextResolver )  ;", "}", "if    (  ( this . applicationContext )     !  =    null )     {", "adapted . setApplicationContext ( this . applicationContext )  ;", "}", "return   adapted ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "this . codecConfigurer    =    codecConfigurer ;", "return   this ;", "}", "METHOD_END"], "methodName": ["codecConfigurer"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . isEmpty ( handlers )  )  )     {", "this . exceptions . addAll ( Arrays . asList ( handlers )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["exceptionHandler"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "consumer . accept ( this . exceptionHandlers )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exceptionHandlers"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . isEmpty ( filters )  )  )     {", "this . filters . addAll ( Arrays . asList ( filters )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "consumer . accept ( this . filters )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["filters"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "this . localeContextResolver    =    localeContextResolver ;", "return   this ;", "}", "METHOD_END"], "methodName": ["localeContextResolver"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "this . sessionManager    =    manager ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sessionManager"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   WebHttpHandlerBuilder ( webHandler )  ;", "}", "METHOD_END"], "methodName": ["webHandler"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilder"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . NoFilterConfig . class )  ;", "context . refresh (  )  ;", "HttpHandler   httpHandler    =    WebHttpHandlerBuilder . applicationContext ( context )  . build (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "httpHandler . handle ( request ,    response )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" handled \"  ,    response . getBodyAsString (  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["configWithoutFilters"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . OrderedExceptionHandlerBeanConfig . class )  ;", "context . refresh (  )  ;", "HttpHandler   httpHandler    =    WebHttpHandlerBuilder . applicationContext ( context )  . build (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "httpHandler . handle ( request ,    response )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" ExceptionHandlerB \"  ,    response . getBodyAsString (  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["orderedWebExceptionHandlerBeans"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . OrderedWebFilterBeanConfig . class )  ;", "context . refresh (  )  ;", "HttpHandler   httpHandler    =    WebHttpHandlerBuilder . applicationContext ( context )  . build (  )  ;", "assertTrue (  ( httpHandler   instanceof   HttpWebHandlerAdapter )  )  ;", "assertSame ( context ,     (  ( HttpWebHandlerAdapter )     ( httpHandler )  )  . getApplicationContext (  )  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "httpHandler . handle ( request ,    response )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" FilterB :  : FilterA \"  ,    response . getBodyAsString (  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["orderedWebFilterBeans"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilderTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    value . getBytes ( StandardCharsets . UTF _  8  )  ;", "DataBuffer   buffer    =    new   DefaultDataBufferFactory (  )  . wrap ( bytes )  ;", "return   exchange . getResponse (  )  . writeWith ( Flux . just ( buffer )  )  ;", "}", "METHOD_END"], "methodName": ["writeToResponse"], "fileName": "org.springframework.web.server.adapter.WebHttpHandlerBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   this . filters ;", "}", "METHOD_END"], "methodName": ["getFilters"], "fileName": "org.springframework.web.server.handler.DefaultWebFilterChain"}, {"methodBody": ["METHOD_START", "{", "return   this . handler ;", "}", "METHOD_END"], "methodName": ["getHandler"], "fileName": "org.springframework.web.server.handler.DefaultWebFilterChain"}, {"methodBody": ["METHOD_START", "{", "return   this . exceptionHandlers ;", "}", "METHOD_END"], "methodName": ["getExceptionHandlers"], "fileName": "org.springframework.web.server.handler.ExceptionHandlingWebHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ExceptionHandlingWebHandler ( this . targetHandler ,    Arrays . asList ( handlers )  )  ;", "}", "METHOD_END"], "methodName": ["createWebHandler"], "fileName": "org.springframework.web.server.handler.ExceptionHandlingWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "createWebHandler ( new   ExceptionHandlingWebHandlerTests . BadRequestExceptionHandler (  )  )  . handle ( this . exchange )  . block (  )  ;", "assertEquals ( HttpStatus . BAD _ REQUEST ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleErrorSignal"], "fileName": "org.springframework.web.server.handler.ExceptionHandlingWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "createWebHandler ( new   ExceptionHandlingWebHandlerTests . UnresolvedExceptionHandler (  )  ,    new   ExceptionHandlingWebHandlerTests . UnresolvedExceptionHandler (  )  ,    new   ExceptionHandlingWebHandlerTests . BadRequestExceptionHandler (  )  ,    new   ExceptionHandlingWebHandlerTests . UnresolvedExceptionHandler (  )  )  . handle ( this . exchange )  . block (  )  ;", "assertEquals ( HttpStatus . BAD _ REQUEST ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleErrorSignalWithMultipleHttpErrorHandlers"], "fileName": "org.springframework.web.server.handler.ExceptionHandlingWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "createWebHandler ( new   ExceptionHandlingWebHandlerTests . BadRequestExceptionHandler (  )  )  . handle ( this . exchange )  . block (  )  ;", "assertEquals ( HttpStatus . BAD _ REQUEST ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["thrownExceptionBecomesErrorSignal"], "fileName": "org.springframework.web.server.handler.ExceptionHandlingWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Void >    mono    =    createWebHandler ( new   ExceptionHandlingWebHandlerTests . UnresolvedExceptionHandler (  )  )  . handle ( this . exchange )  ;", "StepVerifier . create ( mono )  . expectErrorMessage (  \" boo \"  )  . verify (  )  ;", "assertNull ( this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["unresolvedException"], "fileName": "org.springframework.web.server.handler.ExceptionHandlingWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "new   HttpWebHandlerAdapter ( createWebHandler ( new   ExceptionHandlingWebHandlerTests . UnresolvedExceptionHandler (  )  )  )  . handle ( this . exchange . getRequest (  )  ,    this . exchange . getResponse (  )  )  . block (  )  ;", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["unresolvedExceptionWithWebHttpHandlerAdapter"], "fileName": "org.springframework.web.server.handler.ExceptionHandlingWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( this . filters )  ;", "}", "METHOD_END"], "methodName": ["getFilters"], "fileName": "org.springframework.web.server.handler.FilteringWebHandler"}, {"methodBody": ["METHOD_START", "{", "FilteringWebHandlerTests . AsyncFilter   filter    =    new   FilteringWebHandlerTests . AsyncFilter (  )  ;", "FilteringWebHandlerTests . StubWebHandler   targetHandler    =    new   FilteringWebHandlerTests . StubWebHandler (  )  ;", "new   FilteringWebHandler ( targetHandler ,    Collections . singletonList ( filter )  )  . handle ( MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertTrue ( filter . invoked (  )  )  ;", "assertTrue ( targetHandler . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncFilter"], "fileName": "org.springframework.web.server.handler.FilteringWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", ". TestExceptionHandler   exceptionHandler    =    new    . TestExceptionHandler (  )  ;", "WebHttpHandlerBuilder . webHandler ( new    . StubWebHandler (  )  )  . filter ( new    . ExceptionFilter (  )  )  . exceptionHandler ( exceptionHandler )  . build (  )  . handle ( request ,    response )  . block (  )  ;", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    response . getStatusCode (  )  )  ;", "assertNotNull ( exceptionHandler . ex )  ;", "assertEquals (  \" boo \"  ,    exceptionHandler . ex . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleErrorFromFilter"], "fileName": "org.springframework.web.server.handler.FilteringWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "FilteringWebHandlerTests . TestFilter   filter 1     =    new   FilteringWebHandlerTests . TestFilter (  )  ;", "FilteringWebHandlerTests . TestFilter   filter 2     =    new   FilteringWebHandlerTests . TestFilter (  )  ;", "FilteringWebHandlerTests . TestFilter   filter 3     =    new   FilteringWebHandlerTests . TestFilter (  )  ;", "FilteringWebHandlerTests . StubWebHandler   targetHandler    =    new   FilteringWebHandlerTests . StubWebHandler (  )  ;", "new   FilteringWebHandler ( targetHandler ,    Arrays . asList ( filter 1  ,    filter 2  ,    filter 3  )  )  . handle ( MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  . block ( Duration . ZERO )  ;", "assertTrue ( filter 1  . invoked (  )  )  ;", "assertTrue ( filter 2  . invoked (  )  )  ;", "assertTrue ( filter 3  . invoked (  )  )  ;", "assertTrue ( targetHandler . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleFilters"], "fileName": "org.springframework.web.server.handler.FilteringWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "FilteringWebHandlerTests . TestFilter   filter 1     =    new   FilteringWebHandlerTests . TestFilter (  )  ;", "FilteringWebHandlerTests . ShortcircuitingFilter   filter 2     =    new   FilteringWebHandlerTests . ShortcircuitingFilter (  )  ;", "FilteringWebHandlerTests . TestFilter   filter 3     =    new   FilteringWebHandlerTests . TestFilter (  )  ;", "FilteringWebHandlerTests . StubWebHandler   targetHandler    =    new   FilteringWebHandlerTests . StubWebHandler (  )  ;", "new   FilteringWebHandler ( targetHandler ,    Arrays . asList ( filter 1  ,    filter 2  ,    filter 3  )  )  . handle ( MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  . block ( Duration . ZERO )  ;", "assertTrue ( filter 1  . invoked (  )  )  ;", "assertTrue ( filter 2  . invoked (  )  )  ;", "assertFalse ( filter 3  . invoked (  )  )  ;", "assertFalse ( targetHandler . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["shortcircuitFilter"], "fileName": "org.springframework.web.server.handler.FilteringWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "FilteringWebHandlerTests . StubWebHandler   targetHandler    =    new   FilteringWebHandlerTests . StubWebHandler (  )  ;", "new   FilteringWebHandler ( targetHandler ,    Collections . emptyList (  )  )  . handle ( MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  . block ( Duration . ZERO )  ;", "assertTrue ( targetHandler . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["zeroFilters"], "fileName": "org.springframework.web.server.handler.FilteringWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  \" Failed   to   handle   request    [  \"     +     ( request . getMethod (  )  )  )     +     \"     \"  )     +     ( request . getURI (  )  )  )     +     \"  ]  :     \"  )     +     ( ex . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildMessage"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   ResponseStatusException )     {", "return    (  ( ResponseStatusException )     ( ex )  )  . getStatus (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["determineStatus"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   status    =    determineStatus ( ex )  ;", "if    ( status    =  =    null )     {", "Throwable   cause    =    ex . getCause (  )  ;", "if    ( cause    !  =    null )     {", "status    =    resolveStatus ( cause )  ;", "}", "}", "return   status ;", "}", "METHOD_END"], "methodName": ["resolveStatus"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ResponseStatusExceptionHandler (  )  ;", "}", "METHOD_END"], "methodName": ["createResponseStatusExceptionHandler"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   ex    =    new   Exception ( new   ResponseStatusException ( HttpStatus . BAD _ REQUEST ,     \"  \"  )  )  ;", "this . handler . handle ( this . exchange ,    ex )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( HttpStatus . BAD _ REQUEST ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleNestedResponseStatusException"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   ex    =    new   ResponseStatusException ( HttpStatus . BAD _ REQUEST ,     \"  \"  )  ;", "this . handler . handle ( this . exchange ,    ex )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( HttpStatus . BAD _ REQUEST ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleResponseStatusException"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   ex    =    new   ResponseStatusException ( HttpStatus . INTERNAL _ SERVER _ ERROR ,     \" Oops \"  )  ;", "this . exchange . getResponse (  )  . setStatusCode ( HttpStatus . CREATED )  ;", "Mono < Void >    mono    =    this . exchange . getResponse (  )  . setComplete (  )  . then ( Mono . defer (  (  )     -  >    this . handler . handle ( this . exchange ,    ex )  )  )  ;", "StepVerifier . create ( mono )  . consumeErrorWith (  (    actual )     -  >    assertSame ( ex ,    actual )  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["responseCommitted"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler    =    createResponseStatusExceptionHandler (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   expected    =    new   IllegalStateException (  )  ;", "Mono < Void >    mono    =    this . handler . handle ( this . exchange ,    expected )  ;", "StepVerifier . create ( mono )  . consumeErrorWith (  (    actual )     -  >    assertSame ( expected ,    actual )  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["unresolvedException"], "fileName": "org.springframework.web.server.handler.ResponseStatusExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.web.server.handler.WebHandlerDecorator"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultLocale ;", "}", "METHOD_END"], "methodName": ["getDefaultLocale"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . supportedLocales ;", "}", "METHOD_END"], "methodName": ["getSupportedLocales"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( requestLocales )  )     {", "return   this . defaultLocale ;", "}", "List < Locale >    supportedLocales    =    getSupportedLocales (  )  ;", "if    ( supportedLocales . isEmpty (  )  )     {", "return   requestLocales . get (  0  )  ;", "}", "Locale   languageMatch    =    null ;", "for    ( Locale   locale    :    requestLocales )     {", "if    ( supportedLocales . contains ( locale )  )     {", "if    (  ( languageMatch    =  =    null )     |  |     ( languageMatch . getLanguage (  )  . equals ( locale . getLanguage (  )  )  )  )     {", "return   locale ;", "}", "} else", "if    ( languageMatch    =  =    null )     {", "for    ( Locale   candidate    :    supportedLocales )     {", "if    (  (  !  ( util . StringUtils . hasLength ( candidate . getCountry (  )  )  )  )     &  &     ( candidate . getLanguage (  )  . equals ( locale . getLanguage (  )  )  )  )     {", "languageMatch    =    candidate ;", "break ;", "}", "}", "}", "}", "if    ( languageMatch    !  =    null )     {", "return   languageMatch ;", "}", "return    ( this . defaultLocale )     !  =    null    ?    this . defaultLocale    :    requestLocales . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["resolveSupportedLocale"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolver"}, {"methodBody": ["METHOD_START", "{", "this . defaultLocale    =    defaultLocale ;", "}", "METHOD_END"], "methodName": ["setDefaultLocale"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolver"}, {"methodBody": ["METHOD_START", "{", "this . supportedLocales . clear (  )  ;", "this . supportedLocales . addAll ( locales )  ;", "}", "METHOD_END"], "methodName": ["setSupportedLocales"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolver"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setDefaultLocale ( Locale . JAPANESE )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertEquals ( Locale . JAPANESE ,    this . resolver . resolve ( exchange )  . getLocale (  )  )  ;", "request    =    MockServerHttpRequest . get (  \"  /  \"  )  . acceptLanguageAsLocales ( Locale . US )  . build (  )  ;", "exchange    =    MockServerWebExchange . from ( request )  ;", "assertEquals ( Locale . US ,    this . resolver . resolve ( exchange )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultLocale"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  . acceptLanguageAsLocales ( locales )  )  ;", "}", "METHOD_END"], "methodName": ["exchange"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Locale . CANADA ,    this . resolver . resolveLocaleContext ( exchange ( Locale . CANADA )  )  . getLocale (  )  )  ;", "assertEquals ( Locale . US ,    this . resolver . resolveLocaleContext ( exchange ( Locale . US ,    Locale . CANADA )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header ( HttpHeaders . ACCEPT _ LANGUAGE ,     \"  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertNull ( this . resolver . resolve ( exchange )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveEmptyAcceptLanguageHeader"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setDefaultLocale ( Locale . US )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header ( HttpHeaders . ACCEPT _ LANGUAGE ,     \"  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertEquals ( Locale . US ,    this . resolver . resolve ( exchange )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveEmptyAcceptLanguageHeaderWithDefault"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header ( HttpHeaders . ACCEPT _ LANGUAGE ,     \" en _ US \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertNull ( this . resolver . resolve ( exchange )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveInvalidAcceptLanguageHeader"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setDefaultLocale ( Locale . US )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header ( HttpHeaders . ACCEPT _ LANGUAGE ,     \" en _ US \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertEquals ( Locale . US ,    this . resolver . resolve ( exchange )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveInvalidAcceptLanguageHeaderWithDefault"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertNull ( this . resolver . resolve ( exchange )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMissingAcceptLanguageHeader"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setDefaultLocale ( Locale . US )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "assertEquals ( Locale . US ,    this . resolver . resolve ( exchange )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMissingAcceptLanguageHeaderWithDefault"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setSupportedLocales ( Arrays . asList ( Locale . ENGLISH ,    Locale . UK )  )  ;", "assertEquals ( Locale . UK ,    this . resolver . resolve ( exchange ( Locale . GERMANY ,    Locale . US ,    Locale . UK )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePreferredAgainstCountryIfPossible"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setSupportedLocales ( Collections . singletonList ( Locale . ENGLISH )  )  ;", "assertEquals ( Locale . ENGLISH ,    this . resolver . resolve ( exchange ( Locale . GERMANY ,    Locale . US ,    Locale . UK )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePreferredAgainstLanguageOnly"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setSupportedLocales ( Arrays . asList ( Locale . GERMAN ,    Locale . US )  )  ;", "assertEquals ( Locale . GERMAN ,    this . resolver . resolve ( exchange ( Locale . GERMANY ,    Locale . US ,    Locale . UK )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePreferredAgainstLanguageWithMultipleSupportedLocales"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setSupportedLocales ( Collections . singletonList ( Locale . CANADA )  )  ;", "assertEquals ( Locale . US ,    this . resolver . resolve ( exchange ( Locale . US ,    Locale . UK )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePreferredNotSupported"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setSupportedLocales ( Arrays . asList ( Locale . US ,    Locale . JAPAN )  )  ;", "this . resolver . setDefaultLocale ( Locale . JAPAN )  ;", "assertEquals ( Locale . JAPAN ,    this . resolver . resolve ( exchange ( Locale . KOREA )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePreferredNotSupportedWithDefault"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setSupportedLocales ( Collections . singletonList ( Locale . CANADA )  )  ;", "assertEquals ( Locale . CANADA ,    this . resolver . resolve ( exchange ( Locale . US ,    Locale . CANADA )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePreferredSupported"], "fileName": "org.springframework.web.server.i18n.AcceptHeaderLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  . acceptLanguageAsLocales ( locales )  )  ;", "}", "METHOD_END"], "methodName": ["exchange"], "fileName": "org.springframework.web.server.i18n.FixedLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "TimeZone   timeZone    =    TimeZone . getTimeZone ( ZoneId . of (  \" UTC \"  )  )  ;", "resolver    =    new    ( Locale . FRANCE ,    timeZone )  ;", "TimeZoneAwareLocaleContext   context    =     (  ( TimeZoneAwareLocaleContext )     ( resolver . resolveLocaleContext ( exchange (  )  )  )  )  ;", "assertEquals ( Locale . FRANCE ,    context . getLocale (  )  )  ;", "assertEquals ( timeZone ,    context . getTimeZone (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveCustomizedAndTimeZoneLocale"], "fileName": "org.springframework.web.server.i18n.FixedLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "FixedLocaleContextResolver   resolver    =    new   FixedLocaleContextResolver ( Locale . FRANCE )  ;", "assertEquals ( Locale . FRANCE ,    resolver . resolveLocaleContext ( exchange (  )  )  . getLocale (  )  )  ;", "assertEquals ( Locale . FRANCE ,    resolver . resolveLocaleContext ( exchange ( Locale . CANADA )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveCustomizedLocale"], "fileName": "org.springframework.web.server.i18n.FixedLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "FixedLocaleContextResolver   resolver    =    new   FixedLocaleContextResolver (  )  ;", "assertEquals ( Locale . US ,    resolver . resolveLocaleContext ( exchange (  )  )  . getLocale (  )  )  ;", "assertEquals ( Locale . US ,    resolver . resolveLocaleContext ( exchange ( Locale . CANADA )  )  . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultLocale"], "fileName": "org.springframework.web.server.i18n.FixedLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "Locale . setDefault ( Locale . US )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.server.i18n.FixedLocaleContextResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . cookieMaxAge ;", "}", "METHOD_END"], "methodName": ["getCookieMaxAge"], "fileName": "org.springframework.web.server.session.CookieWebSessionIdResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . cookieName ;", "}", "METHOD_END"], "methodName": ["getCookieName"], "fileName": "org.springframework.web.server.session.CookieWebSessionIdResolver"}, {"methodBody": ["METHOD_START", "{", "this . cookieMaxAge    =    maxAge ;", "}", "METHOD_END"], "methodName": ["setCookieMaxAge"], "fileName": "org.springframework.web.server.session.CookieWebSessionIdResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( cookieName ,     \"  ' cookieName '    must   not   be   empty \"  )  ;", "this . cookieName    =    cookieName ;", "}", "METHOD_END"], "methodName": ["setCookieName"], "fileName": "org.springframework.web.server.session.CookieWebSessionIdResolver"}, {"methodBody": ["METHOD_START", "{", "String   name    =    getCookieName (  )  ;", "boolean   secure    =     \" https \"  . equalsIgnoreCase ( exchange . getRequest (  )  . getURI (  )  . getScheme (  )  )  ;", "String   path    =     ( exchange . getRequest (  )  . getPath (  )  . contextPath (  )  . value (  )  )     +     \"  /  \"  ;", "exchange . getResponse (  )  . getCookies (  )  . set ( name ,    ResponseCookie . from ( name ,    id )  . path ( path )  . maxAge ( maxAge )  . httpOnly ( true )  . secure ( secure )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["setSessionCookie"], "fileName": "org.springframework.web.server.session.CookieWebSessionIdResolver"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" https :  /  / example . org / path \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "this . resolver . set ( exchange ,     \"  1  2  3  \"  )  ;", "MultiValueMap < String ,    ResponseCookie >    cookies    =    exchange . getResponse (  )  . getCookies (  )  ;", "assertEquals (  1  ,    cookies . size (  )  )  ;", "ResponseCookie   cookie    =    cookies . getFirst ( this . resolver . getCookieName (  )  )  ;", "assertNotNull ( cookie )  ;", "assertEquals (  \" SESSION =  1  2  3  ;    Path =  /  ;    Secure ;    HttpOnly \"  ,    cookie . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["setSessionId"], "fileName": "org.springframework.web.server.session.CookieWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionIdResolver ;", "}", "METHOD_END"], "methodName": ["getSessionIdResolver"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionStore ;", "}", "METHOD_END"], "methodName": ["getSessionStore"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManager"}, {"methodBody": ["METHOD_START", "{", "return   Flux . fromIterable ( getSessionIdResolver (  )  . resolveSessionIds ( exchange )  )  . concatMap ( this . sessionStore :  : retrieveSession )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["retrieveSession"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManager"}, {"methodBody": ["METHOD_START", "{", "List < String >    ids    =    getSessionIdResolver (  )  . resolveSessionIds ( exchange )  ;", "if    (  (  !  ( isStarted (  )  )  )     |  |     ( isExpired (  )  )  )     {", "if    (  !  ( ids . isEmpty (  )  )  )     {", "this . dResolver . expireSession ( exchange )  ;", "}", "return   Mono . empty (  )  ;", "}", "if    (  ( ids . isEmpty (  )  )     |  |     (  !  ( getId (  )  . equals ( ids . get (  0  )  )  )  )  )     {", "this . dResolver . setSessionId ( exchange ,    getId (  )  )  ;", "}", "return   save (  )  ;", "}", "METHOD_END"], "methodName": ["save"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( sessionIdResolver ,     \" WebSessionIdResolver   is   required \"  )  ;", "this . sessionIdResolver    =    sessionIdResolver ;", "}", "METHOD_END"], "methodName": ["setSessionIdResolver"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( sessionStore ,     \" WebSessionStore   is   required \"  )  ;", "this . sessionStore    =    sessionStore ;", "}", "METHOD_END"], "methodName": ["setSessionStore"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManager"}, {"methodBody": ["METHOD_START", "{", "when ( this . idResolver . resolveSessionIds ( this . exchange )  )  . thenReturn ( Collections . emptyList (  )  )  ;", "String   id    =    this . createSession . getId (  )  ;", "session    =    this . manager . getSession ( this . exchange )  . block (  )  ;", "when ( this . createSession . isStarted (  )  )  . thenReturn ( true )  ;", "this . exchange . getResponse (  )  . setComplete (  )  . block (  )  ;", "verify ( this . idResolver )  . setSessionId ( any (  )  ,    eq ( id )  )  ;", "verify ( this . createSession )  . save (  )  ;", "}", "METHOD_END"], "methodName": ["exchangeWhenResponseSetCompleteThenSavesAndSetsId"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManagerTests"}, {"methodBody": ["METHOD_START", "{", "String   id    =    this . updateSession . getId (  )  ;", "when ( this . store . retrieveSession ( id )  )  . thenReturn ( Mono . just ( this . updateSession )  )  ;", "when ( this . idResolver . resolveSessionIds ( this . exchange )  )  . thenReturn ( Collections . singletonList ( id )  )  ;", "actual    =    this . manager . getSession ( this . exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertEquals ( id ,    actual . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["existingSession"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManagerTests"}, {"methodBody": ["METHOD_START", "{", "when ( this . idResolver . resolveSessionIds ( this . exchange )  )  . thenReturn ( Collections . emptyList (  )  )  ;", "session    =    this . manager . getSession ( this . exchange )  . block (  )  ;", "this . exchange . getResponse (  )  . setComplete (  )  . block (  )  ;", "assertFalse ( session . isStarted (  )  )  ;", "assertFalse ( session . isExpired (  )  )  ;", "verify ( this . createSession ,    never (  )  )  . save (  )  ;", "verify ( this . idResolver ,    never (  )  )  . setSessionId ( any (  )  ,    any (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionSaveWhenCreatedAndNotStartedThenNotSaved"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManagerTests"}, {"methodBody": ["METHOD_START", "{", "when ( this . idResolver . resolveSessionIds ( this . exchange )  )  . thenReturn ( Collections . emptyList (  )  )  ;", "session    =    this . manager . getSession ( this . exchange )  . block (  )  ;", "when ( this . createSession . isStarted (  )  )  . thenReturn ( true )  ;", "this . exchange . getResponse (  )  . setComplete (  )  . block (  )  ;", "String   id    =    session . getId (  )  ;", "verify ( this . store )  . create (  )  ;", "verify ( this . createSession )  . save (  )  ;", "verify ( this . idResolver )  . setSessionId ( any (  )  ,    eq ( id )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionSaveWhenCreatedAndStartedThenSavesAndSetsId"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManagerTests"}, {"methodBody": ["METHOD_START", "{", "WebSession   existing    =    this . updateSession ;", "String   id    =    existing . getId (  )  ;", "when ( this . store . retrieveSession ( any (  )  )  )  . thenReturn ( Mono . empty (  )  )  ;", "when ( this . store . retrieveSession ( id )  )  . thenReturn ( Mono . just ( existing )  )  ;", "when ( this . idResolver . resolveSessionIds ( this . exchange )  )  . thenReturn ( Arrays . asList (  \" neither - this \"  ,     \" nor - that \"  ,    id )  )  ;", "WebSession   actual    =    this . manager . getSession ( this . exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertEquals ( existing . getId (  )  ,    actual . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleSessionIds"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManagerTests"}, {"methodBody": ["METHOD_START", "{", "when ( this . store . createWebSession (  )  )  . thenReturn ( Mono . just ( this . createSession )  )  ;", "when ( this . createSession . save (  )  )  . thenReturn ( Mono . empty (  )  )  ;", "when ( this . updateSession . getId (  )  )  . thenReturn (  \" update - session - id \"  )  ;", "this . manager    =    new    (  )  ;", "this . manager . setSessionIdResolver ( this . idResolver )  ;", "this . manager . setSessionStore ( this . store )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / path \"  )  . build (  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "this . exchange    =    new   DefaultServerWebExchange ( request ,    response ,    this . manager ,    ServerCodecConfigurer . create (  )  ,    new   AcceptHeaderLocaleContextResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.server.session.DefaultWebSessionManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . headerName ;", "}", "METHOD_END"], "methodName": ["getHeaderName"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( headerName ,     \"  ' headerName '    must   not   be   empty \"  )  ;", "this . headerName    =    headerName ;", "}", "METHOD_END"], "methodName": ["setHeaderName"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolver"}, {"methodBody": ["METHOD_START", "{", "this . idResolver . setSessionId ( this . exchange ,     \"  1  2  3  \"  )  ;", "this . idResolver . expireSession ( this . exchange )  ;", "assertEquals ( Arrays . asList (  \"  \"  )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . get (  . DEFAULT _ HEADER _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["expireWhenAfterSetSessionIdThenSetsEmptyHeader"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . idResolver . expireSession ( this . exchange )  ;", "this . idResolver . expireSession ( this . exchange )  ;", "assertEquals ( Arrays . asList (  \"  \"  )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . get (  . DEFAULT _ HEADER _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["expireWhenMultipleInvocationThenSetsSingleEmptyHeader"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . idResolver . expireSession ( this . exchange )  ;", "assertEquals ( Arrays . asList (  \"  \"  )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . get (  . DEFAULT _ HEADER _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["expireWhenValidThenSetsEmptyHeader"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \"  1  2  3  \"  ;", "this . exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path \"  )  . header (  . DEFAULT _ HEADER _ NAME ,    id )  )  ;", "List < String >    ids    =    this . idResolver . resolveSessionIds ( this . exchange )  ;", "assertEquals ( Arrays . asList ( id )  ,    ids )  ;", "}", "METHOD_END"], "methodName": ["resolveSessionIdsWhenIdThenIdFound"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   id 1     =     \"  1  2  3  \"  ;", "String   id 2     =     \" abc \"  ;", "this . exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path \"  )  . header (  . DEFAULT _ HEADER _ NAME ,    id 1  ,    id 2  )  )  ;", "List < String >    ids    =    this . idResolver . resolveSessionIds ( this . exchange )  ;", "assertEquals ( Arrays . asList ( id 1  ,    id 2  )  ,    ids )  ;", "}", "METHOD_END"], "methodName": ["resolveSessionIdsWhenMultipleIdsThenIdsFound"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    ids    =    this . idResolver . resolveSessionIds ( this . exchange )  ;", "assertTrue ( ids . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveSessionIdsWhenNoIdsThenEmpty"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =     \" x - auth \"  ;", "String   id    =     \"  1  2  3  \"  ;", "this . i . setHeaderName ( headerName )  ;", "this . i . setSessionId ( this . exchange ,    id )  ;", "assertEquals ( Arrays . asList ( id )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . get ( headerName )  )  ;", "}", "METHOD_END"], "methodName": ["setSessionIdWhenCustomHeaderNameThenSetsHeader"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \"  1  2  3  \"  ;", "this . idResolver . setSessionId ( this . exchange ,     \" overriddenByNextInvocation \"  )  ;", "this . idResolver . setSessionId ( this . exchange ,    id )  ;", "assertEquals ( Arrays . asList ( id )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . get (  . DEFAULT _ HEADER _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["setSessionIdWhenMultipleThenSetsSingleHeader"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   id    =    null ;", "this . i . setSessionId ( this . exchange ,    id )  ;", "}", "METHOD_END"], "methodName": ["setSessionIdWhenNullIdThenIllegalArgumentException"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \"  1  2  3  \"  ;", "this . idResolver . setSessionId ( this . exchange ,    id )  ;", "assertEquals ( Arrays . asList ( id )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . get (  . DEFAULT _ HEADER _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["setSessionIdWhenValidThenSetsHeader"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . idResolver    =    new   HeaderWebSessionIdResolver (  )  ;", "this . exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.server.session.HeaderWebSessionIdResolverTests"}, {"methodBody": ["METHOD_START", "{", "if    ( this . expirationCheckLock . tryLock (  )  )     {", "try    {", "Iterator <  . InMemoryWebSession >    iterator    =    this . sessions . values (  )  . iterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", ". InMemoryWebSession   session    =    iterator . next (  )  ;", "if    ( session . isExpired ( currentTime )  )     {", "iterator . remove (  )  ;", "session . invalidate (  )  ;", "}", "}", "}    finally    {", "this . nextExpirationCheckTime    =    currentTime . plus (  . EXPIRATION _ CHECK _ PERIOD )  ;", "this . expirationCheckLock . unlock (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkExpiredSessions"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStore"}, {"methodBody": ["METHOD_START", "{", "return   this . clock ;", "}", "METHOD_END"], "methodName": ["getClock"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStore"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clock ,     \" Clock   is   required \"  )  ;", "this . clock    =    clock ;", "this . nextExpirationCheckTime    =    Instant . now ( this . clock )  ;", "}", "METHOD_END"], "methodName": ["setClock"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStore"}, {"methodBody": ["METHOD_START", "{", "return   Mono . fromSupplier (  (  )     -  >     {", "Assert . isInstanceOf (  . class ,    webSession )  ;", "session    =     (  (  )     ( webSession )  )  ;", "session . updateLastAccessTime ( Instant . now ( getClock (  )  )  )  ;", "return   session ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["updateLastAccessTime"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStore"}, {"methodBody": ["METHOD_START", "{", "WebSession   session 1     =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session 1  )  ;", "session 1  . start (  )  ;", "session 1  . save (  )  . block (  )  ;", "WebSession   session 2     =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session 2  )  ;", "session 2  . start (  )  ;", "session 2  . save (  )  . block (  )  ;", "WebSession   session 3     =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session 3  )  ;", "session 3  . start (  )  ;", "session 3  . save (  )  . block (  )  ;", "this . store . setClock ( Clock . offset ( this . store . getClock (  )  ,    Duration . ofMinutes (  3  1  )  )  )  ;", "WebSession   session 4     =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session 4  )  ;", "session 4  . start (  )  ;", "session 4  . save (  )  . block (  )  ;", "WebSession   session 5     =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session 5  )  ;", "session 5  . start (  )  ;", "session 5  . save (  )  . block (  )  ;", "assertNull ( this . store . retrieveSession ( session 1  . getId (  )  )  . block (  )  )  ;", "assertNull ( this . store . retrieveSession ( session 2  . getId (  )  )  . block (  )  )  ;", "assertNull ( this . store . retrieveSession ( session 3  . getId (  )  )  . block (  )  )  ;", "assertNotNull ( this . store . retrieveSession ( session 4  . getId (  )  )  . block (  )  )  ;", "assertNotNull ( this . store . retrieveSession ( session 5  . getId (  )  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["expirationChecks"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStoreTests"}, {"methodBody": ["METHOD_START", "{", "WebSession   session 1     =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session 1  )  ;", "String   id    =    session 1  . getId (  )  ;", "Instant   time 1     =    session 1  . getLastAccessTime (  )  ;", "session 1  . save (  )  . block (  )  ;", "this . store . setClock ( Clock . offset ( this . store . getClock (  )  ,    Duration . ofSeconds (  5  )  )  )  ;", "WebSession   session 2     =    this . store . retrieveSession ( id )  . block (  )  ;", "assertNotNull ( session 2  )  ;", "TestCase . assertSame ( session 1  ,    session 2  )  ;", "Instant   time 2     =    session 2  . getLastAccessTime (  )  ;", "assertTrue ( time 1  . isBefore ( time 2  )  )  ;", "}", "METHOD_END"], "methodName": ["lastAccessTimeIsUpdatedOnRetrieve"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStoreTests"}, {"methodBody": ["METHOD_START", "{", "WebSession   session    =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session )  ;", "session . getAttributes (  )  . put (  \" foo \"  ,     \" bar \"  )  ;", "session . save (  )  . block (  )  ;", "String   id    =    session . getId (  )  ;", "WebSession   retrieved    =    this . store . retrieveSession ( id )  . block (  )  ;", "assertNotNull ( retrieved )  ;", "TestCase . assertSame ( session ,    retrieved )  ;", "this . store . setClock ( Clock . offset ( this . store . getClock (  )  ,    Duration . ofMinutes (  3  1  )  )  )  ;", "WebSession   retrievedAgain    =    this . store . retrieveSession ( id )  . block (  )  ;", "assertNull ( retrievedAgain )  ;", "}", "METHOD_END"], "methodName": ["retrieveExpiredSession"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStoreTests"}, {"methodBody": ["METHOD_START", "{", "WebSession   session    =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session )  ;", "session . start (  )  ;", "assertTrue ( session . isStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["startsSessionExplicitly"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStoreTests"}, {"methodBody": ["METHOD_START", "{", "WebSession   session    =    this . store . createWebSession (  )  . block (  )  ;", "assertNotNull ( session )  ;", "session . start (  )  ;", "session . getAttributes (  )  . put (  \" foo \"  ,     \" bar \"  )  ;", "assertTrue ( session . isStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["startsSessionImplicitly"], "fileName": "org.springframework.web.server.session.InMemoryWebSessionStoreTests"}, {"methodBody": ["METHOD_START", "{", "RequestEntity < Void >    request    =    RequestEntity . get ( createUri (  )  )  . build (  )  ;", "ResponseEntity < Void >    response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "String   oldId    =    extractd ( response . getHeaders (  )  )  ;", "assertNotNull ( oldId )  ;", "assertEquals (  1  ,    this . handler . getSessionRequestCount (  )  )  ;", "URI   uri    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  /  ? changeId \"  )  )  ;", "request    =    RequestEntity . get ( uri )  . header (  \" Cookie \"  ,     (  \" SESSION =  \"     +    oldId )  )  . build (  )  ;", "response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "String   newId    =    extractd ( response . getHeaders (  )  )  ;", "assertNotNull (  \" Expected   new   session   id \"  ,    newId )  ;", "assertNotEquals ( oldId ,    newId )  ;", "assertEquals (  2  ,    this . handler . getSessionRequestCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["changeSessionId"], "fileName": "org.springframework.web.server.session.WebSessionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestEntity < Void >    request    =    RequestEntity . get ( createUri (  )  )  . build (  )  ;", "ResponseEntity < Void >    response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "String   id    =    extractd ( response . getHeaders (  )  )  ;", "assertNotNull ( id )  ;", "assertEquals (  1  ,    this . handler . getSessionRequestCount (  )  )  ;", "request    =    RequestEntity . get ( createUri (  )  )  . header (  \" Cookie \"  ,     (  \" SESSION =  \"     +    id )  )  . build (  )  ;", "response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "assertNull ( response . getHeaders (  )  . get (  \" Set - Cookie \"  )  )  ;", "assertEquals (  2  ,    this . handler . getSessionRequestCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.springframework.web.server.session.WebSessionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createUri"], "fileName": "org.springframework.web.server.session.WebSessionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestEntity < Void >    request    =    RequestEntity . get ( createUri (  )  )  . build (  )  ;", "ResponseEntity < Void >    response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "String   id    =    extractSessionId ( response . getHeaders (  )  )  ;", "assertNotNull ( id )  ;", "InMemoryStore   store    =     (  ( InMemoryStore )     ( this . sessionManager . getSessionStore (  )  )  )  ;", "store . setClock ( Clock . offset ( store . getClock (  )  ,    Duration . ofMinutes (  3  1  )  )  )  ;", "URI   uri    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  /  ? expire \"  )  )  ;", "request    =    RequestEntity . get ( uri )  . header (  \" Cookie \"  ,     (  \" SESSION =  \"     +    id )  )  . build (  )  ;", "response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "String   value    =    response . getHeaders (  )  . getFirst (  \" Set - Cookie \"  )  ;", "assertNotNull ( value )  ;", "assertTrue (  (  \" Actual   value :     \"     +    value )  ,    value . contains (  \" Max - Age =  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["expiredSessionEnds"], "fileName": "org.springframework.web.server.session.WebSessionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestEntity < Void >    request    =    RequestEntity . get ( createUri (  )  )  . build (  )  ;", "ResponseEntity < Void >    response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "String   id    =    extractSessionId ( response . getHeaders (  )  )  ;", "assertNotNull ( id )  ;", "assertEquals (  1  ,    this . handler . getSessionRequestCount (  )  )  ;", "request    =    RequestEntity . get ( createUri (  )  )  . header (  \" Cookie \"  ,     (  \" SESSION =  \"     +    id )  )  . build (  )  ;", "response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "assertNull ( response . getHeaders (  )  . get (  \" Set - Cookie \"  )  )  ;", "assertEquals (  2  ,    this . handler . getSessionRequestCount (  )  )  ;", "InMemoryStore   store    =     (  ( InMemoryStore )     ( this . sessionManager . getSessionStore (  )  )  )  ;", "session    =    store . retrieveSession ( id )  . block (  )  ;", "assertNotNull ( session )  ;", "store . setClock ( Clock . offset ( store . getClock (  )  ,    Duration . ofMinutes (  3  1  )  )  )  ;", "request    =    RequestEntity . get ( createUri (  )  )  . header (  \" Cookie \"  ,     (  \" SESSION =  \"     +    id )  )  . build (  )  ;", "response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "id    =    extractSessionId ( response . getHeaders (  )  )  ;", "assertNotNull (  \" Expected   new   session   id \"  ,    id )  ;", "assertEquals (  1  ,    this . handler . getSessionRequestCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["expiredSessionIsRecreated"], "fileName": "org.springframework.web.server.session.WebSessionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    headerValues    =    headers . get (  \" Set - Cookie \"  )  ;", "assertNotNull ( headerValues )  ;", "assertEquals (  1  ,    headerValues . size (  )  )  ;", "for    ( String   s    :    headerValues . get (  0  )  . split (  \"  ;  \"  )  )     {", "if    ( s . startsWith (  \" SESSION =  \"  )  )     {", "return   s . substring (  \" SESSION =  \"  . length (  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["extractSessionId"], "fileName": "org.springframework.web.server.session.WebSessionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestEntity < Void >    request    =    RequestEntity . get ( createUri (  )  )  . build (  )  ;", "ResponseEntity < Void >    response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "String   id    =    extractd ( response . getHeaders (  )  )  ;", "assertNotNull ( id )  ;", "URI   uri    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  /  ? invalidate \"  )  )  ;", "request    =    RequestEntity . get ( uri )  . header (  \" Cookie \"  ,     (  \" SESSION =  \"     +    id )  )  . build (  )  ;", "response    =    this . restTemplate . exchange ( request ,    Void . class )  ;", "assertEquals ( HttpStatus . OK ,    response . getStatusCode (  )  )  ;", "String   value    =    response . getHeaders (  )  . getFirst (  \" Set - Cookie \"  )  ;", "assertNotNull ( value )  ;", "assertTrue (  (  \" Actual   value :     \"     +    value )  ,    value . contains (  \" Max - Age =  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "org.springframework.web.server.session.WebSessionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . baseUrl ;", "}", "METHOD_END"], "methodName": ["getBaseUrl"], "fileName": "org.springframework.web.util.AbstractUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . defaultUriVariables )  ;", "}", "METHOD_END"], "methodName": ["getDefaultUriVariables"], "fileName": "org.springframework.web.util.AbstractUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "St   baseUrl    =    getBaseUrl (  )  ;", "if    (  ( baseUrl    !  =    null )     &  &     (  ( url . getHost (  )  )     =  =    null )  )     {", "url    =    new   URI (  ( baseUrl    +     ( url . toSt (  )  )  )  )  ;", "}", "return   url ;", "}    catch    ( URISyntaxException   ex )     {", "throw   new   IllegalArgumentException (  (  \" Invalid   URL   after   inserting   base   URL :     \"     +    url )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["insertBaseUrl"], "fileName": "org.springframework.web.util.AbstractUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( baseUrl    !  =    null )     {", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriSt ( baseUrl )  . build (  )  ;", "Assert . hasText ( uriComponents . getScheme (  )  ,     \"  ' baseUrl '    must   have   a   scheme \"  )  ;", "Assert . hasText ( uriComponents . getHost (  )  ,     \"  ' baseUrl '    must   have   a   host \"  )  ;", "Assert . isNull ( uriComponents . getQuery (  )  ,     \"  ' baseUrl '    cannot   have   a   query \"  )  ;", "Assert . isNull ( uriComponents . getFragment (  )  ,     \"  ' baseUrl '    cannot   have   a   fragment \"  )  ;", "}", "this . baseUrl    =    baseUrl ;", "}", "METHOD_END"], "methodName": ["setBaseUrl"], "fileName": "org.springframework.web.util.AbstractUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "this . defaultUriVariables . clear (  )  ;", "if    ( defaultUriVariables    !  =    null )     {", "this . defaultUriVariables . putAll ( defaultUriVariables )  ;", "}", "}", "METHOD_END"], "methodName": ["setDefaultUriVariables"], "fileName": "org.springframework.web.util.AbstractUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . cachedContent . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsByteArray"], "fileName": "org.springframework.web.util.ContentCachingRequestWrapper"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =    getContentType (  )  ;", "return    (  ( contentType    !  =    null )     &  &     ( contentType . contains (  . FORM _ CONTENT _ TYPE )  )  )     &  &     ( HttpMethod . POST . matches ( getMethod (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isFormPost"], "fileName": "org.springframework.web.util.ContentCachingRequestWrapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( this . cached . size (  )  )     =  =     0  )     {", "String   requestEncoding    =    getCharacterEncoding (  )  ;", "Map < String ,    String [  ]  >    form    =    super . getParameterMap (  )  ;", "for    ( Iterator < String >    nameIterator    =    form . keySet (  )  . iterator (  )  ;    nameIterator . hasNext (  )  ;  )     {", "String   name    =    nameIterator . next (  )  ;", "List < String >    values    =    Arrays . asList ( form . get ( name )  )  ;", "for    ( Iterator < String >    valueIterator    =    values . iterator (  )  ;    valueIterator . hasNext (  )  ;  )     {", "String   value    =    valueIterator . next (  )  ;", "this . cached . write ( URLEncoder . encode ( name ,    requestEncoding )  . getBytes (  )  )  ;", "if    ( value    !  =    null )     {", "this . cached . write (  '  =  '  )  ;", "this . cached . write ( URLEncoder . encode ( value ,    requestEncoding )  . getBytes (  )  )  ;", "if    ( valueIterator . hasNext (  )  )     {", "this . cached . write (  '  &  '  )  ;", "}", "}", "}", "if    ( nameIterator . hasNext (  )  )     {", "this . cached . write (  '  &  '  )  ;", "}", "}", "}", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   write   request   parameters   to   cached   content \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeRequestParametersToCachedContent"], "fileName": "org.springframework.web.util.ContentCachingRequestWrapper"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod (  \" GET \"  )  ;", "this . request . setCharacterEncoding (  . CHARSET )  ;", "this . request . setContent (  \" Hello   World \"  . getBytes (  . CHARSET )  )  ;", "ContentCachingRequestWrapper   wrapper    =    new   ContentCachingRequestWrapper ( this . request )  ;", "byte [  ]    response    =    FileCopyUtils . copyToByteArray ( wrapper . getInputStream (  )  )  ;", "assertArrayEquals ( response ,    wrapper . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["cachedContent"], "fileName": "org.springframework.web.util.ContentCachingRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod (  \" GET \"  )  ;", "this . request . setCharacterEncoding (  . CHARSET )  ;", "this . request . setContent (  \" Hello   World \"  . getBytes (  . CHARSET )  )  ;", "ContentCachingRequestWrapper   wrapper    =    new   ContentCachingRequestWrapper ( this . request ,     3  )  ;", "byte [  ]    response    =    FileCopyUtils . copyToByteArray ( wrapper . getInputStream (  )  )  ;", "assertArrayEquals (  \" Hello   World \"  . getBytes (  . CHARSET )  ,    response )  ;", "assertArrayEquals (  \" Hel \"  . getBytes (  . CHARSET )  ,    wrapper . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["cachedContentWithLimit"], "fileName": "org.springframework.web.util.ContentCachingRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod (  \" GET \"  )  ;", "this . request . setCharacterEncoding (  . CHARSET )  ;", "this . request . setContent (  \" Hello   World \"  . getBytes (  . CHARSET )  )  ;", "ContentCachingRequestWrapper   wrapper    =    new   ContentCachingRequestWrapper ( this . request ,     3  )     {", "@ Override", "protected   void   handleContentOverflow ( int   contentCacheLimit )     {", "throw   new   IllegalStateException ( String . valueOf ( contentCacheLimit )  )  ;", "}", "}  ;", "try    {", "FileCopyUtils . copyToByteArray ( wrapper . getInputStream (  )  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \"  3  \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cachedContentWithOverflow"], "fileName": "org.springframework.web.util.ContentCachingRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod (  \" POST \"  )  ;", "this . request . setContentType (  . FORM _ CONTENT _ TYPE )  ;", "this . request . setCharacterEncoding (  . CHARSET )  ;", "this . request . setParameter (  \" first \"  ,     \" value \"  )  ;", "this . request . setParameter (  \" second \"  ,     \" foo \"  ,     \" bar \"  )  ;", "ContentCachingRequestWrapper   wrapper    =    new   ContentCachingRequestWrapper ( this . request )  ;", "byte [  ]    response    =    FileCopyUtils . copyToByteArray ( wrapper . getInputStream (  )  )  ;", "assertArrayEquals ( response ,    wrapper . getContentAsByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["inputStreamFormPostRequest"], "fileName": "org.springframework.web.util.ContentCachingRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "this . request . setMethod (  \" POST \"  )  ;", "this . request . setContentType (  . FORM _ CONTENT _ TYPE )  ;", "this . request . setCharacterEncoding (  . CHARSET )  ;", "this . request . setParameter (  \" first \"  ,     \" value \"  )  ;", "this . request . setParameter (  \" second \"  ,     \" foo \"  ,     \" bar \"  )  ;", "ContentCachingRequestWrapper   wrapper    =    new   ContentCachingRequestWrapper ( this . request )  ;", "assertFalse ( wrapper . getParameterMap (  )  . isEmpty (  )  )  ;", "assertEquals (  \" first = value & second = foo & second = bar \"  ,    new   String ( wrapper . getContentAsByteArray (  )  )  )  ;", "assertEquals (  \"  \"  ,    new   String ( FileCopyUtils . copyToByteArray ( wrapper . getInputStream (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["requestParams"], "fileName": "org.springframework.web.util.ContentCachingRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "copyBodyToResponse ( true )  ;", "}", "METHOD_END"], "methodName": ["copyBodyToResponse"], "fileName": "org.springframework.web.util.ContentCachingResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . content . size (  )  )     >     0  )     {", "HttpServlet   raw    =     (  ( HttpServlet )     ( get (  )  )  )  ;", "if    (  ( complete    |  |     (  ( this . contentLength )     !  =    null )  )     &  &     (  !  ( raw . isCommitted (  )  )  )  )     {", "raw . setContentLength (  ( complete    ?    this . content . size (  )     :    this . contentLength )  )  ;", "this . contentLength    =    null ;", "}", "this . content . writeTo ( raw . getOutputStream (  )  )  ;", "this . content . reset (  )  ;", "if    ( complete )     {", "super . flushBuffer (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["copyBodyToResponse"], "fileName": "org.springframework.web.util.ContentCachingResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "return   this . content . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getContentAsByteArray"], "fileName": "org.springframework.web.util.ContentCachingResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "return   this . content . getInputStream (  )  ;", "}", "METHOD_END"], "methodName": ["getContentInputStream"], "fileName": "org.springframework.web.util.ContentCachingResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "return   this . content . size (  )  ;", "}", "METHOD_END"], "methodName": ["getContentSize"], "fileName": "org.springframework.web.util.ContentCachingResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "return   this . statusCode ;", "}", "METHOD_END"], "methodName": ["getStatusCode"], "fileName": "org.springframework.web.util.ContentCachingResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( len    >     ( Integer . MAX _ VALUE )  )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Content - Length   exceeds    ' s   maximum    (  \"     +     ( Integer . MAX _ VALUE )  )     +     \"  )  :     \"  )     +    len )  )  ;", "}", "int   lenInt    =     (  ( int )     ( len )  )  ;", "if    ( lenInt    >     ( this . content . size (  )  )  )     {", "this . content . resize ( lenInt )  ;", "}", "this . contentLength    =    lenInt ;", "}", "METHOD_END"], "methodName": ["setContentLengthLong"], "fileName": "org.springframework.web.util.ContentCachingResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( response ,     \" HttpServletResponse   must   not   be   null \"  )  ;", "cookie    =    create ( cookieValue )  ;", "Integer   maxAge    =    getMaxAge (  )  ;", "if    ( maxAge    !  =    null )     {", "cookie . setMaxAge ( maxAge )  ;", "}", "if    ( isSecure (  )  )     {", "cookie . setSecure ( true )  ;", "}", "if    ( isHttpOnly (  )  )     {", "cookie . setHttpOnly ( true )  ;", "}", "response . add ( cookie )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Added   cookie   with   name    [  \"     +     ( getName (  )  )  )     +     \"  ]    and   value    [  \"  )     +    cookieValue )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addCookie"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "Cookie   cookie    =    new   Cookie ( getCookieName (  )  ,    cookieValue )  ;", "if    (  ( getCookieDomain (  )  )     !  =    null )     {", "cookie . setDomain ( getCookieDomain (  )  )  ;", "}", "cookie . setPath ( getCookiePath (  )  )  ;", "return   cookie ;", "}", "METHOD_END"], "methodName": ["createCookie"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . cookieDomain ;", "}", "METHOD_END"], "methodName": ["getCookieDomain"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . cookieMaxAge ;", "}", "METHOD_END"], "methodName": ["getCookieMaxAge"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . cookieName ;", "}", "METHOD_END"], "methodName": ["getCookieName"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . cookiePath ;", "}", "METHOD_END"], "methodName": ["getCookiePath"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . cookieHttpOnly ;", "}", "METHOD_END"], "methodName": ["isCookieHttpOnly"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . cookieSecure ;", "}", "METHOD_END"], "methodName": ["isCookieSecure"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( response ,     \" HttpServletResponse   must   not   be   null \"  )  ;", "cookie    =    create (  \"  \"  )  ;", "cookie . setMaxAge (  0  )  ;", "if    ( isSecure (  )  )     {", "cookie . setSecure ( true )  ;", "}", "if    ( isHttpOnly (  )  )     {", "cookie . setHttpOnly ( true )  ;", "}", "response . add ( cookie )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Removed   cookie   with   name    [  \"     +     ( getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["removeCookie"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "this . cookieDomain    =    cookieDomain ;", "}", "METHOD_END"], "methodName": ["setCookieDomain"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "this . cookieHttpOnly    =    cookieHttpOnly ;", "}", "METHOD_END"], "methodName": ["setCookieHttpOnly"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "this . cookieMaxAge    =    cookieMaxAge ;", "}", "METHOD_END"], "methodName": ["setCookieMaxAge"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "this . cookieName    =    cookieName ;", "}", "METHOD_END"], "methodName": ["setCookieName"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "this . cookiePath    =    cookiePath ;", "}", "METHOD_END"], "methodName": ["setCookiePath"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "this . cookieSecure    =    cookieSecure ;", "}", "METHOD_END"], "methodName": ["setCookieSecure"], "fileName": "org.springframework.web.util.CookieGenerator"}, {"methodBody": ["METHOD_START", "{", "return   uriString ( uriTemplate )  . build ( uriVars )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "return   uriString ( uriTemplate )  . build ( uriVars )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . defaultUriVariables )  ;", "}", "METHOD_END"], "methodName": ["getDefaultUriVariables"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . encodingMode ;", "}", "METHOD_END"], "methodName": ["getEncodingMode"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "this . defaultUriVariables . clear (  )  ;", "if    ( defaultUriVariables    !  =    null )     {", "this . defaultUriVariables . putAll ( defaultUriVariables )  ;", "}", "}", "METHOD_END"], "methodName": ["setDefaultUriVariables"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "this . encodingMode    =    encodingMode ;", "}", "METHOD_END"], "methodName": ["setEncodingMode"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "this . parsePath    =    parsePath ;", "}", "METHOD_END"], "methodName": ["setParsePath"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . parsePath ;", "}", "METHOD_END"], "methodName": ["shouldParsePath"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultUriBuilderFactory . DefaultUriBuilder ( uriTemplate )  ;", "}", "METHOD_END"], "methodName": ["uriString"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  \" http :  /  / foo . com / v 1  ? id =  1  2  3  \"  )  ;", "URI   uri    =    factory . uriString (  \"  / bar \"  )  . port (  8  0  8  0  )  . build (  )  ;", "TestCase . assertEquals (  \" http :  /  / foo . com :  8  0  8  0  / v 1  / bar ? id =  1  2  3  \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["baseUri"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  \" http :  /  / foo . com / v 1  ? id =  1  2  3  \"  )  ;", "URI   uri    =    factory . uriString (  \" http :  /  / example . com /  1  /  2  \"  )  . build (  )  ;", "TestCase . assertEquals (  \" Use   of   host   should   case   baseUri   to   be   completely   ignored \"  ,     \" http :  /  / example . com /  1  /  2  \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["baseUriWithFullOverride"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  \" http :  /  / foo . com / v 1  \"  )  ;", "URI   uri    =    factory . builder (  )  . replacePath (  \"  / baz \"  )  . build (  )  ;", "TestCase . assertEquals (  \" http :  /  / foo . com / baz \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["baseUriWithPathOverride"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  )  ;", "URI   uri    =    factory . uriString (  \"  / foo \"  )  . pathSegment (  \"  { id }  \"  )  . build (  \" a / b \"  )  ;", "TestCase . assertEquals (  \"  / foo / a %  2 Fb \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultSettings"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  \" http :  /  /  { host }  / v 1  \"  )  ;", "factory . setDefaultUriVariables ( Collections . singletonMap (  \" host \"  ,     \" foo . com \"  )  )  ;", "URI   uri    =    factory . uriString (  \"  /  { id }  \"  )  . build ( Collections . singletonMap (  \" id \"  ,     \"  1  2  3  \"  )  )  ;", "TestCase . assertEquals (  \" http :  /  / foo . com / v 1  /  1  2  3  \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultUriVars"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    defaultUriVars    =    new   HashMap <  >  (  2  )  ;", "defaultUriVars . put (  \" host \"  ,     \" api . example . com \"  )  ;", "defaultUriVars . put (  \" port \"  ,     \"  4  4  3  \"  )  ;", "factory    =    new    (  )  ;", "factory . setDefaultUriVariables ( defaultUriVars )  ;", "URI   uri    =    factory . expand (  \" https :  /  /  { host }  :  { port }  / v 4  2  / customers /  { id }  \"  ,    Collections . singletonMap (  \" id \"  ,     1  2  3 L )  )  ;", "TestCase . assertEquals (  \" https :  /  / api . example . com :  4  4  3  / v 4  2  / customers /  1  2  3  \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultUriVarsSpr14147"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  \" http :  /  /  { host }  / v 1  \"  )  ;", "factory . setDefaultUriVariables ( Collections . singletonMap (  \" host \"  ,     \" foo . com \"  )  )  ;", "URI   uri    =    factory . uriString (  \"  / bar \"  )  . build (  )  ;", "TestCase . assertEquals (  \" Expected   delegation   to   build ( Map )    method \"  ,     \" http :  /  / foo . com / v 1  / bar \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultUriVarsWithEmptyVarArg"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  \" http :  /  /  { host }  / v 1  \"  )  ;", "factory . setDefaultUriVariables ( Collections . singletonMap (  \" host \"  ,     \" spring . io \"  )  )  ;", "URI   uri    =    factory . uriString (  \"  / bar \"  )  . build ( Collections . singletonMap (  \" host \"  ,     \" docs . spring . io \"  )  )  ;", "TestCase . assertEquals (  \" http :  /  / docs . spring . io / v 1  / bar \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultUriVarsWithOverride"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  )  ;", "factory . setEncodingMode ( DefaultUriBuilderFactory . EncodingMode . NONE )  ;", "UriBuilder   uriBuilder    =    factory . uriString (  \"  / foo / a %  2 Fb /  { id }  \"  )  ;", "String   id    =     \" c %  2 Fd \"  ;", "String   expected    =     \"  / foo / a %  2 Fb / c %  2 Fd \"  ;", "TestCase . assertEquals ( expected ,    uriBuilder . build ( id )  . toString (  )  )  ;", "TestCase . assertEquals ( expected ,    uriBuilder . build ( Collections . singletonMap (  \" id \"  ,    id )  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["encodingNone"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  )  ;", "factory . setEncodingMode ( DefaultUriBuilderFactory . EncodingMode . VALUES _ ONLY )  ;", "UriBuilder   uriBuilder    =    factory . uriString (  \"  / foo / a %  2 Fb /  { id }  \"  )  ;", "String   id    =     \" c / d \"  ;", "String   expected    =     \"  / foo / a %  2 Fb / c %  2 Fd \"  ;", "TestCase . assertEquals ( expected ,    uriBuilder . build ( id )  . toString (  )  )  ;", "TestCase . assertEquals ( expected ,    uriBuilder . build ( Collections . singletonMap (  \" id \"  ,    id )  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["encodingValuesOnly"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  )  ;", "factory . setEncodingMode ( DefaultUriBuilderFactory . EncodingMode . VALUES _ ONLY )  ;", "factory . setDefaultUriVariables ( Collections . singletonMap (  \" host \"  ,     \" www . example . com \"  )  )  ;", "UriBuilder   uriBuilder    =    factory . uriString (  \" http :  /  /  { host }  / user /  { userId }  / dashboard \"  )  ;", "TestCase . assertEquals (  \" http :  /  / www . example . com / user / john %  3 Bdoe / dashboard \"  ,    uriBuilder . build ( Collections . singletonMap (  \" userId \"  ,     \" john ; doe \"  )  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["encodingValuesOnlySpr14147"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  \"  / foo /  { bar }  \"  )  ;", "factory . setParsePath ( false )  ;", "URI   uri    =    factory . uriString (  \"  / baz /  { id }  \"  )  . build (  \" a / b \"  ,     \" c / d \"  )  ;", "TestCase . assertEquals (  \"  / foo / a / b / baz / c / d \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["parsePathIsTurnedOff"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  \"  / foo /  { bar }  \"  )  ;", "URI   uri    =    factory . uriString (  \"  / baz /  { id }  \"  )  . build (  \" a / b \"  ,     \" c / d \"  )  ;", "TestCase . assertEquals (  \"  / foo / a %  2 Fb / baz / c %  2 Fd \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["parsePathWithDefaultSettings"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  )  ;", "URI   uri    =    factory . expand (  \"  / foo /  /  /  /  /  /  /  /  / bar \"  )  ;", "TestCase . assertEquals (  \"  / foo / bar \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathWithDuplicateSlashes"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultUriBuilderFactory   factory    =    new   DefaultUriBuilderFactory (  )  ;", "URI   uri    =    factory . expand (  \" http :  /  / localhost :  8  0  8  0  / spring /  \"  )  ;", "TestCase . assertEquals (  \" http :  /  / localhost :  8  0  8  0  / spring /  \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathWithTrailingSlash"], "fileName": "org.springframework.web.util.DefaultUriBuilderFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   URI ( uriComponents . toUriSt (  )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "throw   new   IllegalStateException (  (  \" Could   not   create   URI   object :     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createUri"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isStrictEncoding (  )  )  )     {", "return   builder . buildAndExpand ( uriVariables )  . encode (  )  ;", "} else    {", "Object [  ]    encodedUriVars    =    UriUtils . encodeUriVariables ( uriVariables )  ;", "return   builder . buildAndExpand ( encodedUriVars )  ;", "}", "}", "METHOD_END"], "methodName": ["expandAndEncode"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isStrictEncoding (  )  )  )     {", "return   builder . buildAndExpand ( uriVariables )  . encode (  )  ;", "} else    {", "Map < St ,     ?  >    encodedUriVars    =    UriUtils . encodeUriVariables ( uriVariables )  ;", "return   builder . buildAndExpand ( encodedUriVars )  ;", "}", "}", "METHOD_END"], "methodName": ["expandAndEncode"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . fromUriString ( uriTemplate )  ;", "if    (  ( shouldParsePath (  )  )     &  &     (  !  ( isStrictEncoding (  )  )  )  )     {", "List < String >    pathSegments    =    builder . build (  )  . getPathSegments (  )  ;", "builder . replacePath ( null )  ;", "for    ( String   pathSegment    :    pathSegments )     {", "builder . pathSegment ( pathSegment )  ;", "}", "}", "return   builder ;", "}", "METHOD_END"], "methodName": ["initUriComponentsBuilder"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . strictEncoding ;", "}", "METHOD_END"], "methodName": ["isStrictEncoding"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "this . parsePath    =    parsePath ;", "}", "METHOD_END"], "methodName": ["setParsePath"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "this . strictEncoding    =    strictEncoding ;", "}", "METHOD_END"], "methodName": ["setStrictEncoding"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . parsePath ;", "}", "METHOD_END"], "methodName": ["shouldParsePath"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandler"}, {"methodBody": ["METHOD_START", "{", "this . handler . setBaseUrl (  \" http :  /  / localhost :  8  0  8  0  / context \"  )  ;", "URI   actual    =    this . handler . expand (  \"  / myapiresource \"  )  ;", "assertEquals (  \" http :  /  / localhost :  8  0  8  0  / context / myapiresource \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["baseUrlWithPath"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setBaseUrl (  \" http :  /  / localhost :  8  0  8  0  \"  )  ;", "URI   actual    =    this . handler . expand (  \"  / myapiresource \"  )  ;", "assertEquals (  \" http :  /  / localhost :  8  0  8  0  / myapiresource \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["baseUrlWithoutPath"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    defaultVars    =    new   HashMap <  >  (  2  )  ;", "defaultVars . put (  \" host \"  ,     \" api . example . com \"  )  ;", "defaultVars . put (  \" port \"  ,     \"  4  4  3  \"  )  ;", "this . handler . setVariables ( defaultVars )  ;", "Map < String ,    Object >    vars    =    new   HashMap <  >  (  1  )  ;", "vars . put (  \" id \"  ,     1  2  3 L )  ;", "String   template    =     \" https :  /  /  { host }  :  { port }  / v 4  2  / customers /  { id }  \"  ;", "URI   actual    =    this . handler . expand ( template ,    vars )  ;", "assertEquals (  \" https :  /  / api . example . com :  4  4  3  / v 4  2  / customers /  1  2  3  \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultUriVariables"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setParsePath ( false )  ;", "Map < String ,    String >    vars    =    new   HashMap <  >  (  2  )  ;", "vars . put (  \" hotel \"  ,     \"  1  \"  )  ;", "vars . put (  \" publicpath \"  ,     \" pics / logo . png \"  )  ;", "String   t    =     \" http :  /  / example . com / hotels /  { hotel }  / pic /  { publicpath }  \"  ;", "URI   actual    =    this . handler . expand ( t ,    vars )  ;", "assertEquals (  \" http :  /  / example . com / hotels /  1  / pic / pics / logo . png \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["parsePathIsOff"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setParsePath ( true )  ;", "Map < String ,    String >    vars    =    new   HashMap <  >  (  2  )  ;", "vars . put (  \" hotel \"  ,     \"  1  \"  )  ;", "vars . put (  \" publicpath \"  ,     \" pics / logo . png \"  )  ;", "vars . put (  \" scale \"  ,     \"  1  5  0 x 1  5  0  \"  )  ;", "String   t    =     \" http :  /  / example . com / hotels /  { hotel }  / pic /  { publicpath }  / size /  { scale }  \"  ;", "URI   actual    =    this . handler . expand ( t ,    vars )  ;", "assertEquals (  \" http :  /  / example . com / hotels /  1  / pic / pics %  2 Flogo . png / size /  1  5  0 x 1  5  0  \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["parsePathIsOn"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    defaultVars    =    new   HashMap <  >  (  1  )  ;", "defaultVars . put (  \" host \"  ,     \" www . example . com \"  )  ;", "this . handler . setVariables ( defaultVars )  ;", "this . handler . setStrictEncoding ( true )  ;", "Map < String ,    Object >    vars    =    new   HashMap <  >  (  1  )  ;", "vars . put (  \" userId \"  ,     \" john ; doe \"  )  ;", "String   template    =     \" http :  /  /  { host }  / user /  { userId }  / dashboard \"  ;", "URI   actual    =    this . handler . expand ( template ,    vars )  ;", "assertEquals (  \" http :  /  / www . example . com / user / john %  3 Bdoe / dashboard \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["strictEncodingAndDefaultUriVariables"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setStrictEncoding ( false )  ;", "Map < String ,    String >    vars    =    new   HashMap <  >  (  2  )  ;", "vars . put (  \" userId \"  ,     \" john ; doe \"  )  ;", "String   t    =     \" http :  /  / www . example . com / user /  { userId }  / dashboard \"  ;", "URI   actual    =    this . handler . expand ( t ,    vars )  ;", "assertEquals (  \" http :  /  / www . example . com / user / john ; doe / dashboard \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["strictEncodingIsOffWithMap"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setStrictEncoding ( false )  ;", "String   t    =     \" http :  /  / www . example . com / user /  { userId }  / dashboard \"  ;", "URI   actual    =    this . handler . expand ( t ,     \" john ; doe \"  )  ;", "assertEquals (  \" http :  /  / www . example . com / user / john ; doe / dashboard \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["strictEncodingOffWithArray"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setStrictEncoding ( true )  ;", "String   t    =     \" http :  /  / www . example . com / user /  { userId }  / dashboard \"  ;", "URI   actual    =    this . handler . expand ( t ,     \" john ; doe \"  )  ;", "assertEquals (  \" http :  /  / www . example . com / user / john %  3 Bdoe / dashboard \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["strictEncodingOnWithArray"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setStrictEncoding ( true )  ;", "Map < String ,    String >    vars    =    new   HashMap <  >  (  2  )  ;", "vars . put (  \" userId \"  ,     \" john ; doe \"  )  ;", "String   t    =     \" http :  /  / www . example . com / user /  { userId }  / dashboard \"  ;", "URI   actual    =    this . handler . expand ( t ,    vars )  ;", "assertEquals (  \" http :  /  / www . example . com / user / john %  3 Bdoe / dashboard \"  ,    actual . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["strictEncodingOnWithMap"], "fileName": "org.springframework.web.util.DefaultUriTemplateHandlerTests"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . queryParams . size (  )  ;", "MultiValueMap < String ,    String >    result    =    new   util . LinkedMultiValueMap ( size )  ;", "this . queryParams . forEach (  (    key ,    values )     -  >     {", "String   name    =    encodeUriComponent ( key ,    charset ,    Type . QUERY _ PARAM )  ;", "List < String >    encodedValues    =    new   ArrayList <  >  ( values . size (  )  )  ;", "for    ( String   value    :    values )     {", "encodedValues . add ( encodeUriComponent ( value ,    charset ,    Type . QUERY _ PARAM )  )  ;", "}", "result . put ( name ,    encodedValues )  ;", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["encodeQueryParams"], "fileName": "org.springframework.web.util.HierarchicalUriComponents"}, {"methodBody": ["METHOD_START", "{", "return   HierarchicalUriComponents . encodeUriComponent ( source ,    Charset . forName ( encoding )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["encodeUriComponent"], "fileName": "org.springframework.web.util.HierarchicalUriComponents"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( source )  )  )     {", "return   source ;", "}", "Assert . notNull ( charset ,     \" Charset   must   not   be   null \"  )  ;", "Assert . notNull ( type ,     \" Type   must   not   be   null \"  )  ;", "byte [  ]    bytes    =    source . getBytes ( charset )  ;", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream ( bytes . length )  ;", "boolean   changed    =    false ;", "for    ( byte   b    :    bytes )     {", "if    ( b    <     0  )     {", "b    +  =     2  5  6  ;", "}", "if    ( type . isAllowed ( b )  )     {", "bos . write ( b )  ;", "} else    {", "bos . write (  '  %  '  )  ;", "char   hex 1     =    Character . toUpperCase ( Character . forDigit (  (  ( b    >  >     4  )     &     1  5  )  ,     1  6  )  )  ;", "char   hex 2     =    Character . toUpperCase ( Character . forDigit (  ( b    &     1  5  )  ,     1  6  )  )  ;", "bos . write ( hex 1  )  ;", "bos . write ( hex 2  )  ;", "changed    =    true ;", "}", "}", "return   changed    ?    new   String ( bos . toByteArray (  )  ,    charset )     :    source ;", "}", "METHOD_END"], "methodName": ["encodeUriComponent"], "fileName": "org.springframework.web.util.HierarchicalUriComponents"}, {"methodBody": ["METHOD_START", "{", "int   size    =    this . queryParams . size (  )  ;", "MultiValueMap < String ,    String >    result    =    new   LinkedMultiValueMap ( size )  ;", "UriComponents . UriTemplateVariables   queryVariables    =    new    . QueryUriTemplateVariables ( variables )  ;", "this . queryParams . forEach (  (    key ,    values )     -  >     {", "String   name    =    expandUriComponent ( key ,    queryVariables )  ;", "List < String >    expandedValues    =    new   ArrayList <  >  ( values . size (  )  )  ;", "for    ( String   value    :    values )     {", "expandedValues . add ( expandUriComponent ( value ,    queryVariables )  )  ;", "}", "result . put ( name ,    expandedValues )  ;", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["expandQueryParams"], "fileName": "org.springframework.web.util.HierarchicalUriComponents"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . host )     !  =    null )     &  &     ( this . host . startsWith (  \"  [  \"  )  )     ?    HierarchicalUriComponents . Type . HOST _ IPV 6     :    HierarchicalUriComponents . Type . HOST _ IPV 4  ;", "}", "METHOD_END"], "methodName": ["getHostType"], "fileName": "org.springframework.web.util.HierarchicalUriComponents"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . encoded )  )     {", "return ;", "}", ". verifyUriComponent ( getScheme (  )  ,     . Type . SCHEME )  ;", ". verifyUriComponent ( this . userInfo ,     . Type . USER _ INFO )  ;", ". verifyUriComponent ( this . host ,    getHostType (  )  )  ;", "this . path . verify (  )  ;", "this . queryParams . forEach (  (    key ,    values )     -  >     {", "verifyUriComponent ( key ,    Type . QUERY _ PARAM )  ;", "for    ( String   value    :    values )     {", "verifyUriComponent ( value ,    Type . QUERY _ PARAM )  ;", "}", "}  )  ;", ". verifyUriComponent ( getFragment (  )  ,     . Type . FRAGMENT )  ;", "}", "METHOD_END"], "methodName": ["verify"], "fileName": "org.springframework.web.util.HierarchicalUriComponents"}, {"methodBody": ["METHOD_START", "{", "if    ( source    =  =    null )     {", "return ;", "}", "int   length    =    source . length (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "char   ch    =    source . charAt ( i )  ;", "if    ( ch    =  =     '  %  '  )     {", "if    (  ( i    +     2  )     <    length )     {", "char   hex 1     =    source . charAt (  ( i    +     1  )  )  ;", "char   hex 2     =    source . charAt (  ( i    +     2  )  )  ;", "int   u    =    Character . digit ( hex 1  ,     1  6  )  ;", "int   l    =    Character . digit ( hex 2  ,     1  6  )  ;", "if    (  ( u    =  =     (  -  1  )  )     |  |     ( l    =  =     (  -  1  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   encoded   sequence    \\  \"  \"     +     ( source . subst ( i )  )  )     +     \"  \\  \"  \"  )  )  ;", "}", "i    +  =     2  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   encoded   sequence    \\  \"  \"     +     ( source . subst ( i )  )  )     +     \"  \\  \"  \"  )  )  ;", "}", "} else", "if    (  !  ( type . isAllowed ( ch )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Invalid   character    '  \"     +    ch )     +     \"  '    for    \"  )     +     ( type . name (  )  )  )     +     \"    in    \\  \"  \"  )     +    source )     +     \"  \\  \"  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["verifyUriComponent"], "fileName": "org.springframework.web.util.HierarchicalUriComponents"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . nextPotentialReferencePosition )     !  =     ( this . currentPosition )  )     {", "int   skipUntilIndex    =     (  ( this . nextPotentialReferencePosition )     !  =     (  -  1  )  )     ?    this . nextPotentialReferencePosition    :    this . originalMessage . length (  )  ;", "if    (  ( skipUntilIndex    -     ( this . currentPosition )  )     >     3  )     {", "this . ddMessage . append ( this . originalMessage . substring ( this . currentPosition ,    skipUntilIndex )  )  ;", "this . currentPosition    =    skipUntilIndex ;", "} else    {", "while    (  ( this . currentPosition )     <    skipUntilIndex )", "this . ddMessage . append ( this . originalMessage . charAt (  (  ( this . currentPosition )  +  +  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["copyCharactersTillPotentialReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityDecoder"}, {"methodBody": ["METHOD_START", "{", "while    (  ( this . currentPosition )     <     ( this . originalMessage . length (  )  )  )     {", "findNextPotentialReference ( this . currentPosition )  ;", "copysTillPotentialReference (  )  ;", "processPossibleReference (  )  ;", "}", "return   this . decodedMessage . toString (  )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.web.util.HtmlCharacterEntityDecoder"}, {"methodBody": ["METHOD_START", "{", "this . nextPotentialReferencePosition    =    Math . max ( startPosition ,     (  ( this . nextSemicolonPosition )     -     ( HtmlCharacterEntityDecoder . MAX _ REFERENCE _ SIZE )  )  )  ;", "do    {", "this . nextPotentialReferencePosition    =    this . originalMessage . indexOf (  '  &  '  ,    this . nextPotentialReferencePosition )  ;", "if    (  (  ( this . nextSemicolonPosition )     !  =     (  -  1  )  )     &  &     (  ( this . nextSemicolonPosition )     <     ( this . nextPotentialReferencePosition )  )  )", "this . nextSemicolonPosition    =    this . originalMessage . indexOf (  '  ;  '  ,     (  ( this . nextPotentialReferencePosition )     +     1  )  )  ;", "boolean   isPotentialReference    =     (  (  ( this . nextPotentialReferencePosition )     !  =     (  -  1  )  )     &  &     (  ( this . nextSemicolonPosition )     !  =     (  -  1  )  )  )     &  &     (  (  ( this . nextPotentialReferencePosition )     -     ( this . nextSemicolonPosition )  )     <     ( HtmlCharacterEntityDecoder . MAX _ REFERENCE _ SIZE )  )  ;", "if    ( isPotentialReference )     {", "break ;", "}", "if    (  ( this . nextPotentialReferencePosition )     =  =     (  -  1  )  )     {", "break ;", "}", "if    (  ( this . nextSemicolonPosition )     =  =     (  -  1  )  )     {", "this . nextPotentialReferencePosition    =     -  1  ;", "break ;", "}", "this . nextPotentialReferencePosition    =     ( this . nextPotentialReferencePosition )     +     1  ;", "}    while    (  ( this . nextPotentialReferencePosition )     !  =     (  -  1  )     )  ;", "}", "METHOD_END"], "methodName": ["findNextPotentialReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityDecoder"}, {"methodBody": ["METHOD_START", "{", "return   this . originalMessage . substring (  (  ( this . nextPotentialReferencePosition )     +    referenceOffset )  ,    this . nextSemicolonPosition )  ;", "}", "METHOD_END"], "methodName": ["getReferenceSubstring"], "fileName": "org.springframework.web.util.HtmlCharacterEntityDecoder"}, {"methodBody": ["METHOD_START", "{", "String   referenceName    =    getReferenceSubstring (  1  )  ;", "char   mappedCharacter    =    this . characterEntityReferences . convertToCharacter ( referenceName )  ;", "if    ( mappedCharacter    !  =     ( References . CHAR _ NULL )  )     {", "this . decodedMessage . append ( mappedCharacter )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["processNamedReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityDecoder"}, {"methodBody": ["METHOD_START", "{", "char   referenceChar    =    this . originalMessage . charAt (  (  ( this . nextPotentialReferencePosition )     +     2  )  )  ;", "boolean   isHexNumberedReference    =     ( referenceChar    =  =     ' x '  )     |  |     ( referenceChar    =  =     ' X '  )  ;", "try    {", "int   value    =     (  ! isHexNumberedReference )     ?    Integer . parseInt ( getReferenceSubstring (  2  )  )     :    Integer . parseInt ( getReferenceSubstring (  3  )  ,     1  6  )  ;", "this . ddMessage . append (  (  ( char )     ( value )  )  )  ;", "return   true ;", "}    catch    ( NumberFormatException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["processNumberedReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityDecoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . nextPotentialReferencePosition )     !  =     (  -  1  )  )     {", "boolean   isNumberedReference    =     ( this . originalMessage . charAt (  (  ( this . currentPosition )     +     1  )  )  )     =  =     '  #  '  ;", "boolean   wasProcessable    =     ( isNumberedReference )     ?    processNumberedReference (  )     :    processNamedReference (  )  ;", "if    ( wasProcessable )     {", "this . currentPosition    =     ( this . nextSemicolonPosition )     +     1  ;", "} else    {", "char   currentChar    =    this . originalMessage . charAt ( this . currentPosition )  ;", "this . ddMessage . append ( currentChar )  ;", "( this . currentPosition )  +  +  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processPossibleReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityDecoder"}, {"methodBody": ["METHOD_START", "{", "Character   referredCharacter    =    this . entityReferenceToCharacterMap . get ( entityReference )  ;", "if    ( referredCharacter    !  =    null )     {", "return   referredCharacter ;", "}", "return    . CHAR _ NULL ;", "}", "METHOD_END"], "methodName": ["convertToCharacter"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferences"}, {"methodBody": ["METHOD_START", "{", "return   convertToReference ( character ,    WebUtils . DEFAULT _ CHARACTER _ ENCODING )  ;", "}", "METHOD_END"], "methodName": ["convertToReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferences"}, {"methodBody": ["METHOD_START", "{", "if    ( encoding . startsWith (  \" UTF -  \"  )  )     {", "switch    ( character )     {", "case    '  <  '     :", "return    \"  & lt ;  \"  ;", "case    '  >  '     :", "return    \"  & gt ;  \"  ;", "case    '  \"  '     :", "return    \"  & quot ;  \"  ;", "case    '  &  '     :", "return    \"  & amp ;  \"  ;", "case    '  \\  '  '     :", "return    \"  &  #  3  9  ;  \"  ;", "}", "} else", "if    (  ( character    <     1  0  0  0  )     |  |     (  ( character    >  =     8  0  0  0  )     &  &     ( character    <     1  0  0  0  0  )  )  )     {", "int   index    =     ( character    <     1  0  0  0  )     ?    character    :    character    -     7  0  0  0  ;", "String   entityReference    =    this . characterToMap [ index ]  ;", "if    ( entityReference    !  =    null )     {", "return   entityReference ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["convertToReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferences"}, {"methodBody": ["METHOD_START", "{", "return   this . entityReferenceToCharacterMap . size (  )  ;", "}", "METHOD_END"], "methodName": ["getSupportedReferenceCount"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferences"}, {"methodBody": ["METHOD_START", "{", "return   isMappedToReference ( character ,    WebUtils . DEFAULT _ CHARACTER _ ENCODING )  ;", "}", "METHOD_END"], "methodName": ["isMappedToReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferences"}, {"methodBody": ["METHOD_START", "{", "return    ( convertToReference ( character ,    encoding )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isMappedToReference"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferences"}, {"methodBody": ["METHOD_START", "{", "HtmlCharacterEntityReferencesTests . CharacterEntityResourceIterator   entityIterator    =    new   HtmlCharacterEntityReferencesTests . CharacterEntityResourceIterator (  )  ;", "Map < Integer ,    String >    referencedCharactersMap    =    new   HashMap <  >  (  )  ;", "while    ( entityIterator . hasNext (  )  )     {", "int   character    =    entityIterator . getReferredCharacter (  )  ;", "String   entityName    =    entityIterator . nextEntry (  )  ;", "referencedCharactersMap . put ( new   Integer ( character )  ,    entityName )  ;", "}", "return   referencedCharactersMap ;", "}", "METHOD_END"], "methodName": ["getReferenceCharacterMap"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferencesTests"}, {"methodBody": ["METHOD_START", "{", "HtmlCharacterEntityReferences   entityReferences    =    new   HtmlCharacterEntityReferences (  )  ;", "String   utf 8     =     \" UTF -  8  \"  ;", "assertEquals (  \"  & lt ;  \"  ,    entityReferences . convertToReference (  '  <  '  ,    utf 8  )  )  ;", "assertEquals (  \"  & gt ;  \"  ,    entityReferences . convertToReference (  '  >  '  ,    utf 8  )  )  ;", "assertEquals (  \"  & amp ;  \"  ,    entityReferences . convertToReference (  '  &  '  ,    utf 8  )  )  ;", "assertEquals (  \"  & quot ;  \"  ,    entityReferences . convertToReference (  '  \"  '  ,    utf 8  )  )  ;", "assertEquals (  \"  &  #  3  9  ;  \"  ,    entityReferences . convertToReference (  '  \\  '  '  ,    utf 8  )  )  ;", "assertNull ( entityReferences . convertToReference (  (  ( char )     (  2  3  3  )  )  ,    utf 8  )  )  ;", "assertNull ( entityReferences . convertToReference (  (  ( char )     (  9  3  4  )  )  ,    utf 8  )  )  ;", "}", "METHOD_END"], "methodName": ["testConvertToReferenceUTF8"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferencesTests"}, {"methodBody": ["METHOD_START", "{", "HtmlCharacterEntityReferences   entityReferences    =    new   HtmlCharacterEntityReferences (  )  ;", "Map < Integer ,    String >    referenceCharactersMap    =    getReferenceCharacterMap (  )  ;", "for    ( int   character    =     0  ;    character    <     1  0  0  0  0  ;    character +  +  )     {", "String   referenceName    =    referenceCharactersMap . get ( character )  ;", "if    ( referenceName    !  =    null )     {", "String   fullReference    =     (  ( HtmlCharacterEntityReferences . REFERENCE _ START )     +    referenceName )     +     ( HtmlCharacterEntityReferences . REFERENCE _ END )  ;", "assertTrue (  (  (  \" The   unicode   character    \"     +    character )     +     \"    should   be   mapped   to   a   reference \"  )  ,    entityReferences . isMappedToReference (  (  ( char )     ( character )  )  )  )  ;", "assertEquals (  (  (  (  \" The   reference   of   unicode   character    \"     +    character )     +     \"    should   be   entity    \"  )     +    referenceName )  ,    fullReference ,    entityReferences . convertToReference (  (  ( char )     ( character )  )  )  )  ;", "assertEquals (  (  (  (  \" The   entity   reference    [  \"     +    referenceName )     +     \"  ]    should   be   mapped   to   unicode   character    \"  )     +    character )  ,     (  ( char )     ( character )  )  ,    entityReferences . convertToCharacter ( referenceName )  )  ;", "} else", "if    ( character    =  =     3  9  )     {", "assertTrue ( entityReferences . isMappedToReference (  (  ( char )     ( character )  )  )  )  ;", "assertEquals (  \"  &  #  3  9  ;  \"  ,    entityReferences . convertToReference (  (  ( char )     ( character )  )  )  )  ;", "} else    {", "assertFalse (  (  (  \" The   unicode   character    \"     +    character )     +     \"    should   not   be   mapped   to   a   reference \"  )  ,    entityReferences . isMappedToReference (  (  ( char )     ( character )  )  )  )  ;", "assertNull (  (  (  \" No   entity   reference   of   unicode   character    \"     +    character )     +     \"    should   exist \"  )  ,    entityReferences . convertToReference (  (  ( char )     ( character )  )  )  )  ;", "}", "}", "assertEquals (  \" The   registered   entity   count   of   entityReferences   should   match   the   number   of   entity   references \"  ,     (  ( referenceCharactersMap . size (  )  )     +     1  )  ,    entityReferences . getSupportedReferenceCount (  )  )  ;", "assertEquals (  \" The   HTML    4  .  0    Standard   defines    2  5  2  +  1    entity   references   so   do   entityReferences \"  ,     (  2  5  2     +     1  )  ,    entityReferences . getSupportedReferenceCount (  )  )  ;", "assertEquals (  \" Invalid   entity   reference   names   should   not   be   convertible \"  ,     (  ( char )     (  -  1  )  )  ,    entityReferences . convertToCharacter (  \" invalid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSupportsAllCharacterEntityReferencesDefinedByHtml"], "fileName": "org.springframework.web.util.HtmlCharacterEntityReferencesTests"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtils . htmlEscape ( input ,    WebUtils . DEFAULT _ CHARACTER _ ENCODING )  ;", "}", "METHOD_END"], "methodName": ["htmlEscape"], "fileName": "org.springframework.web.util.HtmlUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( input ,     \" Input   is   required \"  )  ;", "Assert . notNull ( encoding ,     \" Encoding   is   required \"  )  ;", "StringBuilder   escaped    =    new   StringBuilder (  (  ( input . length (  )  )     *     2  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( input . length (  )  )  ;    i +  +  )     {", "char   character    =    input . charAt ( i )  ;", "String   reference    =     . characterEntityReferences . convertToReference ( character ,    encoding )  ;", "if    ( reference    !  =    null )     {", "escaped . append ( reference )  ;", "} else    {", "escaped . append ( character )  ;", "}", "}", "return   escaped . toString (  )  ;", "}", "METHOD_END"], "methodName": ["htmlEscape"], "fileName": "org.springframework.web.util.HtmlUtils"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtils . htmlEscapeDecimal ( input ,    WebUtils . DEFAULT _ CHARACTER _ ENCODING )  ;", "}", "METHOD_END"], "methodName": ["htmlEscapeDecimal"], "fileName": "org.springframework.web.util.HtmlUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( input ,     \" Input   is   required \"  )  ;", "Assert . notNull ( encoding ,     \" Encoding   is   required \"  )  ;", "StringBuilder   escaped    =    new   StringBuilder (  (  ( input . length (  )  )     *     2  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( input . length (  )  )  ;    i +  +  )     {", "char   character    =    input . charAt ( i )  ;", "if    (  . characterEntityReferences . isMappedToReference ( character ,    encoding )  )     {", "escaped . append ( HtmlCharacterEntityReferences . DECIMAL _ REFERENCE _ START )  ;", "escaped . append (  (  ( int )     ( character )  )  )  ;", "escaped . append ( HtmlCharacterEntityReferences . REFERENCE _ END )  ;", "} else    {", "escaped . append ( character )  ;", "}", "}", "return   escaped . toString (  )  ;", "}", "METHOD_END"], "methodName": ["htmlEscapeDecimal"], "fileName": "org.springframework.web.util.HtmlUtils"}, {"methodBody": ["METHOD_START", "{", "return   HtmlUtils . htmlEscapeHex ( input ,    WebUtils . DEFAULT _ CHARACTER _ ENCODING )  ;", "}", "METHOD_END"], "methodName": ["htmlEscapeHex"], "fileName": "org.springframework.web.util.HtmlUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( input ,     \" Input   is   required \"  )  ;", "Assert . notNull ( encoding ,     \" Encoding   is   required \"  )  ;", "StringBuilder   escaped    =    new   StringBuilder (  (  ( input . length (  )  )     *     2  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( input . length (  )  )  ;    i +  +  )     {", "char   character    =    input . charAt ( i )  ;", "if    (  . characterEntityReferences . isMappedToReference ( character ,    encoding )  )     {", "escaped . append ( HtmlCharacterEntityReferences . HEX _ REFERENCE _ START )  ;", "escaped . append ( Integer . toString ( character ,     1  6  )  )  ;", "escaped . append ( HtmlCharacterEntityReferences . REFERENCE _ END )  ;", "} else    {", "escaped . append ( character )  ;", "}", "}", "return   escaped . toString (  )  ;", "}", "METHOD_END"], "methodName": ["htmlEscapeHex"], "fileName": "org.springframework.web.util.HtmlUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   HtmlCharacterEntityDecoder ( HtmlUtils . characterEntityReferences ,    input )  . decode (  )  ;", "}", "METHOD_END"], "methodName": ["htmlUnescape"], "fileName": "org.springframework.web.util.HtmlUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" An   empty   string   should   be   converted   to   an   empty   string \"  ,     \"  \"  ,    HtmlUtils . htmlUnescape (  \"  \"  )  )  ;", "assertEquals (  \" A   string   containing   no   special   characters   should   not   be   affected \"  ,     \" This   is   a   sentence   containing   no   special   characters .  \"  ,    HtmlUtils . htmlUnescape (  \" This   is   a   sentence   containing   no   special   characters .  \"  )  )  ;", "assertEquals (  \"  ' A & nbsp ; B '    should   be   decoded   to    ' A   B '  \"  ,     (  (  \" A \"     +     (  ( char )     (  1  6  0  )  )  )     +     \" B \"  )  ,    HtmlUtils . htmlUnescape (  \" A & nbsp ; B \"  )  )  ;", "assertEquals (  \"  '  & lt ;     & gt ;  '    should   be   decoded   to    '  <     >  '  \"  ,     \"  <     >  \"  ,    HtmlUtils . htmlUnescape (  \"  & lt ;     & gt ;  \"  )  )  ;", "assertEquals (  \"  '  &  #  6  0  ;     &  #  6  2  ;  '    should   be   decoded   to    '  <     >  '  \"  ,     \"  <     >  \"  ,    HtmlUtils . htmlUnescape (  \"  &  #  6  0  ;     &  #  6  2  ;  \"  )  )  ;", "assertEquals (  \"  '  &  # x 4  1  ;  &  # X 4  2  ;  &  # x 4  3  ;  '    should   be   decoded   to    ' ABC '  \"  ,     \" ABC \"  ,    HtmlUtils . htmlUnescape (  \"  &  # x 4  1  ;  &  # X 4  2  ;  &  # x 4  3  ;  \"  )  )  ;", "assertEquals (  \"  '  & phi ;  '    should   be   decoded   to   uni - code   character    9  6  6  \"  ,     (  \"  \"     +     (  ( char )     (  9  6  6  )  )  )  ,    HtmlUtils . htmlUnescape (  \"  & phi ;  \"  )  )  ;", "assertEquals (  \"  '  & Prime ;  '    should   be   decoded   to   uni - code   character    8  2  4  3  \"  ,     (  \"  \"     +     (  ( char )     (  8  2  4  3  )  )  )  ,    HtmlUtils . htmlUnescape (  \"  & Prime ;  \"  )  )  ;", "assertEquals (  \" A   not   supported   named   reference   leads   should   be   ingnored \"  ,     \"  & prIme ;  \"  ,    HtmlUtils . htmlUnescape (  \"  & prIme ;  \"  )  )  ;", "assertEquals (  \" An   empty   reference    '  &  ;  '    should   be   survive   the   decoding \"  ,     \"  &  ;  \"  ,    HtmlUtils . htmlUnescape (  \"  &  ;  \"  )  )  ;", "assertEquals (  \" The   longest   character   entity   reference    '  & thetasym ;  '    should   be   processable \"  ,     (  \"  \"     +     (  ( char )     (  9  7  7  )  )  )  ,    HtmlUtils . htmlUnescape (  \"  & thetasym ;  \"  )  )  ;", "assertEquals (  \" A   malformed   decimal   reference   should   survive   the   decoding \"  ,     \"  &  # notADecimalNumber ;  \"  ,    HtmlUtils . htmlUnescape (  \"  &  # notADecimalNumber ;  \"  )  )  ;", "assertEquals (  \" A   malformed   hex   reference   should   survive   the   decoding \"  ,     \"  &  # XnotAHexNumber ;  \"  ,    HtmlUtils . htmlUnescape (  \"  &  # XnotAHexNumber ;  \"  )  )  ;", "assertEquals (  \" The   numerical   reference    '  &  #  1  ;  '    should   be   converted   to   char    1  \"  ,     (  \"  \"     +     (  ( char )     (  1  )  )  )  ,    HtmlUtils . htmlUnescape (  \"  &  #  1  ;  \"  )  )  ;", "assertEquals (  \" The   malformed   hex   reference    '  &  # x ;  '    should   remain    '  &  # x ;  '  \"  ,     \"  &  # x ;  \"  ,    HtmlUtils . htmlUnescape (  \"  &  # x ;  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDecodeFromHtmlCharacterSet"], "fileName": "org.springframework.web.util.HtmlUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" An   empty   string   should   be   converted   to   an   empty   string \"  ,     \"  \"  ,    HtmlUtils . htmlEscape (  \"  \"  )  )  ;", "assertEquals (  \" A   string   containing   no   special   characters   should   not   be   affected \"  ,     \" A   sentence   containing   no   special   characters .  \"  ,    HtmlUtils . htmlEscape (  \" A   sentence   containing   no   special   characters .  \"  )  )  ;", "assertEquals (  \"  '  <     >  '    should   be   encoded   to    '  & lt ;     & gt ;  '  \"  ,     \"  & lt ;     & gt ;  \"  ,    HtmlUtils . htmlEscape (  \"  <     >  \"  )  )  ;", "assertEquals (  \"  '  <     >  '    should   be   encoded   to    '  &  #  6  0  ;     &  #  6  2  ;  '  \"  ,     \"  &  #  6  0  ;     &  #  6  2  ;  \"  ,    HtmlUtils . htmlEscapeDecimal (  \"  <     >  \"  )  )  ;", "assertEquals (  \" The   special   character    8  7  0  9    should   be   encoded   to    '  & empty ;  '  \"  ,     \"  & empty ;  \"  ,    HtmlUtils . htmlEscape (  (  \"  \"     +     (  ( char )     (  8  7  0  9  )  )  )  )  )  ;", "assertEquals (  \" The   special   character    8  7  0  9    should   be   encoded   to    '  &  #  8  7  0  9  ;  '  \"  ,     \"  &  #  8  7  0  9  ;  \"  ,    HtmlUtils . htmlEscapeDecimal (  (  \"  \"     +     (  ( char )     (  8  7  0  9  )  )  )  )  )  ;", "assertEquals (  \" The   special   character    9  7  7    should   be   encoded   to    '  & thetasym ;  '  \"  ,     \"  & thetasym ;  \"  ,    HtmlUtils . htmlEscape (  (  \"  \"     +     (  ( char )     (  9  7  7  )  )  )  )  )  ;", "assertEquals (  \" The   special   character    9  7  7    should   be   encoded   to    '  &  #  9  7  7  ;  '  \"  ,     \"  &  #  9  7  7  ;  \"  ,    HtmlUtils . htmlEscapeDecimal (  (  \"  \"     +     (  ( char )     (  9  7  7  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEncodeIntoHtmlCharacterSet"], "fileName": "org.springframework.web.util.HtmlUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   utf 8     =     \" UTF -  8  \"  ;", "assertEquals (  \" An   empty   string   should   be   converted   to   an   empty   string \"  ,     \"  \"  ,     . htmlEscape (  \"  \"  ,    utf 8  )  )  ;", "assertEquals (  \" A   string   containing   no   special   characters   should   not   be   affected \"  ,     \" A   sentence   containing   no   special   characters .  \"  ,     . htmlEscape (  \" A   sentence   containing   no   special   characters .  \"  )  )  ;", "assertEquals (  \"  '  <     >  '    should   be   encoded   to    '  & lt ;     & gt ;  '  \"  ,     \"  & lt ;     & gt ;  \"  ,     . htmlEscape (  \"  <     >  \"  ,    utf 8  )  )  ;", "assertEquals (  \"  '  <     >  '    should   be   encoded   to    '  &  #  6  0  ;     &  #  6  2  ;  '  \"  ,     \"  &  #  6  0  ;     &  #  6  2  ;  \"  ,     . htmlEscapeDecimal (  \"  <     >  \"  ,    utf 8  )  )  ;", "assertEquals (  \" UTF -  8    supported   chars   should   not   be   escaped \"  ,     \"  \u00a6\u00ac  \u00a6\u00c5  \u00a6\u00d1  \u00a6\u00c9  \u00a6\u00ca  \u00a6\u00cf  ?     \u00a6\u00a5  \u00a6\u00cb  \u00a6\u00cb  \u00a6\u00c7  \u00a6\u00cd  \u00a6\u00c9  \u00a6\u00ca  \u00a6\u00cf  ?     & quot ;  \u00a6\u00d6  \u00a6\u00c1  \u00a6\u00d1  \u00a6\u00c1  \u00a6\u00ca  \u00a6\u00d3  ?  \u00a6\u00d1  \u00a6\u00c5  ?  & quot ;  \"  ,     . htmlEscape (  \"  \\ u 0  3  9 c \\ u 0  3 b 5  \\ u 0  3 c 1  \\ u 0  3 b 9  \\ u 0  3 ba \\ u 0  3 bf \\ u 0  3 af    \\ u 0  3  9  5  \\ u 0  3 bb \\ u 0  3 bb \\ u 0  3 b 7  \\ u 0  3 bd \\ u 0  3 b 9  \\ u 0  3 ba \\ u 0  3 bf \\ u 0  3 af    \\  \"  \\ u 0  3 c 7  \\ u 0  3 b 1  \\ u 0  3 c 1  \\ u 0  3 b 1  \\ u 0  3 ba \\ u 0  3 c 4  \\ u 0  3 ae \\ u 0  3 c 1  \\ u 0  3 b 5  \\ u 0  3 c 2  \\  \"  \"  ,    utf 8  )  )  ;", "}", "METHOD_END"], "methodName": ["testEncodeIntoHtmlCharacterSetFromUtf8"], "fileName": "org.springframework.web.util.HtmlUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   unescaped    =     \"  \\  \" This   is   a   quote \\  '  \"  ;", "String   escaped    =     . htmlEscape ( unescaped )  ;", "assertEquals (  \"  & quot ; This   is   a   quote &  #  3  9  ;  \"  ,    escaped )  ;", "escaped    =     . htmlEscapeDecimal ( unescaped )  ;", "assertEquals (  \"  &  #  3  4  ; This   is   a   quote &  #  3  9  ;  \"  ,    escaped )  ;", "escaped    =     . htmlEscapeHex ( unescaped )  ;", "assertEquals (  \"  &  # x 2  2  ; This   is   a   quote &  # x 2  7  ;  \"  ,    escaped )  ;", "}", "METHOD_END"], "methodName": ["testHtmlEscape"], "fileName": "org.springframework.web.util.HtmlUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   escaped    =     \"  & quot ; This   is   a   quote &  #  3  9  ;  \"  ;", "String   unescaped    =     . htmlUnescape ( escaped )  ;", "assertEquals (  \"  \\  \" This   is   a   quote \\  '  \"  ,    unescaped )  ;", "}", "METHOD_END"], "methodName": ["testHtmlUnescape"], "fileName": "org.springframework.web.util.HtmlUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   filtered    =    new   StringBuilder ( input . length (  )  )  ;", "char   prevChar    =     '  \\ u 0  0  0  0  '  ;", "char   c ;", "for    ( int   i    =     0  ;    i    <     ( input . length (  )  )  ;    i +  +  )     {", "c    =    input . charAt ( i )  ;", "if    ( c    =  =     '  \"  '  )     {", "filtered . append (  \"  \\  \\  \\  \"  \"  )  ;", "} else", "if    ( c    =  =     '  \\  '  '  )     {", "filtered . append (  \"  \\  \\  \\  '  \"  )  ;", "} else", "if    ( c    =  =     '  \\  \\  '  )     {", "filtered . append (  \"  \\  \\  \\  \\  \"  )  ;", "} else", "if    ( c    =  =     '  /  '  )     {", "filtered . append (  \"  \\  \\  /  \"  )  ;", "} else", "if    ( c    =  =     '  \\ t '  )     {", "filtered . append (  \"  \\  \\ t \"  )  ;", "} else", "if    ( c    =  =     '  \\ n '  )     {", "if    ( prevChar    !  =     '  \\ r '  )     {", "filtered . append (  \"  \\  \\ n \"  )  ;", "}", "} else", "if    ( c    =  =     '  \\ r '  )     {", "filtered . append (  \"  \\  \\ n \"  )  ;", "} else", "if    ( c    =  =     '  \\ f '  )     {", "filtered . append (  \"  \\  \\ f \"  )  ;", "} else", "if    ( c    =  =     '  \\ b '  )     {", "filtered . append (  \"  \\  \\ b \"  )  ;", "} else", "if    ( c    =  =     '  \\ u 0  0  0 b '  )     {", "filtered . append (  \"  \\  \\ v \"  )  ;", "} else", "if    ( c    =  =     '  <  '  )     {", "filtered . append (  \"  \\  \\ u 0  0  3 C \"  )  ;", "} else", "if    ( c    =  =     '  >  '  )     {", "filtered . append (  \"  \\  \\ u 0  0  3 E \"  )  ;", "} else", "if    ( c    =  =     '  \\ u 2  0  2  8  '  )     {", "filtered . append (  \"  \\  \\ u 2  0  2  8  \"  )  ;", "} else", "if    ( c    =  =     '  \\ u 2  0  2  9  '  )     {", "filtered . append (  \"  \\  \\ u 2  0  2  9  \"  )  ;", "} else    {", "filtered . append ( c )  ;", "}", "prevChar    =    c ;", "}", "return   filtered . toString (  )  ;", "}", "METHOD_END"], "methodName": ["javaScriptEscape"], "fileName": "org.springframework.web.util.JavaScriptUtils"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  '  \"  '  )  ;", "sb . append (  \"  '  \"  )  ;", "sb . append (  \"  \\  \\  \"  )  ;", "sb . append (  \"  /  \"  )  ;", "sb . append (  \"  \\ t \"  )  ;", "sb . append (  \"  \\ n \"  )  ;", "sb . append (  \"  \\ r \"  )  ;", "sb . append (  \"  \\ f \"  )  ;", "sb . append (  \"  \\ b \"  )  ;", "sb . append (  \"  \\ u 0  0  0 b \"  )  ;", "assertEquals (  \"  \\  \\  \\  \"  \\  \\  \\  '  \\  \\  \\  \\  \\  \\  /  \\  \\ t \\  \\ n \\  \\ n \\  \\ f \\  \\ b \\  \\ v \"  ,     . javaScriptEscape ( sb . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["escape"], "fileName": "org.springframework.web.util.JavaScriptUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \\  \\ u 0  0  3 C \\  \\ u 0  0  3 E \"  ,    JavaScriptUtils . javaScriptEscape (  \"  <  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["escapeLessThanGreaterThanSigns"], "fileName": "org.springframework.web.util.JavaScriptUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  '  \\ u 2  0  2  8  '  )  ;", "sb . append (  '  \\ u 2  0  2  9  '  )  ;", "String   result    =     . javaScriptEscape ( sb . toString (  )  )  ;", "assertEquals (  \"  \\  \\ u 2  0  2  8  \\  \\ u 2  0  2  9  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["escapePsLsLineTerminators"], "fileName": "org.springframework.web.util.JavaScriptUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   ServletContextPropertyUtils . resolvePlaceholders ( text ,    servletContext ,    false )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholders"], "fileName": "org.springframework.web.util.ServletContextPropertyUtils"}, {"methodBody": ["METHOD_START", "{", "PropertyPlaceholderHelper   helper    =     ( ignoreUnresolvablePlaceholders )     ?    ServletContextPropertyUtils . nonStrictHelper    :    ServletContextPropertyUtils . strictHelper ;", "return   helper . replacePlaceholders ( text ,    new   ServletContextPropertyUtils . ServletContextPlaceholderResolver ( text ,    servletContext )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholders"], "fileName": "org.springframework.web.util.ServletContextPropertyUtils"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   servletContext    =    new   MockServletContext (  )  ;", "System . setProperty (  \" test . prop \"  ,     \" bar \"  )  ;", "try    {", "String   resolved    =     . resolvePlaceholders (  \"  $  { test . prop : foo }  \"  ,    servletContext )  ;", "assertEquals (  \" bar \"  ,    resolved )  ;", "}    finally    {", "System . clearProperty (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["fallbackToSystemProperties"], "fileName": "org.springframework.web.util.ServletContextPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockServletContext   servletContext    =    new   MockServletContext (  )  ;", "servletContext . setInitParameter (  \" test . prop \"  ,     \" bar \"  )  ;", "String   resolved    =     . resolvePlaceholders (  \"  $  { test . prop : foo }  \"  ,    servletContext )  ;", "assertEquals (  \" bar \"  ,    resolved )  ;", "}", "METHOD_END"], "methodName": ["resolveAsServletContextInitParameter"], "fileName": "org.springframework.web.util.ServletContextPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( tagName ,     \"  ' tagName '    must   not   be   empty \"  )  ;", "Assert . hasText ( ancestorTagName ,     \"  ' ancestorTagName '    must   not   be   empty \"  )  ;", "if    (  !  (  . hasAncestorOfType ( tag ,    ancestorTagClass )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  \" The    '  \"     +    tagName )     +     \"  '    tag   can   only   be   used   inside   a   valid    '  \"  )     +    ancestorTagName )     +     \"  '    tag .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertHasAncestorOfType"], "fileName": "org.springframework.web.util.TagUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( scope ,     \" Scope   to   search   for   cannot   be   null \"  )  ;", "if    ( scope . equals (  . SCOPE _ REQUEST )  )     {", "return   PageContext . REQUEST _ SCOPE ;", "} else", "if    ( scope . equals (  . SCOPE _ SESSION )  )     {", "return   PageContext . SESSION _ SCOPE ;", "} else", "if    ( scope . equals (  . SCOPE _ APPLICATION )  )     {", "return   PageContext . APPLICATION _ SCOPE ;", "} else    {", "return   PageContext . PAGE _ SCOPE ;", "}", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.springframework.web.util.TagUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( tag ,     \" Tag   cannot   be   null \"  )  ;", "Assert . notNull ( ancestorTagClass ,     \" Ancestor   tag   class   cannot   be   null \"  )  ;", "if    (  !  ( Tag . class . isAssignableFrom ( ancestorTagClass )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Class    '  \"     +     ( ancestorTagClass . getName (  )  )  )     +     \"  '    is   not   a   valid   Tag   type \"  )  )  ;", "}", "Tag   ancestor    =    tag . getParent (  )  ;", "while    ( ancestor    !  =    null )     {", "if    ( ancestorTagClass . isAssignableFrom ( ancestor . getClass (  )  )  )     {", "return   true ;", "}", "ancestor    =    ancestor . getParent (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasAncestorOfType"], "fileName": "org.springframework.web.util.TagUtils"}, {"methodBody": ["METHOD_START", "{", "Tag   a    =    new   TagUtilsTests . TagA (  )  ;", "Tag   b    =    new   TagUtilsTests . TagB (  )  ;", "Tag   anotherB    =    new   TagUtilsTests . TagB (  )  ;", "a . setParent ( b )  ;", "b . setParent ( anotherB )  ;", "TagUtils . assertHasAncestorOfType ( a ,    TagUtilsTests . TagC . class ,     \" a \"  ,     \" c \"  )  ;", "}", "METHOD_END"], "methodName": ["assertHasAncestorOfTypeThrowsExceptionOnFail"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TagUtils . assertHasAncestorOfType ( new   TagUtilsTests . TagA (  )  ,    TagUtilsTests . TagC . class ,     \" a \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["assertHasAncestorOfTypeWithNullAncestorTagName"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TagUtils . assertHasAncestorOfType ( new   TagUtilsTests . TagA (  )  ,    TagUtilsTests . TagC . class ,    null ,     \" c \"  )  ;", "}", "METHOD_END"], "methodName": ["assertHasAncestorOfTypeWithNullTagName"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" page \"  ,    TagUtils . SCOPE _ PAGE )  ;", "assertEquals (  \" application \"  ,    TagUtils . SCOPE _ APPLICATION )  ;", "assertEquals (  \" session \"  ,    TagUtils . SCOPE _ SESSION )  ;", "assertEquals (  \" request \"  ,    TagUtils . SCOPE _ REQUEST )  ;", "assertEquals ( PAGE _ SCOPE ,    TagUtils . getScope (  \" page \"  )  )  ;", "assertEquals ( REQUEST _ SCOPE ,    TagUtils . getScope (  \" request \"  )  )  ;", "assertEquals ( SESSION _ SCOPE ,    TagUtils . getScope (  \" session \"  )  )  ;", "assertEquals ( APPLICATION _ SCOPE ,    TagUtils . getScope (  \" application \"  )  )  ;", "assertEquals (  (  \" TagUtils . getScope (  .  .  )    with   a   non - existent   scope   argument   must    \"     +     \" just   return   the   default   scope    ( PageContext . PAGE _ SCOPE )  .  \"  )  ,    PAGE _ SCOPE ,    TagUtils . getScope (  \" bla \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getScopeSunnyDay"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TagUtils . getScope ( null )  ;", "}", "METHOD_END"], "methodName": ["getScopeWithNullScopeArgument"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Tag   a    =    new   TagUtilsTests . TagA (  )  ;", "Tag   b    =    new   TagUtilsTests . TagB (  )  ;", "Tag   anotherB    =    new   TagUtilsTests . TagB (  )  ;", "a . setParent ( b )  ;", "b . setParent ( anotherB )  ;", "assertFalse ( TagUtils . hasAncestorOfType ( a ,    TagUtilsTests . TagC . class )  )  ;", "}", "METHOD_END"], "methodName": ["hasAncestorOfTypeFalseScenario"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Tag   a    =    new   TagUtilsTests . TagA (  )  ;", "Tag   b    =    new   TagUtilsTests . TagB (  )  ;", "Tag   c    =    new   TagUtilsTests . TagC (  )  ;", "a . setParent ( b )  ;", "b . setParent ( c )  ;", "assertTrue ( TagUtils . hasAncestorOfType ( a ,    TagUtilsTests . TagC . class )  )  ;", "}", "METHOD_END"], "methodName": ["hasAncestorOfTypeTrueScenario"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( TagUtils . hasAncestorOfType ( new   TagUtilsTests . TagA (  )  ,    TagUtilsTests . TagC . class )  )  ;", "}", "METHOD_END"], "methodName": ["hasAncestorOfTypeWhenTagHasNoParent"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( TagUtils . hasAncestorOfType ( new   TagSupport (  )  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["hasAncestorOfTypeWhereAncestorTagIsNotATagType"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( TagUtils . hasAncestorOfType ( new   TagSupport (  )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["hasAncestorOfTypeWithNullAncestorTagClassArgument"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( TagUtils . hasAncestorOfType ( null ,    TagSupport . class )  )  ;", "}", "METHOD_END"], "methodName": ["hasAncestorOfTypeWithNullTagArgument"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Tag   a    =    new   TagUtilsTests . TagA (  )  ;", "Tag   b    =    new   TagUtilsTests . TagB (  )  ;", "Tag   c    =    new   TagUtilsTests . TagC (  )  ;", "a . setParent ( b )  ;", "b . setParent ( c )  ;", "TagUtils . assertHasAncestorOfType ( a ,    TagUtilsTests . TagC . class ,     \" a \"  ,     \" c \"  )  ;", "}", "METHOD_END"], "methodName": ["testAssertHasAncestorOfTypeDoesNotThrowExceptionOnPass"], "fileName": "org.springframework.web.util.TagUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   encode ( StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uriVariableValues ,     \"  ' uriVariableValues '    must   not   be   null \"  )  ;", "return   expandInternal ( new    . VarArgsTemplateVariables ( uriVariableValues )  )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uriVariables ,     \"  ' uriVariables '    must   not   be   null \"  )  ;", "return   expandInternal ( new    . MapTemplateVariables ( uriVariables )  )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uriVariables ,     \"  ' uriVariables '    must   not   be   null \"  )  ;", "return   expandInternal ( uriVariables )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "if    ( source    =  =    null )     {", "return   null ;", "}", "if    (  ( source . indexOf (  '  {  '  )  )     =  =     (  -  1  )  )     {", "return   source ;", "}", "if    (  ( source . indexOf (  '  :  '  )  )     !  =     (  -  1  )  )     {", "source    =     . sanitizeSource ( source )  ;", "}", "Matcher   matcher    =     . NAMES _ PATTERN . matcher ( source )  ;", "StringBuffer   sb    =    new   StringBuffer (  )  ;", "while    ( matcher . find (  )  )     {", "String   match    =    matcher . group (  1  )  ;", "String   variableName    =     . getVariableName ( match )  ;", "Object   variableValue    =    uriVariables . getValue ( variableName )  ;", "if    (  . UriTemplateVariables . SKIP _ VALUE . equals ( variableValue )  )     {", "continue ;", "}", "String   variableValueString    =     . getVariableValueAsString ( variableValue )  ;", "String   replacement    =    Matcher . quoteReplacement ( variableValueString )  ;", "matcher . appendReplacement ( sb ,    replacement )  ;", "}", "matcher . appendTail ( sb )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["expandUriComponent"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "return   this . fragment ;", "}", "METHOD_END"], "methodName": ["getFragment"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "return   this . scheme ;", "}", "METHOD_END"], "methodName": ["getScheme"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "int   colonIdx    =    match . indexOf (  '  :  '  )  ;", "return   colonIdx    !  =     (  -  1  )     ?    match . subst (  0  ,    colonIdx )     :    match ;", "}", "METHOD_END"], "methodName": ["getVariableName"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "return   variableValue    !  =    null    ?    variableValue . toString (  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getVariableValueAsString"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "int   level    =     0  ;", "StBuilder   sb    =    new   StBuilder (  )  ;", "for    ( char   c    :    source . toCharArray (  )  )     {", "if    ( c    =  =     '  {  '  )     {", "level +  +  ;", "}", "if    ( c    =  =     '  }  '  )     {", "level -  -  ;", "}", "if    (  ( level    >     1  )     |  |     (  ( level    =  =     1  )     &  &     ( c    =  =     '  }  '  )  )  )     {", "continue ;", "}", "sb . append ( c )  ;", "}", "return   sb . toSt (  )  ;", "}", "METHOD_END"], "methodName": ["sanitizeSource"], "fileName": "org.springframework.web.util.UriComponents"}, {"methodBody": ["METHOD_START", "{", "int   portSeparatorIdx    =    hostToUse . lastIndexOf (  '  :  '  )  ;", "if    ( portSeparatorIdx    >     ( hostToUse . lastIndexOf (  '  ]  '  )  )  )     {", "host ( hostToUse . subst (  0  ,    portSeparatorIdx )  )  ;", "port ( Integer . parseInt ( hostToUse . subst (  ( portSeparatorIdx    +     1  )  )  )  )  ;", "} else    {", "host ( hostToUse )  ;", "port ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["adaptForwardedHost"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   forwardedHeader    =    headers . getFirst (  \" Forwarded \"  )  ;", "if    ( StringUtils . hasText ( forwardedHeader )  )     {", "String   forwardedToUse    =    StringUtils . tokenizeToStringArray ( forwardedHeader ,     \"  ,  \"  )  [  0  ]  ;", "Matcher   matcher    =     . FORWARDED _ PROTO _ PATTERN . matcher ( forwardedToUse )  ;", "if    ( matcher . find (  )  )     {", "scheme ( matcher . group (  1  )  . trim (  )  )  ;", "port ( null )  ;", "}", "matcher    =     . FORWARDED _ HOST _ PATTERN . matcher ( forwardedToUse )  ;", "if    ( matcher . find (  )  )     {", "adaptForwardedHost ( matcher . group (  1  )  . trim (  )  )  ;", "}", "} else    {", "String   protocolHeader    =    headers . getFirst (  \" X - Forwarded - Proto \"  )  ;", "if    ( StringUtils . hasText ( protocolHeader )  )     {", "scheme ( StringUtils . tokenizeToStringArray ( protocolHeader ,     \"  ,  \"  )  [  0  ]  )  ;", "port ( null )  ;", "}", "String   hostHeader    =    headers . getFirst (  \" X - Forwarded - Host \"  )  ;", "if    ( StringUtils . hasText ( hostHeader )  )     {", "adaptForwardedHost ( StringUtils . tokenizeToStringArray ( hostHeader ,     \"  ,  \"  )  [  0  ]  )  ;", "}", "String   portHeader    =    headers . getFirst (  \" X - Forwarded - Port \"  )  ;", "if    ( StringUtils . hasText ( portHeader )  )     {", "port ( Integer . parseInt ( StringUtils . tokenizeToStringArray ( portHeader ,     \"  ,  \"  )  [  0  ]  )  )  ;", "}", "}", "}    catch    ( NumberFormatException   ex )     {", "throw   new   IllegalArgumentException (  (  (  \" Failed   to   parse   a   port   from    \\  \" forwarded \\  \"  - type   headers .     \"     +     (  \" If   not   behind   a   trusted   proxy ,    consider   using   ForwardedHeaderFilter    \"     +     \" with   the   removeOnly = true .    Request   headers :     \"  )  )     +    headers )  )  ;", "}", "if    (  (  ( this . scheme )     !  =    null )     &  &     (  (  ( this . scheme . equals (  \" http \"  )  )     &  &     (  \"  8  0  \"  . equals ( this . port )  )  )     |  |     (  ( this . scheme . equals (  \" https \"  )  )     &  &     (  \"  4  4  3  \"  . equals ( this . port )  )  )  )  )     {", "port ( null )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["adaptFromForwardedHeaders"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   build ( false )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . ssp )     !  =    null )     {", "return   new   Opaque ( this . scheme ,    this . ssp ,    this . fragment )  ;", "} else    {", "return   new   Hierarchical ( this . scheme ,    this . fragment ,    this . userInfo ,    this . host ,    this . port ,    this . pathBuilder . build (  )  ,    this . queryParams ,    encoded ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   build ( false )  . expand ( uriVariableValues )  ;", "}", "METHOD_END"], "methodName": ["buildAndExpand"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   build ( false )  . expand ( uriVariables )  ;", "}", "METHOD_END"], "methodName": ["buildAndExpand"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   UriComponentsBuilder ( this )  ;", "}", "METHOD_END"], "methodName": ["cloneBuilder"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   UriComponentsBuilder . fromUri ( request . getURI (  )  )  . adaptFromForwardedHeaders ( request . getHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequest"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( httpUrl ,     \" HTTP   URL   must   not   be   null \"  )  ;", "Matcher   matcher    =     . HTTP _ URL _ PATTERN . matcher ( httpUrl )  ;", "if    ( matcher . matches (  )  )     {", "builder    =    new    (  )  ;", "String   scheme    =    matcher . group (  1  )  ;", "builder . scheme (  ( scheme    !  =    null    ?    scheme . toLowerCase (  )     :    null )  )  ;", "builder . userInfo ( matcher . group (  4  )  )  ;", "String   host    =    matcher . group (  5  )  ;", "if    (  ( StringUtils . hasLength ( scheme )  )     &  &     (  !  ( StringUtils . hasLength ( host )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \"  [  \"     +    httpUrl )     +     \"  ]    is   not   a   valid   HTTP   URL \"  )  )  ;", "}", "builder . host ( host )  ;", "String   port    =    matcher . group (  7  )  ;", "if    ( StringUtils . hasLength ( port )  )     {", "builder . port ( port )  ;", "}", "builder . path ( matcher . group (  8  )  )  ;", "builder . query ( matcher . group (  1  0  )  )  ;", "return   builder ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \"  [  \"     +    httpUrl )     +     \"  ]    is   not   a   valid   HTTP   URL \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fromHttpUrl"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    UriComponentsBuilder . URI _ PATTERN . matcher ( origin )  ;", "if    ( matcher . matches (  )  )     {", "UriComponentsBuilder   builder    =    new   UriComponentsBuilder (  )  ;", "String   scheme    =    matcher . group (  2  )  ;", "String   host    =    matcher . group (  6  )  ;", "String   port    =    matcher . group (  8  )  ;", "if    ( StringUtils . hasLength ( scheme )  )     {", "builder . scheme ( scheme )  ;", "}", "builder . host ( host )  ;", "if    ( StringUtils . hasLength ( port )  )     {", "builder . port ( port )  ;", "}", "return   builder ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \"  [  \"     +    origin )     +     \"  ]    is   not   a   valid    \\  \" Origin \\  \"    header   value \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fromOriginHeader"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    new   UriComponentsBuilder (  )  ;", "builder . path ( path )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["fromPath"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    new   UriComponentsBuilder (  )  ;", "builder . uri ( uri )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["fromUri"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uri ,     \" URI   must   not   be   null \"  )  ;", "Matcher   matcher    =     . URI _ PATTERN . matcher ( uri )  ;", "if    ( matcher . matches (  )  )     {", "builder    =    new    (  )  ;", "String   scheme    =    matcher . group (  2  )  ;", "String   userInfo    =    matcher . group (  5  )  ;", "String   host    =    matcher . group (  6  )  ;", "String   port    =    matcher . group (  8  )  ;", "String   path    =    matcher . group (  9  )  ;", "String   query    =    matcher . group (  1  1  )  ;", "String   fragment    =    matcher . group (  1  3  )  ;", "boolean   opaque    =    false ;", "if    ( StringUtils . hasLength ( scheme )  )     {", "String   rest    =    uri . substring ( scheme . length (  )  )  ;", "if    (  !  ( rest . startsWith (  \"  :  /  \"  )  )  )     {", "opaque    =    true ;", "}", "}", "builder . scheme ( scheme )  ;", "if    ( opaque )     {", "String   ssp    =    uri . substring ( scheme . length (  )  )  . substring (  1  )  ;", "if    ( StringUtils . hasLength ( fragment )  )     {", "ssp    =    ssp . substring (  0  ,     (  ( ssp . length (  )  )     -     (  ( fragment . length (  )  )     +     1  )  )  )  ;", "}", "builder . schemeSpecificPart ( ssp )  ;", "} else    {", "builder . userInfo ( userInfo )  ;", "builder . host ( host )  ;", "if    ( StringUtils . hasLength ( port )  )     {", "builder . port ( port )  ;", "}", "builder . path ( path )  ;", "builder . query ( query )  ;", "}", "if    ( StringUtils . hasText ( fragment )  )     {", "builder . fragment ( fragment )  ;", "}", "return   builder ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \"  [  \"     +    uri )     +     \"  ]    is   not   a   valid   URI \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fromUriString"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   UriComponentsBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "this . userInfo    =    null ;", "this . host    =    null ;", "this . port    =    null ;", "this . pathBuilder    =    new    . CompositePathComponentBuilder (  )  ;", "this . queryParams . clear (  )  ;", "}", "METHOD_END"], "methodName": ["resetHierarchicalComponents"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "this . ssp    =    null ;", "}", "METHOD_END"], "methodName": ["resetSchemeSpecificPart"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "this . ssp    =    ssp ;", "resetHierarchical (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["schemeSpecificPart"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   build ( false )  . encode (  )  . toUriString (  )  ;", "}", "METHOD_END"], "methodName": ["toUriString"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uri ,     \" URI   must   not   be   null \"  )  ;", "this . scheme    =    uri . getScheme (  )  ;", "if    ( uri . isOpaque (  )  )     {", "this . ssp    =    uri . getRawSchemeSpecificPart (  )  ;", "resetHierarchicalComponents (  )  ;", "} else    {", "if    (  ( uri . getRawUserInfo (  )  )     !  =    null )     {", "this . userInfo    =    uri . getRawUserInfo (  )  ;", "}", "if    (  ( uri . getHost (  )  )     !  =    null )     {", "this . host    =    uri . getHost (  )  ;", "}", "if    (  ( uri . getPort (  )  )     !  =     (  -  1  )  )     {", "this . port    =    String . valueOf ( uri . getPort (  )  )  ;", "}", "if    ( StringUtils . hasLength ( uri . getRawPath (  )  )  )     {", "this . pathBuilder    =    new    . CompositePathComponentBuilder (  )  ;", "this . pathBuilder . addPath ( uri . getRawPath (  )  )  ;", "}", "if    ( StringUtils . hasLength ( uri . getRawQuery (  )  )  )     {", "this . queryParams . clear (  )  ;", "query ( uri . getRawQuery (  )  )  ;", "}", "resetSchemeSpecificPart (  )  ;", "}", "if    (  ( uri . getRawFragment (  )  )     !  =    null )     {", "this . fragment    =    uri . getRawFragment (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["uri"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uriComponents ,     \" UriComponents   must   not   be   null \"  )  ;", "uriComponents . copyTo ( this )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["uriComponents"], "fileName": "org.springframework.web.util.UriComponentsBuilder"}, {"methodBody": ["METHOD_START", "{", "UriComponents   result    =    UriComponentsBuilder . fromPath (  \"  /  { foo }  \"  )  . buildAndExpand (  \" fooValue \"  )  ;", "assertEquals (  \"  / fooValue \"  ,    result . toUriString (  )  )  ;", "Map < String ,    String >    values    =    new   HashMap <  >  (  )  ;", "values . put (  \" foo \"  ,     \" fooValue \"  )  ;", "values . put (  \" bar \"  ,     \" barValue \"  )  ;", "result    =    UriComponentsBuilder . fromPath (  \"  /  { foo }  /  { bar }  \"  )  . buildAndExpand ( values )  ;", "assertEquals (  \"  / fooValue / barValue \"  ,    result . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildAndExpandHierarchical"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   result    =    UriComponentsBuilder . fromUriString (  \" mailto :  { user }  @  { domain }  \"  )  . buildAndExpand (  \" foo \"  ,     \" example . com \"  )  ;", "assertEquals (  \" mailto : foo @ example . com \"  ,    result . toUriString (  )  )  ;", "Map < String ,    String >    values    =    new   HashMap <  >  (  )  ;", "values . put (  \" user \"  ,     \" foo \"  )  ;", "values . put (  \" domain \"  ,     \" example . com \"  )  ;", "UriComponentsBuilder . fromUriString (  \" mailto :  { user }  @  { domain }  \"  )  . buildAndExpand ( values )  ;", "assertEquals (  \" mailto : foo @ example . com \"  ,    result . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildAndExpandOpaque"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  ;", "UriComponents   result    =    builder . queryParam (  \" baz \"  )  . build (  )  ;", "assertEquals (  \" baz \"  ,    result . getQuery (  )  )  ;", "MultiValueMap < String ,    String >    expectedQueryParams    =    new   LinkedMultiValueMap (  2  )  ;", "expectedQueryParams . add (  \" baz \"  ,    null )  ;", "assertEquals ( expectedQueryParams ,    result . getQueryParams (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyQueryParam"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   baseUrl    =     \" http :  /  / example . com / abc /  \"  ;", "assertThat (  . fromUriString ( baseUrl )  . path (  \"  / x / y / z \"  )  . build (  )  . toString (  )  ,    equalTo (  \" http :  /  / example . com / abc / x / y / z \"  )  )  ;", "assertThat (  . fromUriString ( baseUrl )  . pathSegment (  \" x \"  ,     \" y \"  ,     \" z \"  )  . build (  )  . toString (  )  ,    equalTo (  \" http :  /  / example . com / abc / x / y / z \"  )  )  ;", "assertThat (  . fromUriString ( baseUrl )  . path (  \"  / x /  \"  )  . path (  \"  / y / z \"  )  . build (  )  . toString (  )  ,    equalTo (  \" http :  /  / example . com / abc / x / y / z \"  )  )  ;", "assertThat (  . fromUriString ( baseUrl )  . pathSegment (  \" x \"  )  . path (  \" y \"  )  . build (  )  . toString (  )  ,    equalTo (  \" http :  /  / example . com / abc / x / y \"  )  )  ;", "}", "METHOD_END"], "methodName": ["emptySegments"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" http :  /  / example . com / foo ? bar # baz \"  )  ;", "UriComponents   result    =     . fromUri ( uri )  . build (  )  ;", "assertEquals (  \" http \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \" example . com \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / foo \"  ,    result . getPath (  )  )  ;", "assertEquals (  \" bar \"  ,    result . getQuery (  )  )  ;", "assertEquals (  \" baz \"  ,    result . getFragment (  )  )  ;", "assertEquals (  \" Invalid   result   URI \"  ,    uri ,    result . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHierarchicalUri"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  (  -  1  )  )  ;", "request . setRequestURI (  \"  / path \"  )  ;", "request . setQueryString (  \" a =  1  \"  )  ;", "UriComponents   result    =     . fromHttpRequest ( new   ServletServerHttpRequest ( request )  )  . build (  )  ;", "assertEquals (  \" http \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \" localhost \"  ,    result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "assertEquals (  \"  / path \"  ,    result . getPath (  )  )  ;", "assertEquals (  \" a =  1  \"  ,    result . getQuery (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequest"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" proto = https ;    host =  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestForwardedHeader"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" proto =  \\  \" https \\  \"  ;    host =  \\  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \\  \"  \"  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestForwardedHeaderQuoted"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" proto = https ;    host =  8  4  .  1  9  8  .  5  8  .  1  9  9  :  9  0  9  0  \"  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerPort (  8  0  8  0  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "assertEquals (  9  0  9  0  ,    result . getPort (  )  )  ;", "assertEquals (  \" https :  /  /  8  4  .  1  9  8  .  5  8  .  1  9  9  :  9  0  9  0  / rest / mobile / users /  1  \"  ,    result . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestForwardedHeaderWithHostPortAndServerPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" proto = https ;    host =  8  4  .  1  9  8  .  5  8  .  1  9  9  :  9  0  9  0  \"  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "assertEquals (  9  0  9  0  ,    result . getPort (  )  )  ;", "assertEquals (  \" https :  /  /  8  4  .  1  9  8  .  5  8  .  1  9  9  :  9  0  9  0  / rest / mobile / users /  1  \"  ,    result . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestForwardedHeaderWithHostPortAndWithoutServerPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" proto = https \"  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerPort (  8  0  8  0  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \" example . com \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "assertEquals (  \" https :  /  / example . com / rest / mobile / users /  1  \"  ,    result . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestForwardedHeaderWithProtoAndServerPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" proto = https ;    host =  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerPort (  8  0  8  0  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "assertEquals (  \" https :  /  /  8  4  .  1  9  8  .  5  8  .  1  9  9  / rest / mobile / users /  1  \"  ,    result . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestForwardedHeaderWithoutHostPortAndWithServerPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" host =  8  4  .  1  9  8  .  5  8  .  1  9  9  ; proto = https \"  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" proto = ftp ;    host =  1  .  2  .  3  .  4  \"  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestMultipleForwardedHeader"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" host =  8  4  .  1  9  8  .  5  8  .  1  9  9     ; proto = https ,    proto = ftp ;    host =  1  .  2  .  3  .  4  \"  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    result . getHost (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestMultipleForwardedHeaderComma"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . addHeader (  \" X - Forwarded - Proto \"  ,     \" https \"  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  )  ;", "request . addHeader (  \" X - Forwarded - Port \"  ,     4  4  3  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" example . com \"  )  ;", "request . setServerPort (  8  0  )  ;", "request . setRequestURI (  \"  / rest / mobile / users /  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  ,    result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "assertEquals (  \"  / rest / mobile / users /  1  \"  ,    result . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestResetsPortBeforeSettingIt"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  (  -  1  )  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \" anotherHost \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" http :  /  / anotherHost / mvc - showcase \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedHost"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  8  0  8  0  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \" foobarhost \"  )  ;", "request . addHeader (  \" X - Forwarded - Port \"  ,     \"  9  0  9  0  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" foobarhost \"  ,    result . getHost (  )  )  ;", "assertEquals (  9  0  9  0  ,    result . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedHostAndPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  (  -  1  )  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \" webtest . foo . bar . com :  4  4  3  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" webtest . foo . bar . com \"  ,    result . getHost (  )  )  ;", "assertEquals (  4  4  3  ,    result . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedHostIncludingPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  (  -  1  )  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \" a . example . org ,    b . example . org ,    c . example . org \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" a . example . org \"  ,    result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedHostMultiValuedHeader"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  1  0  0  8  0  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \" example . org \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" example . org \"  ,    result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedHostWithDefaultPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  1  0  0  8  0  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \" example . org \"  )  ;", "request . addHeader (  \" X - Forwarded - Proto \"  ,     \" https \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" example . org \"  ,    result . getHost (  )  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedHostWithForwardedScheme"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  (  -  1  )  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" host =  1  9  2  .  1  6  8  .  0  .  1  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" http :  /  /  1  9  2  .  1  6  8  .  0  .  1  / mvc - showcase \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedIPv4Host"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  (  -  1  )  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" Forwarded \"  ,     \" host =  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" http :  /  /  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  / mvc - showcase \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedIPv6"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  (  -  1  )  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \"  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" http :  /  /  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  / mvc - showcase \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedIPv6Host"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  (  -  1  )  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \"  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  :  8  0  8  0  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" http :  /  /  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  :  8  0  8  0  / mvc - showcase \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedIPv6HostAndPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  9  0  9  0  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \" a . example . org \"  )  ;", "request . addHeader (  \" X - Forwarded - Port \"  ,     \"  8  0  ,  5  2  0  2  2  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" http :  /  / a . example . org / mvc - showcase \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedPortMultiValueHeader"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  8  0  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" X - Forwarded - Proto \"  ,     \" https \"  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \"  8  4  .  1  9  8  .  5  8  .  1  9  9  \"  )  ;", "request . addHeader (  \" X - Forwarded - Port \"  ,     \"  4  4  3  \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https :  /  /  8  4  .  1  9  8  .  5  8  .  1  9  9  / mvc - showcase \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedProtoAndDefaultPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" localhost \"  )  ;", "request . setServerPort (  8  0  8  0  )  ;", "request . setRequestURI (  \"  / mvc - showcase \"  )  ;", "request . addHeader (  \" X - Forwarded - Host \"  ,     \" a . example . org \"  )  ;", "request . addHeader (  \" X - Forwarded - Port \"  ,     \"  4  4  3  \"  )  ;", "request . addHeader (  \" X - Forwarded - Proto \"  ,     \" https , https \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https :  /  / a . example . org / mvc - showcase \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedProtoMultiValueHeader"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   request    =    new   MockHttpServletRequest (  )  ;", "request . setScheme (  \" http \"  )  ;", "request . setServerName (  \" example . org \"  )  ;", "request . setServerPort (  1  0  0  8  0  )  ;", "request . addHeader (  \" X - Forwarded - Proto \"  ,     \" https \"  )  ;", "HttpRequest   httpRequest    =    new   ServletServerHttpRequest ( request )  ;", "UriComponents   result    =     . fromHttpRequest ( httpRequest )  . build (  )  ;", "assertEquals (  \" https \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \" example . org \"  ,    result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithForwardedProtoWithDefaultPort"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   before    =    UriComponentsBuilder . fromPath (  \"  / foo /  \"  )  . build (  )  ;", "UriComponents   after    =    UriComponentsBuilder . newInstance (  )  . uriComponents ( before )  . build (  )  ;", "assertEquals (  \"  / foo /  \"  ,    after . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpRequestWithTrailingSlash"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" http \"  ,    UriComponentsBuilder . fromHttpUrl (  \" HTTP :  /  / www . google . com \"  )  . build (  )  . getScheme (  )  )  ;", "assertEquals (  \" https \"  ,    UriComponentsBuilder . fromHttpUrl (  \" HTTPS :  /  / www . google . com \"  )  . build (  )  . getScheme (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpUrlStringCaseInsesitiveScheme"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder . fromHttpUrl (  \" http :  /  /  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc :  8  0  8  0  / resource \"  )  . build (  )  . encode (  )  ;", "}", "METHOD_END"], "methodName": ["fromHttpUrlStringInvalidIPv6Host"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" mailto : foo @ bar . com # baz \"  )  ;", "UriComponents   result    =     . fromUri ( uri )  . build (  )  ;", "assertEquals (  \" mailto \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \" foo @ bar . com \"  ,    result . getSchemeSpecificPart (  )  )  ;", "assertEquals (  \" baz \"  ,    result . getFragment (  )  )  ;", "assertEquals (  \" Invalid   result   URI \"  ,    uri ,    result . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromOpaqueUri"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   result    =    UriComponentsBuilder . fromPath (  \" foo \"  )  . queryParam (  \" bar \"  )  . fragment (  \" baz \"  )  . build (  )  ;", "assertEquals (  \" foo \"  ,    result . getPath (  )  )  ;", "assertEquals (  \" bar \"  ,    result . getQuery (  )  )  ;", "assertEquals (  \" baz \"  ,    result . getFragment (  )  )  ;", "assertEquals (  \" Invalid   result   URI   String \"  ,     \" foo ? bar # baz \"  ,    result . toUriString (  )  )  ;", "URI   expected    =    new   URI (  \" foo ? bar # baz \"  )  ;", "assertEquals (  \" Invalid   result   URI \"  ,    expected ,    result . toUri (  )  )  ;", "result    =    UriComponentsBuilder . fromPath (  \"  / foo \"  )  . build (  )  ;", "assertEquals (  \"  / foo \"  ,    result . getPath (  )  )  ;", "expected    =    new   URI (  \"  / foo \"  )  ;", "assertEquals (  \" Invalid   result   URI \"  ,    expected ,    result . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromPath"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" http :  /  / www . example . org /  ? param = aGVsbG 9 Xb 3 JsZA %  3 D %  3 D \"  )  ;", "String   fromUri    =     . fromUri ( uri )  . build (  )  . getQueryParams (  )  . get (  \" param \"  )  . get (  0  )  ;", "String   fromUriString    =     . fromUriString ( uri . toString (  )  )  . build (  )  . getQueryParams (  )  . get (  \" param \"  )  . get (  0  )  ;", "assertEquals ( fromUri ,    fromUriString )  ;", "}", "METHOD_END"], "methodName": ["fromUriEncodedQuery"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   result    =    UriComponentsBuilder . fromUriString (  \" http :  /  / www . ietf . org / rfc / rfc 3  9  8  6  . txt \"  )  . build (  )  ;", "assertEquals (  \" http \"  ,    result . getScheme (  )  )  ;", "assertNull ( result . getUserInfo (  )  )  ;", "assertEquals (  \" www . ietf . org \"  ,    result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "assertEquals (  \"  / rfc / rfc 3  9  8  6  . txt \"  ,    result . getPath (  )  )  ;", "assertEquals ( Arrays . asList (  \" rfc \"  ,     \" rfc 3  9  8  6  . txt \"  )  ,    result . getPathSegments (  )  )  ;", "assertNull ( result . getQuery (  )  )  ;", "assertNull ( result . getFragment (  )  )  ;", "String   url    =     \" http :  /  / arjen : foobar @ com :  8  0  \"     +     \"  / javase /  6  / docs / api / java / util / BitSet . html ? foo = bar # and ( BitSet )  \"  ;", "result    =    UriComponentsBuilder . fromUriString ( url )  . build (  )  ;", "assertEquals (  \" http \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \" arjen : foobar \"  ,    result . getUserInfo (  )  )  ;", "assertEquals (  \" com \"  ,    result . getHost (  )  )  ;", "assertEquals (  8  0  ,    result . getPort (  )  )  ;", "assertEquals (  \"  / javase /  6  / docs / api / java / util / BitSet . html \"  ,    result . getPath (  )  )  ;", "assertEquals (  \" foo = bar \"  ,    result . getQuery (  )  )  ;", "MultiValueMap < String ,    String >    expectedQueryParams    =    new   LinkedMultiValueMap (  1  )  ;", "expectedQueryParams . add (  \" foo \"  ,     \" bar \"  )  ;", "assertEquals ( expectedQueryParams ,    result . getQueryParams (  )  )  ;", "assertEquals (  \" and ( BitSet )  \"  ,    result . getFragment (  )  )  ;", "result    =    UriComponentsBuilder . fromUriString (  \" mailto : java - net @ com # baz \"  )  . build (  )  ;", "assertEquals (  \" mailto \"  ,    result . getScheme (  )  )  ;", "assertNull ( result . getUserInfo (  )  )  ;", "assertNull ( result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "assertEquals (  \" java - net @ com \"  ,    result . getSchemeSpecificPart (  )  )  ;", "assertNull ( result . getPath (  )  )  ;", "assertNull ( result . getQuery (  )  )  ;", "assertEquals (  \" baz \"  ,    result . getFragment (  )  )  ;", "result    =    UriComponentsBuilder . fromUriString (  \" docs / guide / collections / designfaq . html #  2  8  \"  )  . build (  )  ;", "assertNull ( result . getScheme (  )  )  ;", "assertNull ( result . getUserInfo (  )  )  ;", "assertNull ( result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "assertEquals (  \" docs / guide / collections / designfaq . html \"  ,    result . getPath (  )  )  ;", "assertNull ( result . getQuery (  )  )  ;", "assertEquals (  \"  2  8  \"  ,    result . getFragment (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromUriString"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   result    =    UriComponentsBuilder . fromUriString (  \" http :  /  /  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  :  8  0  8  0  / resource \"  )  . build (  )  . encode (  )  ;", "assertEquals (  \"  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  \"  ,    result . getHost (  )  )  ;", "UriComponents   resultWithScopeId    =    UriComponentsBuilder . fromUriString (  \" http :  /  /  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc % eth 0  ]  :  8  0  8  0  / resource \"  )  . build (  )  . encode (  )  ;", "assertEquals (  \"  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc %  2  5 eth 0  ]  \"  ,    resultWithScopeId . getHost (  )  )  ;", "UriComponents   resultIPv 4 compatible    =    UriComponentsBuilder . fromUriString (  \" http :  /  /  [  :  :  1  9  2  .  1  6  8  .  1  .  1  ]  :  8  0  8  0  / resource \"  )  . build (  )  . encode (  )  ;", "assertEquals (  \"  [  :  :  1  9  2  .  1  6  8  .  1  .  1  ]  \"  ,    resultIPv 4 compatible . getHost (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromUriStringIPv6Host"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   result    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com ? foo = bar @ baz \"  )  . build (  )  ;", "assertTrue ( StringUtils . isEmpty ( result . getUserInfo (  )  )  )  ;", "assertEquals (  \" example . com \"  ,    result . getHost (  )  )  ;", "assertTrue ( result . getQueryParams (  )  . containsKey (  \" foo \"  )  )  ;", "assertEquals (  \" bar @ baz \"  ,    result . getQueryParams (  )  . getFirst (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["fromUriStringNoPathWithReservedCharInQuery"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   httpUrl    =     \" http :  /  / localhost :  8  0  8  0  / test / print ? value =  % EA % B 0  %  8  0  +  % EB %  8  2  %  9  8  \"  ;", "URI   uri    =     . fromHttpUrl ( httpUrl )  . build ( true )  . toUri (  )  ;", "assertEquals ( httpUrl ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromUriStringQueryParamEncodedAndContainingPlus"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   uri    =     \" http :  /  / www . google . com / ig / calculator ? q =  1 USD =  ? EUR \"  ;", "UriComponents   result    =     . fromUriString ( uri )  . build (  )  ;", "assertEquals (  \" q =  1 USD =  ? EUR \"  ,    result . getQuery (  )  )  ;", "assertEquals (  \"  1 USD =  ? EUR \"  ,    result . getQueryParams (  )  . getFirst (  \" q \"  )  )  ;", "}", "METHOD_END"], "methodName": ["fromUriStringQueryParamWithReservedCharInValue"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  . scheme (  \" http \"  )  . host (  \" example . com \"  )  . pathSegment (  \" foo \"  )  ;", "UriComponents   result 1     =    builder . build (  )  ;", "builder    =    builder . pathSegment (  \" foo 2  \"  )  . queryParam (  \" bar \"  )  . fragment (  \" baz \"  )  ;", "UriComponents   result 2     =    builder . build (  )  ;", "assertEquals (  \" http \"  ,    result 1  . getScheme (  )  )  ;", "assertEquals (  \" example . com \"  ,    result 1  . getHost (  )  )  ;", "assertEquals (  \"  / foo \"  ,    result 1  . getPath (  )  )  ;", "URI   expected    =    new   URI (  \" http :  /  / example . com / foo \"  )  ;", "assertEquals (  \" Invalid   result   URI \"  ,    expected ,    result 1  . toUri (  )  )  ;", "assertEquals (  \" http \"  ,    result 2  . getScheme (  )  )  ;", "assertEquals (  \" example . com \"  ,    result 2  . getHost (  )  )  ;", "assertEquals (  \"  / foo / foo 2  \"  ,    result 2  . getPath (  )  )  ;", "assertEquals (  \" bar \"  ,    result 2  . getQuery (  )  )  ;", "assertEquals (  \" baz \"  ,    result 2  . getFragment (  )  )  ;", "expected    =    new   URI (  \" http :  /  / example . com / foo / foo 2  ? bar # baz \"  )  ;", "assertEquals (  \" Invalid   result   URI \"  ,    expected ,    result 2  . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleFromSameBuilder"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   components    =    UriComponentsBuilder . fromUriString (  \"  / example #  \"  )  . build (  )  ;", "assertThat ( components . getFragment (  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( components . toString (  )  ,    equalTo (  \"  / example \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parsesEmptyFragment"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   components    =    UriComponentsBuilder . fromUriString (  \"  \"  )  . build (  )  ;", "assertThat ( components . toString (  )  ,    equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parsesEmptyUri"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . fromPath (  \"  / foo / bar \"  )  ;", "UriComponents   result    =    builder . build (  )  ;", "assertEquals (  \"  / foo / bar \"  ,    result . getPath (  )  )  ;", "assertEquals ( Arrays . asList (  \" foo \"  ,     \" bar \"  )  ,    result . getPathSegments (  )  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  ;", "UriComponents   result    =    builder . pathSegment (  \" foo \"  )  . pathSegment (  \" bar \"  )  . build (  )  ;", "assertEquals (  \"  / foo / bar \"  ,    result . getPath (  )  )  ;", "assertEquals ( Arrays . asList (  \" foo \"  ,     \" bar \"  )  ,    result . getPathSegments (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathSegments"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  . pathSegment (  \"  \"  ,     \" foo \"  ,     \"  \"  ,     \" bar \"  )  ;", "UriComponents   result    =    builder . build (  )  ;", "assertEquals (  \"  / foo / bar \"  ,    result . getPath (  )  )  ;", "assertEquals ( Arrays . asList (  \" foo \"  ,     \" bar \"  )  ,    result . getPathSegments (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathSegmentsSomeEmpty"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  . pathSegment (  \" foo \"  )  . path (  \"  /  \"  )  ;", "UriComponents   result    =    builder . build (  )  ;", "assertEquals (  \"  / foo /  \"  ,    result . getPath (  )  )  ;", "assertEquals ( Collections . singletonList (  \" foo \"  )  ,    result . getPathSegments (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathSegmentsThenPath"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  . pathSegment (  \" foo \"  )  . pathSegment (  \" bar \"  )  ;", "UriComponents   result    =    builder . build (  )  ;", "assertEquals (  \"  / foo / bar \"  ,    result . getPath (  )  )  ;", "assertEquals ( Arrays . asList (  \" foo \"  ,     \" bar \"  )  ,    result . getPathSegments (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathSegmentsThenPathSegments"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . fromPath (  \"  / foo / bar \"  )  . path (  \" ba / z \"  )  ;", "UriComponents   result    =    builder . build (  )  . encode (  )  ;", "assertEquals (  \"  / foo / barba / z \"  ,    result . getPath (  )  )  ;", "assertEquals ( Arrays . asList (  \" foo \"  ,     \" barba \"  ,     \" z \"  )  ,    result . getPathSegments (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathThenPath"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . fromPath (  \"  / foo / bar \"  )  . pathSegment (  \" ba / z \"  )  ;", "UriComponents   result    =    builder . build (  )  . encode (  )  ;", "assertEquals (  \"  / foo / bar / ba %  2 Fz \"  ,    result . getPath (  )  )  ;", "assertEquals ( Arrays . asList (  \" foo \"  ,     \" bar \"  ,     \" ba %  2 Fz \"  )  ,    result . getPathSegments (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathThenPathSegments"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromPath (  \"  / foo /  /  /  /  /  /  /  /  / bar \"  )  . build (  )  ;", "assertEquals (  \"  / foo / bar \"  ,    uriComponents . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathWithDuplicateSlashes"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  ;", "UriComponents   result    =    builder . scheme (  \" http \"  )  . host (  \" example . com \"  )  . path (  \" foo \"  )  . queryParam (  \" bar \"  )  . fragment (  \" baz \"  )  . build (  )  ;", "assertEquals (  \" http \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \" example . com \"  ,    result . getHost (  )  )  ;", "assertEquals (  \" foo \"  ,    result . getPath (  )  )  ;", "assertEquals (  \" bar \"  ,    result . getQuery (  )  )  ;", "assertEquals (  \" baz \"  ,    result . getFragment (  )  )  ;", "URI   expected    =    new   URI (  \" http :  /  / example . com / foo ? bar # baz \"  )  ;", "assertEquals (  \" Invalid   result   URI \"  ,    expected ,    result . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["plain"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / foo ? bar = baz \"  )  . build (  )  ;", "assertThat ( uriComponents . toUriString (  )  ,    equalTo (  \" http :  /  / example . com / foo ? bar = baz \"  )  )  ;", "assertThat ( uriComponents . getQueryParams (  )  . get (  \" bar \"  )  . get (  0  )  ,    equalTo (  \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamWithValueWithEquals"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / foo ? bar =  \"  )  . build (  )  ;", "assertThat ( uriComponents . toUriString (  )  ,    equalTo (  \" http :  /  / example . com / foo ? bar =  \"  )  )  ;", "assertThat ( uriComponents . getQueryParams (  )  . get (  \" bar \"  )  . get (  0  )  ,    equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamWithoutValueWithEquals"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / foo ? bar \"  )  . build (  )  ;", "assertThat ( uriComponents . toUriString (  )  ,    equalTo (  \" http :  /  / example . com / foo ? bar \"  )  )  ;", "assertThat ( uriComponents . getQueryParams (  )  . get (  \" bar \"  )  . get (  0  )  ,    equalTo ( null )  )  ;", "}", "METHOD_END"], "methodName": ["queryParamWithoutValueWithoutEquals"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  ;", "UriComponents   result    =    builder . queryParam (  \" baz \"  ,     \" qux \"  ,     4  2  )  . build (  )  ;", "assertEquals (  \" baz = qux & baz =  4  2  \"  ,    result . getQuery (  )  )  ;", "MultiValueMap < String ,    String >    expectedQueryParams    =    new   LinkedMultiValueMap (  2  )  ;", "expectedQueryParams . add (  \" baz \"  ,     \" qux \"  )  ;", "expectedQueryParams . add (  \" baz \"  ,     \"  4  2  \"  )  ;", "assertEquals ( expectedQueryParams ,    result . getQueryParams (  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParams"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   baseUrl    =     \" http :  /  / example . com \"  ;", "assertThat (  . fromUriString (  ( baseUrl    +     \"  / foo /  .  .  / bar \"  )  )  . build (  )  . toString (  )  ,    equalTo (  ( baseUrl    +     \"  / foo /  .  .  / bar \"  )  )  )  ;", "assertThat (  . fromUriString (  ( baseUrl    +     \"  / foo /  .  .  / bar \"  )  )  . build (  )  . toUriString (  )  ,    equalTo (  ( baseUrl    +     \"  / foo /  .  .  / bar \"  )  )  )  ;", "assertThat (  . fromUriString (  ( baseUrl    +     \"  / foo /  .  .  / bar \"  )  )  . build (  )  . toUri (  )  . getPath (  )  ,    equalTo (  \"  / foo /  .  .  / bar \"  )  )  ;", "assertThat (  . fromUriString (  \"  .  .  /  .  .  /  \"  )  . build (  )  . toString (  )  ,    equalTo (  \"  .  .  /  .  .  /  \"  )  )  ;", "assertThat (  . fromUriString (  \"  .  .  /  .  .  /  \"  )  . build (  )  . toUriString (  )  ,    equalTo (  \"  .  .  /  .  .  /  \"  )  )  ;", "assertThat (  . fromUriString (  \"  .  .  /  .  .  /  \"  )  . build (  )  . toUri (  )  . getPath (  )  ,    equalTo (  \"  .  .  /  .  .  /  \"  )  )  ;", "assertThat (  . fromUriString ( baseUrl )  . path (  \" foo /  .  .  / bar \"  )  . build (  )  . toString (  )  ,    equalTo (  ( baseUrl    +     \"  / foo /  .  .  / bar \"  )  )  )  ;", "assertThat (  . fromUriString ( baseUrl )  . path (  \" foo /  .  .  / bar \"  )  . build (  )  . toUriString (  )  ,    equalTo (  ( baseUrl    +     \"  / foo /  .  .  / bar \"  )  )  )  ;", "assertThat (  . fromUriString ( baseUrl )  . path (  \" foo /  .  .  / bar \"  )  . build (  )  . toUri (  )  . getPath (  )  ,    equalTo (  \"  / foo /  .  .  / bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["relativeUrls"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . fromUriString (  \" http :  /  / www . ietf . org / rfc / rfc 2  3  9  6  . txt \"  )  ;", "builder . replacePath (  \"  / rfc / rfc 3  9  8  6  . txt \"  )  ;", "UriComponents   result    =    builder . build (  )  ;", "assertEquals (  \" http :  /  / www . ietf . org / rfc / rfc 3  9  8  6  . txt \"  ,    result . toUriString (  )  )  ;", "builder    =    UriComponentsBuilder . fromUriString (  \" http :  /  / www . ietf . org / rfc / rfc 2  3  9  6  . txt \"  )  ;", "builder . replacePath ( null )  ;", "result    =    builder . build (  )  ;", "assertEquals (  \" http :  /  / www . ietf . org \"  ,    result . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["replacePath"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / foo ? foo = bar & baz = qux \"  )  ;", "builder . replaceQuery (  \" baz =  4  2  \"  )  ;", "UriComponents   result    =    builder . build (  )  ;", "assertEquals (  \" http :  /  / example . com / foo ? baz =  4  2  \"  ,    result . toUriString (  )  )  ;", "builder    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / foo ? foo = bar & baz = qux \"  )  ;", "builder . replaceQuery ( null )  ;", "result    =    builder . build (  )  ;", "assertEquals (  \" http :  /  / example . com / foo \"  ,    result . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["replaceQuery"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder    =    UriComponentsBuilder . newInstance (  )  . queryParam (  \" baz \"  ,     \" qux \"  ,     4  2  )  ;", "builder . replaceQueryParam (  \" baz \"  ,     \" xuq \"  ,     2  4  )  ;", "UriComponents   result    =    builder . build (  )  ;", "assertEquals (  \" baz = xuq & baz =  2  4  \"  ,    result . getQuery (  )  )  ;", "builder    =    UriComponentsBuilder . newInstance (  )  . queryParam (  \" baz \"  ,     \" qux \"  ,     4  2  )  ;", "builder . replaceQueryParam (  \" baz \"  )  ;", "result    =    builder . build (  )  ;", "assertNull (  \" Query   param   should   have   been   deleted \"  ,    result . getQuery (  )  )  ;", "}", "METHOD_END"], "methodName": ["replaceQueryParam"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder   builder 1     =    UriComponentsBuilder . newInstance (  )  ;", "builder 1  . scheme (  \" http \"  )  . host (  \" e 1  . com \"  )  . path (  \"  / p 1  \"  )  . pathSegment (  \" ps 1  \"  )  . queryParam (  \" q 1  \"  )  . fragment (  \" f 1  \"  )  ;", "UriComponentsBuilder   builder 2     =     (  ( UriComponentsBuilder )     ( builder 1  . clone (  )  )  )  ;", "builder 2  . scheme (  \" https \"  )  . host (  \" e 2  . com \"  )  . path (  \" p 2  \"  )  . pathSegment (  \" ps 2  \"  )  . queryParam (  \" q 2  \"  )  . fragment (  \" f 2  \"  )  ;", "UriComponents   result 1     =    builder 1  . build (  )  ;", "assertEquals (  \" http \"  ,    result 1  . getScheme (  )  )  ;", "assertEquals (  \" e 1  . com \"  ,    result 1  . getHost (  )  )  ;", "assertEquals (  \"  / p 1  / ps 1  \"  ,    result 1  . getPath (  )  )  ;", "assertEquals (  \" q 1  \"  ,    result 1  . getQuery (  )  )  ;", "assertEquals (  \" f 1  \"  ,    result 1  . getFragment (  )  )  ;", "UriComponents   result 2     =    builder 2  . build (  )  ;", "assertEquals (  \" https \"  ,    result 2  . getScheme (  )  )  ;", "assertEquals (  \" e 2  . com \"  ,    result 2  . getHost (  )  )  ;", "assertEquals (  \"  / p 1  / ps 1  / p 2  / ps 2  \"  ,    result 2  . getPath (  )  )  ;", "assertEquals (  \" q 1  & q 2  \"  ,    result 2  . getQuery (  )  )  ;", "assertEquals (  \" f 2  \"  ,    result 2  . getFragment (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClone"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uri 1     =    UriComponentsBuilder . fromUriString (  \" http :  /  / test . com \"  )  . build (  )  . normalize (  )  ;", "UriComponents   uri 2     =    UriComponentsBuilder . fromUriString (  \" http :  /  / test . com /  \"  )  . build (  )  ;", "assertTrue ( uri 1  . getPathSegments (  )  . isEmpty (  )  )  ;", "assertTrue ( uri 2  . getPathSegments (  )  . isEmpty (  )  )  ;", "assertNotEquals ( uri 1  ,    uri 2  )  ;", "}", "METHOD_END"], "methodName": ["uriComponentsNotEqualAfterNormalization"], "fileName": "org.springframework.web.util.UriComponentsBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   source    =    UriComponentsBuilder . fromPath (  \"  / foo / bar \"  )  . pathSegment (  \" ba / z \"  )  . build (  )  ;", "UriComponentsBuilder   targetBuilder    =    UriComponentsBuilder . newInstance (  )  ;", "source . copyToUriComponentsBuilder ( targetBuilder )  ;", "UriComponents   result    =    targetBuilder . build (  )  . encode (  )  ;", "assertEquals (  \"  / foo / bar / ba %  2 Fz \"  ,    result . getPath (  )  )  ;", "assertEquals ( Arrays . asList (  \" foo \"  ,     \" bar \"  ,     \" ba %  2 Fz \"  )  ,    result . getPathSegments (  )  )  ;", "}", "METHOD_END"], "methodName": ["copyToUriComponentsBuilder"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromPath (  \"  / hotel   list \"  )  . build (  )  ;", "UriComponents   encoded    =    uriComponents . encode (  )  ;", "assertEquals (  \"  / hotel %  2  0 list \"  ,    encoded . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / example . com \"  ;", "uric 1     =    Builder . fromUriString ( url )  . path (  \"  /  { foo }  \"  )  . query (  \" bar =  { baz }  \"  )  . build (  )  ;", "uric 2     =    Builder . fromUriString ( url )  . path (  \"  /  { foo }  \"  )  . query (  \" bar =  { baz }  \"  )  . build (  )  ;", "uric 3     =    Builder . fromUriString ( url )  . path (  \"  /  { foo }  \"  )  . query (  \" bin =  { baz }  \"  )  . build (  )  ;", "assertThat ( uric 1  ,    instanceOf ( Hierarchical . class )  )  ;", "assertThat ( uric 1  ,    equalTo ( uric 1  )  )  ;", "assertThat ( uric 1  ,    equalTo ( uric 2  )  )  ;", "assertThat ( uric 1  ,    not ( equalTo ( uric 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsHierarchicalUriComponents"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "String   baseUrl    =     \" http : example . com \"  ;", "uric 1     =    Builder . fromUriString (  ( baseUrl    +     \"  / foo / bar \"  )  )  . build (  )  ;", "uric 2     =    Builder . fromUriString (  ( baseUrl    +     \"  / foo / bar \"  )  )  . build (  )  ;", "uric 3     =    Builder . fromUriString (  ( baseUrl    +     \"  / foo / bin \"  )  )  . build (  )  ;", "assertThat ( uric 1  ,    instanceOf ( Opaque . class )  )  ;", "assertThat ( uric 1  ,    equalTo ( uric 1  )  )  ;", "assertThat ( uric 1  ,    equalTo ( uric 2  )  )  ;", "assertThat ( uric 1  ,    not ( equalTo ( uric 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsOpaqueUriComponents"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com \"  )  . path (  \"  /  { foo }     { bar }  \"  )  . build (  )  ;", "uriComponents    =    uriComponents . expand (  \"  1     2  \"  ,     \"  3     4  \"  )  ;", "assertEquals (  \"  /  1     2     3     4  \"  ,    uriComponents . getPath (  )  )  ;", "assertEquals (  \" http :  /  / example . com /  1     2     3     4  \"  ,    uriComponents . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder . fromPath (  \"  /  { foo }  \"  )  . build (  )  . encode (  )  . expand (  \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["expandEncoded"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "String   template    =     \"  / myurl /  { name :  [ a - z ]  {  1  ,  5  }  }  / show \"  ;", "uriComponents    =    Builder . fromUriString ( template )  . build (  )  ;", "uriComponents    =    uriComponents . expand ( Collections . singletonMap (  \" name \"  ,     \" test \"  )  )  ;", "assertEquals (  \"  / myurl / test / show \"  ,    uriComponents . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["expandWithRegexVar"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder . fromPath (  \"  /  { foo }  \"  )  . build ( true )  ;", "}", "METHOD_END"], "methodName": ["invalidCharacters"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponentsBuilder . fromPath (  \"  / fo %  2 o \"  )  . build ( true )  ;", "}", "METHOD_END"], "methodName": ["invalidEncodedSequence"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / foo /  .  .  / bar \"  )  . build (  )  ;", "assertEquals (  \" http :  /  / example . com / bar \"  ,    uriComponents . normalize (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["normalize"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uri 1     =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com :  8  0  8  0  / bar \"  )  . build (  )  ;", "UriComponents   uri 2     =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / bar \"  )  . port (  8  0  8  0  )  . build (  )  ;", "UriComponents   uri 3     =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / bar \"  )  . port (  \"  { port }  \"  )  . build (  )  . expand (  8  0  8  0  )  ;", "UriComponents   uri 4     =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / bar \"  )  . port (  \"  8  0  8  { digit }  \"  )  . build (  )  . expand (  0  )  ;", "assertEquals (  8  0  8  0  ,    uri 1  . getPort (  )  )  ;", "assertEquals (  \" http :  /  / example . com :  8  0  8  0  / bar \"  ,    uri 1  . toUriString (  )  )  ;", "assertEquals (  8  0  8  0  ,    uri 2  . getPort (  )  )  ;", "assertEquals (  \" http :  /  / example . com :  8  0  8  0  / bar \"  ,    uri 2  . toUriString (  )  )  ;", "assertEquals (  8  0  8  0  ,    uri 3  . getPort (  )  )  ;", "assertEquals (  \" http :  /  / example . com :  8  0  8  0  / bar \"  ,    uri 3  . toUriString (  )  )  ;", "assertEquals (  8  0  8  0  ,    uri 4  . getPort (  )  )  ;", "assertEquals (  \" http :  /  / example . com :  8  0  8  0  / bar \"  ,    uri 4  . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["port"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com \"  )  . path (  \"  /  { foo }  \"  )  . query (  \" bar =  { baz }  \"  )  . build (  )  ;", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( bos )  ;", "oos . writeObject ( uriComponents )  ;", "ObjectInputStream   ois    =    new   ObjectInputStream ( new   ByteArrayInputStream ( bos . toByteArray (  )  )  )  ;", "UriComponents   readObject    =     (  ( UriComponents )     ( ois . readObject (  )  )  )  ;", "assertThat ( uriComponents . toString (  )  ,    equalTo ( readObject . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["serializable"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / hotel %  2  0 list / Z % C 3  % BCrich \"  )  . build ( true )  ;", "UriComponents   encoded    =    uriComponents . encode (  )  ;", "assertEquals ( new   URI (  \" http :  /  / example . com / hotel %  2  0 list / Z % C 3  % BCrich \"  )  ,    encoded . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["toUriAlreadyEncoded"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / hotel   list / Z \\ u 0  0 fcrich \"  )  . build (  )  ;", "assertEquals ( new   URI (  \" http :  /  / example . com / hotel %  2  0 list / Z % C 3  % BCrich \"  )  ,    uriComponents . encode (  )  . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["toUriEncoded"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  / example . com / hotel   list / Z \\ u 0  0 fcrich \"  )  . build (  )  ;", "assertEquals ( new   URI (  \" http :  /  / example . com / hotel %  2  0 list / Z \\ u 0  0 fcrich \"  )  ,    uriComponents . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["toUriNotEncoded"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   uriComponents    =    UriComponentsBuilder . fromUriString (  \" http :  /  /  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  :  8  0  8  0  / hotel %  2  0 list / Z % C 3  % BCrich \"  )  . build ( true )  ;", "UriComponents   encoded    =    uriComponents . encode (  )  ;", "assertEquals ( new   URI (  \" http :  /  /  [  1 abc :  2 abc :  3 abc :  :  5 ABC :  6 abc ]  :  8  0  8  0  / hotel %  2  0 list / Z % C 3  % BCrich \"  )  ,    encoded . toUri (  )  )  ;", "}", "METHOD_END"], "methodName": ["toUriWithIpv6HostAlreadyEncoded"], "fileName": "org.springframework.web.util.UriComponentsTests"}, {"methodBody": ["METHOD_START", "{", "UriComponents   expandedComponents    =    this . uriComponents . expand ( uriVariableValues )  ;", "UriComponents   encodedComponents    =    expandedComponents . encode (  )  ;", "return   encodedComponents . toUri (  )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.web.util.UriTemplate"}, {"methodBody": ["METHOD_START", "{", "UriComponents   expandedComponents    =    this . uriComponents . expand ( uriVariables )  ;", "UriComponents   encodedComponents    =    expandedComponents . encode (  )  ;", "return   encodedComponents . toUri (  )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.web.util.UriTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . variableNames ;", "}", "METHOD_END"], "methodName": ["getVariableNames"], "fileName": "org.springframework.web.util.UriTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uri ,     \"  ' uri '    must   not   be   null \"  )  ;", "Map < St ,    St >    result    =    new   LinkedHashMap <  >  ( this . variableNames . size (  )  )  ;", "Matcher   matcher    =    this . matchPattern . matcher ( uri )  ;", "if    ( matcher . find (  )  )     {", "for    ( int   i    =     1  ;    i    <  =     ( matcher . groupCount (  )  )  ;    i +  +  )     {", "St   name    =    this . variableNames . get (  ( i    -     1  )  )  ;", "St   value    =    matcher . group ( i )  ;", "result . put ( name ,    value )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.web.util.UriTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( uri    =  =    null )     {", "return   false ;", "}", "Matcher   matcher    =    this . matchPattern . matcher ( uri )  ;", "return   matcher . matches (  )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.springframework.web.util.UriTemplate"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / hotel   list /  { hotel }  \"  )  ;", "URI   result    =    template . expand (  \" Z \\ u 0  0 fcrich \"  )  ;", "assertEquals (  \" Invalid   expanded   template \"  ,    new   URI (  \"  / hotel %  2  0 list / Z % C 3  % BCrich \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["expandEncoded"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    uriVariables    =    new   HashMap <  >  (  2  )  ;", "uriVariables . put (  \" booking \"  ,     \"  4  2  \"  )  ;", "uriVariables . put (  \" hotel \"  ,     \"  1  \"  )  ;", "template    =    new    (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ;", "URI   result    =    template . expand ( uriVariables )  ;", "assertEquals (  \" Invalid   expanded   template \"  ,    new   URI (  \"  / hotels /  1  / bookings /  4  2  \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["expandMap"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / order /  { c }  /  { c }  /  { c }  \"  )  ;", "assertEquals ( Arrays . asList (  \" c \"  ,     \" c \"  ,     \" c \"  )  ,    template . getVariableNames (  )  )  ;", "URI   result    =    template . expand ( Collections . singletonMap (  \" c \"  ,     \" cheeseburger \"  )  )  ;", "assertEquals ( new   URI (  \"  / order / cheeseburger / cheeseburger / cheeseburger \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["expandMapDuplicateVariables"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    uriVariables    =    Collections . singletonMap (  \" hotel \"  ,     \" Z \\ u 0  0 fcrich \"  )  ;", "template    =    new    (  \"  / hotel   list /  { hotel }  \"  )  ;", "URI   result    =    template . expand ( uriVariables )  ;", "assertEquals (  \" Invalid   expanded   template \"  ,    new   URI (  \"  / hotel %  2  0 list / Z % C 3  % BCrich \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["expandMapEncoded"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Integer >    uriVariables    =    new   HashMap <  >  (  2  )  ;", "uriVariables . put (  \" booking \"  ,     4  2  )  ;", "uriVariables . put (  \" hotel \"  ,     1  )  ;", "template    =    new    (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ;", "URI   result    =    template . expand ( uriVariables )  ;", "assertEquals (  \" Invalid   expanded   template \"  ,    new   URI (  \"  / hotels /  1  / bookings /  4  2  \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["expandMapNonString"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    uriVariables    =    new   HashMap <  >  (  2  )  ;", "uriVariables . put (  \" booking \"  ,     \"  4  2  \"  )  ;", "uriVariables . put (  \" bar \"  ,     \"  1  \"  )  ;", "template    =    new    (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ;", "template . expand ( uriVariables )  ;", "}", "METHOD_END"], "methodName": ["expandMapUnboundVariables"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ;", "URI   result    =    template . expand (  \"  1  \"  ,     \"  4  2  \"  )  ;", "assertEquals (  \" Invalid   expanded   template \"  ,    new   URI (  \"  / hotels /  1  / bookings /  4  2  \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["expandVarArgs"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ;", "template . expand (  \"  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["expandVarArgsNotEnoughVariables"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / sum ? numbers =  { numbers }  \"  )  ;", "URI   result    =    template . expand ( new   int [  ]  {     1  ,     2  ,     3     }  )  ;", "assertEquals ( new   URI (  \"  / sum ? numbers =  1  ,  2  ,  3  \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["expandVarArgsWithArrayValue"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \" http :  /  / localhost / query =  { query }  \"  )  ;", "URI   uri    =    template . expand (  \" foo @ bar \"  )  ;", "assertEquals (  \" http :  /  / localhost / query = foo @ bar \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["expandWithAtSign"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  /  { a }  \"  )  ;", "URI   uri    =    template . expand (  \"  $ replacement \"  )  ;", "assertEquals (  \"  /  $ replacement \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["expandWithDollar"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / search #  { fragment }  \"  )  ;", "assertTrue ( template . matches (  \"  / search # foo \"  )  )  ;", "template    =    new   UriTemplate (  \"  / search ? query =  { query }  #  { fragment }  \"  )  ;", "assertTrue ( template . matches (  \"  / search ? query = foo # bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["fragments"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ;", "List < String >    variableNames    =    template . getVariableNames (  )  ;", "assertEquals (  \" Invalid   variable   names \"  ,    Arrays . asList (  \" hotel \"  ,     \" booking \"  )  ,    variableNames )  ;", "}", "METHOD_END"], "methodName": ["getVariableNames"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    expected    =    new   HashMap <  >  (  2  )  ;", "expected . put (  \" booking \"  ,     \"  4  2  \"  )  ;", "expected . put (  \" hotel \"  ,     \"  1  \"  )  ;", "template    =    new    (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ;", "Map < String ,    String >    result    =    template . match (  \"  / hotels /  1  / bookings /  4  2  \"  )  ;", "assertEquals (  \" Invalid   match \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    expected    =    new   HashMap <  >  (  2  )  ;", "expected . put (  \" booking \"  ,     \"  4  2  \"  )  ;", "expected . put (  \" hotel \"  ,     \"  1  \"  )  ;", "template    =    new    (  \"  / hotels /  { hotel :  \\  \\ d }  / bookings /  { booking :  \\  \\ d +  }  \"  )  ;", "Map < String ,    String >    result    =    template . match (  \"  / hotels /  1  / bookings /  4  2  \"  )  ;", "assertEquals (  \" Invalid   match \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["matchCustomRegex"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / site .  { domain : co .  [ a - z ]  {  2  }  }  \"  )  ;", "Map < String ,    String >    result    =    template . match (  \"  / site . co . eu \"  )  ;", "assertEquals (  \" Invalid   match \"  ,    Collections . singletonMap (  \" domain \"  ,     \" co . eu \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["matchCustomRegexWithNestedCurlyBraces"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / order /  { c }  /  { c }  /  { c }  \"  )  ;", "Map < String ,    String >    result    =    template . match (  \"  / order / cheeseburger / cheeseburger / cheeseburger \"  )  ;", "Map < String ,    String >    expected    =    Collections . singletonMap (  \" c \"  ,     \" cheeseburger \"  )  ;", "assertEquals (  \" Invalid   match \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["matchDuplicate"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  /  { foo }  -  { bar }  \"  )  ;", "Map < String ,    String >    result    =    template . match (  \"  /  1  2  -  3  4  \"  )  ;", "Map < String ,    String >    expected    =    new   HashMap <  >  (  2  )  ;", "expected . put (  \" foo \"  ,     \"  1  2  \"  )  ;", "expected . put (  \" bar \"  ,     \"  3  4  \"  )  ;", "assertEquals (  \" Invalid   match \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["matchMultipleInOneSegment"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / account /  { accountId }  \"  )  ;", "assertFalse ( template . matches (  \"  / account /  1  5  / alias /  5  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["matchWithMultipleSegmentsAtTheEnd"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ;", "assertTrue (  \" UriTemplate   does   not   match \"  ,    template . matches (  \"  / hotels /  1  / bookings /  4  2  \"  )  )  ;", "assertFalse (  \" UriTemplate   matches \"  ,    template . matches (  \"  / hotels / bookings \"  )  )  ;", "assertFalse (  \" UriTemplate   matches \"  ,    template . matches (  \"  \"  )  )  ;", "assertFalse (  \" UriTemplate   matches \"  ,    template . matches ( null )  )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / hotels /  { hotel :  \\  \\ d +  }  \"  )  ;", "assertTrue (  \" UriTemplate   does   not   match \"  ,    template . matches (  \"  / hotels /  4  2  \"  )  )  ;", "assertFalse (  \" UriTemplate   matches \"  ,    template . matches (  \"  / hotels / foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["matchesCustomRegex"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   uriTemplate    =    new   UriTemplate (  \"  / test /  \"  )  ;", "assertTrue ( uriTemplate . matches (  \"  / test /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["matchesWithSlashAtTheEnd"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "UriTemplate   template    =    new   UriTemplate (  \"  / search ? q =  { query }  \"  )  ;", "assertTrue ( template . matches (  \"  / search ? q = foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryVariables"], "fileName": "org.springframework.web.util.UriTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . uriDecode ( source ,    Charset . forName ( encoding )  )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . uriDecode ( source ,    charset )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( source ,    encoding ,    HierarchicalUriComponents . Type . URI )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   HierarchicalUriComponents . encodeUriComponent ( scheme ,    encoding ,    type )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( source ,    charset ,    HierarchicalUriComponents . Type . URI )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   HierarchicalUriComponents . encodeUriComponent ( scheme ,    charset ,    type )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( authority ,    encoding ,    HierarchicalUriComponents . Type . AUTHORITY )  ;", "}", "METHOD_END"], "methodName": ["encodeAuthority"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( authority ,    charset ,    HierarchicalUriComponents . Type . AUTHORITY )  ;", "}", "METHOD_END"], "methodName": ["encodeAuthority"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( fragment ,    encoding ,    HierarchicalUriComponents . Type . FRAGMENT )  ;", "}", "METHOD_END"], "methodName": ["encodeFragment"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( fragment ,    charset ,    HierarchicalUriComponents . Type . FRAGMENT )  ;", "}", "METHOD_END"], "methodName": ["encodeFragment"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( host ,    encoding ,    HierarchicalUriComponents . Type . HOST _ IPV 4  )  ;", "}", "METHOD_END"], "methodName": ["encodeHost"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( host ,    charset ,    HierarchicalUriComponents . Type . HOST _ IPV 4  )  ;", "}", "METHOD_END"], "methodName": ["encodeHost"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( path ,    encoding ,    HierarchicalUriComponents . Type . PATH )  ;", "}", "METHOD_END"], "methodName": ["encodePath"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( path ,    charset ,    HierarchicalUriComponents . Type . PATH )  ;", "}", "METHOD_END"], "methodName": ["encodePath"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( segment ,    encoding ,    HierarchicalUriComponents . Type . PATH _ SEGMENT )  ;", "}", "METHOD_END"], "methodName": ["encodePathSegment"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( segment ,    charset ,    HierarchicalUriComponents . Type . PATH _ SEGMENT )  ;", "}", "METHOD_END"], "methodName": ["encodePathSegment"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( port ,    encoding ,    HierarchicalUriComponents . Type . PORT )  ;", "}", "METHOD_END"], "methodName": ["encodePort"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( port ,    charset ,    HierarchicalUriComponents . Type . PORT )  ;", "}", "METHOD_END"], "methodName": ["encodePort"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( query ,    encoding ,    HierarchicalUriComponents . Type . QUERY )  ;", "}", "METHOD_END"], "methodName": ["encodeQuery"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( query ,    charset ,    HierarchicalUriComponents . Type . QUERY )  ;", "}", "METHOD_END"], "methodName": ["encodeQuery"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( queryParam ,    encoding ,    HierarchicalUriComponents . Type . QUERY _ PARAM )  ;", "}", "METHOD_END"], "methodName": ["encodeQueryParam"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( queryParam ,    charset ,    HierarchicalUriComponents . Type . QUERY _ PARAM )  ;", "}", "METHOD_END"], "methodName": ["encodeQueryParam"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( scheme ,    encoding ,    HierarchicalUriComponents . Type . SCHEME )  ;", "}", "METHOD_END"], "methodName": ["encodeScheme"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( scheme ,    charset ,    HierarchicalUriComponents . Type . SCHEME )  ;", "}", "METHOD_END"], "methodName": ["encodeScheme"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . stream ( uriVariables )  . map (  (    value )     -  >     {", "String   stringValue    =     ( value    !  =    null )     ?    value . toString (  )     :     \"  \"  ;", "return    . encode ( stringValue ,    StandardCharsets . UTF _  8  )  ;", "}  )  . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["encodeUriVariables"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    result    =    new   LinkedHashMap <  >  ( uriVariables . size (  )  )  ;", "uriVariables . forEach (  (    key ,    value )     -  >     {", "String   stringValue    =     ( value    !  =    null )     ?    value . toString (  )     :     \"  \"  ;", "result . put ( key ,     . encode ( stringValue ,    StandardCharsets . UTF _  8  )  )  ;", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["encodeUriVariables"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( userInfo ,    encoding ,    HierarchicalUriComponents . Type . USER _ INFO )  ;", "}", "METHOD_END"], "methodName": ["encodeUserInfo"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( userInfo ,    charset ,    HierarchicalUriComponents . Type . USER _ INFO )  ;", "}", "METHOD_END"], "methodName": ["encodeUserInfo"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "int   end    =    path . indexOf (  '  ?  '  )  ;", "int   fragmentIndex    =    path . indexOf (  '  #  '  )  ;", "if    (  ( fragmentIndex    !  =     (  -  1  )  )     &  &     (  ( end    =  =     (  -  1  )  )     |  |     ( fragmentIndex    <    end )  )  )     {", "end    =    fragmentIndex ;", "}", "if    ( end    =  =     (  -  1  )  )     {", "end    =    path . length (  )  ;", "}", "int   begin    =     ( path . lastIndexOf (  '  /  '  ,    end )  )     +     1  ;", "int   paramIndex    =    path . indexOf (  '  ;  '  ,    begin )  ;", "end    =     (  ( paramIndex    !  =     (  -  1  )  )     &  &     ( paramIndex    <    end )  )     ?    paramIndex    :    end ;", "int   extIndex    =    path . lastIndexOf (  '  .  '  ,    end )  ;", "if    (  ( extIndex    !  =     (  -  1  )  )     &  &     ( extIndex    >    begin )  )     {", "return   path . subst (  ( extIndex    +     1  )  ,    end )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["extractFileExtension"], "fileName": "org.springframework.web.util.UriUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   URI \"  ,     \"  \"  ,    UriUtils . decode (  \"  \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   URI \"  ,     \" foobar \"  ,    UriUtils . decode (  \" foobar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   URI \"  ,     \" foo   bar \"  ,    UriUtils . decode (  \" foo %  2  0 bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   URI \"  ,     \" foo + bar \"  ,    UriUtils . decode (  \" foo %  2 bbar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" T \\ u 0  1  4 dky \\ u 0  1  4 d \"  ,    UriUtils . decode (  \" T % C 5  %  8 Dky % C 5  %  8 D \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \"  / Z \\ u 0  0 fcrich \"  ,    UriUtils . decode (  \"  / Z % C 3  % BCrich \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" T \\ u 0  1  4 dky \\ u 0  1  4 d \"  ,    UriUtils . decode (  \" T \\ u 0  1  4 dky \\ u 0  1  4 d \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "UriUtils . decode (  \" foo %  2  \"  ,    UriUtilsTests . CHARSET )  ;", "}", "METHOD_END"], "methodName": ["decodeInvalidSequence"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar \"  ,    UriUtils . encodeFragment (  \" foobar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foo %  2  0 bar \"  ,    UriUtils . encodeFragment (  \" foo   bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar /  \"  ,    UriUtils . encodeFragment (  \" foobar /  \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodeFragment"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar \"  ,    UriUtils . encodeHost (  \" foobar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foo %  2  0 bar \"  ,    UriUtils . encodeHost (  \" foo   bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodeHost"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \"  / foo / bar \"  ,    UriUtils . encodePath (  \"  / foo / bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \"  / foo %  2  0 bar \"  ,    UriUtils . encodePath (  \"  / foo   bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \"  / Z % C 3  % BCrich \"  ,    UriUtils . encodePath (  \"  / Z \\ u 0  0 fcrich \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodePath"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar \"  ,    UriUtils . encodePathSegment (  \" foobar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \"  %  2 Ffoo %  2 Fbar \"  ,    UriUtils . encodePathSegment (  \"  / foo / bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodePathSegment"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \"  8  0  \"  ,    UriUtils . encodePort (  \"  8  0  \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodePort"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar \"  ,    UriUtils . encodeQuery (  \" foobar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foo %  2  0 bar \"  ,    UriUtils . encodeQuery (  \" foo   bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar /  +  \"  ,    UriUtils . encodeQuery (  \" foobar /  +  \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" T % C 5  %  8 Dky % C 5  %  8 D \"  ,    UriUtils . encodeQuery (  \" T \\ u 0  1  4 dky \\ u 0  1  4 d \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodeQuery"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar \"  ,    UriUtils . encodeQueryParam (  \" foobar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foo %  2  0 bar \"  ,    UriUtils . encodeQueryParam (  \" foo   bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foo %  2  6 bar \"  ,    UriUtils . encodeQueryParam (  \" foo & bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodeQueryParam"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar +  -  .  \"  ,    UriUtils . encodeScheme (  \" foobar +  -  .  \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foo %  2  0 bar \"  ,    UriUtils . encodeScheme (  \" foo   bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodeScheme"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foobar :  \"  ,    UriUtils . encodeUserInfo (  \" foobar :  \"  ,    UriUtilsTests . CHARSET )  )  ;", "assertEquals (  \" Invalid   encoded   result \"  ,     \" foo %  2  0 bar \"  ,    UriUtils . encodeUserInfo (  \" foo   bar \"  ,    UriUtilsTests . CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["encodeUserInfo"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \" index . html \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / index . html \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html #  / a \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html #  / path / a \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html #  / path / a . do \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html # aaa ? bbb \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html # aaa . xml ? bbb \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html ? param = a \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html ? param =  / path / a \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html ? param =  / path / a . do \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html ? param =  / path / a #  / path / a \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products / view . html ? param =  / path / a . do #  / path / a . do \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products ; q =  1  1  / view . html ? param =  / path / a . do \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products ; q =  1  1  / view . html ; r =  2  2  ? param =  / path / a . do \"  )  )  ;", "assertEquals (  \" html \"  ,    UriUtils . extractFileExtension (  \"  / products ; q =  1  1  / view . html ; r =  2  2  ; s =  3  3  ? param =  / path / a . do \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extractFileExtension"], "fileName": "org.springframework.web.util.UriUtilsTests"}, {"methodBody": ["METHOD_START", "{", "uri    =    removeSemicolonContent ( uri )  ;", "uri    =    decodeRequestSt ( request ,    uri )  ;", "uri    =    getSanitizedPath ( uri )  ;", "return   uri ;", "}", "METHOD_END"], "methodName": ["decodeAndCleanUriString"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   enc    =    determineEncoding ( request )  ;", "try    {", "return   UriUtils . decode ( source ,    enc )  ;", "}    catch    ( UnsupportedCharsetException   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  (  (  (  (  \" Could   not   decode   request   string    [  \"     +    source )     +     \"  ]    with   encoding    '  \"  )     +    enc )     +     \"  '  :    falling   back   to   platform   default   encoding ;    exception   message :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "return   URLDecoder . decode ( source )  ;", "}", "}", "METHOD_END"], "methodName": ["decodeInternal"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( this . urlDecode )     {", "return   vars ;", "} else    {", "MultiValueMap < String ,    String >    decodedVars    =    new   util . LinkedMultiValueMap ( vars . size (  )  )  ;", "vars . forEach (  (    key ,    values )     -  >     {", "for    ( String   value    :    values )     {", "decodedVars . add ( key ,    decodeInternal ( request ,    value )  )  ;", "}", "}  )  ;", "return   decodedVars ;", "}", "}", "METHOD_END"], "methodName": ["decodeMatrixVariables"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( this . urlDecode )     {", "return   vars ;", "} else    {", "Map < St ,    St >    decodedVars    =    new   LinkedHashMap <  >  ( vars . size (  )  )  ;", "vars . forEach (  (    key ,    value )     -  >    decodedVars . put ( key ,    decodeInternal ( request ,    value )  )  )  ;", "return   decodedVars ;", "}", "}", "METHOD_END"], "methodName": ["decodePathVariables"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( this . urlDecode )     {", "return   decodeInternal ( request ,    source )  ;", "}", "return   source ;", "}", "METHOD_END"], "methodName": ["decodeRequestString"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   enc    =    request . getCharacterEncoding (  )  ;", "if    ( enc    =  =    null )     {", "enc    =    getDefaultEncoding (  )  ;", "}", "return   enc ;", "}", "METHOD_END"], "methodName": ["determineEncoding"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   contextPath    =     (  ( String )     ( request . getAttribute ( WebUtils . INCLUDE _ CONTEXT _ PATH _ ATTRIBUTE )  )  )  ;", "if    ( contextPath    =  =    null )     {", "contextPath    =    request . getContextPath (  )  ;", "}", "if    (  \"  /  \"  . equals ( contextPath )  )     {", "contextPath    =     \"  \"  ;", "}", "return   decodeRequestString ( request ,    contextPath )  ;", "}", "METHOD_END"], "methodName": ["getContextPath"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultEncoding ;", "}", "METHOD_END"], "methodName": ["getDefaultEncoding"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( this . alwaysUseFullPath )     {", "return   getPathWithinApplication ( request )  ;", "}", "String   rest    =    getPathWithinServletMapping ( request )  ;", "if    (  !  (  \"  \"  . equals ( rest )  )  )     {", "return   rest ;", "} else    {", "return   getPathWithinApplication ( request )  ;", "}", "}", "METHOD_END"], "methodName": ["getLookupPathForRequest"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   contextPath    =     (  ( String )     ( request . getAttribute ( WebUtils . FORWARD _ CONTEXT _ PATH _ ATTRIBUTE )  )  )  ;", "if    ( contextPath    =  =    null )     {", "contextPath    =    request . getContextPath (  )  ;", "}", "return   decodeRequestString ( request ,    contextPath )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingContextPath"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( request . getAttribute ( WebUtils . FORWARD _ REQUEST _ URI _ ATTRIBUTE )  )     !  =    null )     |  |     (  ( request . getAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  )     !  =    null )  )     {", "return    (  ( St )     ( request . getAttribute ( WebUtils . FORWARD _ QUERY _ STRING _ ATTRIBUTE )  )  )  ;", "} else    {", "return   request . getQuerySt (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getOriginatingQueryString"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   uri    =     (  ( String )     ( request . getAttribute ( UrlPathHelper . WEBSPHERE _ URI _ ATTRIBUTE )  )  )  ;", "if    ( uri    =  =    null )     {", "uri    =     (  ( String )     ( request . getAttribute ( WebUtils . FORWARD _ REQUEST _ URI _ ATTRIBUTE )  )  )  ;", "if    ( uri    =  =    null )     {", "uri    =    request . getRequestURI (  )  ;", "}", "}", "return   decodeAndCleanUriString ( request ,    uri )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingRequestUri"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   servletPath    =     (  ( String )     ( request . getAttribute ( WebUtils . FORWARD _ SERVLET _ PATH _ ATTRIBUTE )  )  )  ;", "if    ( servletPath    =  =    null )     {", "servletPath    =    request . getServletPath (  )  ;", "}", "return   servletPath ;", "}", "METHOD_END"], "methodName": ["getOriginatingServletPath"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   contextPath    =    getContextPath ( request )  ;", "String   requestUri    =    getRequestUri ( request )  ;", "String   path    =    getRemainingPath ( requestUri ,    contextPath ,    true )  ;", "if    ( path    !  =    null )     {", "return   StringUtils . hasText ( path )     ?    path    :     \"  /  \"  ;", "} else    {", "return   requestUri ;", "}", "}", "METHOD_END"], "methodName": ["getPathWithinApplication"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   pathWithinApp    =    getPathWithinApplication ( request )  ;", "String   servletPath    =    getServletPath ( request )  ;", "String   sanitizedPathWithinApp    =    getSanitizedPath ( pathWithinApp )  ;", "String   path ;", "if    ( servletPath . contains ( sanitizedPathWithinApp )  )     {", "path    =    getRemainingPath ( sanitizedPathWithinApp ,    servletPath ,    false )  ;", "} else    {", "path    =    getRemainingPath ( pathWithinApp ,    servletPath ,    false )  ;", "}", "if    ( path    !  =    null )     {", "return   path ;", "} else    {", "String   pathInfo    =    request . getPathInfo (  )  ;", "if    ( pathInfo    !  =    null )     {", "return   pathInfo ;", "}", "if    (  !  ( this . urlDecode )  )     {", "path    =    getRemainingPath ( decodeInternal ( request ,    pathWithinApp )  ,    servletPath ,    false )  ;", "if    ( path    !  =    null )     {", "return   pathWithinApp ;", "}", "}", "return   servletPath ;", "}", "}", "METHOD_END"], "methodName": ["getPathWithinServletMapping"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "int   index 1     =     0  ;", "int   index 2     =     0  ;", "for    (  ;     ( index 1     <     ( requestUri . length (  )  )  )     &  &     ( index 2     <     ( mapping . length (  )  )  )  ;    index 1  +  +     ,    index 2  +  +  )     {", "char   c 1     =    requestUri . charAt ( index 1  )  ;", "char   c 2     =    mapping . charAt ( index 2  )  ;", "if    ( c 1     =  =     '  ;  '  )     {", "index 1     =    requestUri . indexOf (  '  /  '  ,    index 1  )  ;", "if    ( index 1     =  =     (  -  1  )  )     {", "return   null ;", "}", "c 1     =    requestUri . charAt ( index 1  )  ;", "}", "if    (  ( c 1     =  =    c 2  )     |  |     ( ignoreCase    &  &     (  ( Character . toLowerCase ( c 1  )  )     =  =     ( Character . toLowerCase ( c 2  )  )  )  )  )     {", "continue ;", "}", "return   null ;", "}", "if    ( index 2     !  =     ( mapping . length (  )  )  )     {", "return   null ;", "} else", "if    ( index 1     =  =     ( requestUri . length (  )  )  )     {", "return    \"  \"  ;", "} else", "if    (  ( requestUri . charAt ( index 1  )  )     =  =     '  ;  '  )     {", "index 1     =    requestUri . indexOf (  '  /  '  ,    index 1  )  ;", "}", "return   index 1     !  =     (  -  1  )     ?    requestUri . subst ( index 1  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getRemainingPath"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   uri    =     (  ( String )     ( request . getAttribute ( WebUtils . INCLUDE _ REQUEST _ URI _ ATTRIBUTE )  )  )  ;", "if    ( uri    =  =    null )     {", "uri    =    request . getRequestURI (  )  ;", "}", "return   decodeAndCleanUriString ( request ,    uri )  ;", "}", "METHOD_END"], "methodName": ["getRequestUri"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   sanitized    =    path ;", "while    ( true )     {", "int   index    =    sanitized . indexOf (  \"  /  /  \"  )  ;", "if    ( index    <     0  )     {", "break ;", "} else    {", "sanitized    =     ( sanitized . substring (  0  ,    index )  )     +     ( sanitized . substring (  ( index    +     1  )  )  )  ;", "}", "}", "return   sanitized ;", "}", "METHOD_END"], "methodName": ["getSanitizedPath"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "String   servletPath    =     (  ( String )     ( request . getAttribute ( WebUtils . INCLUDE _ SERVLET _ PATH _ ATTRIBUTE )  )  )  ;", "if    ( servletPath    =  =    null )     {", "servletPath    =    request . getServletPath (  )  ;", "}", "if    (  (  (  ( servletPath . length (  )  )     >     1  )     &  &     ( servletPath . endsWith (  \"  /  \"  )  )  )     &  &     ( shouldRemoveTrailingServletPathSlash ( request )  )  )     {", "servletPath    =    servletPath . substring (  0  ,     (  ( servletPath . length (  )  )     -     1  )  )  ;", "}", "return   servletPath ;", "}", "METHOD_END"], "methodName": ["getServletPath"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . urlDecode ;", "}", "METHOD_END"], "methodName": ["isUrlDecode"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "int   startIndex    =    requestUri . toLowerCase (  )  . indexOf (  \"  ; jsessionid =  \"  )  ;", "if    ( startIndex    !  =     (  -  1  )  )     {", "int   endIndex    =    requestUri . indexOf (  '  ;  '  ,     ( startIndex    +     1  2  )  )  ;", "St   start    =    requestUri . subst (  0  ,    startIndex )  ;", "requestUri    =     ( endIndex    !  =     (  -  1  )  )     ?    start    +     ( requestUri . subst ( endIndex )  )     :    start ;", "}", "return   requestUri ;", "}", "METHOD_END"], "methodName": ["removeJsessionid"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . removeSemicolonContent    ?    removeSemicolonContentInternal ( requestUri )     :    removeJsessionid ( requestUri )  ;", "}", "METHOD_END"], "methodName": ["removeSemicolonContent"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "int   semicolonIndex    =    requestUri . indexOf (  '  ;  '  )  ;", "while    ( semicolonIndex    !  =     (  -  1  )  )     {", "int   slashIndex    =    requestUri . indexOf (  '  /  '  ,    semicolonIndex )  ;", "St   start    =    requestUri . subst (  0  ,    semicolonIndex )  ;", "requestUri    =     ( slashIndex    !  =     (  -  1  )  )     ?    start    +     ( requestUri . subst ( slashIndex )  )     :    start ;", "semicolonIndex    =    requestUri . indexOf (  '  ;  '  ,    semicolonIndex )  ;", "}", "return   requestUri ;", "}", "METHOD_END"], "methodName": ["removeSemicolonContentInternal"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "this . alwaysUseFullPath    =    alwaysUseFullPath ;", "}", "METHOD_END"], "methodName": ["setAlwaysUseFullPath"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "this . defaultEncoding    =    defaultEncoding ;", "}", "METHOD_END"], "methodName": ["setDefaultEncoding"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "this . removeSemicolonContent    =    removeSemicolonContent ;", "}", "METHOD_END"], "methodName": ["setRemoveSemicolonContent"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "this . urlDecode    =    urlDecode ;", "}", "METHOD_END"], "methodName": ["setUrlDecode"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . removeSemicolonContent ;", "}", "METHOD_END"], "methodName": ["shouldRemoveSemicolonContent"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getAttribute ( UrlPathHelper . WEBSPHERE _ URI _ ATTRIBUTE )  )     =  =    null )     {", "return   false ;", "}", "Boolean   flagToUse    =    UrlPathHelper . websphereComplianceFlag ;", "if    ( flagToUse    =  =    null )     {", "ClassLoader   classLoader    =    UrlPathHelper . class . getClassLoader (  )  ;", "String   className    =     \" com . ibm . ws . webcontainer . WebContainer \"  ;", "String   methodName    =     \" getWebContainerProperties \"  ;", "String   propName    =     \" com . ibm . ws . webcontainer . removetrailingservletpathslash \"  ;", "boolean   flag    =    false ;", "try    {", "Class <  ?  >    cl    =    classLoader . loadClass ( className )  ;", "Properties   prop    =     (  ( Properties )     ( cl . getMethod ( methodName )  . invoke ( null )  )  )  ;", "flag    =    Boolean . parseBoolean ( prop . getProperty ( propName )  )  ;", "}    catch    ( Throwable   ex )     {", "if    ( UrlPathHelper . logger . isDebugEnabled (  )  )     {", "UrlPathHelper . logger . debug (  (  \" Could   not   introspect   WebSphere   web   container   properties :     \"     +    ex )  )  ;", "}", "}", "flagToUse    =    flag ;", "UrlPathHelper . websphereComplianceFlag    =    flag ;", "}", "return    ! flagToUse ;", "}", "METHOD_END"], "methodName": ["shouldRemoveTrailingServletPathSlash"], "fileName": "org.springframework.web.util.UrlPathHelper"}, {"methodBody": ["METHOD_START", "{", "helper . setAlwaysUseFullPath ( true )  ;", "request . setContextPath (  \"  / petclinic \"  )  ;", "request . setServletPath (  \"  / main \"  )  ;", "request . setRequestURI (  \"  / petclinic / main / welcome . html \"  )  ;", "assertEquals (  \" Incorrect   path   returned \"  ,     \"  / main / welcome . html \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["alwaysUseFullPath"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "helper . setRemoveSemicolonContent ( false )  ;", "request . setContextPath (  \"  / petclinic \"  )  ;", "request . setServletPath (  \"  / main \"  )  ;", "request . setRequestURI (  \"  / petclinic ; a = b / main ; b = c / welcome . html ; c = d \"  )  ;", "assertEquals (  \"  / welcome . html ; c = d \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getLookupPathWithSemicolonContent"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "helper . setRemoveSemicolonContent ( false )  ;", "request . setContextPath (  \"  / petclinic \"  )  ;", "request . setServletPath (  \"  / welcome . html \"  )  ;", "request . setRequestURI (  \"  / petclinic ; a = b / welcome . html ; c = d \"  )  ;", "assertEquals (  \"  / welcome . html ; c = d \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getLookupPathWithSemicolonContentAndNullPathInfo"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setQueryString (  \" forward = on \"  )  ;", "request . setAttribute ( WebUtils . FORWARD _ REQUEST _ URI _ ATTRIBUTE ,     \"  / path \"  )  ;", "request . setAttribute ( WebUtils . FORWARD _ QUERY _ STRING _ ATTRIBUTE ,     \" original = on \"  )  ;", "assertEquals (  \" original = on \"  ,    this . h . getOriginatingQueryString ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingQueryString"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setQueryString (  \" forward = true \"  )  ;", "request . setAttribute ( WebUtils . FORWARD _ REQUEST _ URI _ ATTRIBUTE ,     \"  / path \"  )  ;", "assertNull ( this . h . getOriginatingQueryString ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingQueryStringIsNull"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setQueryString (  \" forward = true \"  )  ;", "assertEquals (  \" forward = true \"  ,    this . h . getOriginatingQueryString ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingQueryStringNotPresent"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setAttribute ( WebUtils . FORWARD _ REQUEST _ URI _ ATTRIBUTE ,     \"  / path \"  )  ;", "request . setRequestURI (  \"  / forwarded \"  )  ;", "assertEquals (  \"  / path \"  ,    h . getOriginatingRequestUri ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingRequestUri"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setRequestURI (  \"  / forwarded \"  )  ;", "assertEquals (  \"  / forwarded \"  ,    h . getOriginatingRequestUri ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingRequestUriDefault"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setAttribute ( UrlPathHelperTests . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / path \"  )  ;", "request . setRequestURI (  \"  / forwarded \"  )  ;", "assertEquals (  \"  / path \"  ,    helper . getOriginatingRequestUri ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingRequestUriWebsphere"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / petclinic \"  )  ;", "request . setRequestURI (  \"  / petclinic / welcome . html \"  )  ;", "assertEquals (  \" Incorrect   path   returned \"  ,     \"  / welcome . html \"  ,    h . getPathWithinApplication ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getPathWithinApplication"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / petclinic \"  )  ;", "request . setRequestURI (  \"  / petclinic \"  )  ;", "assertEquals (  \" Incorrect   root   path   returned \"  ,     \"  /  \"  ,    h . getPathWithinApplication ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getPathWithinApplicationForRootWithNoLeadingSlash"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  /  \"  )  ;", "request . setRequestURI (  \"  / welcome . html \"  )  ;", "assertEquals (  \" Incorrect   path   returned \"  ,     \"  / welcome . html \"  ,    h . getPathWithinApplication ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getPathWithinApplicationForSlashContextPath"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / petclinic \"  )  ;", "request . setServletPath (  \"  / main \"  )  ;", "request . setRequestURI (  \"  / petclinic / main / welcome . html \"  )  ;", "assertEquals (  \" Incorrect   path   returned \"  ,     \"  / welcome . html \"  ,    h . getPathWithinServletMapping ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getPathWithinServlet"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / SPR -  1  1  1  0  1  \"  )  ;", "request . setServletPath (  \"  / test _ url _ decoding / a / b \"  )  ;", "request . setRequestURI (  \"  / test _ url _ decoding / a %  2 Fb \"  )  ;", "h . setUrlDecode ( false )  ;", "String   actual    =    h . getPathWithinServletMapping ( request )  ;", "assertEquals (  \"  / test _ url _ decoding / a %  2 Fb \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["getPathWithinServletWithoutUrlDecoding"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "helper . setRemoveSemicolonContent ( false )  ;", "request . setRequestURI (  \"  / foo ; a = b ; c = d \"  )  ;", "assertEquals (  \"  / foo ; a = b ; c = d \"  ,    helper . getRequestUri ( request )  )  ;", "request . setRequestURI (  \"  / foo ; jsessionid = c 0 o 7 fszeb 1  \"  )  ;", "assertEquals (  \" jsessionid   should   always   be   removed \"  ,     \"  / foo \"  ,    helper . getRequestUri ( request )  )  ;", "request . setRequestURI (  \"  / foo ; a = b ; jsessionid = c 0 o 7 fszeb 1  ; c = d \"  )  ;", "assertEquals (  \" jsessionid   should   always   be   removed \"  ,     \"  / foo ; a = b ; c = d \"  ,    helper . getRequestUri ( request )  )  ;", "request . setRequestURI (  \"  / foo ; a = b ; JSESSIONID = c 0 o 7 fszeb 1  ; c = d \"  )  ;", "assertEquals (  \" JSESSIONID   should   always   be   removed \"  ,     \"  / foo ; a = b ; c = d \"  ,    helper . getRequestUri ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestKeepSemicolonContent"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "helper . setRemoveSemicolonContent ( true )  ;", "request . setRequestURI (  \"  / foo ; f = F ; o = O ; o = O / bar ; b = B ; a = A ; r = R \"  )  ;", "assertEquals (  \"  / foo / bar \"  ,    helper . getRequestUri ( request )  )  ;", "request . setServletPath (  \"  / foo /  1  \"  )  ;", "request . setRequestURI (  \"  / foo /  ; test /  1  \"  )  ;", "assertEquals (  \"  / foo /  1  \"  ,    helper . getRequestUri ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestRemoveSemicolonContent"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setRequestURI (  \"  / welcome . html \"  )  ;", "assertEquals (  \" Incorrect   path   returned \"  ,     \"  / welcome . html \"  ,    h . getRequestUri ( request )  )  ;", "request . setRequestURI (  \"  / foo %  2  0 bar \"  )  ;", "assertEquals (  \" Incorrect   path   returned \"  ,     \"  / foo   bar \"  ,    h . getRequestUri ( request )  )  ;", "request . setRequestURI (  \"  / foo + bar \"  )  ;", "assertEquals (  \" Incorrect   path   returned \"  ,     \"  / foo + bar \"  ,    h . getRequestUri ( request )  )  ;", "}", "METHOD_END"], "methodName": ["getRequestUri"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / SPR -  1  2  3  7  2  \"  )  ;", "request . setPathInfo ( null )  ;", "request . setServletPath (  \"  / foo / bar /  \"  )  ;", "request . setRequestURI (  \"  / SPR -  1  2  3  7  2  / foo /  / bar /  \"  )  ;", "assertEquals (  \"  / foo / bar /  \"  ,    h . getLookupPathForRequest ( request )  )  ;", "request . setServletPath (  \"  / foo / bar /  \"  )  ;", "request . setRequestURI (  \"  / SPR -  1  2  3  7  2  / foo / bar /  /  \"  )  ;", "assertEquals (  \"  / foo / bar /  \"  ,    h . getLookupPathForRequest ( request )  )  ;", "request . setServletPath (  \"  / foo / bar /  /  \"  )  ;", "request . setRequestURI (  \"  / SPR -  1  2  3  7  2  / foo / bar /  /  \"  )  ;", "assertEquals (  \"  / foo / bar /  /  \"  ,    h . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["removeDuplicateSlashesInPath"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo (  \"  / foo \"  )  ;", "request . setServletPath (  \"  / foo \"  )  ;", "request . setRequestURI (  \"  / test / foo / foo \"  )  ;", "assertEquals (  \"  / foo \"  ,    h . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["tomcatCasualServletFile"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo (  \"  / foo /  \"  )  ;", "request . setServletPath (  \"  / foo \"  )  ;", "request . setRequestURI (  \"  / test / foo / foo /  \"  )  ;", "assertEquals (  \"  / foo /  \"  ,    h . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["tomcatCasualServletFolder"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo (  \"  /  \"  )  ;", "request . setServletPath (  \"  / foo \"  )  ;", "request . setRequestURI (  \"  / test / foo /  \"  )  ;", "assertEquals (  \"  /  \"  ,    h . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["tomcatCasualServletRoot"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo ( null )  ;", "request . setServletPath (  \"  / foo \"  )  ;", "request . setRequestURI (  \"  / test / foo \"  )  ;", "assertEquals (  \"  /  \"  ,    h . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["tomcatCasualServletRootWithMissingSlash"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo ( null )  ;", "request . setServletPath (  \"  / foo \"  )  ;", "request . setRequestURI (  \"  / test / foo \"  )  ;", "assertEquals (  \"  / foo \"  ,    h . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["tomcatDefaultServletFile"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo ( null )  ;", "request . setServletPath (  \"  / foo /  \"  )  ;", "request . setRequestURI (  \"  / test / foo /  \"  )  ;", "assertEquals (  \"  / foo /  \"  ,    h . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["tomcatDefaultServletFolder"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo ( null )  ;", "request . setServletPath (  \"  /  \"  )  ;", "request . setRequestURI (  \"  / test /  \"  )  ;", "assertEquals (  \"  /  \"  ,    h . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["tomcatDefaultServletRoot"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo (  \"  / foo \"  )  ;", "request . setServletPath (  \"  / foo \"  )  ;", "request . setRequestURI (  \"  / test / foo / foo \"  )  ;", "request . setAttribute (  . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo / foo \"  )  ;", "assertEquals (  \"  / foo \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["wasCasualServletFile"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setAttribute ( UrlPathHelperTests . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo / foo \"  )  ;", "tomcatCasualServletFile (  )  ;", "}", "METHOD_END"], "methodName": ["wasCasualServletFileWithCompliantSetting"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo (  \"  / foo /  \"  )  ;", "request . setServletPath (  \"  / foo \"  )  ;", "request . setRequestURI (  \"  / test / foo / foo /  \"  )  ;", "request . setAttribute (  . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo / foo /  \"  )  ;", "assertEquals (  \"  / foo /  \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["wasCasualServletFolder"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setAttribute ( UrlPathHelperTests . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo / foo /  \"  )  ;", "tomcatCasualServletFolder (  )  ;", "}", "METHOD_END"], "methodName": ["wasCasualServletFolderWithCompliantSetting"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo ( null )  ;", "request . setServletPath (  \"  / foo /  \"  )  ;", "request . setRequestURI (  \"  / test / foo /  \"  )  ;", "request . setAttribute (  . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo /  \"  )  ;", "assertEquals (  \"  /  \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["wasCasualServletRoot"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setAttribute ( UrlPathHelperTests . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo /  \"  )  ;", "tomcatCasualServletRoot (  )  ;", "}", "METHOD_END"], "methodName": ["wasCasualServletRootWithCompliantSetting"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo ( null )  ;", "request . setServletPath (  \"  / foo \"  )  ;", "request . setRequestURI (  \"  / test / foo \"  )  ;", "request . setAttribute (  . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo \"  )  ;", "assertEquals (  \"  /  \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["wasCasualServletRootWithMissingSlash"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setAttribute ( UrlPathHelperTests . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo \"  )  ;", "tomcatCasualServletRootWithMissingSlash (  )  ;", "}", "METHOD_END"], "methodName": ["wasCasualServletRootWithMissingSlashWithCompliantSetting"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo (  \"  / foo \"  )  ;", "request . setServletPath (  \"  \"  )  ;", "request . setRequestURI (  \"  / test / foo \"  )  ;", "request . setAttribute (  . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo \"  )  ;", "assertEquals (  \"  / foo \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["wasDefaultServletFile"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setAttribute ( UrlPathHelperTests . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo \"  )  ;", "tomcatDefaultServletFile (  )  ;", "}", "METHOD_END"], "methodName": ["wasDefaultServletFileWithCompliantSetting"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo (  \"  / foo /  \"  )  ;", "request . setServletPath (  \"  \"  )  ;", "request . setRequestURI (  \"  / test / foo /  \"  )  ;", "request . setAttribute (  . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo /  \"  )  ;", "assertEquals (  \"  / foo /  \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["wasDefaultServletFolder"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "UrlPathHelper . websphereComplianceFlag    =    true ;", "try    {", "request . setAttribute (  . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test / foo /  \"  )  ;", "tomcatDefaultServletFolder (  )  ;", "}    finally    {", "UrlPathHelper . websphereComplianceFlag    =    false ;", "}", "}", "METHOD_END"], "methodName": ["wasDefaultServletFolderWithCompliantSetting"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setContextPath (  \"  / test \"  )  ;", "request . setPathInfo (  \"  /  \"  )  ;", "request . setServletPath (  \"  \"  )  ;", "request . setRequestURI (  \"  / test /  \"  )  ;", "request . setAttribute (  . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test /  \"  )  ;", "assertEquals (  \"  /  \"  ,    helper . getLookupPathForRequest ( request )  )  ;", "}", "METHOD_END"], "methodName": ["wasDefaultServletRoot"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . setAttribute ( UrlPathHelperTests . WEBSPHERE _ URI _ ATTRIBUTE ,     \"  / test /  \"  )  ;", "tomcatDefaultServletRoot (  )  ;", "}", "METHOD_END"], "methodName": ["wasDefaultServletRootWithCompliantSetting"], "fileName": "org.springframework.web.util.UrlPathHelperTests"}, {"methodBody": ["METHOD_START", "{", "request . removeAttribute ( WebUtils . ERROR _ STATUS _ CODE _ ATTRIBUTE )  ;", "request . removeAttribute ( WebUtils . ERROR _ EXCEPTION _ TYPE _ ATTRIBUTE )  ;", "request . removeAttribute ( WebUtils . ERROR _ MESSAGE _ ATTRIBUTE )  ;", "request . removeAttribute ( WebUtils . ERROR _ EXCEPTION _ ATTRIBUTE )  ;", "request . removeAttribute ( WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE )  ;", "request . removeAttribute ( WebUtils . ERROR _ SERVLET _ NAME _ ATTRIBUTE )  ;", "}", "METHOD_END"], "methodName": ["clearErrorRequestAttributes"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( String   headerName    :    WebUtils . FORWARDED _ HEADER _ NAMES )     {", "if    (  ( request . getHeader ( headerName )  )     !  =    null )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsForwardedHeaders"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "WebUtils . exposeRequestAttributeIfNotPresent ( request ,    WebUtils . ERROR _ STATUS _ CODE _ ATTRIBUTE ,    SC _ OK )  ;", "WebUtils . exposeRequestAttributeIfNotPresent ( request ,    WebUtils . ERROR _ EXCEPTION _ TYPE _ ATTRIBUTE ,    ex . getClass (  )  )  ;", "WebUtils . exposeRequestAttributeIfNotPresent ( request ,    WebUtils . ERROR _ MESSAGE _ ATTRIBUTE ,    ex . getMessage (  )  )  ;", "WebUtils . exposeRequestAttributeIfNotPresent ( request ,    WebUtils . ERROR _ EXCEPTION _ ATTRIBUTE ,    ex )  ;", "WebUtils . exposeRequestAttributeIfNotPresent ( request ,    WebUtils . ERROR _ REQUEST _ URI _ ATTRIBUTE ,    request . getRequestURI (  )  )  ;", "if    ( servletName    !  =    null )     {", "WebUtils . exposeRequestAttributeIfNotPresent ( request ,    WebUtils . ERROR _ SERVLET _ NAME _ ATTRIBUTE ,    servletName )  ;", "}", "}", "METHOD_END"], "methodName": ["exposeErrorRequestAttributes"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . getAttribute ( name )  )     =  =    null )     {", "request . setAttribute ( name ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["exposeRequestAttributeIfNotPresent"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    parameters . get ( name )  ;", "if    ( value   instanceof   String [  ]  )     {", "String [  ]    values    =     (  ( String [  ]  )     ( value )  )  ;", "return    ( values . length )     >     0     ?    values [  0  ]     :    null ;", "} else", "if    ( value    !  =    null )     {", "return   value . toString (  )  ;", "}", "String   prefix    =    name    +     \"  _  \"  ;", "for    ( String   paramName    :    parameters . keySet (  )  )     {", "if    ( paramName . startsWith ( prefix )  )     {", "for    ( String   suffix    :     . SUBMIT _ IMAGE _ SUFFIXES )     {", "if    ( paramName . endsWith ( suffix )  )     {", "return   paramName . substring ( prefix . length (  )  ,     (  ( paramName . length (  )  )     -     ( suffix . length (  )  )  )  )  ;", "}", "}", "return   paramName . substring ( prefix . length (  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findParameterValue"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "return   WebUtils . findParameterValue ( request . getParameterMap (  )  ,    name )  ;", "}", "METHOD_END"], "methodName": ["findParameterValue"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" Request   must   not   be   null \"  )  ;", "Cookie [  ]    cookies    =    request . getCookies (  )  ;", "if    ( cookies    !  =    null )     {", "for    ( Cookie   cookie    :    cookies )     {", "if    ( n . equals ( cookie . getN (  )  )  )     {", "return   cookie ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCookie"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( servletContext    =  =    null )     {", "return   null ;", "}", "String   param    =    servletContext . getInitParameter (  . HTML _ ESCAPE _ CONTEXT _ PARAM )  ;", "return   StringUtils . hasText ( param )     ?    Boolean . valueOf ( param )     :    null ;", "}", "METHOD_END"], "methodName": ["getDefaultHtmlEscape"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( requiredType    !  =    null )     {", "if    ( requiredType . isInstance ( request )  )     {", "return    (  ( T )     ( request )  )  ;", "} else", "if    ( request   instanceof   ServletRequestWrapper )     {", "return    . getNativeRequest (  (  ( ServletRequestWrapper )     ( request )  )  . getRequest (  )  ,    requiredType )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getNativeRequest"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( requiredType    !  =    null )     {", "if    ( requiredType . isInstance ( response )  )     {", "return    (  ( T )     ( response )  )  ;", "} else", "if    ( response   instanceof   ServletResponseWrapper )     {", "return    . getNativeResponse (  (  ( ServletResponseWrapper )     ( response )  )  . getResponse (  )  ,    requiredType )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getNativeResponse"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" Request   must   not   be   null \"  )  ;", "Enumeration < St >    paramNames    =    request . getParameterNames (  )  ;", "Map < St ,    Object >    params    =    new   TreeMap <  >  (  )  ;", "if    ( prefix    =  =    null )     {", "prefix    =     \"  \"  ;", "}", "while    (  ( paramNames    !  =    null )     &  &     ( paramNames . hasMoreElements (  )  )  )     {", "St   paramName    =    paramNames . nextElement (  )  ;", "if    (  (  \"  \"  . equals ( prefix )  )     |  |     ( paramName . startsWith ( prefix )  )  )     {", "St   unprefixed    =    paramName . subst ( prefix . length (  )  )  ;", "St [  ]    values    =    request . getParameterValues ( paramName )  ;", "if    (  ( values    =  =    null )     |  |     (  ( values . length )     =  =     0  )  )     {", "} else", "if    (  ( values . length )     >     1  )     {", "params . put ( unprefixed ,    values )  ;", "} else    {", "params . put ( unprefixed ,    values [  0  ]  )  ;", "}", "}", "}", "return   params ;", "}", "METHOD_END"], "methodName": ["getParametersStartingWith"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( port    =  =     (  -  1  )  )     {", "if    (  (  \" http \"  . equals ( scheme )  )     |  |     (  \" ws \"  . equals ( scheme )  )  )     {", "port    =     8  0  ;", "} else", "if    (  (  \" https \"  . equals ( scheme )  )     |  |     (  \" wss \"  . equals ( scheme )  )  )     {", "port    =     4  4  3  ;", "}", "}", "return   port ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( servletContext ,     \" ServletContext   must   not   be   null \"  )  ;", "if    (  !  ( path . startsWith (  \"  /  \"  )  )  )     {", "path    =     \"  /  \"     +    path ;", "}", "St   realPath    =    servletContext . getRealPath ( path )  ;", "if    ( realPath    =  =    null )     {", "throw   new   FileNotFoundException (  (  (  (  \" ServletContext   resource    [  \"     +    path )     +     \"  ]    cannot   be   resolved   to   absolute   file   path    -     \"  )     +     \" web   application   archive   not   expanded ?  \"  )  )  ;", "}", "return   realPath ;", "}", "METHOD_END"], "methodName": ["getRealPath"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Object   attr    =    WebUtils . getSessionAttribute ( request ,    name )  ;", "if    ( attr    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   session   attribute    '  \"     +    name )     +     \"  '    found \"  )  )  ;", "}", "return   attr ;", "}", "METHOD_END"], "methodName": ["getRequiredSessionAttribute"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( servletContext    =  =    null )     {", "return   null ;", "}", "String   param    =    servletContext . getInitParameter (  . RESPONSE _ ENCODED _ HTML _ ESCAPE _ CONTEXT _ PARAM )  ;", "return   StringUtils . hasText ( param )     ?    Boolean . valueOf ( param )     :    null ;", "}", "METHOD_END"], "methodName": ["getResponseEncodedHtmlEscape"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" Request   must   not   be   null \"  )  ;", "HttpSession   session    =    request . getSession ( false )  ;", "return   session    !  =    null    ?    session . getAttribute ( n )     :    null ;", "}", "METHOD_END"], "methodName": ["getSessionAttribute"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" Request   must   not   be   null \"  )  ;", "HttpSession   session    =    request . getSession ( fae )  ;", "return   session    !  =    null    ?    session . getId (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getSessionId"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( session ,     \" Session   must   not   be   null \"  )  ;", "Object   mutex    =    session . getAttribute (  . SESSION _ MUTEX _ ATTRIBUTE )  ;", "if    ( mutex    =  =    null )     {", "mutex    =    session ;", "}", "return   mutex ;", "}", "METHOD_END"], "methodName": ["getSessionMutex"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( servletContext ,     \" ServletContext   must   not   be   null \"  )  ;", "return    (  ( File )     ( servletContext . getAttribute (  . TEMP _ DIR _ CONTEXT _ ATTRIBUTE )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTempDir"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" Request   must   not   be   null \"  )  ;", "if    (  ( request . getParameter ( name )  )     !  =    null )     {", "return   true ;", "}", "for    ( String   suffix    :     . SUBMIT _ IMAGE _ SUFFIXES )     {", "if    (  ( request . getParameter (  ( name    +    suffix )  )  )     !  =    null )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasSubmitParameter"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( request . getAttribute ( WebUtils . INCLUDE _ REQUEST _ URI _ ATTRIBUTE )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isIncludeRequest"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    request . getHeaders (  )  ;", "String   origin    =    headers . getOrigin (  )  ;", "if    ( origin    =  =    null )     {", "return   true ;", "}", "String   scheme ;", "String   host ;", "int   port ;", "if    ( request   instanceof   ServletServerHttpRequest )     {", "HttpServletRequest   servletRequest    =     (  ( ServletServerHttpRequest )     ( request )  )  . getServletRequest (  )  ;", "scheme    =    servletRequest . getScheme (  )  ;", "host    =    servletRequest . getServerName (  )  ;", "port    =    servletRequest . getServerPort (  )  ;", "if    (  . containsForwardedHeaders ( servletRequest )  )     {", "UriComponents   actualUrl    =    new   UriComponentsBuilder (  )  . scheme ( scheme )  . host ( host )  . port ( port )  . adaptFromForwardedHeaders ( headers )  . build (  )  ;", "scheme    =    actualUrl . getScheme (  )  ;", "host    =    actualUrl . getHost (  )  ;", "port    =    actualUrl . getPort (  )  ;", "}", "} else    {", "UriComponents   actualUrl    =    UriComponentsBuilder . fromHttpRequest ( request )  . build (  )  ;", "scheme    =    actualUrl . getScheme (  )  ;", "host    =    actualUrl . getHost (  )  ;", "port    =    actualUrl . getPort (  )  ;", "}", "UriComponents   originUrl    =    UriComponentsBuilder . fromOriginHeader ( origin )  . build (  )  ;", "return    ( ObjectUtils . nullSafeEquals ( host ,    originUrl . getHost (  )  )  )     &  &     (  (  . getPort ( scheme ,    port )  )     =  =     (  . getPort ( originUrl . getScheme (  )  ,    originUrl . getPort (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameOrigin"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" Request   must   not   be   null \"  )  ;", "Assert . notNull ( allowedOrigins ,     \" Allowed   origins   must   not   be   null \"  )  ;", "String   origin    =    request . getHeaders (  )  . getOrigin (  )  ;", "if    (  ( origin    =  =    null )     |  |     ( allowedOrigins . contains (  \"  *  \"  )  )  )     {", "return   true ;", "} else", "if    ( util . CollectionUtils . isEmpty ( allowedOrigins )  )     {", "return   WebUtils . isSameOrigin ( request )  ;", "} else    {", "return   allowedOrigins . contains ( origin )  ;", "}", "}", "METHOD_END"], "methodName": ["isValidOrigin"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    result    =    new   LinkedMultiValueMap (  )  ;", "if    (  !  ( StringUtils . hasText ( matrixVariables )  )  )     {", "return   result ;", "}", "StringTokenizer   pairs    =    new   StringTokenizer ( matrixVariables ,     \"  ;  \"  )  ;", "while    ( pairs . hasMoreTokens (  )  )     {", "String   pair    =    pairs . nextToken (  )  ;", "int   index    =    pair . indexOf (  '  =  '  )  ;", "if    ( index    !  =     (  -  1  )  )     {", "String   name    =    pair . substring (  0  ,    index )  ;", "String   rawValue    =    pair . substring (  ( index    +     1  )  )  ;", "for    ( String   value    :    StringUtils . commaDelimitedListToStringArray ( rawValue )  )     {", "result . add ( name ,    value )  ;", "}", "} else    {", "result . add ( pair ,     \"  \"  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseMatrixVariables"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( servletContext ,     \" ServletContext   must   not   be   null \"  )  ;", "String   param    =    servletContext . getInitParameter (  . WEB _ APP _ ROOT _ KEY _ PARAM )  ;", "String   key    =     ( param    !  =    null )     ?    param    :     . DEFAULT _ WEB _ APP _ ROOT _ KEY ;", "System . getProperties (  )  . remove ( key )  ;", "}", "METHOD_END"], "methodName": ["removeWebAppRootSystemProperty"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( request ,     \" Request   must   not   be   null \"  )  ;", "if    ( value    !  =    null )     {", "request . getSession (  )  . setAttribute ( n ,    value )  ;", "} else    {", "HttpSession   session    =    request . getSession ( false )  ;", "if    ( session    !  =    null )     {", "session . removeAttribute ( n )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setSessionAttribute"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( servletContext ,     \" ServletContext   must   not   be   null \"  )  ;", "String   root    =    servletContext . getRealPath (  \"  /  \"  )  ;", "if    ( root    =  =    null )     {", "throw   new   IllegalStateException (  \" Cannot   set   web   app   root   system   property   when   WAR   file   is   not   expanded \"  )  ;", "}", "String   param    =    servletContext . getInitParameter (  . WEB _ APP _ ROOT _ KEY _ PARAM )  ;", "String   key    =     ( param    !  =    null )     ?    param    :     . DEFAULT _ WEB _ APP _ ROOT _ KEY ;", "String   oldValue    =    System . getProperty ( key )  ;", "if    (  ( oldValue    !  =    null )     &  &     (  !  ( StringUtils . pathEquals ( oldValue ,    root )  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  (  \" Web   app   root   system   property   already   set   to   different   value :     '  \"     +    key )     +     \"  '     =     [  \"  )     +    oldValue )     +     \"  ]    instead   of    [  \"  )     +    root )     +     \"  ]     -     \"  )     +     \" Choose   unique   values   for   the    ' webAppRootKey '    context - param   in   your   web . xml   files !  \"  )  )  ;", "}", "System . setProperty ( key ,    root )  ;", "servletContext . log (  (  (  (  (  \" Set   web   app   root   system   property :     '  \"     +    key )     +     \"  '     =     [  \"  )     +    root )     +     \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setWebAppRootSystemProperty"], "fileName": "org.springframework.web.util.WebUtils"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   servletRequest    =    new   MockHttpServletRequest (  )  ;", "ServerHttpRequest   request    =    new   ServletServerHttpRequest ( servletRequest )  ;", "servletRequest . setServerName ( serverName )  ;", "if    ( port    !  =     (  -  1  )  )     {", "servletRequest . setServerPort ( port )  ;", "}", "servletRequest . addHeader ( HttpHeaders . ORIGIN ,    originHeader )  ;", "return    . isSameOrigin ( request )  ;", "}", "METHOD_END"], "methodName": ["checkSameOrigin"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   servletRequest    =    new   MockHttpServletRequest (  )  ;", "ServerHttpRequest   request    =    new   ServletServerHttpRequest ( servletRequest )  ;", "servletRequest . setServerName ( serverName )  ;", "if    ( port    !  =     (  -  1  )  )     {", "servletRequest . setServerPort ( port )  ;", "}", "servletRequest . addHeader (  \" Forwarded \"  ,    forwardedHeader )  ;", "servletRequest . addHeader ( HttpHeaders . ORIGIN ,    originHeader )  ;", "return    . isSameOrigin ( request )  ;", "}", "METHOD_END"], "methodName": ["checkSameOriginWithForwardedHeader"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   servletRequest    =    new   MockHttpServletRequest (  )  ;", "ServerHttpRequest   request    =    new   ServletServerHttpRequest ( servletRequest )  ;", "servletRequest . setServerName ( serverName )  ;", "if    ( port    !  =     (  -  1  )  )     {", "servletRequest . setServerPort ( port )  ;", "}", "if    ( forwardedProto    !  =    null )     {", "servletRequest . addHeader (  \" X - Forwarded - Proto \"  ,    forwardedProto )  ;", "}", "if    ( forwardedHost    !  =    null )     {", "servletRequest . addHeader (  \" X - Forwarded - Host \"  ,    forwardedHost )  ;", "}", "if    ( forwardedPort    !  =     (  -  1  )  )     {", "servletRequest . addHeader (  \" X - Forwarded - Port \"  ,    String . valueOf ( forwardedPort )  )  ;", "}", "servletRequest . addHeader ( HttpHeaders . ORIGIN ,    originHeader )  ;", "return    . isSameOrigin ( request )  ;", "}", "METHOD_END"], "methodName": ["checkSameOriginWithXForwardedHeaders"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MockHttpServletRequest   servletRequest    =    new   MockHttpServletRequest (  )  ;", "ServerHttpRequest   request    =    new   ServletServerHttpRequest ( servletRequest )  ;", "servletRequest . setServerName ( serverName )  ;", "if    ( port    !  =     (  -  1  )  )     {", "servletRequest . setServerPort ( port )  ;", "}", "servletRequest . addHeader ( HttpHeaders . ORIGIN ,    originHeader )  ;", "return    . isValidOrigin ( request ,    allowed )  ;", "}", "METHOD_END"], "methodName": ["checkValidOrigin"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    params    =    new   HashMap <  >  (  )  ;", "params . put (  \" myKey 1  \"  ,     \" myValue 1  \"  )  ;", "params . put (  \" myKey 2  _ myValue 2  \"  ,     \" xxx \"  )  ;", "params . put (  \" myKey 3  _ myValue 3  . x \"  ,     \" xxx \"  )  ;", "params . put (  \" myKey 4  _ myValue 4  . y \"  ,    new   String [  ]  {     \" yyy \"     }  )  ;", "assertNull (  . findParameterValue ( params ,     \" myKey 0  \"  )  )  ;", "assertEquals (  \" myValue 1  \"  ,     . findParameterValue ( params ,     \" myKey 1  \"  )  )  ;", "assertEquals (  \" myValue 2  \"  ,     . findParameterValue ( params ,     \" myKey 2  \"  )  )  ;", "assertEquals (  \" myValue 3  \"  ,     . findParameterValue ( params ,     \" myKey 3  \"  )  )  ;", "assertEquals (  \" myValue 4  \"  ,     . findParameterValue ( params ,     \" myKey 4  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findParameterValue"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com :  8  0  \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     4  4  3  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     4  4  3  ,     \" https :  /  / mydomain 1  . com :  4  4  3  \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" http :  /  / mydomain 1  . com :  1  2  3  \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" ws :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     4  4  3  ,     \" wss :  /  / mydomain 1  . com \"  )  )  ;", "assertFalse ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 2  . com \"  )  )  ;", "assertFalse ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertFalse ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" invalid - origin \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com /  \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com :  8  0  /  \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com / path \"  )  )  ;", "assertTrue ( checkSameOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com :  8  0  / path \"  )  )  ;", "assertFalse ( checkSameOrigin (  \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com /  \"  )  )  ;", "assertFalse ( checkSameOrigin (  \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com :  8  0  /  \"  )  )  ;", "assertFalse ( checkSameOrigin (  \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com / path \"  )  )  ;", "assertFalse ( checkSameOrigin (  \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com :  8  0  / path \"  )  )  ;", "assertTrue ( checkSameOrigin (  \"  [  :  :  1  ]  \"  ,     (  -  1  )  ,     \" http :  /  /  [  :  :  1  ]  \"  )  )  ;", "assertTrue ( checkSameOrigin (  \"  [  :  :  1  ]  \"  ,     8  0  8  0  ,     \" http :  /  /  [  :  :  1  ]  :  8  0  8  0  \"  )  )  ;", "assertTrue ( checkSameOrigin (  \"  [  2  0  0  1  :  0 db 8  :  0  0  0  0  :  8  5 a 3  :  0  0  0  0  :  0  0  0  0  : ac 1 f :  8  0  0  1  ]  \"  ,     (  -  1  )  ,     \" http :  /  /  [  2  0  0  1  :  0 db 8  :  0  0  0  0  :  8  5 a 3  :  0  0  0  0  :  0  0  0  0  : ac 1 f :  8  0  0  1  ]  \"  )  )  ;", "assertTrue ( checkSameOrigin (  \"  [  2  0  0  1  :  0 db 8  :  0  0  0  0  :  8  5 a 3  :  0  0  0  0  :  0  0  0  0  : ac 1 f :  8  0  0  1  ]  \"  ,     8  0  8  0  ,     \" http :  /  /  [  2  0  0  1  :  0 db 8  :  0  0  0  0  :  8  5 a 3  :  0  0  0  0  :  0  0  0  0  : ac 1 f :  8  0  0  1  ]  :  8  0  8  0  \"  )  )  ;", "assertFalse ( checkSameOrigin (  \"  [  :  :  1  ]  \"  ,     (  -  1  )  ,     \" http :  /  /  [  :  :  1  ]  :  8  0  8  0  \"  )  )  ;", "assertFalse ( checkSameOrigin (  \"  [  :  :  1  ]  \"  ,     8  0  8  0  ,     \" http :  /  /  [  2  0  0  1  :  0 db 8  :  0  0  0  0  :  8  5 a 3  :  0  0  0  0  :  0  0  0  0  : ac 1 f :  8  0  0  1  ]  :  8  0  8  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameOrigin"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" proto = https \"  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" proto = https \"  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" proto = https ;    host = mydomain 2  . com \"  ,     \" https :  /  / mydomain 2  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" proto = https ;    host = mydomain 2  . com \"  ,     \" https :  /  / mydomain 2  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" proto = https ;    host = mydomain 2  . com :  4  5  6  \"  ,     \" https :  /  / mydomain 2  . com :  4  5  6  \"  )  )  ;", "assertTrue ( checkSameOriginWithForwardedHeader (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" proto = https ;    host = mydomain 2  . com :  4  5  6  \"  ,     \" https :  /  / mydomain 2  . com :  4  5  6  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameOriginWithForwardedHeader"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" https \"  ,    null ,     (  -  1  )  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" https \"  ,    null ,     (  -  1  )  ,     \" https :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" https \"  ,     \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" https :  /  / mydomain 2  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" https \"  ,     \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" https :  /  / mydomain 2  . com \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" https \"  ,     \" mydomain 2  . com \"  ,     4  5  6  ,     \" https :  /  / mydomain 2  . com :  4  5  6  \"  )  )  ;", "assertTrue ( checkSameOriginWithXForwardedHeaders (  \" mydomain 1  . com \"  ,     1  2  3  ,     \" https \"  ,     \" mydomain 2  . com \"  ,     4  5  6  ,     \" https :  /  / mydomain 2  . com :  4  5  6  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameOriginWithXForwardedHeaders"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    allowed    =    Collections . emptyList (  )  ;", "assertTrue ( checkValidOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com \"  ,    allowed )  )  ;", "assertFalse ( checkValidOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 2  . com \"  ,    allowed )  )  ;", "allowed    =    Collections . singletonList (  \"  *  \"  )  ;", "assertTrue ( checkValidOrigin (  \" mydomain 1  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 2  . com \"  ,    allowed )  )  ;", "allowed    =    Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  ;", "assertTrue ( checkValidOrigin (  \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 1  . com \"  ,    allowed )  )  ;", "assertFalse ( checkValidOrigin (  \" mydomain 2  . com \"  ,     (  -  1  )  ,     \" http :  /  / mydomain 3  . com \"  ,    allowed )  )  ;", "}", "METHOD_END"], "methodName": ["isValidOrigin"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    variables ;", "variables    =     . parseMatrixVariables ( null )  ;", "assertEquals (  0  ,    variables . size (  )  )  ;", "variables    =     . parseMatrixVariables (  \" year \"  )  ;", "assertEquals (  1  ,    variables . size (  )  )  ;", "assertEquals (  \"  \"  ,    variables . getFirst (  \" year \"  )  )  ;", "variables    =     . parseMatrixVariables (  \" year =  2  0  1  2  \"  )  ;", "assertEquals (  1  ,    variables . size (  )  )  ;", "assertEquals (  \"  2  0  1  2  \"  ,    variables . getFirst (  \" year \"  )  )  ;", "variables    =     . parseMatrixVariables (  \" year =  2  0  1  2  ; colors = red , blue , green \"  )  ;", "assertEquals (  2  ,    variables . size (  )  )  ;", "assertEquals ( Arrays . asList (  \" red \"  ,     \" blue \"  ,     \" green \"  )  ,    variables . get (  \" colors \"  )  )  ;", "assertEquals (  \"  2  0  1  2  \"  ,    variables . getFirst (  \" year \"  )  )  ;", "variables    =     . parseMatrixVariables (  \"  ; year =  2  0  1  2  ; colors = red , blue , green ;  \"  )  ;", "assertEquals (  2  ,    variables . size (  )  )  ;", "assertEquals ( Arrays . asList (  \" red \"  ,     \" blue \"  ,     \" green \"  )  ,    variables . get (  \" colors \"  )  )  ;", "assertEquals (  \"  2  0  1  2  \"  ,    variables . getFirst (  \" year \"  )  )  ;", "variables    =     . parseMatrixVariables (  \" colors = red ; colors = blue ; colors = green \"  )  ;", "assertEquals (  1  ,    variables . size (  )  )  ;", "assertEquals ( Arrays . asList (  \" red \"  ,     \" blue \"  ,     \" green \"  )  ,    variables . get (  \" colors \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMatrixVariablesString"], "fileName": "org.springframework.web.util.WebUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "for    ( int   i    =    fromSegment ,    max    =    ps . size (  )  ;    i    <    max ;    i +  +  )     {", "PathContainer . Element   element    =    ps . get ( i )  ;", "if    ( element   instanceof   PathContainer . PathSegment )     {", "buf . append (  (  ( PathContainer . PathSegment )     ( element )  )  . valueToMatch (  )  )  ;", "} else    {", "buf . append ( element . value (  )  )  ;", "}", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["pathToString"], "fileName": "org.springframework.web.util.pattern.CaptureTheRestPathElement"}, {"methodBody": ["METHOD_START", "{", "return    (  \" CaptureTheRest (  /  {  *  \"     +     ( this . variableName )  )     +     \"  }  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.CaptureTheRestPathElement"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   b    =    new   StringBuilder (  )  ;", "b . append (  \"  {  \"  )  ;", "b . append ( this . variableName )  ;", "if    (  ( this . constraintPattern )     !  =    null )     {", "b . append (  \"  :  \"  )  . append ( this . constraintPattern (  )  )  ;", "}", "b . append (  \"  }  \"  )  ;", "return   b . toString (  )  . toCharArray (  )  ;", "}", "METHOD_END"], "methodName": ["getChars"], "fileName": "org.springframework.web.util.pattern.CaptureVariablePathElement"}, {"methodBody": ["METHOD_START", "{", "return   this . variableName ;", "}", "METHOD_END"], "methodName": ["getVariableName"], "fileName": "org.springframework.web.util.pattern.CaptureVariablePathElement"}, {"methodBody": ["METHOD_START", "{", "return    (  (  \" CaptureVariable (  {  \"     +     ( this . variableName )  )     +     (  ( this . constraintPattern )     !  =    null    ?     \"  :  \"     +     ( this . constraintPattern . pattern (  )  )     :     \"  \"  )  )     +     \"  }  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.CaptureVariablePathElement"}, {"methodBody": ["METHOD_START", "{", "if    ( this . insideVariableCapture )     {", "throw   new   Exception ( this . pos ,    this . pathPatternData ,    Exception . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "}", "PathElement   newPE    =    null ;", "if    (  ( this . variableCaptureCount )     >     0  )     {", "if    (  (  (  ( this . variableCaptureCount )     =  =     1  )     &  &     (  ( this . pathElementStart )     =  =     ( this . variableCaptureStart )  )  )     &  &     (  ( this . pathPatternData [  (  ( this . pos )     -     1  )  ]  )     =  =     '  }  '  )  )     {", "if    ( this . isCaptureTheRestVariable )     {", "newPE    =    new   CaptureTheRestPathElement ( this . pathElementStart ,    getPathElementText (  )  ,    this . parser . getSeparator (  )  )  ;", "} else    {", "try    {", "newPE    =    new   CaptureVariablePathElement ( this . pathElementStart ,    getPathElementText (  )  ,    this . parser . isCaseSensitive (  )  ,    this . parser . getSeparator (  )  )  ;", "}    catch    ( PatternSyntaxException   pse )     {", "throw   new   Exception ( pse ,     (  ( findRegexStart ( this . pathPatternData ,    this . pathElementStart )  )     +     ( pse . getIndex (  )  )  )  ,    this . pathPatternData ,    Exception . PatternMessage . REGEX _ PATTERN _ SYNTAX _ EXCEPTION )  ;", "}", "recordCapturedVariable ( this . pathElementStart ,     (  ( CaptureVariablePathElement )     ( newPE )  )  . getVariableName (  )  )  ;", "}", "} else    {", "if    ( this . isCaptureTheRestVariable )     {", "throw   new   Exception ( this . pathElementStart ,    this . pathPatternData ,    Exception . PatternMessage . CAPTURE _ ALL _ IS _ STANDALONE _ CONSTRUCT )  ;", "}", "RegexPathElement   newRegexSection    =    new   RegexPathElement ( this . pathElementStart ,    getPathElementText (  )  ,    this . parser . isCaseSensitive (  )  ,    this . pathPatternData ,    this . parser . getSeparator (  )  )  ;", "for    ( String   variableName    :    newRegexSection . getVariableNames (  )  )     {", "recordCapturedVariable ( this . pathElementStart ,    variableName )  ;", "}", "newPE    =    newRegexSection ;", "}", "} else    {", "if    ( this . wildcard )     {", "if    (  (  ( this . pos )     -     1  )     =  =     ( this . pathElementStart )  )     {", "newPE    =    new   WildcardPathElement ( this . pathElementStart ,    this . parser . getSeparator (  )  )  ;", "} else    {", "newPE    =    new   RegexPathElement ( this . pathElementStart ,    getPathElementText (  )  ,    this . parser . isCaseSensitive (  )  ,    this . pathPatternData ,    this . parser . getSeparator (  )  )  ;", "}", "} else", "if    (  ( this . singleCharWildcardCount )     !  =     0  )     {", "newPE    =    new   SingleCharWildcardedPathElement ( this . pathElementStart ,    getPathElementText (  )  ,    this . singleCharWildcardCount ,    this . parser . isCaseSensitive (  )  ,    this . parser . getSeparator (  )  )  ;", "} else    {", "newPE    =    new   LiteralPathElement ( this . pathElementStart ,    getPathElementText (  )  ,    this . parser . isCaseSensitive (  )  ,    this . parser . getSeparator (  )  )  ;", "}", "}", "return   newPE ;", "}", "METHOD_END"], "methodName": ["createPathElement"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    offset ;", "while    ( pos    <     ( data . length )  )     {", "if    (  ( data [ pos ]  )     =  =     '  :  '  )     {", "return   pos    +     1  ;", "}", "pos +  +  ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["findRegexStart"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "char [  ]    pathElementText    =    new   char [  ( this . pos )     -     ( this . pathElementStart )  ]  ;", "System . arraycopy ( this . pData ,    this . pathElementStart ,    pathElementText ,     0  ,     (  ( this . pos )     -     ( this . pathElementStart )  )  )  ;", "return   pathElementText ;", "}", "METHOD_END"], "methodName": ["getPathElementText"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pathPattern ,     \" Path   pattern   must   not   be   null \"  )  ;", "this . pathPatternData    =    pathPattern . toCharArray (  )  ;", "this . pathPatternLength    =    this . pathPatternData . length ;", "this . headPE    =    null ;", "this . currentPE    =    null ;", "this . capturedVariableNames    =    null ;", "this . pathElementStart    =     -  1  ;", "this . pos    =     0  ;", "resetPathElementState (  )  ;", "while    (  ( this . pos )     <     ( this . pathPatternLength )  )     {", "char   ch    =    this . pathPatternData [ this . pos ]  ;", "if    ( ch    =  =     ( this . parser . getSeparator (  )  )  )     {", "if    (  ( this . pathElementStart )     !  =     (  -  1  )  )     {", "pushPathElement ( createPathElement (  )  )  ;", "}", "if    ( peekDoubleWildcard (  )  )     {", "pushPathElement ( new   WildcardTheRestPathElement ( this . pos ,    this . parser . getSeparator (  )  )  )  ;", "this . pos    +  =     2  ;", "} else    {", "pushPathElement ( new   SeparatorPathElement ( this . pos ,    this . parser . getSeparator (  )  )  )  ;", "}", "} else    {", "if    (  ( this . pathElementStart )     =  =     (  -  1  )  )     {", "this . pathElementStart    =    this . pos ;", "}", "if    ( ch    =  =     '  ?  '  )     {", "( this . singleCharWildcardCount )  +  +  ;", "} else", "if    ( ch    =  =     '  {  '  )     {", "if    ( this . insideVariableCapture )     {", "throw   new   Exception ( this . pos ,    this . pathPatternData ,    Exception . PatternMessage . ILLEGAL _ NESTED _ CAPTURE )  ;", "}", "this . insideVariableCapture    =    true ;", "this . variableCaptureStart    =    pos ;", "} else", "if    ( ch    =  =     '  }  '  )     {", "if    (  !  ( this . insideVariableCapture )  )     {", "throw   new   Exception ( this . pos ,    this . pathPatternData ,    Exception . PatternMessage . MISSING _ OPEN _ CAPTURE )  ;", "}", "this . insideVariableCapture    =    false ;", "if    (  ( this . isCaptureTheRestVariable )     &  &     (  (  ( this . pos )     +     1  )     <     ( this . pathPatternLength )  )  )     {", "throw   new   Exception (  (  ( this . pos )     +     1  )  ,    this . pathPatternData ,    Exception . PatternMessage . NO _ MORE _ DATA _ EXPECTED _ AFTER _ CAPTURE _ THE _ REST )  ;", "}", "( this . variableCaptureCount )  +  +  ;", "} else", "if    ( ch    =  =     '  :  '  )     {", "if    (  ( this . insideVariableCapture )     &  &     (  !  ( this . isCaptureTheRestVariable )  )  )     {", "skipCaptureRegex (  )  ;", "this . insideVariableCapture    =    false ;", "( this . variableCaptureCount )  +  +  ;", "}", "} else", "if    ( ch    =  =     '  *  '  )     {", "if    (  ( this . insideVariableCapture )     &  &     (  ( this . variableCaptureStart )     =  =     (  ( this . pos )     -     1  )  )  )     {", "this . isCaptureTheRestVariable    =    true ;", "}", "this . wildcard    =    true ;", "}", "if    ( this . insideVariableCapture )     {", "if    (  (  (  (  ( this . variableCaptureStart )     +     1  )     +     ( this . isCaptureTheRestVariable    ?     1     :     0  )  )     =  =     ( this . pos )  )     &  &     (  !  ( Character . isJavaIdentifierStart ( ch )  )  )  )     {", "throw   new   Exception ( this . pos ,    this . pathPatternData ,    Exception . PatternMessage . ILLEGAL _ CHARACTER _ AT _ START _ OF _ CAPTURE _ DESCRIPTOR ,    Character . toString ( ch )  )  ;", "} else", "if    (  (  ( this . pos )     >     (  (  ( this . variableCaptureStart )     +     1  )     +     ( this . isCaptureTheRestVariable    ?     1     :     0  )  )  )     &  &     (  !  ( Character . isJavaIdentifierPart ( ch )  )  )  )     {", "throw   new   Exception ( this . pos ,    this . pathPatternData ,    Exception . PatternMessage . ILLEGAL _ CHARACTER _ IN _ CAPTURE _ DESCRIPTOR ,    Character . toString ( ch )  )  ;", "}", "}", "}", "( this . pos )  +  +  ;", "}", "if    (  ( this . pathElementStart )     !  =     (  -  1  )  )     {", "pushPathElement ( createPathElement (  )  )  ;", "}", "return   new   PathPattern ( pathPattern ,    this . parser ,    this . headPE )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . pos )     +     2  )     >  =     ( this . pathPatternLength )  )     {", "return   false ;", "}", "if    (  (  ( this . pathPatternData [  (  ( this . pos )     +     1  )  ]  )     !  =     '  *  '  )     |  |     (  ( this . pathPatternData [  (  ( this . pos )     +     2  )  ]  )     !  =     '  *  '  )  )     {", "return   false ;", "}", "return    (  ( this . pos )     +     3  )     =  =     ( this . pathPatternLength )  ;", "}", "METHOD_END"], "methodName": ["peekDoubleWildcard"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "if    ( newPathElement   instanceof   CaptureTheRestPathElement )     {", "if    (  ( this . currentPE )     =  =    null )     {", "this . headPE    =    newPathElement ;", "this . currentPE    =    newPathElement ;", "} else", "if    (  ( this . currentPE )    instanceof   SeparatorPathElement )     {", "PathElement   peBeforeSeparator    =    this . currentPE . prev ;", "if    ( peBeforeSeparator    =  =    null )     {", "this . headPE    =    newPathElement ;", "newPathElement . prev    =    null ;", "} else    {", "peBeforeSeparator . next    =    newPathElement ;", "newPathElement . prev    =    peBeforeSeparator ;", "}", "this . currentPE    =    newPathElement ;", "} else    {", "throw   new   IllegalStateException (  (  \" Expected   SeparatorPathElement   but   was    \"     +     ( this . currentPE )  )  )  ;", "}", "} else    {", "if    (  ( this . headPE )     =  =    null )     {", "this . headPE    =    newPathElement ;", "this . currentPE    =    newPathElement ;", "} else", "if    (  ( this . currentPE )     !  =    null )     {", "this . currentPE . next    =    newPathElement ;", "newPathElement . prev    =    this . currentPE ;", "this . currentPE    =    newPathElement ;", "}", "}", "resetPathElementState (  )  ;", "}", "METHOD_END"], "methodName": ["pushPathElement"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . capturedVariableNames )     =  =    null )     {", "this . capturedVariableNames    =    new   ArrayList <  >  (  )  ;", "}", "if    ( this . capturedVariableNames . contains ( variableName )  )     {", "throw   new   Exception ( pos ,    this . pathPatternData ,    Exception . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE ,    variableName )  ;", "}", "this . capturedVariableNames . add ( variableName )  ;", "}", "METHOD_END"], "methodName": ["recordCapturedVariable"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "this . pathElementStart    =     -  1  ;", "this . singleCharWildcardCount    =     0  ;", "this . insideVariableCapture    =    false ;", "this . variableCaptureCount    =     0  ;", "this . wildcard    =    false ;", "this . isCaptureTheRestVariable    =    false ;", "this . variableCaptureStart    =     -  1  ;", "}", "METHOD_END"], "methodName": ["resetPathElementState"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "( this . pos )  +  +  ;", "int   regexStart    =    this . pos ;", "int   curlyBracketDepth    =     0  ;", "boolean   previousBackslash    =    false ;", "while    (  ( this . pos )     <     ( this . pathPatternLength )  )     {", "char   ch    =    this . pathPatternData [ pos ]  ;", "if    (  ( ch    =  =     '  \\  \\  '  )     &  &     (  ! previousBackslash )  )     {", "( this . pos )  +  +  ;", "previousBackslash    =    true ;", "continue ;", "}", "if    (  ( ch    =  =     '  {  '  )     &  &     (  ! previousBackslash )  )     {", "curlyBracketDepth +  +  ;", "} else", "if    (  ( ch    =  =     '  }  '  )     &  &     (  ! previousBackslash )  )     {", "if    ( curlyBracketDepth    =  =     0  )     {", "if    ( regexStart    =  =     ( this . pos )  )     {", "throw   new   Exception ( regexStart ,    this . pathPatternData ,    Exception . PatternMessage . MISSING _ REGEX _ CONSTRAINT )  ;", "}", "return ;", "}", "curlyBracketDepth -  -  ;", "}", "if    (  ( ch    =  =     ( this . parser . getSeparator (  )  )  )     &  &     (  ! previousBackslash )  )     {", "throw   new   Exception ( this . pos ,    this . pathPatternData ,    Exception . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "}", "( this . pos )  +  +  ;", "previousBackslash    =    false ;", "}", "throw   new   Exception (  (  ( this . pos )     -     1  )  ,    this . pathPatternData ,    Exception . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "}", "METHOD_END"], "methodName": ["skipCaptureRegex"], "fileName": "org.springframework.web.util.pattern.InternalPathPatternParser"}, {"methodBody": ["METHOD_START", "{", "return   this . text ;", "}", "METHOD_END"], "methodName": ["getChars"], "fileName": "org.springframework.web.util.pattern.LiteralPathElement"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Literal (  \"     +     ( String . valueOf ( this . text )  )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.LiteralPathElement"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getCaptureCount"], "fileName": "org.springframework.web.util.pattern.PathElement"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getScore"], "fileName": "org.springframework.web.util.pattern.PathElement"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getWildcardCount"], "fileName": "org.springframework.web.util.pattern.PathElement"}, {"methodBody": ["METHOD_START", "{", "return    ( this . next )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isNoMorePattern"], "fileName": "org.springframework.web.util.pattern.PathElement"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( this . patternString )  )  )     {", "if    (  !  ( StringUtils . hasLength ( pattern 2 string . patternString )  )  )     {", "return   parser . parse (  \"  \"  )  ;", "} else    {", "return   pattern 2 string ;", "}", "} else", "if    (  !  ( StringUtils . hasLength ( pattern 2 string . patternString )  )  )     {", "return   this ;", "}", "if    (  (  (  !  ( this . patternString . equals ( pattern 2 string . patternString )  )  )     &  &     (  ( this . capturedVariableCount )     =  =     0  )  )     &  &     ( matches ( PathContainer . parsePath ( pattern 2 string . patternString )  )  )  )     {", "return   pattern 2 string ;", "}", "if    ( this . endsWithSeparatorWildcard )     {", "return   parser . parse ( concat ( this . patternString . substring (  0  ,     (  ( this . patternString . length (  )  )     -     2  )  )  ,    pattern 2 string . patternString )  )  ;", "}", "int   starDotPos 1     =    this . patternString . indexOf (  \"  *  .  \"  )  ;", "if    (  (  (  ( this . capturedVariableCount )     !  =     0  )     |  |     ( starDotPos 1     =  =     (  -  1  )  )  )     |  |     (  ( this . separator )     =  =     '  .  '  )  )     {", "return   parser . parse ( concat ( this . patternString ,    pattern 2 string . patternString )  )  ;", "}", "String   firstExtension    =    this . patternString . substring (  ( starDotPos 1     +     1  )  )  ;", "String   p 2 string    =    pattern 2 string . patternString ;", "int   dotPos 2     =    p 2 string . indexOf (  '  .  '  )  ;", "String   file 2     =     ( dotPos 2     =  =     (  -  1  )  )     ?    p 2 string    :    p 2 string . substring (  0  ,    dotPos 2  )  ;", "String   secondExtension    =     ( dotPos 2     =  =     (  -  1  )  )     ?     \"  \"     :    p 2 string . substring ( dotPos 2  )  ;", "boolean   firstExtensionWild    =     ( firstExtension . equals (  \"  .  *  \"  )  )     |  |     ( firstExtension . equals (  \"  \"  )  )  ;", "boolean   secondExtensionWild    =     ( secondExtension . equals (  \"  .  *  \"  )  )     |  |     ( secondExtension . equals (  \"  \"  )  )  ;", "if    (  (  ! firstExtensionWild )     &  &     (  ! secondExtensionWild )  )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Cannot   combine   patterns :     \"     +     ( this . patternString )  )     +     \"    and    \"  )     +    pattern 2 string )  )  ;", "}", "return   parser . parse (  ( file 2     +     ( firstExtensionWild    ?    secondExtension    :    firstExtension )  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "PathElement   pe    =    this . head ;", "while    ( pe    !  =    null )     {", "buf . append ( pe . getChars (  )  )  ;", "pe    =    pe . next ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["computePatternString"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "boolean   path 1 EndsWithSeparator    =     ( path 1  . charAt (  (  ( path 1  . length (  )  )     -     1  )  )  )     =  =     ( this . separator )  ;", "boolean   path 2 StartsWithSeparator    =     ( path 2  . charAt (  0  )  )     =  =     ( this . separator )  ;", "if    ( path 1 EndsWithSeparator    &  &    path 2 StartsWithSeparator )     {", "return   path 1     +     ( path 2  . subst (  1  )  )  ;", "} else", "if    ( path 1 EndsWithSeparator    |  |    path 2 StartsWithSeparator )     {", "return   path 1     +    path 2  ;", "} else    {", "return    ( path 1     +     ( this . separator )  )     +    path 2  ;", "}", "}", "METHOD_END"], "methodName": ["concat"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   PathPattern )  )     {", "return   false ;", "}", "PathPattern   otherPattern    =     (  ( PathPattern )     ( other )  )  ;", "return    (  ( this . patternString . equals ( otherPattern . getPatternString (  )  )  )     &  &     (  ( this . separator )     =  =     ( otherPattern . getSeparator (  )  )  )  )     &  &     (  ( this . caseSensitive )     =  =     ( otherPattern . caseSensitive )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "List < PathContainer . Element >    pathElements    =    path . elements (  )  ;", "int   pathElementsCount    =    pathElements . size (  )  ;", "int   startIndex    =     0  ;", "PathElement   elem    =    head ;", "while    ( elem    !  =    null )     {", "if    (  (  ( elem . getWildcardCount (  )  )     !  =     0  )     |  |     (  ( elem . getCaptureCount (  )  )     !  =     0  )  )     {", "break ;", "}", "elem    =    elem . next ;", "startIndex +  +  ;", "}", "if    ( elem    =  =    null )     {", "return   PathContainer . parsePath (  \"  \"  )  ;", "}", "while    (  ( startIndex    <    pathElementsCount )     &  &     (  ( pathElements . get ( startIndex )  )    instanceof   PathContainer . Separator )  )     {", "startIndex +  +  ;", "}", "int   endIndex    =    pathElements . size (  )  ;", "while    (  ( endIndex    >     0  )     &  &     (  ( pathElements . get (  ( endIndex    -     1  )  )  )    instanceof   PathContainer . Separator )  )     {", "endIndex -  -  ;", "}", "boolean   multipleAdjacentSeparators    =    false ;", "for    ( int   i    =    startIndex ;    i    <     ( endIndex    -     1  )  ;    i +  +  )     {", "if    (  (  ( pathElements . get ( i )  )    instanceof   PathContainer . Separator )     &  &     (  ( pathElements . get (  ( i    +     1  )  )  )    instanceof   PathContainer . Separator )  )     {", "multipleAdjacentSeparators    =    true ;", "break ;", "}", "}", "PathContainer   resultPath    =    null ;", "if    ( multipleAdjacentSeparators )     {", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "int   i    =    startIndex ;", "while    ( i    <    endIndex )     {", "PathContainer . Element   e    =    pathElements . get (  ( i +  +  )  )  ;", "buf . append ( e . value (  )  )  ;", "if    ( e   instanceof   PathContainer . Separator )     {", "while    (  ( i    <    endIndex )     &  &     (  ( pathElements . get ( i )  )    instanceof   PathContainer . Separator )  )     {", "i +  +  ;", "}", "}", "}", "resultPath    =    PathContainer . parsePath ( buf . toString (  )  )  ;", "} else", "if    ( startIndex    >  =    endIndex )     {", "resultPath    =    PathContainer . parsePath (  \"  \"  )  ;", "} else    {", "resultPath    =    path . subPath ( startIndex ,    endIndex )  ;", "}", "return   resultPath ;", "}", "METHOD_END"], "methodName": ["extractPathWithinPattern"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return   this . capturedVariableCount ;", "}", "METHOD_END"], "methodName": ["getCapturedVariableCount"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return   this . head ;", "}", "METHOD_END"], "methodName": ["getHeadSection"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return   this . normalizedLength ;", "}", "METHOD_END"], "methodName": ["getNormalizedLength"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return   this . patternString ;", "}", "METHOD_END"], "methodName": ["getPatternString"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return   this . score ;", "}", "METHOD_END"], "methodName": ["getScore"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return   this . separator ;", "}", "METHOD_END"], "methodName": ["getSeparator"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return    ( container    !  =    null )     &  &     (  ( container . elements (  )  . size (  )  )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["hasLength"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( this . patternString . hashCode (  )  )     +     ( this . separator )  )     *     1  7  )     +     ( this . caseSensitive    ?     1     :     0  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return   this . catchAll ;", "}", "METHOD_END"], "methodName": ["isCatchAll"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . head )     =  =    null )     {", "return    ( hasLength ( pathContainer )  )     &  &     (  !  (  ( this . matchOptionalTrailingSeparator )     &  &     ( pathContainerIsJustSeparator ( pathContainer )  )  )  )     ?    null    :    PathPMatchInfo . EMPTY ;", "} else", "if    (  !  ( hasLength ( pathContainer )  )  )     {", "if    (  (  ( this . head )    instanceof   WildcardTheRestPathElement )     |  |     (  ( this . head )    instanceof   CaptureTheRestPathElement )  )     {", "pathContainer    =    PathPattern . EMPTY _ PATH ;", "} else    {", "return   null ;", "}", "}", "PathPattern . MatchingContext   matchingContext    =    new   PathPattern . MatchingContext ( pathContainer ,    true )  ;", "return   this . head . matches (  0  ,    matchingContext )     ?    matchingContext . getPathMatchResult (  )     :    null ;", "}", "METHOD_END"], "methodName": ["matchAndExtract"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . head )     =  =    null )     {", "return   new   PathPRemainingMatchInfo ( pathContainer )  ;", "} else", "if    (  !  ( hasLength ( pathContainer )  )  )     {", "return   null ;", "}", "PathPattern . MatchingContext   matchingContext    =    new   PathPattern . MatchingContext ( pathContainer ,    true )  ;", "matchingContext . setMatchAllowExtraPath (  )  ;", "boolean   matches    =    this . head . matches (  0  ,    matchingContext )  ;", "if    (  ! matches )     {", "return   null ;", "} else    {", "PathPRemainingMatchInfo   info ;", "if    (  ( matchingContext . remainingPathIndex )     =  =     ( pathContainer . elements (  )  . size (  )  )  )     {", "info    =    new   PathPRemainingMatchInfo ( PathPattern . EMPTY _ PATH ,    matchingContext . getPathMatchResult (  )  )  ;", "} else    {", "info    =    new   PathPRemainingMatchInfo ( pathContainer . subPath ( matchingContext . remainingPathIndex )  ,    matchingContext . getPathMatchResult (  )  )  ;", "}", "return   info ;", "}", "}", "METHOD_END"], "methodName": ["matchStartOfPath"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . head )     =  =    null )     {", "return    (  !  ( hasLength ( pathContainer )  )  )     |  |     (  ( this . matchOptionalTrailingSeparator )     &  &     ( pathContainerIsJustSeparator ( pathContainer )  )  )  ;", "} else", "if    (  !  ( hasLength ( pathContainer )  )  )     {", "if    (  (  ( this . head )    instanceof   WildcardTheRestPathElement )     |  |     (  ( this . head )    instanceof   CaptureTheRestPathElement )  )     {", "pathContainer    =     . EMPTY _ PATH ;", "} else    {", "return   false ;", "}", "}", ". MatchingContext   matchingContext    =    new    . MatchingContext ( pathContainer ,    false )  ;", "return   this . head . matches (  0  ,    matchingContext )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return    (  ( pathContainer . value (  )  . length (  )  )     =  =     1  )     &  &     (  ( pathContainer . value (  )  . charAt (  0  )  )     =  =     ( separator )  )  ;", "}", "METHOD_END"], "methodName": ["pathContainerIsJustSeparator"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return    -  ( pattern . getNormalizedLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["scoreByNormalizedLength"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "PathElement   pe    =    this . head ;", "while    ( pe    !  =    null )     {", "buf . append ( pe . toString (  )  )  . append (  \"     \"  )  ;", "pe    =    pe . next ;", "}", "return   buf . toString (  )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["toChainString"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return   this . patternString ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.PathPattern"}, {"methodBody": ["METHOD_START", "{", "return    '  /  '  ;", "}", "METHOD_END"], "methodName": ["getSeparator"], "fileName": "org.springframework.web.util.pattern.PathPatternParser"}, {"methodBody": ["METHOD_START", "{", "return   this . caseSensitive ;", "}", "METHOD_END"], "methodName": ["isCaseSensitive"], "fileName": "org.springframework.web.util.pattern.PathPatternParser"}, {"methodBody": ["METHOD_START", "{", "return   this . matchOptionalTrailingSeparator ;", "}", "METHOD_END"], "methodName": ["isMatchOptionalTrailingSeparator"], "fileName": "org.springframework.web.util.pattern.PathPatternParser"}, {"methodBody": ["METHOD_START", "{", "return   new   InternalPathPatternParser ( this )  . parse ( pathPattern )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.web.util.pattern.PathPatternParser"}, {"methodBody": ["METHOD_START", "{", "this . caseSensitive    =    caseSensitive ;", "}", "METHOD_END"], "methodName": ["setCaseSensitive"], "fileName": "org.springframework.web.util.pattern.PathPatternParser"}, {"methodBody": ["METHOD_START", "{", "this . matchOptionalTrailingSeparator    =    matchOptionalTrailingSeparator ;", "}", "METHOD_END"], "methodName": ["setMatchOptionalTrailingSeparator"], "fileName": "org.springframework.web.util.pattern.PathPatternParser"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( pp . matches ( PathPatternTests . toPathContainer ( path )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMatches"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( pp . matches ( PathPatternTests . toPathContainer ( path )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNoMatch"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "PathElement   head    =    p . getHeadSection (  )  ;", "for    ( Class <  ?    extends   PathElement >    sectionClass    :    sectionClasses )     {", "if    ( head    =  =    null )     {", "fail (  (  \" Ran   out   of   data   in   parsed      Pattern   is :     \"     +     ( p . toChainString (  )  )  )  )  ;", "}", "assertEquals (  (  \" Not   expected   section   type .    Pattern   is :     \"     +     ( p . toChainString (  )  )  )  ,    sectionClass . getSimpleName (  )  ,    head . getClass (  )  . getSimpleName (  )  )  ;", "head    =    head . next ;", "}", "}", "METHOD_END"], "methodName": ["assertPathElements"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "checkError (  \"  /  {  ?  }  /  \"  ,     2  ,    PatternParseException . PatternMessage . ILLEGAL _ CHARACTER _ AT _ START _ OF _ CAPTURE _ DESCRIPTOR ,     \"  ?  \"  )  ;", "checkError (  \"  /  { a ? b }  /  \"  ,     3  ,    PatternParseException . PatternMessage . ILLEGAL _ CHARACTER _ IN _ CAPTURE _ DESCRIPTOR ,     \"  ?  \"  )  ;", "checkError (  \"  /  {  %  %  $  }  \"  ,     2  ,    PatternParseException . PatternMessage . ILLEGAL _ CHARACTER _ AT _ START _ OF _ CAPTURE _ DESCRIPTOR ,     \"  %  \"  )  ;", "checkError (  \"  /  {     }  \"  ,     2  ,    PatternParseException . PatternMessage . ILLEGAL _ CHARACTER _ AT _ START _ OF _ CAPTURE _ DESCRIPTOR ,     \"     \"  )  ;", "checkError (  \"  /  {  %  :  [  0  -  9  ]  *  }  \"  ,     2  ,    PatternParseException . PatternMessage . ILLEGAL _ CHARACTER _ AT _ START _ OF _ CAPTURE _ DESCRIPTOR ,     \"  %  \"  )  ;", "}", "METHOD_END"], "methodName": ["badPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "checkStructure (  \"  /  \"  )  ;", "checkStructure (  \"  / foo \"  )  ;", "checkStructure (  \" foo \"  )  ;", "checkStructure (  \" foo /  \"  )  ;", "checkStructure (  \"  / foo /  \"  )  ;", "checkStructure (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["basicPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "pathPattern    =    parse (  \"  {  * foobar }  \"  )  ;", "assertEquals (  \"  /  {  * foobar }  \"  ,    pathPattern . computePatternString (  )  )  ;", "assertPathElements ( pathPattern ,    CaptureTheRestPathElement . class )  ;", "pathPattern    =    checkStructure (  \"  /  {  * foobar }  \"  )  ;", "assertPathElements ( pathPattern ,    CaptureTheRestPathElement . class )  ;", "checkError (  \"  /  {  * foobar }  /  \"  ,     1  0  ,    Exception . PatternMessage . NO _ MORE _ DATA _ EXPECTED _ AFTER _ CAPTURE _ THE _ REST )  ;", "checkError (  \"  /  {  * foobar } abc \"  ,     1  0  ,    Exception . PatternMessage . NO _ MORE _ DATA _ EXPECTED _ AFTER _ CAPTURE _ THE _ REST )  ;", "checkError (  \"  /  {  * f % obar }  \"  ,     4  ,    Exception . PatternMessage . ILLEGAL _ CHARACTER _ IN _ CAPTURE _ DESCRIPTOR )  ;", "checkError (  \"  /  {  * foobar } abc \"  ,     1  0  ,    Exception . PatternMessage . NO _ MORE _ DATA _ EXPECTED _ AFTER _ CAPTURE _ THE _ REST )  ;", "checkError (  \"  /  { f * oobar }  \"  ,     3  ,    Exception . PatternMessage . ILLEGAL _ CHARACTER _ IN _ CAPTURE _ DESCRIPTOR )  ;", "checkError (  \"  /  {  * foobar }  / abc \"  ,     1  0  ,    Exception . PatternMessage . NO _ MORE _ DATA _ EXPECTED _ AFTER _ CAPTURE _ THE _ REST )  ;", "checkError (  \"  /  {  * foobar :  .  *  }  / abc \"  ,     9  ,    Exception . PatternMessage . ILLEGAL _ CHARACTER _ IN _ CAPTURE _ DESCRIPTOR )  ;", "checkError (  \"  /  { abc }  {  * foobar }  \"  ,     1  ,    Exception . PatternMessage . CAPTURE _ ALL _ IS _ STANDALONE _ CONSTRUCT )  ;", "checkError (  \"  /  { abc }  {  * foobar }  { foo }  \"  ,     1  5  ,    Exception . PatternMessage . NO _ MORE _ DATA _ EXPECTED _ AFTER _ CAPTURE _ THE _ REST )  ;", "}", "METHOD_END"], "methodName": ["captureTheRestPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "pathPattern    =    parse ( pattern )  ;", "fail (  \" Expected   to   fail \"  )  ;", "}    catch    ( Exception   ppe )     {", "assertEquals ( ppe . toDetailedString (  )  ,    expectedPos ,    ppe . getPosition (  )  )  ;", "assertEquals ( ppe . toDetailedString (  )  ,    expectedMessage ,    ppe . getMessageType (  )  )  ;", "if    (  ( expectedInserts . length )     !  =     0  )     {", "assertEquals ( ppe . getInserts (  )  . length ,    expectedInserts . length )  ;", "for    ( int   i    =     0  ;    i    <     ( expectedInserts . length )  ;    i +  +  )     {", "assertEquals (  (  (  \" Insert   at   position    \"     +    i )     +     \"    is   wrong \"  )  ,    expectedInserts [ i ]  ,    ppe . getInserts (  )  [ i ]  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkError"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "PathPattern   pp    =    parse ( pattern )  ;", "assertEquals ( pattern ,    pp . computePatternString (  )  )  ;", "return   pp ;", "}", "METHOD_END"], "methodName": ["checkStructure"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "PathPattern   p 1  ;", "PathPattern   p 2  ;", "PathPattern   p 3  ;", "p 1     =    parse (  \"  { a }  \"  )  ;", "p 2     =    parse (  \"  { a }  /  { b }  \"  )  ;", "p 3     =    parse (  \"  { a }  /  { b }  /  { c }  \"  )  ;", "assertEquals (  (  -  1  )  ,    p 1  . compareTo ( p 2  )  )  ;", "List < PathPattern >    patterns    =    new   ArrayList <  >  (  )  ;", "patterns . add ( p 2  )  ;", "patterns . add ( p 3  )  ;", "patterns . add ( p 1  )  ;", "Collections . sort ( patterns )  ;", "assertEquals ( p 1  ,    patterns . get (  0  )  )  ;", "p 1     =    parse (  \"  / a / b / c \"  )  ;", "p 2     =    parse (  \"  / a / boo / c / doo \"  )  ;", "p 3     =    parse (  \"  / asdjflaksjdfjasdf \"  )  ;", "assertEquals (  1  ,    p 1  . compareTo ( p 2  )  )  ;", "patterns    =    new   ArrayList <  >  (  )  ;", "patterns . add ( p 2  )  ;", "patterns . add ( p 3  )  ;", "patterns . add ( p 1  )  ;", "Collections . sort ( patterns )  ;", "assertEquals ( p 3  ,    patterns . get (  0  )  )  ;", "p 1     =    parse (  \"  /  *  \"  )  ;", "p 2     =    parse (  \"  /  *  /  *  \"  )  ;", "p 3     =    parse (  \"  /  *  /  *  /  *  _  *  \"  )  ;", "assertEquals (  (  -  1  )  ,    p 1  . compareTo ( p 2  )  )  ;", "patterns    =    new   ArrayList <  >  (  )  ;", "patterns . add ( p 2  )  ;", "patterns . add ( p 3  )  ;", "patterns . add ( p 1  )  ;", "Collections . sort ( patterns )  ;", "assertEquals ( p 1  ,    patterns . get (  0  )  )  ;", "p 1     =    parse (  \"  {  * foobar }  \"  )  ;", "p 2     =    parse (  \"  {  * goo }  \"  )  ;", "assertTrue (  (  ( p 1  . compareTo ( p 2  )  )     !  =     0  )  )  ;", "p 1     =    parse (  \"  /  {  * foobar }  \"  )  ;", "p 2     =    parse (  \"  / abc /  {  * ww }  \"  )  ;", "assertEquals (  (  +  1  )  ,    p 1  . compareTo ( p 2  )  )  ;", "assertEquals (  (  -  1  )  ,    p 2  . compareTo ( p 1  )  )  ;", "p 3     =    parse (  \"  / this / that / theother \"  )  ;", "assertTrue ( p 1  . isCatchAll (  )  )  ;", "assertTrue ( p 2  . isCatchAll (  )  )  ;", "assertFalse ( p 3  . isCatchAll (  )  )  ;", "patterns    =    new   ArrayList <  >  (  )  ;", "patterns . add ( p 2  )  ;", "patterns . add ( p 3  )  ;", "patterns . add ( p 1  )  ;", "Collections . sort ( patterns )  ;", "assertEquals ( p 3  ,    patterns . get (  0  )  )  ;", "assertEquals ( p 2  ,    patterns . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTests"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "pathPattern    =    checkStructure (  \"  { foo :  .  .  .  }  \"  )  ;", "assertPathElements ( pathPattern ,    CaptureVariablePathElement . class )  ;", "pathPattern    =    checkStructure (  \"  { foo :  [  0  -  9  ]  *  }  \"  )  ;", "assertPathElements ( pathPattern ,    CaptureVariablePathElement . class )  ;", "checkError (  \"  { foo :  }  \"  ,     5  ,    Exception . PatternMessage . MISSING _ REGEX _ CONSTRAINT )  ;", "}", "METHOD_END"], "methodName": ["completeCaptureWithConstraints"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "pathPattern    =    checkStructure (  \"  { foo }  \"  )  ;", "assertEquals ( CaptureVariablePathElement . class . getName (  )  ,    pathPattern . getHeadSection (  )  . getClass (  )  . getName (  )  )  ;", "checkStructure (  \"  /  { foo }  \"  )  ;", "checkStructure (  \"  /  { f }  /  \"  )  ;", "checkStructure (  \"  /  { foo }  /  { bar }  /  { wibble }  \"  )  ;", "}", "METHOD_END"], "methodName": ["completeCapturingPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "return   capturedVariableCount    +     ( wildcardCount    *     1  0  0  )  ;", "}", "METHOD_END"], "methodName": ["computeScore"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   caseInsensitiveParser    =    new   PathPatternParser (  )  ;", "caseInsensitiveParser . setCaseSensitive ( false )  ;", "PathPatternParser   caseSensitiveParser    =    new   PathPatternParser (  )  ;", "PathPattern   pp 1     =    caseInsensitiveParser . parse (  \"  / abc \"  )  ;", "PathPattern   pp 2     =    caseInsensitiveParser . parse (  \"  / abc \"  )  ;", "PathPattern   pp 3     =    caseInsensitiveParser . parse (  \"  / def \"  )  ;", "assertEquals ( pp 1  ,    pp 2  )  ;", "assertEquals ( pp 1  . hashCode (  )  ,    pp 2  . hashCode (  )  )  ;", "assertNotEquals ( pp 1  ,    pp 3  )  ;", "assertFalse ( pp 1  . equals (  \" abc \"  )  )  ;", "pp 1     =    caseInsensitiveParser . parse (  \"  / abc \"  )  ;", "pp 2     =    caseSensitiveParser . parse (  \"  / abc \"  )  ;", "assertFalse ( pp 1  . equals ( pp 2  )  )  ;", "assertNotEquals ( pp 1  . hashCode (  )  ,    pp 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsAndHashcode"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "checkError (  \"  { abc /  \"  ,     4  ,    PatternParseException . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "checkError (  \"  { abc :  }  /  \"  ,     5  ,    PatternParseException . PatternMessage . MISSING _ REGEX _ CONSTRAINT )  ;", "checkError (  \"  {  \"  ,     1  ,    PatternParseException . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "checkError (  \"  { abc \"  ,     4  ,    PatternParseException . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "checkError (  \"  {  /  }  \"  ,     1  ,    PatternParseException . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "checkError (  \"  /  {  \"  ,     2  ,    PatternParseException . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "checkError (  \"  }  \"  ,     0  ,    PatternParseException . PatternMessage . MISSING _ OPEN _ CAPTURE )  ;", "checkError (  \"  /  }  \"  ,     1  ,    PatternParseException . PatternMessage . MISSING _ OPEN _ CAPTURE )  ;", "checkError (  \" def }  \"  ,     3  ,    PatternParseException . PatternMessage . MISSING _ OPEN _ CAPTURE )  ;", "checkError (  \"  /  {  /  }  \"  ,     2  ,    PatternParseException . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "checkError (  \"  /  {  {  /  }  \"  ,     2  ,    PatternParseException . PatternMessage . ILLEGAL _ NESTED _ CAPTURE )  ;", "checkError (  \"  /  { abc {  /  }  \"  ,     5  ,    PatternParseException . PatternMessage . ILLEGAL _ NESTED _ CAPTURE )  ;", "checkError (  \"  /  {  0 abc }  / abc \"  ,     2  ,    PatternParseException . PatternMessage . ILLEGAL _ CHARACTER _ AT _ START _ OF _ CAPTURE _ DESCRIPTOR )  ;", "checkError (  \"  /  { a ? bc }  / abc \"  ,     3  ,    PatternParseException . PatternMessage . ILLEGAL _ CHARACTER _ IN _ CAPTURE _ DESCRIPTOR )  ;", "checkError (  \"  /  { abc }  _  { abc }  \"  ,     1  ,    PatternParseException . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE )  ;", "checkError (  \"  / foobar /  { abc }  _  { abc }  \"  ,     8  ,    PatternParseException . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE )  ;", "checkError (  \"  / foobar /  { abc :  .  .  }  _  { abc :  .  .  }  \"  ,     8  ,    PatternParseException . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE )  ;", "PathPattern   pp    =    parse (  \"  /  { abc : foo ( bar )  }  \"  )  ;", "try    {", "pp . matchAndExtract ( toPSC (  \"  / foo \"  )  )  ;", "fail (  \" Should   have   raised   exception \"  )  ;", "}    catch    ( IllegalArgumentException   iae )     {", "assertEquals (  \" No   capture   groups   allowed   in   the   constraint   regex :    foo ( bar )  \"  ,    iae . getMessage (  )  )  ;", "}", "try    {", "pp . matchAndExtract ( toPSC (  \"  / foobar \"  )  )  ;", "fail (  \" Should   have   raised   exception \"  )  ;", "}    catch    ( IllegalArgumentException   iae )     {", "assertEquals (  \" No   capture   groups   allowed   in   the   constraint   regex :    foo ( bar )  \"  ,    iae . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["illegalCapturePatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "return   pp . matchAndExtract ( PathPatternTests . toPathContainer ( path )  )  ;", "}", "METHOD_END"], "methodName": ["matchAndExtract"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "pathPattern    =    checkStructure (  \"  /  /  / aaa \"  )  ;", "assertEquals (  6  ,    pathPattern . getNormalizedLength (  )  )  ;", "assertPathElements ( pathPattern ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    LiteralPathElement . class )  ;", "pathPattern    =    checkStructure (  \"  /  /  / aaa /  /  /  / aaa / b \"  )  ;", "assertEquals (  1  5  ,    pathPattern . getNormalizedLength (  )  )  ;", "assertPathElements ( pathPattern ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    LiteralPathElement . class ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    LiteralPathElement . class ,    SeparatorPathElement . class ,    LiteralPathElement . class )  ;", "pathPattern    =    checkStructure (  \"  /  /  /  /  /  *  *  \"  )  ;", "assertEquals (  5  ,    pathPattern . getNormalizedLength (  )  )  ;", "assertPathElements ( pathPattern ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    SeparatorPathElement . class ,    WildcardTheRestPathElement . class )  ;", "}", "METHOD_END"], "methodName": ["multipleSeparatorPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "pathPattern    =    checkStructure (  \"  /  *  *  \"  )  ;", "assertPathElements ( pathPattern ,    WildcardTheRestPathElement . class )  ;", "pathPattern    =    checkStructure (  \"  /  *  * acb \"  )  ;", "assertPathElements ( pathPattern ,    SeparatorPathElement . class ,    RegexPathElement . class )  ;", "}", "METHOD_END"], "methodName": ["multiwildcardPattern"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "PathPattern   pp    =    parse (  \"  /  { var : f   o }  \"  )  ;", "assertEquals (  \" Separator (  /  )    CaptureVariable (  { var : f   o }  )  \"  ,    pp . toChainString (  )  )  ;", "pp    =    parse (  \"  /  { var : f   o }  _  \"  )  ;", "assertEquals (  \" Separator (  /  )    Regex (  { var : f   o }  _  )  \"  ,    pp . toChainString (  )  )  ;", "pp    =    parse (  \"  { foo : f   o }  _     _  { bar : b \\  \\  | o }  \"  )  ;", "assertEquals (  \" Regex (  { foo : f   o }  _     _  { bar : b \\  \\  | o }  )  \"  ,    pp . toChainString (  )  )  ;", "}", "METHOD_END"], "methodName": ["noEncoding"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   patternParser    =    new   PathPatternParser (  )  ;", "return   patternParser . parse ( pattern )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "pathPattern    =    checkStructure (  \"  { foo } abc \"  )  ;", "assertEquals ( RegexPathElement . class . getName (  )  ,    pathPattern . getHeadSection (  )  . getClass (  )  . getName (  )  )  ;", "checkStructure (  \" abc { foo }  \"  )  ;", "checkStructure (  \"  / abc { foo }  \"  )  ;", "checkStructure (  \"  { foo } def /  \"  )  ;", "checkStructure (  \"  / abc { foo } def /  \"  )  ;", "checkStructure (  \"  { foo } abc { bar }  \"  )  ;", "checkStructure (  \"  { foo } abc { bar }  /  \"  )  ;", "checkStructure (  \"  /  { foo } abc { bar }  /  \"  )  ;", "}", "METHOD_END"], "methodName": ["partialCapturingPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    parse (  \"  { foo }  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  0  ,    parse (  \" foo \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  1  ,    parse (  \"  {  * foobar }  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  1  ,    parse (  \"  /  {  * foobar }  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  0  ,    parse (  \"  /  *  *  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  1  ,    parse (  \"  { abc } asdf \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  1  ,    parse (  \"  { abc }  _  *  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  2  ,    parse (  \"  { abc }  _  { def }  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  0  ,    parse (  \"  /  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  0  ,    parse (  \" a ? b \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  0  ,    parse (  \"  *  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  0  ,    parse (  \"  / foo / bar \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  1  ,    parse (  \"  /  { foo }  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  2  ,    parse (  \"  /  { foo }  /  { bar }  \"  )  . getCapturedVariableCount (  )  )  ;", "assertEquals (  4  ,    parse (  \"  /  { foo }  /  { bar }  _  { goo }  _  { wibble }  / abc / bar \"  )  . getCapturedVariableCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["patternPropertyGetCaptureCountTests"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    parse (  \"  { foo }  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  3  ,    parse (  \" foo \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  1  ,    parse (  \"  {  * foobar }  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  1  ,    parse (  \"  /  {  * foobar }  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  1  ,    parse (  \"  /  *  *  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  5  ,    parse (  \"  { abc } asdf \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  3  ,    parse (  \"  { abc }  _  *  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  3  ,    parse (  \"  { abc }  _  { def }  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  1  ,    parse (  \"  /  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  3  ,    parse (  \" a ? b \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  1  ,    parse (  \"  *  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  8  ,    parse (  \"  / foo / bar \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  2  ,    parse (  \"  /  { foo }  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  4  ,    parse (  \"  /  { foo }  /  { bar }  \"  )  . getNormalizedLength (  )  )  ;", "assertEquals (  1  6  ,    parse (  \"  /  { foo }  /  { bar }  _  { goo }  _  { wibble }  / abc / bar \"  )  . getNormalizedLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["patternPropertyGetLengthTests"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( computeScore (  1  ,     0  )  ,    parse (  \"  { foo }  \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  0  ,     0  )  ,    parse (  \" foo \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  0  ,     0  )  ,    parse (  \"  {  * foobar }  \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  1  ,     0  )  ,    parse (  \"  { abc } asdf \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  1  ,     1  )  ,    parse (  \"  { abc }  _  *  \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  2  ,     0  )  ,    parse (  \"  { abc }  _  { def }  \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  0  ,     0  )  ,    parse (  \"  /  \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  0  ,     0  )  ,    parse (  \" a ? b \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  0  ,     1  )  ,    parse (  \"  *  \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  0  ,     0  )  ,    parse (  \"  / foo / bar \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  1  ,     0  )  ,    parse (  \"  /  { foo }  \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  2  ,     0  )  ,    parse (  \"  /  { foo }  /  { bar }  \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  4  ,     0  )  ,    parse (  \"  /  { foo }  /  { bar }  _  { goo }  _  { wibble }  / abc / bar \"  )  . getScore (  )  )  ;", "assertEquals ( computeScore (  4  ,     3  )  ,    parse (  \"  /  { foo }  /  *  /  *  _  *  /  { bar }  _  { goo }  _  { wibble }  / abc / bar \"  )  . getScore (  )  )  ;", "}", "METHOD_END"], "methodName": ["patternPropertyGetWildcardCountTests"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "checkError (  \"  /  { var :  [  ^  /  ]  *  }  \"  ,     8  ,    PatternParseException . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "checkError (  \"  /  { var : abc \"  ,     8  ,    PatternParseException . PatternMessage . MISSING _ CLOSE _ CAPTURE )  ;", "checkError (  \"  /  { var : a {  {  1  ,  2  }  }  }  \"  ,     6  ,    PatternParseException . PatternMessage . REGEX _ PATTERN _ SYNTAX _ EXCEPTION )  ;", "pathPattern    =    checkStructure (  \"  /  { var :  \\  \\  \\  \\  }  \"  )  ;", "PathElement   next    =    pathPattern . getHeadSection (  )  . next ;", "assertEquals ( CaptureVariablePathElement . class . getName (  )  ,    next . getClass (  )  . getName (  )  )  ;", "assertMatches ( pathPattern ,     \"  /  \\  \\  \"  )  ;", "pathPattern    =    checkStructure (  \"  /  { var :  \\  \\  /  }  \"  )  ;", "next    =    pathPattern . getHeadSection (  )  . next ;", "assertEquals ( CaptureVariablePathElement . class . getName (  )  ,    next . getClass (  )  . getName (  )  )  ;", "assertNoMatch ( pathPattern ,     \"  / aaa \"  )  ;", "pathPattern    =    checkStructure (  \"  /  { var : a {  1  ,  2  }  }  \"  )  ;", "next    =    pathPattern . getHeadSection (  )  . next ;", "assertEquals ( CaptureVariablePathElement . class . getName (  )  ,    next . getClass (  )  . getName (  )  )  ;", "pathPattern    =    checkStructure (  \"  /  { var :  [  ^  \\  \\  /  ]  *  }  \"  )  ;", "next    =    pathPattern . getHeadSection (  )  . next ;", "assertEquals ( CaptureVariablePathElement . class . getName (  )  ,    next . getClass (  )  . getName (  )  )  ;", "PathPattern . PathMatchInfo   result    =    matchAndExtract ( pathPattern ,     \"  / foo \"  )  ;", "assertEquals (  \" foo \"  ,    result . getUriVariables (  )  . get (  \" var \"  )  )  ;", "pathPattern    =    checkStructure (  \"  /  { var :  \\  \\  [  *  }  \"  )  ;", "next    =    pathPattern . getHeadSection (  )  . next ;", "assertEquals ( CaptureVariablePathElement . class . getName (  )  ,    next . getClass (  )  . getName (  )  )  ;", "result    =    matchAndExtract ( pathPattern ,     \"  /  [  [  [  \"  )  ;", "assertEquals (  \"  [  [  [  \"  ,    result . getUriVariables (  )  . get (  \" var \"  )  )  ;", "pathPattern    =    checkStructure (  \"  /  { var :  [  \\  \\  {  ]  *  }  \"  )  ;", "next    =    pathPattern . getHeadSection (  )  . next ;", "assertEquals ( CaptureVariablePathElement . class . getName (  )  ,    next . getClass (  )  . getName (  )  )  ;", "result    =    matchAndExtract ( pathPattern ,     \"  /  {  {  {  \"  )  ;", "assertEquals (  \"  {  {  {  \"  ,    result . getUriVariables (  )  . get (  \" var \"  )  )  ;", "pathPattern    =    checkStructure (  \"  /  { var :  [  \\  \\  }  ]  *  }  \"  )  ;", "next    =    pathPattern . getHeadSection (  )  . next ;", "assertEquals ( CaptureVariablePathElement . class . getName (  )  ,    next . getClass (  )  . getName (  )  )  ;", "result    =    matchAndExtract ( pathPattern ,     \"  /  }  }  }  \"  )  ;", "assertEquals (  \"  }  }  }  \"  ,    result . getUriVariables (  )  . get (  \" var \"  )  )  ;", "pathPattern    =    checkStructure (  \"  *  \"  )  ;", "assertEquals ( WildcardPathElement . class . getName (  )  ,    pathPattern . getHeadSection (  )  . getClass (  )  . getName (  )  )  ;", "checkStructure (  \"  /  *  \"  )  ;", "checkStructure (  \"  /  *  /  \"  )  ;", "checkStructure (  \"  *  /  \"  )  ;", "checkStructure (  \"  /  *  /  \"  )  ;", "pathPattern    =    checkStructure (  \"  /  * a *  /  \"  )  ;", "next    =    pathPattern . getHeadSection (  )  . next ;", "assertEquals ( RegexPathElement . class . getName (  )  ,    next . getClass (  )  . getName (  )  )  ;", "pathPattern    =    checkStructure (  \"  *  /  \"  )  ;", "assertEquals ( WildcardPathElement . class . getName (  )  ,    pathPattern . getHeadSection (  )  . getClass (  )  . getName (  )  )  ;", "checkError (  \"  { foo }  _  { foo }  \"  ,     0  ,    PatternParseException . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE ,     \" foo \"  )  ;", "checkError (  \"  /  { bar }  /  { bar }  \"  ,     7  ,    PatternParseException . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE ,     \" bar \"  )  ;", "checkError (  \"  /  { bar }  /  { bar }  _  { foo }  \"  ,     7  ,    PatternParseException . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE ,     \" bar \"  )  ;", "pathPattern    =    checkStructure (  \"  { symbolicName :  [  \\  \\ p { L }  \\  \\  .  ]  +  }  - sources -  { version :  [  \\  \\ p { N }  \\  \\  .  ]  +  }  . jar \"  )  ;", "assertEquals ( RegexPathElement . class . getName (  )  ,    pathPattern . getHeadSection (  )  . getClass (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["regexPathElementPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "pathPattern    =    checkStructure (  \"  ?  \"  )  ;", "assertPathElements ( pathPattern ,    SingleCharWildcardedPathElement . class )  ;", "checkStructure (  \"  /  ?  /  \"  )  ;", "checkStructure (  \"  /  ? abc ?  /  \"  )  ;", "}", "METHOD_END"], "methodName": ["singleCharWildcardPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "return   PathPatternTests . toPathContainer ( path )  ;", "}", "METHOD_END"], "methodName": ["toPSC"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" CaptureTheRest (  /  {  * foobar }  )  \"  ,    checkStructure (  \"  /  {  * foobar }  \"  )  . toChainString (  )  )  ;", "assertEquals (  \" CaptureVariable (  { foobar }  )  \"  ,    checkStructure (  \"  { foobar }  \"  )  . toChainString (  )  )  ;", "assertEquals (  \" Literal ( abc )  \"  ,    checkStructure (  \" abc \"  )  . toChainString (  )  )  ;", "assertEquals (  \" Regex (  { a }  _  *  _  { b }  )  \"  ,    checkStructure (  \"  { a }  _  *  _  { b }  \"  )  . toChainString (  )  )  ;", "assertEquals (  \" Separator (  /  )  \"  ,    checkStructure (  \"  /  \"  )  . toChainString (  )  )  ;", "assertEquals (  \" SingleCharWildcarded (  ? a ? b ? c )  \"  ,    checkStructure (  \"  ? a ? b ? c \"  )  . toChainString (  )  )  ;", "assertEquals (  \" Wildcard (  *  )  \"  ,    checkStructure (  \"  *  \"  )  . toChainString (  )  )  ;", "assertEquals (  \" WildcardTheRest (  /  *  *  )  \"  ,    checkStructure (  \"  /  *  *  \"  )  . toChainString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStringTests"], "fileName": "org.springframework.web.util.pattern.PathPatternParserTests"}, {"methodBody": ["METHOD_START", "{", "checkMatches (  \" test \"  ,     \" test \"  )  ;", "checkMatches (  \"  / test \"  ,     \"  / test \"  )  ;", "checkMatches (  \" http :  /  / example . org \"  ,     \" http :  /  / example . org \"  )  ;", "checkNoMatch (  \"  / test . jpg \"  ,     \" test . jpg \"  )  ;", "checkNoMatch (  \" test \"  ,     \"  / test \"  )  ;", "checkNoMatch (  \"  / test \"  ,     \" test \"  )  ;", "checkMatches (  \" t ? st \"  ,     \" test \"  )  ;", "checkMatches (  \"  ?  ? st \"  ,     \" test \"  )  ;", "checkMatches (  \" tes ?  \"  ,     \" test \"  )  ;", "checkMatches (  \" te ?  ?  \"  ,     \" test \"  )  ;", "checkMatches (  \"  ? es ?  \"  ,     \" test \"  )  ;", "checkNoMatch (  \" tes ?  \"  ,     \" tes \"  )  ;", "checkNoMatch (  \" tes ?  \"  ,     \" testt \"  )  ;", "checkNoMatch (  \" tes ?  \"  ,     \" tsst \"  )  ;", "checkMatches (  \"  *  \"  ,     \" test \"  )  ;", "checkMatches (  \" test *  \"  ,     \" test \"  )  ;", "checkMatches (  \" test *  \"  ,     \" test \"  )  ;", "checkMatches (  \" test /  *  \"  ,     \" test /  \"  )  ;", "checkMatches (  \" test /  *  \"  ,     \" test / t \"  )  ;", "checkMatches (  \" test /  *  \"  ,     \" test /  \"  )  ;", "checkMatches (  \"  * test *  \"  ,     \" Anothertest \"  )  ;", "checkMatches (  \"  * test \"  ,     \" Anothertest \"  )  ;", "checkMatches (  \"  *  .  *  \"  ,     \" test .  \"  )  ;", "checkMatches (  \"  *  .  *  \"  ,     \" test . test \"  )  ;", "checkMatches (  \"  *  .  *  \"  ,     \" test . test . test \"  )  ;", "checkMatches (  \" test * aaa \"  ,     \" testblaaaa \"  )  ;", "checkNoMatch (  \" test *  \"  ,     \" tst \"  )  ;", "checkNoMatch (  \" test *  \"  ,     \" tsttest \"  )  ;", "checkMatches (  \" test *  \"  ,     \" test /  \"  )  ;", "checkMatches (  \" test *  \"  ,     \" test \"  )  ;", "checkNoMatch (  \" test *  \"  ,     \" test / t \"  )  ;", "checkNoMatch (  \" test /  *  \"  ,     \" test \"  )  ;", "checkNoMatch (  \"  * test *  \"  ,     \" tsttst \"  )  ;", "checkNoMatch (  \"  * test \"  ,     \" tsttst \"  )  ;", "checkNoMatch (  \"  *  .  *  \"  ,     \" tsttst \"  )  ;", "checkNoMatch (  \" test * aaa \"  ,     \" test \"  )  ;", "checkNoMatch (  \" test * aaa \"  ,     \" testblaaab \"  )  ;", "checkMatches (  \"  /  ?  \"  ,     \"  / a \"  )  ;", "checkMatches (  \"  /  ?  / a \"  ,     \"  / a / a \"  )  ;", "checkMatches (  \"  / a /  ?  \"  ,     \"  / a / b \"  )  ;", "checkMatches (  \"  /  ?  ?  / a \"  ,     \"  / aa / a \"  )  ;", "checkMatches (  \"  / a /  ?  ?  \"  ,     \"  / a / bb \"  )  ;", "checkMatches (  \"  /  ?  \"  ,     \"  / a \"  )  ;", "checkMatches (  \"  /  *  *  \"  ,     \"  \"  )  ;", "checkMatches (  \"  / books /  *  *  \"  ,     \"  / books \"  )  ;", "checkMatches (  \"  /  *  *  \"  ,     \"  / testing / testing \"  )  ;", "checkMatches (  \"  /  *  /  *  *  \"  ,     \"  / testing / testing \"  )  ;", "checkMatches (  \"  / bla * bla / test \"  ,     \"  / blaXXXbla / test \"  )  ;", "checkMatches (  \"  /  * bla / test \"  ,     \"  / XXXbla / test \"  )  ;", "checkNoMatch (  \"  / bla * bla / test \"  ,     \"  / blaXXXbl / test \"  )  ;", "checkNoMatch (  \"  /  * bla / test \"  ,     \" XXXblab / test \"  )  ;", "checkNoMatch (  \"  /  * bla / test \"  ,     \" XXXbl / test \"  )  ;", "checkNoMatch (  \"  /  ?  ?  ?  ?  \"  ,     \"  / bala / bla \"  )  ;", "checkMatches (  \"  / foo / bar /  *  *  \"  ,     \"  / foo / bar /  \"  )  ;", "checkMatches (  \"  /  { bla }  . html \"  ,     \"  / testing . html \"  )  ;", "checkCapture (  \"  /  { bla }  .  *  \"  ,     \"  / testing . html \"  ,     \" bla \"  ,     \" testing \"  )  ;", "}", "METHOD_END"], "methodName": ["antPathMatcherTests"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( pp . matches ( PathPatternTests . toPathContainer ( path )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMatches"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( pp . matches ( PathPatternTests . toPathContainer ( path )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNoMatch"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkMatches (  \"  \"  ,     \"  \"  )  ;", "checkMatches (  \"  \"  ,     \"  /  \"  )  ;", "checkMatches (  \"  \"  ,    null )  ;", "checkNoMatch (  \"  / abc \"  ,     \"  /  \"  )  ;", "checkMatches (  \"  /  \"  ,     \"  /  \"  )  ;", "checkNoMatch (  \"  /  \"  ,     \"  / a \"  )  ;", "checkMatches (  \" foo / bar /  \"  ,     \" foo / bar /  \"  )  ;", "checkNoMatch (  \" foo \"  ,     \" foobar \"  )  ;", "checkMatches (  \"  / foo / bar \"  ,     \"  / foo / bar \"  )  ;", "checkNoMatch (  \"  / foo / bar \"  ,     \"  / foo / baz \"  )  ;", "}", "METHOD_END"], "methodName": ["basicMatching"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkMatches (  \"  / resource /  {  * foobar }  \"  ,     \"  / resource \"  )  ;", "checkNoMatch (  \"  / resource /  {  * foobar }  \"  ,     \"  / resourceX \"  )  ;", "checkNoMatch (  \"  / resource /  {  * foobar }  \"  ,     \"  / resourceX / foobar \"  )  ;", "checkMatches (  \"  / resource /  {  * foobar }  \"  ,     \"  / resource / foobar \"  )  ;", "checkCapture (  \"  / resource /  {  * foobar }  \"  ,     \"  / resource / foobar \"  ,     \" foobar \"  ,     \"  / foobar \"  )  ;", "checkCapture (  \"  / customer /  {  * someth }  \"  ,     \"  / customer /  9  9  \"  ,     \" someth \"  ,     \"  /  9  9  \"  )  ;", "checkCapture (  \"  / customer /  {  * someth }  \"  ,     \"  / customer / aa / bb / cc \"  ,     \" someth \"  ,     \"  / aa / bb / cc \"  )  ;", "checkCapture (  \"  / customer /  {  * someth }  \"  ,     \"  / customer /  \"  ,     \" someth \"  ,     \"  /  \"  )  ;", "checkCapture (  \"  / customer /  /  /  /  /  {  * someth }  \"  ,     \"  / customer /  /  /  /  /  \"  ,     \" someth \"  ,     \"  /  \"  )  ;", "checkCapture (  \"  / customer /  /  /  /  /  {  * someth }  \"  ,     \"  / customer /  /  /  /  /  /  \"  ,     \" someth \"  ,     \"  /  /  \"  )  ;", "checkCapture (  \"  / customer /  /  /  /  /  /  {  * someth }  \"  ,     \"  / customer /  /  /  /  /  /  9  9  \"  ,     \" someth \"  ,     \"  /  9  9  \"  )  ;", "checkCapture (  \"  / customer /  /  /  /  /  /  {  * someth }  \"  ,     \"  / customer /  /  /  /  /  /  9  9  \"  ,     \" someth \"  ,     \"  /  9  9  \"  )  ;", "checkCapture (  \"  / customer /  {  * someth }  \"  ,     \"  / customer \"  ,     \" someth \"  ,     \"  \"  )  ;", "checkCapture (  \"  /  {  * someth }  \"  ,     \"  \"  ,     \" someth \"  ,     \"  \"  )  ;", "checkCapture (  \"  / customer /  {  * someth }  \"  ,     \"  / customer /  /  /  /  /  /  9  9  \"  ,     \" someth \"  ,     \"  /  /  /  /  /  /  9  9  \"  )  ;", "}", "METHOD_END"], "methodName": ["captureTheRest"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( false )  ;", "PathPattern   p    =    pp . parse (  \"  / group /  { groupName }  / members \"  )  ;", "assertMatches ( p ,     \"  / group / sales / members \"  )  ;", "assertMatches ( p ,     \"  / Group / Sales / Members \"  )  ;", "assertMatches ( p ,     \"  / group / Sales / members \"  )  ;", "}", "METHOD_END"], "methodName": ["caseInsensitive"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( false )  ;", "PathPattern   p    =    pp . parse (  \" abc \"  )  ;", "assertMatches ( p ,     \" AbC \"  )  ;", "assertNoMatch ( p ,     \" def \"  )  ;", "p    =    pp . parse (  \" fOo \"  )  ;", "assertMatches ( p ,     \" FoO \"  )  ;", "p    =    pp . parse (  \"  / fOo / bAr \"  )  ;", "assertMatches ( p ,     \"  / FoO / BaR \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( true )  ;", "p    =    pp . parse (  \" abc \"  )  ;", "assertNoMatch ( p ,     \" AbC \"  )  ;", "p    =    pp . parse (  \" fOo \"  )  ;", "assertNoMatch ( p ,     \" FoO \"  )  ;", "p    =    pp . parse (  \"  / fOo / bAr \"  )  ;", "assertNoMatch ( p ,     \"  / FoO / BaR \"  )  ;", "p    =    pp . parse (  \"  / fOO / bAr \"  )  ;", "assertMatches ( p ,     \"  / fOO / bAr \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( false )  ;", "p    =    pp . parse (  \"  { foo :  [ A - Z ]  *  }  \"  )  ;", "assertMatches ( p ,     \" abc \"  )  ;", "assertMatches ( p ,     \" ABC \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( true )  ;", "p    =    pp . parse (  \"  { foo :  [ A - Z ]  *  }  \"  )  ;", "assertNoMatch ( p ,     \" abc \"  )  ;", "assertMatches ( p ,     \" ABC \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( false )  ;", "p    =    pp . parse (  \" ab ?  \"  )  ;", "assertMatches ( p ,     \" AbC \"  )  ;", "p    =    pp . parse (  \" fO ?  \"  )  ;", "assertMatches ( p ,     \" FoO \"  )  ;", "p    =    pp . parse (  \"  / fO ?  / bA ?  \"  )  ;", "assertMatches ( p ,     \"  / FoO / BaR \"  )  ;", "assertNoMatch ( p ,     \"  / bAr / fOo \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( true )  ;", "p    =    pp . parse (  \" ab ?  \"  )  ;", "assertNoMatch ( p ,     \" AbC \"  )  ;", "p    =    pp . parse (  \" fO ?  \"  )  ;", "assertNoMatch ( p ,     \" FoO \"  )  ;", "p    =    pp . parse (  \"  / fO ?  / bA ?  \"  )  ;", "assertNoMatch ( p ,     \"  / FoO / BaR \"  )  ;", "p    =    pp . parse (  \"  / fO ?  / bA ?  \"  )  ;", "assertMatches ( p ,     \"  / fOO / bAr \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( false )  ;", "p    =    pp . parse (  \"  { abc :  [ A - Z ]  *  }  _  { def :  [ A - Z ]  *  }  \"  )  ;", "assertMatches ( p ,     \" abc _ abc \"  )  ;", "assertMatches ( p ,     \" ABC _ aBc \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( true )  ;", "p    =    pp . parse (  \"  { abc :  [ A - Z ]  *  }  _  { def :  [ A - Z ]  *  }  \"  )  ;", "assertNoMatch ( p ,     \" abc _ abc \"  )  ;", "assertMatches ( p ,     \" ABC _ ABC \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( false )  ;", "p    =    pp . parse (  \"  *  ? a ?  *  \"  )  ;", "assertMatches ( p ,     \" bab \"  )  ;", "assertMatches ( p ,     \" bAb \"  )  ;", "pp    =    new   PathPatternParser (  )  ;", "pp . setCaseSensitive ( true )  ;", "p    =    pp . parse (  \"  *  ? A ?  *  \"  )  ;", "assertNoMatch ( p ,     \" bab \"  )  ;", "assertMatches ( p ,     \" bAb \"  )  ;", "}", "METHOD_END"], "methodName": ["caseSensitivity"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   parser    =    new   PathPatternParser (  )  ;", "PathPattern   pattern    =    parser . parse ( uriTemplate )  ;", "PathPattern . PathMatchInfo   matchResult    =    pattern . matchAndExtract (  . toPathContainer ( path )  )  ;", "Map < String ,    String >    expectedKeyValues    =    new   HashMap <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     ( keyValues . length )  ;    i    +  =     2  )     {", "expectedKeyValues . put ( keyValues [ i ]  ,    keyValues [  ( i    +     1  )  ]  )  ;", "}", "for    ( Map . Entry < String ,    String >    me    :    expectedKeyValues . entrySet (  )  )     {", "String   value    =    matchResult . getUriVariables (  )  . get ( me . getKey (  )  )  ;", "if    ( value    =  =    null )     {", "fail (  (  (  (  \" Did   not   find   key    '  \"     +     ( me . getKey (  )  )  )     +     \"  '    in   captured   variables :     \"  )     +     ( matchResult . getUriVariables (  )  )  )  )  ;", "}", "if    (  !  ( value . equals ( me . getValue (  )  )  )  )     {", "fail (  (  (  (  (  (  (  \" Expected   value    '  \"     +     ( me . getValue (  )  )  )     +     \"  '    for   key    '  \"  )     +     ( me . getKey (  )  )  )     +     \"  '    but   was    '  \"  )     +    value )     +     \"  '  \"  )  )  ;", "}", "}", "return   matchResult ;", "}", "METHOD_END"], "methodName": ["checkCapture"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   ppp    =    new   PathPatternParser (  )  ;", "PathPattern   pp    =    ppp . parse ( pattern )  ;", "String   s    =    pp . extractPathWithinPattern (  . toPathContainer ( path )  )  . value (  )  ;", "assertEquals ( expected ,    s )  ;", "}", "METHOD_END"], "methodName": ["checkExtractPathWithinPattern"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   parser    =    new   PathPatternParser (  )  ;", "parser . setMatchOptionalTrailingSeparator ( true )  ;", "PathPattern   p    =    parser . parse ( uriTemplate )  ;", "PathContainer   pc    =     . toPathContainer ( path )  ;", "assertTrue ( p . matches ( pc )  )  ;", "}", "METHOD_END"], "methodName": ["checkMatches"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   p    =    new   PathPatternParser (  )  ;", "PathPattern   pattern    =    p . parse ( uriTemplate )  ;", "PathContainer   PathContainer    =     . toPathContainer ( path )  ;", "assertFalse ( pattern . matches ( PathContainer )  )  ;", "}", "METHOD_END"], "methodName": ["checkNoMatch"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternTests . TestPathCombiner   pathMatcher    =    new   PathPatternTests . TestPathCombiner (  )  ;", "assertEquals (  \"  \"  ,    pathMatcher . combine (  \"  \"  ,     \"  \"  )  )  ;", "assertEquals (  \"  / hotels \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \"  \"  )  )  ;", "assertEquals (  \"  / hotels \"  ,    pathMatcher . combine (  \"  \"  ,     \"  / hotels \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels /  *  \"  ,     \" booking \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels /  *  \"  ,     \"  / booking \"  )  )  ;", "assertEquals (  \"  / hotels /  *  *  / booking \"  ,    pathMatcher . combine (  \"  / hotels /  *  *  \"  ,     \" booking \"  )  )  ;", "assertEquals (  \"  / hotels /  *  *  / booking \"  ,    pathMatcher . combine (  \"  / hotels /  *  *  \"  ,     \"  / booking \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \"  / booking \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \" booking \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels /  \"  ,     \" booking \"  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  \"  ,    pathMatcher . combine (  \"  / hotels /  *  \"  ,     \"  { hotel }  \"  )  )  ;", "assertEquals (  \"  / hotels /  *  *  /  { hotel }  \"  ,    pathMatcher . combine (  \"  / hotels /  *  *  \"  ,     \"  { hotel }  \"  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \"  { hotel }  \"  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  .  *  \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \"  { hotel }  .  *  \"  )  )  ;", "assertEquals (  \"  / hotels /  *  / booking /  { booking }  \"  ,    pathMatcher . combine (  \"  / hotels /  *  / booking \"  ,     \"  { booking }  \"  )  )  ;", "assertEquals (  \"  / hotel . html \"  ,    pathMatcher . combine (  \"  /  *  . html \"  ,     \"  / hotel . html \"  )  )  ;", "assertEquals (  \"  / hotel . html \"  ,    pathMatcher . combine (  \"  /  *  . html \"  ,     \"  / hotel \"  )  )  ;", "assertEquals (  \"  / hotel . html \"  ,    pathMatcher . combine (  \"  /  *  . html \"  ,     \"  / hotel .  *  \"  )  )  ;", "assertEquals (  \"  / d / e / f / hotel . html \"  ,    pathMatcher . combine (  \"  / a / b / c /  *  . html \"  ,     \"  / d / e / f / hotel .  *  \"  )  )  ;", "assertEquals (  \"  /  *  . html \"  ,    pathMatcher . combine (  \"  /  *  *  \"  ,     \"  /  *  . html \"  )  )  ;", "assertEquals (  \"  /  *  . html \"  ,    pathMatcher . combine (  \"  /  *  \"  ,     \"  /  *  . html \"  )  )  ;", "assertEquals (  \"  /  *  . html \"  ,    pathMatcher . combine (  \"  /  *  .  *  \"  ,     \"  /  *  . html \"  )  )  ;", "assertEquals (  \"  /  { foo }  / bar \"  ,    pathMatcher . combine (  \"  /  { foo }  \"  ,     \"  / bar \"  )  )  ;", "assertEquals (  \"  / user / user \"  ,    pathMatcher . combine (  \"  / user \"  ,     \"  / user \"  )  )  ;", "assertEquals (  \"  /  { foo :  .  *  [  ^  0  -  9  ]  .  *  }  / edit /  \"  ,    pathMatcher . combine (  \"  /  { foo :  .  *  [  ^  0  -  9  ]  .  *  }  \"  ,     \"  / edit /  \"  )  )  ;", "assertEquals (  \"  /  1  .  0  / foo / test \"  ,    pathMatcher . combine (  \"  /  1  .  0  \"  ,     \"  / foo / test \"  )  )  ;", "assertEquals (  \"  / hotel \"  ,    pathMatcher . combine (  \"  /  \"  ,     \"  / hotel \"  )  )  ;", "assertEquals (  \"  / hotel / booking \"  ,    pathMatcher . combine (  \"  / hotel /  \"  ,     \"  / booking \"  )  )  ;", "assertEquals (  \"  / hotel \"  ,    pathMatcher . combine (  \"  \"  ,     \"  / hotel \"  )  )  ;", "assertEquals (  \"  / hotel \"  ,    pathMatcher . combine (  \"  / hotel \"  ,     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternTests . TestPathCombiner   pathMatcher    =    new   PathPatternTests . TestPathCombiner (  )  ;", "exception . expect ( IllegalArgumentException . class )  ;", "pathMatcher . combine (  \"  /  *  . html \"  ,     \"  /  *  . txt \"  )  ;", "}", "METHOD_END"], "methodName": ["combineWithTwoFileExtensionPatterns"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   parser    =    new   PathPatternParser (  )  ;", "PathPattern   p 1     =    parser . parse (  \"  /  { foo }  \"  )  ;", "PathPattern   p 2     =    parser . parse (  \"  /  { foo }  .  *  \"  )  ;", "PathPattern . PathMatchInfo   r 1     =    matchAndExtract ( p 1  ,     \"  / file . txt \"  )  ;", "PathPattern . PathMatchInfo   r 2     =    matchAndExtract ( p 2  ,     \"  / file . txt \"  )  ;", "assertEquals (  \" file . txt \"  ,    r 1  . getUriVariables (  )  . get (  \" foo \"  )  )  ;", "assertEquals (  \" file \"  ,    r 2  . getUriVariables (  )  . get (  \" foo \"  )  )  ;", "assertThat ( p 1  . compareTo ( p 2  )  ,    Matchers . greaterThan (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["compare_spr15597"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkCapture (  \"  { foo :  [  0  -  9  ]  *  }  \"  ,     \"  1  2  3  \"  ,     \" foo \"  ,     \"  1  2  3  \"  )  ;", "checkNoMch (  \"  { foo :  [  0  -  9  ]  *  }  \"  ,     \" abc \"  )  ;", "checkNoMch (  \"  /  { foo :  [  0  -  9  ]  *  }  \"  ,     \" abc \"  )  ;", "checkCapture (  \"  /  *  /  { foo :  .  .  .  .  }  /  *  *  \"  ,     \"  / foo / barg / foo \"  ,     \" foo \"  ,     \" barg \"  )  ;", "checkCapture (  \"  /  *  /  { foo :  .  .  .  .  }  /  *  *  \"  ,     \"  / foo / barg / abc / def / ghi \"  ,     \" foo \"  ,     \" barg \"  )  ;", "checkNoMch (  \"  { foo :  .  .  .  .  }  \"  ,     \"  9  9  \"  )  ;", "checkMches (  \"  { foo :  .  .  }  \"  ,     \"  9  9  \"  )  ;", "checkCapture (  \"  /  { abc :  \\  \\  {  \\  \\  }  }  \"  ,     \"  /  {  }  \"  ,     \" abc \"  ,     \"  {  }  \"  )  ;", "checkCapture (  \"  /  { abc :  \\  \\  [  \\  \\  ]  }  \"  ,     \"  /  [  ]  \"  ,     \" abc \"  ,     \"  [  ]  \"  )  ;", "checkCapture (  \"  /  { abc :  \\  \\  \\  \\  \\  \\  \\  \\  }  \"  ,     \"  /  \\  \\  \\  \\  \"  )  ;", "}", "METHOD_END"], "methodName": ["constrainedMatches"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   s    =    new   StringBuilder (  )  ;", "for    ( PathContainer . Element   element    :    elements )     {", "s . append (  \"  [  \"  )  . append ( element . value (  )  )  . append (  \"  ]  \"  )  ;", "}", "return   s . toString (  )  ;", "}", "METHOD_END"], "methodName": ["elementsToString"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkCapture (  \"  { var }  \"  ,     \" f %  2  0 o \"  ,     \" var \"  ,     \" f   o \"  )  ;", "checkCapture (  \"  { var 1  }  /  { var 2  }  \"  ,     \" f %  2  0 o / f %  7 Co \"  ,     \" var 1  \"  ,     \" f   o \"  ,     \" var 2  \"  ,     \" f | o \"  )  ;", "checkCapture (  \"  { var 1  }  /  { var 2  }  \"  ,     \" f %  2  0 o / f %  7 co \"  ,     \" var 1  \"  ,     \" f   o \"  ,     \" var 2  \"  ,     \" f | o \"  )  ;", "checkCapture (  \"  { var : foo }  \"  ,     \" foo \"  ,     \" var \"  ,     \" foo \"  )  ;", "checkCapture (  \"  { var : f   o }  \"  ,     \" f %  2  0 o \"  ,     \" var \"  ,     \" f   o \"  )  ;", "checkCapture (  \"  { var : f . o }  \"  ,     \" f %  2  0 o \"  ,     \" var \"  ,     \" f   o \"  )  ;", "checkCapture (  \"  { var : f \\  \\  | o }  \"  ,     \" f %  7 co \"  ,     \" var \"  ,     \" f | o \"  )  ;", "}", "METHOD_END"], "methodName": ["encodingAndBoundVariablesCapturePathElement"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkCapture (  \"  /  {  * var }  \"  ,     \"  / f %  2  0 o \"  ,     \" var \"  ,     \"  / f   o \"  )  ;", "checkCapture (  \"  { var 1  }  /  {  * var 2  }  \"  ,     \" f %  2  0 o / f %  7 Co \"  ,     \" var 1  \"  ,     \" f   o \"  ,     \" var 2  \"  ,     \"  / f | o \"  )  ;", "checkCapture (  \"  /  {  * var }  \"  ,     \"  / foo \"  ,     \" var \"  ,     \"  / foo \"  )  ;", "checkCapture (  \"  /  {  * var }  \"  ,     \"  / f %  2  0 o \"  ,     \" var \"  ,     \"  / f   o \"  )  ;", "checkCapture (  \"  /  {  * var }  \"  ,     \"  / f %  2  0 o \"  ,     \" var \"  ,     \"  / f   o \"  )  ;", "checkCapture (  \"  /  {  * var }  \"  ,     \"  / f %  7 co \"  ,     \" var \"  ,     \"  / f | o \"  )  ;", "}", "METHOD_END"], "methodName": ["encodingAndBoundVariablesCaptureTheRestPathElement"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkCapture (  \"  /  { var 1  : f   o }  _     _  { var 2  }  \"  ,     \"  / f %  2  0 o _  %  2  0  _ f %  7 co \"  ,     \" var 1  \"  ,     \" f   o \"  ,     \" var 2  \"  ,     \" f | o \"  )  ;", "checkCapture (  \"  /  { var 1  }  _  { var 2  }  \"  ,     \"  / f %  2  0 o _ foo \"  ,     \" var 1  \"  ,     \" f   o \"  ,     \" var 2  \"  ,     \" foo \"  )  ;", "checkCapture (  \"  /  { var 1  }  _     _  { var 2  }  \"  ,     \"  / f %  2  0 o _  %  2  0  _ f %  7 co \"  ,     \" var 1  \"  ,     \" f   o \"  ,     \" var 2  \"  ,     \" f | o \"  )  ;", "checkCapture (  \"  /  { var 1  }  _     _  { var 2  : f \\  \\  | o }  \"  ,     \"  / f %  2  0 o _  %  2  0  _ f %  7 co \"  ,     \" var 1  \"  ,     \" f   o \"  ,     \" var 2  \"  ,     \" f | o \"  )  ;", "checkCapture (  \"  /  { var 1  : f   o }  _     _  { var 2  : f \\  \\  | o }  \"  ,     \"  / f %  2  0 o _  %  2  0  _ f %  7 co \"  ,     \" var 1  \"  ,     \" f   o \"  ,     \" var 2  \"  ,     \" f | o \"  )  ;", "}", "METHOD_END"], "methodName": ["encodingAndBoundVariablesRegexPathElement"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkExtractPathWithinPattern (  \"  / welcome *  /  \"  ,     \"  / welcome /  \"  ,     \" welcome \"  )  ;", "checkExtractPathWithinPattern (  \"  / docs / commit . html \"  ,     \"  / docs / commit . html \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  / docs /  *  \"  ,     \"  / docs / cvs / commit \"  ,     \" cvs / commit \"  )  ;", "checkExtractPathWithinPattern (  \"  / docs / cvs /  *  . html \"  ,     \"  / docs / cvs / commit . html \"  ,     \" commit . html \"  )  ;", "checkExtractPathWithinPattern (  \"  / docs /  *  *  \"  ,     \"  / docs / cvs / commit \"  ,     \" cvs / commit \"  )  ;", "checkExtractPathWithinPattern (  \"  / doo /  {  * foobar }  \"  ,     \"  / doo / customer . html \"  ,     \" customer . html \"  )  ;", "checkExtractPathWithinPattern (  \"  / doo /  {  * foobar }  \"  ,     \"  / doo / daa / customer . html \"  ,     \" daa / customer . html \"  )  ;", "checkExtractPathWithinPattern (  \"  /  *  . html \"  ,     \"  / commit . html \"  ,     \" commit . html \"  )  ;", "checkExtractPathWithinPattern (  \"  / docs /  *  /  *  /  *  /  *  \"  ,     \"  / docs / cvs / other / commit . html \"  ,     \" cvs / other / commit . html \"  )  ;", "checkExtractPathWithinPattern (  \"  / d ? cs /  *  *  \"  ,     \"  / docs / cvs / commit \"  ,     \" docs / cvs / commit \"  )  ;", "checkExtractPathWithinPattern (  \"  /  *  /  *  *  \"  ,     \"  / docs / cvs / commit /  /  /  \"  ,     \" docs / cvs / commit \"  )  ;", "checkExtractPathWithinPattern (  \"  /  *  /  *  *  \"  ,     \"  / docs / cvs / commit /  \"  ,     \" docs / cvs / commit \"  )  ;", "checkExtractPathWithinPattern (  \"  / aaa / bbb /  *  *  \"  ,     \"  / aaa /  /  /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  / aaa / bbb /  *  *  \"  ,     \"  / aaa /  /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  / aaa / bbb /  *  *  \"  ,     \"  / aaa /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  / docs /  *  *  \"  ,     \"  / docs / cvs / commit /  /  /  \"  ,     \" cvs / commit \"  )  ;", "checkExtractPathWithinPattern (  \"  / docs /  *  *  \"  ,     \"  / docs / cvs / commit /  \"  ,     \" cvs / commit \"  )  ;", "checkExtractPathWithinPattern (  \"  / docs / c ? s /  *  . html \"  ,     \"  / docs / cvs / commit . html \"  ,     \" cvs / commit . html \"  )  ;", "checkExtractPathWithinPattern (  \"  / d ? cs /  *  /  *  . html \"  ,     \"  / docs / cvs / commit . html \"  ,     \" docs / cvs / commit . html \"  )  ;", "checkExtractPathWithinPattern (  \"  / a / b / c * d *  /  *  . html \"  ,     \"  / a / b / cod / foo . html \"  ,     \" cod / foo . html \"  )  ;", "checkExtractPathWithinPattern (  \" a /  { foo }  / b /  { bar }  \"  ,     \" a / c / b / d \"  ,     \" c / b / d \"  )  ;", "checkExtractPathWithinPattern (  \" a /  { foo }  _  { bar }  / d / e \"  ,     \" a / b _ c / d / e \"  ,     \" b _ c / d / e \"  )  ;", "checkExtractPathWithinPattern (  \" aaa /  /  *  /  /  / ccc /  /  / ddd \"  ,     \" aaa /  / bbb /  /  / ccc /  /  / ddd \"  ,     \" bbb / ccc / ddd \"  )  ;", "checkExtractPathWithinPattern (  \" aaa /  /  *  /  /  / ccc /  /  / ddd \"  ,     \" aaa /  / bbb /  / ccc / ddd \"  ,     \" bbb / ccc / ddd \"  )  ;", "checkExtractPathWithinPattern (  \" aaa / c *  / ddd /  \"  ,     \" aaa / ccc /  /  / ddd /  /  /  \"  ,     \" ccc / ddd \"  )  ;", "checkExtractPathWithinPattern (  \"  \"  ,     \"  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  /  \"  ,     \"  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  /  /  \"  ,     \"  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  \"  ,     \"  /  /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  /  /  \"  ,     \"  /  /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  /  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  /  \"  ,     \"  /  /  \"  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["extractPathWithinPattern"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkExtractPathWithinPattern (  \"  /  *  *  \"  ,     \"  /  /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  /  *  *  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  /  *  *  \"  ,     \"  \"  ,     \"  \"  )  ;", "checkExtractPathWithinPattern (  \"  /  *  *  \"  ,     \"  / foobar \"  ,     \" foobar \"  )  ;", "}", "METHOD_END"], "methodName": ["extractPathWithinPattern_spr15259"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "assertMatches ( parse (  \"  { hotel }  \"  )  ,     \"  1  \"  )  ;", "assertMatches ( parse (  \"  / hotels /  { hotel }  \"  )  ,     \"  / hotels /  1  \"  )  ;", "checkCapture (  \"  / hotels /  { hotel }  \"  ,     \"  / hotels /  1  \"  ,     \" hotel \"  ,     \"  1  \"  )  ;", "checkCapture (  \"  / h ? tels /  { hotel }  \"  ,     \"  / hotels /  1  \"  ,     \" hotel \"  ,     \"  1  \"  )  ;", "checkCapture (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  ,     \"  / hotels /  1  / bookings /  2  \"  ,     \" hotel \"  ,     \"  1  \"  ,     \" booking \"  ,     \"  2  \"  )  ;", "checkCapture (  \"  /  *  / hotels /  *  /  { hotel }  \"  ,     \"  / foo / hotels / bar /  1  \"  ,     \" hotel \"  ,     \"  1  \"  )  ;", "checkCapture (  \"  /  { page }  . html \"  ,     \"  /  4  2  . html \"  ,     \" page \"  ,     \"  4  2  \"  )  ;", "checkNoMatch (  \"  /  { var }  \"  ,     \"  /  \"  )  ;", "checkCapture (  \"  /  { page }  .  *  \"  ,     \"  /  4  2  . html \"  ,     \" page \"  ,     \"  4  2  \"  )  ;", "checkCapture (  \"  / A -  { B }  - C \"  ,     \"  / A - b - C \"  ,     \" B \"  ,     \" b \"  )  ;", "checkCapture (  \"  /  { name }  .  { extension }  \"  ,     \"  / test . html \"  ,     \" name \"  ,     \" test \"  ,     \" extension \"  ,     \" html \"  )  ;", "assertNull ( checkCapture (  \"  /  { one }  /  \"  ,     \"  /  /  \"  )  )  ;", "assertNull ( checkCapture (  \"  \"  ,     \"  / abc \"  )  )  ;", "assertEquals (  0  ,    checkCapture (  \"  \"  ,     \"  \"  )  . getUriVariables (  )  . size (  )  )  ;", "checkCapture (  \"  { id }  \"  ,     \"  9  9  \"  ,     \" id \"  ,     \"  9  9  \"  )  ;", "checkCapture (  \"  / customer /  { customerId }  \"  ,     \"  / customer /  7  8  \"  ,     \" customerId \"  ,     \"  7  8  \"  )  ;", "checkCapture (  \"  / customer /  { customerId }  / banana \"  ,     \"  / customer /  4  2  / banana \"  ,     \" customerId \"  ,     \"  4  2  \"  )  ;", "checkCapture (  \"  { id }  /  { id 2  }  \"  ,     \"  9  9  /  9  8  \"  ,     \" id \"  ,     \"  9  9  \"  ,     \" id 2  \"  ,     \"  9  8  \"  )  ;", "checkCapture (  \"  / foo /  { bar }  / boo /  { baz }  \"  ,     \"  / foo / plum / boo / apple \"  ,     \" bar \"  ,     \" plum \"  ,     \" baz \"  ,     \" apple \"  )  ;", "checkCapture (  \"  /  { bla }  .  *  \"  ,     \"  / testing . html \"  ,     \" bla \"  ,     \" testing \"  )  ;", "PathPMatchInfo   extracted    =    checkCapture (  \"  / abc \"  ,     \"  / abc \"  )  ;", "assertEquals (  0  ,    extracted . getUriVariables (  )  . size (  )  )  ;", "checkCapture (  \"  /  { bla }  / foo \"  ,     \"  / a / foo \"  )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVariables"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   pp    =    new   PathPatternParser (  )  ;", "PathPattern   p    =    null ;", "p    =    pp . parse (  \"  { symbolicName :  [  \\  \\ w \\  \\  .  ]  +  }  -  { version :  [  \\  \\ w \\  \\  .  ]  +  }  . jar \"  )  ;", "PathPattern . PathMatchInfo   result    =    matchAndExtract ( p ,     \" com . example -  1  .  0  .  0  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . getUriVariables (  )  . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  \"  ,    result . getUriVariables (  )  . get (  \" version \"  )  )  ;", "p    =    pp . parse (  \"  { symbolicName :  [  \\  \\ w \\  \\  .  ]  +  }  - sources -  { version :  [  \\  \\ w \\  \\  .  ]  +  }  . jar \"  )  ;", "result    =    matchAndExtract ( p ,     \" com . example - sources -  1  .  0  .  0  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . getUriVariables (  )  . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  \"  ,    result . getUriVariables (  )  . get (  \" version \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVariablesRegex"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPattern   pp ;", "pp    =    new   PathPatternParser (  )  . parse (  \"  /  { foo }  \"  )  ;", "assertMatches ( pp ,     \"  / abc \"  )  ;", "assertNoMatch ( pp ,     \"  /  \"  )  ;", "assertNoMatch ( pp ,     \"  /  /  \"  )  ;", "checkCapture (  \"  /  { foo }  \"  ,     \"  / abc \"  ,     \" foo \"  ,     \" abc \"  )  ;", "pp    =    new   PathPatternParser (  )  . parse (  \"  /  { foo }  /  { bar }  \"  )  ;", "assertMatches ( pp ,     \"  / abc / def \"  )  ;", "assertNoMatch ( pp ,     \"  / def \"  )  ;", "assertNoMatch ( pp ,     \"  /  \"  )  ;", "assertNoMatch ( pp ,     \"  /  / def \"  )  ;", "assertNoMatch ( pp ,     \"  /  /  \"  )  ;", "pp    =    parse (  \"  /  { foo }  / boo \"  )  ;", "assertMatches ( pp ,     \"  / abc / boo \"  )  ;", "assertMatches ( pp ,     \"  / a / boo \"  )  ;", "assertNoMatch ( pp ,     \"  / boo \"  )  ;", "assertNoMatch ( pp ,     \"  /  / boo \"  )  ;", "pp    =    parse (  \"  /  { foo }  *  \"  )  ;", "assertMatches ( pp ,     \"  / abc \"  )  ;", "assertNoMatch ( pp ,     \"  /  \"  )  ;", "checkCapture (  \"  /  { word :  [ a - z ]  *  }  \"  ,     \"  / abc \"  ,     \" word \"  ,     \" abc \"  )  ;", "pp    =    parse (  \"  /  { word :  [ a - z ]  *  }  \"  )  ;", "assertNoMatch ( pp ,     \"  /  1  \"  )  ;", "assertMatches ( pp ,     \"  / a \"  )  ;", "assertNoMatch ( pp ,     \"  /  \"  )  ;", "pp    =    new   PathPatternParser (  )  . parse (  \"  /  { foo }  { bar }  \"  )  ;", "assertMatches ( pp ,     \"  / abcdef \"  )  ;", "assertNoMatch ( pp ,     \"  /  \"  )  ;", "assertNoMatch ( pp ,     \"  /  /  \"  )  ;", "checkCapture (  \"  /  { foo :  [ a - z ]  [ a - z ]  }  { bar :  [ a - z ]  }  \"  ,     \"  / abc \"  ,     \" foo \"  ,     \" ab \"  ,     \" bar \"  ,     \" c \"  )  ;", "PathPatternParser   ppp    =    new   PathPatternParser (  )  ;", "ppp . setMatchOptionalTrailingSeparator ( true )  ;", "pp    =    ppp . parse (  \"  /  *  *  *  *  \"  )  ;", "assertMatches ( pp ,     \"  / abcdef \"  )  ;", "assertMatches ( pp ,     \"  /  \"  )  ;", "assertMatches ( pp ,     \"  /  \"  )  ;", "assertMatches ( pp ,     \"  /  /  \"  )  ;", "assertFalse ( new   AntPathMatcher (  )  . match (  \"  /  { foo }  \"  ,     \"  /  \"  )  )  ;", "assertTrue ( new   AntPathMatcher (  )  . match (  \"  /  { foo }  \"  ,     \"  / a \"  )  )  ;", "assertTrue ( new   AntPathMatcher (  )  . match (  \"  /  { foo }  { bar }  \"  ,     \"  / a \"  )  )  ;", "assertFalse ( new   AntPathMatcher (  )  . match (  \"  /  { foo }  *  \"  ,     \"  /  \"  )  )  ;", "assertTrue ( new   AntPathMatcher (  )  . match (  \"  /  *  \"  ,     \"  /  \"  )  )  ;", "assertFalse ( new   AntPathMatcher (  )  . match (  \"  /  *  { foo }  \"  ,     \"  /  \"  )  )  ;", "Map < String ,    String >    vars    =    new   AntPathMatcher (  )  . extractUriTemplateVariables (  \"  /  { foo }  { bar }  \"  ,     \"  / a \"  )  ;", "assertEquals (  \" a \"  ,    vars . get (  \" foo \"  )  )  ;", "assertEquals (  \"  \"  ,    vars . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVariables_spr15264"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   ppp    =    new   PathPatternParser (  )  ;", "PathPattern   pathPattern    =    ppp . parse (  \"  / web /  { id : foo ( bar )  ?  }  _  { goo }  \"  )  ;", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( containsString (  \" The   number   of   capturing   groups   in   the   pattern \"  )  )  ;", "matchAndExtract ( pathPattern ,     \"  / web / foobar _ goo \"  )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVarsRegexCapturingGroups"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   pp    =    new   PathPatternParser (  )  ;", "PathPattern   p    =    pp . parse (  \"  { symbolicName :  [  \\  \\ p { L }  \\  \\  .  ]  +  }  - sources -  { version :  [  \\  \\ p { N }  \\  \\  .  ]  +  }  . jar \"  )  ;", "PathPattern . PathMatchInfo   result    =    p . matchAndExtract (  . toPathContainer (  \" com . example - sources -  1  .  0  .  0  . jar \"  )  )  ;", "assertEquals (  \" com . example \"  ,    result . getUriVariables (  )  . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  \"  ,    result . getUriVariables (  )  . get (  \" version \"  )  )  ;", "p    =    pp . parse (  (  \"  { symbolicName :  [  \\  \\ w \\  \\  .  ]  +  }  - sources -  \"     +     \"  { version :  [  \\  \\ d \\  \\  .  ]  +  }  -  { year :  \\  \\ d {  4  }  }  { month :  \\  \\ d {  2  }  }  { day :  \\  \\ d {  2  }  }  . jar \"  )  )  ;", "result    =    matchAndExtract ( p ,     \" com . example - sources -  1  .  0  .  0  -  2  0  1  0  0  2  2  0  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . getUriVariables (  )  . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  \"  ,    result . getUriVariables (  )  . get (  \" version \"  )  )  ;", "assertEquals (  \"  2  0  1  0  \"  ,    result . getUriVariables (  )  . get (  \" year \"  )  )  ;", "assertEquals (  \"  0  2  \"  ,    result . getUriVariables (  )  . get (  \" month \"  )  )  ;", "assertEquals (  \"  2  0  \"  ,    result . getUriVariables (  )  . get (  \" day \"  )  )  ;", "p    =    pp . parse (  \"  { symbolicName :  [  \\  \\ p { L }  \\  \\  .  ]  +  }  - sources -  { version :  [  \\  \\ p { N }  \\  \\  .  \\  \\  {  \\  \\  }  ]  +  }  . jar \"  )  ;", "result    =    matchAndExtract ( p ,     \" com . example - sources -  1  .  0  .  0  .  {  1  2  }  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . getUriVariables (  )  . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  .  {  1  2  }  \"  ,    result . getUriVariables (  )  . get (  \" version \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVarsRegexQualifiers"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "return   parse ( pattern )  . matchStartOfPath ( PathPatternTests . toPathContainer ( path )  )  ;", "}", "METHOD_END"], "methodName": ["getPathRemaining"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "return   pattern . matchStartOfPath ( PathPatternTests . toPathContainer ( path )  )  ;", "}", "METHOD_END"], "methodName": ["getPathRemaining"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "return   parse ( pattern )  . matchAndExtract ( PathPatternTests . toPathContainer ( path )  )  ;", "}", "METHOD_END"], "methodName": ["matchAndExtract"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "return   p . matchAndExtract ( PathPatternTests . toPathContainer ( path )  )  ;", "}", "METHOD_END"], "methodName": ["matchAndExtract"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkMatches (  \" foo \"  ,     \" foo \"  )  ;", "checkNoMatch (  \" foo \"  ,     \" bar \"  )  ;", "checkNoMatch (  \" foo \"  ,     \"  / foo \"  )  ;", "checkNoMatch (  \"  / foo \"  ,     \" foo \"  )  ;", "checkMatches (  \"  / f \"  ,     \"  / f \"  )  ;", "checkMatches (  \"  / foo \"  ,     \"  / foo \"  )  ;", "checkNoMatch (  \"  / foo \"  ,     \"  / food \"  )  ;", "checkNoMatch (  \"  / food \"  ,     \"  / foo \"  )  ;", "checkMatches (  \"  / foo /  \"  ,     \"  / foo /  \"  )  ;", "checkMatches (  \"  / foo / bar / woo \"  ,     \"  / foo / bar / woo \"  )  ;", "checkMatches (  \" foo / bar / woo \"  ,     \" foo / bar / woo \"  )  ;", "}", "METHOD_END"], "methodName": ["matching_LiteralPathElement"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkNoMatch (  \"  / abc \"  ,     \"  /  /  /  / abc \"  )  ;", "checkNoMatch (  \"  /  \"  ,     \"  /  /  \"  )  ;", "checkNoMatch (  \"  / abc / def / ghi \"  ,     \"  / abc /  / def /  /  / ghi \"  )  ;", "checkNoMatch (  \"  / abc \"  ,     \"  /  /  /  / abc \"  )  ;", "checkMatches (  \"  /  /  /  / abc \"  ,     \"  /  /  /  / abc \"  )  ;", "checkNoMatch (  \"  /  \"  ,     \"  /  /  \"  )  ;", "checkNoMatch (  \"  / abc /  / def \"  ,     \"  / abc / def \"  )  ;", "checkNoMatch (  \"  / abc /  / def /  /  / ghi \"  ,     \"  / abc / def / ghi \"  )  ;", "checkMatches (  \"  / abc /  / def /  /  / ghi \"  ,     \"  / abc /  / def /  /  / ghi \"  )  ;", "}", "METHOD_END"], "methodName": ["multipleSelectorsInPath"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPattern   pp    =    parse (  \" a /  / b /  / c \"  )  ;", "assertEquals (  \" Literal ( a )    Separator (  /  )    Separator (  /  )    Literal ( b )    Separator (  /  )    Separator (  /  )    Literal ( c )  \"  ,    pp . toChainString (  )  )  ;", "assertMatches ( pp ,     \" a /  / b /  / c \"  )  ;", "assertEquals (  \" Literal ( a )    Separator (  /  )    WildcardTheRest (  /  *  *  )  \"  ,    parse (  \" a /  /  *  *  \"  )  . toChainString (  )  )  ;", "checkMatches (  \"  /  /  / abc \"  ,     \"  /  /  / abc \"  )  ;", "checkNoMatch (  \"  /  /  / abc \"  ,     \"  / abc \"  )  ;", "checkNoMatch (  \"  /  /  \"  ,     \"  /  \"  )  ;", "checkMatches (  \"  /  /  \"  ,     \"  /  /  \"  )  ;", "checkNoMatch (  \"  /  /  / abc /  / d / e \"  ,     \"  / abc / d / e \"  )  ;", "checkMatches (  \"  /  /  / abc /  / d / e \"  ,     \"  /  /  / abc /  / d / e \"  )  ;", "checkNoMatch (  \"  /  /  / abc /  /  { def }  /  /  /  /  /  / xyz \"  ,     \"  / abc / foo / xyz \"  )  ;", "checkMatches (  \"  /  /  / abc /  /  { def }  /  /  /  /  /  / xyz \"  ,     \"  /  /  / abc /  / p /  /  /  /  /  / xyz \"  )  ;", "}", "METHOD_END"], "methodName": ["multipleSeparatorsInPattern"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkNoMatch (  \"  /  /  / one /  /  / two /  /  / three \"  ,     \"  /  / one /  /  /  /  / two /  /  /  /  /  /  / three \"  )  ;", "checkMatches (  \"  /  / one /  /  /  /  / two /  /  /  /  /  /  / three \"  ,     \"  /  / one /  /  /  /  / two /  /  /  /  /  /  / three \"  )  ;", "checkNoMatch (  \"  /  / one /  / two /  / three \"  ,     \"  / one /  /  /  /  / two / three \"  )  ;", "checkMatches (  \"  / one /  /  /  /  / two / three \"  ,     \"  / one /  /  /  /  / two / three \"  )  ;", "checkCapture (  \"  /  /  /  { foo }  /  /  / bar \"  ,     \"  /  /  / one /  /  / bar \"  ,     \" foo \"  ,     \" one \"  )  ;", "}", "METHOD_END"], "methodName": ["multipleSeparatorsInPatternAndPath"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPattern   pp ;", "pp    =    parse (  \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parse (  \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parse (  \" res ? urce \"  )  ;", "assertNoMatch ( pp ,     \" resource /  /  \"  )  ;", "pp    =    parse (  \"  / res ? urce \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parse (  \"  / res ? urce /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parse (  \"  /  { var }  \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertEquals (  \" resource \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertEquals (  \" resource \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parse (  \"  /  { var }  /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertEquals (  \" resource \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parse (  \"  /  {  * var }  \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertEquals (  \"  / resource \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertEquals (  \"  / resource /  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertMatches ( pp ,     \"  / resource /  /  \"  )  ;", "assertEquals (  \"  / resource /  /  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource /  /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertMatches ( pp ,     \"  /  / resource /  /  \"  )  ;", "assertEquals (  \"  /  / resource /  /  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  /  / resource /  /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "pp    =    parse (  \"  /  *  *  \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertMatches ( pp ,     \"  / resource /  /  \"  )  ;", "assertMatches ( pp ,     \"  /  / resource /  /  \"  )  ;", "pp    =    parse (  \"  /  *  \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parse (  \"  /  *  /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parse (  \"  /  { var 1  }  _  { var 2  }  \"  )  ;", "assertMatches ( pp ,     \"  / res 1  _ res 2  \"  )  ;", "assertEquals (  \" res 1  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  \"  )  )  . getUriVariables (  )  . get (  \" var 1  \"  )  )  ;", "assertEquals (  \" res 2  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  \"  )  )  . getUriVariables (  )  . get (  \" var 2  \"  )  )  ;", "assertMatches ( pp ,     \"  / res 1  _ res 2  /  \"  )  ;", "assertEquals (  \" res 1  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  /  \"  )  )  . getUriVariables (  )  . get (  \" var 1  \"  )  )  ;", "assertEquals (  \" res 2  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  /  \"  )  )  . getUriVariables (  )  . get (  \" var 2  \"  )  )  ;", "assertNoMatch ( pp ,     \"  / res 1  _ res 2  /  /  \"  )  ;", "pp    =    parse (  \"  /  { var 1  }  _  { var 2  }  /  \"  )  ;", "assertNoMatch ( pp ,     \"  / res 1  _ res 2  \"  )  ;", "assertMatches ( pp ,     \"  / res 1  _ res 2  /  \"  )  ;", "assertEquals (  \" res 1  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  /  \"  )  )  . getUriVariables (  )  . get (  \" var 1  \"  )  )  ;", "assertEquals (  \" res 2  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  /  \"  )  )  . getUriVariables (  )  . get (  \" var 2  \"  )  )  ;", "assertNoMatch ( pp ,     \"  / res 1  _ res 2  /  /  \"  )  ;", "pp    =    parse (  \"  /  { var 1  }  *  \"  )  ;", "assertMatches ( pp ,     \"  / a \"  )  ;", "assertMatches ( pp ,     \"  / a /  \"  )  ;", "assertNoMatch ( pp ,     \"  /  \"  )  ;", "assertNoMatch ( pp ,     \"  /  /  \"  )  ;", "PathPatternParser   parser    =    new   PathPatternParser (  )  ;", "parser . setMatchOptionalTrailingSeparator ( false )  ;", "pp    =    parser . parse (  \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  / res ? urce \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  / res ? urce /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  /  { var }  \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertEquals (  \" resource \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertNoMatch ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  /  { var }  /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertEquals (  \" resource \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  /  {  * var }  \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertEquals (  \"  / resource \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertEquals (  \"  / resource /  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertMatches ( pp ,     \"  / resource /  /  \"  )  ;", "assertEquals (  \"  / resource /  /  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / resource /  /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertMatches ( pp ,     \"  /  / resource /  /  \"  )  ;", "assertEquals (  \"  /  / resource /  /  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  /  / resource /  /  \"  )  )  . getUriVariables (  )  . get (  \" var \"  )  )  ;", "pp    =    parser . parse (  \"  /  *  *  \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertMatches ( pp ,     \"  / resource /  /  \"  )  ;", "assertMatches ( pp ,     \"  /  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  /  *  \"  )  ;", "assertMatches ( pp ,     \"  / resource \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  /  *  /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource \"  )  ;", "assertMatches ( pp ,     \"  / resource /  \"  )  ;", "assertNoMatch ( pp ,     \"  / resource /  /  \"  )  ;", "pp    =    parser . parse (  \"  /  { var 1  }  _  { var 2  }  \"  )  ;", "assertMatches ( pp ,     \"  / res 1  _ res 2  \"  )  ;", "assertEquals (  \" res 1  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  \"  )  )  . getUriVariables (  )  . get (  \" var 1  \"  )  )  ;", "assertEquals (  \" res 2  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  \"  )  )  . getUriVariables (  )  . get (  \" var 2  \"  )  )  ;", "assertNoMatch ( pp ,     \"  / res 1  _ res 2  /  \"  )  ;", "assertNoMatch ( pp ,     \"  / res 1  _ res 2  /  /  \"  )  ;", "pp    =    parser . parse (  \"  /  { var 1  }  _  { var 2  }  /  \"  )  ;", "assertNoMatch ( pp ,     \"  / res 1  _ res 2  \"  )  ;", "assertMatches ( pp ,     \"  / res 1  _ res 2  /  \"  )  ;", "assertEquals (  \" res 1  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  /  \"  )  )  . getUriVariables (  )  . get (  \" var 1  \"  )  )  ;", "assertEquals (  \" res 2  \"  ,    pp . matchAndExtract (  . toPathContainer (  \"  / res 1  _ res 2  /  \"  )  )  . getUriVariables (  )  . get (  \" var 2  \"  )  )  ;", "assertNoMatch ( pp ,     \"  / res 1  _ res 2  /  /  \"  )  ;", "pp    =    parser . parse (  \"  /  { var 1  }  *  \"  )  ;", "assertMatches ( pp ,     \"  / a \"  )  ;", "assertNoMatch ( pp ,     \"  / a /  \"  )  ;", "assertNoMatch ( pp ,     \"  /  \"  )  ;", "assertNoMatch ( pp ,     \"  /  /  \"  )  ;", "}", "METHOD_END"], "methodName": ["optionalTrailingSeparators"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPattern . PathMatchInfo   result    =    matchAndExtract (  \"  / abc /  { var }  \"  ,     \"  / abc / one ; two = three ; four = five \"  )  ;", "assertEquals (  \" one \"  ,    result . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertEquals (  \" three \"  ,    result . getMatrixVariables (  )  . get (  \" var \"  )  . getFirst (  \" two \"  )  )  ;", "assertEquals (  \" five \"  ,    result . getMatrixVariables (  )  . get (  \" var \"  )  . getFirst (  \" four \"  )  )  ;", "result    =    matchAndExtract (  \"  / abc /  { var 1  }  _  { var 2  }  \"  ,     \"  / abc /  1  2  3  _  4  5  6  ; a = b ; c = d \"  )  ;", "assertEquals (  \"  1  2  3  \"  ,    result . getUriVariables (  )  . get (  \" var 1  \"  )  )  ;", "assertEquals (  \"  4  5  6  \"  ,    result . getUriVariables (  )  . get (  \" var 2  \"  )  )  ;", "assertNull ( result . getMatrixVariables (  )  . get (  \" var 1  \"  )  )  ;", "assertNull ( result . getMatrixVariables (  )  . get (  \" var 1  \"  )  )  ;", "assertEquals (  \" b \"  ,    result . getMatrixVariables (  )  . get (  \" var 2  \"  )  . getFirst (  \" a \"  )  )  ;", "assertEquals (  \" d \"  ,    result . getMatrixVariables (  )  . get (  \" var 2  \"  )  . getFirst (  \" c \"  )  )  ;", "result    =    matchAndExtract (  \"  /  {  * var }  \"  ,     \"  / abc /  1  2  3  _  4  5  6  ; a = b ; c = d \"  )  ;", "assertEquals (  \"  / abc /  1  2  3  _  4  5  6  \"  ,    result . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertEquals (  \" b \"  ,    result . getMatrixVariables (  )  . get (  \" var \"  )  . getFirst (  \" a \"  )  )  ;", "assertEquals (  \" d \"  ,    result . getMatrixVariables (  )  . get (  \" var \"  )  . getFirst (  \" c \"  )  )  ;", "result    =    matchAndExtract (  \"  /  {  * var }  \"  ,     \"  / abc /  1  2  3  _  4  5  6  ; a = b ; c = d /  7  8  9  ; a = e ; f = g \"  )  ;", "assertEquals (  \"  / abc /  1  2  3  _  4  5  6  /  7  8  9  \"  ,    result . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertEquals (  \"  [ b ,    e ]  \"  ,    result . getMatrixVariables (  )  . get (  \" var \"  )  . get (  \" a \"  )  . toString (  )  )  ;", "assertEquals (  \" d \"  ,    result . getMatrixVariables (  )  . get (  \" var \"  )  . getFirst (  \" c \"  )  )  ;", "assertEquals (  \" g \"  ,    result . getMatrixVariables (  )  . get (  \" var \"  )  . getFirst (  \" f \"  )  )  ;", "result    =    matchAndExtract (  \"  / abc /  { var }  \"  ,     \"  / abc / one \"  )  ;", "assertEquals (  \" one \"  ,    result . getUriVariables (  )  . get (  \" var \"  )  )  ;", "assertNull ( result . getMatrixVariables (  )  . get (  \" var \"  )  )  ;", "result    =    matchAndExtract (  \"  \"  ,     \"  \"  )  ;", "assertNotNull ( result )  ;", "result    =    matchAndExtract (  \"  \"  ,     \"  /  \"  )  ;", "assertNotNull ( result )  ;", "}", "METHOD_END"], "methodName": ["parameters"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   pp    =    new   PathPatternParser (  )  ;", "pp . setMatchOptionalTrailingSeparator ( true )  ;", "return   pp . parse ( path )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  [  /  ]  [ abc ]  [  /  ]  [ def ]  \"  ,    elementsToString ( PathPatternTests . toPathContainer (  \"  / abc / def \"  )  . elements (  )  )  )  ;", "assertEquals (  \"  [ abc ]  [  /  ]  [ def ]  \"  ,    elementsToString ( PathPatternTests . toPathContainer (  \" abc / def \"  )  . elements (  )  )  )  ;", "assertEquals (  \"  [ abc ]  [  /  ]  [ def ]  [  /  ]  \"  ,    elementsToString ( PathPatternTests . toPathContainer (  \" abc / def /  \"  )  . elements (  )  )  )  ;", "assertEquals (  \"  [ abc ]  [  /  ]  [  /  ]  [ def ]  [  /  ]  [  /  ]  \"  ,    elementsToString ( PathPatternTests . toPathContainer (  \" abc /  / def /  /  \"  )  . elements (  )  )  )  ;", "assertEquals (  \"  [  /  ]  \"  ,    elementsToString ( PathPatternTests . toPathContainer (  \"  /  \"  )  . elements (  )  )  )  ;", "assertEquals (  \"  [  /  ]  [  /  ]  [  /  ]  \"  ,    elementsToString ( PathPatternTests . toPathContainer (  \"  /  /  /  \"  )  . elements (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["pathContainer"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  / foo \"  ,     \"  / foo / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  /  \"  ,    getPathRemaining (  \"  / foo \"  ,     \"  / foo /  \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  / foo *  \"  ,     \"  / foo / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  /  *  \"  ,     \"  / foo / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  /  { foo }  \"  ,     \"  / foo / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertNull ( getPathRemaining (  \"  / foo \"  ,     \"  / bar / baz \"  )  )  ;", "assertEquals (  \"  \"  ,    getPathRemaining (  \"  /  *  *  \"  ,     \"  / foo / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  \"  ,    getPathRemaining (  \"  /  {  * bar }  \"  ,     \"  / foo / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  / a ? b / d ? e \"  ,     \"  / aab / dde / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  /  { abc } abc \"  ,     \"  / xyzabc / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  /  * y *  \"  ,     \"  / xyzxyz / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  \"  ,    getPathRemaining (  \"  /  \"  ,     \"  /  \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" a \"  ,    getPathRemaining (  \"  /  \"  ,     \"  / a \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" a /  \"  ,    getPathRemaining (  \"  /  \"  ,     \"  / a /  \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  / a { abc }  \"  ,     \"  / a / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  / bar \"  ,    getPathRemaining (  \"  / foo /  /  \"  ,     \"  / foo /  /  / bar \"  )  . getPathRemaining (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathRemainderBasicCases_spr15336"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( parse (  \"  / foo \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / footastic / bar \"  )  )  )  ;", "assertNull ( parse (  \"  / f ? o \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / footastic / bar \"  )  )  )  ;", "assertNull ( parse (  \"  / f * o * p \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / flooptastic / bar \"  )  )  )  ;", "assertNull ( parse (  \"  /  { abc } abc \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / xyzabcbar / bar \"  )  )  )  ;", "assertNull ( parse (  \"  / resource /  *  *  \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / resourceX \"  )  )  )  ;", "assertEquals (  \"  \"  ,    parse (  \"  / resource /  *  *  \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / resource \"  )  )  . getPathRemaining (  )  . value (  )  )  ;", "assertNull ( parse (  \"  / resource /  {  * foo }  \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / resourceX \"  )  )  )  ;", "assertEquals (  \"  \"  ,    parse (  \"  / resource /  {  * foo }  \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / resource \"  )  )  . getPathRemaining (  )  . value (  )  )  ;", "PathPattern . PathRemainingMatchInfo   pri    =    parse (  \"  / aaa /  { bbb }  / c ? d / e * f /  *  / g \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / aaa / b / ccd / ef / x / g / i \"  )  )  ;", "assertNotNull ( pri )  ;", "assertEquals (  \"  / i \"  ,    pri . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" b \"  ,    pri . getUriVariables (  )  . get (  \" bbb \"  )  )  ;", "pri    =    parse (  \"  / aaa /  { bbb }  / c ? d / e * f /  *  / g /  \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / aaa / b / ccd / ef / x / g / i \"  )  )  ;", "assertNotNull ( pri )  ;", "assertEquals (  \" i \"  ,    pri . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" b \"  ,    pri . getUriVariables (  )  . get (  \" bbb \"  )  )  ;", "pri    =    parse (  \"  /  { aaa }  _  { bbb }  / e * f /  { x }  / g \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / aa _ bb / ef / x / g / i \"  )  )  ;", "assertNotNull ( pri )  ;", "assertEquals (  \"  / i \"  ,    pri . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" aa \"  ,    pri . getUriVariables (  )  . get (  \" aaa \"  )  )  ;", "assertEquals (  \" bb \"  ,    pri . getUriVariables (  )  . get (  \" bbb \"  )  )  ;", "assertEquals (  \" x \"  ,    pri . getUriVariables (  )  . get (  \" x \"  )  )  ;", "assertNull ( parse (  \"  / a / b \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  \"  )  )  )  ;", "assertEquals (  \"  / a / b \"  ,    parse (  \"  \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  / a / b \"  )  )  . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \"  \"  ,    parse (  \"  \"  )  . matchStartOfPath ( PathPatternTests . toPathContainer (  \"  \"  )  )  . getPathRemaining (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathRemainingCornerCases_spr15336"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "PathPattern   pp ;", "PathPattern . PathRemainingMatchInfo   pri ;", "pp    =    parse (  \"  /  { this }  /  { one }  /  { here }  \"  )  ;", "pri    =    getPathRemaining ( pp ,     \"  / foo / bar / goo / boo \"  )  ;", "assertEquals (  \"  / boo \"  ,    pri . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" foo \"  ,    pri . getUriVariables (  )  . get (  \" this \"  )  )  ;", "assertEquals (  \" bar \"  ,    pri . getUriVariables (  )  . get (  \" one \"  )  )  ;", "assertEquals (  \" goo \"  ,    pri . getUriVariables (  )  . get (  \" here \"  )  )  ;", "pp    =    parse (  \"  / aaa /  { foo }  \"  )  ;", "pri    =    getPathRemaining ( pp ,     \"  / aaa / bbb \"  )  ;", "assertEquals (  \"  \"  ,    pri . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" bbb \"  ,    pri . getUriVariables (  )  . get (  \" foo \"  )  )  ;", "pp    =    parse (  \"  / aaa / bbb \"  )  ;", "pri    =    getPathRemaining ( pp ,     \"  / aaa / bbb \"  )  ;", "assertEquals (  \"  \"  ,    pri . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  0  ,    pri . getUriVariables (  )  . size (  )  )  ;", "pp    =    parse (  \"  /  *  /  { foo }  / b *  \"  )  ;", "pri    =    getPathRemaining ( pp ,     \"  / foo \"  )  ;", "assertNull ( pri )  ;", "pri    =    getPathRemaining ( pp ,     \"  / abc / def / bhi \"  )  ;", "assertEquals (  \"  \"  ,    pri . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" def \"  ,    pri . getUriVariables (  )  . get (  \" foo \"  )  )  ;", "pri    =    getPathRemaining ( pp ,     \"  / abc / def / bhi / jkl \"  )  ;", "assertEquals (  \"  / jkl \"  ,    pri . getPathRemaining (  )  . value (  )  )  ;", "assertEquals (  \" def \"  ,    pri . getUriVariables (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["pathRemainingEnhancements_spr15419"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < PathPattern >    comparator    =    PathPattern . SPECIFICITY _ COMPARATOR ;", "assertEquals (  0  ,    comparator . compare ( parse (  \"  / hotels / new \"  )  ,    parse (  \"  / hotels / new \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  / hotels / new \"  )  ,    parse (  \"  / hotels /  *  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  / hotels /  *  \"  )  ,    parse (  \"  / hotels / new \"  )  )  )  ;", "assertEquals (  0  ,    comparator . compare ( parse (  \"  / hotels /  *  \"  )  ,    parse (  \"  / hotels /  *  \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  / hotels / new \"  )  ,    parse (  \"  / hotels /  { hotel }  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  / hotels /  { hotel }  \"  )  ,    parse (  \"  / hotels / new \"  )  )  )  ;", "assertEquals (  0  ,    comparator . compare ( parse (  \"  / hotels /  { hotel }  \"  )  ,    parse (  \"  / hotels /  { hotel }  \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  / hotels /  { hotel }  / booking \"  )  ,    parse (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  ,    parse (  \"  / hotels /  { hotel }  / booking \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  / hotels /  { hotel }  / bookings /  { booking }  / cutomers /  { customer }  \"  )  ,    parse (  \"  /  *  *  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  /  *  *  \"  )  ,    parse (  \"  / hotels /  { hotel }  / bookings /  { booking }  / cutomers /  { customer }  \"  )  )  )  ;", "assertEquals (  0  ,    comparator . compare ( parse (  \"  /  *  *  \"  )  ,    parse (  \"  /  *  *  \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  / hotels /  { hotel }  \"  )  ,    parse (  \"  / hotels /  *  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  / hotels /  *  \"  )  ,    parse (  \"  / hotels /  { hotel }  \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  / hotels /  *  \"  )  ,    parse (  \"  / hotels /  *  /  *  *  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  / hotels /  *  /  *  *  \"  )  ,    parse (  \"  / hotels /  *  \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  / hotels /  { hotel }  / bookings /  { booking }  / cutomers /  { customer }  \"  )  ,    parse (  \"  / hotels /  *  *  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  / hotels /  *  *  \"  )  ,    parse (  \"  / hotels /  { hotel }  / bookings /  { booking }  / cutomers /  { customer }  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  / hotels / foo / bar /  *  *  \"  )  ,    parse (  \"  / hotels /  { hotel }  \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  / hotels /  { hotel }  \"  )  ,    parse (  \"  / hotels / foo / bar /  *  *  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  /  *  *  \"  )  ,    parse (  \"  / hotels /  { hotel }  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  / hotels \"  )  ,    parse (  \"  / hotels 2  \"  )  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare ( parse (  \"  *  \"  )  ,    parse (  \"  *  /  *  *  \"  )  )  )  ;", "assertEquals (  1  ,    comparator . compare ( parse (  \"  *  /  *  *  \"  )  ,    parse (  \"  *  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["patternComparator"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( PathPattern . SPECIFICITY _ COMPARATOR . compare ( null ,    null )  )     =  =     0  )  )  ;", "assertTrue (  (  ( PathPattern . SPECIFICITY _ COMPARATOR . compare ( parse (  \"  / abc \"  )  ,    null )  )     <     0  )  )  ;", "assertTrue (  (  ( PathPattern . SPECIFICITY _ COMPARATOR . compare ( null ,    parse (  \"  / abc \"  )  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["patternCompareWithNull"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkNoMatch (  \" a \"  ,     \" ab \"  )  ;", "checkMatches (  \"  / f ? o / bar \"  ,     \"  / foo / bar \"  )  ;", "checkNoMatch (  \"  / foo / b 2 r \"  ,     \"  / foo / bar \"  )  ;", "checkNoMatch (  \"  ?  \"  ,     \" te \"  )  ;", "checkMatches (  \"  ?  \"  ,     \" a \"  )  ;", "checkMatches (  \"  ?  ?  ?  \"  ,     \" abc \"  )  ;", "checkNoMatch (  \" tes ?  \"  ,     \" te \"  )  ;", "checkNoMatch (  \" tes ?  \"  ,     \" tes \"  )  ;", "checkNoMatch (  \" tes ?  \"  ,     \" tt \"  )  ;", "checkNoMatch (  \" tes ?  \"  ,     \" tsst \"  )  ;", "checkMatches (  \"  .  ?  . a \"  ,     \"  . a . a \"  )  ;", "checkNoMatch (  \"  .  ?  . a \"  ,     \"  . aba \"  )  ;", "checkMatches (  \"  / f ? o / bar \"  ,     \"  / f %  2  0 o / bar \"  )  ;", "}", "METHOD_END"], "methodName": ["questionMarks"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "if    ( path    =  =    null )     {", "return   null ;", "}", "return   Container . parse ( path )  ;", "}", "METHOD_END"], "methodName": ["toPathContainer"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "checkMatches (  \"  /  *  / bar \"  ,     \"  / foo / bar \"  )  ;", "checkNoMatch (  \"  /  *  / bar \"  ,     \"  / foo / baz \"  )  ;", "checkNoMatch (  \"  /  *  / bar \"  ,     \"  /  / bar \"  )  ;", "checkMatches (  \"  / f *  / bar \"  ,     \"  / foo / bar \"  )  ;", "checkMatches (  \"  /  *  / bar \"  ,     \"  / foo / bar \"  )  ;", "checkMatches (  \" a /  *  \"  ,     \" a /  \"  )  ;", "checkMatches (  \"  /  *  \"  ,     \"  /  \"  )  ;", "checkMatches (  \"  /  *  / bar \"  ,     \"  / foo / bar \"  )  ;", "checkNoMatch (  \"  /  *  / bar \"  ,     \"  / foo / baz \"  )  ;", "checkMatches (  \"  / f *  / bar \"  ,     \"  / foo / bar \"  )  ;", "checkMatches (  \"  /  *  / bar \"  ,     \"  / foo / bar \"  )  ;", "checkMatches (  \"  / a * b * c * d / bar \"  ,     \"  / abcd / bar \"  )  ;", "checkMatches (  \"  * a *  \"  ,     \" testa \"  )  ;", "checkMatches (  \" a /  *  \"  ,     \" a /  \"  )  ;", "checkNoMatch (  \" a /  *  \"  ,     \" a /  /  \"  )  ;", "checkMatches (  \" a /  *  \"  ,     \" a / a /  \"  )  ;", "PathPatternParser   ppp    =    new   PathPatternParser (  )  ;", "ppp . setMatchOptionalTrailingSeparator ( false )  ;", "assertFalse ( ppp . parse (  \" a /  *  \"  )  . matches (  . toPathContainer (  \" a /  /  \"  )  )  )  ;", "checkMatches (  \" a /  *  \"  ,     \" a / a \"  )  ;", "checkMatches (  \" a /  *  \"  ,     \" a / a /  \"  )  ;", "checkMatches (  \"  / resource /  *  *  \"  ,     \"  / resource \"  )  ;", "checkNoMatch (  \"  / resource /  *  *  \"  ,     \"  / resourceX \"  )  ;", "checkNoMatch (  \"  / resource /  *  *  \"  ,     \"  / resourceX / foobar \"  )  ;", "checkMatches (  \"  / resource /  *  *  \"  ,     \"  / resource / foobar \"  )  ;", "}", "METHOD_END"], "methodName": ["wildcards"], "fileName": "org.springframework.web.util.pattern.PathPatternTests"}, {"methodBody": ["METHOD_START", "{", "return   this . inserts ;", "}", "METHOD_END"], "methodName": ["getInserts"], "fileName": "org.springframework.web.util.pattern.PatternParseException"}, {"methodBody": ["METHOD_START", "{", "return   this . messageType ;", "}", "METHOD_END"], "methodName": ["getMessageType"], "fileName": "org.springframework.web.util.pattern.PatternParseException"}, {"methodBody": ["METHOD_START", "{", "return   this . position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "org.springframework.web.util.pattern.PatternParseException"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "buf . append ( this )  . append (  '  \\ n '  )  ;", "for    ( int   i    =     0  ;    i    <     ( this . position )  ;    i +  +  )     {", "buf . append (  '     '  )  ;", "}", "buf . append (  \"  ^  \\ n \"  )  ;", "buf . append ( getMessage (  )  )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toDetailedString"], "fileName": "org.springframework.web.util.pattern.PatternParseException"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   patternBuilder    =    new   StringBuilder (  )  ;", "String   text    =    new   String ( regex )  ;", "Matcher   matcher    =     . GLOB _ PATTERN . matcher ( text )  ;", "int   end    =     0  ;", "while    ( matcher . find (  )  )     {", "patternBuilder . append ( quote ( text ,    end ,    matcher . start (  )  )  )  ;", "String   match    =    matcher . group (  )  ;", "if    (  \"  ?  \"  . equals ( match )  )     {", "patternBuilder . append (  '  .  '  )  ;", "} else", "if    (  \"  *  \"  . equals ( match )  )     {", "patternBuilder . append (  \"  .  *  \"  )  ;", "int   pos    =    matcher . start (  )  ;", "if    (  ( pos    <     1  )     |  |     (  ( text . charAt (  ( pos    -     1  )  )  )     !  =     '  .  '  )  )     {", "( this . wildcardCount )  +  +  ;", "}", "} else", "if    (  ( match . startsWith (  \"  {  \"  )  )     &  &     ( match . endsWith (  \"  }  \"  )  )  )     {", "int   colonIdx    =    match . indexOf (  '  :  '  )  ;", "if    ( colonIdx    =  =     (  -  1  )  )     {", "patternBuilder . append (  . DEFAULT _ VARIABLE _ PATTERN )  ;", "String   variableName    =    matcher . group (  1  )  ;", "if    ( this . variableNames . contains ( variableName )  )     {", "throw   new   PatternParseException ( this . pos ,    completePattern ,    PatternParseException . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE ,    variableName )  ;", "}", "this . variableNames . add ( variableName )  ;", "} else    {", "String   variablePattern    =    match . substring (  ( colonIdx    +     1  )  ,     (  ( match . length (  )  )     -     1  )  )  ;", "patternBuilder . append (  '  (  '  )  ;", "patternBuilder . append ( variablePattern )  ;", "patternBuilder . append (  '  )  '  )  ;", "String   variableName    =    match . substring (  1  ,    colonIdx )  ;", "if    ( this . variableNames . contains ( variableName )  )     {", "throw   new   PatternParseException ( this . pos ,    completePattern ,    PatternParseException . PatternMessage . ILLEGAL _ DOUBLE _ CAPTURE ,    variableName )  ;", "}", "this . variableNames . add ( variableName )  ;", "}", "}", "end    =    matcher . end (  )  ;", "}", "patternBuilder . append ( quote ( text ,    end ,    text . length (  )  )  )  ;", "if    ( this . caseSensitive )     {", "return   Pattern . compile ( patternBuilder . toString (  )  )  ;", "} else    {", "return   Pattern . compile ( patternBuilder . toString (  )  ,    Pattern . CASE _ INSENSITIVE )  ;", "}", "}", "METHOD_END"], "methodName": ["buildPattern"], "fileName": "org.springframework.web.util.pattern.RegexPathElement"}, {"methodBody": ["METHOD_START", "{", "return   this . variableNames ;", "}", "METHOD_END"], "methodName": ["getVariableNames"], "fileName": "org.springframework.web.util.pattern.RegexPathElement"}, {"methodBody": ["METHOD_START", "{", "if    ( start    =  =    end )     {", "return    \"  \"  ;", "}", "return   Pquote ( s . substring ( start ,    end )  )  ;", "}", "METHOD_END"], "methodName": ["quote"], "fileName": "org.springframework.web.util.pattern.RegexPathElement"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Regex (  \"     +     ( String . valueOf ( this . regex )  )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.RegexPathElement"}, {"methodBody": ["METHOD_START", "{", "return   new   char [  ]  {    this . separator    }  ;", "}", "METHOD_END"], "methodName": ["getChars"], "fileName": "org.springframework.web.util.pattern.SeparatorPathElement"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Separator (  \"     +     ( this . separator )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.SeparatorPathElement"}, {"methodBody": ["METHOD_START", "{", "return    (  \" SingleCharWildcarded (  \"     +     ( String . valueOf ( this . text )  )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.SingleCharWildcardedPathElement"}, {"methodBody": ["METHOD_START", "{", "return    \" Wildcard (  *  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.WildcardPathElement"}, {"methodBody": ["METHOD_START", "{", "return    (  \" WildcardTheRest (  \"     +     ( this . separator )  )     +     \"  *  *  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.util.pattern.WildcardTheRestPathElement"}]