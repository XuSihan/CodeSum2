[{"methodBody": ["METHOD_START", "{", "if    ( this . initCalled )     {", "throw   new   IllegalStateException (  \" Init   already   called \"  )  ;", "}", "this . initCalled    =    true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "example.scannable.AutowiredQualifierFooService"}, {"methodBody": ["METHOD_START", "{", "if    ( this . initCalled )     {", "throw   new   IllegalStateException (  \" Init   already   called \"  )  ;", "}", "this . initCalled    =    true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "example.scannable.FooServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   fooDao (  )  . findFoo ( id )  ;", "}", "METHOD_END"], "methodName": ["lookupFoo"], "fileName": "example.scannable.FooServiceImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . message ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "example.scannable.MessageBean"}, {"methodBody": ["METHOD_START", "{", "return    \" bar \"  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "example.scannable.NamedStubDao"}, {"methodBody": ["METHOD_START", "{", "( this . useCount )  +  +  ;", ". threadLocalCount . set ( this . useCount )  ;", "}", "METHOD_END"], "methodName": ["countUse"], "fileName": "example.scannable.ServiceInvocationCounter"}, {"methodBody": ["METHOD_START", "{", "return   this . useCount ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "example.scannable.ServiceInvocationCounter"}, {"methodBody": ["METHOD_START", "{", "return   ServiceInvocationCounter . threadLocalCount . get (  )  ;", "}", "METHOD_END"], "methodName": ["getThreadLocalCount"], "fileName": "example.scannable.ServiceInvocationCounter"}, {"methodBody": ["METHOD_START", "{", "return   new   ConfigurableComponent ( true )  ;", "}", "METHOD_END"], "methodName": ["configurableComponent"], "fileName": "example.scannable_implicitbasepackage.ComponentScanAnnotatedConfigWithImplicitBasePackage"}, {"methodBody": ["METHOD_START", "{", "return   this . flag ;", "}", "METHOD_END"], "methodName": ["isFlag"], "fileName": "example.scannable_implicitbasepackage.ConfigurableComponent"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . needsJoinPoint ( tjp . getSignature (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["needsJoinPoint"], "fileName": "org.springframework.aop.aspectj.AdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . needsJoinPointStaticPart ( tjpsp . getSignature (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["needsJoinPointStaticPart"], "fileName": "org.springframework.aop.aspectj.AdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . oneIntAndOneObject ( x ,    o )  ;", "}", "METHOD_END"], "methodName": ["oneIntAndOneObject"], "fileName": "org.springframework.aop.aspectj.AdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . oneIntArg ( age )  ;", "}", "METHOD_END"], "methodName": ["oneIntArg"], "fileName": "org.springframework.aop.aspectj.AdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . oneObjectArg ( bean )  ;", "}", "METHOD_END"], "methodName": ["oneObjectArg"], "fileName": "org.springframework.aop.aspectj.AdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator    =    aCollaborator ;", "}", "METHOD_END"], "methodName": ["setCollaborator"], "fileName": "org.springframework.aop.aspectj.AdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "Aspect   afterAdviceAspect    =     (  ( Aspect )     ( ctx . getBean (  \" testAspect \"  )  )  )  ;", "testBeanProxy    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( testBeanProxy )  )  ;", "testBeanTarget    =     (  ( TestBean )     (  (  ( Advised )     ( testBeanProxy )  )  . getTargetSource (  )  . getTarget (  )  )  )  ;", "mockCollaborator    =    mock ( Aspect . AdviceBindingCollaborator . class )  ;", "afterAdviceAspect . setCollaborator ( mockCollaborator )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.AfterAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . needsJoinPoint (  \" getAge \"  )  ;", "}", "METHOD_END"], "methodName": ["testNeedsJoinPoint"], "fileName": "org.springframework.aop.aspectj.AfterAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . needsJoinPointStaticPart (  \" getAge \"  )  ;", "}", "METHOD_END"], "methodName": ["testNeedsJoinPointStaticPart"], "fileName": "org.springframework.aop.aspectj.AfterAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  5  )  ;", "verify ( mockCollaborator )  . oneIntAndOneObject (  5  ,    this . testBeanProxy )  ;", "}", "METHOD_END"], "methodName": ["testOneIntAndOneObjectArgs"], "fileName": "org.springframework.aop.aspectj.AfterAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  5  )  ;", "verify ( mockCollaborator )  . oneIntArg (  5  )  ;", "}", "METHOD_END"], "methodName": ["testOneIntArg"], "fileName": "org.springframework.aop.aspectj.AfterAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . oneObjectArg ( this . testBeanProxy )  ;", "}", "METHOD_END"], "methodName": ["testOneObjectArgBindingProxyWithThis"], "fileName": "org.springframework.aop.aspectj.AfterAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getDoctor (  )  ;", "verify ( mockCollaborator )  . oneObjectArg ( this . testBeanTarget )  ;", "}", "METHOD_END"], "methodName": ["testOneObjectArgBindingTarget"], "fileName": "org.springframework.aop.aspectj.AfterAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( AfterReturningAdviceBindingTestAspect . AfterReturningAdviceBindingCollaborator )     ( this . collaborator )  )  ;", "}", "METHOD_END"], "methodName": ["getCollaborator"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "getCollaborator (  )  . objectMatchNoArgs (  )  ;", "}", "METHOD_END"], "methodName": ["objectMatchNoArgs"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "getCollaborator (  )  . oneInt ( result )  ;", "}", "METHOD_END"], "methodName": ["oneInt"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "getCollaborator (  )  . oneString ( name )  ;", "}", "METHOD_END"], "methodName": ["oneString"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "getCollaborator (  )  . oneTestBeanArg ( bean )  ;", "}", "METHOD_END"], "methodName": ["oneTestBeanArg"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "getCollaborator (  )  . stringMatchNoArgs (  )  ;", "}", "METHOD_END"], "methodName": ["stringMatchNoArgs"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "getCollaborator (  )  . testBeanArrayArg ( beans )  ;", "}", "METHOD_END"], "methodName": ["testBeanArrayArg"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . afterAdviceAspect    =    anAspect ;", "}", "METHOD_END"], "methodName": ["setAfterReturningAdviceAspect"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "afterAdviceAspect    =     (  ( Aspect )     ( ctx . getBean (  \" testAspect \"  )  )  )  ;", "mockCollaborator    =    mock ( Aspect . AfterReturningAdviceBindingCollaborator . class )  ;", "afterAdviceAspect . setCollaborator ( mockCollaborator )  ;", "testBeanProxy    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( testBeanProxy )  )  ;", "this . testBeanTarget    =     (  ( TestBean )     (  (  ( Advised )     ( testBeanProxy )  )  . getTargetSource (  )  . getTarget (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . needsJoinPoint (  \" getAge \"  )  ;", "}", "METHOD_END"], "methodName": ["testNeedsJoinPoint"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . needsJoinPointStaticPart (  \" getAge \"  )  ;", "}", "METHOD_END"], "methodName": ["testNeedsJoinPointStaticPart"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setSpouse ( this . testBeanProxy )  ;", "testBeanProxy . getSpouse (  )  ;", "verifyZeroInteractions ( mockCollaborator )  ;", "}", "METHOD_END"], "methodName": ["testNoInvokeWhenReturningParameterTypeDoesNotMatch"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  5  )  ;", "verify ( mockCollaborator )  . oneIntAndOneObject (  5  ,    this . testBeanProxy )  ;", "}", "METHOD_END"], "methodName": ["testOneIntAndOneObjectArgs"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  5  )  ;", "verify ( mockCollaborator )  . oneIntArg (  5  )  ;", "}", "METHOD_END"], "methodName": ["testOneIntArg"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . oneObjectArg ( this . testBeanProxy )  ;", "}", "METHOD_END"], "methodName": ["testOneObjectArg"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . returnsThis (  )  ;", "verify ( mockCollaborator )  . oneTestBeanArg ( this . testBeanTarget )  ;", "}", "METHOD_END"], "methodName": ["testReturningBean"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "this . testBeanTarget . setSpouse ( new   TestBean (  )  )  ;", "ITestBean [  ]    spouses    =    this . testBeanTarget . getSpouses (  )  ;", "testBeanProxy . getSpouses (  )  ;", "verify ( mockCollaborator )  . testBeanArrayArg ( spouses )  ;", "}", "METHOD_END"], "methodName": ["testReturningBeanArray"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . returnsThis (  )  ;", "verify ( mockCollaborator )  . objectMatchNoArgs (  )  ;", "}", "METHOD_END"], "methodName": ["testReturningByType"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . returnsThis (  )  ;", "verify ( mockCollaborator )  . oneObjectArg ( this . testBeanTarget )  ;", "}", "METHOD_END"], "methodName": ["testReturningObject"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  2  0  )  ;", "testBeanProxy . haveBirthday (  )  ;", "verify ( mockCollaborator )  . oneInt (  2  0  )  ;", "}", "METHOD_END"], "methodName": ["testReturningPrimitive"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setName (  \" adrian \"  )  ;", "testBeanProxy . getName (  )  ;", "verify ( mockCollaborator )  . oneSt (  \" adrian \"  )  ;", "}", "METHOD_END"], "methodName": ["testReturningString"], "fileName": "org.springframework.aop.aspectj.AfterReturningAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . noArgs (  )  ;", "}", "METHOD_END"], "methodName": ["noArgs"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . noArgsOnRuntimeExceptionMatch (  )  ;", "}", "METHOD_END"], "methodName": ["noArgsOnRuntimeExceptionMatch"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . noArgsOnThrowableMatch (  )  ;", "}", "METHOD_END"], "methodName": ["noArgsOnThrowableMatch"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . oneRuntimeException ( ex )  ;", "}", "METHOD_END"], "methodName": ["oneRuntimeException"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . oneThrowable ( t )  ;", "}", "METHOD_END"], "methodName": ["oneThrowable"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator    =    aCollaborator ;", "}", "METHOD_END"], "methodName": ["setCollaborator"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testBean    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "afterThrowingAdviceAspect    =     (  ( Aspect )     ( ctx . getBean (  \" testAspect \"  )  )  )  ;", "mockCollaborator    =    mock ( Aspect . AfterThrowingAdviceBindingCollaborator . class )  ;", "afterThrowingAdviceAspect . setCollaborator ( mockCollaborator )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   t    =    new   Throwable (  )  ;", "this . testBean . exceptional ( t )  ;", "verify ( mockCollaborator )  . oneThrowable ( t )  ;", "}", "METHOD_END"], "methodName": ["testAfterThrowingWithBinding"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   t    =    new   Throwable (  )  ;", "this . testBean . exceptional ( t )  ;", "verify ( mockCollaborator )  . noArgs (  )  ;", "verify ( mockCollaborator )  . oneThrowable ( t )  ;", "verify ( mockCollaborator )  . noArgsOnThrowableMatch (  )  ;", "}", "METHOD_END"], "methodName": ["testAfterThrowingWithNamedTypeRestriction"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "RuntimeException   ex    =    new   RuntimeException (  )  ;", "this . tBean . exceptional ( ex )  ;", "verify ( mockCollaborator )  . oneRuntimeException ( ex )  ;", "}", "METHOD_END"], "methodName": ["testAfterThrowingWithRuntimeExceptionBinding"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "this . testBean . exceptional ( new   RuntimeException (  )  )  ;", "verify ( mockCollaborator )  . noArgsOnRuntimeExceptionMatch (  )  ;", "}", "METHOD_END"], "methodName": ["testAfterThrowingWithRuntimeTypeSpecified"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "this . testBean . exceptional ( new   Throwable (  )  )  ;", "verify ( mockCollaborator )  . noArgsOnThrowableMatch (  )  ;", "}", "METHOD_END"], "methodName": ["testAfterThrowingWithTypeSpecified"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "this . testBean . exceptional ( new   Throwable (  )  )  ;", "verify ( mockCollaborator )  . noArgs (  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleAfterThrowing"], "fileName": "org.springframework.aop.aspectj.AfterThrowingAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . justJoinPoint ( pjp . getSignature (  )  . getName (  )  )  ;", "return    (  ( Integer )     ( pjp . proceed (  )  )  )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["justJoinPoint"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . oneIntAndOneObject ( x ,    o )  ;", "pjp . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["oneIntAndOneObject"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . oneIntArg ( age )  ;", "pjp . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["oneIntArg"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . oneObjectArg ( bean )  ;", "return    (  ( Integer )     ( pjp . proceed (  )  )  )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["oneObjectArg"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator    =    aCollaborator ;", "}", "METHOD_END"], "methodName": ["setCollaborator"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "Aspect   aroundAdviceAspect    =     (  ( Aspect )     ( ctx . getBean (  \" testAspect \"  )  )  )  ;", "ITestBean   injectedTestBean    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( injectedTestBean )  )  ;", "this . testBeanProxy    =    injectedTestBean ;", "this . testBeanTarget    =     (  ( TestBean )     (  (  ( Advised )     ( testBeanProxy )  )  . getTargetSource (  )  . getTarget (  )  )  )  ;", "mockCollaborator    =    mock ( Aspect . AroundAdviceBindingCollaborator . class )  ;", "aroundAdviceAspect . setCollaborator ( mockCollaborator )  ;", "}", "METHOD_END"], "methodName": ["onSetUp"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . justJoinPoint (  \" getAge \"  )  ;", "}", "METHOD_END"], "methodName": ["testJustJoinPoint"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  5  )  ;", "verify ( mockCollaborator )  . oneIntAndOneObject (  5  ,    this . testBeanProxy )  ;", "}", "METHOD_END"], "methodName": ["testOneIntAndOneObjectArgs"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  5  )  ;", "verify ( mockCollaborator )  . oneIntArg (  5  )  ;", "}", "METHOD_END"], "methodName": ["testOneIntArg"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . oneObjectArg ( this . testBeanTarget )  ;", "}", "METHOD_END"], "methodName": ["testOneObjectArgBoundToTarget"], "fileName": "org.springframework.aop.aspectj.AroundAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "Object   tb    =    ctx . getBean (  \" testBean \"  )  ;", "assertTrue ( AopUtils . isAopProxy ( tb )  )  ;", "Object   tb 2     =    ctx . getBean (  \" testBean 2  \"  )  ;", "assertTrue ( AopUtils . isAopProxy ( tb 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testBothBeansAreProxies"], "fileName": "org.springframework.aop.aspectj.AroundAdviceCircularTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "highPrecedenceAspect    =     (  ( Aspect )     ( ctx . getBean (  \" highPrecedenceAspect \"  )  )  )  ;", "lowPrecedenceAspect    =     (  ( Aspect )     ( ctx . getBean (  \" lowPrecedenceAspect \"  )  )  )  ;", "highPrecedenceSpringAdvice    =     (  ( SimpleSpringBeforeAdvice )     ( ctx . getBean (  \" highPrecedenceSpringAdvice \"  )  )  )  ;", "lowPrecedenceSpringAdvice    =     (  ( SimpleSpringBeforeAdvice )     ( ctx . getBean (  \" lowPrecedenceSpringAdvice \"  )  )  )  ;", "testBean    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.AspectAndAdvicePrecedenceTests"}, {"methodBody": ["METHOD_START", "{", "PrecedenceTestAspect . Collaborator   collaborator    =    new   AspectAndAdvicePrecedenceTests . PrecedenceVerifyingCollaborator (  )  ;", "this . highPrecedenceAspect . setCollaborator ( collaborator )  ;", "this . lowPrecedenceAspect . setCollaborator ( collaborator )  ;", "this . highPrecedenceSpringAdvice . setCollaborator ( collaborator )  ;", "this . lowPrecedenceSpringAdvice . setCollaborator ( collaborator )  ;", "this . testBean . getAge (  )  ;", "}", "METHOD_END"], "methodName": ["testAdviceOrder"], "fileName": "org.springframework.aop.aspectj.AspectAndAdvicePrecedenceTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testBean    =     (  ( IBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "interceptor    =     (  ( CallCountingInterceptor )     ( ctx . getBean (  \" interceptor \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Count   should   be    0  \"  ,     0  ,    interceptor . getCount (  )  )  ;", "testBean . getSpouses (  )  ;", "assertEquals (  \" Count   should   be    1  \"  ,     1  ,    interceptor . getCount (  )  )  ;", "testBean . getSpouse (  )  ;", "assertEquals (  \" Count   should   be    1  \"  ,     1  ,    interceptor . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPointcutting"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  (  \" User    [  \"     +    username )     +     \"  ]    attempting   to   authenticate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["logAuthenticationAttempt"], "fileName": "org.springframework.aop.aspectj.AuthenticationLogger"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "counter    =     (  ( Counter )     ( ctx . getBean (  \" counter \"  )  )  )  ;", "testBean 1     =     (  ( ITestBean )     ( ctx . getBean (  \" testBean 1  \"  )  )  )  ;", "testBean 3     =     (  ( ITestBean )     ( ctx . getBean (  \" testBean 3  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutAtAspectTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Expected   a   proxy \"  ,     (  ( testBean 1  )    instanceof   Advised )  )  ;", "testBean 1  . setAge (  2  0  )  ;", "testBean 1  . setName (  \"  \"  )  ;", "assertEquals (  2  ,    counter . count )  ;", "}", "METHOD_END"], "methodName": ["testMatchingBeanName"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutAtAspectTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" Didn ' t   expect   a   proxy \"  ,     (  ( testBean 3  )    instanceof   Advised )  )  ;", "testBean 3  . setAge (  2  0  )  ;", "assertEquals (  0  ,    counter . count )  ;", "}", "METHOD_END"], "methodName": ["testNonMatchingBeanName"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutAtAspectTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   testBean    =    new   TestBean (  )  ;", "JProxyFactory   factory    =    new   JProxyFactory (  )  ;", "factory . setTarget ( testBean )  ;", "Counter   myCounter    =    new   Counter (  )  ;", "factory . add ( myCounter )  ;", "ITestBean   proxyTestBean    =    factory . getProxy (  )  ;", "assertTrue (  \" Expected   a   proxy \"  ,     ( proxyTestBean   instanceof   Advised )  )  ;", "proxyTestBean . setAge (  2  0  )  ;", "assertEquals (  \" Programmatically   created   proxy   shouldn ' t   match   bean (  )  \"  ,     0  ,    myCounter . count )  ;", "}", "METHOD_END"], "methodName": ["testProgrammaticProxyCreation"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutAtAspectTests"}, {"methodBody": ["METHOD_START", "{", "ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testBean 1     =     (  ( ITestBean )     ( ctx . getBean (  \" testBean 1  \"  )  )  )  ;", "testBean 2     =     (  ( ITestBean )     ( ctx . getBean (  \" testBean 2  \"  )  )  )  ;", "testBeanContainingNestedBean    =     (  ( ITestBean )     ( ctx . getBean (  \" testBeanContainingNestedBean \"  )  )  )  ;", "testFactoryBean 1     =     (  ( Map <  ?  ,     ?  >  )     ( ctx . getBean (  \" testFactoryBean 1  \"  )  )  )  ;", "testFactoryBean 2     =     (  ( Map <  ?  ,     ?  >  )     ( ctx . getBean (  \" testFactoryBean 2  \"  )  )  )  ;", "counterAspect    =     (  ( Counter )     ( ctx . getBean (  \" counterAspect \"  )  )  )  ;", "interceptThis    =     (  ( ITestBean )     ( ctx . getBean (  \" interceptThis \"  )  )  )  ;", "dontInterceptThis    =     (  ( ITestBean )     ( ctx . getBean (  \" dontInterceptThis \"  )  )  )  ;", "testInterceptor    =     (  (  . TestInterceptor )     ( ctx . getBean (  \" testInterceptor \"  )  )  )  ;", "counterAspect . reset (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Matching   bean   must   be   advised    ( proxied )  \"  ,     (  ( this . testBean 1  )    instanceof   Advised )  )  ;", "this . testBean 1  . setAge (  2  0  )  ;", "this . testBean 1  . setName (  \"  \"  )  ;", "assertEquals (  \" Advice   not   executed :    must   have   been \"  ,     2  ,    this . counterA . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchingBeanName"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Matching   bean   must    * not *    be   advised    ( proxied )  \"  ,     (  !  (  ( this . testFactoryBean 2  )    instanceof   Advised )  )  )  ;", "FactoryBean <  ?  >    fb    =     (  ( FactoryBean <  ?  >  )     ( ctx . getBean (  \"  & testFactoryBean 2  \"  )  )  )  ;", "assertTrue (  \" FactoryBean   itself   must   be   advised \"  ,     ( fb   instanceof   Advised )  )  ;", "assertTrue ( Map . class . isAssignableFrom ( fb . getObjectType (  )  )  )  ;", "assertTrue ( Map . class . isAssignableFrom ( fb . getObjectType (  )  )  )  ;", "assertEquals (  \" Advice   not   executed :    must   have   been \"  ,     2  ,    this . counterA . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchingFactoryBeanItself"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Matching   bean   must   be   advised    ( proxied )  \"  ,     (  ( this . testFactoryBean 1  )    instanceof   Advised )  )  ;", "assertEquals (  \" myValue \"  ,    this . testFactoryBean 1  . get (  \" myKey \"  )  )  ;", "assertEquals (  \" myValue \"  ,    this . testFactoryBean 1  . get (  \" myKey \"  )  )  ;", "assertEquals (  \" Advice   not   executed :    must   have   been \"  ,     2  ,    this . counterA . getCount (  )  )  ;", "FactoryBean <  ?  >    fb    =     (  ( FactoryBean <  ?  >  )     ( ctx . getBean (  \"  & testFactoryBean 1  \"  )  )  )  ;", "assertTrue (  \" FactoryBean   itself   must    * not *    be   advised \"  ,     (  !  ( fb   instanceof   Advised )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchingFactoryBeanObject"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" Non - matching   bean   must    * not *    be   advised    ( proxied )  \"  ,     (  ( this . testBean 2  )    instanceof   Advised )  )  ;", "this . testBean 2  . setAge (  2  0  )  ;", "assertEquals (  \" Advice   must    * not *    have   been   executed \"  ,     0  ,    this . counterA . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonMatchingBeanName"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" Non - matching   bean   must    * not *    be   advised    ( proxied )  \"  ,     (  ( this . testBeanContainingNestedBean . getDoctor (  )  )    instanceof   Advised )  )  ;", "}", "METHOD_END"], "methodName": ["testNonMatchingNestedBeanName"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Matching   bean   must   be   advised    ( proxied )  \"  ,     (  ( this . interceptThis )    instanceof   Advised )  )  ;", "assertFalse (  \" Non - matching   bean   must    * not *    be   advised    ( proxied )  \"  ,     (  ( this . dontInterceptThis )    instanceof   Advised )  )  ;", "interceptThis . setAge (  2  0  )  ;", "assertEquals (  1  ,    testInterceptor . interceptionCount )  ;", "dontInterceptThis . setAge (  2  0  )  ;", "assertEquals (  1  ,    testInterceptor . interceptionCount )  ;", "}", "METHOD_END"], "methodName": ["testPointcutAdvisorCombination"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutTests"}, {"methodBody": ["METHOD_START", "{", "return    \" before - advice - tests . xml \"  ;", "}", "METHOD_END"], "methodName": ["getConfigPath"], "fileName": "org.springframework.aop.aspectj.BeforeAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testBeanProxy    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( testBeanProxy )  )  ;", "testBeanTarget    =     (  ( TestBean )     (  (  ( Advised )     ( testBeanProxy )  )  . getTargetSource (  )  . getTarget (  )  )  )  ;", "Aspect   beforeAdviceAspect    =     (  ( Aspect )     ( ctx . getBean (  \" testAspect \"  )  )  )  ;", "mockCollaborator    =    mock ( Aspect . AdviceBindingCollaborator . class )  ;", "beforeAdviceAspect . setCollaborator ( mockCollaborator )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.BeforeAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . needsJoinPoint (  \" getAge \"  )  ;", "}", "METHOD_END"], "methodName": ["testNeedsJoinPoint"], "fileName": "org.springframework.aop.aspectj.BeforeAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . needsJoinPointStaticPart (  \" getAge \"  )  ;", "}", "METHOD_END"], "methodName": ["testNeedsJoinPointStaticPart"], "fileName": "org.springframework.aop.aspectj.BeforeAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  5  )  ;", "verify ( mockCollaborator )  . oneIntAndOneObject (  5  ,    this . testBeanTarget )  ;", "}", "METHOD_END"], "methodName": ["testOneIntAndOneObjectArgs"], "fileName": "org.springframework.aop.aspectj.BeforeAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . setAge (  5  )  ;", "verify ( mockCollaborator )  . oneIntArg (  5  )  ;", "}", "METHOD_END"], "methodName": ["testOneIntArg"], "fileName": "org.springframework.aop.aspectj.BeforeAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "testBeanProxy . getAge (  )  ;", "verify ( mockCollaborator )  . oneObjectArg ( this . testBeanProxy )  ;", "}", "METHOD_END"], "methodName": ["testOneObjectArgBoundToProxyUsingThis"], "fileName": "org.springframework.aop.aspectj.BeforeAdviceBindingTests"}, {"methodBody": ["METHOD_START", "{", "return   count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.aop.aspectj.CallCountingInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . count    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.aop.aspectj.CallCountingInterceptor"}, {"methodBody": ["METHOD_START", "{", "( count )  +  +  ;", "}", "METHOD_END"], "methodName": ["increment1ForAnonymousPointcut"], "fileName": "org.springframework.aop.aspectj.CounterAspect"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "=     (  ( TopsyTurvyAspect )     ( ctx . getBean (  \" topsyTurvyAspect \"  )  )  )  ;", "target    =     (  ( TopsyTurvyTarget )     ( ctx . getBean (  \" topsyTurvyTarget \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.DeclarationOrderIndependenceTests"}, {"methodBody": ["METHOD_START", "{", "AspectCollaborator   collab    =    new   AspectCollaborator (  )  ;", "this . setCollaborator ( collab )  ;", "this . target . getX (  )  ;", "assertTrue (  \" after   returning   advice   fired \"  ,    collab . afterReturningFired )  ;", "}", "METHOD_END"], "methodName": ["testAfterReturningFiringOk"], "fileName": "org.springframework.aop.aspectj.DeclarationOrderIndependenceTests"}, {"methodBody": ["METHOD_START", "{", "AspectCollaborator   collab    =    new   AspectCollaborator (  )  ;", "this . setCollaborator ( collab )  ;", "this . target . getX (  )  ;", "assertTrue (  \" around   advice   fired \"  ,    collab . aroundFired )  ;", "}", "METHOD_END"], "methodName": ["testAroundAdviceFiringOk"], "fileName": "org.springframework.aop.aspectj.DeclarationOrderIndependenceTests"}, {"methodBody": ["METHOD_START", "{", "AspectCollaborator   collab    =    new   AspectCollaborator (  )  ;", "this . setCollaborator ( collab )  ;", "this . target . doSomething (  )  ;", "assertTrue (  \" before   advice   fired \"  ,    collab . beforeFired )  ;", "}", "METHOD_END"], "methodName": ["testBeforeAdviceFiringOk"], "fileName": "org.springframework.aop.aspectj.DeclarationOrderIndependenceTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" target   bean   is   bean   name   aware \"  ,     (  ( this . target )    instanceof   BeanNameAware )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetIsBeanNameAware"], "fileName": "org.springframework.aop.aspectj.DeclarationOrderIndependenceTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" target   bean   is   serializable \"  ,     (  ( this . target )    instanceof   Serializable )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetIsSerializable"], "fileName": "org.springframework.aop.aspectj.DeclarationOrderIndependenceTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "noMethodsBean    =     (  ( NoMethodsBean )     ( ctx . getBean (  \" noMethodsBean \"  )  )  )  ;", "counter    =     (  ( Counter )     ( ctx . getBean (  \" counter \"  )  )  )  ;", "counter . reset (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.DeclareParentsDelegateRefTests"}, {"methodBody": ["METHOD_START", "{", "(  ( ICounter )     ( noMethodsBean )  )  . increment (  )  ;", "assertEquals (  \"  ' s   counter   should   be   updated \"  ,     1  ,    counter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionDelegation"], "fileName": "org.springframework.aop.aspectj.DeclareParentsDelegateRefTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Introduction   must   have   been   made \"  ,     (  ( noMethodsBean )    instanceof   ICounter )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionWasMade"], "fileName": "org.springframework.aop.aspectj.DeclareParentsDelegateRefTests"}, {"methodBody": ["METHOD_START", "{", "ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testBeanProxy    =     (  ( IBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( testBeanProxy )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.DeclareParentsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Introduction   must   have   been   made \"  ,     (  ( testBeanProxy )    instanceof   Lockable )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionWasMade"], "fileName": "org.springframework.aop.aspectj.DeclareParentsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "Obj   introductionObj    =    ctx . getBean (  \" introduction \"  )  ;", "assertFalse (  \" Introduction   should   not   be   proxied \"  ,    AopUtils . isAopProxy ( introductionObj )  )  ;", "Lockable   lockable    =     (  ( Lockable )     ( testBeanProxy )  )  ;", "assertFalse ( lockable . locked (  )  )  ;", "testBeanProxy . getAge (  )  ;", "testBeanProxy . setName (  \"  \"  )  ;", "lockable . lock (  )  ;", "try    {", "testBeanProxy . setName (  \"     \"  )  ;", "fail (  \" Should   be   locked \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLockingWorks"], "fileName": "org.springframework.aop.aspectj.DeclareParentsTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAspect"], "fileName": "org.springframework.aop.aspectj.ImplicitJPArgumentMatchingAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAspect"], "fileName": "org.springframework.aop.aspectj.ImplicitJPArgumentMatchingTests"}, {"methodBody": ["METHOD_START", "{", "( aroundExecutions )  +  +  ;", "return   pjp . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["around"], "fileName": "org.springframework.aop.aspectj.JoinPointMonitorAspect"}, {"methodBody": ["METHOD_START", "{", "( beforeExecutions )  +  +  ;", "}", "METHOD_END"], "methodName": ["before"], "fileName": "org.springframework.aop.aspectj.JoinPointMonitorAspect"}, {"methodBody": ["METHOD_START", "{", "return   counter ;", "}", "METHOD_END"], "methodName": ["getCounter"], "fileName": "org.springframework.aop.aspectj.JoinPointMonitorAspect"}, {"methodBody": ["METHOD_START", "{", "this . counter    =    counter ;", "}", "METHOD_END"], "methodName": ["setCounter"], "fileName": "org.springframework.aop.aspectj.JoinPointMonitorAspect"}, {"methodBody": ["METHOD_START", "{", "( aroundExecutions )  +  +  ;", "return   pjp . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["around"], "fileName": "org.springframework.aop.aspectj.JoinPointMonitorAtAspectJAspect"}, {"methodBody": ["METHOD_START", "{", "( beforeExecutions )  +  +  ;", "}", "METHOD_END"], "methodName": ["before"], "fileName": "org.springframework.aop.aspectj.JoinPointMonitorAtAspectJAspect"}, {"methodBody": ["METHOD_START", "{", "return   counter ;", "}", "METHOD_END"], "methodName": ["getCounter"], "fileName": "org.springframework.aop.aspectj.JoinPointMonitorAtAspectJAspect"}, {"methodBody": ["METHOD_START", "{", "this . counter    =    counter ;", "}", "METHOD_END"], "methodName": ["setCounter"], "fileName": "org.springframework.aop.aspectj.JoinPointMonitorAtAspectJAspect"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( x )  ;", "}", "METHOD_END"], "methodName": ["doBefore"], "fileName": "org.springframework.aop.aspectj.MyAspect"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( x )  ;", "}", "METHOD_END"], "methodName": ["doBefore"], "fileName": "org.springframework.aop.aspectj.MyAspect"}, {"methodBody": ["METHOD_START", "{", "if    ( mixin . locked (  )  )     {", "throw   new   IllegalSException (  \" locked \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNotLocked"], "fileName": "org.springframework.aop.aspectj.NonAnnotatedMakeLockable"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - ambiguous . xml \"  )  ,    getClass (  )  )  ;", "}    catch    ( BeanCreationException   ex )     {", "Throwable   cause    =    ex . getRootCause (  )  ;", "assertTrue (  \" Should   be   IllegalArgumentException \"  ,     ( cause   instanceof   IllegalArgumentException )  )  ;", "assertTrue (  \" Cannot   resolve   method    ' myBefore '    to   a   unique   method \"  ,     (  ( cause . getMessage (  )  . indexOf (  \" Cannot   resolve   method    ' myBefore '    to   a   unique   method \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExceptionOnConfigParsingWithAmbiguousAdviceMethod"], "fileName": "org.springframework.aop.aspectj.OverloadedAdviceTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleN (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "}    catch    ( BeanCreationException   ex )     {", "Throwable   cause    =    ex . getRootCause (  )  ;", "assertTrue (  \" Should   be   IllegalArgumentException \"  ,     ( cause   instanceof   IllegalArgumentException )  )  ;", "assertTrue (  \" invalidAbsoluteTypeN   should   be   detected   by   AJ \"  ,     (  ( cause . getMessage (  )  . indexOf (  \" invalidAbsoluteTypeN \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExceptionOnConfigParsingWithMismatchedAdviceMethod"], "fileName": "org.springframework.aop.aspectj.OverloadedAdviceTests"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . afterAdviceOne ( this . name )  ;", "}", "METHOD_END"], "methodName": ["afterAdviceOne"], "fileName": "org.springframework.aop.aspectj.PrecedenceTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . afterAdviceTwo ( this . name )  ;", "}", "METHOD_END"], "methodName": ["afterAdviceTwo"], "fileName": "org.springframework.aop.aspectj.PrecedenceTestAspect"}, {"methodBody": ["METHOD_START", "{", "int   ret    =     -  1  ;", "this . collaborator . aroundAdviceOne ( this . n )  ;", "try    {", "ret    =     (  ( Integer )     ( pjp . proceed (  )  )  )  . intValue (  )  ;", "}    catch    ( Throwable   t )     {", "throw   new   RuntimeException ( t )  ;", "}", "this . collaborator . aroundAdviceOne ( this . n )  ;", "return   ret ;", "}", "METHOD_END"], "methodName": ["aroundAdviceOne"], "fileName": "org.springframework.aop.aspectj.PrecedenceTestAspect"}, {"methodBody": ["METHOD_START", "{", "int   ret    =     -  1  ;", "this . collaborator . aroundAdviwo ( this . name )  ;", "try    {", "ret    =     (  ( Integer )     ( pjp . proceed (  )  )  )  . intValue (  )  ;", "}    catch    ( Throwable   t )     {", "throw   new   RuntimeException ( t )  ;", "}", "this . collaborator . aroundAdviwo ( this . name )  ;", "return   ret ;", "}", "METHOD_END"], "methodName": ["aroundAdviceTwo"], "fileName": "org.springframework.aop.aspectj.PrecedenceTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . beforeAdviceOne ( this . name )  ;", "}", "METHOD_END"], "methodName": ["beforeAdviceOne"], "fileName": "org.springframework.aop.aspectj.PrecedenceTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . beforeAdviceTwo ( this . name )  ;", "}", "METHOD_END"], "methodName": ["beforeAdviceTwo"], "fileName": "org.springframework.aop.aspectj.PrecedenceTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator    =    collaborator ;", "}", "METHOD_END"], "methodName": ["setCollaborator"], "fileName": "org.springframework.aop.aspectj.PrecedenceTestAspect"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.aop.aspectj.PrecedenceTestAspect"}, {"methodBody": ["METHOD_START", "{", "float   fv    =    value . floatValue (  )  ;", "return   pjp . p ( new   Object [  ]  {    new   Float (  ( fv    +     1  .  0 F )  )     }  )  ;", "}", "METHOD_END"], "methodName": ["addOne"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "return   pjp . proceed ( new   Object [  ]  {    value . toUpperCase (  )     }  )  ;", "}", "METHOD_END"], "methodName": ["capitalize"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "float   tjpArg    =     (  ( Float )     ( tjp . getArgs (  )  [  0  ]  )  )  . floatValue (  )  ;", "if    (  ( Math . abs (  ( tjpArg    -    arg )  )  )     >     1  .  0 E -  6  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" argument   is    '  \"     +    arg )     +     \"  '  ,     \"  )     +     \" but   args   array   has    '  \"  )     +    tjpArg )     +     \"  '  \"  )  )  ;", "}", "this . lastBeforeFloatValue    =    arg ;", "}", "METHOD_END"], "methodName": ["captureFloatArgument"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( tjp . getArgs (  )  [  0  ]  . equals ( arg )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" argument   is    '  \"     +    arg )     +     \"  '  ,     \"  )     +     \" but   args   array   has    '  \"  )     +     ( tjp . getArgs (  )  [  0  ]  )  )     +     \"  '  \"  )  )  ;", "}", "this . lastBeforeStValue    =    arg ;", "}", "METHOD_END"], "methodName": ["captureStringArgument"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( pjp . getArgs (  )  [  0  ]  . equals ( arg )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" argument   is    '  \"     +    arg )     +     \"  '  ,     \"  )     +     \" but   args   array   has    '  \"  )     +     ( pjp . getArgs (  )  [  0  ]  )  )     +     \"  '  \"  )  )  ;", "}", "this . lastAroundStringValue    =    arg ;", "return   pjp . p (  )  ;", "}", "METHOD_END"], "methodName": ["captureStringArgumentInAround"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "int   value    =     (  ( Integer )     ( pjp . getArgs (  )  [  0  ]  )  )  . intValue (  )  ;", "pjp . getArgs (  )  [  0  ]     =    new   Integer (  ( value    *     2  )  )  ;", "return   pjp . p (  )  ;", "}", "METHOD_END"], "methodName": ["doubleOrQuits"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "return   this . lastAroundStringValue ;", "}", "METHOD_END"], "methodName": ["getLastAroundStringValue"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "return   this . lastBeforeFloatValue ;", "}", "METHOD_END"], "methodName": ["getLastBeforeFloatValue"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "return   this . lastBeforeStringValue ;", "}", "METHOD_END"], "methodName": ["getLastBeforeStringValue"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.aop.aspectj.ProceedTestingAspect"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testBean    =     (  ( SimpleBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "firstTestAspect    =     (  ( ingAspect )     ( ctx . getBean (  \" firstTestAspect \"  )  )  )  ;", "secondTestAspect    =     (  ( ingAspect )     ( ctx . getBean (  \" secondTestAspect \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.ProceedTests"}, {"methodBody": ["METHOD_START", "{", "this . testBean . setAge (  5  )  ;", "assertEquals (  \" getArgs   is   defensive \"  ,     5  ,    this . testBean . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetArgsIsDefensive"], "fileName": "org.springframework.aop.aspectj.ProceedTests"}, {"methodBody": ["METHOD_START", "{", "this . testBean . setSex (  \" male \"  )  ;", "assertEquals (  \" value   changed   in   around   advice \"  ,     \" MALE \"  ,    this . testBean . getSex (  )  )  ;", "assertEquals (  \" changed   value   visible   to   next   before   advice   in   chain \"  ,     \" MALE \"  ,    this . secondTestA . getLastBeforeStringValue (  )  )  ;", "assertEquals (  \" changed   value   visible   to   next   around   advice   in   chain \"  ,     \" MALE \"  ,    this . secondTestA . getLastAroundStringValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProceedWithArgsAcrossAspects"], "fileName": "org.springframework.aop.aspectj.ProceedTests"}, {"methodBody": ["METHOD_START", "{", "this . testBean . setMyFloat (  1  .  0 F )  ;", "assertTrue (  \" value   changed   in   around   advice \"  ,     (  ( this . testBean . getMyFloat (  )  )     >     1  .  9 F )  )  ;", "assertTrue (  \" changed   value   visible   to   next   advice   in   chain \"  ,     (  ( this . firstTestA . getLastBeforeFloatValue (  )  )     >     1  .  9 F )  )  ;", "}", "METHOD_END"], "methodName": ["testProceedWithArgsInSameAspect"], "fileName": "org.springframework.aop.aspectj.ProceedTests"}, {"methodBody": ["METHOD_START", "{", "this . testBean . setName (  \" abc \"  )  ;", "assertEquals (  \" Name   changed   in   around   advice \"  ,     \" ABC \"  ,    this . testBean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleProceedWithChangedArgs"], "fileName": "org.springframework.aop.aspectj.ProceedTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext ( appContextFile ,    getClass (  )  )  ;", "ICounter   counter    =     (  ( ICounter )     ( context . getBean (  \" counter \"  )  )  )  ;", "assertTrue (  \" Proxy   didn ' t   get   created \"  ,     ( counter   instanceof   Advised )  )  ;", "counter . increment (  )  ;", "JoinPointMonitorAJAspect   callCountingAspect    =     (  ( JoinPointMonitorAJAspect )     ( context . getBean (  \" monitoringAspect \"  )  )  )  ;", "assertEquals (  \" Advise   didn ' t   get   executed \"  ,     1  ,    callCountingAspect . beforeExecutions )  ;", "assertEquals (  \" Advise   didn ' t   get   executed \"  ,     1  ,    callCountingAspect . aroundExecutions )  ;", "}", "METHOD_END"], "methodName": ["checkAtAspectJAspect"], "fileName": "org.springframework.aop.aspectj.PropertyDependentAspectTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext ( appContextFile ,    getClass (  )  )  ;", "ICounter   counter    =     (  ( ICounter )     ( context . getBean (  \" counter \"  )  )  )  ;", "assertTrue (  \" Proxy   didn ' t   get   created \"  ,     ( counter   instanceof   Advised )  )  ;", "counter . increment (  )  ;", "JoinPointMonitor   callCounting    =     (  ( JoinPointMonitor )     ( context . getBean (  \" monitoring \"  )  )  )  ;", "assertEquals (  \" Advise   didn ' t   get   executed \"  ,     1  ,    callCounting . beforeExecutions )  ;", "assertEquals (  \" Advise   didn ' t   get   executed \"  ,     1  ,    callCounting . aroundExecutions )  ;", "}", "METHOD_END"], "methodName": ["checkXmlAspect"], "fileName": "org.springframework.aop.aspectj.PropertyDependentAspectTests"}, {"methodBody": ["METHOD_START", "{", "checkXmlAspect (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyDependentAspectWithPropertyDeclaredAfterAdvice"], "fileName": "org.springframework.aop.aspectj.PropertyDependentAspectTests"}, {"methodBody": ["METHOD_START", "{", "checkXmlAspect (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - before . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyDependentAspectWithPropertyDeclaredBeforeAdvice"], "fileName": "org.springframework.aop.aspectj.PropertyDependentAspectTests"}, {"methodBody": ["METHOD_START", "{", "checkAtAspectJAspect (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - atAspectJ - after . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyDependentAtAspectJAspectWithPropertyDeclaredAfterAdvice"], "fileName": "org.springframework.aop.aspectj.PropertyDependentAspectTests"}, {"methodBody": ["METHOD_START", "{", "checkAtAspectJAspect (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - atAspectJ - before . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyDependentAtAspectJAspectWithPropertyDeclaredBeforeAdvice"], "fileName": "org.springframework.aop.aspectj.PropertyDependentAspectTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["authenticate"], "fileName": "org.springframework.aop.aspectj.SecurityManager"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "toBeAdvised    =     (  ( ToBeAdvised )     ( ctx . getBean (  \" toBeAdvised \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.SharedPointcutWithArgsMismatchTests"}, {"methodBody": ["METHOD_START", "{", "this . toBeAdvised . foo (  \" Hello \"  )  ;", "}", "METHOD_END"], "methodName": ["testMismatchedArgBinding"], "fileName": "org.springframework.aop.aspectj.SharedPointcutWithArgsMismatchTests"}, {"methodBody": ["METHOD_START", "{", "this . collaborator    =    collaborator ;", "}", "METHOD_END"], "methodName": ["setCollaborator"], "fileName": "org.springframework.aop.aspectj.SimpleSpringBeforeAdvice"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "nonSerializableBean    =     (  ( NonSerializableFoo )     ( ctx . getBean (  \" testClassA \"  )  )  )  ;", "serializableBean    =     (  ( SerializableFoo )     ( ctx . getBean (  \" testClassB \"  )  )  )  ;", "bar    =     (  ( Bar )     ( ctx . getBean (  \" testClassC \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.SubtypeSensitiveMatchingTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" bean   with   serializable   type   should   be   proxied \"  ,     (  ( this . serializableBean )    instanceof   Advised )  )  ;", "}", "METHOD_END"], "methodName": ["testBeansAreProxiedOnStaticMatch"], "fileName": "org.springframework.aop.aspectj.SubtypeSensitiveMatchingTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" bean   with   args   check   should   be   proxied \"  ,     (  ( this . bar )    instanceof   Advised )  )  ;", "}", "METHOD_END"], "methodName": ["testBeansThatDoNotMatchBasedOnOtherTestAreProxied"], "fileName": "org.springframework.aop.aspectj.SubtypeSensitiveMatchingTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" bean   with   non - serializable   type   should   not   be   proxied \"  ,     (  ( this . nonSerializableBean )    instanceof   Advised )  )  ;", "}", "METHOD_END"], "methodName": ["testBeansThatDoNotMatchBasedSolelyOnRuntimeTypeAreNotProxied"], "fileName": "org.springframework.aop.aspectj.SubtypeSensitiveMatchingTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testImpl 1     =     (  (  . TestInterface )     ( ctx . getBean (  \" testImpl 1  \"  )  )  )  ;", "testImpl 2     =     (  (  . TestInterface )     ( ctx . getBean (  \" testImpl 2  \"  )  )  )  ;", "testAspectForTestImpl 1     =     (  (  . TestAspect )     ( ctx . getBean (  \" testAspectForTestImpl 1  \"  )  )  )  ;", "testAspectForAbstractTestImpl    =     (  (  . TestAspect )     ( ctx . getBean (  \" testAspectForAbstractTestImpl \"  )  )  )  ;", "testInterceptor    =     (  (  . TestInterceptor )     ( ctx . getBean (  \" testInterceptor \"  )  )  )  ;", "testAspectForTestImpl 1  . count    =     0  ;", "testAspectForAbstractTestImpl . count    =     0  ;", "testInterceptor . count    =     0  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.TargetPointcutSelectionTests"}, {"methodBody": ["METHOD_START", "{", "testImpl 2  . interfaceMethod (  )  ;", "assertEquals (  \" Shouldn ' t   have   been   advised   by   POJO   advice   for   impl \"  ,     0  ,    testAForTestImpl 1  . count )  ;", "assertEquals (  \" Should   have   been   advised   by   POJO   advice   for   base   type \"  ,     1  ,    testAForAbstractTestImpl . count )  ;", "assertEquals (  \" Shouldn ' t   have   been   advised   by   advisor \"  ,     0  ,    testInterceptor . count )  ;", "}", "METHOD_END"], "methodName": ["targetNonSelectionForMismatchedType"], "fileName": "org.springframework.aop.aspectj.TargetPointcutSelectionTests"}, {"methodBody": ["METHOD_START", "{", "testImpl 1  . interfaceMethod (  )  ;", "assertEquals (  \" Should   have   been   advised   by   POJO   advice   for   impl \"  ,     1  ,    testAForTestImpl 1  . count )  ;", "assertEquals (  \" Should   have   been   advised   by   POJO   advice   for   base   type \"  ,     1  ,    testAForAbstractTestImpl . count )  ;", "assertEquals (  \" Should   have   been   advised   by   advisor \"  ,     1  ,    testInterceptor . count )  ;", "}", "METHOD_END"], "methodName": ["targetSelectionForMatchedType"], "fileName": "org.springframework.aop.aspectj.TargetPointcutSelectionTests"}, {"methodBody": ["METHOD_START", "{", "testAnnotatedMethodBean . doIt (  )  ;", "assertEquals (  1  ,    counter . atAnnotaMethodAnnotaCounter )  ;", "}", "METHOD_END"], "methodName": ["atAnnotationMethodAnnotationMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "testAnnotatedClassBean . doIt (  )  ;", "assertEquals (  1  ,    counter . atClassAnnotationCounter )  ;", "}", "METHOD_END"], "methodName": ["atTargetClassAnnotationMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testBean    =     (  (  . TestInterface )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "testAnnotatedClassBean    =     (  (  . TestInterface )     ( ctx . getBean (  \" testAnnotatedClassBean \"  )  )  )  ;", "testAnnotatedMethodBean    =     (  (  . TestInterface )     ( ctx . getBean (  \" testAnnotatedMethodBean \"  )  )  )  ;", "counter    =     (  (  . Counter )     ( ctx . getBean (  \" counter \"  )  )  )  ;", "counter . reset (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    counter . tAsClassCounter )  ;", "}", "METHOD_END"], "methodName": ["targetAsClassDoesMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    counter . tAsInterfaceCounter )  ;", "}", "METHOD_END"], "methodName": ["targetAsInterfaceMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  0  ,    counter . thisAsClasAsClassCounter )  ;", "}", "METHOD_END"], "methodName": ["thisAsClassAndTargetAsClassCounterNotMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  0  ,    counter . tsClassCounter )  ;", "}", "METHOD_END"], "methodName": ["thisAsClassDoesNotMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    counter . thisAsInterfaceAsInterfaceCounter )  ;", "}", "METHOD_END"], "methodName": ["thisAsInterfaceAndTargetAsClassCounterMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    counter . thisAsInterfaceAsInterfaceCounter )  ;", "}", "METHOD_END"], "methodName": ["thisAsInterfaceAndTargetAsInterfaceCounterMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    counter . tsInterfaceCounter )  ;", "}", "METHOD_END"], "methodName": ["thisAsInterfaceMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsAtAspectJTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "testBean    =     (  ( TestInterface )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "thisAsClassCounter    =     (  ( Counter )     ( ctx . getBean (  \" thisAsClassCounter \"  )  )  )  ;", "thisAsInterfaceCounter    =     (  ( Counter )     ( ctx . getBean (  \" thisAsInterfaceCounter \"  )  )  )  ;", "targetAsClassCounter    =     (  ( Counter )     ( ctx . getBean (  \" targetAsClassCounter \"  )  )  )  ;", "targetAsInterfaceCounter    =     (  ( Counter )     ( ctx . getBean (  \" targetAsInterfaceCounter \"  )  )  )  ;", "thisAsClasAsClassCounter    =     (  ( Counter )     ( ctx . getBean (  \" thisAsClasAsClassCounter \"  )  )  )  ;", "thisAsInterfaceAndTargetAsInterfaceCounter    =     (  ( Counter )     ( ctx . getBean (  \" thisAsInterfaceAndTargetAsInterfaceCounter \"  )  )  )  ;", "thisAsInterfaceAndTargetAsClassCounter    =     (  ( Counter )     ( ctx . getBean (  \" thisAsInterfaceAndTargetAsClassCounter \"  )  )  )  ;", "thisAsClassCounter . reset (  )  ;", "thisAsInterfaceCounter . reset (  )  ;", "targetAsClassCounter . reset (  )  ;", "targetAsInterfaceCounter . reset (  )  ;", "thisAsClasAsClassCounter . reset (  )  ;", "thisAsInterfaceAndTargetAsInterfaceCounter . reset (  )  ;", "thisAsInterfaceAndTargetAsClassCounter . reset (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    tAsClassCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetAsClassDoesMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    tAsInterfaceCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetAsInterfaceMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  0  ,    thisAsClasAsClassCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThisAsClassAndTargetAsClassCounterNotMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  0  ,    tsClassCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThisAsClassDoesNotMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    thisAsInterfaceAsInterfaceCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThisAsInterfaceAndTargetAsClassCounterMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    thisAsInterfaceAsInterfaceCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThisAsInterfaceAndTargetAsInterfaceCounterMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsTests"}, {"methodBody": ["METHOD_START", "{", "testBean . doIt (  )  ;", "assertEquals (  1  ,    tsInterfaceCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThisAsInterfaceMatch"], "fileName": "org.springframework.aop.aspectj.ThisAndTargetSelectionOnlyPointcutsTests"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( s )  ;", "}", "METHOD_END"], "methodName": ["foo"], "fileName": "org.springframework.aop.aspectj.ToBeAdvised"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . afterReturningAdviceFired (  )  ;", "}", "METHOD_END"], "methodName": ["afterReturning"], "fileName": "org.springframework.aop.aspectj.TopsyTurvyAspect"}, {"methodBody": ["METHOD_START", "{", "Object   ret    =    pjp . proceed (  )  ;", "this . collaborator . aroundAdviceFired (  )  ;", "return   ret ;", "}", "METHOD_END"], "methodName": ["around"], "fileName": "org.springframework.aop.aspectj.TopsyTurvyAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator . beforeAdviceFired (  )  ;", "}", "METHOD_END"], "methodName": ["before"], "fileName": "org.springframework.aop.aspectj.TopsyTurvyAspect"}, {"methodBody": ["METHOD_START", "{", "this . collaborator    =    collaborator ;", "}", "METHOD_END"], "methodName": ["setCollaborator"], "fileName": "org.springframework.aop.aspectj.TopsyTurvyAspect"}, {"methodBody": ["METHOD_START", "{", "this . lastEntry    =    jp . toString (  )  ;", "}", "METHOD_END"], "methodName": ["entryTrace"], "fileName": "org.springframework.aop.aspectj.autoproxy.AdviceUsingThisJoinPoint"}, {"methodBody": ["METHOD_START", "{", "return   this . lastEntry ;", "}", "METHOD_END"], "methodName": ["getLastMethodEntered"], "fileName": "org.springframework.aop.aspectj.autoproxy.AdviceUsingThisJoinPoint"}, {"methodBody": ["METHOD_START", "{", "return   testAnnotation . value (  )  ;", "}", "METHOD_END"], "methodName": ["doWithAnnotation"], "fileName": "org.springframework.aop.aspectj.autoproxy.AnnotationBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "testBean    =     (  ( edTestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.autoproxy.AnnotationBindingTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" this   value \"  ,    testBean . doThis (  )  )  ;", "assertEquals (  \" that   value \"  ,    testBean . doThat (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationBindingInAroundAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AnnotationBindingTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" doTheOther \"  ,    testBean . doTheOther (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoMatchingWithoutAnnotationPresent"], "fileName": "org.springframework.aop.aspectj.autoproxy.AnnotationBindingTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "testBean    =     (  ( edTestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.autoproxy.AnnotationPointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" this   value \"  ,    testBean . doThis (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationBindingInAroundAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AnnotationPointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" doTheOther \"  ,    testBean . doTheOther (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoMatchingWithoutAnnotationPresent"], "fileName": "org.springframework.aop.aspectj.autoproxy.AnnotationPointcutTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "ITestBean   testBean    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "An   interfaceExtendingAspect    =     (  ( An )     ( ctx . getBean (  \" interfaceExtendingAspect \"  )  )  )  ;", "assertTrue (  ( testBean   instanceof   Advised )  )  ;", "assertFalse (  ( interfaceExtendingAspect   instanceof   Advised )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyCreation"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectImplementingInterfaceTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "ITestBean   adrian    =     (  ( ITestBean )     ( ctx . getBean (  \" adrian \"  )  )  )  ;", "assertEquals (  0  ,    LazyTestBean . instantiations )  ;", "assertNotNull ( adrian )  ;", "adrian . getAge (  )  ;", "assertEquals (  6  8  ,    adrian . getAge (  )  )  ;", "assertEquals (  1  ,    LazyTestBean . instantiations )  ;", "}", "METHOD_END"], "methodName": ["testAdrian"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorAndLazyInitTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "long   totalTimeMillis    =    sw . getTotalTimeMillis (  )  ;", "assertTrue (  (  (  (  (  (  (  \"  '  \"     +     ( sw . getLastTaskName (  )  )  )     +     \"  '    took   too   long :    exed   less   than <  \"  )     +    maxTimeMillis )     +     \"  >    ms ,    actual <  \"  )     +    totalTimeMillis )     +     \"  >    ms .  \"  )  ,     ( totalTimeMillis    <    maxTimeMillis )  )  ;", "}", "METHOD_END"], "methodName": ["assertStopWatchTimeLimit"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "TestBeanAdvisor   tba    =     (  ( TestBeanAdvisor )     ( ac . getBean (  \" advisor \"  )  )  )  ;", "MultiplyReturnValue   mrv    =     (  ( MultiplyReturnValue )     ( ac . getBean (  \" aspect \"  )  )  )  ;", "assertEquals (  3  ,    mrv . getMultiple (  )  )  ;", "tba . count    =     0  ;", "mrv . invocations    =     0  ;", "assertTrue (  \" Aing   must   apply   from    @ AspectJ   aspect \"  ,    AopUtils . isAopProxy ( shouldBeWeaved )  )  ;", "assertEquals (  \" Adrian \"  ,    shouldBeWeaved . getName (  )  )  ;", "assertEquals (  0  ,    mrv . invocations )  ;", "assertEquals (  (  3  4     *     ( mrv . getMultiple (  )  )  )  ,    shouldBeWeaved . getAge (  )  )  ;", "assertEquals (  \" Spring   advisor   must   be   invoked \"  ,     2  ,    tba . count )  ;", "assertEquals (  \" Must   be   able   to   hold   state   in   aspect \"  ,     1  ,    mrv . invocations )  ;", "}", "METHOD_END"], "methodName": ["doTestAspectsAndAdvisorAreApplied"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathXmlApplicationContext ( qName ( fileSuffix )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["newContext"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \"  % s -  % s \"  ,    getClass (  )  . getSimpleName (  )  ,    fileSuffix )  ;", "}", "METHOD_END"], "methodName": ["qName"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" usesJoinPointAspect . xml \"  )  ;", "ITestBean   adrian 1     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "adrian 1  . getAge (  )  ;", "AdviceUsingThisJoinPoint   aspectInstance    =     (  ( AdviceUsingThisJoinPoint )     ( bf . getBean (  \" aspect \"  )  )  )  ;", "assertTrue (  (  ( aspectInstance . getLastMethodEntered (  )  . indexOf (  \" TestBean . getAge (  )  )  \"  )  )     !  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testAdviceUsingJoinPoint"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AopUtils . isAopProxy ( adrian )  )  ;", "adrian . setName (  \"  \"  )  ;", "assertEquals ( start ,    adrian . age (  )  )  ;", "int   newAge    =     3  2  ;", "adrian . setAge ( newAge )  ;", "assertEquals (  ( start    +    increment )  ,    adrian . age (  )  )  ;", "adrian . setAge (  0  )  ;", "assertEquals (  ( start    +     ( increment    *     2  )  )  ,    adrian . age (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAgeAspect"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "ClassPathXmlApplicationContext   ac    =    newContext (  \" aspectsPlusAdvisor . xml \"  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" Prototype   Creation \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  ;    i +  +  )     {", "ITestBean   shouldBeWeaved    =     (  ( ITestBean )     ( ac . getBean (  \" adrian 2  \"  )  )  )  ;", "if    ( i    <     1  0  )     {", "doTestAspectsAndAdvisorAreApplied ( ac ,    shouldBeWeaved )  ;", "}", "}", "sw . stop (  )  ;", "assertStopWatchTimeLimit ( sw ,     9  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testAspectsAndAdvisorAppliedToPrototypeIsFastEnough"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ac    =    newContext (  \" aspectsPlusAdvisor . xml \"  )  ;", "ITestBean   shouldBeWeaved    =     (  ( ITestBean )     ( ac . getBean (  \" adrian \"  )  )  )  ;", "doTestAspectsAndAdvisorAreApplied ( ac ,    shouldBeWeaved )  ;", "}", "METHOD_END"], "methodName": ["testAspectsAndAdvisorAreApplied"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ac    =    newContext (  \" aspectsPlusAdvisor . xml \"  )  ;", "GenericApplicationContext   childAc    =    new   GenericApplicationContext ( ac )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . getPropertyValues (  )  . addPropertyValue ( new   PropertyValue (  \" name \"  ,     \" Adrian \"  )  )  . addPropertyValue ( new   PropertyValue (  \" age \"  ,     3  4  )  )  ;", "childAc . registerBeanDefinition (  \" adrian 2  \"  ,    bd )  ;", "childAc . registerBeanDefinition ( AnnotationAware . class . getName (  )  ,    new   RootBeanDefinition ( AnnotationAware . class )  )  ;", "childAc . refresh (  )  ;", "ITestBean   beanFromChildContextThatShouldBeWeaved    =     (  ( ITestBean )     ( childAc . getBean (  \" adrian 2  \"  )  )  )  ;", "doTestAspectsAndAdvisorAreApplied ( childAc ,    beanFromChildContextThatShouldBeWeaved )  ;", "}", "METHOD_END"], "methodName": ["testAspectsAndAdvisorAreAppliedEvenIfComingFromParentFactory"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "new   XmlBeanDefinitionReader ( ac )  . loadBeanDefinitions ( new   ClassPathResource ( qName (  \" aspectsPlusAdvisor . xml \"  )  ,    getClass (  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  ;    i +  +  )     {", "ac . registerBeanDefinition (  (  \" singleton \"     +    i )  ,    new   RootBeanDefinition ( NestedTestBean . class )  )  ;", "}", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" Singleton   Creation \"  )  ;", "ac . refresh (  )  ;", "sw . stop (  )  ;", "assertStopWatchTimeLimit ( sw ,     8  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testAspectsAndAdvisorNotAppliedToManySingletonsIsFastEnough"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "ClassPathXmlApplicationContext   ac    =    newContext (  \" aspectsPlusAdvisor . xml \"  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" Prototype   Creation \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "INestedTestBean   shouldNotBeWeaved    =     (  ( INestedTestBean )     ( ac . getBean (  \" i 2  1  \"  )  )  )  ;", "if    ( i    <     1  0  )     {", "assertFalse ( AopUtils . isAopProxy ( shouldNotBeWeaved )  )  ;", "}", "}", "sw . stop (  )  ;", "assertStopWatchTimeLimit ( sw ,     6  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testAspectsAndAdvisorNotAppliedToPrototypeIsFastEnough"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" aspects . xml \"  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertEquals (  6  8  ,    tb . getAge (  )  )  ;", "MethodInvokingFactoryBean   factoryBean    =     (  ( MethodInvokingFactoryBean )     ( bf . getBean (  \"  & factoryBean \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( factoryBean . getTargetObject (  )  )  )  ;", "assertEquals (  6  8  ,     (  ( ITestBean )     ( factoryBean . getTargetObject (  )  )  )  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAspectsAreApplied"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" aspectsWithOrdering . xml \"  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertEquals (  7  1  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAspectsAreAppliedInDefinedOrder"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" aspectsWithCGLIB . xml \"  )  ;", "ProxyConfig   pc    =     (  ( ProxyConfig )     ( bf . getBean ( AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  )  )  ;", "assertTrue (  \" should   be   proxying   classes \"  ,    pc . isProxyTargetClass (  )  )  ;", "assertTrue (  \" should   expose   proxy \"  ,    pc . isExposeProxy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testForceProxyTargetClass"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" usesInclude . xml \"  )  ;", "ITestBean   adrian    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertTrue ( AopUtils . isAop ( adrian )  )  ;", "assertEquals (  6  8  ,    adrian . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIncludeMechanism"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" aspects . xml \"  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "tb . setAge (  1  0  )  ;", "assertEquals (  2  0  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleAspectsWithParameterApplied"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" pertarget . xml \"  )  ;", "ITestBean   adrian 1     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( adrian 1  )  )  ;", "int   explicitlySetAge    =     2  5  ;", "adrian 1  . setAge ( explicitlySetAge )  ;", "assertEquals (  \" Setter   does   not   initiate   advice \"  ,    explicitlySetAge ,    adrian 1  . getAge (  )  )  ;", "Metadata   am    =    new   Metadata ( PerTarget . class ,     \" someBean \"  )  ;", "assertTrue ( am . getPerClausePointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getSpouse \"  )  ,    null )  )  ;", "adrian 1  . getSpouse (  )  ;", "assertEquals (  \" Advice   has   now   been   instantiated \"  ,     0  ,    adrian 1  . getAge (  )  )  ;", "adrian 1  . setAge (  1  1  )  ;", "assertEquals (  \" Any   int   setter   increments \"  ,     2  ,    adrian 1  . getAge (  )  )  ;", "adrian 1  . setName (  \" Adrian \"  )  ;", "ITestBean   adrian 2     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertNotSame ( adrian 1  ,    adrian 2  )  ;", "assertTrue ( AopUtils . isAopProxy ( adrian 1  )  )  ;", "assertEquals (  3  4  ,    adrian 2  . getAge (  )  )  ;", "adrian 2  . getSpouse (  )  ;", "assertEquals (  \"    now   fired \"  ,     0  ,    adrian 2  . getAge (  )  )  ;", "assertEquals (  1  ,    adrian 2  . getAge (  )  )  ;", "assertEquals (  2  ,    adrian 2  . getAge (  )  )  ;", "assertEquals (  3  ,    adrian 1  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerTargetAspect"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" perthis . xml \"  )  ;", "ITestBean   adrian 1     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertTrue ( AopUtils . isAop ( adrian 1  )  )  ;", "assertEquals (  0  ,    adrian 1  . getAge (  )  )  ;", "assertEquals (  1  ,    adrian 1  . getAge (  )  )  ;", "ITestBean   adrian 2     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertNotSame ( adrian 1  ,    adrian 2  )  ;", "assertTrue ( AopUtils . isAop ( adrian 1  )  )  ;", "assertEquals (  0  ,    adrian 2  . getAge (  )  )  ;", "assertEquals (  1  ,    adrian 2  . getAge (  )  )  ;", "assertEquals (  2  ,    adrian 2  . getAge (  )  )  ;", "assertEquals (  3  ,    adrian 2  . getAge (  )  )  ;", "assertEquals (  2  ,    adrian 1  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerThisAspect"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" retryAspect . xml \"  )  ;", "UnreliableBean   bean    =     (  ( UnreliableBean )     ( bf . getBean (  \" unreliableBean \"  )  )  )  ;", "RetryAspect   aspect    =     (  ( RetryAspect )     ( bf . getBean (  \" retryAspect \"  )  )  )  ;", "int   attempts    =    bean . unreliable (  )  ;", "assertEquals (  2  ,    attempts )  ;", "assertEquals (  2  ,    aspect . getBeginCalls (  )  )  ;", "assertEquals (  1  ,    aspect . getRollbackCalls (  )  )  ;", "assertEquals (  1  ,    aspect . getCommitCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRetryAspect"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" twoAdviceAspect . xml \"  )  ;", "ITestBean   adrian 1     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "testAgeAspect ( adrian 1  ,     0  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testTwoAdviceAspect"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" twoAdviceAspectPrototype . xml \"  )  ;", "ITestBean   adrian 1     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "testAgeAspect ( adrian 1  ,     0  ,     1  )  ;", "ITestBean   adrian 2     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertNotSame ( adrian 1  ,    adrian 2  )  ;", "testAgeAspect ( adrian 2  ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testTwoAdviceAspectPrototype"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" twoAdviceAspectSingleton . xml \"  )  ;", "ITestBean   adrian 1     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "testAgeAspect ( adrian 1  ,     0  ,     1  )  ;", "ITestBean   adrian 2     =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertNotSame ( adrian 1  ,    adrian 2  )  ;", "testAgeAspect ( adrian 2  ,     2  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testTwoAdviceAspectSingleton"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" aspectsWithAbstractBean . xml \"  )  ;", "ITestBean   adrian    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( adrian )  )  ;", "assertEquals (  6  8  ,    adrian . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithAbstractFactoryBeanAreApplied"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    newContext (  \" withBeanNameAutoProxyCreator . xml \"  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertEquals (  6  8  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithBeanNameAutoProxyCreator"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "ITestBean   bean    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "ExceptionHandlingAspect       =     (  ( ExceptionHandlingAspect )     ( ctx . getBean (  \"  \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( bean )  )  ;", "try    {", "bean . unreliableFileOperation (  )  ;", "}    catch    ( IOException   e )     {", "}", "assertEquals (  1  ,     . handled )  ;", "assertNotNull (  . lastException )  ;", "}", "METHOD_END"], "methodName": ["testAccessThrowable"], "fileName": "org.springframework.aop.aspectj.autoproxy.AtAspectJAfterThrowingTests"}, {"methodBody": ["METHOD_START", "{", "String   annValue    =    testAnn . value (  )  ;", "Object   result    =    pjp . proceed (  )  ;", "return   result   instanceof   String    ?     ( annValue    +     \"     \"  )     +    result    :    result ;", "}", "METHOD_END"], "methodName": ["doWithAnnotation"], "fileName": "org.springframework.aop.aspectj.autoproxy.AtAspectJAnnotationBindingTestAspect"}, {"methodBody": ["METHOD_START", "{", "ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "testBean    =     (  ( edTestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.autoproxy.AtAspectJAnnotationBindingTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" this   value   doThis \"  ,    testBean . doThis (  )  )  ;", "assertEquals (  \" that   value   doThat \"  ,    testBean . doThat (  )  )  ;", "assertEquals (  2  ,    testBean . doArray (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationBindingInAroundAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AtAspectJAnnotationBindingTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" doTheOther \"  ,    testBean . doTheOther (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoMatchingWithoutAnnotationPresent"], "fileName": "org.springframework.aop.aspectj.autoproxy.AtAspectJAnnotationBindingTests"}, {"methodBody": ["METHOD_START", "{", "ctx . getBean (  \" arrayFactoryBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testPointcutEvaulatedAgainstArray"], "fileName": "org.springframework.aop.aspectj.autoproxy.AtAspectJAnnotationBindingTests"}, {"methodBody": ["METHOD_START", "{", "return   pjp . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.aop.aspectj.autoproxy.DummyAspect"}, {"methodBody": ["METHOD_START", "{", "return   pjp . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.aop.aspectj.autoproxy.DummyAspectWithParameter"}, {"methodBody": ["METHOD_START", "{", "( handled )  +  +  ;", "last    =    ex ;", "}", "METHOD_END"], "methodName": ["handleIOException"], "fileName": "org.springframework.aop.aspectj.autoproxy.ExceptionHandlingAspect"}, {"methodBody": ["METHOD_START", "{", "int   result    =     (  ( Integer )     ( pjp . proceed (  )  )  )  ;", "r   result    +     3  ;", "}", "METHOD_END"], "methodName": ["doubleReturnValue"], "fileName": "org.springframework.aop.aspectj.autoproxy.IncreaseReturnValue"}, {"methodBody": ["METHOD_START", "{", "pjp . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["increment"], "fileName": "org.springframework.aop.aspectj.autoproxy.InterfaceExtendingAspect"}, {"methodBody": ["METHOD_START", "{", "+  +  ( this . invocations )  ;", "int   result    =     (  ( Integer )     ( pjp . proceed (  )  )  )  ;", "return   result    *     ( this . me )  ;", "}", "METHOD_END"], "methodName": ["doubleReturnValue"], "fileName": "org.springframework.aop.aspectj.autoproxy.MultiplyReturnValue"}, {"methodBody": ["METHOD_START", "{", "return   this . multiple ;", "}", "METHOD_END"], "methodName": ["getMultiple"], "fileName": "org.springframework.aop.aspectj.autoproxy.MultiplyReturnValue"}, {"methodBody": ["METHOD_START", "{", "this . multiple    =    multiple ;", "}", "METHOD_END"], "methodName": ["setMultiple"], "fileName": "org.springframework.aop.aspectj.autoproxy.MultiplyReturnValue"}, {"methodBody": ["METHOD_START", "{", "+  +  ( this . invocations )  ;", "int   result    =     (  ( Integer )     ( pjp . proceed (  )  )  )  ;", "return   result    *     ( this . me )  ;", "}", "METHOD_END"], "methodName": ["doubleReturnValue"], "fileName": "org.springframework.aop.aspectj.autoproxy.MultiplyReturnValueForMarker"}, {"methodBody": ["METHOD_START", "{", "return   this . multiple ;", "}", "METHOD_END"], "methodName": ["getMultiple"], "fileName": "org.springframework.aop.aspectj.autoproxy.MultiplyReturnValueForMarker"}, {"methodBody": ["METHOD_START", "{", "this . multiple    =    multiple ;", "}", "METHOD_END"], "methodName": ["setMultiple"], "fileName": "org.springframework.aop.aspectj.autoproxy.MultiplyReturnValueForMarker"}, {"methodBody": ["METHOD_START", "{", "+  +  ( count )  ;", "}", "METHOD_END"], "methodName": ["countSetter"], "fileName": "org.springframework.aop.aspectj.autoproxy.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "return    ( count )  +  +  ;", "}", "METHOD_END"], "methodName": ["returnCountAsAge"], "fileName": "org.springframework.aop.aspectj.autoproxy.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.aop.aspectj.autoproxy.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "return   this . beginCalls ;", "}", "METHOD_END"], "methodName": ["getBeginCalls"], "fileName": "org.springframework.aop.aspectj.autoproxy.RetryAspect"}, {"methodBody": ["METHOD_START", "{", "return   this . commitCalls ;", "}", "METHOD_END"], "methodName": ["getCommitCalls"], "fileName": "org.springframework.aop.aspectj.autoproxy.RetryAspect"}, {"methodBody": ["METHOD_START", "{", "return   this . rollbackCalls ;", "}", "METHOD_END"], "methodName": ["getRollbackCalls"], "fileName": "org.springframework.aop.aspectj.autoproxy.RetryAspect"}, {"methodBody": ["METHOD_START", "{", "boolean   retry    =    true ;", "Object   o    =    null ;", "while    ( retry )     {", "try    {", "retry    =    false ;", "( this . beginCalls )  +  +  ;", "try    {", "o    =    jp . proceed (  )  ;", "( this . commitCalls )  +  +  ;", "}    catch    ( ableException   re )     {", "( this . rollbackCalls )  +  +  ;", "throw   re ;", "}", "}    catch    ( ableException   re )     {", "retry    =    true ;", "}", "}", "return   o ;", "}", "METHOD_END"], "methodName": ["retry"], "fileName": "org.springframework.aop.aspectj.autoproxy.RetryAspect"}, {"methodBody": ["METHOD_START", "{", "( this . calls )  +  +  ;", "if    (  (  ( this . calls )     %     2  )     !  =     0  )     {", "throw   new   RetryException (  \" foo \"  )  ;", "}", "return   this . calls ;", "}", "METHOD_END"], "methodName": ["unreliable"], "fileName": "org.springframework.aop.aspectj.autoproxy.UnreliableBean"}, {"methodBody": ["METHOD_START", "{", "return    1  0  ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    new   ClassPathXmlApplicationContext ( file ,    BenchmarkTests . CLASS )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  (  ( howmany    +     \"    repeated   after   returning   advice   invocations   with    \"  )     +    technology )  )  ;", "ITestBean   adrian    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( adrian )  )  ;", "Advised   a    =     (  ( Advised )     ( adrian )  )  ;", "assertTrue (  (  ( a . getAdvisors (  )  . length )     >  =     3  )  )  ;", "adrian . setAge (  2  5  )  ;", "for    ( int   i    =     0  ;    i    <    howmany ;    i +  +  )     {", "adrian . setAge ( i )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . prettyPrint (  )  )  ;", "return   sw . getLastTaskTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["testAfterReturningAdviceWithoutJoinPoint"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    new   ClassPathXmlApplicationContext ( file ,    BenchmarkTests . CLASS )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  (  ( howmany    +     \"    repeated   before   advice   invocations   with    \"  )     +    technology )  )  ;", "ITestBean   adrian    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( adrian )  )  ;", "Advised   a    =     (  ( Advised )     ( adrian )  )  ;", "assertTrue (  (  ( a . getAdvisors (  )  . length )     >  =     3  )  )  ;", "assertEquals (  \" adrian \"  ,    adrian . getName (  )  )  ;", "for    ( int   i    =     0  ;    i    <    howmany ;    i +  +  )     {", "adrian . getName (  )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . prettyPrint (  )  )  ;", "return   sw . getLastTaskTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["testBeforeAdviceWithoutJoinPoint"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    new   ClassPathXmlApplicationContext ( file ,    BenchmarkTests . CLASS )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  (  ( howmany    +     \"    repeated   mixed   invocations   with    \"  )     +    technology )  )  ;", "ITestBean   adrian    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( adrian )  )  ;", "Advised   a    =     (  ( Advised )     ( adrian )  )  ;", "assertTrue (  (  ( a . getAdvisors (  )  . length )     >  =     3  )  )  ;", "for    ( int   i    =     0  ;    i    <    howmany ;    i +  +  )     {", "adrian . getAge (  )  ;", "adrian . getName (  )  ;", "adrian . setAge ( i )  ;", "adrian . getDoctor (  )  ;", "adrian . getLawyer (  )  ;", "adrian . getSpouse (  )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . prettyPrint (  )  )  ;", "return   sw . getLastTaskTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["testMix"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "testAfterReturningAdviceWithoutJoinPoint ( BenchmarkTests . ASPECTJ _ CONTEXT ,    getCount (  )  ,     \" AspectJ \"  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedAfterReturningAdviceInvocationsWithAspectJ"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "testAfterReturningAdviceWithoutJoinPoint ( BenchmarkTests . SPRING _ AOP _ CONTEXT ,    getCount (  )  ,     \" Spring   AOP \"  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedAfterReturningAdviceInvocationsWithSpringAop"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    new   ClassPathXmlApplicationContext ( file ,    BenchmarkTests . CLASS )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  (  ( howmany    +     \"    repeated   around   advice   invocations   with    \"  )     +    technology )  )  ;", "ITestBean   adrian    =     (  ( ITestBean )     ( bf . getBean (  \" adrian \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( adrian )  )  ;", "assertEquals (  6  8  ,    adrian . getAge (  )  )  ;", "for    ( int   i    =     0  ;    i    <    howmany ;    i +  +  )     {", "adrian . getAge (  )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . prettyPrint (  )  )  ;", "return   sw . getLastTaskTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedAroundAdviceInvocations"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "testRepeatedAroundAdviceInvocations ( BenchmarkTests . ASPECTJ _ CONTEXT ,    getCount (  )  ,     \" AspectJ \"  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedAroundAdviceInvocationsWithAspectJ"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "testRepeatedAroundAdviceInvocations ( BenchmarkTests . SPRING _ AOP _ CONTEXT ,    getCount (  )  ,     \" Spring   AOP \"  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedAroundAdviceInvocationsWithSpringAop"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "testBeforeAdviceWithoutJoinPoint ( BenchmarkTests . ASPECTJ _ CONTEXT ,    getCount (  )  ,     \" AspectJ \"  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedBeforeAdviceInvocationsWithAspectJ"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "testBeforeAdviceWithoutJoinPoint ( BenchmarkTests . SPRING _ AOP _ CONTEXT ,    getCount (  )  ,     \" Spring   AOP \"  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedBeforeAdviceInvocationsWithSpringAop"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "testMix ( BenchmarkTests . ASPECTJ _ CONTEXT ,    getCount (  )  ,     \" AspectJ \"  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedMixWithAspectJ"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "testMix ( BenchmarkTests . SPRING _ AOP _ CONTEXT ,    getCount (  )  ,     \" Spring   AOP \"  )  ;", "}", "METHOD_END"], "methodName": ["testRepeatedMixWithSpringAop"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.BenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "return   this . multiple ;", "}", "METHOD_END"], "methodName": ["getMultiple"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.MultiplyReturnValueInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . multiple    =    multiple ;", "}", "METHOD_END"], "methodName": ["setMultiple"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.MultiplyReturnValueInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPointcutAdvisor ( new   StaticMethodMatcherPointcut (  )     {", "@ Override", "public   boolean   matches ( Method   method ,    Class <  ?  >    targetClass )     {", "return    (  ( method . getParameterCount (  )  )     =  =     1  )     &  &     ( method . getParameterTypes (  )  [  0  ]  . equals ( Integer . class )  )  ;", "}", "}  ,    new    (  )  )  ;", "}", "METHOD_END"], "methodName": ["advisor"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.TraceAfterReturningAdvice"}, {"methodBody": ["METHOD_START", "{", "+  +  ( beforeStringReturn )  ;", "}", "METHOD_END"], "methodName": ["traceWithoutJoinPoint"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.TraceAspect"}, {"methodBody": ["METHOD_START", "{", "+  +  ( afterTakesInt )  ;", "}", "METHOD_END"], "methodName": ["traceWithoutJoinPoint2"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.TraceAspect"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPointcutAdvisor ( new   StaticMethodMatcherPointcut (  )     {", "@ Override", "public   boolean   matches ( Method   method ,    Class <  ?  >    targetClass )     {", "return   method . getReturnType (  )  . equals ( String . class )  ;", "}", "}  ,    new    (  )  )  ;", "}", "METHOD_END"], "methodName": ["advisor"], "fileName": "org.springframework.aop.aspectj.autoproxy.benchmark.TraceBeforeAdvice"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  . xml \"  )  ,    getClass (  )  )  ;", "service    =     (  ( Service )     ( ctx . getBean (  \" service \"  )  )  )  ;", "try    {", "this . service . serveMe (  )  ;", "fail (  \" service   operation   has   not   been   advised   by   transaction   interceptor \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertEquals (  \" advice   invoked \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testServiceIsAdvised"], "fileName": "org.springframework.aop.aspectj.autoproxy.spr3064.SPR3064Tests"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" advice   invoked \"  )  ;", "}", "METHOD_END"], "methodName": ["around"], "fileName": "org.springframework.aop.aspectj.autoproxy.spr3064.TransactionInterceptor"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "counterAspect    =     (  ( CounterAspect )     ( ctx . getBean (  \" counterAspect \"  )  )  )  ;", "counterAspect . reset (  )  ;", "testBean    =     (  ( ReturnTypeVariationClass )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.generic.AfterReturningGenericTypeMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . getStrings (  )  ;", "assertEquals (  1  ,    counterA . getStringsInvocationsCount )  ;", "assertEquals (  0  ,    counterA . getIntegersInvocationsCount )  ;", "counterA . reset (  )  ;", "testBean . getIntegers (  )  ;", "assertEquals (  0  ,    counterA . getStringsInvocationsCount )  ;", "assertEquals (  1  ,    counterA . getIntegersInvocationsCount )  ;", "}", "METHOD_END"], "methodName": ["testReturnTypeExactMatching"], "fileName": "org.springframework.aop.aspectj.generic.AfterReturningGenericTypeMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . getTestBeans (  )  ;", "assertEquals (  1  ,    counterA . getTestBeanInvocationsCount )  ;", "counterA . reset (  )  ;", "testBean . getEmployees (  )  ;", "assertEquals (  0  ,    counterA . getTestBeanInvocationsCount )  ;", "}", "METHOD_END"], "methodName": ["testReturnTypeLowerBoundMatching"], "fileName": "org.springframework.aop.aspectj.generic.AfterReturningGenericTypeMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . getStrings (  )  ;", "assertEquals (  1  ,    counterA . getRawsInvocationsCount )  ;", "counterA . reset (  )  ;", "testBean . getIntegers (  )  ;", "assertEquals (  1  ,    counterA . getRawsInvocationsCount )  ;", "}", "METHOD_END"], "methodName": ["testReturnTypeRawMatching"], "fileName": "org.springframework.aop.aspectj.generic.AfterReturningGenericTypeMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . getIntegers (  )  ;", "assertEquals (  1  ,    counterA . getNumbersInvocationsCount )  ;", "}", "METHOD_END"], "methodName": ["testReturnTypeUpperBoundMatching"], "fileName": "org.springframework.aop.aspectj.generic.AfterReturningGenericTypeMatchingTests"}, {"methodBody": ["METHOD_START", "{", "( getIntegersInvocationsCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["incrementGetIntegersInvocationsCount"], "fileName": "org.springframework.aop.aspectj.generic.CounterAspect"}, {"methodBody": ["METHOD_START", "{", "( getNumbersInvocationsCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["incrementGetNumbersInvocationsCount"], "fileName": "org.springframework.aop.aspectj.generic.CounterAspect"}, {"methodBody": ["METHOD_START", "{", "( getRawsInvocationsCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["incrementGetRawsInvocationsCount"], "fileName": "org.springframework.aop.aspectj.generic.CounterAspect"}, {"methodBody": ["METHOD_START", "{", "( getStringsInvocationsCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["incrementGetStringsInvocationsCount"], "fileName": "org.springframework.aop.aspectj.generic.CounterAspect"}, {"methodBody": ["METHOD_START", "{", "( getTestBeanInvocationsCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["incrementTestBeanInvocationsCount"], "fileName": "org.springframework.aop.aspectj.generic.CounterAspect"}, {"methodBody": ["METHOD_START", "{", "getRawsInvocationsCount    =     0  ;", "getStringsInvocationsCount    =     0  ;", "getIntegersInvocationsCount    =     0  ;", "getNumbersInvocationsCount    =     0  ;", "getTestBeanInvocationsCount    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.aop.aspectj.generic.CounterAspect"}, {"methodBody": ["METHOD_START", "{", "(  ( DerivedStringParameterizedClass )     ( testBean )  )  . genericBaseInterfaceMethod (  \"  \"  )  ;", "assertEquals (  1  ,    counterAspect . count )  ;", "}", "METHOD_END"], "methodName": ["testGenericBaseInterfaceMethodThroughClass"], "fileName": "org.springframework.aop.aspectj.generic.GenericBridgeMethodMatchingClassProxyTests"}, {"methodBody": ["METHOD_START", "{", "(  ( DerivedStringParameterizedClass )     ( testBean )  )  . genericDerivedInterfaceMethod (  \"  \"  )  ;", "assertEquals (  1  ,    counterAspect . count )  ;", "}", "METHOD_END"], "methodName": ["testGenericDerivedInterfaceMethodThroughClass"], "fileName": "org.springframework.aop.aspectj.generic.GenericBridgeMethodMatchingClassProxyTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "counterAspect    =     (  ( CounterAspect )     ( ctx . getBean (  \" counterAspect \"  )  )  )  ;", "counterAspect . count    =     0  ;", "testBean    =     (  ( DerivedInterface < String >  )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.generic.GenericBridgeMethodMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . genericBaseInterfaceMethod (  \"  \"  )  ;", "assertEquals (  1  ,    counterAspect . count )  ;", "}", "METHOD_END"], "methodName": ["testGenericBaseInterfaceMethodThroughInterface"], "fileName": "org.springframework.aop.aspectj.generic.GenericBridgeMethodMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . genericDerivedInterfaceMethod (  \"  \"  )  ;", "assertEquals (  1  ,    counterAspect . count )  ;", "}", "METHOD_END"], "methodName": ["testGenericDerivedInterfaceMethodThroughInterface"], "fileName": "org.springframework.aop.aspectj.generic.GenericBridgeMethodMatchingTests"}, {"methodBody": ["METHOD_START", "{", "( count )  +  +  ;", "}", "METHOD_END"], "methodName": ["increment"], "fileName": "org.springframework.aop.aspectj.generic.GenericCounterAspect"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "counterAspect    =     (  (  . CounterAspect )     ( ctx . getBean (  \" counterAspect \"  )  )  )  ;", "counterAspect . reset (  )  ;", "testBean    =     (  (  . GenericInterface < String >  )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.generic.GenericParameterMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . save (  \"  \"  )  ;", "assertEquals (  1  ,    counterAspectInterfaceGenericArgExecutionCount )  ;", "}", "METHOD_END"], "methodName": ["testGenericInterfaceGenericArgExecution"], "fileName": "org.springframework.aop.aspectj.generic.GenericParameterMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . saveAll ( null )  ;", "assertEquals (  1  ,    counterAspectInterfaceGenericCollectionArgExecutionCount )  ;", "}", "METHOD_END"], "methodName": ["testGenericInterfaceGenericCollectionArgExecution"], "fileName": "org.springframework.aop.aspectj.generic.GenericParameterMatchingTests"}, {"methodBody": ["METHOD_START", "{", "testBean . saveAll ( null )  ;", "assertEquals (  1  ,    counterAspectInterfaceSubtypeGenericCollectionArgExecutionCount )  ;", "}", "METHOD_END"], "methodName": ["testGenericInterfaceSubtypeGenericCollectionArgExecution"], "fileName": "org.springframework.aop.aspectj.generic.GenericParameterMatchingTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  (  )  ;", "}", "METHOD_END"], "methodName": ["getEmployees"], "fileName": "org.springframework.aop.aspectj.generic.GenericReturnTypeVariationClass"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  (  )  ;", "}", "METHOD_END"], "methodName": ["getIntegers"], "fileName": "org.springframework.aop.aspectj.generic.GenericReturnTypeVariationClass"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  (  )  ;", "}", "METHOD_END"], "methodName": ["getStrings"], "fileName": "org.springframework.aop.aspectj.generic.GenericReturnTypeVariationClass"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  (  )  ;", "}", "METHOD_END"], "methodName": ["getTestBeans"], "fileName": "org.springframework.aop.aspectj.generic.GenericReturnTypeVariationClass"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - ok . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParsingOfAdviceTypes"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerAdviceTypeTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimple (  )  )     +     \"  - error . xml \"  )  ,    getClass (  )  )  ;", "fail (  \" Expected   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue ( ex . contains ( SAXParseException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParsingOfAdviceTypesWithError"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerAdviceTypeTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimple (  )  )     +     \"  - error . xml \"  )  ,    getClass (  )  )  ;", "fail (  \" Expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . contains ( IllegalArgumentException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testArgNamesError"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerArgNamesTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - ok . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testArgNamesOK"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerArgNamesTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   bean    =    getTestBean (  )  ;", "assertTrue (  \" Should   be   a   CGLIB   proxy \"  ,    AopUtils . isCglib ( bean )  )  ;", "assertTrue (  \" Should   expose   proxy \"  ,     (  ( Advised )     ( bean )  )  . isExpose (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsClassProxy"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerProxyTargetClassTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimple (  )  )     +     \"  - error . xml \"  )  ,    getClass (  )  )  ;", "fail (  \" Expected   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue ( ex . contains ( SAXParseException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParseReturningOnOtherAdviceType"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerReturningTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - ok . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReturningOnReturningAdvice"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerReturningTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ITestBean )     ( this . context . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTestBean"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "CountingBeforeAdvice   getAgeCounter    =     (  ( CountingBeforeAdvice )     ( this . context . getBean (  \" getAgeCounter \"  )  )  )  ;", "CountingBeforeAdvice   getNameCounter    =     (  ( CountingBeforeAdvice )     ( this . context . getBean (  \" getNameCounter \"  )  )  )  ;", "ITestBean   bean    =    getTestBean (  )  ;", "assertEquals (  \" Incorrect   initial   getAge   count \"  ,     0  ,    getAgeCounter . getCalls (  \" getAge \"  )  )  ;", "assertEquals (  \" Incorrect   initial   getName   count \"  ,     0  ,    getNameCounter . getCalls (  \" getName \"  )  )  ;", "bean . getAge (  )  ;", "assertEquals (  \" Incorrect   getAge   count   on   getAge   counter \"  ,     1  ,    getAgeCounter . getCalls (  \" getAge \"  )  )  ;", "assertEquals (  \" Incorrect   getAge   count   on   getName   counter \"  ,     0  ,    getNameCounter . getCalls (  \" getAge \"  )  )  ;", "bean . getName (  )  ;", "assertEquals (  \" Incorrect   getName   count   on   getName   counter \"  ,     1  ,    getNameCounter . getCalls (  \" getName \"  )  )  ;", "assertEquals (  \" Incorrect   getName   count   on   getAge   counter \"  ,     0  ,    getAgeCounter . getCalls (  \" getName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAdviceInvokedCorrectly"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   bean    =    getTestBean (  )  ;", "CountingAspectJAdvice   advice    =     (  ( CountingAspectJAdvice )     ( this . context . getBean (  \" countingAdvice \"  )  )  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     0  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     0  ,    advice . getAfterCount (  )  )  ;", "bean . setName (  \" Sally \"  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     1  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     1  ,    advice . getAfterCount (  )  )  ;", "bean . getName (  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     1  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     1  ,    advice . getAfterCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAspectApplied"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   bean    =     (  ( ITestBean )     ( this . context . getAutowireCapableBeanFactory (  )  . initializeBean ( new   TestBean (  )  ,     \"  \"  )  )  )  ;", "CountingAspectJAdvice   advice    =     (  ( CountingAspectJAdvice )     ( this . context . getBean (  \" countingAdvice \"  )  )  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     0  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     0  ,    advice . getAfterCount (  )  )  ;", "bean . setName (  \" Sally \"  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     1  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     1  ,    advice . getAfterCount (  )  )  ;", "bean . getName (  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     1  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     1  ,    advice . getAfterCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAspectAppliedForInitializeBeanWithEmptyName"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   bean    =     (  ( ITestBean )     ( this . context . getAutowireCapableBeanFactory (  )  . initializeBean ( new   TestBean (  )  ,    null )  )  )  ;", "CountingAspectJAdvice   advice    =     (  ( CountingAspectJAdvice )     ( this . context . getBean (  \" countingAdvice \"  )  )  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     0  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     0  ,    advice . getAfterCount (  )  )  ;", "bean . setName (  \" Sally \"  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     1  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     1  ,    advice . getAfterCount (  )  )  ;", "bean . getName (  )  ;", "assertEquals (  \" Incorrect   before   count \"  ,     1  ,    advice . getBeforeCount (  )  )  ;", "assertEquals (  \" Incorrect   after   count \"  ,     1  ,    advice . getAfterCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAspectAppliedForInitializeBeanWithNullName"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   bean    =    getTestBean (  )  ;", "assertTrue (  \" Bean   is   not   a   proxy \"  ,    AopUtils . isAopProxy ( bean )  )  ;", "Advised   advised    =     (  ( Advised )     ( bean )  )  ;", "Advisor [  ]    advisors    =    advised . getAdvisors (  )  ;", "assertTrue (  \" Advisors   should   not   be   empty \"  ,     (  ( advisors . length )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsProxy"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimple (  )  )     +     \"  - error . xml \"  )  ,    getClass (  )  )  ;", "fail (  \" Expected   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue ( ex . contains ( SAXParseException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParseThrowingOnOtherAdviceType"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerThrowingTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - ok . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThrowingOnThrowingAdvice"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerThrowingTests"}, {"methodBody": ["METHOD_START", "{", "return   this . afterCount ;", "}", "METHOD_END"], "methodName": ["getAfterCount"], "fileName": "org.springframework.aop.config.CountingAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   this . aroundCount ;", "}", "METHOD_END"], "methodName": ["getAroundCount"], "fileName": "org.springframework.aop.config.CountingAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   this . beforeCount ;", "}", "METHOD_END"], "methodName": ["getBeforeCount"], "fileName": "org.springframework.aop.config.CountingAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "( this . afterCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["myAfterAdvice"], "fileName": "org.springframework.aop.config.CountingAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "( this . afterCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["myAfterReturningAdvice"], "fileName": "org.springframework.aop.config.CountingAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "( this . afterCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["myAfterThrowingAdvice"], "fileName": "org.springframework.aop.config.CountingAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "( this . aroundCount )  +  +  ;", "pjp . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["myAroundAdvice"], "fileName": "org.springframework.aop.config.CountingAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "( this . beforeCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["myBeforeAdvice"], "fileName": "org.springframework.aop.config.CountingAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "factory    =    new   MethodLocatingFactoryBean (  )  ;", "beanFactory    =    mock ( BeanFactory . class )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Method . class ,    factory . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetObjectType"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( factory . isSingleton (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsSingleton"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "given ( beanFactory . getType ( MethodLocatingFactoryBeanTests . BEAN _ NAME )  )  . willReturn (  (  ( Class )     ( String . class )  )  )  ;", "factory . setTargetBeanName ( MethodLocatingFactoryBeanTests . BEAN _ NAME )  ;", "factory . setMethodName (  \" toString (  )  \"  )  ;", "factory . setBeanFactory ( beanFactory )  ;", "Object   result    =    factory . getObject (  )  ;", "assertNotNull ( result )  ;", "assertTrue (  ( result   instanceof   Method )  )  ;", "Method   method    =     (  ( Method )     ( result )  )  ;", "assertEquals (  \" Bingo \"  ,    method . invoke (  \" Bingo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayPath"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factory . setTargetBeanName ( MethodLocatingFactoryBeanTests . BEAN _ NAME )  ;", "factory . setMethodName (  \" toString (  )  \"  )  ;", "factory . setBeanFactory ( beanFactory )  ;", "verify ( beanFactory )  . getType ( MethodLocatingFactoryBeanTests . BEAN _ NAME )  ;", "}", "METHOD_END"], "methodName": ["testWhenTargetBeanClassCannotBeResolved"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "given ( beanFactory . getType ( MethodLocatingFactoryBeanTests . BEAN _ NAME )  )  . willReturn (  (  ( Class )     ( String . class )  )  )  ;", "factory . setTargetBeanName ( MethodLocatingFactoryBeanTests . BEAN _ NAME )  ;", "factory . setMethodName (  \" loadOfOld (  )  \"  )  ;", "factory . setBeanFactory ( beanFactory )  ;", "}", "METHOD_END"], "methodName": ["testWhereMethodCannotBeResolved"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factory . setTargetBeanName (  \"  \"  )  ;", "factory . setMethodName (  \" toString (  )  \"  )  ;", "factory . setBean ( bean )  ;", "}", "METHOD_END"], "methodName": ["testWithEmptyTargetBeanName"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factory . setTargetBeanName ( MethodLocatingFactoryBeanTests . BEAN _ NAME )  ;", "factory . setMethodName (  \"  \"  )  ;", "factory . setBeanFactory ( beanFactory )  ;", "}", "METHOD_END"], "methodName": ["testWithEmptyTargetMethodName"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factory . setMethodName (  \" toString (  )  \"  )  ;", "factory . setBean ( bean )  ;", "}", "METHOD_END"], "methodName": ["testWithNullTargetBeanName"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factory . setTargetBeanName ( MethodLocatingFactoryBeanTests . BEAN _ NAME )  ;", "factory . setBeanFactory ( beanFactory )  ;", "}", "METHOD_END"], "methodName": ["testWithNullTargetMethodName"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInjectionBeforeWrappingCheckDoesNotKickInForPrototypeProxy"], "fileName": "org.springframework.aop.config.PrototypeProxyTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ExposeInvocationInterceptor . currentInvocation (  )  ;", "fail (  \" Expected   no   invocation   context \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["assertNoInvocationContext"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["requiresTarget"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "mockTargetSource . reset (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "mockTargetSource . verify (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "MyThrowsHandler   th    =    new   MyThrowsHandler (  )  ;", "Echo   target    =    new   Echo (  )  ;", "target . setA (  1  6  )  ;", "Factory   pf    =    new   Factory ( target )  ;", "pf . addAdvice ( new   NopInterceptor (  )  )  ;", "pf . addAdvice ( th )  ;", "IEcho   proxied    =     (  ( IEcho )     ( create ( pf )  )  )  ;", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "assertEquals ( target . getA (  )  ,    proxied . getA (  )  )  ;", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "Exception   ex    =    new   Exception (  )  ;", "try    {", "proxied . echoException (  1  ,    ex )  ;", "fail (  )  ;", "}    catch    ( Exception   caught )     {", "assertEquals ( ex ,    caught )  ;", "}", "ex    =    new   MarshalException (  \"  \"  )  ;", "try    {", "proxied . echoException (  1  ,    ex )  ;", "fail (  )  ;", "}    catch    ( MarshalException   caught )     {", "assertEquals ( ex ,    caught )  ;", "}", "assertEquals (  1  ,    th . getCalls (  \" remoteException \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddThrowsAdviceWithoutAdvisor"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "String   name    =     \" tony \"  ;", "tb . setName ( name )  ;", "Factory   pc    =    new   Factory ( tb )  ;", "NopInterceptor   di    =    new   NopInterceptor (  )  ;", "pc . addAdvice ( di )  ;", "final   long   ts    =     3  7  ;", "pc . addAdvice ( new   DelegatingIntroductionInterceptor ( new   TimeStamped (  )     {", "@ Override", "public   long   getTimeStamp (  )     {", "return   ts ;", "}", "}  )  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( create ( pc )  )  )  ;", "assertEquals ( name ,    proxied . getName (  )  )  ;", "TimeStamped   intro    =     (  ( TimeStamped )     ( proxied )  )  ;", "assertEquals ( ts ,    intro . getTimeStamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAdviceImplementsIntroductionInfo"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "AbstractAopProxyTests . CountingAdvisorListener   l    =    new   AbstractAopProxyTests . CountingAdvisorListener ( pc )  ;", "pc . addListener ( l )  ;", "AbstractAopProxyTests . RefreshCountingAdvisorChainFactory   acf    =    new   AbstractAopProxyTests . RefreshCountingAdvisorChainFactory (  )  ;", "pc . addListener ( acf )  ;", "assertFalse ( pc . isActive (  )  )  ;", "assertEquals (  0  ,    l . activates )  ;", "assertEquals (  0  ,    acf . refreshes )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "assertEquals (  1  ,    acf . refreshes )  ;", "assertEquals (  1  ,    l . activates )  ;", "assertTrue ( pc . isActive (  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "assertEquals (  0  ,    l . adviceChanges )  ;", "NopInterceptor   di    =    new   NopInterceptor (  )  ;", "pc . addAdvice (  0  ,    di )  ;", "assertEquals (  1  ,    l . adviceChanges )  ;", "assertEquals (  2  ,    acf . refreshes )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "pc . removeAdvice ( di )  ;", "assertEquals (  2  ,    l . adviceChanges )  ;", "assertEquals (  3  ,    acf . refreshes )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "pc . getProxy (  )  ;", "assertEquals (  1  ,    l . activates )  ;", "pc . removeListener ( l )  ;", "assertEquals (  2  ,    l . adviceChanges )  ;", "pc . addAdvisor ( new   support . DefaultPointcutAdvisor ( new   NopInterceptor (  )  )  )  ;", "assertEquals (  2  ,    l . adviceChanges )  ;", "}", "METHOD_END"], "methodName": ["testAdviceSupportListeners"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "class   SummingAfterAdvice   implements   AfterReturningAdvice    {", "public   int   sum ;", "@ Override", "public   void   afterReturning (  @ Nullable", "Object   returnValue ,    Method   m ,    Object [  ]    args ,     @ Nullable", "Object   target )    throws   Throwable    {", "sum    +  =     (  ( Integer )     ( returnValue )  )  . intValue (  )  ;", "}", "}", "SummingAfterAdvice   aa    =    new   SummingAfterAdvice (  )  ;", "@ SuppressWarnings (  \" serial \"  )", "Advisor   matchesInt    =    new   StaticMethodMatcherPointcutAdvisor ( aa )     {", "@ Override", "public   boolean   matches ( Method   m ,     @ Nullable", "Class <  ?  >    targetClass )     {", "return    ( m . getReturnType (  )  )     =  =     ( int . class )  ;", "}", "}  ;", "TestBean   target    =    new   TestBean (  )  ;", "Factory   pf    =    new   Factory ( target )  ;", "pf . addAdvice ( new   NopInterceptor (  )  )  ;", "pf . addAdvisor ( matchesInt )  ;", "assertEquals (  \" Advisor   was   added \"  ,    matchesInt ,    pf . getAdvisors (  )  [  1  ]  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( create ( pf )  )  )  ;", "assertEquals (  0  ,    aa . sum )  ;", "int   i 1     =     1  2  ;", "int   i 2     =     1  3  ;", "proxied . setAge ( i 1  )  ;", "assertEquals ( i 1  ,    proxied . getAge (  )  )  ;", "assertEquals ( i 1  ,    aa . sum )  ;", "proxied . setAge ( i 2  )  ;", "assertEquals ( i 2  ,    proxied . getAge (  )  )  ;", "assertEquals (  ( i 1     +    i 2  )  ,    aa . sum )  ;", "assertEquals ( i 2  ,    proxied . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAfterReturningAdvisorIsInvoked"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "CountingAfterReturningAdvice   car    =    new   CountingAfterReturningAdvice (  )  ;", "TestBean   target    =    new   TestBean (  )  ;", "Factory   pf    =    new   Factory ( target )  ;", "pf . addAdvice ( new   NopInterceptor (  )  )  ;", "pf . addAdvice ( car )  ;", "assertEquals (  \" Advice   was   wrapped   in   Advisor   and   added \"  ,    car ,    pf . getAdvisors (  )  [  1  ]  . getAdvice (  )  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( create ( pf )  )  )  ;", "assertEquals (  0  ,    car . getCalls (  )  )  ;", "int   age    =     1  0  ;", "proxied . setAge ( age )  ;", "assertEquals ( age ,    proxied . getAge (  )  )  ;", "assertEquals (  2  ,    car . getCalls (  )  )  ;", "Exception   exc    =    new   Exception (  )  ;", "try    {", "proxied . exceptional ( exc )  ;", "fail (  )  ;", "}    catch    ( Throwable   t )     {", "assertSame ( exc ,    t )  ;", "}", "assertEquals (  2  ,    car . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAfterReturningAdvisorIsNotInvokedOnException"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeException   rex    =    new   RuntimeException (  )  ;", "@ SuppressWarnings (  \" serial \"  )", "CountingBeforeAdvice   ba    =    new   CountingBeforeAdvice (  )     {", "@ Override", "public   void   before ( Method   m ,    Object [  ]    args ,    Object   target )    throws   Throwable    {", "super . before ( m ,    args ,    target )  ;", "if    ( m . getName (  )  . startsWith (  \" set \"  )  )", "throw   rex ;", "}", "}  ;", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  8  0  )  ;", "NopInterceptor   nop 1     =    new   NopInterceptor (  )  ;", "NopInterceptor   nop 2     =    new   NopInterceptor (  )  ;", "Factory   pf    =    new   Factory ( target )  ;", "pf . addAdvice ( nop 1  )  ;", "pf . addAdvice ( ba )  ;", "pf . addAdvice ( nop 2  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( create ( pf )  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,    ba . getCalls (  )  )  ;", "assertEquals (  1  ,    ba . getCalls (  \" getAge \"  )  )  ;", "assertEquals (  1  ,    nop 1  . getCount (  )  )  ;", "assertEquals (  1  ,    nop 2  . getCount (  )  )  ;", "try    {", "proxied . setAge (  2  6  )  ;", "fail (  \" before   advice   should   have   ended   chain \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertEquals ( rex ,    ex )  ;", "}", "assertEquals (  2  ,    ba . getCalls (  )  )  ;", "assertEquals (  2  ,    nop 1  . getCount (  )  )  ;", "assertEquals (  1  ,    nop 2  . getCount (  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeforeAdviceThrowsException"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "CountingBeforeAdvice   cba    =    new   CountingBeforeAdvice (  )  ;", "@ SuppressWarnings (  \" serial \"  )", "Advisor   matchesNoArgs    =    new   StaticMethodMatcherPointcutAdvisor ( cba )     {", "@ Override", "public   boolean   matches ( Method   m ,     @ Nullable", "Class <  ?  >    targetClass )     {", "return    ( m . getParameterCount (  )  )     =  =     0  ;", "}", "}  ;", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  8  0  )  ;", "Factory   pf    =    new   Factory ( target )  ;", "pf . addAdvice ( new   NopInterceptor (  )  )  ;", "pf . addAdvisor ( matchesNoArgs )  ;", "assertEquals (  \" Advisor   was   added \"  ,    matchesNoArgs ,    pf . getAdvisors (  )  [  1  ]  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( create ( pf )  )  )  ;", "assertEquals (  0  ,    cba . getCalls (  )  )  ;", "assertEquals (  0  ,    cba . getCalls (  \" getAge \"  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "assertEquals (  1  ,    cba . getCalls (  \" getAge \"  )  )  ;", "assertEquals (  0  ,    cba . getCalls (  \" setAge \"  )  )  ;", "proxied . setAge (  2  6  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "assertEquals (  2  6  ,    proxied . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeforeAdvisorIsInvoked"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Factory   pc    =    new   Factory ( tb )  ;", "NopInterceptor   di    =    new   NopInterceptor (  )  ;", "pc . addAdvice (  0  ,    di )  ;", "ITestBean   t    =     (  ( ITestBean )     ( create ( pc )  )  )  ;", "assertEquals (  0  ,    di . getCount (  )  )  ;", "t . setAge (  2  3  )  ;", "assertEquals (  2  3  ,    t . getAge (  )  )  ;", "assertEquals (  2  ,    di . getCount (  )  )  ;", "Advised   advised    =     (  ( Advised )     ( t )  )  ;", "assertEquals (  \" Have    1    advisor \"  ,     1  ,    advised . getAdvisors (  )  . length )  ;", "assertEquals ( di ,    advised . getAdvisors (  )  [  0  ]  . getAdvice (  )  )  ;", "NopInterceptor   di 2     =    new   NopInterceptor (  )  ;", "advised . addAdvice (  1  ,    di 2  )  ;", "t . getName (  )  ;", "assertEquals (  3  ,    di . getCount (  )  )  ;", "assertEquals (  1  ,    di 2  . getCount (  )  )  ;", "advised . removeAdvisor (  0  )  ;", "t . getAge (  )  ;", "assertEquals (  3  ,    di . getCount (  )  )  ;", "assertEquals (  2  ,    di 2  . getCount (  )  )  ;", "CountingBeforeAdvice   cba    =    new   CountingBeforeAdvice (  )  ;", "assertEquals (  0  ,    cba . getCalls (  )  )  ;", "advised . addAdvice ( cba )  ;", "t . setAge (  1  6  )  ;", "assertEquals (  1  6  ,    t . getAge (  )  )  ;", "assertEquals (  2  ,    cba . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanCastProxyToProxyConfig"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( tb )  ;", "pc . addInterface ( ITestBean . class )  ;", "MethodInterceptor   nameReverter    =    new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   mi )    throws   Throwable    {", "MethodInvocation   clone    =     (  ( ReflectiveMethodInvocation )     ( mi )  )  . invocableClone (  )  ;", "String   oldName    =     (  ( ITestBean )     ( mi . getThis (  )  )  )  . getName (  )  ;", "clone . getArguments (  )  [  0  ]     =    oldName ;", "mi . proceed (  )  ;", "return   clone . proceed (  )  ;", "}", "}  ;", "class   NameSaver   implements   MethodInterceptor    {", "private   List < Object >    names    =    new   LinkedList <  >  (  )  ;", "@ Override", "public   Object   invoke ( MethodInvocation   mi )    throws   Throwable    {", "names . add ( mi . getArguments (  )  [  0  ]  )  ;", "return   mi . proceed (  )  ;", "}", "}", "NameSaver   saver    =    new   NameSaver (  )  ;", "pc . addAdvisor ( new   support . DefaultPointcutAdvisor ( Pointcuts . SETTERS ,    nameReverter )  )  ;", "pc . addAdvisor ( new   support . DefaultPointcutAdvisor ( Pointcuts . SETTERS ,    saver )  )  ;", "ITestBean   it    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "String   name 1     =     \" tony \"  ;", "String   name 2     =     \" gordon \"  ;", "tb . setName ( name 1  )  ;", "assertEquals ( name 1  ,    tb . getName (  )  )  ;", "it . setName ( name 2  )  ;", "assertEquals ( name 1  ,    it . getName (  )  )  ;", "assertEquals (  2  ,    saver . names . size (  )  )  ;", "assertEquals ( name 2  ,    saver . names . get (  0  )  )  ;", "assertEquals ( name 1  ,    saver . names . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanChangeArgumentsIndependentlyOnClonedInvocation"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "pc . setInterfaces ( ITestBean . class )  ;", "pc . addAdvice ( new   NopInterceptor (  )  )  ;", "CountingBeforeAdvice   mba    =    new   CountingBeforeAdvice (  )  ;", "Advisor   advisor    =    new   support . DefaultPointcutAdvisor ( new   NameMatchMethodPointcut (  )  . addMethodName (  \" setAge \"  )  ,    mba )  ;", "pc . addAdvisor ( advisor )  ;", "assertFalse (  \" Opaque   defaults   to   false \"  ,    pc . isOpaque (  )  )  ;", "pc . setOpaque ( true )  ;", "assertTrue (  \" Opaque   now   true   for   this   config \"  ,    pc . isOpaque (  )  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "proxied . setAge (  1  0  )  ;", "assertEquals (  1  0  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,    mba . getCalls (  )  )  ;", "assertFalse (  \" Cannot   be   cast   to   Advised \"  ,     ( proxied   instanceof   Advised )  )  ;", "}", "METHOD_END"], "methodName": ["testCanPreventCastToAdvisedUsingOpaque"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "assertFalse ( pc . isFrozen (  )  )  ;", "pc . addAdvice ( new   NopInterceptor (  )  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "pc . setFrozen ( true )  ;", "Advised   advised    =     (  ( Advised )     ( proxied )  )  ;", "assertTrue ( pc . isFrozen (  )  )  ;", "try    {", "advised . addAdvisor ( new   support . DefaultPointcutAdvisor ( new   NopInterceptor (  )  )  )  ;", "fail (  \" Shouldn ' t   be   able   to   add   Advisor   when   frozen \"  )  ;", "}    catch    ( AopConfigException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" frozen \"  )  )  ;", "}", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,    advised . getAdvisors (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testCannotAddAdvisorWhenFrozenUsingCast"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "try    {", "pc . addAdvice ( new    . DummyIntroductionAdviceImpl (  )  )  ;", "fail (  \" Shouldn ' t   be   able   to   add   introduction   interceptor   except   via   introduction   advice \"  )  ;", "}    catch    ( AopConfigException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" ntroduction \"  )  )     >     (  -  1  )  )  )  ;", "}", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCannotAddDynamicIntroductionAdviceExceptInIntroductionAdvice"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "Factory   pc    =    new   Factory ( target )  ;", "assertFalse ( pc . isFrozen (  )  )  ;", "pc . addAdvice ( new   NopInterceptor (  )  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( create ( pc )  )  )  ;", "pc . setFrozen ( true )  ;", "try    {", "pc . addAdvice (  0  ,    new   NopInterceptor (  )  )  ;", "fail (  \" Shouldn ' t   be   able   to   add   interceptor   when   frozen \"  )  ;", "}    catch    ( AopConfigException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" frozen \"  )  )     >     (  -  1  )  )  )  ;", "}", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,     (  ( Advised )     ( proxied )  )  . getAdvisors (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testCannotAddInterceptorWhenFrozen"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "try    {", "pc . addAdvisor (  0  ,    new   support . DefaultIntroductionAdvisor ( new   TimestampIntroductionInterceptor (  )  ,    TestBean . class )  )  ;", "fail (  \" Shouldn ' t   be   able   to   add   introduction   advice   that   introduces   a   class ,    rather   than   an   interface \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" interface \"  )  )  ;", "}", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCannotAddIntroductionAdviceToIntroduceClass"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "try    {", "pc . addAdvisor (  0  ,    new   support . DefaultIntroductionAdvisor ( new   TimestampIntroductionInterceptor (  )  ,    ITestBean . class )  )  ;", "fail (  \" Shouldn ' t   be   able   to   add   introduction   advice   introducing   an   unimplemented   interface \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCannotAddIntroductionAdviceWithUnimplementedInterface"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "Factory   pc    =    new   Factory ( target )  ;", "assertFalse ( pc . isFrozen (  )  )  ;", "pc . addAdvice ( new   NopInterceptor (  )  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( create ( pc )  )  )  ;", "pc . setFrozen ( true )  ;", "Advised   advised    =     (  ( Advised )     ( proxied )  )  ;", "assertTrue ( pc . isFrozen (  )  )  ;", "try    {", "advised . removeAdvisor (  0  )  ;", "fail (  \" Shouldn ' t   be   able   to   remove   Advisor   when   frozen \"  )  ;", "}    catch    ( AopConfigException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" frozen \"  )  )  ;", "}", "assertEquals (  1  ,    advised . getAdvisors (  )  . length )  ;", "pc . setFrozen ( false )  ;", "advised . removeAdvisor (  0  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "assertEquals (  0  ,    advised . getAdvisors (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testCannotRemoveAdvisorWhenFrozen"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Factory   pc    =    new   Factory ( tb )  ;", "pc . addInterface ( ITestBean . class )  ;", "MethodInterceptor   twoBirthdayInterceptor    =    new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   mi )    throws   Throwable    {", "MethodInvocation   clone 1     =     (  ( ReflectiveMethodInvocation )     ( mi )  )  . invocableClone (  )  ;", "MethodInvocation   clone 2     =     (  ( ReflectiveMethodInvocation )     ( mi )  )  . invocableClone (  )  ;", "clone 1  . proceed (  )  ;", "clone 2  . proceed (  )  ;", "return   mi . proceed (  )  ;", "}", "}  ;", "@ SuppressWarnings (  \" serial \"  )", "StaticMethodMatcherPointcutAdvisor   advisor    =    new   StaticMethodMatcherPointcutAdvisor ( twoBirthdayInterceptor )     {", "@ Override", "public   boolean   matches ( Method   m ,     @ Nullable", "Class <  ?  >    targetClass )     {", "return    \" haveBirthday \"  . equals ( m . getName (  )  )  ;", "}", "}  ;", "pc . addAdvisor ( advisor )  ;", "ITestBean   it    =     (  ( ITestBean )     ( create ( pc )  )  )  ;", "final   int   age    =     2  0  ;", "it . setAge ( age )  ;", "assertEquals ( age ,    it . getAge (  )  )  ;", "assertEquals (  ( age    +     2  )  ,    it . haveBirthday (  )  )  ;", "assertEquals (  ( age    +     3  )  ,    it . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCloneInvocationToProceedThreeTimes"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "testContext ( true )  ;", "}", "METHOD_END"], "methodName": ["testContext"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =     \" foo \"  ;", "MethodInterceptor   mi    =    new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "if    (  ! context )     {", "assertNoInvocationContext (  )  ;", "} else    {", "assertNotNull (  \" have   context \"  ,    ExposeInvocationInterceptor . currentInvocation (  )  )  ;", "}", "return   s ;", "}", "}  ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "if    ( context )     {", "pc . addAdvice ( INSTANCE )  ;", "}", "pc . addAdvice ( mi )  ;", "if    ( requiresTarget (  )  )     {", "pc . setTarget ( new   TestBean (  )  )  ;", "}", "aop    =    create ( pc )  ;", "assertNoInvocationContext (  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( aop . getProxy (  )  )  )  ;", "assertNoInvocationContext (  )  ;", "assertSame (  \" correct   return   value \"  ,    s ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testContext"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   Exception   expectedException    =    new   Exception (  )  ;", "MethodInterceptor   mi    =    new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "throw   expectedException ;", "}", "}  ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "pc . addAdvice ( INSTANCE )  ;", "pc . addAdvice ( mi )  ;", "mockTargetSource . setTarget ( new   TestBean (  )  )  ;", "pc . setTargetSource ( mockTargetSource )  ;", "aop    =    create ( pc )  ;", "try    {", "ITestBean   tb    =     (  ( ITestBean )     ( aop . getProxy (  )  )  )  ;", "tb . exceptional ( expectedException )  ;", "fail (  \" Should   have   thrown   exception   raised   by   interceptor \"  )  ;", "}    catch    ( Exception   thrown )     {", "assertEquals (  \" exception   matches \"  ,    expectedException ,    thrown )  ;", "}", "}", "METHOD_END"], "methodName": ["testDeclaredException"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "ProxyFactory   pc    =    new   ProxyFactory (  )  ;", "pc . addInterface ( ITestBean . class )  ;", ". TestDynamicPointcutAdvice   dp    =    new    . TestDynamicPointcutAdvice ( new   NopInterceptor (  )  ,     \" getAge \"  )  ;", "pc . addAdvisor ( dp )  ;", "pc . setTarget ( tb )  ;", "ITestBean   it    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "assertEquals (  0  ,    dp . count )  ;", "it . getAge (  )  ;", "assertEquals (  1  ,    dp . count )  ;", "it . setAge (  1  1  )  ;", "assertEquals (  1  1  ,    it . getAge (  )  )  ;", "assertEquals (  2  ,    dp . count )  ;", "}", "METHOD_END"], "methodName": ["testDynamicMethodPointcutThatAlwaysAppliesStatically"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "ProxyFactory   pc    =    new   ProxyFactory (  )  ;", "pc . addInterface ( ITestBean . class )  ;", ". TestDynamicPointcutForSettersOnly   dp    =    new    . TestDynamicPointcutForSettersOnly ( new   NopInterceptor (  )  ,     \" Age \"  )  ;", "pc . addAdvisor ( dp )  ;", "this . mockTargetSource . setTarget ( tb )  ;", "pc . setTargetSource ( mockTargetSource )  ;", "ITestBean   it    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "assertEquals (  0  ,    dp . count )  ;", "it . getAge (  )  ;", "assertEquals (  0  ,    dp . count )  ;", "it . setAge (  1  1  )  ;", "assertEquals (  1  1  ,    it . getAge (  )  )  ;", "assertEquals (  1  ,    dp . count )  ;", "it . setName (  \" joe \"  )  ;", "assertEquals (  1  ,    dp . count )  ;", "}", "METHOD_END"], "methodName": ["testDynamicMethodPointcutThatAppliesStaticallyOnlyToSetters"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "IOther   a    =    new   AbstractAopProxyTests . AllInstancesAreEqual (  )  ;", "IOther   b    =    new   AbstractAopProxyTests . AllInstancesAreEqual (  )  ;", "NopInterceptor   i 1     =    new   NopInterceptor (  )  ;", "NopInterceptor   i 2     =    new   NopInterceptor (  )  ;", "ProxyFactory   pfa    =    new   ProxyFactory ( a )  ;", "pfa . addAdvice ( i 1  )  ;", "ProxyFactory   pfb    =    new   ProxyFactory ( b )  ;", "pfb . addAdvice ( i 2  )  ;", "IOther   proxyA    =     (  ( IOther )     ( createProxy ( pfa )  )  )  ;", "IOther   proxyB    =     (  ( IOther )     ( createProxy ( pfb )  )  )  ;", "assertEquals ( pfa . getAdvisors (  )  . length ,    pfb . getAdvisors (  )  . length )  ;", "assertEquals ( a ,    b )  ;", "assertEquals ( i 1  ,    i 2  )  ;", "assertEquals ( proxyA ,    proxyB )  ;", "assertEquals ( proxyA . hashCode (  )  ,    proxyB . hashCode (  )  )  ;", "assertFalse ( proxyA . equals ( a )  )  ;", "assertEquals (  0  ,    i 1  . getCount (  )  )  ;", "proxyA . absquatulate (  )  ;", "assertEquals (  1  ,    i 1  . getCount (  )  )  ;", "assertFalse ( proxyA . equals ( proxyB )  )  ;", "}", "METHOD_END"], "methodName": ["testEquals"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb 1     =    new   TestBean (  )  ;", "tb 1  . setAge (  3  3  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "tb 2  . setAge (  2  6  )  ;", "tb 2  . setName (  \" Juergen \"  )  ;", "TestBean   tb 3     =    new   TestBean (  )  ;", "tb 3  . setAge (  3  7  )  ;", "Factory   pc    =    new   Factory ( tb 1  )  ;", "NopInterceptor   nop    =    new   NopInterceptor (  )  ;", "pc . addAdvice ( nop )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( create ( pc )  )  )  ;", "assertEquals ( nop . getCount (  )  ,     0  )  ;", "assertEquals ( tb 1  . getAge (  )  ,    proxy . getAge (  )  )  ;", "assertEquals ( nop . getCount (  )  ,     1  )  ;", "pc . setTarget ( tb 2  )  ;", "assertEquals ( tb 2  . getAge (  )  ,    proxy . getAge (  )  )  ;", "assertEquals ( nop . getCount (  )  ,     2  )  ;", "HotSwappableTargetSource   hts    =    new   HotSwappableTargetSource ( tb 3  )  ;", "pc . setTargetSource ( hts )  ;", "assertEquals ( tb 3  . getAge (  )  ,    proxy . getAge (  )  )  ;", "assertEquals ( nop . getCount (  )  ,     3  )  ;", "hts . swap ( tb 1  )  ;", "assertEquals ( tb 1  . getAge (  )  ,    proxy . getAge (  )  )  ;", "tb 1  . setName (  \" Colin \"  )  ;", "assertEquals ( tb 1  . getName (  )  ,    proxy . getName (  )  )  ;", "assertEquals ( nop . getCount (  )  ,     5  )  ;", "Advised   advised    =     (  ( Advised )     ( proxy )  )  ;", "assertSame ( hts ,    advised . getTargetSource (  )  )  ;", "SingletonTargetSource   sts    =    new   SingletonTargetSource ( tb 2  )  ;", "advised . setTargetSource ( sts )  ;", "assertEquals ( tb 2  . getName (  )  ,    proxy . getName (  )  )  ;", "assertSame ( sts ,    advised . getTargetSource (  )  )  ;", "assertEquals ( tb 2  . getAge (  )  ,    proxy . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExistingProxyChangesTarget"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "Factory   pc    =    new   Factory ( target )  ;", "@ SuppressWarnings (  \" serial \"  )", "class   MyDi   extends   DelegatingIntroductionInterceptor   implements   TimeStamped    {", "@ Override", "public   long   getTimeStamp (  )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}", "pc . addAdvisor ( new   DefaultIntroductionAdvisor ( new   MyDi (  )  )  )  ;", "TimeStamped   ts    =     (  ( TimeStamped )     ( create ( pc )  )  )  ;", "try    {", "ts . getTimeStamp (  )  ;", "fail (  \" Should   throw   UnsupportedOperationException \"  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testIntroductionThrowsUncheckedException"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "int   howMany    =     1  0  0  0  0  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  (  (  \" Create    \"     +    howMany )     +     \"    proxies \"  )  )  ;", "testManyProxies ( howMany )  ;", "sw . stop (  )  ;", "assertTrue (  \"    creation   was   too   slow \"  ,     (  ( sw . getTotalTimeMillis (  )  )     <     5  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testManyProxies"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "int   age 1     =     3  3  ;", "TestBean   target 1     =    new   TestBean (  )  ;", "target 1  . setAge ( age 1  )  ;", "ProxyFactory   pf 1     =    new   ProxyFactory ( target 1  )  ;", "pf 1  . addAdvice ( new   NopInterceptor (  )  )  ;", "pf 1  . addAdvice ( new   NopInterceptor (  )  )  ;", "ITestBean [  ]    proxies    =    new   ITestBean [ howMany ]  ;", "for    ( int   i    =     0  ;    i    <    howMany ;    i +  +  )     {", "proxies [ i ]     =     (  ( ITestBean )     ( create ( pf 1  )  . getProxy (  )  )  )  ;", "assertEquals ( age 1  ,    proxies [ i ]  . getAge (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testManyProxies"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Factory   pc    =    new   Factory (  )  ;", "pc . addInterface ( ITestBean . class )  ;", "pc . addAdvisor ( new   LockMixinAdvisor (  )  )  ;", "pc . setTarget ( tb )  ;", "testTestBeanIntroduction ( pc )  ;", "}", "METHOD_END"], "methodName": ["testMixinWithIntroductionAdvisor"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Factory   pc    =    new   Factory (  )  ;", "pc . addInterface ( ITestBean . class )  ;", "pc . addAdvice ( new   LockMixin (  )  )  ;", "pc . setTarget ( tb )  ;", "testTestBeanIntroduction ( pc )  ;", "}", "METHOD_END"], "methodName": ["testMixinWithIntroductionInfo"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "AbstractAopProxyTests . CountingMultiAdvice   cca    =    new   AbstractAopProxyTests . CountingMultiAdvice (  )  ;", "@ SuppressWarnings (  \" serial \"  )", "Advisor   matchesNoArgs    =    new   StaticMethodMatcherPointcutAdvisor ( cca )     {", "@ Override", "public   boolean   matches ( Method   m ,     @ Nullable", "Class <  ?  >    targetClass )     {", "return    (  ( m . getParameterCount (  )  )     =  =     0  )     |  |     (  \" exceptional \"  . equals ( m . getName (  )  )  )  ;", "}", "}  ;", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  8  0  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "pf . addAdvice ( new   NopInterceptor (  )  )  ;", "pf . addAdvisor ( matchesNoArgs )  ;", "assertEquals (  \" Advisor   was   added \"  ,    matchesNoArgs ,    pf . getAdvisors (  )  [  1  ]  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pf )  )  )  ;", "assertEquals (  0  ,    cca . getCalls (  )  )  ;", "assertEquals (  0  ,    cca . getCalls (  \" getAge \"  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "assertEquals (  2  ,    cca . getCalls (  )  )  ;", "assertEquals (  2  ,    cca . getCalls (  \" getAge \"  )  )  ;", "assertEquals (  0  ,    cca . getCalls (  \" setAge \"  )  )  ;", "proxied . setAge (  2  6  )  ;", "assertEquals (  2  ,    cca . getCalls (  )  )  ;", "assertEquals (  2  6  ,    proxied . getAge (  )  )  ;", "assertEquals (  4  ,    cca . getCalls (  )  )  ;", "try    {", "proxied . exceptional ( new   AbstractAopProxyTests . SpecializedUncheckedException (  \" foo \"  ,     (  ( SQLException )     ( null )  )  )  )  ;", "fail (  \" Should   have   thrown   CannotGetJdbcConnectionException \"  )  ;", "}    catch    ( AbstractAopProxyTests . SpecializedUncheckedException   ex )     {", "}", "assertEquals (  6  ,    cca . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiAdvice"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "testContext ( false )  ;", "}", "METHOD_END"], "methodName": ["testNoContext"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "aop    =    create ( pc )  ;", "aop . getProxy (  )  ;", "}", "METHOD_END"], "methodName": ["testNoInterceptorsAndNoTarget"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "int   age 1     =     3  3  ;", "int   age 2     =     3  7  ;", "TestBean   target 1     =    new   TestBean (  )  ;", "ProxyFactory   pf 1     =    new   ProxyFactory ( target 1  )  ;", "pf 1  . setExposeProxy ( true )  ;", "NopInterceptor   di 1     =    new   NopInterceptor (  )  ;", "pf 1  . addAdvice (  0  ,    di 1  )  ;", "pf 1  . addAdvice (  1  ,    new    . ProxyMatcherInterceptor (  )  )  ;", "pf 1  . addAdvice (  2  ,    new    . CheckMethodInvocationIsSameInAndOutInterceptor (  )  )  ;", "pf 1  . addAdvice (  1  ,    new    . CheckMethodInvocationViaThreadLocalIsSameInAndOutInterceptor (  )  )  ;", "pf 1  . addAdvice (  0  ,    INSTANCE )  ;", "ITestBean   advised 1     =     (  ( ITestBean )     ( pf 1  . getProxy (  )  )  )  ;", "advised 1  . setAge ( age 1  )  ;", "TestBean   target 2     =    new   TestBean (  )  ;", "ProxyFactory   pf 2     =    new   ProxyFactory ( target 2  )  ;", "pf 2  . setExposeProxy ( true )  ;", "NopInterceptor   di 2     =    new   NopInterceptor (  )  ;", "pf 2  . addAdvice (  0  ,    di 2  )  ;", "pf 2  . addAdvice (  1  ,    new    . ProxyMatcherInterceptor (  )  )  ;", "pf 2  . addAdvice (  2  ,    new    . CheckMethodInvocationIsSameInAndOutInterceptor (  )  )  ;", "pf 2  . addAdvice (  1  ,    new    . CheckMethodInvocationViaThreadLocalIsSameInAndOutInterceptor (  )  )  ;", "pf 2  . addAdvice (  0  ,    INSTANCE )  ;", "ITestBean   advised 2     =     (  ( ITestBean )     ( createProxy ( pf 2  )  )  )  ;", "advised 2  . setAge ( age 2  )  ;", "advised 1  . setSpouse ( advised 2  )  ;", "assertEquals (  \" Advised   one   has   correct   age \"  ,    age 1  ,    advised 1  . getAge (  )  )  ;", "assertEquals (  \" Advised   two   has   correct   age \"  ,    age 2  ,    advised 2  . getAge (  )  )  ;", "assertEquals (  \" Advised   one   spouse   has   correct   age \"  ,    age 2  ,    advised 1  . getSpouse (  )  . getAge (  )  )  ;", "assertEquals (  \" one   was   invoked   correct   number   of   times \"  ,     4  ,    di 1  . getCount (  )  )  ;", "assertEquals (  \" one   was   invoked   correct   number   of   times \"  ,     3  ,    di 2  . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOneAdvisedObjectCallsAnother"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "AbstractAopProxyTests . Overloads   target    =    new   AbstractAopProxyTests . Overloads (  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "NopInterceptor   overLoadVoids    =    new   NopInterceptor (  )  ;", "pc . addAdvisor ( new   StaticMethodMatcherPointcutAdvisor ( overLoadVoids )     {", "@ Override", "public   boolean   matches ( Method   m ,     @ Nullable", "Class <  ?  >    targetClass )     {", "return    ( m . getName (  )  . equals (  \" overload \"  )  )     &  &     (  ( m . getParameterCount (  )  )     =  =     0  )  ;", "}", "}  )  ;", "NopInterceptor   overLoadInts    =    new   NopInterceptor (  )  ;", "pc . addAdvisor ( new   StaticMethodMatcherPointcutAdvisor ( overLoadInts )     {", "@ Override", "public   boolean   matches ( Method   m ,     @ Nullable", "Class <  ?  >    targetClass )     {", "return    (  ( m . getName (  )  . equals (  \" overload \"  )  )     &  &     (  ( m . getParameterCount (  )  )     =  =     1  )  )     &  &     ( m . getParameterTypes (  )  [  0  ]  . equals ( int . class )  )  ;", "}", "}  )  ;", "AbstractAopProxyTests . IOverloads   proxy    =     (  ( AbstractAopProxyTests . IOverloads )     ( createProxy ( pc )  )  )  ;", "assertEquals (  0  ,    overLoadInts . getCount (  )  )  ;", "assertEquals (  0  ,    overLoadVoids . getCount (  )  )  ;", "proxy . overload (  )  ;", "assertEquals (  0  ,    overLoadInts . getCount (  )  )  ;", "assertEquals (  1  ,    overLoadVoids . getCount (  )  )  ;", "assertEquals (  2  5  ,    proxy . overload (  2  5  )  )  ;", "assertEquals (  1  ,    overLoadInts . getCount (  )  )  ;", "assertEquals (  1  ,    overLoadVoids . getCount (  )  )  ;", "proxy . noAdvice (  )  ;", "assertEquals (  1  ,    overLoadInts . getCount (  )  )  ;", "assertEquals (  1  ,    overLoadVoids . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOverloadedMethodsWithDifferentAdvice"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "pc . setInterfaces ( ITestBean . class )  ;", "pc . addAdvice ( new   NopInterceptor (  )  )  ;", "MethodBeforeAdvice   mba    =    new   CountingBeforeAdvice (  )  ;", "Advisor   advisor    =    new   support . DefaultPointcutAdvisor ( new   NameMatchMethodPointcut (  )  ,    mba )  ;", "pc . addAdvisor ( advisor )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "String   proxyConfigString    =     (  ( Advised )     ( proxied )  )  . toProxyConfigString (  )  ;", "assertTrue ( proxyConfigString . contains ( advisor . toString (  )  )  )  ;", "assertTrue ( proxyConfigString . contains (  \"  1    interface \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyConfigString"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   TestBean   target    =    new   TestBean (  )  ;", "Factory   pf    =    new   Factory ( target )  ;", "pf . addAdvice ( new   DebugInterceptor (  )  )  ;", "pf . setExpose ( true )  ;", "final   ITestBean   proxy    =     (  ( ITestBean )     ( create ( pf )  )  )  ;", "Advised   config    =     (  ( Advised )     ( proxy )  )  ;", "config . setTargetSource ( new   TargetSource (  )     {", "@ Override", "public   Class <  ?  >    getTargetClass (  )     {", "return   TestBean . class ;", "}", "@ Override", "public   boolean   isStatic (  )     {", "return   false ;", "}", "@ Override", "public   Object   getTarget (  )    throws   Exception    {", "assertEquals ( proxy ,    AopContext . current (  )  )  ;", "return   target ;", "}", "@ Override", "public   void   releaseTarget ( Object   target )    throws   Exception    {", "}", "}  )  ;", "assertEquals (  0  ,    proxy . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyIsBoundBeforeTargetSourceInvoked"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "int   age 1     =     3  3  ;", "TestBean   target 1     =    new   TestBean (  )  ;", "Factory   pf 1     =    new   Factory ( target 1  )  ;", "NopInterceptor   di 1     =    new   NopInterceptor (  )  ;", "pf 1  . addAdvice (  0  ,    di 1  )  ;", "ITestBean   advised 1     =     (  ( ITestBean )     ( create ( pf 1  )  )  )  ;", "advised 1  . setAge ( age 1  )  ;", "advised 1  . setSpouse ( advised 1  )  ;", "assertEquals (  \" one   was   invoked   correct   number   of   times \"  ,     2  ,    di 1  . getCount (  )  )  ;", "assertEquals (  \" Advised   one   has   correct   age \"  ,    age 1  ,    advised 1  . getAge (  )  )  ;", "assertEquals (  \" one   was   invoked   correct   number   of   times \"  ,     3  ,    di 1  . getCount (  )  )  ;", "assertEquals (  \" Advised   spouse   has   correct   age \"  ,    age 1  ,    advised 1  . getSpouse (  )  . getAge (  )  )  ;", "assertEquals (  \" one   was   invoked   correct   number   of   times \"  ,     5  ,    di 1  . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReentrance"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  1  )  ;", "ProxyFactory   pc    =    new   ProxyFactory ( target )  ;", "pc . addAdvisor ( new   DefaultIntroductionAdvisor ( new    . DummyIntroductionAdviceImpl (  )  ,    Comparable . class )  )  ;", "try    {", "ITestBean   proxied    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "proxied . getName (  )  ;", "fail (  \" Bogus   introduction \"  )  ;", "}    catch    ( Exception   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testRejectsBogusDynamicIntroductionAdviceWithNoAdapter"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "ProxyFactory   pc    =    new   ProxyFactory (  )  ;", "pc . addInterface ( ITestBean . class )  ;", "pc . setTarget ( tb )  ;", "pc . addAdvisor ( new    . StringSetterNullReplacementAdvice (  )  )  ;", "ITestBean   t    =     (  ( ITestBean )     ( pc . getProxy (  )  )  )  ;", "int   newAge    =     5  ;", "t . setAge ( newAge )  ;", "assertEquals ( newAge ,    t . getAge (  )  )  ;", "String   newName    =     \" greg \"  ;", "t . setName ( newName )  ;", "assertEquals ( newName ,    t . getName (  )  )  ;", "t . setName ( null )  ;", "assertEquals (  \"  \"  ,    t . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReplaceArgument"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "SerializablePerson   personTarget    =    new   SerializablePerson (  )  ;", "personTarget . setName (  \" jim \"  )  ;", "personTarget . setAge (  2  6  )  ;", "assertTrue ( SerializationTestUtils . isSerializable ( personTarget )  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( personTarget )  ;", ". CountingThrowsAdvice   cta    =    new    . CountingThrowsAdvice (  )  ;", "pf . addAdvice ( new   SerializableNopInterceptor (  )  )  ;", "pf . addAdvice ( new   CountingBeforeAdvice (  )  )  ;", "pf . addAdvice ( new   CountingAfterReturningAdvice (  )  )  ;", "pf . addAdvice ( cta )  ;", "Person   p    =     (  ( Person )     ( createAopProxy ( pf )  . getProxy (  )  )  )  ;", "p . echo ( null )  ;", "assertEquals (  0  ,    cta . getCalls (  )  )  ;", "try    {", "p . echo ( new   IOException (  )  )  ;", "}    catch    ( IOException   ex )     {", "}", "assertEquals (  1  ,    cta . getCalls (  )  )  ;", "Person   p 2     =     (  ( Person )     ( SerializationTestUtils . serializeAndDeserialize ( p )  )  )  ;", "assertNotSame ( p ,    p 2  )  ;", "assertEquals ( p . getName (  )  ,    p 2  . getName (  )  )  ;", "assertEquals ( p . getAge (  )  ,    p 2  . getAge (  )  )  ;", "assertTrue (  \" Deserialized   object   is   an   AOP   proxy \"  ,    AopUtils . isAopProxy ( p 2  )  )  ;", "Advised   a 1     =     (  ( Advised )     ( p )  )  ;", "Advised   a 2     =     (  ( Advised )     ( p 2  )  )  ;", "assertEquals ( a 1  . getAdvisors (  )  . length ,    a 2  . getAdvisors (  )  . length )  ;", "assertEquals (  \" Proxies   should   be   equal ,    even   after   one   was   serialized \"  ,    p ,    p 2  )  ;", "assertEquals (  \" Proxies   should   be   equal ,    even   after   one   was   serialized \"  ,    p 2  ,    p )  ;", "NopInterceptor   ni    =    new   NopInterceptor (  )  ;", "p 2  . getAge (  )  ;", "assertEquals (  0  ,    ni . getCount (  )  )  ;", "a 2  . addAdvice ( ni )  ;", "p 2  . getAge (  )  ;", "assertEquals (  1  ,    ni . getCount (  )  )  ;", "cta    =     (  (  . CountingThrowsAdvice )     ( a 2  . getAdvisors (  )  [  3  ]  . getAdvice (  )  )  )  ;", "p 2  . echo ( null )  ;", "assertEquals (  1  ,    cta . getCalls (  )  )  ;", "try    {", "p 2  . echo ( new   IOException (  )  )  ;", "}    catch    ( IOException   ex )     {", "}", "assertEquals (  2  ,    cta . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializableTargetAndAdvice"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "assertFalse ( SerializationTestUtils . isSerializable ( tb )  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( tb )  ;", "pf . addAdvice ( new   NopInterceptor (  )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( create ( pf )  . getProxy (  )  )  )  ;", "assertFalse ( SerializationTestUtils . isSerializable ( proxy )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializationAdviceAndTargetNotSerializable"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "SerializablePerson   sp    =    new   SerializablePerson (  )  ;", "assertTrue ( SerializationTestUtils . isSerializable ( sp )  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( sp )  ;", "Advice   i    =    new   NopInterceptor (  )  ;", "pf . addAdvice ( i )  ;", "assertFalse ( SerializationTestUtils . isSerializable ( i )  )  ;", "Object   proxy    =    create ( pf )  . getProxy (  )  ;", "assertFalse ( SerializationTestUtils . isSerializable ( proxy )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializationAdviceNotSerializable"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "ProxyFactory   pc    =    new   ProxyFactory (  )  ;", "pc . addInterface ( ITestBean . class )  ;", "NopInterceptor   di    =    new   NopInterceptor (  )  ;", ". TestStaticPointcutAdvice   sp    =    new    . TestStaticPointcutAdvice ( di ,     \" getAge \"  )  ;", "pc . addAdvisor ( sp )  ;", "pc . setTarget ( tb )  ;", "ITestBean   it    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "assertEquals ( di . getCount (  )  ,     0  )  ;", "it . getAge (  )  ;", "assertEquals ( di . getCount (  )  ,     1  )  ;", "it . setAge (  1  1  )  ;", "assertEquals ( it . getAge (  )  ,     1  1  )  ;", "assertEquals ( di . getCount (  )  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testStaticMethodPointcut"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   AbstractAopProxyTests . InvocationCheckExposedInvocationTestBean   expectedTarget    =    new   AbstractAopProxyTests . InvocationCheckExposedInvocationTestBean (  )  ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class ,    IOther . class )  ;", "pc . addAdvice ( INSTANCE )  ;", "AbstractAopProxyTests . TrapTargetInterceptor   tii    =    new   AbstractAopProxyTests . TrapTargetInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "assertEquals (  \" Target   is   correct \"  ,    expectedTarget ,    invocation . getThis (  )  )  ;", "return   super . invoke ( invocation )  ;", "}", "}  ;", "pc . addAdvice ( tii )  ;", "pc . setTarget ( expectedTarget )  ;", "AopProxy   aop    =    createAopProxy ( pc )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( aop . getProxy (  )  )  )  ;", "tb . getName (  )  ;", "}", "METHOD_END"], "methodName": ["testTargetCanGetInvocation"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "AbstractAopProxyTests . NeedsToSeeProxy   target    =    new   AbstractAopProxyTests . NeedsToSeeProxy (  )  ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( AbstractAopProxyTests . INeedsToSeeProxy . class )  ;", "pc . setTarget ( target )  ;", "pc . setExposeProxy ( true )  ;", "AopProxy   aop    =    createAopProxy ( pc )  ;", "AbstractAopProxyTests . INeedsToSeeProxy   proxied    =     (  ( AbstractAopProxyTests . INeedsToSeeProxy )     ( aop . getProxy (  )  )  )  ;", "proxied . incrementViaProxy (  )  ;", "}", "METHOD_END"], "methodName": ["testTargetCanGetInvocationEvenIfNoAdviceChain"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "NopInterceptor   di    =    new   NopInterceptor (  )  ;", ". INeedsToSeeProxy   target    =    new    . TargetChecker (  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory ( target )  ;", "proxyFactory . setExposeProxy ( true )  ;", "assertTrue ( proxyFactory . isExposeProxy (  )  )  ;", "proxyFactory . addAdvice (  0  ,    di )  ;", ". INeedsToSeeProxy   proxied    =     (  (  . INeedsToSeeProxy )     ( createProxy ( proxyFactory )  )  )  ;", "assertEquals (  0  ,    di . getCount (  )  )  ;", "assertEquals (  0  ,    target . getCount (  )  )  ;", "proxied . incrementViaThis (  )  ;", "assertEquals (  \" Increment   happened \"  ,     1  ,    target . getCount (  )  )  ;", "assertEquals (  \" Only   one   invocation   via   AOP   as   use   of   this   wasn ' t   proxied \"  ,     1  ,    di . getCount (  )  )  ;", "assertEquals (  \" Increment   happened \"  ,     1  ,    proxied . getCount (  )  )  ;", "proxied . incrementViaProxy (  )  ;", "assertEquals (  \" Increment   happened \"  ,     2  ,    target . getCount (  )  )  ;", "assertEquals (  \"  3    more   invocations   via   AOP   as   the   first   call   was   reentrant   through   the   proxy \"  ,     4  ,    di . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetCanGetProxy"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "AbstractAopProxyTests . NeedsToSeeProxy   et    =    new   AbstractAopProxyTests . NeedsToSeeProxy (  )  ;", "ProxyFactory   pf 1     =    new   ProxyFactory ( et )  ;", "assertFalse ( pf 1  . isExposeProxy (  )  )  ;", "AbstractAopProxyTests . INeedsToSeeProxy   proxied    =     (  ( AbstractAopProxyTests . INeedsToSeeProxy )     ( createProxy ( pf 1  )  )  )  ;", "proxied . incrementViaProxy (  )  ;", "}", "METHOD_END"], "methodName": ["testTargetCantGetProxyByDefault"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   raw    =    new   AbstractAopProxyTests . OwnSpouse (  )  ;", "ProxyCreatorSupport   pc    =    new   ProxyCreatorSupport (  )  ;", "pc . setInterfaces ( ITestBean . class )  ;", "pc . setTarget ( raw )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( createProxy ( pc )  )  )  ;", "assertSame (  \" this   return   is   wrapped   in   proxy \"  ,    tb ,    tb . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetReturnsThis"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "int   newAge    =     6  5  ;", "ITestBean   itb    =     (  ( ITestBean )     ( create ( pc )  )  )  ;", "itb . setAge ( newAge )  ;", "assertEquals ( newAge ,    itb . getAge (  )  )  ;", "Lockable   lockable    =     (  ( Lockable )     ( itb )  )  ;", "assertFalse ( lockable . locked (  )  )  ;", "lockable . lock (  )  ;", "assertEquals ( newAge ,    itb . getAge (  )  )  ;", "try    {", "itb . setAge (  1  )  ;", "fail (  \" Setters   should   fail   when   locked \"  )  ;", "}    catch    ( LockedException   ex )     {", "}", "assertEquals ( newAge ,    itb . getAge (  )  )  ;", "assertTrue ( lockable . locked (  )  )  ;", "lockable . unlock (  )  ;", "itb . setAge (  1  )  ;", "assertEquals (  1  ,    itb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTestBeanIntroduction"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "MyThrowsHandler   th    =    new   MyThrowsHandler (  )  ;", "@ SuppressWarnings (  \" serial \"  )", "Advisor   matchesEchoInvocations    =    new   StaticMethodMatcherPointcutAdvisor ( th )     {", "@ Override", "public   boolean   matches ( Method   m ,     @ Nullable", "Class <  ?  >    targetClass )     {", "return   m . getName (  )  . startsWith (  \" echo \"  )  ;", "}", "}  ;", "Echo   target    =    new   Echo (  )  ;", "target . setA (  1  6  )  ;", "Factory   pf    =    new   Factory ( target )  ;", "pf . addAdvice ( new   NopInterceptor (  )  )  ;", "pf . addAdvisor ( matchesEchoInvocations )  ;", "assertEquals (  \" Advisor   was   added \"  ,    matchesEchoInvocations ,    pf . getAdvisors (  )  [  1  ]  )  ;", "IEcho   proxied    =     (  ( IEcho )     ( create ( pf )  )  )  ;", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "assertEquals ( target . getA (  )  ,    proxied . getA (  )  )  ;", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "Exception   ex    =    new   Exception (  )  ;", "try    {", "proxied . echoException (  1  ,    ex )  ;", "fail (  )  ;", "}    catch    ( Exception   caught )     {", "assertEquals ( ex ,    caught )  ;", "}", "ex    =    new   FileNotFoundException (  )  ;", "try    {", "proxied . echoException (  1  ,    ex )  ;", "fail (  )  ;", "}    catch    ( FileNotFoundException   caught )     {", "assertEquals ( ex ,    caught )  ;", "}", "assertEquals (  1  ,    th . getCalls (  \" ioException \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testThrowsAdvisorIsInvoked"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   Exception   unexpectedException    =    new   Exception (  )  ;", "MethodInterceptor   mi    =    new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "throw   unexpectedException ;", "}", "}  ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "pc . addAdvice ( INSTANCE )  ;", "pc . addAdvice ( mi )  ;", "pc . setTarget ( new   TestBean (  )  )  ;", "aop    =    create ( pc )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( aop . getProxy (  )  )  )  ;", "try    {", "tb . getAge (  )  ;", "fail (  \" Should   have   wrapped   exception   raised   by   interceptor \"  )  ;", "}    catch    ( UndeclaredThrowableException   thrown )     {", "assertEquals (  \" exception   matches \"  ,    unexpectedException ,    thrown . getUndeclaredThrowable (  )  )  ;", "}    catch    ( Exception   ex )     {", "ex . printStackTrace (  )  ;", "fail (  (  \" Didn ' t   expect   exception :     \"     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUndeclaredCheckedException"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeException   unexpectedException    =    new   RuntimeException (  )  ;", "MethodInterceptor   mi    =    new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "throw   unexpectedException ;", "}", "}  ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "pc . addAdvice ( INSTANCE )  ;", "pc . addAdvice ( mi )  ;", "pc . setTarget ( new   TestBean (  )  )  ;", "aop    =    create ( pc )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( aop . getProxy (  )  )  )  ;", "try    {", "tb . getAge (  )  ;", "fail (  \" Should   have   wrapped   exception   raised   by   interceptor \"  )  ;", "}    catch    ( RuntimeException   thrown )     {", "assertEquals (  \" exception   matches \"  ,    unexpectedException ,    thrown )  ;", "}", "}", "METHOD_END"], "methodName": ["testUndeclaredUnheckedException"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target 1     =    new   TestBean (  )  ;", "ProxyFactory   pf 1     =    new   ProxyFactory ( target 1  )  ;", "pf 1  . addAdvice ( new   NopInterceptor (  )  )  ;", "ITestBean   proxy 1     =     (  ( ITestBean )     ( createProxy ( pf 1  )  )  )  ;", "TestBean   target 2     =    new   TestBean (  )  ;", "ProxyFactory   pf 2     =    new   ProxyFactory ( target 2  )  ;", "pf 2  . addAdvisor ( new   support . DefaultIntroductionAdvisor ( new   TimestampIntroductionInterceptor (  )  )  )  ;", "ITestBean   proxy 2     =     (  ( ITestBean )     ( createProxy ( pf 2  )  )  )  ;", "HashMap < ITestBean ,    Object >    h    =    new   HashMap <  >  (  )  ;", "Object   value 1     =     \" foo \"  ;", "Object   value 2     =     \" bar \"  ;", "assertNull ( h . get ( proxy 1  )  )  ;", "h . put ( proxy 1  ,    value 1  )  ;", "h . put ( proxy 2  ,    value 2  )  ;", "assertEquals ( h . get ( proxy 1  )  ,    value 1  )  ;", "assertEquals ( h . get ( proxy 2  )  ,    value 2  )  ;", "}", "METHOD_END"], "methodName": ["testUseAsHashKey"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "class   MapAwareMethodInterceptor   implements   MethodInterceptor    {", "private   final   Map < String ,    String >    expectedValues ;", "private   final   Map < String ,    String >    valuesToAdd ;", "public   MapAwareMethodInterceptor ( Map < String ,    String >    expectedValues ,    Map < String ,    String >    valuesToAdd )     {", "this . expectedValues    =    expectedValues ;", "this . valuesToAdd    =    valuesToAdd ;", "}", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "ReflectiveMethodInvocation   rmi    =     (  ( ReflectiveMethodInvocation )     ( invocation )  )  ;", "for    ( Iterator < String >    it    =    rmi . getUserAttributes (  )  . keySet (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Object   key    =    it . next (  )  ;", "assertEquals ( expectedValues . get ( key )  ,    rmi . getUserAttributes (  )  . get ( key )  )  ;", "}", "rmi . getUserAttributes (  )  . putAll ( valuesToAdd )  ;", "return   invocation . proceed (  )  ;", "}", "}", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "MapAwareMethodInterceptor   mami 1     =    new   MapAwareMethodInterceptor ( new   HashMap <  >  (  )  ,    new   HashMap < String ,    String >  (  )  )  ;", "Map < String ,    String >    firstValuesToAdd    =    new   HashMap <  >  (  )  ;", "firstValuesToAdd . put (  \" test \"  ,     \"  \"  )  ;", "MapAwareMethodInterceptor   mami 2     =    new   MapAwareMethodInterceptor ( new   HashMap <  >  (  )  ,    firstValuesToAdd )  ;", "MapAwareMethodInterceptor   mami 3     =    new   MapAwareMethodInterceptor ( firstValuesToAdd ,    new   HashMap <  >  (  )  )  ;", "MapAwareMethodInterceptor   mami 4     =    new   MapAwareMethodInterceptor ( firstValuesToAdd ,    new   HashMap <  >  (  )  )  ;", "Map < String ,    String >    secondValuesToAdd    =    new   HashMap <  >  (  )  ;", "secondValuesToAdd . put (  \" foo \"  ,     \" bar \"  )  ;", "secondValuesToAdd . put (  \" cat \"  ,     \" dog \"  )  ;", "MapAwareMethodInterceptor   mami 5     =    new   MapAwareMethodInterceptor ( firstValuesToAdd ,    secondValuesToAdd )  ;", "Map < String ,    String >    finalExpected    =    new   HashMap <  >  ( firstValuesToAdd )  ;", "finalExpected . putAll ( secondValuesToAdd )  ;", "MapAwareMethodInterceptor   mami 6     =    new   MapAwareMethodInterceptor ( finalExpected ,    secondValuesToAdd )  ;", "pc . addAdvice ( mami 1  )  ;", "pc . addAdvice ( mami 2  )  ;", "pc . addAdvice ( mami 3  )  ;", "pc . addAdvice ( mami 4  )  ;", "pc . addAdvice ( mami 5  )  ;", "pc . addAdvice ( mami 6  )  ;", "pc . setTarget ( new   TestBean (  )  )  ;", "aop    =    create ( pc )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( aop . getProxy (  )  )  )  ;", "String   newName    =     \" foo \"  ;", "tb . setName ( newName )  ;", "assertEquals ( newName ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUserAttributes"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "int   age 1     =     3  3  ;", "int   age 2     =     3  7  ;", "String   name    =     \" tony \"  ;", "TestBean   target 1     =    new   TestBean (  )  ;", "target 1  . setAge ( age 1  )  ;", "ProxyFactory   pf 1     =    new   ProxyFactory ( target 1  )  ;", "pf 1  . addAdvisor ( new   support . DefaultPointcutAdvisor ( new   NopInterceptor (  )  )  )  ;", "pf 1  . addAdvisor ( new   support . DefaultPointcutAdvisor ( new   TimestampIntroductionInterceptor (  )  )  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( pf 1  . getProxy (  )  )  )  ;", "assertEquals ( age 1  ,    tb . getAge (  )  )  ;", "tb . setAge ( age 2  )  ;", "assertEquals ( age 2  ,    tb . getAge (  )  )  ;", "assertNull ( tb . getName (  )  )  ;", "tb . setName ( name )  ;", "assertEquals ( name ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValuesStick"], "fileName": "org.springframework.aop.framework.AbstractAopProxyTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory ( new   Class <  ?  >  [  ]  {    ITestBean . class    }  )  ;", "pf . setProxyTargetClass ( true )  ;", "MethodInterceptor   advice    =    new   NopInterceptor (  )  ;", "Pointcut   pointcut    =    new   Pointcut (  )     {", "@ Override", "public   ClassFilter   getClassFilter (  )     {", "return   ClassFilter . TRUE ;", "}", "@ Override", "public   MethodMatcher   getMethodMatcher (  )     {", "return   MethodMatcher . TRUE ;", "}", "@ Override", "public   boolean   equals ( Object   obj )     {", "return   true ;", "}", "@ Override", "public   int   hashCode (  )     {", "return    0  ;", "}", "}  ;", "pf . addAdvisor ( new   support . DefaultPointcutAdvisor ( pointcut ,    advice )  )  ;", "pf . setTarget ( target )  ;", "pf . setFrozen ( true )  ;", "pf . setExposeProxy ( false )  ;", "return    (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAdvisedProxy"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory ( ITestBean . class )  ;", "pf . setargetClass ( true )  ;", "pf . addAdvisor ( new   LockMixinAdvisor (  )  )  ;", "pf . setTarget ( target )  ;", "pf . setFrozen ( true )  ;", "pf . setExposeProxy ( false )  ;", "return    (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getIntroductionAdvisorProxy"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =    new   TestBean (  )  ;", "CountingBeforeAdvice   cba    =    new   CountingBeforeAdvice (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTarget ( bean )  ;", "pf . setFrozen ( false )  ;", "pf . setOpaque ( false )  ;", "pf . setProxyTargetClass ( true )  ;", "TestBean   proxy    =     (  ( TestBean )     ( pf . getProxy (  )  )  )  ;", "assertTrue ( AopUtils . is ( proxy )  )  ;", "proxy . getAge (  )  ;", "assertEquals (  0  ,    cba . getCalls (  )  )  ;", "(  ( Advised )     ( proxy )  )  . addAdvice ( cba )  ;", "proxy . getAge (  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddAdviceAtRuntime"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "CglibProxyTests . ExceptionThrower   bean    =    new   CglibProxyTests . ExceptionThrower (  )  ;", "mockTargetSource . setTarget ( bean )  ;", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . setTargetSource ( mockTargetSource )  ;", "as . addAdvice ( new   NopInterceptor (  )  )  ;", "AopProxy   aop    =    new   CglibAopProxy ( as )  ;", "CglibProxyTests . ExceptionThrower   proxy    =     (  ( CglibProxyTests . ExceptionThrower )     ( aop . getProxy (  )  )  )  ;", "try    {", "proxy . doTest (  )  ;", "}    catch    ( Exception   ex )     {", "assertTrue (  \" Invalid   exception   class \"  ,     ( ex   instanceof   ApplicationContextException )  )  ;", "}", "assertTrue (  \" Catch   was   not   invoked \"  ,    proxy . isCatchInvoked (  )  )  ;", "assertTrue (  \" Finally   was   not   invoked \"  ,    proxy . isFinallyInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExceptionHandling"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "CglibTestBean   bean    =    new   CglibTestBean (  )  ;", "bean . setName (  \" Rob   Harrop \"  )  ;", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . setTarget ( bean )  ;", "as . addAdvice ( new   NopInterceptor (  )  )  ;", "AopProxy   aop    =    new   CglibAopProxy ( as )  ;", "CglibTestBean   proxy    =     (  ( CglibTestBean )     ( aop . getProxy (  )  )  )  ;", "assertEquals (  \" The   name   property   has   been   overwritten   by   the   constructor \"  ,     \" Rob   Harrop \"  ,    proxy . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodInvocationDuringConstructor"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  0  )  ;", "TestBean   target 2     =    new   TestBean (  )  ;", "target 2  . setAge (  2  1  )  ;", "ITestBean   proxy 1     =    getAdvised ( target )  ;", "ITestBean   proxy 2     =    getAdvised ( target 2  )  ;", "assertSame ( proxy 1  . getClass (  )  ,    proxy 2  . getClass (  )  )  ;", "assertEquals ( target . getAge (  )  ,    proxy 1  . getAge (  )  )  ;", "assertEquals ( target 2  . getAge (  )  ,    proxy 2  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleProxies"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target 1     =    new   TestBean (  )  ;", "target 1  . setAge (  2  0  )  ;", "TestBean   target 2     =    new   TestBean (  )  ;", "target 2  . setAge (  2  1  )  ;", "ITestBean   proxy 1     =    getIntroductionAdvisor ( target 1  )  ;", "ITestBean   proxy 2     =    getIntroductionAdvisor ( target 2  )  ;", "assertSame (  \" Incorrect   duplicate   creation   of   proxy   classes \"  ,    proxy 1  . getClass (  )  ,    proxy 2  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleProxiesForIntroductionAdvisor"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "pc . addAdvice ( new   NopInterceptor (  )  )  ;", "Aop   aop    =    createAop ( pc )  ;", "aop . get (  )  ;", "}", "METHOD_END"], "methodName": ["testNoTarget"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "new   CglibAopProxy ( null )  ;", "}", "METHOD_END"], "methodName": ["testNullConfig"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "CglibProxyTests . PackageMethodTestBean   bean    =    new   CglibProxyTests . PackageMethodTestBean (  )  ;", "bean . value    =     \" foo \"  ;", "mockTargetSource . setTarget ( bean )  ;", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . setTargetSource ( mockTargetSource )  ;", "as . addAdvice ( new   NopInterceptor (  )  )  ;", "AopProxy   aop    =    new   CglibAopProxy ( as )  ;", "CglibProxyTests . PackageMethodTestBean   proxy    =     (  ( CglibProxyTests . PackageMethodTestBean )     ( aop . getProxy (  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( proxy )  )  ;", "assertEquals ( proxy . getClass (  )  . getClassLoader (  )  ,    bean . getClass (  )  . getClassLoader (  )  )  ;", "assertEquals (  \" foo \"  ,    proxy . getString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPackageMethodInvocation"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "CglibProxyTests . ProtectedMethodTestBean   bean    =    new   CglibProxyTests . ProtectedMethodTestBean (  )  ;", "bean . value    =     \" foo \"  ;", "mockTargetSource . setTarget ( bean )  ;", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . setTargetSource ( mockTargetSource )  ;", "as . addAdvice ( new   NopInterceptor (  )  )  ;", "AopProxy   aop    =    new   CglibAopProxy ( as )  ;", "CglibProxyTests . ProtectedMethodTestBean   proxy    =     (  ( CglibProxyTests . ProtectedMethodTestBean )     ( aop . getProxy (  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( proxy )  )  ;", "assertEquals ( proxy . getClass (  )  . getClassLoader (  )  ,    bean . getClass (  )  . getClassLoader (  )  )  ;", "assertEquals (  \" foo \"  ,    proxy . getString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProtectedMethodInvocation"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   target    =    new   TestBean (  )  ;", "mockTargetSource . setTarget ( target )  ;", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . setTargetSource ( mockTargetSource )  ;", "as . addAdvice ( new   NopInterceptor (  )  )  ;", "AopProxy   cglib    =    new   AopProxy ( as )  ;", "ITestBean   proxy 1     =     (  ( ITestBean )     ( cglib . getProxy (  )  )  )  ;", "mockTargetSource . setTarget ( proxy 1  )  ;", "as    =    new   AdvisedSupport ( new   Class <  ?  >  [  ]  {        }  )  ;", "as . setTargetSource ( mockTargetSource )  ;", "as . addAdvice ( new   NopInterceptor (  )  )  ;", "cglib    =    new   AopProxy ( as )  ;", "assertThat ( cglib . getProxy (  )  ,    instanceOf ( ITestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyAProxy"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   target    =    new   TestBean (  )  ;", "mockTargetSource . setTarget ( target )  ;", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . setTargetSource ( mockTargetSource )  ;", "as . addAdvice ( new   NopInterceptor (  )  )  ;", "as . addInterface ( Serializable . class )  ;", "AopProxy   cglib    =    new   AopProxy ( as )  ;", "ITestBean   proxy 1     =     (  ( ITestBean )     ( cglib . getProxy (  )  )  )  ;", "mockTargetSource . setTarget ( proxy 1  )  ;", "as    =    new   AdvisedSupport ( new   Class <  ?  >  [  ]  {        }  )  ;", "as . setTargetSource ( mockTargetSource )  ;", "as . addAdvice ( new   NopInterceptor (  )  )  ;", "cglib    =    new   AopProxy ( as )  ;", "ITestBean   proxy 2     =     (  ( ITestBean )     ( cglib . getProxy (  )  )  )  ;", "assertTrue (  ( proxy 2    instanceof   Serializable )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyAProxyWithAdditionalInterface"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   raw    =    new   TestBean (  )  ;", "raw . setAge (  3  2  )  ;", "mockTargetSource . setTarget ( raw )  ;", "AdvisedSupport   pc    =    new   AdvisedSupport (  )  ;", "pc . setTargetSource ( mockTargetSource )  ;", "AopProxy   aop    =    new   CglibAopProxy ( pc )  ;", "Object   proxy    =    aop . getProxy (  )  ;", "assertTrue ( AopUtils . is ( proxy )  )  ;", "assertTrue (  ( proxy   instanceof   ITestBean )  )  ;", "assertTrue (  ( proxy   instanceof   TestBean )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( proxy )  )  ;", "assertEquals (  3  2  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyCanBeClassNotInterface"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "CountingBeforeAdvice   advice    =    new   CountingBeforeAdvice (  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory ( new    . MyBean (  )  )  ;", "proxyFactory . addAdvice ( advice )  ;", "proxyFactory . setProxyTargetClass ( true )  ;", ". MyBean   proxy    =     (  (  . MyBean )     ( proxyFactory . getProxy (  )  )  )  ;", "assertEquals (  4  ,    proxy . add (  1  ,     3  )  )  ;", "assertEquals (  1  ,    advice . getCalls (  \" add \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyProtectedMethod"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory ( new   CglibProxyTests . MyBean (  )  )  ;", "CglibProxyTests . MyBean   proxy    =     (  ( CglibProxyTests . MyBean )     ( proxyFactory . getProxy (  )  )  )  ;", "assertEquals (  4  ,    proxy . add (  1  ,     3  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyTargetClassInCaseOfNoInterfaces"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "CglibTestBean   target    =    new   CglibTestBean (  )  ;", "target . setName (  \" Rob   Harrop \"  )  ;", "AdvisedSupport   pc    =    new   AdvisedSupport (  )  ;", "pc . setFrozen ( true )  ;", "pc . setTarget ( target )  ;", "CglibAopProxy   aop    =    new   CglibAopProxy ( pc )  ;", "CglibTestBean   proxy    =     (  ( CglibTestBean )     ( aop . getProxy (  )  )  )  ;", "assertNotNull (  \" Proxy   should   not   be   null \"  ,    proxy )  ;", "assertEquals (  \" Constructor   overrode   the   value   of   name \"  ,     \" Rob   Harrop \"  ,    proxy . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnadvisedProxyCreationWithCallDuringConstructor"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory ( new   CglibProxyTests . MyBean (  )  )  ;", "CglibProxyTests . MyBean   proxy    =     (  ( CglibProxyTests . MyBean )     ( proxyFactory . getProxy (  )  )  )  ;", "assertTrue ( proxy . doWithVarargs ( CglibProxyTests . MyEnum . A ,    CglibProxyTests . MyOtherEnum . C )  )  ;", "}", "METHOD_END"], "methodName": ["testVarargsWithEnumArray"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( CglibProxyTests . DEPENDENCY _ CHECK _ CONTEXT ,    getClass (  )  )  ;", "ctx . getBean (  \" testBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testWithDependencyChecking"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "CglibProxyTests . NoArgCtorTestBean   target    =    new   CglibProxyTests . NoArgCtorTestBean (  \" b \"  ,     1  )  ;", "target . reset (  )  ;", "mockTargetSource . setTarget ( target )  ;", "AdvisedSupport   pc    =    new   AdvisedSupport (  )  ;", "pc . setTargetSource ( mockTargetSource )  ;", "CglibAopProxy   aop    =    new   CglibAopProxy ( pc )  ;", "aop . setConstructorArguments ( new   Object [  ]  {     \" Rob   Harrop \"  ,     2  2     }  ,    new   Class <  ?  >  [  ]  {    String . class ,    int . class    }  )  ;", "CglibProxyTests . NoArgCtorTestBean   proxy    =     (  ( CglibProxyTests . NoArgCtorTestBean )     ( aop . getProxy (  )  )  )  ;", "assertNotNull ( proxy )  ;", "}", "METHOD_END"], "methodName": ["testWithNoArgConstructor"], "fileName": "org.springframework.aop.framework.CglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.aop.framework.CglibTestBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.aop.framework.CglibTestBean"}, {"methodBody": ["METHOD_START", "{", "return   this . dependency ;", "}", "METHOD_END"], "methodName": ["getDependency"], "fileName": "org.springframework.aop.framework.ClassWithComplexConstructor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  (  ( this . selfReference )     !  =     ( this )  )     &  &     ( AopUtils . isCglibProxy ( this . selfReference )  )  )  ,     \" Self   reference   must   be   a   CGLIB   proxy \"  )  ;", "this . dependency . method (  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.aop.framework.ClassWithComplexConstructor"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.aop.framework.Dependency"}, {"methodBody": ["METHOD_START", "{", "( value )  +  +  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.aop.framework.Dependency"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   as    =    new   AdvisedSupport ( JdkDynamicProxyTests . Named . class )  ;", "as . setTarget ( new   JdkDynamicProxyTests . Person (  )  )  ;", "JdkDynamicAopProxy   aopProxy    =    new   JdkDynamicAopProxy ( as )  ;", "JdkDynamicProxyTests . Named   proxy    =     (  ( JdkDynamicProxyTests . Named )     ( aopProxy . getProxy (  )  )  )  ;", "JdkDynamicProxyTests . Named   named    =    new   JdkDynamicProxyTests . Person (  )  ;", "assertEquals (  \" equals (  )  \"  ,    proxy ,    named )  ;", "assertEquals (  \" hashCode (  )  \"  ,    proxy . hashCode (  )  ,    named . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEqualsAndHashCodeDefined"], "fileName": "org.springframework.aop.framework.JdkDynamicProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   int   age    =     2  5  ;", "MethodInterceptor   mi    =     (    invocation )     -  >    age ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "pc . addAdvice ( mi )  ;", "Aop   aop    =    createAop ( pc )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( aop . get (  )  )  )  ;", "assertEquals (  \" correct   return   value \"  ,    age ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInterceptorIsInvokedWithNoTarget"], "fileName": "org.springframework.aop.framework.JdkDynamicProxyTests"}, {"methodBody": ["METHOD_START", "{", "new   JdkDynamicAopProxy ( null )  ;", "}", "METHOD_END"], "methodName": ["testNullConfig"], "fileName": "org.springframework.aop.framework.JdkDynamicProxyTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   raw    =    new   TestBean (  )  ;", "raw . setAge (  3  2  )  ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class )  ;", "pc . setTarget ( raw )  ;", "AopProxy   aop    =    new   AopProxy ( pc )  ;", "Object   proxy    =    aop . getProxy (  )  ;", "assertTrue (  ( proxy   instanceof   ITestBean )  )  ;", "assertFalse (  ( proxy   instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyIsJustInterface"], "fileName": "org.springframework.aop.framework.JdkDynamicProxyTests"}, {"methodBody": ["METHOD_START", "{", "JdkDynamicProxyTests . FooBar   bean    =    new   JdkDynamicProxyTests . FooBar (  )  ;", "ProxyCreatorSupport   as    =    new   ProxyCreatorSupport (  )  ;", "as . setInterfaces ( JdkDynamicProxyTests . Foo . class )  ;", "as . setTarget ( bean )  ;", "JdkDynamicProxyTests . Foo   proxy    =     (  ( JdkDynamicProxyTests . Foo )     ( createProxy ( as )  )  )  ;", "assertSame (  \" Target   should   be   returned   when   return   types   are   incompatible \"  ,    bean ,    proxy . getBarThis (  )  )  ;", "assertSame (  \" Proxy   should   be   returned   when   return   types   are   compatible \"  ,    proxy ,    proxy . getFooThis (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyNotWrappedIfIncompatible"], "fileName": "org.springframework.aop.framework.JdkDynamicProxyTests"}, {"methodBody": ["METHOD_START", "{", "final   AbstractAopProxyTests . ExposedInvocationTestBean   expectedTarget    =    new   AbstractAopProxyTests . ExposedInvocationTestBean (  )     {", "@ Override", "protected   void   assertions ( MethodInvocation   invocation )     {", "assertEquals ( this ,    invocation . getThis (  )  )  ;", "assertEquals (  (  \" Invocation   should   be   on   ITestBean :     \"     +     ( invocation . getMethod (  )  )  )  ,    ITestBean . class ,    invocation . getMethod (  )  . getDeclaringClass (  )  )  ;", "}", "}  ;", "AdvisedSupport   pc    =    new   AdvisedSupport ( ITestBean . class ,    IOther . class )  ;", "pc . addAdvice ( INSTANCE )  ;", "AbstractAopProxyTests . TrapTargetInterceptor   tii    =    new   AbstractAopProxyTests . TrapTargetInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "assertEquals (  \" Target   is   correct \"  ,    expectedTarget ,    invocation . getThis (  )  )  ;", "return   super . invoke ( invocation )  ;", "}", "}  ;", "pc . addAdvice ( tii )  ;", "pc . setTarget ( expectedTarget )  ;", "AopProxy   aop    =    createAopProxy ( pc )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( aop . getProxy (  )  )  )  ;", "tb . getName (  )  ;", "}", "METHOD_END"], "methodName": ["testTargetCanGetInvocationWithPrivateClass"], "fileName": "org.springframework.aop.framework.JdkDynamicProxyTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory ( new   JdkDynamicProxyTests . VarargTestBean (  )  )  ;", "JdkDynamicProxyTests . VarargTestInterface   proxy    =     (  ( JdkDynamicProxyTests . VarargTestInterface )     ( proxyFactory . getProxy (  )  )  )  ;", "assertTrue ( proxy . doWithVarargs ( JdkDynamicProxyTests . MyEnum . A ,    JdkDynamicProxyTests . MyOtherEnum . C )  )  ;", "}", "METHOD_END"], "methodName": ["testVarargsWithEnumArray"], "fileName": "org.springframework.aop.framework.JdkDynamicProxyTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" resource \"  )", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \"  - context . xml \"  ,    getClass (  )  )  ;", "ClassWithComplexConstructor   bean    =    context . getBean ( ClassWithComplexConstructor . class )  ;", "bean . method (  )  ;", "DebugInterceptor   interceptor    =    context . getBean ( DebugInterceptor . class )  ;", "assertThat ( interceptor . getCount (  )  ,    is (  1 L )  )  ;", "assertThat ( bean . getDependency (  )  . getValue (  )  ,    is (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["appliesAspectToClassWithComplexConstructor"], "fileName": "org.springframework.aop.framework.ObjenesisProxyTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "parent . registerBeanDefinition (  \" target 2  \"  ,    new   RootBeanDefinition ( TestListener . class )  )  ;", "this . factory    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader (  (  ( BeanDefinitionRegistry )     ( this . factory )  )  )  . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" Hieronymous \"  ;", "TestBean   target    =     (  ( TestBean )     ( f . getBean (  \" test \"  )  )  )  ;", "target . setName ( name )  ;", "ITestBean   autoInvoker    =     (  ( ITestBean )     ( f . getBean (  \" autoInvoker \"  )  )  )  ;", "assertTrue ( autoInvoker . getName (  )  . equals ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testAutoInvoker"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   it    =     (  ( ITestBean )     ( factory . getBean (  \" test 1  \"  )  )  )  ;", "Advised   pc    =     (  ( Advised )     ( it )  )  ;", "it . getAge (  )  ;", "NopInterceptor   di    =    new   NopInterceptor (  )  ;", "pc . addAdvice (  0  ,    di )  ;", "assertEquals (  0  ,    di . getCount (  )  )  ;", "it . setAge (  2  5  )  ;", "assertEquals (  2  5  ,    it . getAge (  )  )  ;", "assertEquals (  2  ,    di . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanAddAndRemoveAdvicesOnSingleton"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertThat (  \" Shouldn ' t   implement   TimeStamped   before   manipulation \"  ,    factory . getBean (  \" test 2  \"  )  ,    not ( instanceOf ( TimeStamped . class )  )  )  ;", "ProxyFactoryBean   config    =     (  ( ProxyFactoryBean )     ( factory . getBean (  \"  & test 2  \"  )  )  )  ;", "long   time    =     6  6  6 L ;", "TimestampIntroductionInterceptor   ti    =    new   TimestampIntroductionInterceptor (  )  ;", "ti . setTime ( time )  ;", "int   oldCount    =    config . getAdvisors (  )  . length ;", "config . addAdvisor (  0  ,    new   support . DefaultIntroductionAdvisor ( ti ,    TimeStamped . class )  )  ;", "assertTrue (  (  ( config . getAdvisors (  )  . length )     =  =     ( oldCount    +     1  )  )  )  ;", "TimeStamped   ts    =     (  ( TimeStamped )     ( factory . getBean (  \" test 2  \"  )  )  )  ;", "assertEquals ( time ,    ts . getTimeStamp (  )  )  ;", "config . removeAdvice ( ti )  ;", "assertTrue (  (  ( config . getAdvisors (  )  . length )     =  =    oldCount )  )  ;", "assertTrue (  (  ( ts . getTimeStamp (  )  )     =  =    time )  )  ;", "assertThat (  \" Should   no   longer   implement   TimeStamped \"  ,    factory . getBean (  \" test 2  \"  )  ,    not ( instanceOf ( TimeStamped . class )  )  )  ;", "config . removeAdvice ( new   DebugInterceptor (  )  )  ;", "assertTrue (  (  ( config . getAdvisors (  )  . length )     =  =    oldCount )  )  ;", "ITestBean   it    =     (  ( ITestBean )     ( ts )  )  ;", "DebugInterceptor   debugInterceptor    =    new   DebugInterceptor (  )  ;", "config . addAdvice (  0  ,    debugInterceptor )  ;", "it . getSpouse (  )  ;", "assertTrue (  (  ( debugInterceptor . getCount (  )  )     =  =     0  )  )  ;", "it    =     (  ( ITestBean )     ( factory . getBean (  \" test 2  \"  )  )  )  ;", "it . getSpouse (  )  ;", "assertEquals (  1  ,    debugInterceptor . getCount (  )  )  ;", "config . removeAdvice ( debugInterceptor )  ;", "it . getSpouse (  )  ;", "assertEquals (  2  ,    debugInterceptor . getCount (  )  )  ;", "it    =     (  ( ITestBean )     ( factory . getBean (  \" test 2  \"  )  )  )  ;", "it . getSpouse (  )  ;", "assertEquals (  2  ,    debugInterceptor . getCount (  )  )  ;", "assertEquals ( time ,    ts . getTimeStamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanAddAndRemoveAspectInterfacesOnPrototype"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   f    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( f )  . loadBeanDefinitions ( new   ClassPathResource (  . THROWS _ ADVICE _ CONTEXT ,     . CLASS )  )  ;", "MyThrowsHandler   th    =     (  ( MyThrowsHandler )     ( f . getBean (  \" throwsAdvice \"  )  )  )  ;", "CountingBeforeAdvice   cba    =     (  ( CountingBeforeAdvice )     ( f . getBean (  \" countingBeforeAdvice \"  )  )  )  ;", "assertEquals (  0  ,    cba . getCalls (  )  )  ;", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "IEcho   echo    =     (  ( IEcho )     ( f . getBean (  \" throwsAdvised \"  )  )  )  ;", "int   i    =     1  2  ;", "echo . setA ( i )  ;", "assertEquals ( i ,    echo . getA (  )  )  ;", "assertEquals (  2  ,    cba . getCalls (  )  )  ;", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "Exception   expected    =    new   Exception (  )  ;", "try    {", "echo . echoException (  1  ,    expected )  ;", "fail (  )  ;", "}    catch    ( Exception   ex )     {", "assertEquals ( expected ,    ex )  ;", "}", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "expected    =    new   FileNotFoundException (  )  ;", "try    {", "echo . echoException (  1  ,    expected )  ;", "fail (  )  ;", "}    catch    ( IOException   ex )     {", "assertEquals ( expected ,    ex )  ;", "}", "assertEquals (  1  ,    th . getCalls (  \" ioException \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanAddThrowsAdviceWithoutAdvisor"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactoryBean   config    =     (  ( ProxyFactoryBean )     ( factory . getBean (  \"  & test 1  \"  )  )  )  ;", "assertTrue (  \" Has   correct   object   type \"  ,    ITestBean . class . isAssignableFrom ( config . getObjectType (  )  )  )  ;", "assertTrue (  \" Has   correct   object   type \"  ,    ITestBean . class . isAssignableFrom ( factory . getType (  \" test 1  \"  )  )  )  ;", "config . getObject (  )  ;", "assertEquals (  \" Have   one   advisors \"  ,     1  ,    config . getAdvisors (  )  . length )  ;", "assertTrue (  \" Has   correct   object   type \"  ,    ITestBean . class . isAssignableFrom ( config . getObjectType (  )  )  )  ;", "assertTrue (  \" Has   correct   object   type \"  ,    ITestBean . class . isAssignableFrom ( factory . getType (  \" test 1  \"  )  )  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( factory . getBean (  \" test 1  \"  )  )  )  ;", "tb . hashCode (  )  ;", "final   Exception   ex    =    new   UnsupportedOperationException (  \" invoke \"  )  ;", "config . addAdvice (  0  ,    new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "throw   ex ;", "}", "}  )  ;", "assertEquals (  \" Have   correct   advisor   count \"  ,     2  ,    config . getAdvisors (  )  . length )  ;", "tb    =     (  ( ITestBean )     ( factory . getBean (  \" test 1  \"  )  )  )  ;", "try    {", "tb . toString (  )  ;", "fail (  \" Evil   interceptor   added   programmatically   should   fail   all   method   calls \"  )  ;", "}    catch    ( Exception   thrown )     {", "assertTrue (  ( thrown    =  =    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCanGetFactoryReferenceAndManipulate"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Object   prototype    =    testPrototypeInstancesAreIndependent (  \" cglibPrototype \"  )  ;", "assertTrue (  \" It ' s   a   cglib   proxy \"  ,    AopUtils . isCglib ( prototype )  )  ;", "assertFalse (  \" It ' s   not   a   dynamic   proxy \"  ,    AopUtils . isJdkDynamic ( prototype )  )  ;", "}", "METHOD_END"], "methodName": ["testCglibPrototypeInstance"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactoryBean   fb    =    new   ProxyFactoryBean (  )  ;", "fb . setTarget ( new   TestBean (  )  )  ;", "fb . addAdvice ( new   DebugInterceptor (  )  )  ;", "fb . setBeanFactory ( new   DefaultListableBeanFactory (  )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( fb . getObject (  )  )  )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( proxy )  )  ;", "}", "METHOD_END"], "methodName": ["testDetectsInterfaces"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . DBL _ TARGETSOURCE _ CONTEXT ,     . CLASS )  )  ;", "bf . getBean ( name )  ;", "fail (  \" Should   not   allow   TargetSource   to   be   specified   in   interceptorNames   as   well   as   targetSource   property \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "AopConfigException   aex    =     (  ( AopConfigException )     ( ex . getCause (  )  )  )  ;", "assertTrue (  (  ( aex . getMessage (  )  . indexOf (  \" TargetSource \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDoubleTargetSourceIsRejected"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "testDoubleTargetSourceIsRejected (  \" doubleTarget \"  )  ;", "testDoubleTargetSourceIsRejected (  \" arbitraryTarget \"  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleTargetSourcesAreRejected"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . INVALID _ CONTEXT ,     . CLASS )  )  ;", "try    {", "bf . getBean (  \" emptyInterceptorNames \"  )  ;", "fail (  \" Interceptor   names   cannot   be   empty \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testEmptyInterceptorNames"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . FROZEN _ CONTEXT ,     . CLASS )  )  ;", "Advised   advised    =     (  ( Advised )     ( bf . getBean (  \" frozen \"  )  )  )  ;", "assertTrue (  \" The   proxy   should   be   frozen \"  ,    advised . isFrozen (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFrozenFactoryBean"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . TARGETSOURCE _ CONTEXT ,     . CLASS )  )  ;", "CountingBeforeAdvice   cba    =     (  ( CountingBeforeAdvice )     ( bf . getBean (  \" countingBeforeAdvice \"  )  )  )  ;", "assertEquals (  0  ,    cba . getCalls (  )  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" directTarget \"  )  )  )  ;", "assertTrue ( tb . getName (  )  . equals (  \" Adam \"  )  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "ProxyFactoryBean   pfb    =     (  ( ProxyFactoryBean )     ( bf . getBean (  \"  & directTarget \"  )  )  )  ;", "assertTrue (  \" Has   correct   object   type \"  ,    TestBean . class . isAssignableFrom ( pfb . getObjectType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetObjectTypeWithDirectTarget"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . TARGETSOURCE _ CONTEXT ,     . CLASS )  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" noTarget \"  )  )  )  ;", "try    {", "tb . getName (  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", "assertEquals (  \" getName \"  ,    ex . getMessage (  )  )  ;", "}", "FactoryBean <  ?  >    pfb    =     (  ( ProxyFactoryBean )     ( bf . getBean (  \"  & noTarget \"  )  )  )  ;", "assertTrue (  \" Has   correct   object   type \"  ,    ITestBean . class . isAssignableFrom ( pfb . getObjectType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetObjectTypeWithNoTargetOrTargetSource"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . TARGETSOURCE _ CONTEXT ,     . CLASS )  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" viaTargetSource \"  )  )  )  ;", "assertTrue ( tb . getName (  )  . equals (  \" Adam \"  )  )  ;", "ProxyFactoryBean   pfb    =     (  ( ProxyFactoryBean )     ( bf . getBean (  \"  & viaTargetSource \"  )  )  )  ;", "assertTrue (  \" Has   correct   object   type \"  ,    TestBean . class . isAssignableFrom ( pfb . getObjectType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetObjectTypeWithTargetViaTargetSource"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactoryBeanTests . AddedGlobalInterface   agi    =     (  ( ProxyFactoryBeanTests . AddedGlobalInterface )     ( factory . getBean (  \" autoInvoker \"  )  )  )  ;", "assertTrue (  (  ( agi . globalsAdded (  )  )     =  =     (  -  1  )  )  )  ;", "ProxyFactoryBean   pfb    =     (  ( ProxyFactoryBean )     ( factory . getBean (  \"  & validGlobals \"  )  )  )  ;", "pfb . getObject (  )  ;", "assertEquals (  \" Have    2    globals   and    2    explicit   advisors \"  ,     3  ,    pfb . getAdvisors (  )  . length )  ;", "ApplicationListener <  ?  >    l    =     (  ( ApplicationListener <  ?  >  )     ( factory . getBean (  \" validGlobals \"  )  )  )  ;", "agi    =     (  ( ProxyFactoryBeanTests . AddedGlobalInterface )     ( l )  )  ;", "assertTrue (  (  ( agi . globalsAdded (  )  )     =  =     (  -  1  )  )  )  ;", "try    {", "agi    =     (  ( ProxyFactoryBeanTests . AddedGlobalInterface )     ( factory . getBean (  \" test 1  \"  )  )  )  ;", "fail (  \" Aspect   interface   should ' t   be   implemeneted   without   globals \"  )  ;", "}    catch    ( ClassCastException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testGlobalsCanAddAspectInterfaces"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . INVALID _ CONTEXT ,     . CLASS )  )  ;", "try    {", "bf . getBean (  \" globalsWithoutTarget \"  )  ;", "fail (  \" Should   require   target   name \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   AopConfigException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGlobalsWithoutTarget"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . AUTOWIRING _ CONTEXT ,     . CLASS )  )  ;", "bf . getBean (  \" testBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testInnerBeanTargetUsingAutowiring"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   test 1     =     (  ( ITestBean )     ( factory . getBean (  \" test 3  \"  )  )  )  ;", "assertTrue (  \" test 3    is   a   dynamic   proxy \"  ,    Proxy . isProxyClass ( test 1  . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsDynamicProxyWhenAutodetectingInterfaces"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   test 1     =     (  ( ITestBean )     ( factory . getBean (  \" test 4  \"  )  )  )  ;", "assertTrue (  \" test 4    is   a   dynamic   proxy \"  ,    Proxy . isProxyClass ( test 1  . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsDynamicProxyWhenAutodetectingInterfacesForPrototype"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   test 1     =     (  ( ITestBean )     ( factory . getBean (  \" test 1  \"  )  )  )  ;", "assertTrue (  \" test 1    is   a   dynamic   proxy \"  ,    Proxy . isProxyClass ( test 1  . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsDynamicProxyWhenInterfaceSpecified"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   test 1     =     (  ( ITestBean )     ( factory . getBean (  \" test 2  \"  )  )  )  ;", "assertTrue (  \" test 2    is   a   dynamic   proxy \"  ,    Proxy . isProxyClass ( test 1  . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsDynamicProxyWhenInterfaceSpecifiedForPrototype"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   tb    =     (  ( ITestBean )     ( factory . getBean (  \" pointcuts \"  )  )  )  ;", ". PointcutForVoid . reset (  )  ;", "assertTrue (  \" No   methods   intercepted \"  ,     . PointcutForVoid . methodNames . isEmpty (  )  )  ;", "tb . getAge (  )  ;", "assertTrue (  \" Not   void :    shouldn ' t   have   intercepted \"  ,     . PointcutForVoid . methodNames . isEmpty (  )  )  ;", "tb . setAge (  1  )  ;", "tb . getAge (  )  ;", "tb . setName (  \" Tristan \"  )  ;", "tb . toString (  )  ;", "assertEquals (  \" Recorded   wrong   number   of   invocations \"  ,     2  ,     . PointcutForVoid . methodNames . size (  )  )  ;", "assertTrue (  . PointcutForVoid . methodNames . get (  0  )  . equals (  \" setAge \"  )  )  ;", "assertTrue (  . PointcutForVoid . methodNames . get (  1  )  . equals (  \" setName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodPointcuts"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT ,     . CLASS )  )  ;", "ITestBean   bean 1     =     (  ( ITestBean )     ( bf . getBean (  \" prototypeTestBeanProxy \"  )  )  )  ;", "ITestBean   bean 2     =     (  ( ITestBean )     ( bf . getBean (  \" prototypeTestBeanProxy \"  )  )  )  ;", "bean 1  . setAge (  3  )  ;", "bean 2  . setAge (  4  )  ;", "assertEquals (  3  ,    bean 1  . getAge (  )  )  ;", "assertEquals (  4  ,    bean 2  . getAge (  )  )  ;", "(  ( Lockable )     ( bean 1  )  )  . lock (  )  ;", "try    {", "bean 1  . setAge (  5  )  ;", "fail (  \" expected   LockedException \"  )  ;", "}    catch    ( LockedException   ex )     {", "}", "try    {", "bean 2  . setAge (  6  )  ;", "}    catch    ( LockedException   ex )     {", "fail (  \" did   not   expect   LockedException \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPrototypeAdvisor"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "int   INITIAL _ COUNT    =     1  0  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . PROTOTYPE _ CONTEXT ,     . CLASS )  )  ;", "SideEffectBean   raw    =     (  ( SideEffectBean )     ( bf . getBean (  \" prototypeTarget \"  )  )  )  ;", "assertEquals ( INITIAL _ COUNT ,    raw . getCount (  )  )  ;", "raw . doWork (  )  ;", "assertEquals (  ( INITIAL _ COUNT    +     1  )  ,    raw . getCount (  )  )  ;", "raw    =     (  ( SideEffectBean )     ( bf . getBean (  \" prototypeTarget \"  )  )  )  ;", "assertEquals ( INITIAL _ COUNT ,    raw . getCount (  )  )  ;", "SideEffectBean   prototype 2 FirstInstance    =     (  ( SideEffectBean )     ( bf . getBean ( beanName )  )  )  ;", "assertEquals ( INITIAL _ COUNT ,    prototype 2 FirstInstance . getCount (  )  )  ;", "prototype 2 FirstInstance . doWork (  )  ;", "assertEquals (  ( INITIAL _ COUNT    +     1  )  ,    prototype 2 FirstInstance . getCount (  )  )  ;", "SideEffectBean   prototype 2 SecondInstance    =     (  ( SideEffectBean )     ( bf . getBean ( beanName )  )  )  ;", "assertFalse (  \" Prototypes   are   not    =  =  \"  ,     ( prototype 2 FirstInstance    =  =    prototype 2 SecondInstance )  )  ;", "assertEquals ( INITIAL _ COUNT ,    prototype 2 SecondInstance . getCount (  )  )  ;", "assertEquals (  ( INITIAL _ COUNT    +     1  )  ,    prototype 2 FirstInstance . getCount (  )  )  ;", "return   prototype 2 FirstInstance ;", "}", "METHOD_END"], "methodName": ["testPrototypeInstancesAreIndependent"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Has   correct   object   type \"  ,    ITestBean . class . isAssignableFrom ( factory . getType (  \" prototype \"  )  )  )  ;", "ITestBean   test 2     =     (  ( ITestBean )     ( factory . getBean (  \" prototype \"  )  )  )  ;", "ITestBean   test 2  _  1     =     (  ( ITestBean )     ( factory . getBean (  \" prototype \"  )  )  )  ;", "assertTrue (  \" Prototype   instances    !  =  \"  ,     ( test 2     !  =    test 2  _  1  )  )  ;", "assertTrue (  \" Prototype   instances   equal \"  ,    test 2  . equals ( test 2  _  1  )  )  ;", "assertTrue (  \" Has   correct   object   type \"  ,    ITestBean . class . isAssignableFrom ( factory . getType (  \" prototype \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeInstancesAreNotEqual"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT ,     . CLASS )  )  ;", "ITestBean   bean 1     =     (  ( ITestBean )     ( bf . getBean (  \" prototypeTestBeanProxySingletonTarget \"  )  )  )  ;", "ITestBean   bean 2     =     (  ( ITestBean )     ( bf . getBean (  \" prototypeTestBeanProxySingletonTarget \"  )  )  )  ;", "bean 1  . setAge (  1  )  ;", "bean 2  . setAge (  2  )  ;", "assertEquals (  2  ,    bean 1  . getAge (  )  )  ;", "(  ( Lockable )     ( bean 1  )  )  . lock (  )  ;", "try    {", "bean 1  . setAge (  5  )  ;", "fail (  \" expected   LockedException \"  )  ;", "}    catch    ( LockedException   ex )     {", "}", "try    {", "bean 2  . setAge (  6  )  ;", "}    catch    ( LockedException   ex )     {", "fail (  \" did   not   expect   LockedException \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPrototypeInterceptorSingletonTarget"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . SERIALIZATION _ CONTEXT ,     . CLASS )  )  ;", "Person   p    =     (  ( Person )     ( bf . getBean (  \" interceptorNotSerializableSingleton \"  )  )  )  ;", "assertFalse (  \" Not   serializable   because   an   interceptor   isn ' t   serializable \"  ,    SerializationTestUtils . isSerializable ( p )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyNotSerializableBecauseOfAdvice"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . SERIALIZATION _ CONTEXT ,     . CLASS )  )  ;", "Person   p    =     (  ( Person )     ( bf . getBean (  \" serializablePrototype \"  )  )  )  ;", "assertNotSame (  \" Should   not   be   a   Singleton \"  ,    p ,    bf . getBean (  \" serializablePrototype \"  )  )  ;", "Person   p 2     =     (  ( Person )     ( SerializationTestUtils . serializeAndDeserialize ( p )  )  )  ;", "assertEquals ( p ,    p 2  )  ;", "assertNotSame ( p ,    p 2  )  ;", "assertEquals (  \" serializablePrototype \"  ,    p 2  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializablePrototypeProxy"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . SERIALIZATION _ CONTEXT ,     . CLASS )  )  ;", "Person   p    =     (  ( Person )     ( bf . getBean (  \" serializableSingleton \"  )  )  )  ;", "assertSame (  \" Should   be   a   Singleton \"  ,    p ,    bf . getBean (  \" serializableSingleton \"  )  )  ;", "Person   p 2     =     (  ( Person )     ( SerializationTestUtils . serializeAndDeserialize ( p )  )  )  ;", "assertEquals ( p ,    p 2  )  ;", "assertNotSame ( p ,    p 2  )  ;", "assertEquals (  \" serializableSingleton \"  ,    p 2  . getName (  )  )  ;", "Advice   nop    =    new   NopInterceptor (  )  ;", "(  ( Advised )     ( p )  )  . addAdvice ( nop )  ;", "assertEquals ( p 2  . getName (  )  ,    p 2  . getName (  )  )  ;", "assertFalse (  \" Not   serializable   because   an   interceptor   isn ' t   serializable \"  ,    SerializationTestUtils . isSerializable ( p )  )  ;", "assertTrue (  (  ( Advised )     ( p )  )  . removeAdvice ( nop )  )  ;", "assertTrue (  \" Serializable   again   because   offending   interceptor   was   removed \"  ,    SerializationTestUtils . isSerializable ( p )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializableSingletonProxy"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . SERIALIZATION _ CONTEXT ,     . CLASS )  )  ;", "Person   p    =     (  ( Person )     ( bf . getBean (  \" serializableSingleton \"  )  )  )  ;", "ProxyFactoryBean   pfb    =     (  ( ProxyFactoryBean )     ( bf . getBean (  \"  & serializableSingleton \"  )  )  )  ;", "ProxyFactoryBean   pfb 2     =     (  ( ProxyFactoryBean )     ( SerializationTestUtils . serializeAndDeserialize ( pfb )  )  )  ;", "Person   p 2     =     (  ( Person )     ( pfb 2  . getObject (  )  )  )  ;", "assertEquals ( p ,    p 2  )  ;", "assertNotSame ( p ,    p 2  )  ;", "assertEquals (  \" serializableSingleton \"  ,    p 2  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializableSingletonProxyFactoryBean"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   test 1     =     (  ( ITestBean )     ( factory . getBean (  \" test 1  \"  )  )  )  ;", "ITestBean   test 1  _  1     =     (  ( ITestBean )     ( factory . getBean (  \" test 1  \"  )  )  )  ;", "assertEquals (  \" Singleton   instances    =  =  \"  ,    test 1  ,    test 1  _  1  )  ;", "test 1  . setAge (  2  5  )  ;", "assertEquals ( test 1  . getAge (  )  ,    test 1  _  1  . getAge (  )  )  ;", "test 1  . setAge (  2  5  0  )  ;", "assertEquals ( test 1  . getAge (  )  ,    test 1  _  1  . getAge (  )  )  ;", "Advised   pc 1     =     (  ( Advised )     ( test 1  )  )  ;", "Advised   pc 2     =     (  ( Advised )     ( test 1  _  1  )  )  ;", "assertArrayEquals ( pc 1  . getAdvisors (  )  ,    pc 2  . getAdvisors (  )  )  ;", "int   oldLength    =    pc 1  . getAdvisors (  )  . length ;", "NopInterceptor   di    =    new   NopInterceptor (  )  ;", "pc 1  . addAdvice (  1  ,    di )  ;", "assertArrayEquals ( pc 1  . getAdvisors (  )  ,    pc 2  . getAdvisors (  )  )  ;", "assertEquals (  \" Now   have   one   more   advisor \"  ,     ( oldLength    +     1  )  ,    pc 2  . getAdvisors (  )  . length )  ;", "assertEquals ( di . getCount (  )  ,     0  )  ;", "test 1  . setAge (  5  )  ;", "assertEquals ( test 1  _  1  . getAge (  )  ,    test 1  . getAge (  )  )  ;", "assertEquals ( di . getCount (  )  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testSingletonInstancesAreEqual"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . INNER _ BEAN _ TARGET _ CONTEXT ,     . CLASS )  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( bf . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" innerBeanTarget \"  ,    itb . getName (  )  )  ;", "assertEquals (  \" Only   have   proxy   and   interceptor :    no   target \"  ,     3  ,    bf . getBeanDefinitionCount (  )  )  ;", ". DependsOnITestBean   doit    =     (  (  . DependsOnITestBean )     ( bf . getBean (  \" autowireCheck \"  )  )  )  ;", "assertSame ( itb ,    doit . tb )  ;", "}", "METHOD_END"], "methodName": ["testTargetAsInnerBean"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  . NOTLAST _ TARGETSOURCE _ CONTEXT ,     . CLASS )  )  ;", "bf . getBean (  \" targetSourceNotLast \"  )  ;", "fail (  \" TargetSource   or   non - advised   object   must   be   last   in   interceptorNames \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "AopConfigException   aex    =     (  ( AopConfigException )     ( ex . getCause (  )  )  )  ;", "assertTrue ( aex . getMessage (  )  . contains (  \" interceptorNames \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTargetSourceNotAtEndOfInterceptorNamesIsRejected"], "fileName": "org.springframework.aop.framework.ProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Advised   advised    =     (  ( Advised )     ( tb )  )  ;", "advisor    =    advised . gets (  )  [  0  ]  ;", "return    (  ( SimpleBeforeAdviceImpl )     ( advisor . getAdvice (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAdviceImpl"], "fileName": "org.springframework.aop.framework.adapter.AdvisorAdapterRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "GlobalAdvisorAdapterRegistry . reset (  )  ;", "}", "METHOD_END"], "methodName": ["resetGlobalAdvisorAdapterRegistry"], "fileName": "org.springframework.aop.framework.adapter.AdvisorAdapterRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - without - bpp . xml \"  )  ,    getClass (  )  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "try    {", "tb . getName (  )  ;", "fail (  \" Should   throw   UnknownAdviceTypeException \"  )  ;", "}    catch    ( UnknownAdviceTypeException   ex )     {", "assertEquals (  0  ,    getAdviceImpl ( tb )  . getInvocationCounter (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAdvisorAdapterRegistrationManagerNotPresentInContext"], "fileName": "org.springframework.aop.framework.adapter.AdvisorAdapterRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - with - bpp . xml \"  )  ,    getClass (  )  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "try    {", "tb . getName (  )  ;", "assertEquals (  1  ,    getAdviceImpl ( tb )  . getInvocationCounter (  )  )  ;", "}    catch    ( UnknownAdviceTypeException   ex )     {", "fail (  \" Should   not   throw   UnknownAdviceTypeException \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAdvisorAdapterRegistrationManagerPresentInContext"], "fileName": "org.springframework.aop.framework.adapter.AdvisorAdapterRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "return   invocationCounter ;", "}", "METHOD_END"], "methodName": ["getInvocationCounter"], "fileName": "org.springframework.aop.framework.adapter.SimpleBeforeAdviceImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathXmlApplicationContext ( AdvisorAutoProxyCreatorTests . DEFAULT _ CONTEXT ,    AdvisorAutoProxyCreatorTests . CLASS )  ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   bf    =    new   ClassPathXmlApplicationContext ( AdvisorAutoProxyCreatorTests . COMMON _ INTERCEPTORS _ CONTEXT ,    AdvisorAutoProxyCreatorTests . CLASS )  ;", "ITestBean   test 1     =     (  ( ITestBean )     ( bf . getBean (  \" test 1  \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( test 1  )  )  ;", "Lockable   lockable 1     =     (  ( Lockable )     ( test 1  )  )  ;", "NopInterceptor   nop 1     =     (  ( NopInterceptor )     ( bf . getBean (  \" nopInterceptor \"  )  )  )  ;", "NopInterceptor   nop 2     =     (  ( NopInterceptor )     ( bf . getBean (  \" pointcutAdvisor \"  ,    Advisor . class )  . getAdvice (  )  )  )  ;", "ITestBean   test 2     =     (  ( ITestBean )     ( bf . getBean (  \" test 2  \"  )  )  )  ;", "Lockable   lockable 2     =     (  ( Lockable )     ( test 2  )  )  ;", "assertFalse ( lockable 1  . locked (  )  )  ;", "assertFalse ( lockable 2  . locked (  )  )  ;", "assertEquals (  2  ,    nop 1  . getCount (  )  )  ;", "assertEquals (  0  ,    nop 2  . getCount (  )  )  ;", "lockable 1  . lock (  )  ;", "assertTrue ( lockable 1  . locked (  )  )  ;", "assertFalse ( lockable 2  . locked (  )  )  ;", "assertEquals (  5  ,    nop 1  . getCount (  )  )  ;", "assertEquals (  0  ,    nop 2  . getCount (  )  )  ;", "PackageVisibleMethod   packageVisibleMethod    =     (  ( PackageVisibleMethod )     ( bf . getBean (  \" packageVisibleMethod \"  )  )  )  ;", "assertEquals (  5  ,    nop 1  . getCount (  )  )  ;", "assertEquals (  0  ,    nop 2  . getCount (  )  )  ;", "packageVisibleMethod . doSomething (  )  ;", "assertEquals (  6  ,    nop 1  . getCount (  )  )  ;", "assertEquals (  1  ,    nop 2  . getCount (  )  )  ;", "assertTrue (  ( packageVisibleMethod   instanceof   Lockable )  )  ;", "Lockable   lockable 3     =     (  ( Lockable )     ( packageVisibleMethod )  )  ;", "lockable 3  . lock (  )  ;", "assertTrue ( lockable 3  . locked (  )  )  ;", "lockable 3  . unlock (  )  ;", "assertFalse ( lockable 3  . locked (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCommonInterceptorAndAdvisor"], "fileName": "org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "CountingTestBean . count    =     0  ;", "BeanFactory   bf    =    new   ClassPathXmlApplicationContext (  . CUSTOM _ TARGETSOURCE _ CONTEXT ,     . CLASS )  ;", "ITestBean   test    =     (  ( ITestBean )     ( bf . getBean (  \" prototypeTest \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( test )  )  ;", "Advised   advised    =     (  ( Advised )     ( test )  )  ;", "assertTrue (  (  ( advised . getTargetSource (  )  )    instanceof   PrototypeTargetSource )  )  ;", "assertEquals (  \" Rod \"  ,    test . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test . getSpouse (  )  . getName (  )  )  ;", "assertEquals (  \" Only    2    CountingTestBeans   instantiated \"  ,     2  ,    count )  ;", "CountingTestBean . count    =     0  ;", "}", "METHOD_END"], "methodName": ["testCustomPrototypeTargetSource"], "fileName": "org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   bf    =    new   ClassPathXmlApplicationContext ( AdvisorAutoProxyCreatorTests . CUSTOM _ TARGETSOURCE _ CONTEXT ,    AdvisorAutoProxyCreatorTests . CLASS )  ;", "ITestBean   test    =     (  ( ITestBean )     ( bf . getBean (  \" test \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( test )  )  ;", "assertEquals (  \" Rod \"  ,    test . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomTargetSourceNoMatch"], "fileName": "org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "CountingTestBean . count    =     0  ;", "BeanFactory   bf    =    new   ClassPathXmlApplicationContext (  . CUSTOM _ TARGETSOURCE _ CONTEXT ,     . CLASS )  ;", "ITestBean   test    =     (  ( ITestBean )     ( bf . getBean (  \" lazyInitTest \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( test )  )  ;", "Advised   advised    =     (  ( Advised )     ( test )  )  ;", "assertTrue (  (  ( advised . getTargetSource (  )  )    instanceof   LazyInitTargetSource )  )  ;", "assertEquals (  \" No   CountingTestBean   instantiated   yet \"  ,     0  ,    count )  ;", "assertEquals (  \" Rod \"  ,    test . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test . getSpouse (  )  . getName (  )  )  ;", "assertEquals (  \" Only    1    CountingTestBean   instantiated \"  ,     1  ,    count )  ;", "CountingTestBean . count    =     0  ;", "}", "METHOD_END"], "methodName": ["testLazyInitTargetSource"], "fileName": "org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   bf    =    new   ClassPathXmlApplicationContext ( AdvisorAutoProxyCreatorTests . QUICK _ TARGETSOURCE _ CONTEXT ,    AdvisorAutoProxyCreatorTests . CLASS )  ;", "ITestBean   test    =     (  ( ITestBean )     ( bf . getBean (  \" test \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( test )  )  ;", "assertEquals (  \" Rod \"  ,    test . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test . getSpouse (  )  . getName (  )  )  ;", "test    =     (  ( ITestBean )     ( bf . getBean (  \"  : test \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( test )  )  ;", "Advised   advised    =     (  ( Advised )     ( test )  )  ;", "assertTrue (  (  ( advised . getTargetSource (  )  )    instanceof   CommonsPool 2 TargetSource )  )  ;", "assertEquals (  \" Rod \"  ,    test . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test . getSpouse (  )  . getName (  )  )  ;", "test    =     (  ( ITestBean )     ( bf . getBean (  \"  % test \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( test )  )  ;", "advised    =     (  ( Advised )     ( test )  )  ;", "assertTrue (  (  ( advised . getTargetSource (  )  )    instanceof   ThreadLocalTargetSource )  )  ;", "assertEquals (  \" Rod \"  ,    test . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test . getSpouse (  )  . getName (  )  )  ;", "test    =     (  ( ITestBean )     ( bf . getBean (  \"  ! test \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( test )  )  ;", "advised    =     (  ( Advised )     ( test )  )  ;", "assertTrue (  (  ( advised . getTargetSource (  )  )    instanceof   PrototypeTargetSource )  )  ;", "assertEquals (  \" Rod \"  ,    test . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test . getSpouse (  )  . getName (  )  )  ;", "ITestBean   test 2     =     (  ( ITestBean )     ( bf . getBean (  \"  ! test \"  )  )  )  ;", "assertFalse (  \" Prototypes   cannot   be   the   same   object \"  ,     ( test    =  =    test 2  )  )  ;", "assertEquals (  \" Rod \"  ,    test 2  . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test 2  . getSpouse (  )  . getName (  )  )  ;", "bf . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQuickTargetSourceCreator"], "fileName": "org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    new   ClassPathXmlApplicationContext ( AdvisorAutoProxyCreatorTests . OPTIMIZED _ CONTEXT ,    AdvisorAutoProxyCreatorTests . CLASS )  ;", "ITestBean   testBean    =     (  ( ITestBean )     ( beanFactory . getBean (  \" optimizedTestBean \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( testBean )  )  ;", "CountingBeforeAdvice   beforeAdvice    =     (  ( CountingBeforeAdvice )     ( beanFactory . getBean (  \" countingAdvice \"  )  )  )  ;", "testBean . setAge (  2  3  )  ;", "testBean . getAge (  )  ;", "assertEquals (  \" Incorrect   number   of   calls   to   proxy \"  ,     2  ,    beforeAdvice . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithOptimizedProxy"], "fileName": "org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "sac . registerSingleton (  \" testAutoProxyCreator \"  ,     . TestAutoProxyCreator . class )  ;", "sac . registerSingleton (  \" singletonFactoryToBeProxied \"  ,    DummyFactory . class )  ;", "sac . refresh (  )  ;", ". TestAutoProxyCreator   tapc    =     (  (  . TestAutoProxyCreator )     ( sac . getBean (  \" testAutoProxyCreator \"  )  )  )  ;", "tapc . testInterceptor . nrOfInvocations    =     0  ;", "FactoryBean <  ?  >    factory    =     (  ( FactoryBean <  ?  >  )     ( sac . getBean (  \"  & singletonFactoryToBeProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( factory )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( sac . getBean (  \" singletonFactoryToBeProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( tb )  )  ;", "assertEquals (  2  ,    tapc . testInterceptor . nrOfInvocations )  ;", "tb . getAge (  )  ;", "assertEquals (  3  ,    tapc . testInterceptor . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testAutoProxyCreatorWithFactoryBean"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "sac . registerSingleton (  \" testAutoProxyCreator \"  ,     . TestAutoProxyCreator . class )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" singleton \"  ,     \" false \"  )  ;", "sac . registerSingleton (  \" prototypeFactoryToBeProxied \"  ,    DummyFactory . class ,    pvs )  ;", "sac . refresh (  )  ;", ". TestAutoProxyCreator   tapc    =     (  (  . TestAutoProxyCreator )     ( sac . getBean (  \" testAutoProxyCreator \"  )  )  )  ;", "tapc . testInterceptor . nrOfInvocations    =     0  ;", "FactoryBean <  ?  >    prototypeFactory    =     (  ( FactoryBean <  ?  >  )     ( sac . getBean (  \"  & prototypeFactoryToBeProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( prototypeFactory )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( sac . getBean (  \" prototypeFactoryToBeProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( tb )  )  ;", "assertEquals (  2  ,    tapc . testInterceptor . nrOfInvocations )  ;", "tb . getAge (  )  ;", "assertEquals (  3  ,    tapc . testInterceptor . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testAutoProxyCreatorWithFactoryBeanAndPrototype"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" proxyObject \"  ,     \" false \"  )  ;", "sac . registerSingleton (  \" testAutoProxyCreator \"  ,     . TestAutoProxyCreator . class ,    pvs )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" singleton \"  ,     \" false \"  )  ;", "sac . registerSingleton (  \" prototypeFactoryToBeProxied \"  ,    DummyFactory . class ,    pvs )  ;", "sac . refresh (  )  ;", ". TestAutoProxyCreator   tapc    =     (  (  . TestAutoProxyCreator )     ( sac . getBean (  \" testAutoProxyCreator \"  )  )  )  ;", "tapc . testInterceptor . nrOfInvocations    =     0  ;", "FactoryBean <  ?  >    prototypeFactory    =     (  ( FactoryBean <  ?  >  )     ( sac . getBean (  \"  & prototypeFactoryToBeProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( prototypeFactory )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( sac . getBean (  \" prototypeFactoryToBeProxied \"  )  )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( tb )  )  ;", "assertEquals (  2  ,    tapc . testInterceptor . nrOfInvocations )  ;", "tb . getAge (  )  ;", "assertEquals (  2  ,    tapc . testInterceptor . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testAutoProxyCreatorWithFactoryBeanAndProxyFactoryBeanOnly"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" proxyFactoryBean \"  ,     \" false \"  )  ;", "sac . registerSingleton (  \" testAutoProxyCreator \"  ,     . TestAutoProxyCreator . class ,    pvs )  ;", "sac . registerSingleton (  \" singletonFactoryToBeProxied \"  ,    DummyFactory . class )  ;", "sac . refresh (  )  ;", ". TestAutoProxyCreator   tapc    =     (  (  . TestAutoProxyCreator )     ( sac . getBean (  \" testAutoProxyCreator \"  )  )  )  ;", "tapc . testInterceptor . nrOfInvocations    =     0  ;", "FactoryBean <  ?  >    factory    =     (  ( FactoryBean <  ?  >  )     ( sac . getBean (  \"  & singletonFactoryToBeProxied \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( factory )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( sac . getBean (  \" singletonFactoryToBeProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( tb )  )  ;", "assertEquals (  0  ,    tapc . testInterceptor . nrOfInvocations )  ;", "tb . getAge (  )  ;", "assertEquals (  1  ,    tapc . testInterceptor . nrOfInvocations )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( sac . getBean (  \" singletonFactoryToBeProxied \"  )  )  )  ;", "assertSame ( tb ,    tb 2  )  ;", "assertEquals (  1  ,    tapc . testInterceptor . nrOfInvocations )  ;", "tb 2  . getAge (  )  ;", "assertEquals (  2  ,    tapc . testInterceptor . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testAutoProxyCreatorWithFactoryBeanAndProxyObjectOnly"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" proxyFactoryBean \"  ,     \" false \"  )  ;", "sac . registerSingleton (  \" testAutoProxyCreator \"  ,     . TestAutoProxyCreator . class ,    pvs )  ;", "sac . registerSingleton (  \" noInterfaces \"  ,     . NoInterfaces . class )  ;", "sac . registerSingleton (  \" containerCallbackInterfacesOnly \"  ,     . ContainerCallbackInterfacesOnly . class )  ;", "sac . registerSingleton (  \" singletonNoInterceptor \"  ,     . CustomProxyFactoryBean . class )  ;", "sac . registerSingleton (  \" singletonToBeProxied \"  ,     . CustomProxyFactoryBean . class )  ;", "sac . registerPrototype (  \" prototypeToBeProxied \"  ,     . SpringProxyFactoryBean . class )  ;", "sac . refresh (  )  ;", "MessageSource   messageSource    =     (  ( MessageSource )     ( sac . getBean (  \" messageSource \"  )  )  )  ;", ". NoInterfaces   noInterfaces    =     (  (  . NoInterfaces )     ( sac . getBean (  \" noInterfaces \"  )  )  )  ;", ". ContainerCallbackInterfacesOnly   containerCallbackInterfacesOnly    =     (  (  . ContainerCallbackInterfacesOnly )     ( sac . getBean (  \" containerCallbackInterfacesOnly \"  )  )  )  ;", "ITestBean   singletonNoInterceptor    =     (  ( ITestBean )     ( sac . getBean (  \" singletonNoInterceptor \"  )  )  )  ;", "ITestBean   singletonToBeProxied    =     (  ( ITestBean )     ( sac . getBean (  \" singletonToBeProxied \"  )  )  )  ;", "ITestBean   prototypeToBeProxied    =     (  ( ITestBean )     ( sac . getBean (  \" prototypeToBeProxied \"  )  )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( messageSource )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( noInterfaces )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( containerCallbackInterfacesOnly )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( singletonNoInterceptor )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( singletonToBeProxied )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( prototypeToBeProxied )  )  ;", ". TestAutoProxyCreator   tapc    =     (  (  . TestAutoProxyCreator )     ( sac . getBean (  \" testAutoProxyCreator \"  )  )  )  ;", "assertEquals (  0  ,    tapc . testInterceptor . nrOfInvocations )  ;", "singletonNoInterceptor . getName (  )  ;", "assertEquals (  0  ,    tapc . testInterceptor . nrOfInvocations )  ;", "singletonToBeProxied . getAge (  )  ;", "assertEquals (  1  ,    tapc . testInterceptor . nrOfInvocations )  ;", "prototypeToBeProxied . getSpouse (  )  ;", "assertEquals (  2  ,    tapc . testInterceptor . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testAutoProxyCreatorWithFallbackToDynamicProxy"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "sac . registerSingleton (  \" testAutoProxyCreator \"  ,     . FallbackTestAutoProxyCreator . class )  ;", "sac . registerSingleton (  \" noInterfaces \"  ,     . NoInterfaces . class )  ;", "sac . registerSingleton (  \" containerCallbackInterfacesOnly \"  ,     . ContainerCallbackInterfacesOnly . class )  ;", "sac . registerSingleton (  \" singletonNoInterceptor \"  ,    TestBean . class )  ;", "sac . registerSingleton (  \" singletonToBeProxied \"  ,    TestBean . class )  ;", "sac . registerPrototype (  \" prototypeToBeProxied \"  ,    TestBean . class )  ;", "sac . refresh (  )  ;", "MessageSource   messageSource    =     (  ( MessageSource )     ( sac . getBean (  \" messageSource \"  )  )  )  ;", ". NoInterfaces   noInterfaces    =     (  (  . NoInterfaces )     ( sac . getBean (  \" noInterfaces \"  )  )  )  ;", ". ContainerCallbackInterfacesOnly   containerCallbackInterfacesOnly    =     (  (  . ContainerCallbackInterfacesOnly )     ( sac . getBean (  \" containerCallbackInterfacesOnly \"  )  )  )  ;", "ITestBean   singletonNoInterceptor    =     (  ( ITestBean )     ( sac . getBean (  \" singletonNoInterceptor \"  )  )  )  ;", "ITestBean   singletonToBeProxied    =     (  ( ITestBean )     ( sac . getBean (  \" singletonToBeProxied \"  )  )  )  ;", "ITestBean   prototypeToBeProxied    =     (  ( ITestBean )     ( sac . getBean (  \" prototypeToBeProxied \"  )  )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( messageSource )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( noInterfaces )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( containerCallbackInterfacesOnly )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( singletonNoInterceptor )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( singletonToBeProxied )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( prototypeToBeProxied )  )  ;", ". TestAutoProxyCreator   tapc    =     (  (  . TestAutoProxyCreator )     ( sac . getBean (  \" testAutoProxyCreator \"  )  )  )  ;", "assertEquals (  0  ,    tapc . testInterceptor . nrOfInvocations )  ;", "singletonNoInterceptor . getName (  )  ;", "assertEquals (  0  ,    tapc . testInterceptor . nrOfInvocations )  ;", "singletonToBeProxied . getAge (  )  ;", "assertEquals (  1  ,    tapc . testInterceptor . nrOfInvocations )  ;", "prototypeToBeProxied . getSpouse (  )  ;", "assertEquals (  2  ,    tapc . testInterceptor . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testAutoProxyCreatorWithFallbackToTargetClass"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "sac . registerSingleton (  \" testAutoProxyCreator \"  ,     . TestAutoProxyCreator . class )  ;", "sac . registerSingleton (  \" packageVisibleMethodToBeProxied \"  ,    PackageVisibleMethod . class )  ;", "sac . refresh (  )  ;", ". TestAutoProxyCreator   tapc    =     (  (  . TestAutoProxyCreator )     ( sac . getBean (  \" testAutoProxyCreator \"  )  )  )  ;", "tapc . testInterceptor . nrOfInvocations    =     0  ;", "PackageVisibleMethod   tb    =     (  ( PackageVisibleMethod )     ( sac . getBean (  \" packageVisibleMethodToBeProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( tb )  )  ;", "assertEquals (  0  ,    tapc . testInterceptor . nrOfInvocations )  ;", "tb . doSomething (  )  ;", "assertEquals (  1  ,    tapc . testInterceptor . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testAutoProxyCreatorWithPackageVisibleMethod"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "sac . registerSingleton (  \" testInterceptor \"  ,     . TestInterceptor . class )  ;", "RootBeanDefinition   proxyCreator    =    new   RootBeanDefinition ( BeanNameAutoProxyCreator . class )  ;", "proxyCreator . getPropertyValues (  )  . add (  \" interceptorNames \"  ,     \" testInterceptor \"  )  ;", "proxyCreator . getPropertyValues (  )  . add (  \" beanNames \"  ,     \" singletonToBeProxied , innerBean , singletonFactoryToBeProxied \"  )  ;", "sac . getDefaultListableBeanFactory (  )  . registerBeanDefinition (  \" beanNameAutoProxyCreator \"  ,    proxyCreator )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setAutowireMode ( AUTOWIRE _ BY _ TYPE )  ;", "RootBeanDefinition   innerBean    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" spouse \"  ,    new   BeanDefinitionHolder ( innerBean ,     \" innerBean \"  )  )  ;", "sac . getDefaultListableBeanFactory (  )  . registerBeanDefinition (  \" singletonToBeProxied \"  ,    bd )  ;", "sac . registerSingleton (  \" singletonFactoryToBeProxied \"  ,    DummyFactory . class )  ;", "sac . registerSingleton (  \" autowiredIndexedTestBean \"  ,    IndexedTestBean . class )  ;", "sac . refresh (  )  ;", "MessageSource   messageSource    =     (  ( MessageSource )     ( sac . getBean (  \" messageSource \"  )  )  )  ;", "ITestBean   singletonToBeProxied    =     (  ( ITestBean )     ( sac . getBean (  \" singletonToBeProxied \"  )  )  )  ;", "assertFalse ( Proxy . isProxyClass ( messageSource . getClass (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( singletonToBeProxied . getClass (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( singletonToBeProxied . getSpouse (  )  . getClass (  )  )  )  ;", "assertEquals ( sac . getBean (  \" autowiredIndexedTestBean \"  )  ,    singletonToBeProxied . getNestedIndexedBean (  )  )  ;", ". TestInterceptor   ti    =     (  (  . TestInterceptor )     ( sac . getBean (  \" testInterceptor \"  )  )  )  ;", "assertEquals (  2  ,    ti . nrOfInvocations )  ;", "singletonToBeProxied . getName (  )  ;", "singletonToBeProxied . getSpouse (  )  . getName (  )  ;", "assertEquals (  5  ,    ti . nrOfInvocations )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( sac . getBean (  \" singletonFactoryToBeProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( tb )  )  ;", "assertEquals (  5  ,    ti . nrOfInvocations )  ;", "tb . getAge (  )  ;", "assertEquals (  6  ,    ti . nrOfInvocations )  ;", "ITestBean   tb 2     =     (  ( ITestBean )     ( sac . getBean (  \" singletonFactoryToBeProxied \"  )  )  )  ;", "assertSame ( tb ,    tb 2  )  ;", "assertEquals (  6  ,    ti . nrOfInvocations )  ;", "tb 2  . getAge (  )  ;", "assertEquals (  7  ,    ti . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testBeanNameAutoProxyCreator"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "sac . registerSingleton (  \" testInterceptor \"  ,     . TestInterceptor . class )  ;", "RootBeanDefinition   proxyCreator    =    new   RootBeanDefinition ( BeanNameAutoProxyCreator . class )  ;", "proxyCreator . getPropertyValues (  )  . add (  \" interceptorNames \"  ,     \" testInterceptor \"  )  ;", "proxyCreator . getPropertyValues (  )  . add (  \" beanNames \"  ,     \" singletonToBeProxied ,  & singletonFactoryToBeProxied \"  )  ;", "sac . getDefaultListableBeanFactory (  )  . registerBeanDefinition (  \" beanNameAutoProxyCreator \"  ,    proxyCreator )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "sac . getDefaultListableBeanFactory (  )  . registerBeanDefinition (  \" singletonToBeProxied \"  ,    bd )  ;", "sac . registerSingleton (  \" singletonFactoryToBeProxied \"  ,    DummyFactory . class )  ;", "sac . refresh (  )  ;", "ITestBean   singletonToBeProxied    =     (  ( ITestBean )     ( sac . getBean (  \" singletonToBeProxied \"  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( singletonToBeProxied . getClass (  )  )  )  ;", ". TestInterceptor   ti    =     (  (  . TestInterceptor )     ( sac . getBean (  \" testInterceptor \"  )  )  )  ;", "int   initialNr    =    ti . nrOfInvocations ;", "singletonToBeProxied . getName (  )  ;", "assertEquals (  ( initialNr    +     1  )  ,    ti . nrOfInvocations )  ;", "FactoryBean <  ?  >    factory    =     (  ( FactoryBean <  ?  >  )     ( sac . getBean (  \"  & singletonFactoryToBeProxied \"  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( factory . getClass (  )  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( sac . getBean (  \" singletonFactoryToBeProxied \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( tb )  )  ;", "assertEquals (  ( initialNr    +     3  )  ,    ti . nrOfInvocations )  ;", "tb . getAge (  )  ;", "assertEquals (  ( initialNr    +     3  )  ,    ti . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testBeanNameAutoProxyCreatorWithFactoryBeanProxy"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   sac    =    new   StaticApplicationContext (  )  ;", "sac . registerSingleton (  \" testAutoProxyCreator \"  ,     . TestAutoProxyCreator . class )  ;", "sac . registerSingleton (  \" noInterfaces \"  ,     . NoInterfaces . class )  ;", "sac . registerSingleton (  \" containerCallbackInterfacesOnly \"  ,     . ContainerCallbackInterfacesOnly . class )  ;", "sac . registerSingleton (  \" singletonNoInterceptor \"  ,    TestBean . class )  ;", "sac . registerSingleton (  \" singletonToBeProxied \"  ,    TestBean . class )  ;", "sac . registerPrototype (  \" prototypeToBeProxied \"  ,    TestBean . class )  ;", "sac . refresh (  )  ;", "MessageSource   messageSource    =     (  ( MessageSource )     ( sac . getBean (  \" messageSource \"  )  )  )  ;", ". NoInterfaces   noInterfaces    =     (  (  . NoInterfaces )     ( sac . getBean (  \" noInterfaces \"  )  )  )  ;", ". ContainerCallbackInterfacesOnly   containerCallbackInterfacesOnly    =     (  (  . ContainerCallbackInterfacesOnly )     ( sac . getBean (  \" containerCallbackInterfacesOnly \"  )  )  )  ;", "ITestBean   singletonNoInterceptor    =     (  ( ITestBean )     ( sac . getBean (  \" singletonNoInterceptor \"  )  )  )  ;", "ITestBean   singletonToBeProxied    =     (  ( ITestBean )     ( sac . getBean (  \" singletonToBeProxied \"  )  )  )  ;", "ITestBean   prototypeToBeProxied    =     (  ( ITestBean )     ( sac . getBean (  \" prototypeToBeProxied \"  )  )  )  ;", "assertFalse ( AopUtils . isCglibProxy ( messageSource )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( noInterfaces )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( containerCallbackInterfacesOnly )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( singletonNoInterceptor )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( singletonToBeProxied )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( prototypeToBeProxied )  )  ;", ". TestAutoProxyCreator   tapc    =     (  (  . TestAutoProxyCreator )     ( sac . getBean (  \" testAutoProxyCreator \"  )  )  )  ;", "assertEquals (  0  ,    tapc . testInterceptor . nrOfInvocations )  ;", "singletonNoInterceptor . getName (  )  ;", "assertEquals (  0  ,    tapc . testInterceptor . nrOfInvocations )  ;", "singletonToBeProxied . getAge (  )  ;", "assertEquals (  1  ,    tapc . testInterceptor . nrOfInvocations )  ;", "prototypeToBeProxied . getSpouse (  )  ;", "assertEquals (  2  ,    tapc . testInterceptor . nrOfInvocations )  ;", "}", "METHOD_END"], "methodName": ["testCustomAutoProxyCreator"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "TestBean   bean    =     (  ( TestBean )     ( ctx . getBean (  \" bean \"  )  )  )  ;", "bean . setName (  \" foo \"  )  ;", "assertEquals (  \" foo \"  ,    bean . getName (  )  )  ;", "bean . setName ( null )  ;", "}", "METHOD_END"], "methodName": ["testIgnoreAdvisorThatIsCurrentlyInCreation"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorInitTests"}, {"methodBody": ["METHOD_START", "{", "CountingBeforeAdvice   cba    =     (  ( CountingBeforeAdvice )     ( beanFactory . getBean (  \" countingBeforeAdvice \"  )  )  )  ;", "NopInterceptor   nop    =     (  ( NopInterceptor )     ( beanFactory . getBean (  \" nopInterceptor \"  )  )  )  ;", "assertEquals (  0  ,    cba . getCalls (  )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "assertTrue ( AopUtils . isCglib ( tb )  )  ;", "int   age    =     5  ;", "tb . setAge ( age )  ;", "assertEquals ( age ,    tb . getAge (  )  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "assertEquals (  2  ,    cba . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["cglibAssertions"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "NopInterceptor   nop    =     (  ( NopInterceptor )     ( beanFactory . getBean (  \" nopInterceptor \"  )  )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "assertTrue ( AopUtils . isJdkDynamic ( tb )  )  ;", "int   age    =     5  ;", "tb . setAge ( age )  ;", "assertEquals ( age ,    tb . getAge (  )  )  ;", "assertEquals (  (  2     *    nopInterceptorCount )  ,    nop . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["jdkAssertions"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory    =    new   ClassPathXmlApplicationContext (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =     (  ( TestBean )     ( beanFactory . getBean (  \" cglib 1  \"  )  )  )  ;", "cglibAssertions ( tb )  ;", "assertEquals (  \" cglib 1  \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCglibProxyWithWildcardMatch"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   tb    =     (  ( ITestBean )     ( beanFactory . getBean (  \" introductionUsingJdk \"  )  )  )  ;", "NopInterceptor   nop    =     (  ( NopInterceptor )     ( beanFactory . getBean (  \" introductionNopInterceptor \"  )  )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "assertTrue ( AopUtils . isJdkDynamic ( tb )  )  ;", "int   age    =     5  ;", "tb . setAge ( age )  ;", "assertEquals ( age ,    tb . getAge (  )  )  ;", "assertTrue (  \" Introduction   was   made \"  ,     ( tb   instanceof   TimeStamped )  )  ;", "assertEquals (  0  ,     (  ( TimeStamped )     ( tb )  )  . getTimeStamp (  )  )  ;", "assertEquals (  3  ,    nop . getCount (  )  )  ;", "assertEquals (  \" introductionUsingJdk \"  ,    tb . getName (  )  )  ;", "ITestBean   tb 2     =     (  ( ITestBean )     ( beanFactory . getBean (  \" second - introductionUsingJdk \"  )  )  )  ;", "Lockable   lockable 1     =     (  ( Lockable )     ( tb )  )  ;", "Lockable   lockable 2     =     (  ( Lockable )     ( tb 2  )  )  ;", "assertFalse ( lockable 1  . locked (  )  )  ;", "assertFalse ( lockable 2  . locked (  )  )  ;", "tb . setAge (  6  5  )  ;", "assertEquals (  6  5  ,    tb . getAge (  )  )  ;", "lockable 1  . lock (  )  ;", "assertTrue ( lockable 1  . locked (  )  )  ;", "assertFalse ( lockable 2  . locked (  )  )  ;", "tb 2  . setAge (  1  2  )  ;", "try    {", "tb . setAge (  6  )  ;", "fail (  \" Mixin   should   have   locked   this   object \"  )  ;", "}    catch    ( LockedException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testJdkIntroduction"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   tb    =     (  ( ITestBean )     ( beanFactory . getBean (  \" factory - introductionUsingJdk \"  )  )  )  ;", "NopInterceptor   nop    =     (  ( NopInterceptor )     ( beanFactory . getBean (  \" introductionNopInterceptor \"  )  )  )  ;", "assertEquals (  \" NOP   should   not   have   done   any   work   yet \"  ,     0  ,    nop . getCount (  )  )  ;", "assertTrue ( AopUtils . isJdkDynamic ( tb )  )  ;", "int   age    =     5  ;", "tb . setAge ( age )  ;", "assertEquals ( age ,    tb . getAge (  )  )  ;", "assertTrue (  \" Introduction   was   made \"  ,     ( tb   instanceof   TimeStamped )  )  ;", "assertEquals (  0  ,     (  ( TimeStamped )     ( tb )  )  . getTimeStamp (  )  )  ;", "assertEquals (  3  ,    nop . getCount (  )  )  ;", "ITestBean   tb 2     =     (  ( ITestBean )     ( beanFactory . getBean (  \" second - introductionUsingJdk \"  )  )  )  ;", "Lockable   lockable 1     =     (  ( Lockable )     ( tb )  )  ;", "Lockable   lockable 2     =     (  ( Lockable )     ( tb 2  )  )  ;", "assertFalse ( lockable 1  . locked (  )  )  ;", "assertFalse ( lockable 2  . locked (  )  )  ;", "tb . setAge (  6  5  )  ;", "assertEquals (  6  5  ,    tb . getAge (  )  )  ;", "lockable 1  . lock (  )  ;", "assertTrue ( lockable 1  . locked (  )  )  ;", "assertFalse ( lockable 2  . locked (  )  )  ;", "tb 2  . setAge (  1  2  )  ;", "try    {", "tb . setAge (  6  )  ;", "fail (  \" Mixin   should   have   locked   this   object \"  )  ;", "}    catch    ( LockedException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testJdkIntroductionAppliesToCreatedObjectsNotFactoryBean"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   tb    =     (  ( ITestBean )     ( beanFactory . getBean (  \" doubleJdk \"  )  )  )  ;", "jdkAssertions ( tb ,     2  )  ;", "assertEquals (  \" doubleJdk \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJdkProxyWithDoubleProxying"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   tb    =     (  ( ITestBean )     ( beanFactory . getBean (  \" onlyJdk \"  )  )  )  ;", "jdkAssertions ( tb ,     1  )  ;", "assertEquals (  \" onlyJdk \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJdkProxyWithExactNameMatch"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   tb    =     (  ( ITestBean )     ( beanFactory . getBean (  \" jdk 1  \"  )  )  )  ;", "jdkAssertions ( tb ,     1  )  ;", "assertEquals (  \" jdk 1  \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJdkProxyWithWildcardMatch"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =     (  ( TestBean )     ( beanFactory . getBean (  \" noproxy \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( tb )  )  ;", "assertEquals (  \" noproxy \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoProxy"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   testBean    =     (  ( ITestBean )     ( beanFactory . getBean (  \" frozenBean \"  )  )  )  ;", "assertTrue (  (  ( Advised )     ( testBean )  )  . isFrozen (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithFrozenProxy"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( args . length )  ;    i +  +  )     {", "if    (  ( args [ i ]  )     =  =    null )     {", "throw   new   IllegalArgumentException (  (  \"    argument   at   position    \"     +    i )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["check"], "fileName": "org.springframework.aop.framework.autoproxy.NullChecker"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( ScopedProxyTests . LIST _ CONTEXT )  ;", "bf . setSerializationId (  \" Y \"  )  ;", "SimpleMapScope   scope    =    new   SimpleMapScope (  )  ;", "bf . registerScope (  \" request \"  ,    scope )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" testBean \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( tb . getFriends (  )  )  )  ;", "assertTrue (  (  ( tb . getFriends (  )  )    instanceof   ScopedObject )  )  ;", "ScopedObject   scoped    =     (  ( ScopedObject )     ( tb . getFriends (  )  )  )  ;", "assertEquals ( ArrayList . class ,    scoped . getTargetObject (  )  . getClass (  )  )  ;", "tb . getFriends (  )  . add (  \" myFriend \"  )  ;", "assertTrue ( scope . getMap (  )  . containsKey (  \" scopedTarget . scopedList \"  )  )  ;", "assertEquals ( ArrayList . class ,    scope . getMap (  )  . get (  \" scopedTarget . scopedList \"  )  . getClass (  )  )  ;", "ArrayList <  ?  >    deserialized    =     (  ( ArrayList <  ?  >  )     ( SerializationTestUtils . serializeAndDeserialize ( tb . getFriends (  )  )  )  )  ;", "assertNotNull ( deserialized )  ;", "assertTrue ( AopUtils . isCglibProxy ( deserialized )  )  ;", "assertTrue ( deserialized . contains (  \" myFriend \"  )  )  ;", "assertTrue (  ( deserialized   instanceof   ScopedObject )  )  ;", "ScopedObject   scopedDeserialized    =     (  ( ScopedObject )     ( deserialized )  )  ;", "assertEquals ( ArrayList . class ,    scopedDeserialized . getTargetObject (  )  . getClass (  )  )  ;", "bf . setSerializationId ( null )  ;", "}", "METHOD_END"], "methodName": ["testCglibScopedProxy"], "fileName": "org.springframework.aop.scope.ScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( ScopedProxyTests . TESTBEAN _ CONTEXT )  ;", "bf . setSerializationId (  \" X \"  )  ;", "SimpleMapScope   scope    =    new   SimpleMapScope (  )  ;", "bf . registerScope (  \" request \"  ,    scope )  ;", "ITestBean   bean    =     (  ( ITestBean )     ( bf . getBean (  \" testBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( bean )  )  ;", "assertTrue (  ( bean   instanceof   ScopedObject )  )  ;", "ScopedObject   scoped    =     (  ( ScopedObject )     ( bean )  )  ;", "assertEquals ( TestBean . class ,    scoped . getTargetObject (  )  . getClass (  )  )  ;", "bean . setAge (  1  0  1  )  ;", "assertTrue ( scope . getMap (  )  . containsKey (  \" testBeanTarget \"  )  )  ;", "assertEquals ( TestBean . class ,    scope . getMap (  )  . get (  \" testBeanTarget \"  )  . getClass (  )  )  ;", "ITestBean   deserialized    =     (  ( ITestBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertNotNull ( deserialized )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( deserialized )  )  ;", "assertEquals (  1  0  1  ,    bean . getAge (  )  )  ;", "assertTrue (  ( deserialized   instanceof   ScopedObject )  )  ;", "ScopedObject   scopedDeserialized    =     (  ( ScopedObject )     ( deserialized )  )  ;", "assertEquals ( TestBean . class ,    scopedDeserialized . getTargetObject (  )  . getClass (  )  )  ;", "bf . setSerializationId ( null )  ;", "}", "METHOD_END"], "methodName": ["testJdkScopedProxy"], "fileName": "org.springframework.aop.scope.ScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( ScopedProxyTests . MAP _ CONTEXT )  ;", "Object   baseMap    =    bf . getBean (  \" singletonMap \"  )  ;", "assertTrue (  ( baseMap   instanceof   Map )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyAssignable"], "fileName": "org.springframework.aop.scope.ScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "new   XmlBeanDefinitionReader ( ctx )  . loadBeanDefinitions (  . OVERRIDE _ CONTEXT )  ;", "SimpleMapScope   scope    =    new   SimpleMapScope (  )  ;", "ctx . getBeanFactory (  )  . registerScope (  \" request \"  ,    scope )  ;", "ctx . refresh (  )  ;", "ITestBean   bean    =     (  ( ITestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" male \"  ,    bean . getName (  )  )  ;", "assertEquals (  9  9  ,    bean . getAge (  )  )  ;", "assertTrue ( scope . getMap (  )  . containsKey (  \" scopedTarget . testBean \"  )  )  ;", "assertEquals ( TestBean . class ,    scope . getMap (  )  . get (  \" scopedTarget . testBean \"  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedOverride"], "fileName": "org.springframework.aop.scope.ScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( ScopedProxyTests . MAP _ CONTEXT )  ;", "Object   simpleMap    =    bf . getBean (  \" simpleMap \"  )  ;", "assertTrue (  ( simpleMap   instanceof   Map )  )  ;", "assertTrue (  ( simpleMap   instanceof   HashMap )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleProxy"], "fileName": "org.springframework.aop.scope.ScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" target \"  ;", "StaticApplicationContext   applicationContext    =    new   StaticApplicationContext (  )  ;", "applicationContext . registerPrototype ( beanName ,    SerializablePerson . class )  ;", "t . setTargetBeanName ( beanName )  ;", "t . setBeanFactory ( applicationContext )  ;", "}", "METHOD_END"], "methodName": ["prepareTargetSource"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "CommonsPool 2 TargetSource   targetSource    =    new   CommonsPool 2 TargetSource (  )  ;", "targetSource . setMaxWait (  1  )  ;", "prepareTargetSource ( targetSource )  ;", "Object   first    =    targetSource . getTarget (  )  ;", "Object   second    =    targetSource . getTarget (  )  ;", "assertTrue (  ( first   instanceof   SerializablePerson )  )  ;", "assertTrue (  ( second   instanceof   SerializablePerson )  )  ;", "assertEquals ( first ,    second )  ;", "targetSource . releaseTarget ( first )  ;", "targetSource . releaseTarget ( second )  ;", "}", "METHOD_END"], "methodName": ["referenceIdentityByDefault"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( this . beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - context . xml \"  )  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SideEffectBean   pooled    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" pooledWithMixin \"  )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    pooled . getCount (  )  )  ;", "PoolingConfig   conf    =     (  ( PoolingConfig )     ( beanFactory . getBean (  \" pooledWithMixin \"  )  )  )  ;", "pooled . doWork (  )  ;", "assertEquals (  \" Correct   target   source \"  ,     2  5  ,    conf . getMaxSize (  )  )  ;", "assertEquals (  2  5  ,    conf . getMaxSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConfigMixin"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "testFunctionality (  \" pooled \"  )  ;", "}", "METHOD_END"], "methodName": ["testFunctionality"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SideEffectBean   pooled    =     (  ( SideEffectBean )     ( beanFactory . getBean ( name )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    pooled . getCount (  )  )  ;", "pooled . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     1  )  ,    pooled . getCount (  )  )  ;", "pooled    =     (  ( SideEffectBean )     ( beanFactory . getBean ( name )  )  )  ;", "pooled . doWork (  )  ;", "}", "METHOD_END"], "methodName": ["testFunctionality"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "testFunctionality (  \" pooledNoInterceptors \"  )  ;", "}", "METHOD_END"], "methodName": ["testFunctionalityWithNoInterceptors"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "int   maxSize    =     1  0  ;", "targetSource    =    new    (  )  ;", "targetSource . setMaxSize ( maxSize )  ;", "targetSource . setMaxWait (  1  )  ;", "prepareTargetSource ( targetSource )  ;", "Object [  ]    pooledInstances    =    new   Object [ maxSize ]  ;", "for    ( int   x    =     0  ;    x    <    maxSize ;    x +  +  )     {", "Object   instance    =    targetSource . getTarget (  )  ;", "assertNotNull ( instance )  ;", "pooledInstances [ x ]     =    instance ;", "}", "try    {", "targetSource . getTarget (  )  ;", "fail (  \" Should   throw   NoSuchElementException \"  )  ;", "}    catch    ( NoSuchElementException   ex )     {", "}", "targetSource . releaseTarget ( pooledInstances [  9  ]  )  ;", "pooledInstances [  9  ]     =    targetSource . getTarget (  )  ;", "for    ( int   i    =     0  ;    i    <     ( pooledInstances . length )  ;    i +  +  )     {", "targetSource . releaseTarget ( pooledInstances [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testHitMaxSize"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "Advised   person    =     (  ( Advised )     ( beanFactory . getBean (  \" maxSizePooledPerson \"  )  )  )  ;", "targetSource    =     (  (  )     ( person . getTargetSource (  )  )  )  ;", "int   maxSize    =    targetSource . getMaxSize (  )  ;", "Object [  ]    pooledInstances    =    new   Object [ maxSize ]  ;", "for    ( int   x    =     0  ;    x    <    maxSize ;    x +  +  )     {", "Object   instance    =    targetSource . getTarget (  )  ;", "assertNotNull ( instance )  ;", "pooledInstances [ x ]     =    instance ;", "}", "try    {", "targetSource . getTarget (  )  ;", "fail (  \" Should   throw   NoSuchElementException \"  )  ;", "}    catch    ( NoSuchElementException   ex )     {", "}", "targetSource . releaseTarget ( pooledInstances [  9  ]  )  ;", "pooledInstances [  9  ]     =    targetSource . getTarget (  )  ;", "for    ( int   i    =     0  ;    i    <     ( pooledInstances . length )  ;    i +  +  )     {", "System . out . println ( i )  ;", "targetSource . releaseTarget ( pooledInstances [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testHitMaxSizeLoadedFromContext"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "Person   pooled    =     (  ( Person )     ( beanFactory . getBean (  \" pooledPerson \"  )  )  )  ;", "assertTrue (  (  (  (  ( Advised )     ( pooled )  )  . getTargetSource (  )  )    instanceof    )  )  ;", "Person   serialized    =     (  ( Person )     ( SerializationTestUtils . serializeAndDeserialize ( pooled )  )  )  ;", "assertTrue (  (  (  (  ( Advised )     ( serialized )  )  . getTargetSource (  )  )    instanceof   SingletonTargetSource )  )  ;", "serialized . setAge (  2  5  )  ;", "assertEquals (  2  5  ,    serialized . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxySerializableWithoutConfigMixin"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "CommonsPool 2 TargetSource   targetSource    =    new   CommonsPool 2 TargetSource (  )  ;", "targetSource . setBlockWhenExhausted ( true )  ;", "assertEquals ( true ,    targetSource . isBlockWhenExhausted (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetWhenExhaustedAction"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "CommonsPool 2 TargetSource   cpts    =     (  ( CommonsPool 2 TargetSource )     ( beanFactory . getBean (  \" personPoolTargetSource \"  )  )  )  ;", "SingletonTargetSource   serialized    =     (  ( SingletonTargetSource )     ( SerializationTestUtils . serializeAndDeserialize ( cpts )  )  )  ;", "assertTrue (  (  ( serialized . getTarget (  )  )    instanceof   Person )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetSourceSerializableWithoutConfigMixin"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . UserServiceImpl . class ,     . Foo . class )  ;", "ctx . refresh (  )  ;", "assertNotNull ( ctx . getBean (  . UserServiceImpl . class )  . object )  ;", "}", "METHOD_END"], "methodName": ["SPR8434"], "fileName": "org.springframework.beans.factory.annotation.BridgeMethodAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedConstructorArgumentTestBean   bean    =     (  (  . QualifiedConstructorArgumentTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredConstructorArgumentResolvesQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  ( e   instanceof   UnsatisfiedDependencyException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredConstructorArgumentWithMultipleNonQualifiedCandidates"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  ( e   instanceof   UnsatisfiedDependencyException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredConstructorArgumentWithSingleNonQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "person . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedConstructorArgumentTestBean   bean    =     (  (  . QualifiedConstructorArgumentTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredConstructorArgumentWithSingleQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifierWithDefaultValue . class ,     \" not   the   default \"  )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredFieldDoesNotResolveCandidateWithDefaultValueAndConflictingValueOnBeanDefinition"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  \" the   real   juergen \"  )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" juergen \"  )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  \" juergen   imposter \"  )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "person 2  . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" juergen \"  )  )  ;", "context . registerBeanDefinition (  \" juergen 1  \"  ,    person 1  )  ;", "context . registerBeanDefinition (  \" juergen 2  \"  ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentWithBaseQualifierNonDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  ( e   instanceof   UnsatisfiedDependencyException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredFieldDoesNotResolveWithBaseQualifierAndNonDefaultValueAndMultipleMatchingCandidates"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier . setAttribute (  \" number \"  ,     4  5  6  )  ;", "person 1  . addQualifier ( qualifier )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "AutowireCandidateQualifier   qualifier 2     =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier 2  . setAttribute (  \" number \"  ,     1  2  3  )  ;", "qualifier 2  . setAttribute (  \" value \"  ,     \" not   the   default \"  )  ;", "person 2  . addQualifier ( qualifier 2  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithMultipleAttributesTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredFieldDoesNotResolveWithMultipleQualifierValuesAndConflictingDefaultValue"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier . setAttribute (  \" number \"  ,     1  2  3  )  ;", "person 1  . addQualifier ( qualifier )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "AutowireCandidateQualifier   qualifier 2     =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier 2  . setAttribute (  \" number \"  ,     1  2  3  )  ;", "qualifier 2  . setAttribute (  \" value \"  ,     \" default \"  )  ;", "person 2  . addQualifier ( qualifier 2  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithMultipleAttributesTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredFieldDoesNotResolveWithMultipleQualifierValuesAndMultipleMatchingCandidates"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldTestBean   bean    =     (  (  . QualifiedFieldTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredFieldResolvesQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifierWithDefaultValue . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithDefaultValueTestBean   bean    =     (  (  . QualifiedFieldWithDefaultValueTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredFieldResolvesQualifiedCandidateWithDefaultValueAndNoValueOnBeanDefinition"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifierWithDefaultValue . class ,     \" default \"  )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithDefaultValueTestBean   bean    =     (  (  . QualifiedFieldWithDefaultValueTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredFieldResolvesWithDefaultValueAndExplicitDefaultValueOnBeanDefinition"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier . setAttribute (  \" number \"  ,     4  5  6  )  ;", "person 1  . addQualifier ( qualifier )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "AutowireCandidateQualifier   qualifier 2     =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier 2  . setAttribute (  \" number \"  ,     1  2  3  )  ;", "person 2  . addQualifier ( qualifier 2  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithMultipleAttributesTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithMultipleAttributesTestBean   bean    =     (  (  . QualifiedFieldWithMultipleAttributesTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . MARK ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredFieldResolvesWithMultipleQualifierValues"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier . setAttribute (  \" number \"  ,     4  5  6  )  ;", "person 1  . addQualifier ( qualifier )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "AutowireCandidateQualifier   qualifier 2     =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier 2  . setAttribute (  \" number \"  ,     1  2  3  )  ;", "qualifier 2  . setAttribute (  \" value \"  ,     \" default \"  )  ;", "person 2  . addQualifier ( qualifier 2  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithMultipleAttributesTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithMultipleAttributesTestBean   bean    =     (  (  . QualifiedFieldWithMultipleAttributesTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . MARK ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredFieldResolvesWithMultipleQualifierValuesAndExplicitDefaultValue"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredFieldWithMultipleNonQualifiedCandidates"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredFieldWithSingleNonQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "person . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldTestBean   bean    =     (  (  . QualifiedFieldTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredFieldWithSingleQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedMethodParameterTestBean   bean    =     (  (  . QualifiedMethodParameterTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredMethodParameterResolvesQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredMethodParameterWithMultipleNonQualifiedCandidates"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowiredMethodParameterWithSingleNonQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "person . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedMethodParameterTestBean   bean    =     (  (  . QualifiedMethodParameterTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredMethodParameterWithSingleQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . QualifiedPerson . class ,    cavs ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    ScopedProxyUtils . createScopedProxy ( new   BeanDefinitionHolder ( person ,     . JUERGEN )  ,    context ,    true )  . getBeanDefinition (  )  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedMethodParameterTestBean   bean    =     (  (  . QualifiedMethodParameterTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredMethodParameterWithStaticallyQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . QualifiedPerson . class ,    cavs ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedMethodParameterTestBean   bean    =     (  (  . QualifiedMethodParameterTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredMethodParameterWithStaticallyQualifiedCandidateAmongOthers"], "fileName": "org.springframework.beans.factory.support.InjectAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedConstructorArgumentTestBean   bean    =     (  (  . QualifiedConstructorArgumentTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredConstructorArgumentResolvesQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  ( e   instanceof   UnsatisfiedDependencyException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredConstructorArgumentWithMultipleNonQualifiedCandidates"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  ( e   instanceof   UnsatisfiedDependencyException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredConstructorArgumentWithSingleNonQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "person . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedConstructorArgumentTestBean   bean    =     (  (  . QualifiedConstructorArgumentTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredConstructorArgumentWithSingleQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifierWithDefaultValue . class ,     \" not   the   default \"  )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredFieldDoesNotResolveCandidateWithDefaultValueAndConflictingValueOnBeanDefinition"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  \" the   real   juergen \"  )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" juergen \"  )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  \" juergen   imposter \"  )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "person 2  . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" juergen \"  )  )  ;", "context . registerBeanDefinition (  \" juergen 1  \"  ,    person 1  )  ;", "context . registerBeanDefinition (  \" juergen 2  \"  ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentWithBaseQualifierNonDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  ( e   instanceof   UnsatisfiedDependencyException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredFieldDoesNotResolveWithBaseQualifierAndNonDefaultValueAndMultipleMatchingCandidates"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier . setAttribute (  \" number \"  ,     4  5  6  )  ;", "person 1  . addQualifier ( qualifier )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "AutowireCandidateQualifier   qualifier 2     =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier 2  . setAttribute (  \" number \"  ,     1  2  3  )  ;", "qualifier 2  . setAttribute (  \" value \"  ,     \" not   the   default \"  )  ;", "person 2  . addQualifier ( qualifier 2  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithMultipleAttributesTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredFieldDoesNotResolveWithMultipleQualifierValuesAndConflictingDefaultValue"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier . setAttribute (  \" number \"  ,     1  2  3  )  ;", "person 1  . addQualifier ( qualifier )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "AutowireCandidateQualifier   qualifier 2     =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier 2  . setAttribute (  \" number \"  ,     1  2  3  )  ;", "qualifier 2  . setAttribute (  \" value \"  ,     \" default \"  )  ;", "person 2  . addQualifier ( qualifier 2  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithMultipleAttributesTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredFieldDoesNotResolveWithMultipleQualifierValuesAndMultipleMatchingCandidates"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . MetaQualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". MetaQualifiedFieldTestBean   bean    =     (  (  . MetaQualifiedFieldTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldResolvesMetaQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldTestBean   bean    =     (  (  . QualifiedFieldTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldResolvesQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifierWithDefaultValue . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithDefaultValueTestBean   bean    =     (  (  . QualifiedFieldWithDefaultValueTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldResolvesQualifiedCandidateWithDefaultValueAndNoValueOnBeanDefinition"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "person 2  . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class )  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithBaseQualifierDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithBaseQualifierDefaultValueTestBean   bean    =     (  (  . QualifiedFieldWithBaseQualifierDefaultValueTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . MARK ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldResolvesWithBaseQualifierAndDefaultValue"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  \" the   real   juergen \"  )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" juergen \"  )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  \" juergen   imposter \"  )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "person 2  . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" not   really   juergen \"  )  )  ;", "context . registerBeanDefinition (  \" juergen 1  \"  ,    person 1  )  ;", "context . registerBeanDefinition (  \" juergen 2  \"  ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedConstructorArgumentWithBaseQualifierNonDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedConstructorArgumentWithBaseQualifierNonDefaultValueTestBean   bean    =     (  (  . QualifiedConstructorArgumentWithBaseQualifierNonDefaultValueTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  \" the   real   juergen \"  ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldResolvesWithBaseQualifierAndNonDefaultValue"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifierWithDefaultValue . class ,     \" default \"  )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithDefaultValueTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithDefaultValueTestBean   bean    =     (  (  . QualifiedFieldWithDefaultValueTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldResolvesWithDefaultValueAndExplicitDefaultValueOnBeanDefinition"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier . setAttribute (  \" number \"  ,     4  5  6  )  ;", "person 1  . addQualifier ( qualifier )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "AutowireCandidateQualifier   qualifier 2     =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier 2  . setAttribute (  \" number \"  ,     1  2  3  )  ;", "person 2  . addQualifier ( qualifier 2  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithMultipleAttributesTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithMultipleAttributesTestBean   bean    =     (  (  . QualifiedFieldWithMultipleAttributesTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . MARK ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldResolvesWithMultipleQualifierValues"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier . setAttribute (  \" number \"  ,     4  5  6  )  ;", "person 1  . addQualifier ( qualifier )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "AutowireCandidateQualifier   qualifier 2     =    new   AutowireCandidateQualifier (  . TestQualifierWithMultipleAttributes . class )  ;", "qualifier 2  . setAttribute (  \" number \"  ,     1  2  3  )  ;", "qualifier 2  . setAttribute (  \" value \"  ,     \" default \"  )  ;", "person 2  . addQualifier ( qualifier 2  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldWithMultipleAttributesTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldWithMultipleAttributesTestBean   bean    =     (  (  . QualifiedFieldWithMultipleAttributesTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . MARK ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldResolvesWithMultipleQualifierValuesAndExplicitDefaultValue"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredFieldWithMultipleNonQualifiedCandidates"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredFieldWithSingleNonQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "person . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedFieldTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedFieldTestBean   bean    =     (  (  . QualifiedFieldTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredFieldWithSingleQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedMethodParameterTestBean   bean    =     (  (  . QualifiedMethodParameterTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredMethodParameterResolvesQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredMethodParameterWithMultipleNonQualifiedCandidates"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue (  (  ( e . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "assertEquals (  \" autowired \"  ,    e . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["autowiredMethodParameterWithSingleNonQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "person . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedMethodParameterTestBean   bean    =     (  (  . QualifiedMethodParameterTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredMethodParameterWithSingleQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . QualifiedPerson . class ,    cavs ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    ScopedProxyUtils . createScopedProxy ( new   BeanDefinitionHolder ( person ,     . JUERGEN )  ,    context ,    true )  . getBeanDefinition (  )  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedMethodParameterTestBean   bean    =     (  (  . QualifiedMethodParameterTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredMethodParameterWithStaticallyQualifiedCandidate"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . QualifiedPerson . class ,    cavs ,    null )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . DefaultValueQualifiedPerson . class ,    cavs 2  ,    null )  ;", "context . registerBeanDefinition (  . JUERGEN ,    person )  ;", "context . registerBeanDefinition (  . MARK ,    person 2  )  ;", "context . registerBeanDefinition (  \" autowired \"  ,    new   RootBeanDefinition (  . QualifiedMethodParameterTestBean . class )  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( context )  ;", "context . refresh (  )  ;", ". QualifiedMethodParameterTestBean   bean    =     (  (  . QualifiedMethodParameterTestBean )     ( context . getBean (  \" autowired \"  )  )  )  ;", "assertEquals (  . JUERGEN ,    bean . getPerson (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredMethodParameterWithStaticallyQualifiedCandidateAmongOthers"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireContextTests"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   other ;", "}", "METHOD_END"], "methodName": ["getOther"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   spouse 1  ;", "}", "METHOD_END"], "methodName": ["getSpouse1"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   spouse 2  ;", "}", "METHOD_END"], "methodName": ["getSpouse2"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   setterString ;", "}", "METHOD_END"], "methodName": ["getSetterString"], "fileName": "org.springframework.beans.factory.xml.ConstructorInjectedOverrides"}, {"methodBody": ["METHOD_START", "{", "return   this . tb ;", "}", "METHOD_END"], "methodName": ["getTestBean"], "fileName": "org.springframework.beans.factory.xml.ConstructorInjectedOverrides"}, {"methodBody": ["METHOD_START", "{", "this . setterString    =    setterString ;", "}", "METHOD_END"], "methodName": ["setSetterString"], "fileName": "org.springframework.beans.factory.xml.ConstructorInjectedOverrides"}, {"methodBody": ["METHOD_START", "{", "this . destroyed    =    true ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.beans.factory.xml.DerivedConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "this . initialized    =    true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.beans.factory.xml.DerivedConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   dummyFactory ;", "}", "METHOD_END"], "methodName": ["getDummyFactory"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "return   testBean 1  ;", "}", "METHOD_END"], "methodName": ["getTestBean1"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "return   testBean 2  ;", "}", "METHOD_END"], "methodName": ["getTestBean2"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "this . dummyFactory    =    dummyFactory ;", "}", "METHOD_END"], "methodName": ["setDummyFactory"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "this . testBean 1     =    testBean 1  ;", "}", "METHOD_END"], "methodName": ["setTestBean1"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "this . testBean 2     =    testBean 2  ;", "}", "METHOD_END"], "methodName": ["setTestBean2"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \" defaultInstance \"  )  ;", "return   new    ( tb ,     \" default \"  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["defaultInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   num ;", "}", "METHOD_END"], "methodName": ["getNum"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   this . stringValue ;", "}", "METHOD_END"], "methodName": ["getStringValue"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   this . tb ;", "}", "METHOD_END"], "methodName": ["getTestBean"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   Collections . EMPTY _ LIST ;", "}", "METHOD_END"], "methodName": ["listInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   new   FactoryMethods ( tb ,     \" default \"  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "if    ( something    !  =    null )     {", "throw   new   IllegalStateException (  \" Should   never   be   called   with   non - null   value \"  )  ;", "}", "return   new    ( tb ,    null ,    num )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )     {", "throw   new   IllegalStateException (  \" Should   never   be   called   with   null   value \"  )  ;", "}", "return   new    ( tb ,    name ,    num )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["nullInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   this . tb ;", "}", "METHOD_END"], "methodName": ["privateGetTestBean"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   this . tb ;", "}", "METHOD_END"], "methodName": ["protectedGetTestBean"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "this . stringValue    =    stringValue ;", "}", "METHOD_END"], "methodName": ["setStringValue"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "DebugInterceptor   interceptor    =    getInterceptor (  )  ;", "assertEquals (  \" Interceptor   count   is   incorrect \"  ,    count ,    interceptor . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertInterceptorCount"], "fileName": "org.springframework.beans.factory.xml.LookupMethodWrappedByCglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DebugInterceptor )     ( applicationContext . getBean (  \" interceptor \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInterceptor"], "fileName": "org.springframework.beans.factory.xml.LookupMethodWrappedByCglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "DebugInterceptor   interceptor    =    getInterceptor (  )  ;", "interceptor . resetCount (  )  ;", "}", "METHOD_END"], "methodName": ["resetInterceptor"], "fileName": "org.springframework.beans.factory.xml.LookupMethodWrappedByCglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "this . applicationContext    =    new   ClassPathXmlApplicationContext ( LookupMethodWrappedByCglibProxyTests . CONTEXT ,    LookupMethodWrappedByCglibProxyTests . CLASS )  ;", "resetInterceptor (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.xml.LookupMethodWrappedByCglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "OverloadLookup   olup    =     (  ( OverloadLookup )     ( applicationContext . getBean (  \" autoProxiedOverload \"  )  )  )  ;", "ITestBean   jenny    =    olup . newTestBean (  )  ;", "assertEquals (  \" Jenny \"  ,    jenny . getName (  )  )  ;", "assertEquals (  \" foo \"  ,    olup . testMethod (  )  )  ;", "assertInterceptorCount (  2  )  ;", "}", "METHOD_END"], "methodName": ["testAutoProxiedLookup"], "fileName": "org.springframework.beans.factory.xml.LookupMethodWrappedByCglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "OverloadLookup   olup    =     (  ( OverloadLookup )     ( applicationContext . getBean (  \" regularlyProxiedOverload \"  )  )  )  ;", "ITestBean   jenny    =    olup . newTestBean (  )  ;", "assertEquals (  \" Jenny \"  ,    jenny . getName (  )  )  ;", "assertEquals (  \" foo \"  ,    olup . testMethod (  )  )  ;", "assertInterceptorCount (  2  )  ;", "}", "METHOD_END"], "methodName": ["testRegularlyProxiedLookup"], "fileName": "org.springframework.beans.factory.xml.LookupMethodWrappedByCglibProxyTests"}, {"methodBody": ["METHOD_START", "{", "return   obj ;", "}", "METHOD_END"], "methodName": ["getObject"], "fileName": "org.springframework.beans.factory.xml.MapAndSet"}, {"methodBody": ["METHOD_START", "{", "return   echo ;", "}", "METHOD_END"], "methodName": ["replaceMe"], "fileName": "org.springframework.beans.factory.xml.MethodReplaceCandidate"}, {"methodBody": ["METHOD_START", "{", "return   jumble ;", "}", "METHOD_END"], "methodName": ["getJumble"], "fileName": "org.springframework.beans.factory.xml.MixedCollectionBean"}, {"methodBody": ["METHOD_START", "{", "this . jumble    =    jumble ;", "}", "METHOD_END"], "methodName": ["setJumble"], "fileName": "org.springframework.beans.factory.xml.MixedCollectionBean"}, {"methodBody": ["METHOD_START", "{", "return    \" foo \"  ;", "}", "METHOD_END"], "methodName": ["testMethod"], "fileName": "org.springframework.beans.factory.xml.OverloadLookup"}, {"methodBody": ["METHOD_START", "{", "return   echo ;", "}", "METHOD_END"], "methodName": ["echo"], "fileName": "org.springframework.beans.factory.xml.OverrideOneMethod"}, {"methodBody": ["METHOD_START", "{", "return   getPrototypeDependency (  )  ;", "}", "METHOD_END"], "methodName": ["invokesOverriddenMethodOnSelf"], "fileName": "org.springframework.beans.factory.xml.OverrideOneMethod"}, {"methodBody": ["METHOD_START", "{", "return    \" replaceMe \"  ;", "}", "METHOD_END"], "methodName": ["replaceMe"], "fileName": "org.springframework.beans.factory.xml.OverrideOneMethod"}, {"methodBody": ["METHOD_START", "{", "return    \" replaceMe :  \"     +    someParam ;", "}", "METHOD_END"], "methodName": ["replaceMe"], "fileName": "org.springframework.beans.factory.xml.OverrideOneMethod"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( this . inited )  )     |  |     (  ( this . initMethodDeclared )     &  &     (  !  ( this . initedViaDeclaredInitMethod )  )  )  )     |  |     (  !  ( this . postProcessedAfterInit )  )  )     {", "throw   new   RuntimeException (  \" Factory   didn ' t   initialize   l   object   correctly \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["businessMethod"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . inited )  )     {", "throw   new   RuntimeException (  \" F   didn ' t   call   afterPropertiesSet   before   declared   init   method \"  )  ;", "}", "if    ( this . initedViaDeclaredInitMethod )     {", "throw   new   RuntimeException (  \" F   called   declared   init   method   twice \"  )  ;", "}", "this . initedViaDeclaredInitMethod    =    true ;", "}", "METHOD_END"], "methodName": ["declaredInitMethod"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   destroyed ;", "}", "METHOD_END"], "methodName": ["isDestroyed"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   initMethodDeclared ;", "}", "METHOD_END"], "methodName": ["isInitMethodDeclared"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . inited )  )     {", "throw   new   RuntimeException (  \" F   called   postProcessAfterInit   before   afterPropertiesSet \"  )  ;", "}", "if    (  ( this . initMethodDeclared )     &  &     (  !  ( this . initedViaDeclaredInitMethod )  )  )     {", "throw   new   RuntimeException (  \" F   called   postProcessAfterInit   before   calling   declared   init   method \"  )  ;", "}", "if    ( this . postProcessedAfterInit )     {", "throw   new   RuntimeException (  \" F   called   postProcessAfterInit   twice \"  )  ;", "}", "this . postProcessedAfterInit    =    true ;", "}", "METHOD_END"], "methodName": ["postProcessAfterInit"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . inited )     |  |     ( this . initedViaDeclaredInitMethod )  )     {", "throw   new   RuntimeException (  \" F   called   postProcessBeforeInit   after   afterPropertiesSet \"  )  ;", "}", "if    ( this . postProcessedBeforeInit )     {", "throw   new   RuntimeException (  \" F   called   postProcessBeforeInit   twice \"  )  ;", "}", "this . postProcessedBeforeInit    =    true ;", "}", "METHOD_END"], "methodName": ["postProcessBeforeInit"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "this . initMethodDeclared    =    initMethodDeclared ;", "}", "METHOD_END"], "methodName": ["setInitMethodDeclared"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "}", "METHOD_END"], "methodName": ["testInterfaceWithOneQualifiedFactoryAndOneQualifiedBean"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . NonQualifiedTestBean . class )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" Should   have   thrown   a   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue ( e . getMessage (  )  . contains (  \" found    6  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNonQualifiedFieldFails"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByAliasTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByAliasTestBean   testBean    =     (  (  . QualifiedByAliasTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getStooge (  )  ;", "assertEquals (  \" LarryBean \"  ,    person . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByAlias"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByAnnotationTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByAnnotationTestBean   testBean    =     (  (  . QualifiedByAnnotationTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getLarry (  )  ;", "assertEquals (  \" LarrySpecial \"  ,    person . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByAnnotation"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByAnnotationValueTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByAnnotationValueTestBean   testBean    =     (  (  . QualifiedByAnnotationValueTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getLarry (  )  ;", "assertEquals (  \" LarrySpecial \"  ,    person . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByAnnotationValue"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByAttributesTestBean . class )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" should   have   thrown   a   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "assertTrue ( e . getMessage (  )  . contains (  \" found    6  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testQualifiedByAttributesFailsWithoutCustomQualifierRegistered"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "QualifierAnnotationAutowireCandidateResolver   resolver    =     (  ( QualifierAnnotationAutowireCandidateResolver )     ( context . getDefaultListableBeanFactory (  )  . getAutowireCandidateResolver (  )  )  )  ;", "resolver . addQualifierType (  . MultipleAttributeQualifier . class )  ;", "context . registerSingleton (  \" testBean \"  ,     . MultiQualifierClient . class )  ;", "context . refresh (  )  ;", ". MultiQualifierClient   testBean    =     (  (  . MultiQualifierClient )     ( context . getBean (  \" testBean \"  )  )  )  ;", "assertNotNull ( testBean . factoryTheta )  ;", "assertNotNull ( testBean . implTheta )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByAttributesWithCustomQualifierRegistered"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByBeanNameTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByBeanNameTestBean   testBean    =     (  (  . QualifiedByBeanNameTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getLarry (  )  ;", "assertEquals (  \" LarryBean \"  ,    person . getName (  )  )  ;", "assertTrue (  (  (  ( testBean . myProps )     !  =    null )     &  &     ( testBean . myProps . isEmpty (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByBeanName"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByCustomValueTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByCustomValueTestBean   testBean    =     (  (  . QualifiedByCustomValueTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getCurly (  )  ;", "assertEquals (  \" Curly \"  ,    person . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByCustomValue"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByFieldNameTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByFieldNameTestBean   testBean    =     (  (  . QualifiedByFieldNameTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getLarry (  )  ;", "assertEquals (  \" LarryBean \"  ,    person . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByFieldName"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByParameterNameTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByParameterNameTestBean   testBean    =     (  (  . QualifiedByParameterNameTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getLarry (  )  ;", "assertEquals (  \" LarryBean \"  ,    person . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByParameterName"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   parent    =    new   StaticApplicationContext (  )  ;", "GenericBeanDefinition   parentLarry    =    new   GenericBeanDefinition (  )  ;", "parentLarry . setBeanClass (  . Person . class )  ;", "parentLarry . getPropertyValues (  )  . add (  \" name \"  ,     \" ParentLarry \"  )  ;", "parentLarry . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" parentLarry \"  )  )  ;", "parent . registerBeanDefinition (  \" someLarry \"  ,    parentLarry )  ;", "GenericBeanDefinition   otherLarry    =    new   GenericBeanDefinition (  )  ;", "otherLarry . setBeanClass (  . Person . class )  ;", "otherLarry . getPropertyValues (  )  . add (  \" name \"  ,     \" OtherLarry \"  )  ;", "otherLarry . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" otherLarry \"  )  )  ;", "parent . registerBeanDefinition (  \" someOtherLarry \"  ,    otherLarry )  ;", "parent . refresh (  )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext ( parent )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByParentValueTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByParentValueTestBean   testBean    =     (  (  . QualifiedByParentValueTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getLarry (  )  ;", "assertEquals (  \" ParentLarry \"  ,    person . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByParentValue"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  . CONFIG _ LOCATION )  ;", "context . registerSingleton (  \" testBean \"  ,     . QualifiedByValueTestBean . class )  ;", "context . refresh (  )  ;", ". QualifiedByValueTestBean   testBean    =     (  (  . QualifiedByValueTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", ". Person   person    =    testBean . getLarry (  )  ;", "assertEquals (  \" Larry \"  ,    person . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testQualifiedByValue"], "fileName": "org.springframework.beans.factory.xml.QualifierAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorArgBean"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorArgBean"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" simplePropertyNamespaceHandlerWithExpressionLanguageTests . xml \"  ,    getClass (  )  )  ;", "ITestBean   foo    =    applicationContext . getBean (  \" foo \"  ,    ITestBean . class )  ;", "ITestBean   bar    =    applicationContext . getBean (  \" bar \"  ,    ITestBean . class )  ;", "assertEquals (  \" Invalid   name \"  ,     \" Baz \"  ,    foo . getName (  )  )  ;", "assertEquals (  \" Invalid   name \"  ,     \" Baz \"  ,    bar . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["combineWithExpressionLanguage"], "fileName": "org.springframework.beans.factory.xml.SimplePropertyNamespaceHandlerWithExpressionLanguageTests"}, {"methodBody": ["METHOD_START", "{", "return   testString ;", "}", "METHOD_END"], "methodName": ["getTestString"], "fileName": "org.springframework.beans.factory.xml.SingleSimpleTypeConstructorBean"}, {"methodBody": ["METHOD_START", "{", "return   secondBoolean ;", "}", "METHOD_END"], "methodName": ["isSecondBoolean"], "fileName": "org.springframework.beans.factory.xml.SingleSimpleTypeConstructorBean"}, {"methodBody": ["METHOD_START", "{", "return   singleBoolean ;", "}", "METHOD_END"], "methodName": ["isSingleBoolean"], "fileName": "org.springframework.beans.factory.xml.SingleSimpleTypeConstructorBean"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathResource (  (  ( XmlBeanFactoryTests . CLASSNAME )     +    suffix )  ,    XmlBeanFactoryTests . CLASS )  ;", "}", "METHOD_END"], "methodName": ["classPathResource"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DependenciesBean   rod 1     =     (  ( DependenciesBean )     ( xbf . getBean (  \" rod 1  \"  )  )  )  ;", "TestBean   kerry    =     (  ( TestBean )     ( xbf . getBean (  \" spouse \"  )  )  )  ;", "assertEquals ( kerry ,    rod 1  . getSpouse (  )  )  ;", "DependenciesBean   rod 1 a    =     (  ( DependenciesBean )     ( xbf . getBean (  \" rod 1 a \"  )  )  )  ;", "assertEquals ( kerry ,    rod 1 a . getSpouse (  )  )  ;", "DependenciesBean   rod 2     =     (  ( DependenciesBean )     ( xbf . getBean (  \" rod 2  \"  )  )  )  ;", "assertEquals ( kerry ,    rod 2  . getSpouse (  )  )  ;", "DependenciesBean   rod 2 a    =     (  ( DependenciesBean )     ( xbf . getBean (  \" rod 2 a \"  )  )  )  ;", "assertEquals ( kerry ,    rod 2 a . getSpouse (  )  )  ;", "ConstructorDependenciesBean   rod 3     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 3  \"  )  )  )  ;", "IndexedTestBean   other    =     (  ( IndexedTestBean )     ( xbf . getBean (  \" other \"  )  )  )  ;", "assertEquals ( kerry ,    rod 3  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry ,    rod 3  . getSpouse 2  (  )  )  ;", "assertEquals ( other ,    rod 3  . getOther (  )  )  ;", "ConstructorDependenciesBean   rod 3 a    =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 3 a \"  )  )  )  ;", "assertEquals ( kerry ,    rod 3 a . getSpouse 1  (  )  )  ;", "assertEquals ( kerry ,    rod 3 a . getSpouse 2  (  )  )  ;", "assertEquals ( other ,    rod 3 a . getOther (  )  )  ;", "try    {", "xbf . getBean (  \" rod 4  \"  ,    ConstructorDependenciesBean . class )  ;", "fail (  \" Must   have   thrown   a   FatalBeanException \"  )  ;", "}    catch    ( FatalBeanException   expected )     {", "}", "DependenciesBean   rod 5     =     (  ( DependenciesBean )     ( xbf . getBean (  \" rod 5  \"  )  )  )  ;", "assertNull ( rod 5  . getSpouse (  )  )  ;", "appCtx    =     (  (  )     ( xbf . getBean (  \" childAppCtx \"  )  )  )  ;", "assertTrue ( appCtx . containsBean (  \" rod 1  \"  )  )  ;", "assertTrue ( appCtx . containsBean (  \" jenny \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestAutowire"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "XmlBeanFactoryTests . PreparingBean 1  . prepared    =    false ;", "XmlBeanFactoryTests . PreparingBean 1  . destroyed    =    false ;", "XmlBeanFactoryTests . PreparingBean 2  . prepared    =    false ;", "XmlBeanFactoryTests . PreparingBean 2  . destroyed    =    false ;", "XmlBeanFactoryTests . DependingBean . destroyCount    =     0  ;", "XmlBeanFactoryTests . HoldingBean . destroyCount    =     0  ;", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions ( resource )  ;", "xbf . preInstantiateSingletons (  )  ;", "xbf . destroySingletons (  )  ;", "assertTrue ( XmlBeanFactoryTests . PreparingBean 1  . prepared )  ;", "assertTrue ( XmlBeanFactoryTests . PreparingBean 1  . destroyed )  ;", "assertTrue ( XmlBeanFactoryTests . PreparingBean 2  . prepared )  ;", "assertTrue ( XmlBeanFactoryTests . PreparingBean 2  . destroyed )  ;", "assertEquals ( nrOfHoldingBeans ,    XmlBeanFactoryTests . DependingBean . destroyCount )  ;", "if    (  !  ( xbf . getBeansOfType ( XmlBeanFactoryTests . HoldingBean . class ,    false ,    false )  . isEmpty (  )  )  )     {", "assertEquals ( nrOfHoldingBeans ,    XmlBeanFactoryTests . HoldingBean . destroyCount )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestDependencies"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . INVALID _ CONTEXT )  ;", "}", "METHOD_END"], "methodName": ["invalidXmlFile"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions (  . OVERRIDES _ CONTEXT )  ;", "lookupOverrideMethodsWithSetterInjection ( xbf ,     \" overrideOneMethod \"  ,    true )  ;", "lookupOverrideMethodsWithSetterInjection ( xbf ,     \" overrideInheritedMethod \"  ,    true )  ;", "int   howMany    =     1  0  0  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  (  (  \" Look   up    \"     +    howMany )     +     \"    prototype   bean   instances   with   method   overrides \"  )  )  ;", "for    ( int   i    =     0  ;    i    <    howMany ;    i +  +  )     {", "lookupOverrideMethodsWithSetterInjection ( xbf ,     \" overrideOnPrototype \"  ,    false )  ;", "}", "sw . stop (  )  ;", "if    (  !  ( LogFactory . getLog ( DefaultListableBeanFactory . class )  . isDebugEnabled (  )  )  )     {", "assertTrue (  (  ( sw . getTotalTimeMillis (  )  )     <     2  0  0  0  )  )  ;", "}", "OverrideOneMethod   swappedOom    =     (  ( OverrideOneMethod )     ( xbf . getBean (  \" overrideOneMethodSwappedReturnValues \"  )  )  )  ;", "TestBean   tb    =    swappedOom . getPrototypeDependency (  )  ;", "assertEquals (  \" David \"  ,    tb . getName (  )  )  ;", "tb    =    swappedOom . protectedOverrideSingleton (  )  ;", "assertEquals (  \" Jenny \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["lookupOverrideMethodsWithSetterInjection"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "OverrideOneMethod   oom    =     (  ( OverrideOneMethod )     ( xbf . getBean ( beanName )  )  )  ;", "if    ( singleton )     {", "assertSame ( oom ,    xbf . getBean ( beanName )  )  ;", "} else    {", "assertNotSame ( oom ,    xbf . getBean ( beanName )  )  ;", "}", "TestBean   jenny 1     =    oom . getPrototypeDependency (  )  ;", "assertEquals (  \" Jenny \"  ,    jenny 1  . getName (  )  )  ;", "TestBean   jenny 2     =    oom . getPrototypeDependency (  )  ;", "assertEquals (  \" Jenny \"  ,    jenny 2  . getName (  )  )  ;", "assertNotSame ( jenny 1  ,    jenny 2  )  ;", "TestBean   jenny 3     =    oom . invokesOverriddenMethodOnSelf (  )  ;", "assertEquals (  \" Jenny \"  ,    jenny 3  . getName (  )  )  ;", "assertNotSame ( jenny 1  ,    jenny 3  )  ;", "TestBean   dave 1     =    oom . protectedOverrideSingleton (  )  ;", "assertEquals (  \" David \"  ,    dave 1  . getName (  )  )  ;", "TestBean   dave 2     =    oom . protectedOverrideSingleton (  )  ;", "assertEquals (  \" David \"  ,    dave 2  . getName (  )  )  ;", "assertSame ( dave 1  ,    dave 2  )  ;", "}", "METHOD_END"], "methodName": ["lookupOverrideMethodsWithSetterInjection"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions (  . CONSTRUCTOR _ OVERRIDES _ CONTEXT )  ;", "ConstructorInjectedOverrides   cio    =     (  ( ConstructorInjectedOverrides )     ( xbf . getBean (  \" constructorOverrides \"  )  )  )  ;", "assertEquals (  \" Setter   string   was   set \"  ,     \" from   property   element \"  ,    cio . getSetterString (  )  )  ;", "TestBean   jenny    =     (  ( TestBean )     ( xbf . getBean (  \" jenny \"  )  )  )  ;", "assertSame ( jenny ,    cio . getTestBean (  )  )  ;", "assertSame ( jenny ,    cio . getTestBean (  )  )  ;", "FactoryMethods   fm 1     =    cio . createFactoryMethods (  )  ;", "FactoryMethods   fm 2     =    cio . createFactoryMethods (  )  ;", "assertNotSame (  \" FactoryMethods   reference   is   to   a   prototype \"  ,    fm 1  ,    fm 2  )  ;", "assertSame (  \" The   two   prototypes   hold   the   same   singleton   reference \"  ,    fm 1  . getTestBean (  )  ,    fm 2  . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["lookupOverrideOneMethodWithConstructorInjection"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    firstClass    =    null ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . OVERRIDES _ CONTEXT )  ;", "final   Class <  ?  >    currentClass    =    bf . getBean (  \" overrideOneMethod \"  )  . getClass (  )  ;", "assertTrue (  (  (  \" Method   injected   bean   class    [  \"     +    currentClass )     +     \"  ]    must   be   a   CGLIB   enhanced   subclass .  \"  )  ,    ClassUtils . isCglibProxyClass ( currentClass )  )  ;", "if    ( firstClass    =  =    null )     {", "firstClass    =    currentClass ;", "} else    {", "assertEquals ( firstClass ,    currentClass )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["methodInjectedBeanMustBeOfSameEnhancedCglibSubclassTypeAcrossBeanFactories"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . NO _ SUCH _ FACTORY _ METHOD _ CONTEXT )  ;", "assertNotNull ( xbf . getBean (  \" defaultTestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["noSuchFactoryBeanMethod"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . MISSING _ CONTEXT )  ;", "}", "METHOD_END"], "methodName": ["noSuchXmlFile"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . RECURSIVE _ IMPORT _ CONTEXT )  ;", "}", "METHOD_END"], "methodName": ["recursiveImport"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions (  . DELEGATION _ OVERRIDES _ CONTEXT )  ;", "SerializableMethodReplacerCandidate   s    =     (  ( SerializableMethodReplacerCandidate )     ( xbf . getBean (  \" serializableReplacer \"  )  )  )  ;", "String   forwards    =     \" this   is   forwards \"  ;", "String   backwards    =    new   StringBuffer ( forwards )  . reverse (  )  . toString (  )  ;", "assertEquals ( backwards ,    s . replaceMe ( forwards )  )  ;", "assertFalse (  \" Lookup   methods   and   method   replacers   are   not   meant   to   be   serializable .  \"  ,    SerializationTestUtils . isSerializable ( s )  )  ;", "}", "METHOD_END"], "methodName": ["serializableMethodReplacerAndSuperclass"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "parent . preInstantiateSingletons (  )  ;", "assertTrue ( parent . isSingleton (  \" inheritedTestBeanWithoutClass \"  )  )  ;", "Map <  ?  ,     ?  >    tbs    =    parent . getBeansOfType ( TestBean . class )  ;", "assertEquals (  2  ,    tbs . size (  )  )  ;", "assertTrue ( tbs . containsKey (  \" inheritedTestBeanPrototype \"  )  )  ;", "assertTrue ( tbs . containsKey (  \" inheritedTestBeanSingleton \"  )  )  ;", "try    {", "parent . getBean (  \" inheritedTestBeanWithoutClass \"  )  ;", "fail (  \" Should   have   thrown   BeanIsAbstractException \"  )  ;", "}    catch    ( BeanIsAbstractException   ex )     {", "}", "assertTrue (  (  ( parent . getBean (  \" inheritedTestBeanPrototype \"  )  )    instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testAbstractParentBeans"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . AUTOWIRE _ CONTEXT )  ;", "TestBean   spouse    =    new   TestBean (  \" kerry \"  ,     0  )  ;", "xbf . registerSingleton (  \" spouse \"  ,    spouse )  ;", "doTestAutowire ( xbf )  ;", "}", "METHOD_END"], "methodName": ["testAutowire"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "ConstructorDependenciesBean   rod 1     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  \"  )  )  )  ;", "TestBean   kerry    =     (  ( TestBean )     ( xbf . getBean (  \" kerry 2  \"  )  )  )  ;", "assertEquals ( kerry ,    rod 1  . getSpouse 1  (  )  )  ;", "assertEquals (  0  ,    rod 1  . getAge (  )  )  ;", "assertEquals ( null ,    rod 1  . getName (  )  )  ;", "ConstructorDependenciesBean   rod 2     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 2  \"  )  )  )  ;", "TestBean   kerry 1     =     (  ( TestBean )     ( xbf . getBean (  \" kerry 1  \"  )  )  )  ;", "TestBean   kerry 2     =     (  ( TestBean )     ( xbf . getBean (  \" kerry 2  \"  )  )  )  ;", "assertEquals ( kerry 2  ,    rod 2  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry 1  ,    rod 2  . getSpouse 2  (  )  )  ;", "assertEquals (  0  ,    rod 2  . getAge (  )  )  ;", "assertEquals ( null ,    rod 2  . getName (  )  )  ;", "ConstructorDependenciesBean   rod    =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 3  \"  )  )  )  ;", "IndexedTestBean   other    =     (  ( IndexedTestBean )     ( xbf . getBean (  \" other \"  )  )  )  ;", "assertEquals ( kerry ,    rod . getSpouse 1  (  )  )  ;", "assertEquals ( kerry ,    rod . getSpouse 2  (  )  )  ;", "assertEquals ( other ,    rod . getOther (  )  )  ;", "assertEquals (  0  ,    rod . getAge (  )  )  ;", "assertEquals ( null ,    rod . getName (  )  )  ;", "xbf . getBean (  \" rod 4  \"  ,    ConstructorDependenciesBean . class )  ;", "assertEquals ( kerry ,    rod . getSpouse 1  (  )  )  ;", "assertEquals ( kerry ,    rod . getSpouse 2  (  )  )  ;", "assertEquals ( other ,    rod . getOther (  )  )  ;", "assertEquals (  0  ,    rod . getAge (  )  )  ;", "assertEquals ( null ,    rod . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireByConstructor"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "ConstructorDependenciesBean   rod 5     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 5  \"  )  )  )  ;", "TestBean   kerry 1     =     (  ( TestBean )     ( xbf . getBean (  \" kerry 1  \"  )  )  )  ;", "TestBean   kerry 2     =     (  ( TestBean )     ( xbf . getBean (  \" kerry 2  \"  )  )  )  ;", "IndexedTestBean   other    =     (  ( IndexedTestBean )     ( xbf . getBean (  \" other \"  )  )  )  ;", "assertEquals ( kerry 2  ,    rod 5  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry 1  ,    rod 5  . getSpouse 2  (  )  )  ;", "assertEquals ( other ,    rod 5  . getOther (  )  )  ;", "assertEquals (  9  9  ,    rod 5  . getAge (  )  )  ;", "assertEquals (  \" myname \"  ,    rod 5  . getName (  )  )  ;", "DerivedConstructorDependenciesBean   rod 6     =     (  ( DerivedConstructorDependenciesBean )     ( xbf . getBean (  \" rod 6  \"  )  )  )  ;", "assertTrue ( rod 6  . initialized )  ;", "assertTrue (  (  !  ( rod 6  . destroyed )  )  )  ;", "assertEquals ( kerry 2  ,    rod 6  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry 1  ,    rod 6  . getSpouse 2  (  )  )  ;", "assertEquals ( other ,    rod 6  . getOther (  )  )  ;", "assertEquals (  0  ,    rod 6  . getAge (  )  )  ;", "assertEquals ( null ,    rod 6  . getName (  )  )  ;", "xbf . destroySingletons (  )  ;", "assertTrue ( rod 6  . destroyed )  ;", "}", "METHOD_END"], "methodName": ["testAutowireByConstructorWithSimpleValues"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions (  . OVERRIDES _ CONTEXT )  ;", "TestBean   david    =     (  ( TestBean )     ( xbf . getBean (  \" magicDavid \"  )  )  )  ;", "assertNotNull ( david . getSpouse (  )  )  ;", "TestBean   derivedDavid    =     (  ( TestBean )     ( xbf . getBean (  \" magicDavidDerived \"  )  )  )  ;", "assertNull (  \" autowiring   not   propagated   along   child   relationships \"  ,    derivedDavid . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireModeNotInherited"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . DEFAULT _ AUTOWIRE _ CONTEXT )  ;", "DependenciesBean   rod 1     =     (  ( DependenciesBean )     ( xbf . getBean (  \" rod 1  \"  )  )  )  ;", "assertNotNull ( rod 1  . getSpouse (  )  )  ;", "assertTrue ( rod 1  . getSpouse (  )  . getName (  )  . equals (  \" Kerry \"  )  )  ;", "DependenciesBean   rod 2     =     (  ( DependenciesBean )     ( xbf . getBean (  \" rod 2  \"  )  )  )  ;", "assertNotNull ( rod 2  . getSpouse (  )  )  ;", "assertTrue ( rod 2  . getSpouse (  )  . getName (  )  . equals (  \" Kerry \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireWithDefault"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . AUTOWIRE _ CONTEXT )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" kerry \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd )  ;", "xbf . setParentBeanFactory ( lbf )  ;", "doTestAutowire ( xbf )  ;", "}", "METHOD_END"], "methodName": ["testAutowireWithParent"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "try    {", "child . getBean (  \" bogusParent \"  ,    TestBean . class )  ;", "fail (  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" bogusParent \"  )  )     !  =     (  -  1  )  )  )  ;", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBogusParentageFromParentFactory"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "TestBean   inherits    =     (  ( TestBean )     ( child . getBean (  \" inheritedTestBean \"  )  )  )  ;", "assertTrue ( inherits . getName (  )  . equals (  \" overrideParentBean \"  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     1  )  )  ;", "TestBean   inherits 2     =     (  ( TestBean )     ( child . getBean (  \" inheritedTestBean \"  )  )  )  ;", "assertTrue (  ( inherits 2     !  =    inherits )  )  ;", "}", "METHOD_END"], "methodName": ["testChildOverridesParentBean"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "xbf . getBean (  \" egoBridge \"  )  ;", "TestBean   complexEgo    =     (  ( TestBean )     ( xbf . getBean (  \" complexEgo \"  )  )  )  ;", "assertTrue (  \" Correct   circular   reference \"  ,     (  ( complexEgo . getSpouse (  )  . getSpouse (  )  )     =  =    complexEgo )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularReferenceWithFactoryBeanFirst"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "TestBean   ego 1     =     (  ( TestBean )     ( xbf . getBean (  \" ego 1  \"  )  )  )  ;", "assertTrue (  \" Correct   circular   reference \"  ,     (  ( ego 1  . getSpouse (  )  . getSpouse (  )  )     =  =    ego 1  )  )  ;", "TestBean   ego 3     =     (  ( TestBean )     ( xbf . getBean (  \" ego 3  \"  )  )  )  ;", "assertTrue (  \" Correct   circular   reference \"  ,     (  ( ego 3  . getSpouse (  )  . getSpouse (  )  )     =  =    ego 3  )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularReferenceWithTwoFactoryBeans"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "TestBean   jenny    =     (  ( TestBean )     ( xbf . getBean (  \" jenny \"  )  )  )  ;", "TestBean   david    =     (  ( TestBean )     ( xbf . getBean (  \" david \"  )  )  )  ;", "TestBean   ego    =     (  ( TestBean )     ( xbf . getBean (  \" ego \"  )  )  )  ;", "TestBean   complexInnerEgo    =     (  ( TestBean )     ( xbf . getBean (  \" complexInnerEgo \"  )  )  )  ;", "TestBean   complexEgo    =     (  ( TestBean )     ( xbf . getBean (  \" complexEgo \"  )  )  )  ;", "assertTrue (  \" Correct   circular   reference \"  ,     (  ( jenny . getSpouse (  )  )     =  =    david )  )  ;", "assertTrue (  \" Correct   circular   reference \"  ,     (  ( david . getSpouse (  )  )     =  =    jenny )  )  ;", "assertTrue (  \" Correct   circular   reference \"  ,     (  ( ego . getSpouse (  )  )     =  =    ego )  )  ;", "assertTrue (  \" Correct   circular   reference \"  ,     (  ( complexInnerEgo . getSpouse (  )  . getSpouse (  )  )     =  =    complexInnerEgo )  )  ;", "assertTrue (  \" Correct   circular   reference \"  ,     (  ( complexEgo . getSpouse (  )  . getSpouse (  )  )     =  =    complexEgo )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularReferences"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "xbf . setAllowCircularReferences ( false )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "try    {", "xbf . getBean (  \" jenny \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . contains ( BeanCurrentlyInCreationException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCircularReferencesWithNotAllowed"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "xbf . addBeanPostProcessor ( new    . WrappingPostProcessor (  )  )  ;", "try    {", "xbf . getBean (  \" jenny \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . contains ( BeanCurrentlyInCreationException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCircularReferencesWithWrapping"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "xbf . setAllowRawInjectionDespiteWrapping ( true )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "xbf . addBeanPostProcessor ( new    . WrappingPostProcessor (  )  )  ;", "ITestBean   jenny    =     (  ( ITestBean )     ( xbf . getBean (  \" jenny \"  )  )  )  ;", "ITestBean   david    =     (  ( ITestBean )     ( xbf . getBean (  \" david \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( jenny )  )  ;", "assertTrue ( AopUtils . isAopProxy ( david )  )  ;", "assertSame ( david ,    jenny . getSpouse (  )  )  ;", "assertNotSame ( jenny ,    david . getSpouse (  )  )  ;", "assertEquals (  \" Jenny \"  ,    david . getSpouse (  )  . getName (  )  )  ;", "assertSame ( david ,    david . getSpouse (  )  . getSpouse (  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( jenny . getSpouse (  )  )  )  ;", "assertTrue (  (  !  ( AopUtils . isAopProxy ( david . getSpouse (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularReferencesWithWrappingAndRawInjectionAllowed"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . CLASS _ NOT _ FOUND _ CONTEXT )  ;", "try    {", "factory . getBean (  \" classNotFound \"  )  ;", "fail (  \" Must   have   thrown   a   CannotLoadBeanClassException \"  )  ;", "}    catch    ( CannotLoadBeanClassException   ex )     {", "assertTrue (  (  ( ex . getResourceDescription (  )  . indexOf (  \" classNotFound . xml \"  )  )     !  =     (  -  1  )  )  )  ;", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   ClassNotFoundException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testClassNotFoundWithDefaultBeanClassLoader"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( bf )  ;", "reader . setBeanClassLoader ( null )  ;", "reader . loadBeanDefinitions (  . CLASS _ NOT _ FOUND _ CONTEXT )  ;", "assertEquals (  \" WhatALotOfRubbish \"  ,    bf . getBeanDefinition (  \" classNotFound \"  )  . getBeanClassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassNotFoundWithNoBeanClassLoader"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . RESOURCE _ CONTEXT )  ;", "xbf . getBean (  \" resource 1  \"  ,    ResourceTestBean . class )  ;", "xbf . getBean (  \" resource 2  \"  ,    ResourceTestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testClassPathResourceWithImport"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . COLLECTIONS _ XSD _ CONTEXT )  ;", "factory . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionsReferredToAsRefLocals"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . COMPLEX _ FACTORY _ CIRCLE _ CONTEXT )  ;", "xbf . getBean (  \" proxy 1  \"  )  ;", "assertEquals (  4  ,    xbf . getSingletonCount (  )  )  ;", "xbf . getBean (  \" proxy 2  \"  )  ;", "assertEquals (  5  ,    xbf . getSingletonCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexFactoryReferenceCircle"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "TestBean   kerry 1     =     (  ( TestBean )     ( xbf . getBean (  \" kerry 1  \"  )  )  )  ;", "TestBean   kerry 2     =     (  ( TestBean )     ( xbf . getBean (  \" kerry 2  \"  )  )  )  ;", "ConstructorDependenciesBean   rod 9     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 9  \"  )  )  )  ;", "assertEquals (  9  9  ,    rod 9  . getAge (  )  )  ;", "ConstructorDependenciesBean   rod 9 a    =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 9  \"  ,     9  8  )  )  )  ;", "assertEquals (  9  8  ,    rod 9 a . getAge (  )  )  ;", "ConstructorDependenciesBean   rod 9 b    =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 9  \"  ,     \" myName \"  )  )  )  ;", "assertEquals (  \" myName \"  ,    rod 9 b . getName (  )  )  ;", "ConstructorDependenciesBean   rod 9 c    =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 9  \"  ,     9  7  )  )  )  ;", "assertEquals (  9  7  ,    rod 9 c . getAge (  )  )  ;", "ConstructorDependenciesBean   rod 1  0     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  0  \"  )  )  )  ;", "assertEquals ( null ,    rod 1  0  . getName (  )  )  ;", "ConstructorDependenciesBean   rod 1  1     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  1  \"  )  )  )  ;", "assertEquals ( kerry 2  ,    rod 1  1  . getSpouse 1  (  )  )  ;", "ConstructorDependenciesBean   rod 1  2     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  2  \"  )  )  )  ;", "assertEquals ( kerry 1  ,    rod 1  2  . getSpouse 1  (  )  )  ;", "assertNull ( rod 1  2  . getSpouse 2  (  )  )  ;", "ConstructorDependenciesBean   rod 1  3     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  3  \"  )  )  )  ;", "assertEquals ( kerry 1  ,    rod 1  3  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry 2  ,    rod 1  3  . getSpouse 2  (  )  )  ;", "ConstructorDependenciesBean   rod 1  4     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  4  \"  )  )  )  ;", "assertEquals ( kerry 1  ,    rod 1  4  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry 2  ,    rod 1  4  . getSpouse 2  (  )  )  ;", "ConstructorDependenciesBean   rod 1  5     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  5  \"  )  )  )  ;", "assertEquals ( kerry 2  ,    rod 1  5  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry 1  ,    rod 1  5  . getSpouse 2  (  )  )  ;", "ConstructorDependenciesBean   rod 1  6     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  6  \"  )  )  )  ;", "assertEquals ( kerry 2  ,    rod 1  6  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry 1  ,    rod 1  6  . getSpouse 2  (  )  )  ;", "assertEquals (  2  9  ,    rod 1  6  . getAge (  )  )  ;", "ConstructorDependenciesBean   rod 1  7     =     (  ( ConstructorDependenciesBean )     ( xbf . getBean (  \" rod 1  7  \"  )  )  )  ;", "assertEquals ( kerry 1  ,    rod 1  7  . getSpouse 1  (  )  )  ;", "assertEquals ( kerry 2  ,    rod 1  7  . getSpouse 2  (  )  )  ;", "assertEquals (  2  9  ,    rod 1  7  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorArgResolution"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "SingleSimpleTypeConstructorBean   bean    =     (  ( SingleSimpleTypeConstructorBean )     ( xbf . getBean (  \" beanWithBooleanAndString \"  )  )  )  ;", "assertTrue ( bean . isSecondBoolean (  )  )  ;", "assertEquals (  \" A   String \"  ,    bean . getTestString (  )  )  ;", "SingleSimpleTypeConstructorBean   bean 2     =     (  ( SingleSimpleTypeConstructorBean )     ( xbf . getBean (  \" beanWithBooleanAndString 2  \"  )  )  )  ;", "assertTrue ( bean 2  . isSecondBoolean (  )  )  ;", "assertEquals (  \" A   String \"  ,    bean 2  . getTestString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorArgWithDoubleSimpleTypeMatch"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "File   file    =     (  ( File )     ( xbf . getBean (  \" file \"  )  )  )  ;", "assertEquals (  (  ( File . separator )     +     \" test \"  )  ,    file . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorArgWithSingleMatch"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "SingleSimpleTypeConstructorBean   bean    =     (  ( SingleSimpleTypeConstructorBean )     ( xbf . getBean (  \" beanWithBoolean \"  )  )  )  ;", "assertTrue ( bean . isSingleBoolean (  )  )  ;", "SingleSimpleTypeConstructorBean   bean 2     =     (  ( SingleSimpleTypeConstructorBean )     ( xbf . getBean (  \" beanWithBoolean 2  \"  )  )  )  ;", "assertTrue ( bean 2  . isSingleBoolean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorArgWithSingleSimpleTypeMatch"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "AtomicInteger   bean    =     (  ( AtomicInteger )     ( xbf . getBean (  \" constructorUnresolvableName \"  )  )  )  ;", "assertEquals (  1  ,    bean . get (  )  )  ;", "bean    =     (  ( AtomicInteger )     ( xbf . getBean (  \" constructorUnresolvableNameWithIndex \"  )  )  )  ;", "assertEquals (  1  ,    bean . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorWithUnresolvableParameterName"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "AbstractBeanDefinition   bd    =     (  ( AbstractBeanDefinition )     ( xbf . getBeanDefinition (  \" stringConstructor \"  )  )  )  ;", "bd . setLenientConstructorResolution ( false )  ;", ". StringConstructorTestBean   tb    =     (  (  . StringConstructorTestBean )     ( xbf . getBean (  \" stringConstructor \"  )  )  )  ;", "assertEquals (  \" test \"  ,    tb . name )  ;", "}", "METHOD_END"], "methodName": ["testCustomStringConstructor"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "XmlBeanFactoryTests . InitAndIB . constructed    =    false ;", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions ( XmlBeanFactoryTests . DEFAULT _ LAZY _ CONTEXT )  ;", "assertFalse ( XmlBeanFactoryTests . InitAndIB . constructed )  ;", "xbf . preInstantiateSingletons (  )  ;", "assertTrue ( XmlBeanFactoryTests . InitAndIB . constructed )  ;", "try    {", "xbf . getBean (  \" lazy - and - bad \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IOException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDefaultLazyInit"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . DEP _ MATERIALIZE _ CONTEXT )  ;", "assertEquals (  2  ,    xbf . getBeansOfType ( DummyBo . class ,    true ,    false )  . size (  )  )  ;", "assertEquals (  3  ,    xbf . getBeansOfType ( DummyBo . class ,    true ,    true )  . size (  )  )  ;", "assertEquals (  3  ,    xbf . getBeansOfType ( DummyBo . class ,    true ,    false )  . size (  )  )  ;", "assertEquals (  3  ,    xbf . getBeansOfType ( DummyBo . class )  . size (  )  )  ;", "assertEquals (  2  ,    xbf . getBeansOfType ( DummyBoImpl . class ,    true ,    true )  . size (  )  )  ;", "assertEquals (  1  ,    xbf . getBeansOfType ( DummyBoImpl . class ,    false ,    true )  . size (  )  )  ;", "assertEquals (  2  ,    xbf . getBeansOfType ( DummyBoImpl . class )  . size (  )  )  ;", "DummyBoImpl   bos    =     (  ( DummyBoImpl )     ( xbf . getBean (  \" boSingleton \"  )  )  )  ;", "DummyBoImpl   bop    =     (  ( DummyBoImpl )     ( xbf . getBean (  \" boPrototype \"  )  )  )  ;", "assertNotSame ( bos ,    bop )  ;", "assertTrue (  (  ( bos . dao )     =  =     ( bop . dao )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesMaterializeThis"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ CARG _ AUTOWIRE _ CONTEXT ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesThroughConstructorArgumentAutowiring"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ CARG _ CONTEXT ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesThroughConstructorArguments"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ CARG _ INNER _ CONTEXT ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesThroughConstructorArgumentsInInnerBean"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ PROP ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesThroughProperties"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ PROP _ INNER _ CONTEXT ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesThroughPropertiesInInnerBean"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ PROP _ MIDDLE _ CONTEXT ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesThroughPropertiesWithInTheMiddle"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ PROP _ ABN _ CONTEXT ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesThroughPropertyAutowiringByName"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ PROP _ ABT _ CONTEXT ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependenciesThroughPropertyAutowiringByType"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ DEPENDSON _ CONTEXT ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testDependsOn"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestDependencies ( XmlBeanFactoryTests . DEP _ DEPENDSON _ INNER _ CONTEXT ,     4  )  ;", "}", "METHOD_END"], "methodName": ["testDependsOnInInnerBean"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", ". DoubleBooleanConstructorBean   bean    =     (  (  . DoubleBooleanConstructorBean )     ( xbf . getBean (  \" beanWithDoubleBoolean \"  )  )  )  ;", "assertEquals ( Boolean . TRUE ,    bean . boolean 1  )  ;", "assertEquals ( Boolean . FALSE ,    bean . boolean 2  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleBooleanAutowire"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", ". DoubleBooleanConstructorBean   bean    =     (  (  . DoubleBooleanConstructorBean )     ( xbf . getBean (  \" beanWithDoubleBooleanAndIndex \"  )  )  )  ;", "assertEquals ( Boolean . FALSE ,    bean . boolean 1  )  ;", "assertEquals ( Boolean . TRUE ,    bean . boolean 2  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleBooleanAutowireWithIndex"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . FACTORY _ CIRCLE _ CONTEXT )  ;", "TestBean   tb    =     (  ( TestBean )     ( xbf . getBean (  \" singletonFactory \"  )  )  )  ;", "DummyFactory   db    =     (  ( DummyFactory )     ( xbf . getBean (  \"  & singletonFactory \"  )  )  )  ;", "assertTrue (  ( tb    =  =     ( db . getOtherTestBean (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryReferenceCircle"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . FACTORY _ CIRCLE _ CONTEXT )  ;", "assertThat ( xbf . getBean (  \"  &  & singletonFactory \"  )  ,    instanceOf ( DummyFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryReferenceWithDoublePrefix"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "try    {", "xbf . getBean (  \" failsOnInnerBean \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "ex . printStackTrace (  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" failsOnInnerBean \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" someMap \"  )  )  ;", "}", "try    {", "xbf . getBean (  \" failsOnInnerBeanForConstructor \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "ex . printStackTrace (  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" failsOnInnerBeanForConstructor \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" constructor   argument \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFailsOnInnerBean"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =    getClass (  )  . getResource ( XmlBeanFactoryTests . RESOURCE _ CONTEXT . getPath (  )  )  . toURI (  )  . getPath (  )  ;", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions ( new   FileSystemResource ( file )  )  ;", "xbf . getBean (  \" resource 1  \"  ,    ResourceTestBean . class )  ;", "xbf . getBean (  \" resource 2  \"  ,    ResourceTestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testFileSystemResourceWithImport"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", ". ConstructorArrayTestBean   bean    =     (  (  . ConstructorArrayTestBean )     ( xbf . getBean (  \" indexedConstructorArray \"  )  )  )  ;", "assertTrue (  (  ( bean . array )    instanceof   int [  ]  )  )  ;", "assertEquals (  1  ,     (  ( int [  ]  )     ( bean . array )  )  . length )  ;", "assertEquals (  1  ,     (  ( int [  ]  )     ( bean . array )  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testIndexedPrimitiveConstructorArray"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "assertEquals ( TestBean . class ,    child . getType (  \" inheritsFromParentFactory \"  )  )  ;", "TestBean   inherits    =     (  ( TestBean )     ( child . getBean (  \" inheritsFromParentFactory \"  )  )  )  ;", "assertTrue ( inherits . getName (  )  . equals (  \" override \"  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     1  )  )  ;", "TestBean   inherits 2     =     (  ( TestBean )     ( child . getBean (  \" inheritsFromParentFactory \"  )  )  )  ;", "assertFalse (  ( inherits 2     =  =    inherits )  )  ;", "}", "METHOD_END"], "methodName": ["testInheritanceFromParentFactoryPrototype"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "assertEquals ( DerivedTestBean . class ,    child . getType (  \" inheritsWithClass \"  )  )  ;", "DerivedTestBean   inherits    =     (  ( DerivedTestBean )     ( child . getBean (  \" inheritsWithClass \"  )  )  )  ;", "assertTrue ( inherits . getName (  )  . equals (  \" override \"  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     1  )  )  ;", "assertTrue ( inherits . wasInitialized (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInheritanceWithClass"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "assertEquals ( DerivedTestBean . class ,    child . getType (  \" inheritsWithClass \"  )  )  ;", "DerivedTestBean   inherits    =     (  ( DerivedTestBean )     ( child . getBean (  \" inheritsWithDifferentClass \"  )  )  )  ;", "assertTrue ( inherits . getName (  )  . equals (  \" override \"  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     1  )  )  ;", "assertTrue ( inherits . wasInitialized (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInheritanceWithDifferentClass"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . INITIALIZERS _ CONTEXT )  ;", ". DoubleInitializer   in    =     (  (  . DoubleInitializer )     ( xbf . getBean (  \" init - method 1  \"  )  )  )  ;", "assertEquals (  1  4  ,    in . getNum (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInitMethodIsInvoked"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . INITIALIZERS _ CONTEXT )  ;", "try    {", "xbf . getBean (  \" init - method 2  \"  )  ;", "fail (  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getResourceDescription (  )  . indexOf (  \" initializers . xml \"  )  )     !  =     (  -  1  )  )  )  ;", "assertEquals (  \" init - method 2  \"  ,    ex . getBeanName (  )  )  ;", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IOException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInitMethodThrowsException"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "XmlBeanFactoryTests . InitAndIB . constructed    =    false ;", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions ( XmlBeanFactoryTests . INITIALIZERS _ CONTEXT )  ;", "assertFalse ( XmlBeanFactoryTests . InitAndIB . constructed )  ;", "xbf . preInstantiateSingletons (  )  ;", "assertFalse ( XmlBeanFactoryTests . InitAndIB . constructed )  ;", "XmlBeanFactoryTests . InitAndIB   iib    =     (  ( XmlBeanFactoryTests . InitAndIB )     ( xbf . getBean (  \" init - and - ib \"  )  )  )  ;", "assertTrue ( XmlBeanFactoryTests . InitAndIB . constructed )  ;", "assertTrue (  (  ( iib . afterPropertiesSetInvoked )     &  &     ( iib . initMethodInvoked )  )  )  ;", "assertTrue (  (  (  !  ( iib . destroyed )  )     &  &     (  !  ( iib . customDestroyed )  )  )  )  ;", "xbf . destroySingletons (  )  ;", "assertTrue (  (  ( iib . destroyed )     &  &     ( iib . customDestroyed )  )  )  ;", "xbf . destroySingletons (  )  ;", "assertTrue (  (  ( iib . destroyed )     &  &     ( iib . customDestroyed )  )  )  ;", "}", "METHOD_END"], "methodName": ["testInitializingBeanAndInitMethod"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "XmlBeanFactoryTests . InitAndIB . constructed    =    false ;", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions ( XmlBeanFactoryTests . INITIALIZERS _ CONTEXT )  ;", "assertFalse ( XmlBeanFactoryTests . InitAndIB . constructed )  ;", "xbf . preInstantiateSingletons (  )  ;", "assertFalse ( XmlBeanFactoryTests . InitAndIB . constructed )  ;", "XmlBeanFactoryTests . InitAndIB   iib    =     (  ( XmlBeanFactoryTests . InitAndIB )     ( xbf . getBean (  \" ib - same - init \"  )  )  )  ;", "assertTrue ( XmlBeanFactoryTests . InitAndIB . constructed )  ;", "assertTrue (  (  ( iib . afterPropertiesSetInvoked )     &  &     (  !  ( iib . initMethodInvoked )  )  )  )  ;", "assertTrue (  (  (  !  ( iib . destroyed )  )     &  &     (  !  ( iib . customDestroyed )  )  )  )  ;", "xbf . destroySingletons (  )  ;", "assertTrue (  (  ( iib . destroyed )     &  &     (  !  ( iib . customDestroyed )  )  )  )  ;", "xbf . destroySingletons (  )  ;", "assertTrue (  (  ( iib . destroyed )     &  &     (  !  ( iib . customDestroyed )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testInitializingBeanAndSameInitMethod"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions (  . OVERRIDES _ CONTEXT )  ;", "TestBean   jenny 1     =     (  ( TestBean )     ( xbf . getBean (  \" jennyChild \"  )  )  )  ;", "assertEquals (  1  ,    jenny 1  . getFriends (  )  . size (  )  )  ;", "Object   friend 1     =    jenny 1  . getFriends (  )  . iterator (  )  . next (  )  ;", "assertTrue (  ( friend 1    instanceof   TestBean )  )  ;", "TestBean   jenny 2     =     (  ( TestBean )     ( xbf . getBean (  \" jennyChild \"  )  )  )  ;", "assertEquals (  1  ,    jenny 2  . getFriends (  )  . size (  )  )  ;", "Object   friend 2     =    jenny 2  . getFriends (  )  . iterator (  )  . next (  )  ;", "assertTrue (  ( friend 2    instanceof   TestBean )  )  ;", "assertNotSame ( jenny 1  ,    jenny 2  )  ;", "assertNotSame ( friend 1  ,    friend 2  )  ;", "}", "METHOD_END"], "methodName": ["testInnerBeanInheritsScopeFromConcreteChildDefinition"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "InputStream   inputStream    =    getClass (  )  . getResourceAsStream (  . REFTYPES _ CONTEXT . getPath (  )  )  ;", "try    {", "reader . loadBeanDefinitions ( new   InputSource ( inputStream )  )  ;", "}    finally    {", "inputStream . close (  )  ;", "}", "xbf . getBean (  \" innerBean \"  )  ;", "TestBean   hasInnerBeans    =     (  ( TestBean )     ( xbf . getBean (  \" hasInnerBeans \"  )  )  )  ;", "assertEquals (  5  ,    hasInnerBeans . getAge (  )  )  ;", "TestBean   inner 1     =     (  ( TestBean )     ( hasInnerBeans . getSpouse (  )  )  )  ;", "assertNotNull ( inner 1  )  ;", "assertEquals (  \" innerBean #  1  \"  ,    inner 1  . getBeanName (  )  )  ;", "assertEquals (  \" inner 1  \"  ,    inner 1  . getName (  )  )  ;", "assertEquals (  6  ,    inner 1  . getAge (  )  )  ;", "assertNotNull ( hasInnerBeans . getFriends (  )  )  ;", "Object [  ]    friends    =    hasInnerBeans . getFriends (  )  . toArray (  )  ;", "assertEquals (  3  ,    friends . length )  ;", "DerivedTestBean   inner 2     =     (  ( DerivedTestBean )     ( friends [  0  ]  )  )  ;", "assertEquals (  \" inner 2  \"  ,    inner 2  . getName (  )  )  ;", "assertTrue ( inner 2  . getBeanName (  )  . startsWith ( DerivedTestBean . class . getName (  )  )  )  ;", "assertFalse ( xbf . containsBean (  \" innerBean #  1  \"  )  )  ;", "assertNotNull ( inner 2  )  ;", "assertEquals (  7  ,    inner 2  . getAge (  )  )  ;", "TestBean   innerFactory    =     (  ( TestBean )     ( friends [  1  ]  )  )  ;", "assertEquals ( SINGLETON _ NAME ,    innerFactory . getName (  )  )  ;", "TestBean   inner 5     =     (  ( TestBean )     ( friends [  2  ]  )  )  ;", "assertEquals (  \" innerBean #  2  \"  ,    inner 5  . getBeanName (  )  )  ;", "assertNotNull ( hasInnerBeans . getSomeMap (  )  )  ;", "assertEquals (  2  ,    hasInnerBeans . getSomeMap (  )  . size (  )  )  ;", "TestBean   inner 3     =     (  ( TestBean )     ( hasInnerBeans . getSomeMap (  )  . get (  \" someKey \"  )  )  )  ;", "assertEquals (  \" Jenny \"  ,    inner 3  . getName (  )  )  ;", "assertEquals (  3  0  ,    inner 3  . getAge (  )  )  ;", "TestBean   inner 4     =     (  ( TestBean )     ( hasInnerBeans . getSomeMap (  )  . get (  \" someOtherKey \"  )  )  )  ;", "assertEquals (  \" inner 4  \"  ,    inner 4  . getName (  )  )  ;", "assertEquals (  9  ,    inner 4  . getAge (  )  )  ;", "TestBean   hasInnerBeansForConstructor    =     (  ( TestBean )     ( xbf . getBean (  \" hasInnerBeansForConstructor \"  )  )  )  ;", "TestBean   innerForConstructor    =     (  ( TestBean )     ( hasInnerBeansForConstructor . getSpouse (  )  )  )  ;", "assertNotNull ( innerForConstructor )  ;", "assertEquals (  \" innerBean #  3  \"  ,    innerForConstructor . getBeanName (  )  )  ;", "assertEquals (  \" inner 1  \"  ,    innerForConstructor . getName (  )  )  ;", "assertEquals (  6  ,    innerForConstructor . getAge (  )  )  ;", "hasInnerBeansForConstructor    =     (  ( TestBean )     ( xbf . getBean (  \" hasInnerBeansAsPrototype \"  )  )  )  ;", "innerForConstructor    =     (  ( TestBean )     ( hasInnerBeansForConstructor . getSpouse (  )  )  )  ;", "assertNotNull ( innerForConstructor )  ;", "assertEquals (  \" innerBean \"  ,    innerForConstructor . getBeanName (  )  )  ;", "assertEquals (  \" inner 1  \"  ,    innerForConstructor . getName (  )  )  ;", "assertEquals (  6  ,    innerForConstructor . getAge (  )  )  ;", "hasInnerBeansForConstructor    =     (  ( TestBean )     ( xbf . getBean (  \" hasInnerBeansAsPrototype \"  )  )  )  ;", "innerForConstructor    =     (  ( TestBean )     ( hasInnerBeansForConstructor . getSpouse (  )  )  )  ;", "assertNotNull ( innerForConstructor )  ;", "assertEquals (  \" innerBean \"  ,    innerForConstructor . getBeanName (  )  )  ;", "assertEquals (  \" inner 1  \"  ,    innerForConstructor . getName (  )  )  ;", "assertEquals (  6  ,    innerForConstructor . getAge (  )  )  ;", "xbf . destroySingletons (  )  ;", "assertTrue ( inner 1  . wasDestroyed (  )  )  ;", "assertTrue ( inner 2  . wasDestroyed (  )  )  ;", "assertTrue (  (  ( innerFactory . getName (  )  )     =  =    null )  )  ;", "assertTrue ( inner 5  . wasDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInnerBeans"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "xbf . getBean (  \" innerBean \"  )  ;", "TestBean   hasInnerBeans    =     (  ( TestBean )     ( xbf . getBean (  \" hasInnerBeansWithoutDestroy \"  )  )  )  ;", "assertEquals (  5  ,    hasInnerBeans . getAge (  )  )  ;", "TestBean   inner 1     =     (  ( TestBean )     ( hasInnerBeans . getSpouse (  )  )  )  ;", "assertNotNull ( inner 1  )  ;", "assertTrue ( inner 1  . getBeanName (  )  . startsWith (  \" innerBean \"  )  )  ;", "assertEquals (  \" inner 1  \"  ,    inner 1  . getName (  )  )  ;", "assertEquals (  6  ,    inner 1  . getAge (  )  )  ;", "assertNotNull ( hasInnerBeans . getFriends (  )  )  ;", "Object [  ]    friends    =    hasInnerBeans . getFriends (  )  . toArray (  )  ;", "assertEquals (  3  ,    friends . length )  ;", "DerivedTestBean   inner 2     =     (  ( DerivedTestBean )     ( friends [  0  ]  )  )  ;", "assertEquals (  \" inner 2  \"  ,    inner 2  . getName (  )  )  ;", "assertTrue ( inner 2  . getBeanName (  )  . startsWith ( DerivedTestBean . class . getName (  )  )  )  ;", "assertNotNull ( inner 2  )  ;", "assertEquals (  7  ,    inner 2  . getAge (  )  )  ;", "TestBean   innerFactory    =     (  ( TestBean )     ( friends [  1  ]  )  )  ;", "assertEquals ( SINGLETON _ NAME ,    innerFactory . getName (  )  )  ;", "TestBean   inner 5     =     (  ( TestBean )     ( friends [  2  ]  )  )  ;", "assertTrue ( inner 5  . getBeanName (  )  . startsWith (  \" innerBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testInnerBeansWithoutDestroy"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "AbstractBeanDefinition   bd    =     (  ( AbstractBeanDefinition )     ( xbf . getBeanDefinition (  \" string \"  )  )  )  ;", "bd . setLenientConstructorResolution ( false )  ;", "String   str    =     (  ( String )     ( xbf . getBean (  \" string \"  )  )  )  ;", "assertEquals (  \" test \"  ,    str )  ;", "}", "METHOD_END"], "methodName": ["testJavaLangStringConstructor"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", ". LenientDependencyTestBean   bean    =     (  (  . LenientDependencyTestBean )     ( xbf . getBean (  \" lenientDependencyTestBean \"  )  )  )  ;", "assertTrue (  (  ( bean . tb )    instanceof   DerivedTestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testLenientDependencyMatching"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", ". LenientDependencyTestBean   bean    =     (  (  . LenientDependencyTestBean )     ( xbf . getBean (  \" lenientDependencyTestBeanFactoryMethod \"  )  )  )  ;", "assertTrue (  (  ( bean . tb )    instanceof   DerivedTestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testLenientDependencyMatchingFactoryMethod"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "IndexedTestBean   bean    =     (  ( IndexedTestBean )     ( child . getBean (  \" indexedTestBean \"  )  )  )  ;", "assertEquals (  \" name   applied   correctly \"  ,     \" myname \"  ,    bean . getArray (  )  [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedPropertyValue"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . INITIALIZERS _ CONTEXT )  ;", "try    {", "xbf . getBean (  \" init - method 3  \"  )  ;", "fail (  )  ;", "}    catch    ( FatalBeanException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" initializers . xml \"  )  )     !  =     (  -  1  )  )  )  ;", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" init - method 3  \"  )  )     !  =     (  -  1  )  )  )  ;", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" init \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNoSuchInitMethod"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "AbstractBeanDefinition   bd    =     (  ( AbstractBeanDefinition )     ( xbf . getBeanDefinition (  \" lenientDependencyTestBean \"  )  )  )  ;", "bd . setLenientConstructorResolution ( false )  ;", "try    {", "xbf . getBean (  \" lenientDependencyTestBean \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "ex . printStackTrace (  )  ;", "assertTrue ( ex . getMostSpecificCause (  )  . getMessage (  )  . contains (  \" Ambiguous \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNonLenientDependencyMatching"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "AbstractBeanDefinition   bd    =     (  ( AbstractBeanDefinition )     ( xbf . getBeanDefinition (  \" lenientDependencyTestBeanFactoryMethod \"  )  )  )  ;", "bd . setLenientConstructorResolution ( false )  ;", "try    {", "xbf . getBean (  \" lenientDependencyTestBeanFactoryMethod \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "ex . printStackTrace (  )  ;", "assertTrue ( ex . getMostSpecificCause (  )  . getMessage (  )  . contains (  \" Ambiguous \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNonLenientDependencyMatchingFactoryMethod"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions (  . DELEGATION _ OVERRIDES _ CONTEXT )  ;", "OverrideOneMethod   oom    =     (  ( OverrideOneMethod )     ( xbf . getBean (  \" overrideOneMethodByAttribute \"  )  )  )  ;", "assertEquals (  \" should   not   replace \"  ,     \" replaceMe :  1  \"  ,    oom . replaceMe (  1  )  )  ;", "assertEquals (  \" should   replace \"  ,     \" cba \"  ,    oom . replaceMe (  \" abc \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testOverrideMethodByArgTypeAttribute"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions (  . DELEGATION _ OVERRIDES _ CONTEXT )  ;", "OverrideOneMethod   oom    =     (  ( OverrideOneMethod )     ( xbf . getBean (  \" overrideOneMethodByElement \"  )  )  )  ;", "assertEquals (  \" should   not   replace \"  ,     \" replaceMe :  1  \"  ,    oom . replaceMe (  1  )  )  ;", "assertEquals (  \" should   replace \"  ,     \" cba \"  ,    oom . replaceMe (  \" abc \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testOverrideMethodByArgTypeElement"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", ". ConstructorArrayTestBean   bean    =     (  (  . ConstructorArrayTestBean )     ( xbf . getBean (  \" constructorArray \"  )  )  )  ;", "assertTrue (  (  ( bean . array )    instanceof   int [  ]  )  )  ;", "assertEquals (  1  ,     (  ( int [  ]  )     ( bean . array )  )  . length )  ;", "assertEquals (  1  ,     (  ( int [  ]  )     ( bean . array )  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testPrimitiveConstructorArray"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "assertEquals ( TestBean . class ,    child . getType (  \" prototypeInheritsFromParentFactoryPrototype \"  )  )  ;", "TestBean   inherits    =     (  ( TestBean )     ( child . getBean (  \" prototypeInheritsFromParentFactoryPrototype \"  )  )  )  ;", "assertTrue ( inherits . getName (  )  . equals (  \" prototype - override \"  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     2  )  )  ;", "TestBean   inherits 2     =     (  ( TestBean )     ( child . getBean (  \" prototypeInheritsFromParentFactoryPrototype \"  )  )  )  ;", "assertFalse (  ( inherits 2     =  =    inherits )  )  ;", "inherits 2  . setAge (  1  3  )  ;", "assertTrue (  (  ( inherits 2  . getAge (  )  )     =  =     1  3  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeInheritanceFromParentFactoryPrototype"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "TestBean   inherits    =     (  ( TestBean )     ( child . getBean (  \" protoypeInheritsFromParentFactorySingleton \"  )  )  )  ;", "assertTrue ( inherits . getName (  )  . equals (  \" prototypeOverridesInheritedSingleton \"  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     1  )  )  ;", "TestBean   inherits 2     =     (  ( TestBean )     ( child . getBean (  \" protoypeInheritsFromParentFactorySingleton \"  )  )  )  ;", "assertFalse (  ( inherits 2     =  =    inherits )  )  ;", "inherits 2  . setAge (  1  3  )  ;", "assertTrue (  (  ( inherits 2  . getAge (  )  )     =  =     1  3  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     1  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeInheritanceFromParentFactorySingleton"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "SimpleConstructorArgBean   cd 1     =     (  ( SimpleConstructorArgBean )     ( xbf . getBean (  \" rod 1  8  \"  )  )  )  ;", "assertEquals (  0  ,    cd 1  . getAge (  )  )  ;", "SimpleConstructorArgBean   cd 2     =     (  ( SimpleConstructorArgBean )     ( xbf . getBean (  \" rod 1  8  \"  ,     9  8  )  )  )  ;", "assertEquals (  9  8  ,    cd 2  . getAge (  )  )  ;", "SimpleConstructorArgBean   cd 3     =     (  ( SimpleConstructorArgBean )     ( xbf . getBean (  \" rod 1  8  \"  ,     \" myName \"  )  )  )  ;", "assertEquals (  \" myName \"  ,    cd 3  . getName (  )  )  ;", "SimpleConstructorArgBean   cd 4     =     (  ( SimpleConstructorArgBean )     ( xbf . getBean (  \" rod 1  8  \"  )  )  )  ;", "assertEquals (  0  ,    cd 4  . getAge (  )  )  ;", "SimpleConstructorArgBean   cd 5     =     (  ( SimpleConstructorArgBean )     ( xbf . getBean (  \" rod 1  8  \"  ,     9  7  )  )  )  ;", "assertEquals (  9  7  ,    cd 5  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeWithExplicitArguments"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions (  . REFTYPES _ CONTEXT )  ;", "TestBean   emma    =     (  ( TestBean )     ( xbf . getBean (  \" emma \"  )  )  )  ;", "TestBean   georgia    =     (  ( TestBean )     ( xbf . getBean (  \" georgia \"  )  )  )  ;", "ITestBean   emmasJenks    =    emma . getSpouse (  )  ;", "ITestBean   georgiasJenks    =    gegetSpouse (  )  ;", "assertTrue (  \" Emma   and   georgia   think   they   have   a   different   boyfriend \"  ,     ( emmasJenks    !  =    georgiasJenks )  )  ;", "assertTrue (  \" Emmas   jenks   has   right   name \"  ,    emmasJenks . getName (  )  . equals (  \" Andrew \"  )  )  ;", "assertTrue (  \" Emmas   doesn ' t   equal   new   ref \"  ,     ( emmasJenks    !  =     ( xbf . getBean (  \" jenks \"  )  )  )  )  ;", "assertTrue (  \" Georgias   jenks   has   right   name \"  ,    emmasJenks . getName (  )  . equals (  \" Andrew \"  )  )  ;", "assertTrue (  \" They   are   object   equal \"  ,    emmasJenks . equals ( georgiasJenks )  )  ;", "assertTrue (  \" They   object   equal   direct   ref \"  ,    emmasJenks . equals ( xbf . getBean (  \" jenks \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRefToSeparatePrototypeInstances"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . setValidationMode ( VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions ( new   core . io . support . EncodedResource ( XmlBeanFactoryTests . REFTYPES _ CONTEXT ,     \" ISO -  8  8  5  9  -  1  \"  )  )  ;", "TestBean   jen    =     (  ( TestBean )     ( xbf . getBean (  \" jenny \"  )  )  )  ;", "TestBean   dave    =     (  ( TestBean )     ( xbf . getBean (  \" david \"  )  )  )  ;", "TestBean   jenks    =     (  ( TestBean )     ( xbf . getBean (  \" jenks \"  )  )  )  ;", "ITestBean   davesJen    =    dave . getSpouse (  )  ;", "ITestBean   jenksJen    =    jenks . getSpouse (  )  ;", "assertTrue (  \"  1    jen   instance \"  ,     ( davesJen    =  =    jenksJen )  )  ;", "assertTrue (  \"  1    jen   instance \"  ,     ( davesJen    =  =    jen )  )  ;", "}", "METHOD_END"], "methodName": ["testRefToSingleton"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "try    {", "reader . loadBeanDefinitions (  . INVALID _ NO _ SUCH _ METHOD _ CONTEXT )  ;", "xbf . getBean (  \" constructorOverrides \"  )  ;", "fail (  \" Shouldn ' t   allow   override   of   bogus   method \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue (  \" Bogus   method   name   correctly   reported \"  ,     (  ( ex . getMessage (  )  . indexOf (  \" bogusMethod \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRejectsOverrideOfBogusMethodName"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "try    {", "xbf . getBean (  \" rod 2 Accessor \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . toString (  )  . indexOf (  \" touchy \"  )  )     !  =     (  -  1  )  )  )  ;", "ex . printStackTrace (  )  ;", "assertNull ( ex . getRelatedCauses (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRelatedCausesFromConstructorResolution"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions (  . DELEGATION _ OVERRIDES _ CONTEXT )  ;", "OverrideOneMethod   oom    =     (  ( OverrideOneMethod )     ( xbf . getBean (  \" overrideOneMethod \"  )  )  )  ;", "TestBean   jenny 1     =    oom . getPrototypeDependency (  )  ;", "assertEquals (  \" Jenny \"  ,    jenny 1  . getName (  )  )  ;", "TestBean   jenny 2     =    oom . getPrototypeDependency (  )  ;", "assertEquals (  \" Jenny \"  ,    jenny 2  . getName (  )  )  ;", "assertNotSame ( jenny 1  ,    jenny 2  )  ;", "TestBean   notJenny    =    oom . getPrototypeDependency (  \" someParam \"  )  ;", "assertTrue (  (  !  (  \" Jenny \"  . equals ( notJenny . getName (  )  )  )  )  )  ;", "TestBean   dave 1     =    oom . protectedOverrideSingleton (  )  ;", "assertEquals (  \" David \"  ,    dave 1  . getName (  )  )  ;", "TestBean   dave 2     =    oom . protectedOverrideSingleton (  )  ;", "assertEquals (  \" David \"  ,    dave 2  . getName (  )  )  ;", "assertSame ( dave 1  ,    dave 2  )  ;", "String   str    =     \" woierowijeiowiej \"  ;", "assertEquals ( str ,    oom . echo ( str )  )  ;", "String   s    =     \" this   is   not   a   palindrome \"  ;", "String   reverse    =    new   StringBuffer ( s )  . reverse (  )  . toString (  )  ;", "assertEquals (  \" Should   have   overridden   to   reverse ,    not   echo \"  ,    reverse ,    oom . replaceMe ( s )  )  ;", "assertEquals (  \" Should   have   overridden   no - arg   overloaded   replaceMe   method   to   return   fixed   value \"  ,    FixedMethodReplacer . VALUE ,    oom . replaceMe (  )  )  ;", "OverrideOneMethodSubclass   ooms    =     (  ( OverrideOneMethodSubclass )     ( xbf . getBean (  \" replaceVoidMethod \"  )  )  )  ;", ". DoSomethingReplacer   dos    =     (  (  . DoSomethingReplacer )     ( xbf . getBean (  \" doSomethingReplacer \"  )  )  )  ;", "assertEquals ( null ,    dos . lastArg )  ;", "String   s 1     =     \"  \"  ;", "String   s 2     =     \" foo   bar   black   sheep \"  ;", "ooms . doSomething ( s 1  )  ;", "assertEquals ( s 1  ,    dos . lastArg )  ;", "ooms . doSomething ( s 2  )  ;", "assertEquals ( s 2  ,    dos . lastArg )  ;", "}", "METHOD_END"], "methodName": ["testReplaceMethodOverrideWithSetterInjection"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . RESOURCE _ CONTEXT )  ;", "ResourceTestBean   resource 1     =     (  ( ResourceTestBean )     ( xbf . getBean (  \" resource 1  \"  )  )  )  ;", "ResourceTestBean   resource 2     =     (  ( ResourceTestBean )     ( xbf . getBean (  \" resource 2  \"  )  )  )  ;", "assertTrue (  (  ( resource 1  . getResource (  )  )    instanceof   ClassPathResource )  )  ;", "StringWriter   writer    =    new   StringWriter (  )  ;", "FileCopyUtils . copy ( new   InputStreamReader ( resource 1  . getResource (  )  . getInputStream (  )  )  ,    writer )  ;", "assertEquals (  \" test \"  ,    writer . toString (  )  )  ;", "writer    =    new   StringWriter (  )  ;", "FileCopyUtils . copy ( new   InputStreamReader ( resource 1  . getInputStream (  )  )  ,    writer )  ;", "assertEquals (  \" test \"  ,    writer . toString (  )  )  ;", "writer    =    new   StringWriter (  )  ;", "FileCopyUtils . copy ( new   InputStreamReader ( resource 2  . getResource (  )  . getInputStream (  )  )  ,    writer )  ;", "assertEquals (  \" test \"  ,    writer . toString (  )  )  ;", "writer    =    new   StringWriter (  )  ;", "FileCopyUtils . copy ( new   InputStreamReader ( resource 2  . getInputStream (  )  )  ,    writer )  ;", "assertEquals (  \" test \"  ,    writer . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceAndInputStream"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "TestBean   beanFromParent    =     (  ( TestBean )     ( parent . getBean (  \" inheritedTestBeanSingleton \"  )  )  )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "TestBean   beanFromChild    =     (  ( TestBean )     ( child . getBean (  \" inheritedTestBeanSingleton \"  )  )  )  ;", "assertTrue (  \" singleton   from   parent   and   child   is   the   same \"  ,     ( beanFromParent    =  =    beanFromChild )  )  ;", "}", "METHOD_END"], "methodName": ["testSingletonFromParent"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . PARENT _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . CHILD _ CONTEXT )  ;", "TestBean   inherits    =     (  ( TestBean )     ( child . getBean (  \" singletonInheritsFromParentFactoryPrototype \"  )  )  )  ;", "assertTrue ( inherits . getName (  )  . equals (  \" prototype - override \"  )  )  ;", "assertTrue (  (  ( inherits . getAge (  )  )     =  =     2  )  )  ;", "TestBean   inherits 2     =     (  ( TestBean )     ( child . getBean (  \" singletonInheritsFromParentFactoryPrototype \"  )  )  )  ;", "assertTrue (  ( inherits 2     =  =    inherits )  )  ;", "}", "METHOD_END"], "methodName": ["testSingletonInheritsFromParentFactoryPrototype"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", ". ConstructorArrayTestBean   bean    =     (  (  . ConstructorArrayTestBean )     ( xbf . getBean (  \" constructorArrayNoType \"  )  )  )  ;", "assertTrue (  (  ( bean . array )    instanceof   String [  ]  )  )  ;", "assertEquals (  0  ,     (  ( String [  ]  )     ( bean . array )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testStringConstructorArrayNoType"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "AbstractBeanDefinition   bd    =     (  ( AbstractBeanDefinition )     ( xbf . getBeanDefinition (  \" constructorArrayNoType \"  )  )  )  ;", "bd . setLenientConstructorResolution ( false )  ;", ". ConstructorArrayTestBean   bean    =     (  (  . ConstructorArrayTestBean )     ( xbf . getBean (  \" constructorArrayNoType \"  )  )  )  ;", "assertTrue (  (  ( bean . array )    instanceof   String [  ]  )  )  ;", "assertEquals (  0  ,     (  ( String [  ]  )     ( bean . array )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testStringConstructorArrayNoTypeNonLenient"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "URL   url    =    getClass (  )  . getResource ( XmlBeanFactoryTests . RESOURCE _ CONTEXT . getPath (  )  )  ;", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions ( new   UrlResource ( url )  )  ;", "xbf . getBean (  \" resource 1  \"  ,    ResourceTestBean . class )  ;", "xbf . getBean (  \" resource 2  \"  ,    ResourceTestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testUrlResourceWithImport"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "try    {", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . TEST _ WITH _ DUP _ NAMES _ CONTEXT )  ;", "fail (  \" Duplicate   name   not   detected \"  )  ;", "}    catch    ( BeansException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" Bean   name    ' foo '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithDuplicateName"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "try    {", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . TEST _ WITH _ DUP _ NAME _ IN _ ALIAS _ CONTEXT )  ;", "fail (  \" Duplicate   name   not   detected \"  )  ;", "}    catch    ( BeansException   e )     {", "assertTrue ( e . getMessage (  )  . contains (  \" Bean   name    ' foo '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithDuplicateNameInAlias"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "xbf . getBean (  \" rod 8  \"  ,    ConstructorDependenciesBean . class )  ;", "}", "METHOD_END"], "methodName": ["throwsExceptionOnAmbiguousResolution"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONSTRUCTOR _ ARG _ CONTEXT )  ;", "xbf . getBean (  \" rod 7  \"  ,    ConstructorDependenciesBean . class )  ;", "}", "METHOD_END"], "methodName": ["throwsExceptionOnTooManyArguments"], "fileName": "org.springframework.beans.factory.xml.XmlBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Invalid   name \"  ,     \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "assertEquals (  \" Invalid   age \"  ,     2  3  ,    bean . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertTestBean"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathResource ( CustomNamespaceHandlerTests . NS _ XML )  ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "NamespaceHandlerResolver   resolver    =    new   DefaultNamespaceHandlerResolver ( CustomNamespaceHandlerTests . CLASS . getClassLoader (  )  ,    CustomNamespaceHandlerTests . NS _ PROPS )  ;", "this . beanFactory    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . setNamespaceHandlerResolver ( resolver )  ;", "reader . setValidationMode ( VALIDATION _ XSD )  ;", "reader . setEntityResolver ( new   CustomNamespaceHandlerTests . DummySchemaResolver (  )  )  ;", "reader . loadBeanDefinitions ( getResource (  )  )  ;", "this . beanFactory . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   bean    =     (  ( ITestBean )     ( this . beanFactory . getBean (  \" chainedTestBean \"  )  )  )  ;", "assertTestBean ( bean )  ;", "assertTrue ( AopUtils . isAopProxy ( bean )  )  ;", "Advisor [  ]    advisors    =     (  ( Advised )     ( bean )  )  . getAdvisors (  )  ;", "assertEquals (  \" Incorrect   number   of   advisors \"  ,     2  ,    advisors . length )  ;", "assertEquals (  \" Incorrect   advice   class \"  ,    DebugInterceptor . class ,    advisors [  0  ]  . getAdvice (  )  . getClass (  )  )  ;", "assertEquals (  \" Incorrect   advice   class \"  ,    NopInterceptor . class ,    advisors [  1  ]  . getAdvice (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testChainedDecorators"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    things    =     (  ( List <  ?  >  )     ( this . beanFactory . getBean (  \" list . of . things \"  )  )  )  ;", "assertNotNull ( things )  ;", "assertEquals (  2  ,    things . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomElementNestedWithinUtilList"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map <  ?  ,     ?  >    things    =     (  ( Map <  ?  ,     ?  >  )     ( this . beanFactory . getBean (  \" map . of . things \"  )  )  )  ;", "assertNotNull ( things )  ;", "assertEquals (  2  ,    things . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomElementNestedWithinUtilMap"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Set <  ?  >    things    =     (  ( Set <  ?  >  )     ( this . beanFactory . getBean (  \" set . of . things \"  )  )  )  ;", "assertNotNull ( things )  ;", "assertEquals (  2  ,    things . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomElementNestedWithinUtilSet"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getBeanDefinition (  \" decorateWithAttribute \"  )  ;", "assertEquals (  \" foo \"  ,    beanDefinition . getAttribute (  \" objectName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDecorationViaAttribute"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   bean    =     (  ( ITestBean )     ( this . beanFactory . getBean (  \" debuggingTestBean \"  )  )  )  ;", "assertTestBean ( bean )  ;", "assertTrue ( AopUtils . isAopProxy ( bean )  )  ;", "Advisor [  ]    advisors    =     (  ( Advised )     ( bean )  )  . getAdvisors (  )  ;", "assertEquals (  \" Incorrect   number   of   advisors \"  ,     1  ,    advisors . length )  ;", "assertEquals (  \" Incorrect   advice   class \"  ,    DebugInterceptor . class ,    advisors [  0  ]  . getAdvice (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyingDecorator"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    beanNames    =    this . beanFactory . getBeanNamesForType ( ApplicationListener . class )  ;", "assertTrue ( Arrays . asList ( beanNames )  . contains (  \" debuggingTestBeanNoInstance \"  )  )  ;", "assertEquals ( ApplicationListener . class ,    this . beanFactory . getType (  \" debuggingTestBeanNoInstance \"  )  )  ;", "try    {", "this . beanFactory . getBean (  \" debuggingTestBeanNoInstance \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getRootCause (  )  )    instanceof   BeanInstantiationException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProxyingDecoratorNoInstance"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" customisedTestBean \"  )  )  )  ;", "assertTestBean ( bean )  ;", "}", "METHOD_END"], "methodName": ["testSimpleDecorator"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean \"  )  )  )  ;", "assertTestBean ( bean )  ;", "}", "METHOD_END"], "methodName": ["testSimpleParser"], "fileName": "org.springframework.beans.factory.xml.support.CustomNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   UUID . randomUUID (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createRandomKey"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache (  )  ;", "String   key    =    createRandomKey (  )  ;", ". assertNull ( cache . get ( key )  )  ;", "Object   value    =    cache . get ( key ,     (  )     -  >    returnValue )  ;", ". assertEquals ( returnValue ,    value )  ;", ". assertEquals ( value ,    cache . get ( key )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestCacheGetCallable"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache (  )  ;", "String   key    =    createRandomKey (  )  ;", "cache . put ( key ,    initialValue )  ;", "Object   value    =    cache . get ( key ,     (  )     -  >     {", "throw   new   IllegalStateException (  \" Should   not   have   been   invoked \"  )  ;", "}  )  ;", ". assertEquals ( initialValue ,    value )  ;", "}", "METHOD_END"], "methodName": ["doTestCacheGetCallableNotInvokedWithHit"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache (  )  ;", ". assertNull ( cache . get (  \" enescu \"  )  )  ;", "cache . put (  \" enescu \"  ,     \" george \"  )  ;", ". assertNull ( cache . get (  \" vlaicu \"  )  )  ;", "cache . put (  \" vlaicu \"  ,     \" aurel \"  )  ;", "cache . clear (  )  ;", ". assertNull ( cache . get (  \" vlaicu \"  )  )  ;", ". assertNull ( cache . get (  \" enescu \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheClear"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "doTestCacheGetCallable (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["testCacheGetCallable"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache (  )  ;", "String   key    =    createRandomKey (  )  ;", ". assertNull ( cache . get ( key )  )  ;", "try    {", "cache . get ( key ,     (  )     -  >     {", "throw   new   UnsupportedOperationException (  \" Expected   exception \"  )  ;", "}  )  ;", "}    catch    ( Cache . ValueRetrievalException   ex )     {", ". assertNotNull ( ex . getCause (  )  )  ;", ". assertEquals ( UnsupportedOperationException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCacheGetCallableFail"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "doTestCacheGetCallableNotInvokedWithHit (  \" existing \"  )  ;", "}", "METHOD_END"], "methodName": ["testCacheGetCallableNotInvokedWithHit"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "doTestCacheGetCallableNotInvokedWithHit ( null )  ;", "}", "METHOD_END"], "methodName": ["testCacheGetCallableNotInvokedWithHitNull"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "doTestCacheGetCallable ( null )  ;", "}", "METHOD_END"], "methodName": ["testCacheGetCallableWithNull"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache (  )  ;", "final   AtomicInteger   counter    =    new   AtomicInteger (  )  ;", "final   List < Object >    results    =    new   CopyOnWriteArrayList <  >  (  )  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  0  )  ;", "String   key    =    createRandomKey (  )  ;", "Runnable   run    =     (  )     -  >     {", "try    {", "Integer   value    =    cache . get ( key ,     (  )     -  >     {", "Thread . sleep (  5  0  )  ;", "return   counter . incrementAndGet (  )  ;", "}  )  ;", "results . add ( value )  ;", "}    finally    {", "latch . countDown (  )  ;", "}", "}  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "new   Thread ( run )  . start (  )  ;", "}", "latch . await (  )  ;", ". assertEquals (  1  0  ,    results . size (  )  )  ;", "results . forEach (  (    r )     -  >    assertThat ( r ,     . is (  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheGetSynchronized"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "AbstractCacheTests . assertEquals ( AbstractCacheTests . CACHE _ NAME ,    getCache (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheName"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache (  )  ;", "String   key    =    createRandomKey (  )  ;", "Object   value    =     \" george \"  ;", ". assertNull ( cache . get ( key )  )  ;", ". assertNull ( cache . get ( key ,    String . class )  )  ;", ". assertNull ( cache . get ( key ,    Object . class )  )  ;", "cache . put ( key ,    value )  ;", ". assertEquals ( value ,    cache . get ( key )  . get (  )  )  ;", ". assertEquals ( value ,    cache . get ( key ,    String . class )  )  ;", ". assertEquals ( value ,    cache . get ( key ,    Object . class )  )  ;", ". assertEquals ( value ,    cache . get ( key ,     (  ( Class <  ?  >  )     ( null )  )  )  )  ;", "cache . put ( key ,    null )  ;", ". assertNotNull ( cache . get ( key )  )  ;", ". assertNull ( cache . get ( key )  . get (  )  )  ;", ". assertNull ( cache . get ( key ,    String . class )  )  ;", ". assertNull ( cache . get ( key ,    Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCachePut"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache (  )  ;", "String   key    =    createRandomKey (  )  ;", "Object   value    =     \" initialValue \"  ;", ". assertNull ( cache . get ( key )  )  ;", ". assertNull ( cache . putIfAbsent ( key ,    value )  )  ;", ". assertEquals ( value ,    cache . get ( key )  . get (  )  )  ;", ". assertEquals (  \" initialValue \"  ,    cache . putIfAbsent ( key ,     \" anotherValue \"  )  . get (  )  )  ;", ". assertEquals ( value ,    cache . get ( key )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCachePutIfAbsent"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache (  )  ;", "String   key    =    createRandomKey (  )  ;", "Object   value    =     \" george \"  ;", ". assertNull ( cache . get ( key )  )  ;", "cache . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["testCacheRemove"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "AbstractCacheTests . assertSame ( getNativeCache (  )  ,    getCache (  )  . getNativeCache (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNativeCache"], "fileName": "org.springframework.cache.AbstractCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   cache    =    getCache ( false )  ;", "String   key    =    createRandomKey (  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  . CACHE _ NAME _ NO _ NULL )  ;", "this . thrown . expectMessage (  \" is   configured   to   not   allow   null   values   but   null   was   provided \"  )  ;", "cache . put ( key ,    null )  ;", "}", "METHOD_END"], "methodName": ["testCachePutNullValueAllowNullFalse"], "fileName": "org.springframework.cache.AbstractValueAdaptingCacheTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  1  1  2  4 Config . class )  ;", "CacheReproTests . Spr 1  1  1  2  4 Service   bean    =    context . getBean ( CacheReproTests . Spr 1  1  1  2  4 Service . class )  ;", "bean . single (  2  )  ;", "bean . single (  2  )  ;", "bean . multiple (  2  )  ;", "bean . multiple (  2  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr11124MultipleAnnotations"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  1  2  4  9 Config . class )  ;", "CacheReproTests . Spr 1  1  2  4  9 Service   bean    =    context . getBean ( CacheReproTests . Spr 1  1  2  4  9 Service . class )  ;", "Object   result    =    bean . doSomething (  \" op \"  ,     2  ,     3  )  ;", "assertSame ( result ,    bean . doSomething (  \" op \"  ,     2  ,     3  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr11249PrimitiveVarargs"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  1  5  9  2 Config . class )  ;", "CacheReproTests . Spr 1  1  5  9  2 Service   bean    =    context . getBean ( CacheReproTests . Spr 1  1  5  9  2 Service . class )  ;", "Cache   cache    =    context . getBean (  \" cache \"  ,    Cache . class )  ;", "String   key    =     \"  1  \"  ;", "Object   result    =    bean . getNeverCache (  \"  1  \"  )  ;", "verify ( cache ,    times (  0  )  )  . get ( key )  ;", "Object   cachedResult    =    bean . getNeverCache (  \"  1  \"  )  ;", "assertNotSame ( result ,    cachedResult )  ;", "verify ( cache ,    times (  0  )  )  . get ( key )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr11592GetNeverCache"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  1  5  9  2 Config . class )  ;", "CacheReproTests . Spr 1  1  5  9  2 Service   bean    =    context . getBean ( CacheReproTests . Spr 1  1  5  9  2 Service . class )  ;", "Cache   cache    =    context . getBean (  \" cache \"  ,    Cache . class )  ;", "String   key    =     \"  1  \"  ;", "Object   result    =    bean . getSimple (  \"  1  \"  )  ;", "verify ( cache ,    times (  1  )  )  . get ( key )  ;", "Object   cachedResult    =    bean . getSimple (  \"  1  \"  )  ;", "assertSame ( result ,    cachedResult )  ;", "verify ( cache ,    times (  2  )  )  . get ( key )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr11592GetSimple"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  3  0  8  1 Config . class )  ;", "CacheReproTests . Spr 1  3  0  8  1 Service   bean    =    context . getBean ( CacheReproTests . Spr 1  3  0  8  1 Service . class )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage ( CacheReproTests . MyCacheResolver . class . getName (  )  )  ;", "bean . getSimple ( null )  ;", "}", "METHOD_END"], "methodName": ["spr13081ConfigFailIfCacheResolverReturnsNullCacheName"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  3  0  8  1 Config . class )  ;", "CacheReproTests . MyCacheResolver   cacheResolver    =    context . getBean ( CacheReproTests . MyCacheResolver . class )  ;", "CacheReproTests . Spr 1  3  0  8  1 Service   bean    =    context . getBean ( CacheReproTests . Spr 1  3  0  8  1 Service . class )  ;", "assertNull ( cacheResolver . getCache (  \" foo \"  )  . get (  \" foo \"  )  )  ;", "Object   result    =    bean . getSimple (  \" foo \"  )  ;", "assertEquals ( result ,    cacheResolver . getCache (  \" foo \"  )  . get (  \" foo \"  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["spr13081ConfigNoCacheNameIsRequired"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  4  2  3  0 Config . class )  ;", "CacheReproTests . Spr 1  4  2  3  0 Service   bean    =    context . getBean ( CacheReproTests . Spr 1  4  2  3  0 Service . class )  ;", "Cache   cache    =    context . getBean ( CacheManager . class )  . getCache (  \" itemCache \"  )  ;", "TestBean   tb    =    new   TestBean (  \" tb 1  \"  )  ;", "bean . insertItem ( tb )  ;", "assertSame ( tb ,    bean . findById (  \" tb 1  \"  )  . get (  )  )  ;", "assertSame ( tb ,    cache . get (  \" tb 1  \"  )  . get (  )  )  ;", "cache . clear (  )  ;", "TestBean   tb 2     =    bean . findById (  \" tb 1  \"  )  . get (  )  ;", "assertNotSame ( tb ,    tb 2  )  ;", "assertSame ( tb 2  ,    cache . get (  \" tb 1  \"  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["spr14230AdaptsToOptional"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  4  8  5  3 Config . class )  ;", "CacheReproTests . Spr 1  4  8  5  3 Service   bean    =    context . getBean ( CacheReproTests . Spr 1  4  8  5  3 Service . class )  ;", "Cache   cache    =    context . getBean ( CacheManager . class )  . getCache (  \" itemCache \"  )  ;", "TestBean   tb    =    new   TestBean (  \" tb 1  \"  )  ;", "bean . insertItem ( tb )  ;", "assertSame ( tb ,    bean . findById (  \" tb 1  \"  )  . get (  )  )  ;", "assertSame ( tb ,    cache . get (  \" tb 1  \"  )  . get (  )  )  ;", "cache . clear (  )  ;", "TestBean   tb 2     =    bean . findById (  \" tb 1  \"  )  . get (  )  ;", "assertNotSame ( tb ,    tb 2  )  ;", "assertSame ( tb 2  ,    cache . get (  \" tb 1  \"  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["spr14853AdaptsToOptionalWithSync"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  5  2  7  1 ConfigB . class )  ;", "CacheReproTests . Spr 1  5  2  7  1 Interface   bean    =    context . getBean ( CacheReproTests . Spr 1  5  2  7  1 Interface . class )  ;", "Cache   cache    =    context . getBean ( CacheManager . class )  . getCache (  \" itemCache \"  )  ;", "TestBean   tb    =    new   TestBean (  \" tb 1  \"  )  ;", "bean . insertItem ( tb )  ;", "assertSame ( tb ,    bean . findById (  \" tb 1  \"  )  . get (  )  )  ;", "assertSame ( tb ,    cache . get (  \" tb 1  \"  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["spr15271FindsOnInterfaceWithCglibProxy"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheReproTests . Spr 1  5  2  7  1 ConfigA . class )  ;", "CacheReproTests . Spr 1  5  2  7  1 Interface   bean    =    context . getBean ( CacheReproTests . Spr 1  5  2  7  1 Interface . class )  ;", "Cache   cache    =    context . getBean ( CacheManager . class )  . getCache (  \" itemCache \"  )  ;", "TestBean   tb    =    new   TestBean (  \" tb 1  \"  )  ;", "bean . insertItem ( tb )  ;", "assertSame ( tb ,    bean . findById (  \" tb 1  \"  )  . get (  )  )  ;", "assertSame ( tb ,    cache . get (  \" tb 1  \"  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["spr15271FindsOnInterfaceWithInterfaceProxy"], "fileName": "org.springframework.cache.CacheReproTests"}, {"methodBody": ["METHOD_START", "{", "for    ( Cache    :     )     {", "Cache . ValueWrapper   wrapper    =    get ( key )  ;", "assertNotNull (  (  (  (  \" An   entry   in    \"     +        +     \"    should   have   been   found   with   key    \"  )     +    key )  ,    wrapper )  ;", "assertEquals (  (  (  (  \" Wrong   value   in    \"     +        +     \"    for   entry   with   key    \"  )     +    key )  ,    value ,    wrapper . get (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertCacheHit"], "fileName": "org.springframework.cache.CacheTestUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Cache    :     )     {", "assertNull (  (  (  (  \" No   entry   in    \"     +        +     \"    should   have   been   found   with   key    \"  )     +    key )  ,    get ( key )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertCacheMiss"], "fileName": "org.springframework.cache.CacheTestUtils"}, {"methodBody": ["METHOD_START", "{", "SimpleCacheManager   result    =    new   SimpleCacheManager (  )  ;", "List < Cache >    caches    =    new   ArrayList <  >  (  )  ;", "for    ( String   cacheName    :    cacheNames )     {", "caches . add ( new   ConcurrentMapCache ( cacheName )  )  ;", "}", "result . setCaches ( caches )  ;", "result . afterPropertiesSet (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createSimpleCacheManager"], "fileName": "org.springframework.cache.CacheTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   UUID . randomUUID (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createRandomKey"], "fileName": "org.springframework.cache.NoOpCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =    createRandomKey (  )  ;", "Cache   cache    =    this . m . getCache ( name )  ;", "Object   returnValue    =    new   Object (  )  ;", "Object   value    =    cache . get ( new   Object (  )  ,     (  )     -  >    returnValue )  ;", "assertEquals ( returnValue ,    value )  ;", "}", "METHOD_END"], "methodName": ["testCacheCallable"], "fileName": "org.springframework.cache.NoOpCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    this . manager . getCache ( createRandomKey (  )  )  ;", "String   key    =    createRandomKey (  )  ;", "try    {", "cache . get ( key ,     (  )     -  >     {", "throw   new   UnsupportedOperationException (  \" Expected   exception \"  )  ;", "}  )  ;", "}    catch    ( Cache . ValueRetrievalException   ex )     {", "assertNotNull ( ex . getCause (  )  )  ;", "assertEquals ( UnsupportedOperationException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCacheGetCallableFail"], "fileName": "org.springframework.cache.NoOpCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" bucket \"  ;", "assertFalse ( this . m . getCacheNames (  )  . contains ( name )  )  ;", "this . m . getCache ( name )  ;", "assertTrue ( this . m . getCacheNames (  )  . contains ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheName"], "fileName": "org.springframework.cache.NoOpCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    this . manager . getCache (  \" bucket \"  )  ;", "assertNotNull ( cache )  ;", "assertSame ( cache ,    this . manager . getCache (  \" bucket \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetCache"], "fileName": "org.springframework.cache.NoOpCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =    createRandomKey (  )  ;", "Cache   cache    =    this . m . getCache ( name )  ;", "assertEquals ( name ,    cache . getName (  )  )  ;", "Object   key    =    new   Object (  )  ;", "cache . put ( key ,    new   Object (  )  )  ;", "assertNull ( cache . get ( key )  )  ;", "assertNull ( cache . get ( key ,    Object . class )  )  ;", "assertSame ( cache ,    cache . getNativeCache (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoOpCache"], "fileName": "org.springframework.cache.NoOpCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( configurers )  )     {", "return ;", "}", "if    (  ( configurers . size (  )  )     >     1  )     {", "throw   new   IllegalStateException (  (  (  (  (  ( configurers . size (  )  )     +     \"    implementations   of    \"  )     +     \" er   were   found   when   only    1    was   expected .     \"  )     +     \" Refactor   the   configuration   such   that   er   is    \"  )     +     \" implemented   only   once   or   not   at   all .  \"  )  )  ;", "}", "er   configurer    =    configurers . iterator (  )  . next (  )  ;", "useer ( configurer )  ;", "}", "METHOD_END"], "methodName": ["setConfigurers"], "fileName": "org.springframework.cache.annotation.AbstractCachingConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . cacheManager    =    config . cacheManager (  )  ;", "this . cacheResolver    =    config . cacheResolver (  )  ;", "this . keyGenerator    =    config . keyGenerator (  )  ;", "this . errorHandler    =    config . errorHandler (  )  ;", "}", "METHOD_END"], "methodName": ["useCachingConfigurer"], "fileName": "org.springframework.cache.annotation.AbstractCachingConfiguration"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    null ;", "for    ( CacheAnnotationParser   annotationParser    :    this . annotationParsers )     {", "Collection < CacheOperation >    annOps    =    provider . getCacheOperations ( annotationParser )  ;", "if    ( annOps    !  =    null )     {", "if    ( ops    =  =    null )     {", "ops    =    new   ArrayList <  >  (  )  ;", "}", "ops . addAll ( annOps )  ;", "}", "}", "return   ops ;", "}", "METHOD_END"], "methodName": ["determineCacheOperations"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Wrong   key   manager \"  ,    keyGenerator ,    actual . getKeyGenerator (  )  )  ;", "assertEquals (  \" Wrong      manager \"  ,    Manager ,    actual . getCacheManager (  )  )  ;", "assertEquals (  \" Wrong      resolver \"  ,    Resolver ,    actual . getCacheResolver (  )  )  ;", "assertEquals (  \" Wrong   number   of      names \"  ,    Names . length ,    actual . getCacheNames (  )  . size (  )  )  ;", "Arrays . stream ( Names )  . forEach (  (    Name )     -  >    assertTrue (  (  (  (  \" Cache    '  \"     +    Name )     +     \"  '    not   found   in    \"  )     +     ( actual . getCacheNames (  )  )  )  ,    actual . getCacheNames (  )  . contains ( Name )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSharedConfig"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . InterfaceCacheConfig . class ,     \" interfaceCacheableOverride \"  )  ;", "assertSame (  1  ,    ops . size (  )  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertTrue (  ( cacheOperation   instanceof   CacheableOperation )  )  ;", "}", "METHOD_END"], "methodName": ["cacheAnnotationOverride"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . InterfaceCacheConfig . class ,     \" interfaceCacheConfig \"  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \"  \"  ,     \"  \"  ,     \"  \"  ,     \" myCache \"  )  ;", "}", "METHOD_END"], "methodName": ["cacheConfigFromInterface"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . exception . expect ( IllegalStateException . class )  ;", "getOps (  . AnnotatedClass . class ,     \" invalidCacheResolverAndCacheManagerSet \"  )  ;", "}", "METHOD_END"], "methodName": ["cacheResolverAndCacheManagerCannotBeSetTogether"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" caching \"  ,     2  )  ;", "Iterator < CacheOperation >    it    =    ops . iterator (  )  ;", "assertTrue (  (  ( it . next (  )  )    instanceof   CacheableOperation )  )  ;", "assertTrue (  (  ( it . next (  )  )    instanceof   CacheEvictOperation )  )  ;", "}", "METHOD_END"], "methodName": ["caching"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" customCacheManager \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertEquals (  \" Custom   cache   manager   not   set \"  ,     \" custom \"  ,    cacheOperation . getCacheManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["customCacheManager"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" customCacheManagerInherited \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertEquals (  \" Custom   cache   manager   not   set \"  ,     \" custom \"  ,    cacheOperation . getCacheManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["customCacheManagerInherited"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" customCacheResolver \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertEquals (  \" Custom   cache   resolver   not   set \"  ,     \" custom \"  ,    cacheOperation . getCacheResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["customCacheResolver"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" customCacheResolverInherited \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertEquals (  \" Custom   cache   resolver   not   set \"  ,     \" custom \"  ,    cacheOperation . getCacheResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["customCacheResolverInherited"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClassWithCustomDefault . class ,     \" methodLevelCacheName \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \" classKeyGenerator \"  ,     \"  \"  ,     \" classCacheResolver \"  ,     \" custom \"  )  ;", "}", "METHOD_END"], "methodName": ["customClassLevelWithCustomCacheName"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" customKeyGenerator \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertEquals (  \" Custom   key   generator   not   set \"  ,     \" custom \"  ,    cacheOperation . getKeyGenerator (  )  )  ;", "}", "METHOD_END"], "methodName": ["customKeyGenerator"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" customKeyGeneratorInherited \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertEquals (  \" Custom   key   generator   not   set \"  ,     \" custom \"  ,    cacheOperation . getKeyGenerator (  )  )  ;", "}", "METHOD_END"], "methodName": ["customKeyGeneratorInherited"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" emptyCaching \"  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["emptyCaching"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClassWithFullDefault . class ,     \" methodLevelCacheManager \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \" classKeyGenerator \"  ,     \" custom \"  ,     \"  \"  ,     \" classCacheName \"  )  ;", "}", "METHOD_END"], "methodName": ["fullClassLevelWithCustomCacheManager"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClassWithFullDefault . class ,     \" methodLevelCacheName \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \" classKeyGenerator \"  ,     \"  \"  ,     \" classCacheResolver \"  ,     \" custom \"  )  ;", "}", "METHOD_END"], "methodName": ["fullClassLevelWithCustomCacheName"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClassWithFullDefault . class ,     \" methodLevelCacheResolver \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \" classKeyGenerator \"  ,     \"  \"  ,     \" custom \"  ,     \" classCacheName \"  )  ;", "}", "METHOD_END"], "methodName": ["fullClassLevelWithCustomCacheResolver"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClassWithFullDefault . class ,     \" methodLevelKeyGenerator \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \" custom \"  ,     \"  \"  ,     \" classCacheResolver \"  ,     \" classCacheName \"  )  ;", "}", "METHOD_END"], "methodName": ["fullClassLevelWithCustomKeyManager"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   method    =    target . getMethod ( name )  ;", "return   this . source . gets ( method ,    target )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getOps"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    result    =    getOps ( target ,    name )  ;", "assertEquals (  (  (  \" Wrong   number   of   operation ( s )    for    '  \"     +    name )     +     \"  '  \"  )  ,    expectedNumberOfOperations ,    result . size (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getOps"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . exception . expect ( IllegalStateException . class )  ;", "getOps (  . AnnotatedClass . class ,     \" invalidKeyAndKeyGeneratorSet \"  )  ;", "}", "METHOD_END"], "methodName": ["keyAndKeyGeneratorCannotBeSetTogether"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" multiple \"  ,     2  )  ;", "Iterator < CacheOperation >    it    =    ops . iterator (  )  ;", "assertTrue (  (  ( it . next (  )  )    instanceof   CacheableOperation )  )  ;", "assertTrue (  (  ( it . next (  )  )    instanceof   CacheEvictOperation )  )  ;", "}", "METHOD_END"], "methodName": ["multipleAnnotation"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" multipleComposed \"  ,     4  )  ;", "Iterator < CacheOperation >    it    =    ops . iterator (  )  ;", "CacheOperation   cacheOperation    =    it . next (  )  ;", "assertThat ( cacheOperation ,    instanceOf ( CacheableOperation . class )  )  ;", "assertThat ( cacheOperation . getCacheNames (  )  ,    equalTo ( Collections . singleton (  \" directly   declared \"  )  )  )  ;", "assertThat ( cacheOperation . getKey (  )  ,    equalTo (  \"  \"  )  )  ;", "cacheOperation    =    it . next (  )  ;", "assertThat ( cacheOperation ,    instanceOf ( CacheableOperation . class )  )  ;", "assertThat ( cacheOperation . getCacheNames (  )  ,    equalTo ( Collections . singleton (  \" composedCache \"  )  )  )  ;", "assertThat ( cacheOperation . getKey (  )  ,    equalTo (  \" composedKey \"  )  )  ;", "cacheOperation    =    it . next (  )  ;", "assertThat ( cacheOperation ,    instanceOf ( CacheableOperation . class )  )  ;", "assertThat ( cacheOperation . getCacheNames (  )  ,    equalTo ( Collections . singleton (  \" foo \"  )  )  )  ;", "assertThat ( cacheOperation . getKey (  )  ,    equalTo (  \"  \"  )  )  ;", "cacheOperation    =    it . next (  )  ;", "assertThat ( cacheOperation ,    instanceOf ( CacheEvictOperation . class )  )  ;", "assertThat ( cacheOperation . getCacheNames (  )  ,    equalTo ( Collections . singleton (  \" composedCacheEvict \"  )  )  )  ;", "assertThat ( cacheOperation . getKey (  )  ,    equalTo (  \" composedEvictionKey \"  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleComposedAnnotations"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" multipleStereotype \"  ,     3  )  ;", "Iterator < CacheOperation >    it    =    ops . iterator (  )  ;", "assertTrue (  (  ( it . next (  )  )    instanceof   CacheableOperation )  )  ;", "CacheOperation   next    =    it . next (  )  ;", "assertTrue (  ( next   instanceof   CacheEvictOperation )  )  ;", "assertTrue ( next . getCacheNames (  )  . contains (  \" foo \"  )  )  ;", "next    =    it . next (  )  ;", "assertTrue (  ( next   instanceof   CacheEvictOperation )  )  ;", "assertTrue ( next . getCacheNames (  )  . contains (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleStereotypes"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClassWithSomeDefault . class ,     \" methodLevelCacheManager \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \" classKeyGenerator \"  ,     \" custom \"  ,     \"  \"  ,     \" classCacheName \"  )  ;", "}", "METHOD_END"], "methodName": ["partialClassLevelWithCustomCacheManager"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClassWithSomeDefault . class ,     \" methodLevelCacheResolver \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \" classKeyGenerator \"  ,     \"  \"  ,     \" custom \"  ,     \" classCacheName \"  )  ;", "}", "METHOD_END"], "methodName": ["partialClassLevelWithCustomCacheResolver"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClassWithSomeDefault . class ,     \" noCustomization \"  ,     1  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \" classKeyGenerator \"  ,     \" classCacheManager \"  ,     \"  \"  ,     \" classCacheName \"  )  ;", "}", "METHOD_END"], "methodName": ["partialClassLevelWithNoCustomization"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . MultipleCacheConfig . class ,     \" multipleCacheConfig \"  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertSharedConfig ( cacheOperation ,     \"  \"  ,     \"  \"  ,     \"  \"  ,     \" myCache \"  )  ;", "}", "METHOD_END"], "methodName": ["severalCacheConfigUseClosest"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" singleComposed \"  ,     2  )  ;", "Iterator < CacheOperation >    it    =    ops . iterator (  )  ;", "CacheOperation   cacheOperation    =    it . next (  )  ;", "assertThat ( cacheOperation ,    instanceOf ( CacheableOperation . class )  )  ;", "assertThat ( cacheOperation . getCacheNames (  )  ,    equalTo ( Collections . singleton (  \" directly   declared \"  )  )  )  ;", "assertThat ( cacheOperation . getKey (  )  ,    equalTo (  \"  \"  )  )  ;", "cacheOperation    =    it . next (  )  ;", "assertThat ( cacheOperation ,    instanceOf ( CacheableOperation . class )  )  ;", "assertThat ( cacheOperation . getCacheNames (  )  ,    equalTo ( Collections . singleton (  \" composedCache \"  )  )  )  ;", "assertThat ( cacheOperation . getKey (  )  ,    equalTo (  \" composedKey \"  )  )  ;", "}", "METHOD_END"], "methodName": ["singleComposedAnnotation"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" singular \"  ,     1  )  ;", "assertTrue (  (  ( ops . iterator (  )  . next (  )  )    instanceof   CacheableOperation )  )  ;", "}", "METHOD_END"], "methodName": ["singularAnnotation"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" singleStereotype \"  ,     1  )  ;", "assertTrue (  (  ( ops . iterator (  )  . next (  )  )    instanceof   CacheEvictOperation )  )  ;", "}", "METHOD_END"], "methodName": ["singularStereotype"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps ( AnnotationCacheOperationSourceTests . AnnotatedClass . class ,     \" noCacheNameSpecified \"  )  ;", "CacheOperation   cacheOperation    =    ops . iterator (  )  . next (  )  ;", "assertNotNull (  \" cache   names   set   must   not   be   null \"  ,    cacheOperation . getCacheNames (  )  )  ;", "assertEquals (  \" no   cache   names   specified \"  ,     0  ,    cacheOperation . getCacheNames (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["validateNoCacheIsValid"], "fileName": "org.springframework.cache.annotation.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "result . add (  . CACHE _ ASPECT _ CONFIGURATION _ CLASS _ NAME )  ;", "if    (  (  . jsr 1  0  7 Present )     &  &     (  . jcacheImplPresent )  )     {", "result . add (  . JCACHE _ ASPECT _ CONFIGURATION _ CLASS _ NAME )  ;", "}", "return   StringUtils . toStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["getAspectJImports"], "fileName": "org.springframework.cache.annotation.CachingConfigurationSelector"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "result . add ( AutoProxyRegistrar . class . getName (  )  )  ;", "result . add ( ProxyCachingConfiguration . class . getName (  )  )  ;", "if    (  (  . jsr 1  0  7 Present )     &  &     (  . jcacheImplPresent )  )     {", "result . add (  . PROXY _ JCACHE _ CONFIGURATION _ CLASS )  ;", "}", "return   StringUtils . toStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["getProxyImports"], "fileName": "org.springframework.cache.annotation.CachingConfigurationSelector"}, {"methodBody": ["METHOD_START", "{", "BeanFactoryCacheOperationSourceAdvisor   advisor    =    new   BeanFactoryCacheOperationSourceAdvisor (  )  ;", "advisor . setCacheOperationSource ( cacheOperationSource (  )  )  ;", "advisor . setAdvice ( cacheInterceptor (  )  )  ;", "if    (  ( this . enable )     !  =    null )     {", "advisor . setOrder ( this . enable .  < Integer > getNumber (  \" order \"  )  )  ;", "}", "return   advisor ;", "}", "METHOD_END"], "methodName": ["cacheAdvisor"], "fileName": "org.springframework.cache.annotation.ProxyCachingConfiguration"}, {"methodBody": ["METHOD_START", "{", "CacheInterceptor   interceptor    =    new   CacheInterceptor (  )  ;", "interceptor . setCacheOpeSources ( cacheOpeSource (  )  )  ;", "if    (  ( this . cacheResolver )     !  =    null )     {", "interceptor . setCacheResolver ( this . cacheResolver )  ;", "} else", "if    (  ( this . cacheManager )     !  =    null )     {", "interceptor . setCacheManager ( this . cacheManager )  ;", "}", "if    (  ( this . keyGenerator )     !  =    null )     {", "interceptor . setKeyGenerator ( this . keyGenerator )  ;", "}", "if    (  ( this . errorHandler )     !  =    null )     {", "interceptor . setErrorHandler ( this . errorHandler )  ;", "}", "return   interceptor ;", "}", "METHOD_END"], "methodName": ["cacheInterceptor"], "fileName": "org.springframework.cache.annotation.ProxyCachingConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotationCacheOperationSource (  )  ;", "}", "METHOD_END"], "methodName": ["cacheOperationSource"], "fileName": "org.springframework.cache.annotation.ProxyCachingConfiguration"}, {"methodBody": ["METHOD_START", "{", "CacheConfig   annotation    =    AnnotatedElementUtils . findMergedAnnotation ( target ,    CacheConfig . class )  ;", "if    ( annotation    !  =    null )     {", "return   new    . DefaultCacheConfig ( annotation . cacheNames (  )  ,    annotation . keyGenerator (  )  ,    annotation . cacheManager (  )  ,    annotation . cacheResolver (  )  )  ;", "}", "return   new    . DefaultCacheConfig (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCacheConfig"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "return   ops    !  =    null    ?    ops    :    new   ArrayList <  >  (  1  )  ;", "}", "METHOD_END"], "methodName": ["lazyInit"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    parseCacheAnnotations ( cachingConfig ,    ae ,    false )  ;", "if    (  (  ( ops    !  =    null )     &  &     (  ( ops . size (  )  )     >     1  )  )     &  &     (  ( ae . getAnnotations (  )  . length )     >     0  )  )     {", "Collection < CacheOperation >    localOps    =    parseCacheAnnotations ( cachingConfig ,    ae ,    true )  ;", "if    ( localOps    !  =    null )     {", "return   localOps ;", "}", "}", "return   ops ;", "}", "METHOD_END"], "methodName": ["parseCacheAnnotations"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    null ;", "Collection < Cacheable >    cacheables    =     ( localOnly )     ?    AnnotatedElementUtils . getAllMergedAnnotations ( ae ,    Cacheable . class )     :    AnnotatedElementUtils . findAllMergedAnnotations ( ae ,    Cacheable . class )  ;", "if    (  !  ( cacheables . isEmpty (  )  )  )     {", "ops    =    lazyInit ( null )  ;", "for    ( Cacheable   cacheable    :    cacheables )     {", "ops . add ( parseCacheabl ( ae ,    cachingConfig ,    cacheable )  )  ;", "}", "}", "Collection < CacheEvict >    evicts    =     ( localOnly )     ?    AnnotatedElementUtils . getAllMergedAnnotations ( ae ,    CacheEvict . class )     :    AnnotatedElementUtils . findAllMergedAnnotations ( ae ,    CacheEvict . class )  ;", "if    (  !  ( evicts . isEmpty (  )  )  )     {", "ops    =    lazyInit ( ops )  ;", "for    ( CacheEvict   evict    :    evicts )     {", "ops . add ( parseEvictAnnotation ( ae ,    cachingConfig ,    evict )  )  ;", "}", "}", "Collection < CachePut >    puts    =     ( localOnly )     ?    AnnotatedElementUtils . getAllMergedAnnotations ( ae ,    CachePut . class )     :    AnnotatedElementUtils . findAllMergedAnnotations ( ae ,    CachePut . class )  ;", "if    (  !  ( puts . isEmpty (  )  )  )     {", "ops    =    lazyInit ( ops )  ;", "for    ( CachePut   put    :    puts )     {", "ops . add ( parsePutAnnotation ( ae ,    cachingConfig ,    put )  )  ;", "}", "}", "Collection < Caching >    cachings    =     ( localOnly )     ?    AnnotatedElementUtils . getAllMergedAnnotations ( ae ,    Caching . class )     :    AnnotatedElementUtils . findAllMergedAnnotations ( ae ,    Caching . class )  ;", "if    (  !  ( cachings . isEmpty (  )  )  )     {", "ops    =    lazyInit ( ops )  ;", "for    ( Caching   caching    :    cachings )     {", "Collection < CacheOperation >    cachingOps    =    parseCachingAnnotation ( ae ,    cachingConfig ,    caching )  ;", "if    ( cachingOps    !  =    null )     {", "ops . addAll ( cachingOps )  ;", "}", "}", "}", "return   ops ;", "}", "METHOD_END"], "methodName": ["parseCacheAnnotations"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "CacheableOperation . Builder   builder    =    new   CacheableOperation . Builder (  )  ;", "builder . setName ( ae . toString (  )  )  ;", "builder . setCacheNames ( cacheable . cacheNames (  )  )  ;", "builder . setCondition ( cacheable . condition (  )  )  ;", "builder . setUnless ( cacheable . unless (  )  )  ;", "builder . setKey ( cacheable . key (  )  )  ;", "builder . setKeyGenerator ( cacheable . keyGenerator (  )  )  ;", "builder . setCacheManager ( cacheable . cacheManager (  )  )  ;", "builder . setCacheResolver ( cacheable . cacheResolver (  )  )  ;", "builder . setSync ( cacheable . sync (  )  )  ;", "defaultConfig . applyDefault ( builder )  ;", "CacheableOperation   op    =    builder . build (  )  ;", "validateCacheOperation ( ae ,    op )  ;", "return   op ;", "}", "METHOD_END"], "methodName": ["parseCacheableAnnotation"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    null ;", "Cacheable [  ]    cacheables    =    caching . cacheable (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( cacheables )  )  )     {", "ops    =    lazyInit ( null )  ;", "for    ( Cacheable   cacheable    :    cacheables )     {", "ops . add ( parseCacheabl ( ae ,    defaultConfig ,    cacheable )  )  ;", "}", "}", "CacheEvict [  ]    cacheEvicts    =    caching . evict (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( cacheEvicts )  )  )     {", "ops    =    lazyInit ( ops )  ;", "for    ( CacheEvict   cacheEvict    :    cacheEvicts )     {", "ops . add ( parseEvictAnnotation ( ae ,    defaultConfig ,    cacheEvict )  )  ;", "}", "}", "CachePut [  ]    cachePuts    =    caching . put (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( cachePuts )  )  )     {", "ops    =    lazyInit ( ops )  ;", "for    ( CachePut   cachePut    :    cachePuts )     {", "ops . add ( parsePutAnnotation ( ae ,    defaultConfig ,    cachePut )  )  ;", "}", "}", "return   ops ;", "}", "METHOD_END"], "methodName": ["parseCachingAnnotation"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "CacheEvictOperation . Builder   builder    =    new   CacheEvictOperation . Builder (  )  ;", "builder . setName ( ae . toString (  )  )  ;", "builder . setCacheNames ( cacheEvict . cacheNames (  )  )  ;", "builder . setCondition ( cacheEvict . condition (  )  )  ;", "builder . setKey ( cacheEvict . key (  )  )  ;", "builder . setKeyGenerator ( cacheEvict . keyGenerator (  )  )  ;", "builder . setCacheManager ( cacheEvict . cacheManager (  )  )  ;", "builder . setCacheResolver ( cacheEvict . cacheResolver (  )  )  ;", "builder . setCacheWide ( cacheEvict . allEntries (  )  )  ;", "builder . setBeforeInvocation ( cacheEvict . beforeInvocation (  )  )  ;", "defaultConfig . applyDefault ( builder )  ;", "CacheEvictOperation   op    =    builder . build (  )  ;", "validateCacheOperation ( ae ,    op )  ;", "return   op ;", "}", "METHOD_END"], "methodName": ["parseEvictAnnotation"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "CachePutOperation . Builder   builder    =    new   CachePutOperation . Builder (  )  ;", "builder . setName ( ae . toString (  )  )  ;", "builder . setCacheNames ( cachePut . cacheNames (  )  )  ;", "builder . setCondition ( cachePut . condition (  )  )  ;", "builder . setUnless ( cachePut . unless (  )  )  ;", "builder . setKey ( cachePut . key (  )  )  ;", "builder . setKeyGenerator ( cachePut . keyGenerator (  )  )  ;", "builder . setCacheManager ( cachePut . cacheManager (  )  )  ;", "builder . setCacheResolver ( cachePut . cacheResolver (  )  )  ;", "defaultConfig . applyDefault ( builder )  ;", "CachePutOperation   op    =    builder . build (  )  ;", "validateCacheOperation ( ae ,    op )  ;", "return   op ;", "}", "METHOD_END"], "methodName": ["parsePutAnnotation"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( StringUtils . hasText ( operation . getKey (  )  )  )     &  &     ( StringUtils . hasText ( operation . getKeyGenerator (  )  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  \" Invalid   cache      configuration   on    '  \"     +     ( ae . toString (  )  )  )     +     \"  '  .    Both    ' key '    and    ' keyGenerator '    attributes   have   been   set .     \"  )     +     \" These   attributes   are   mutually   exclusive :    either   set   the   SpEL   expression   used   to \"  )     +     \" compute   the   key   at   runtime   or   set   the   name   of   the   KeyGenerator   bean   to   use .  \"  )  )  ;", "}", "if    (  ( StringUtils . hasText ( operation . getCacheManager (  )  )  )     &  &     ( StringUtils . hasText ( operation . getCacheResolver (  )  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" Invalid   cache      configuration   on    '  \"     +     ( ae . toString (  )  )  )     +     \"  '  .    Both    ' cacheManager '    and    ' cacheResolver '    attributes   have   been   set .     \"  )     +     \" These   attributes   are   mutually   exclusive :    the   cache   manager   is   used   to   configure   a \"  )     +     \" default   cache   resolver   if   none   is   set .    If   a   cache   resolver   is   set ,    the   cache   manager \"  )     +     \" won ' t   be   used .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateCacheOperation"], "fileName": "org.springframework.cache.annotation.SpringCacheAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "ByteArrayInputStream   in    =    new   ByteArrayInputStream (  (  ( byte [  ]  )     ( storeValue )  )  )  ;", "try    {", "return   serialization . deserialize ( in )  ;", "}    finally    {", "in . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["deserializeValue"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCache"}, {"methodBody": ["METHOD_START", "{", "return    ( this . serialization )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isStoreByValue"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCache"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "try    {", "serialization . serialize ( storeValue ,    out )  ;", "return   out . toByteArray (  )  ;", "}    finally    {", "out . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["serializeValue"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCache"}, {"methodBody": ["METHOD_START", "{", "this . allowNullValues    =    allowNullValues ;", "}", "METHOD_END"], "methodName": ["setAllowNullValues"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . store    =    store ;", "}", "METHOD_END"], "methodName": ["setStore"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "SerializationDelegate   actualSerialization    =     ( isStoreByValue (  )  )     ?    this . serialization    :    null ;", "return   new    ( name ,    new   ConcurrentHashMap (  2  5  6  )  ,    isAllowNullValues (  )  ,    actualSerialization )  ;", "}", "METHOD_END"], "methodName": ["createConcurrentMapCache"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   this . allowNullValues ;", "}", "METHOD_END"], "methodName": ["isAllowNullValues"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   this . storeByValue ;", "}", "METHOD_END"], "methodName": ["isStoreByValue"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManager"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    Cache >    entry    :    this . cacheMap . entrySet (  )  )     {", "entry . setValue ( create ( entry . getKey (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["recreateCaches"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    ( allowNullValues    !  =     ( this . allowNullValues )  )     {", "this . allowNullValues    =    allowNullValues ;", "recreates (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAllowNullValues"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    ( cacheNames    !  =    null )     {", "for    ( String   name    :    cacheNames )     {", "this . cacheMap . put ( name ,    create ( name )  )  ;", "}", "this . dynamic    =    false ;", "} else    {", "this . dynamic    =    true ;", "}", "}", "METHOD_END"], "methodName": ["setCacheNames"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    ( storeByValue    !  =     ( this . storeByValue )  )     {", "this . storeByValue    =    storeByValue ;", "recreates (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setStoreByValue"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManager"}, {"methodBody": ["METHOD_START", "{", "ConcurrentMapCacheManager   cm    =    new   ConcurrentMapCacheManager (  \" c 1  \"  ,     \" c 2  \"  )  ;", "assertFalse ( cm . isStoreByValue (  )  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1    instanceof   ConcurrentMapCache )  )  ;", "assertFalse (  (  ( ConcurrentMapCache )     ( cache 1  )  )  . isStoreByValue (  )  )  ;", "cache 1  . put (  \" key \"  ,     \" value \"  )  ;", "cm . setStoreByValue ( true )  ;", "assertTrue ( cm . isStoreByValue (  )  )  ;", "Cache   cache 1 x    =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1 x   instanceof   ConcurrentMapCache )  )  ;", "assertTrue (  ( cache 1 x    !  =    cache 1  )  )  ;", "assertNull ( cache 1 x . get (  \" key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testChangeStoreByValue"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "CacheManager   cm    =    new   ConcurrentMapCacheManager (  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1    instanceof   ConcurrentMapCache )  )  ;", "Cache   cache 1 again    =    cm . getCache (  \" c 1  \"  )  ;", "assertSame ( cache 1 again ,    cache 1  )  ;", "Cache   cache 2     =    cm . getCache (  \" c 2  \"  )  ;", "assertTrue (  ( cache 2    instanceof   ConcurrentMapCache )  )  ;", "Cache   cache 2 again    =    cm . getCache (  \" c 2  \"  )  ;", "assertSame ( cache 2 again ,    cache 2  )  ;", "Cache   cache 3     =    cm . getCache (  \" c 3  \"  )  ;", "assertTrue (  ( cache 3    instanceof   ConcurrentMapCache )  )  ;", "Cache   cache 3 again    =    cm . getCache (  \" c 3  \"  )  ;", "assertSame ( cache 3 again ,    cache 3  )  ;", "cache 1  . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "assertEquals (  \" value 1  \"  ,    cache 1  . get (  \" key 1  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 2  \"  ,     2  )  ;", "assertEquals (  2  ,    cache 1  . get (  \" key 2  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 3  \"  ,    null )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 3  \"  ,    null )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  . get (  )  )  ;", "cache 1  . evict (  \" key 3  \"  )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    cache 1  . putIfAbsent (  \" key 1  \"  ,     \" value 1 x \"  )  . get (  )  )  ;", "assertEquals (  \" value 1  \"  ,    cache 1  . get (  \" key 1  \"  )  . get (  )  )  ;", "assertEquals (  2  ,    cache 1  . putIfAbsent (  \" key 2  \"  ,     2  .  1  )  . get (  )  )  ;", "assertNull ( cache 1  . putIfAbsent (  \" key 3  \"  ,    null )  )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  . get (  )  )  ;", "assertNull ( cache 1  . putIfAbsent (  \" key 3  \"  ,    null )  . get (  )  )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  . get (  )  )  ;", "cache 1  . evict (  \" key 3  \"  )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDynamicMode"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentMapCacheManager   cm    =    new   ConcurrentMapCacheManager (  \" c 1  \"  ,     \" c 2  \"  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1    instanceof   ConcurrentMapCache )  )  ;", "Cache   cache 1 again    =    cm . getCache (  \" c 1  \"  )  ;", "assertSame ( cache 1 again ,    cache 1  )  ;", "Cache   cache 2     =    cm . getCache (  \" c 2  \"  )  ;", "assertTrue (  ( cache 2    instanceof   ConcurrentMapCache )  )  ;", "Cache   cache 2 again    =    cm . getCache (  \" c 2  \"  )  ;", "assertSame ( cache 2 again ,    cache 2  )  ;", "Cache   cache 3     =    cm . getCache (  \" c 3  \"  )  ;", "assertNull ( cache 3  )  ;", "cache 1  . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "assertEquals (  \" value 1  \"  ,    cache 1  . get (  \" key 1  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 2  \"  ,     2  )  ;", "assertEquals (  2  ,    cache 1  . get (  \" key 2  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 3  \"  ,    null )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  . get (  )  )  ;", "cache 1  . evict (  \" key 3  \"  )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  )  ;", "cm . setAllowNullValues ( false )  ;", "Cache   cache 1 x    =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1 x   instanceof   ConcurrentMapCache )  )  ;", "assertTrue (  ( cache 1 x    !  =    cache 1  )  )  ;", "Cache   cache 2 x    =    cm . getCache (  \" c 2  \"  )  ;", "assertTrue (  ( cache 2 x   instanceof   ConcurrentMapCache )  )  ;", "assertTrue (  ( cache 2 x    !  =    cache 2  )  )  ;", "Cache   cache 3 x    =    cm . getCache (  \" c 3  \"  )  ;", "assertNull ( cache 3 x )  ;", "cache 1 x . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "assertEquals (  \" value 1  \"  ,    cache 1 x . get (  \" key 1  \"  )  . get (  )  )  ;", "cache 1 x . put (  \" key 2  \"  ,     2  )  ;", "assertEquals (  2  ,    cache 1 x . get (  \" key 2  \"  )  . get (  )  )  ;", "cm . setAllowNullValues ( true )  ;", "Cache   cache 1 y    =    cm . getCache (  \" c 1  \"  )  ;", "cache 1 y . put (  \" key 3  \"  ,    null )  ;", "assertNull ( cache 1 y . get (  \" key 3  \"  )  . get (  )  )  ;", "cache 1 y . evict (  \" key 3  \"  )  ;", "assertNull ( cache 1 y . get (  \" key 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticMode"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ConcurrentMapCache ( AbstractCacheTests . CACHE _ NAME ,    this . nativeCache ,    true ,    new   SerializationDelegate ( ConcurrentMapCacheTests . class . getClassLoader (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createCacheWithStoreByValue"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheTests"}, {"methodBody": ["METHOD_START", "{", "this . nativeCache    =    new   ConcurrentHashMap <  >  (  )  ;", "this . cache    =    new    ( AbstractCacheTests . CACHE _ NAME ,    this . nativeCache ,    true )  ;", "this . nativeCacheNoNull    =    new   ConcurrentHashMap <  >  (  )  ;", "this . cacheNoNull    =    new    ( AbstractValueAdaptingCacheTests . CACHE _ NAME _ NO _ NULL ,    this . nativeCacheNoNull ,    false )  ;", "this . cache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentMapCache   serializeCache    =    createCacheWithStoreByValue (  )  ;", "String   key    =    createRandomKey (  )  ;", "this . nativeCache . put ( key ,     \" Some   garbage \"  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Failed   to   deserialize \"  )  ;", "this . thrown . expectMessage (  \" Some   garbage \"  )  ;", "serializeCache . get ( key )  ;", "}", "METHOD_END"], "methodName": ["testInvalidSerializedContent"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . cache . isStoreByValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsStoreByReferenceByDefault"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentMapCache   serializeCache    =    createCacheWithStoreByValue (  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Failed   to   serialize \"  )  ;", "this . thrown . expectMessage ( this . cache . getClass (  )  . getName (  )  )  ;", "serializeCache . put ( createRandomKey (  )  ,    this . cache )  ;", "}", "METHOD_END"], "methodName": ["testNonSerializableContent"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentMapCache   serializeCache    =    createCacheWithStoreByValue (  )  ;", "assertTrue ( serializeCache . isStoreByValue (  )  )  ;", "Object   key    =    createRandomKey (  )  ;", "List < String >    content    =    new   ArrayList <  >  (  )  ;", "content . addAll ( Arrays . asList (  \" one \"  ,     \" two \"  ,     \" three \"  )  )  ;", "serializeCache . put ( key ,    content )  ;", "content . remove (  0  )  ;", "List < String >    entry    =     (  ( List < String >  )     ( serializeCache . get ( key )  . get (  )  )  )  ;", "assertEquals (  3  ,    entry . size (  )  )  ;", "assertEquals (  \" one \"  ,    entry . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializer"], "fileName": "org.springframework.cache.concurrent.ConcurrentMapCacheTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . ctx )     !  =    null )     {", "this . ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "this . ctx    =    getApplicationContext (  )  ;", "this . cs    =    ctx . getBean (  \" service \"  ,    CacheableService . class )  ;", "this . ccs    =    ctx . getBean (  \" classService \"  ,    CacheableService . class )  ;", "this . cm    =    ctx . getBean (  \" cacheManager \"  ,    CacheManager . class )  ;", "Collection < String >    cn    =    this . cm . geNames (  )  ;", "assertTrue ( cn . contains (  \" tes \"  )  )  ;", "assertTrue ( cn . contains (  \" secondary \"  )  )  ;", "assertTrue ( cn . contains (  \" primary \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    new   Object (  )  ;", "Cache   cache    =    this . cm . ge (  \" tes \"  )  ;", "assertNull ( cache . get ( o )  )  ;", "Object   r 1     =    service . update ( o )  ;", "assertSame ( r 1  ,    cache . get ( o )  . get (  )  )  ;", "o    =    new   Object (  )  ;", "assertNull ( cache . get ( o )  )  ;", "Object   r 2     =    service . update ( o )  ;", "assertSame ( r 2  ,    cache . get ( o )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheUpdate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCacheable ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testCacheable"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   r 1     =    service ( o 1  )  ;", "Object   r 2     =    service ( o 1  )  ;", "Object   r 3     =    service ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "assertSame ( r 1  ,    r 3  )  ;", "}", "METHOD_END"], "methodName": ["testCacheable"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCacheableNull ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testCacheableNull"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "assertNull ( this . cm . ge (  \" tes \"  )  . get ( o 1  )  )  ;", "Object   r 1     =    service . cacheNull ( o 1  )  ;", "Object   r 2     =    service . cacheNull ( o 1  )  ;", "Object   r 3     =    service . cacheNull ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "assertSame ( r 1  ,    r 3  )  ;", "assertEquals ( r 3  ,    this . cm . ge (  \" tes \"  )  . get ( o 1  )  . get (  )  )  ;", "assertNull (  \" Cached   value   should   be   null \"  ,    r 3  )  ;", "}", "METHOD_END"], "methodName": ["testCacheableNull"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCacheableSync ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testCacheableSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   r 1     =    serviceSync ( o 1  )  ;", "Object   r 2     =    serviceSync ( o 1  )  ;", "Object   r 3     =    serviceSync ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "assertSame ( r 1  ,    r 3  )  ;", "}", "METHOD_END"], "methodName": ["testCacheableSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCacheableSyncNull ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testCacheableSyncNull"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "assertNull ( this . cm . ge (  \" tes \"  )  . get ( o 1  )  )  ;", "Object   r 1     =    service . cacheSyncNull ( o 1  )  ;", "Object   r 2     =    service . cacheSyncNull ( o 1  )  ;", "Object   r 3     =    service . cacheSyncNull ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "assertSame ( r 1  ,    r 3  )  ;", "assertEquals ( r 3  ,    this . cm . ge (  \" tes \"  )  . get ( o 1  )  . get (  )  )  ;", "assertNull (  \" Cached   value   should   be   null \"  ,    r 3  )  ;", "}", "METHOD_END"], "methodName": ["testCacheableSyncNull"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCheckedThrowable ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testCheckedException"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCheckedThrowableSync ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testCheckedExceptionSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   arg    =    UUID . randomUUID (  )  . toString (  )  ;", "try    {", "service . throwChecked ( arg )  ;", "fail (  \" Excepted   exception \"  )  ;", "}    catch    ( Exception   ex )     {", "assertEquals (  \" Wrong   exception   type \"  ,    IOException . class ,    ex . getClass (  )  )  ;", "assertEquals ( arg ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCheckedThrowable"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   arg    =    UUID . randomUUID (  )  . toString (  )  ;", "try    {", "service . throwCheckedSync ( arg )  ;", "fail (  \" Excepted   exception \"  )  ;", "}    catch    ( Exception   ex )     {", "ex . printStackTrace (  )  ;", "assertEquals (  \" Wrong   exception   type \"  ,    IOException . class ,    ex . getClass (  )  )  ;", "assertEquals ( arg ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCheckedThrowableSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCacheable ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassCacheCacheable"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvict ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassCacheInvalidate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictWKey ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassCacheInvalidateWKey"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testUnlessExpression ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testClassCacheUnlessExpression"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCheckedThrowable ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassCheckedException"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCheckedThrowableSync ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassCheckedExceptionSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testConditionalCacheUpdate ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassConditionalUpdate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictEarly ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassEarlyInvalidate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictWKeyEarly ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassEarlyInvalidateWithKey"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictAll ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassEvictAll"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictException ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassEvictWithException"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMethodName ( this . ccs ,     \" nametestCache \"  )  ;", "}", "METHOD_END"], "methodName": ["testClassMethodName"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiCache ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassMultiCache"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiCacheAndEvict ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassMultiCacheAndEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiConditionalCacheAndEvict ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassMultiConditionalCacheAndEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiEvict ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassMultiEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiPut ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassMultiPut"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testNullArg ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassNullArg"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   key    =    new   Object (  )  ;", "assertNull ( this . ccs . nullValue ( key )  )  ;", "int   nr    =    this . ccs . nullInvocations (  )  . intValue (  )  ;", "assertNull ( this . ccs . nullValue ( key )  )  ;", "assertEquals ( nr ,    this . ccs . nullInvocations (  )  . intValue (  )  )  ;", "assertNull ( this . ccs . nullValue ( new   Object (  )  )  )  ;", "assertEquals ( nr ,    this . ccs . nullInvocations (  )  . intValue (  )  )  ;", "assertEquals (  ( nr    +     1  )  ,    edClassCacheableService . nullInvocations . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassNullValue"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testPutRefersToResult ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassPutRefersToResult"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testRootVars ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassRootVars"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testUncheckedThrowable ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassUncheckedException"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testUncheckedThrowableSync ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassUncheckedExceptionSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCacheUpdate ( this . ccs )  ;", "}", "METHOD_END"], "methodName": ["testClassUpdate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Integer   one    =     1  ;", "Integer   three    =     3  ;", "Cache   cache    =    this . cm . ge (  \" tes \"  )  ;", "assertEquals ( one ,    Integer . valueOf ( service . conditionalUpdate ( one )  . toString (  )  )  )  ;", "assertNull ( cache . get ( one )  )  ;", "assertEquals ( three ,    Integer . valueOf ( service . conditionalUpdate ( three )  . toString (  )  )  )  ;", "assertEquals ( three ,    Integer . valueOf ( cache . get ( three )  . get (  )  . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testConditionalCacheUpdate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testConditionalExpression ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testConditionalExpression"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   r 1     =    service . conditional (  4  )  ;", "Object   r 2     =    service . conditional (  4  )  ;", "assertNotSame ( r 1  ,    r 2  )  ;", "Object   r 3     =    service . conditional (  3  )  ;", "Object   r 4     =    service . conditional (  3  )  ;", "assertSame ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testConditionalExpression"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testConditionalExpressionSync ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testConditionalExpressionSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   r 1     =    service . conditionalSync (  4  )  ;", "Object   r 2     =    service . conditionalSync (  4  )  ;", "assertNotSame ( r 1  ,    r 2  )  ;", "Object   r 3     =    service . conditionalSync (  3  )  ;", "Object   r 4     =    service . conditionalSync (  3  )  ;", "assertSame ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testConditionalExpressionSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testConditionalCacheUpdate ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testConditionalUpdate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "CacheManager   customCm    =    this . ctx . getBean (  \" customCacheManager \"  ,    CacheManager . class )  ;", "Object   key    =    new   Object (  )  ;", "Object   r 1     =    this . cs . customCacheManager ( key )  ;", "assertSame ( r 1  ,    this . cs . customCacheManager ( key )  )  ;", "Cache   cache    =    customCm . ge (  \" tes \"  )  ;", "assertNotNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomCacheManager"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   param    =    new   Object (  )  ;", "Object   r 1     =    this . cs . customKeyGenerator ( param )  ;", "assertSame ( r 1  ,    this . cs . customKeyGenerator ( param )  )  ;", "Cache   cache    =    this . cm . ge (  \" tes \"  )  ;", "Object   expectedKey    =    SomeCustomKeyGenerator . generateKey (  \" customKeyGenerator \"  ,    param )  ;", "assertNotNull ( cache . get ( expectedKey )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomKeyGenerator"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictEarly ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testEarlyInvalidate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictWKeyEarly ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testEarlyInvalidateWithKey"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   r 1     =    service ( o 1  )  ;", "Object   r 2     =    service ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "service . invalidate ( o 1  )  ;", "Object   r 3     =    service ( o 1  )  ;", "Object   r 4     =    service ( o 1  )  ;", "assertNotSame ( r 1  ,    r 3  )  ;", "assertSame ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictAll ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testEvictAll"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   r 1     =    service ( o 1  )  ;", "Object   r 2     =    service ( o 1  )  ;", "Object   o 2     =    new   Object (  )  ;", "Object   r 1  0     =    service ( o 2  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "assertNotSame ( r 1  ,    r 1  0  )  ;", "service . evictAll ( new   Object (  )  )  ;", "Cache    =    this . cm . getCache (  \" testCache \"  )  ;", "assertNull . get ( o 1  )  )  ;", "assertNull . get ( o 2  )  )  ;", "Object   r 3     =    service ( o 1  )  ;", "Object   r 4     =    service ( o 1  )  ;", "assertNotSame ( r 1  ,    r 3  )  ;", "assertSame ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testEvictAll"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   r 1     =    service ( o 1  )  ;", "Object   r 2     =    service ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "try    {", "service . evictEarly ( o 1  )  ;", "}    catch    ( RuntimeException   ex )     {", "}", "Object   r 3     =    service ( o 1  )  ;", "Object   r 4     =    service ( o 1  )  ;", "assertNotSame ( r 1  ,    r 3  )  ;", "assertSame ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testEvictEarly"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   r 1     =    service ( o 1  )  ;", "Object   r 2     =    service ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "try    {", "service . evictWithException ( o 1  )  ;", "}    catch    ( RuntimeException   ex )     {", "}", "Object   r 3     =    service ( o 1  )  ;", "assertSame ( r 1  ,    r 3  )  ;", "}", "METHOD_END"], "methodName": ["testEvictException"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   r 1     =    service ( o 1  )  ;", "Object   r 2     =    service ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "service . evict ( o 1  ,    null )  ;", "Object   r 3     =    service ( o 1  )  ;", "Object   r 4     =    service ( o 1  )  ;", "assertNotSame ( r 1  ,    r 3  )  ;", "assertSame ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testEvictWKey"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   r 1     =    service ( o 1  )  ;", "Object   r 2     =    service ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "try    {", "service . invalidateEarly ( o 1  ,    null )  ;", "}    catch    ( Exception   ex )     {", "}", "Object   r 3     =    service ( o 1  )  ;", "Object   r 4     =    service ( o 1  )  ;", "assertNotSame ( r 1  ,    r 3  )  ;", "assertSame ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testEvictWKeyEarly"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictException ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testEvictWithException"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvict ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testInvalidate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testEvictWKey ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testInvalidateWithKey"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testKeyExpression ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testKeyExpression"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   r 1     =    service . key (  5  ,     1  )  ;", "Object   r 2     =    service . key (  5  ,     2  )  ;", "assertS ( r 1  ,    r 2  )  ;", "Object   r 3     =    service . key (  1  ,     5  )  ;", "Object   r 4     =    service . key (  2  ,     5  )  ;", "assertNotS ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testKeyExpression"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMethodName ( this . cs ,     \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["testMethodName"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   key    =    new   Object (  )  ;", "Object   r 1     =    service . name ( key )  ;", "assertSame ( r 1  ,    service . name ( key )  )  ;", "Cache   cache    =    this . cm . ge (  \" tes \"  )  ;", "assertNotNull ( cache . get ( keyName )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodName"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiCache ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testMultiCache"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   o 2     =    new   Object (  )  ;", "Cache   primary    =    this . cm . ge (  \" primary \"  )  ;", "Cache   secondary    =    this . cm . ge (  \" secondary \"  )  ;", "assertNull ( primary . get ( o 1  )  )  ;", "assertNull ( secondary . get ( o 1  )  )  ;", "Object   r 1     =    service . multiCache ( o 1  )  ;", "assertSame ( r 1  ,    primary . get ( o 1  )  . get (  )  )  ;", "assertSame ( r 1  ,    secondary . get ( o 1  )  . get (  )  )  ;", "Object   r 2     =    service . multiCache ( o 1  )  ;", "Object   r 3     =    service . multiCache ( o 1  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "assertSame ( r 1  ,    r 3  )  ;", "assertNull ( primary . get ( o 2  )  )  ;", "assertNull ( secondary . get ( o 2  )  )  ;", "Object   r 4     =    service . multiCache ( o 2  )  ;", "assertSame ( r 4  ,    primary . get ( o 2  )  . get (  )  )  ;", "assertSame ( r 4  ,    secondary . get ( o 2  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiCache"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiCacheAndEvict ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testMultiCacheAndEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" multiCacheAndEvict \"  ;", "Cache   primary    =    this . cm . getCache (  \" primary \"  )  ;", "Cache   secondary    =    this . cm . getCache (  \" secondary \"  )  ;", "Object   key    =     1  ;", "secondary . put ( key ,    key )  ;", "assertNull ( secondary . get ( methodName )  )  ;", "assertSame ( key ,    secondary . get ( key )  . get (  )  )  ;", "Object   r 1     =    service . multiCacheAndEvict ( key )  ;", "assertSame ( r 1  ,    service . multiCacheAndEvict ( key )  )  ;", "assertSame ( r 1  ,    primary . get ( methodName )  . get (  )  )  ;", "assertNull ( secondary . get ( methodName )  )  ;", "assertNull ( secondary . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiCacheAndEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiConditionalCacheAndEvict ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testMultiConditionalCacheAndEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   primary    =    this . cm . getCache (  \" primary \"  )  ;", "Cache   secondary    =    this . cm . getCache (  \" secondary \"  )  ;", "Object   key    =     1  ;", "secondary . put ( key ,    key )  ;", "assertNull ( primary . get ( key )  )  ;", "assertSame ( key ,    secondary . get ( key )  . get (  )  )  ;", "Object   r 1     =    service . multiConditionaldEvict ( key )  ;", "Object   r 3     =    service . multiConditionaldEvict ( key )  ;", "assertTrue (  (  !  ( r 1  . equals ( r 3  )  )  )  )  ;", "assertNull ( primary . get ( key )  )  ;", "Object   key 2     =     3  ;", "Object   r 2     =    service . multiConditionaldEvict ( key 2  )  ;", "assertSame ( r 2  ,    service . multiConditionaldEvict ( key 2  )  )  ;", "assertSame ( r 2  ,    primary . get ( key 2  )  . get (  )  )  ;", "assertNull ( secondary . get ( key 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiConditionalCacheAndEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiEvict ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testMultiEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o 1     =    new   Object (  )  ;", "Object   o 2     =     ( o 1  . toString (  )  )     +     \" A \"  ;", "Object   r 1     =    service . multiCache ( o 1  )  ;", "Object   r 2     =    service . multiCache ( o 1  )  ;", "Cache   primary    =    this . cm . ge (  \" primary \"  )  ;", "Cache   secondary    =    this . cm . ge (  \" secondary \"  )  ;", "primary . put ( o 2  ,    o 2  )  ;", "assertSame ( r 1  ,    r 2  )  ;", "assertSame ( r 1  ,    primary . get ( o 1  )  . get (  )  )  ;", "assertSame ( r 1  ,    secondary . get ( o 1  )  . get (  )  )  ;", "service . multiEvict ( o 1  )  ;", "assertNull ( primary . get ( o 1  )  )  ;", "assertNull ( secondary . get ( o 1  )  )  ;", "assertNull ( primary . get ( o 2  )  )  ;", "Object   r 3     =    service . multiCache ( o 1  )  ;", "Object   r 4     =    service . multiCache ( o 1  )  ;", "assertNotSame ( r 1  ,    r 3  )  ;", "assertSame ( r 3  ,    r 4  )  ;", "assertSame ( r 3  ,    primary . get ( o 1  )  . get (  )  )  ;", "assertSame ( r 4  ,    secondary . get ( o 1  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiEvict"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testMultiPut ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testMultiPut"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =     1  ;", "Cache   primary    =    this . cm . ge (  \" primary \"  )  ;", "Cache   secondary    =    this . cm . ge (  \" secondary \"  )  ;", "assertNull ( primary . get ( o )  )  ;", "assertNull ( secondary . get ( o )  )  ;", "Object   r 1     =    service . multiUpdate ( o )  ;", "assertSame ( r 1  ,    primary . get ( o )  . get (  )  )  ;", "assertSame ( r 1  ,    secondary . get ( o )  . get (  )  )  ;", "o    =     2  ;", "assertNull ( primary . get ( o )  )  ;", "assertNull ( secondary . get ( o )  )  ;", "Object   r 2     =    service . multiUpdate ( o )  ;", "assertSame ( r 2  ,    primary . get ( o )  . get (  )  )  ;", "assertSame ( r 2  ,    secondary . get ( o )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiPut"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testNullArg ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testNullArg"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   r 1     =    service . cache ( null )  ;", "assertSame ( r 1  ,    service . cache ( null )  )  ;", "}", "METHOD_END"], "methodName": ["testNullArg"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testNullValue ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testNullValue"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   key    =    new   Object (  )  ;", "assertNull ( service . nullValue ( key )  )  ;", "int   nr    =    service . nullInvocs (  )  . intValue (  )  ;", "assertNull ( service . nullValue ( key )  )  ;", "assertEquals ( nr ,    service . nullInvocs (  )  . intValue (  )  )  ;", "assertNull ( service . nullValue ( new   Object (  )  )  )  ;", "assertEquals (  ( nr    +     1  )  ,    service . nullInvocs (  )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNullValue"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testPutRefersToResult ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testPutRefersToResult"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Long   id    =    Long . MIN _ VALUE ;", "TestEntity   entity    =    new   TestEntity (  )  ;", "Cache   primary    =    this . cm . ge (  \" primary \"  )  ;", "assertNull ( primary . get ( id )  )  ;", "assertNull ( entity . getId (  )  )  ;", "service . putRefersToResult ( entity )  ;", "assertSame ( entity ,    primary . get ( id )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPutRefersToResult"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testRootVars ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testRootVars"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   key    =    new   Object (  )  ;", "Object   r 1     =    service . rootVars ( key )  ;", "assertSame ( r 1  ,    service . rootVars ( key )  )  ;", "Cache   cache    =    this . cm . ge (  \" tes \"  )  ;", "String   expectedKey    =     (  \" rootVarsrootVars \"     +     ( AopProxyUtils . ultimateTargetClass ( service )  )  )     +    service ;", "assertNotNull ( cache . get ( expectedKey )  )  ;", "}", "METHOD_END"], "methodName": ["testRootVars"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testUncheckedThrowable ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testUncheckedException"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testUncheckedThrowableSync ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testUncheckedExceptionSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "service . throwUnchecked (  1 L )  ;", "fail (  \" Excepted   exception \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertEquals (  \" Wrong   exception   type \"  ,    UnsupportedOperException . class ,    ex . getClass (  )  )  ;", "assertEquals (  \"  1  \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUncheckedThrowable"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "service . throwUncheckedSync (  1 L )  ;", "fail (  \" Excepted   exception \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertEquals (  \" Wrong   exception   type \"  ,    UnsupportedOperException . class ,    ex . getClass (  )  )  ;", "assertEquals (  \"  1  \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUncheckedThrowableSync"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   param    =    new   Object (  )  ;", "this . cs . unknownCustomManager ( param )  ;", "fail (  \" should   have   failed   with   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testUnknownCustomCacheManager"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   param    =    new   Object (  )  ;", "this . cs . unknownCustomKeyGenerator ( param )  ;", "fail (  \" should   have   failed   with   NoSuchBeanDefiniExcep \"  )  ;", "}    catch    ( NoSuchBeanDefiniExcep   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testUnknownCustomKeyGenerator"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testUnlessExpression ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testUnlessExpression"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    this . cm . getCache (  \" testCache \"  )  ;", "lear (  )  ;", "service . unless (  1  0  )  ;", "service . unless (  1  1  )  ;", "assertThat ( cache . get (  1  0  )  . get (  )  ,    equalTo (  1  0 L )  )  ;", "assertThat ( cache . get (  1  1  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnlessExpression"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testCacheUpdate ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testUpdate"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "testVarArgsKey ( this . cs )  ;", "}", "METHOD_END"], "methodName": ["testVarArgsKey"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Object   r 1     =    service . varArgsKey (  1  ,     2  ,     3  )  ;", "Object   r 2     =    service . varArgsKey (  1  ,     2  ,     3  )  ;", "assertS ( r 1  ,    r 2  )  ;", "Object   r 3     =    service . varArgsKey (  1  ,     2  ,     3  )  ;", "Object   r 4     =    service . varArgsKey (  1  ,     2  )  ;", "assertNotS ( r 3  ,    r 4  )  ;", "}", "METHOD_END"], "methodName": ["testVarArgsKey"], "fileName": "org.springframework.cache.config.AbstractCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =    element . getAttribute (  \" cache - resolver \"  )  ;", "if    ( StringUtils . hasText ( name )  )     {", "def . getPropertyValues (  )  . add (  \" cacheResolver \"  ,    new   RuntimeBeanReference ( name . trim (  )  )  )  ;", "}", "if    (  (  !  ( StringUtils . hasText ( name )  )  )     |  |    setBoth )     {", "def . getPropertyValues (  )  . add (  \" cacheManager \"  ,    new   RuntimeBeanReference ( CacheNamespaceHandler . extractCacheManager ( element )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseCacheResolution"], "fileName": "org.springframework.cache.config.AnnotationDrivenCacheBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    element . getAttribute (  \" error - handler \"  )  ;", "if    ( StringUtils . hasText ( name )  )     {", "def . getPropertyValues (  )  . add (  \" errorHandler \"  ,    new   RuntimReference ( name . trim (  )  )  )  ;", "}", "return   def ;", "}", "METHOD_END"], "methodName": ["parseErrorHandler"], "fileName": "org.springframework.cache.config.AnnotationDrivenCacheBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "AopNamespaceUtils . registerAutoProxyCreatorIfNecessary ( parserContext ,    element )  ;", ". SpringCachingConfigurer . registerCacheAdvisor ( element ,    parserContext )  ;", "if    (  (  . jsr 1  0  7 Present )     &  &     (  . jcacheImplPresent )  )     {", ". JCacheCachingConfigurer . registerCacheAdvisor ( element ,    parserContext )  ;", "}", "}", "METHOD_END"], "methodName": ["registerCacheAdvisor"], "fileName": "org.springframework.cache.config.AnnotationDrivenCacheBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "AnnotationDrivenCacheBeanDefinitionParser . SpringCachingConfigurer . registerCacheAspect ( element ,    parserContext )  ;", "if    (  ( AnnotationDrivenCacheBeanDefinitionParser . jsr 1  0  7 Present )     &  &     ( AnnotationDrivenCacheBeanDefinitionParser . jcacheImplPresent )  )     {", "AnnotationDrivenCacheBeanDefinitionParser . JCacheCachingConfigurer . registerCacheAspect ( element ,    parserContext )  ;", "}", "}", "METHOD_END"], "methodName": ["registerCacheAspect"], "fileName": "org.springframework.cache.config.AnnotationDrivenCacheBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   GenericXmlApplicationContext (  \"  / org / springframework / cache / config / annotationDrivenCacheNamespace - manager - resolver . xml \"  )  ;", "CacheInterceptor   ci    =    context . getBean ( CacheInterceptor . class )  ;", "assertSame ( context . getBean (  \" cacheResolver \"  )  ,    ci . getCacheResolver (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["bothSetOnlyResolverIsUsed"], "fileName": "org.springframework.cache.config.AnnotationNamespaceDrivenTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   GenericXmlApplicationContext (  \"  / org / springframework / cache / config / annotationDrivenCacheNamespace - resolver . xml \"  )  ;", "CacheInterceptor   ci    =    context . getBean ( CacheInterceptor . class )  ;", "assertSame ( context . getBean (  \" cacheResolver \"  )  ,    ci . getCacheResolver (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["cacheResolver"], "fileName": "org.springframework.cache.config.AnnotationNamespaceDrivenTests"}, {"methodBody": ["METHOD_START", "{", "CacheInterceptor   ci    =    this . ctx . getBean (  \" CacheInterceptor #  0  \"  ,    CacheInterceptor . class )  ;", "assertSame ( this . ctx . getBean (  \" errorHandler \"  ,    CacheErrorHandler . class )  ,    ci . getErrorHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheErrorHandler"], "fileName": "org.springframework.cache.config.AnnotationNamespaceDrivenTests"}, {"methodBody": ["METHOD_START", "{", "CacheInterceptor   ci    =    this . ctx . getBean (  \" CacheInterceptor #  0  \"  ,    CacheInterceptor . class )  ;", "assertSame ( this . ctx . getBean (  \" keyGenerator \"  )  ,    ci . getKeyGenerator (  )  )  ;", "}", "METHOD_END"], "methodName": ["testKeyStrategy"], "fileName": "org.springframework.cache.config.AnnotationNamespaceDrivenTests"}, {"methodBody": ["METHOD_START", "{", "CacheInterceptor   bean    =    this . ctx . getBean (  \" cacheAdviceClass \"  ,    CacheInterceptor . class )  ;", "Assert . assertSame ( this . ctx . getBean (  \" keyGenerator \"  )  ,    bean . getKeyGenerator (  )  )  ;", "}", "METHOD_END"], "methodName": ["testKeyStrategy"], "fileName": "org.springframework.cache.config.CacheAdviceNamespaceTests"}, {"methodBody": ["METHOD_START", "{", "String   attribute    =    element . getAttribute ( attributeName )  ;", "if    ( StringUtils . hasText ( attribute )  )     {", "return   attribute . trim (  )  ;", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["getAttributeValue"], "fileName": "org.springframework.cache.config.CacheAdviceParser"}, {"methodBody": ["METHOD_START", "{", "CacheAdviceParser . Props   prop    =    new   CacheAdviceParser . Props ( definition )  ;", "ManagedMap < TypedStringValue ,    Collection < CacheOperation >  >    cacheOpMap    =    new   ManagedMap (  )  ;", "cacheOpMap . setSource ( parserContext . extractSource ( definition )  )  ;", "List < Element >    cacheableCacheMethods    =    DomUtils . getChildElementsByTagName ( definition ,    CacheAdviceParser . CACHEABLE _ ELEMENT )  ;", "for    ( Element   opElement    :    cacheableCacheMethods )     {", "String   name    =    prop . merge ( opElement ,    parserContext . getReaderContext (  )  )  ;", "TypedStringValue   nameHolder    =    new   TypedStringValue ( name )  ;", "nameHolder . setSource ( parserContext . extractSource ( opElement )  )  ;", "CacheableOperation . Builder   builder    =    prop . merge ( opElement ,    parserContext . getReaderContext (  )  ,    new   CacheableOperation . Builder (  )  )  ;", "builder . setUnless ( CacheAdviceParser . getAttributeValue ( opElement ,     \" unless \"  ,     \"  \"  )  )  ;", "builder . setSync ( Boolean . valueOf ( CacheAdviceParser . getAttributeValue ( opElement ,     \" sync \"  ,     \" false \"  )  )  )  ;", "Collection < CacheOperation >    col    =    cacheOpMap . get ( nameHolder )  ;", "if    ( col    =  =    null )     {", "col    =    new   ArrayList <  >  (  2  )  ;", "cacheOpMap . put ( nameHolder ,    col )  ;", "}", "col . add ( builder . build (  )  )  ;", "}", "List < Element >    evictCacheMethods    =    DomUtils . getChildElementsByTagName ( definition ,    CacheAdviceParser . CACHE _ EVICT _ ELEMENT )  ;", "for    ( Element   opElement    :    evictCacheMethods )     {", "String   name    =    prop . merge ( opElement ,    parserContext . getReaderContext (  )  )  ;", "TypedStringValue   nameHolder    =    new   TypedStringValue ( name )  ;", "nameHolder . setSource ( parserContext . extractSource ( opElement )  )  ;", "CacheEvictOperation . Builder   builder    =    prop . merge ( opElement ,    parserContext . getReaderContext (  )  ,    new   CacheEvictOperation . Builder (  )  )  ;", "String   wide    =    opElement . getAttribute (  \" all - entries \"  )  ;", "if    ( StringUtils . hasText ( wide )  )     {", "builder . setCacheWide ( Boolean . valueOf ( wide . trim (  )  )  )  ;", "}", "String   after    =    opElement . getAttribute (  \" before - invocation \"  )  ;", "if    ( StringUtils . hasText ( after )  )     {", "builder . setBeforeInvocation ( Boolean . valueOf ( after . trim (  )  )  )  ;", "}", "Collection < CacheOperation >    col    =    cacheOpMap . get ( nameHolder )  ;", "if    ( col    =  =    null )     {", "col    =    new   ArrayList <  >  (  2  )  ;", "cacheOpMap . put ( nameHolder ,    col )  ;", "}", "col . add ( builder . build (  )  )  ;", "}", "List < Element >    putCacheMethods    =    DomUtils . getChildElementsByTagName ( definition ,    CacheAdviceParser . CACHE _ PUT _ ELEMENT )  ;", "for    ( Element   opElement    :    putCacheMethods )     {", "String   name    =    prop . merge ( opElement ,    parserContext . getReaderContext (  )  )  ;", "TypedStringValue   nameHolder    =    new   TypedStringValue ( name )  ;", "nameHolder . setSource ( parserContext . extractSource ( opElement )  )  ;", "CachePutOperation . Builder   builder    =    prop . merge ( opElement ,    parserContext . getReaderContext (  )  ,    new   CachePutOperation . Builder (  )  )  ;", "builder . setUnless ( CacheAdviceParser . getAttributeValue ( opElement ,     \" unless \"  ,     \"  \"  )  )  ;", "Collection < CacheOperation >    col    =    cacheOpMap . get ( nameHolder )  ;", "if    ( col    =  =    null )     {", "col    =    new   ArrayList <  >  (  2  )  ;", "cacheOpMap . put ( nameHolder ,    col )  ;", "}", "col . add ( builder . build (  )  )  ;", "}", "RootBeanDefinition   attributeSourceDefinition    =    new   RootBeanDefinition ( NameMatchCacheOperationSource . class )  ;", "attributeSourceDefinition . setSource ( parserContext . extractSource ( definition )  )  ;", "attributeSourceDefinition . getPropertyValues (  )  . add (  \" nameMap \"  ,    cacheOpMap )  ;", "return   attributeSourceDefinition ;", "}", "METHOD_END"], "methodName": ["parseDefinitionSource"], "fileName": "org.springframework.cache.config.CacheAdviceParser"}, {"methodBody": ["METHOD_START", "{", "ManagedList < RootBeanDefinition >    defs    =    new   ManagedList ( definitions . size (  )  )  ;", "for    ( Element   element    :    definitions )     {", "defs . add ( parseDefinitionSource ( element ,    pContext )  )  ;", "}", "return   defs ;", "}", "METHOD_END"], "methodName": ["parseDefinitionsSources"], "fileName": "org.springframework.cache.config.CacheAdviceParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   GenericXmlApplicationContext (  \"  / org /  / cache / config / cache - advice - invalid . xml \"  )  ;", "fail (  \" Should   have   failed   to   load   context ,    one   advise   define   both   a   key   and   a   key   generator \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["keyAndKeyGeneratorCannotBeSetTogether"], "fileName": "org.springframework.cache.config.CacheAdviceParserTests"}, {"methodBody": ["METHOD_START", "{", "return   element . hasAttribute ( CacheNamespaceHandler . CACHE _ MANAGER _ ATTRIBUTE )     ?    element . getAttribute ( CacheNamespaceHandler . CACHE _ MANAGER _ ATTRIBUTE )     :    CacheNamespaceHandler . DEFAULT _ CACHE _ MANAGER _ BEAN _ NAME ;", "}", "METHOD_END"], "methodName": ["extractCacheManager"], "fileName": "org.springframework.cache.config.CacheNamespaceHandler"}, {"methodBody": ["METHOD_START", "{", "String   name    =    element . getAttribute (  \" key - generator \"  )  ;", "if    ( StringUtils . hasText ( name )  )     {", "def . getPropertyValues (  )  . add (  \" keyGenerator \"  ,    new   RuntimeBeanReference ( name . trim (  )  )  )  ;", "}", "return   def ;", "}", "METHOD_END"], "methodName": ["parseKeyGenerator"], "fileName": "org.springframework.cache.config.CacheNamespaceHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . cs . throwChecked (  0 L )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( RuntimeExion   e )     {", "assertNotNull (  \" missing   original   exion \"  ,    e . getCause (  )  )  ;", "assertEquals ( IOExion . class ,    e . getCause (  )  . getClass (  )  )  ;", "}    catch    ( Exion   e )     {", "fail (  (  \" Wrong   exion   type    \"     +    e )  )  ;", "}", "}", "METHOD_END"], "methodName": ["customInterceptorAppliesWithCheckedException"], "fileName": "org.springframework.cache.config.CustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    this . cs . throwUnchecked (  0 L )  ;", "assertEquals (  5  5 L ,    o )  ;", "}", "METHOD_END"], "methodName": ["customInterceptorAppliesWithRuntimeException"], "fileName": "org.springframework.cache.config.CustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    CacheInterceptor >    interceptors    =    this . ctx . getBeansOfType ( CacheInterceptor . class )  ;", "assertEquals (  \" Only   one   interceptor   should   be   defined \"  ,     1  ,    interceptors . size (  )  )  ;", "CacheInterceptor   interceptor    =    interceptors . values (  )  . iterator (  )  . next (  )  ;", "assertEquals (  \" Custom   interceptor   not   defined \"  ,     . TestCacheInterceptor . class ,    interceptor . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["onlyOneInterceptorIsAvailable"], "fileName": "org.springframework.cache.config.CustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . ctx    =    new   AnnotationConfigApplicationContext ( CustomInterceptorTests . EnableCachingConfig . class )  ;", "this . cs    =    ctx . getBean (  \" service \"  ,    CacheableService . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.config.CustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.cache.config.CustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( EnableCachingIntegrationTests . BeanConditionConfig . class )  ;", "Cache   cache    =    getCache (  )  ;", "EnableCachingIntegrationTests . FooService   service    =    this . context . getBean ( EnableCachingIntegrationTests . FooService . class )  ;", "Object   key    =    new   Object (  )  ;", "service . getWithCondition ( key )  ;", "CacheTestUtils . assertCacheMiss ( key ,    cache )  ;", "}", "METHOD_END"], "methodName": ["beanCondition"], "fileName": "org.springframework.cache.config.EnableCachingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . context )     !  =    null )     {", "this . context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeContext"], "fileName": "org.springframework.cache.config.EnableCachingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    getCache (  )  ;", "Object   key    =    new   Object (  )  ;", "CacheTestUtils . assertCacheMiss ( key ,    cache )  ;", "Object   value    =    service . getSimple ( key )  ;", "CacheTestUtils . assertCacheHit ( key ,    value ,    cache )  ;", "}", "METHOD_END"], "methodName": ["fooGetSimple"], "fileName": "org.springframework.cache.config.EnableCachingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( EnableCachingIntegrationTests . FooConfig . class )  ;", "EnableCachingIntegrationTests . FooService   service    =    this . context . getBean ( EnableCachingIntegrationTests . FooService . class )  ;", "fooGetSimple ( service )  ;", "}", "METHOD_END"], "methodName": ["fooServiceWithInterface"], "fileName": "org.springframework.cache.config.EnableCachingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( EnableCachingIntegrationTests . FooConfigCglib . class )  ;", "EnableCachingIntegrationTests . FooService   service    =    this . context . getBean ( EnableCachingIntegrationTests . FooService . class )  ;", "fooGetSimple ( service )  ;", "}", "METHOD_END"], "methodName": ["fooServiceWithInterfaceCglib"], "fileName": "org.springframework.cache.config.EnableCachingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . context . getBean ( CacheManager . class )  . getCache (  \" testCache \"  )  ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.springframework.cache.config.EnableCachingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( EnableCachingTests . FullCachingConfig . class )  ;", "CacheInterceptor   ci    =    context . getBean ( CacheInterceptor . class )  ;", "assertSame ( context . getBean (  \" cacheResolver \"  )  ,    ci . getCacheResolver (  )  )  ;", "assertSame ( context . getBean (  \" keyGenerator \"  )  ,    ci . getKeyGenerator (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["bothSetOnlyResolverIsUsed"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( EnableCachingTests . EmptyConfigSupportConfig . class )  ;", "CacheInterceptor   ci    =    context . getBean ( CacheInterceptor . class )  ;", "assertNotNull ( ci . getCacheResolver (  )  )  ;", "assertEquals ( SimpleCacheResolver . class ,    ci . getCacheResolver (  )  . getClass (  )  )  ;", "assertSame ( context . getBean ( CacheManager . class )  ,     (  ( SimpleCacheResolver )     ( ci . getCacheResolver (  )  )  )  . getCacheManager (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["emptyConfigSupport"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . MultiCacheManagerConfig . class )  ;", "try    {", "ctx . refresh (  )  ;", "}    catch    ( BeanCreationException   ex )     {", "Throwable   root    =    ex . getRootCause (  )  ;", "assertTrue ( root . getMessage (  )  . contains (  \" beans   of   type   CacheManager \"  )  )  ;", "throw   root ;", "}", "}", "METHOD_END"], "methodName": ["multipleCacheManagerBeans"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . MultiCacheManagerConfigurer . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["multipleCacheManagerBeans_implementsCachingConfigurer"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . MultiCacheManagerConfigurer . class ,     . EnableCachingConfig . class )  ;", "try    {", "ctx . refresh (  )  ;", "}    catch    ( BeanCreationException   ex )     {", "Throwable   root    =    ex . getRootCause (  )  ;", "assertTrue ( root . getMessage (  )  . contains (  \" implementations   of   CachingConfigurer \"  )  )  ;", "throw   root ;", "}", "}", "METHOD_END"], "methodName": ["multipleCachingConfigurers"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . EmptyConfig . class )  ;", "try    {", "ctx . refresh (  )  ;", "}    catch    ( BeanCreationException   ex )     {", "Throwable   root    =    ex . getRootCause (  )  ;", "assertTrue ( root . getMessage (  )  . contains (  \" No   bean   of   type   CacheManager \"  )  )  ;", "throw   root ;", "}", "}", "METHOD_END"], "methodName": ["noCacheManagerBeans"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . SingleCacheManagerConfig . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["singleCacheManagerBean"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "CacheInterceptor   ci    =    this . ctx . getBean ( CacheInterceptor . class )  ;", "assertSame ( this . ctx . getBean (  \" errorHandler \"  ,    CacheErrorHandler . class )  ,    ci . getErrorHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheErrorHandler"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "CacheInterceptor   ci    =    this . ctx . getBean ( CacheInterceptor . class )  ;", "assertSame ( this . ctx . getBean (  \" keyGenerator \"  ,    KeyGenerator . class )  ,    ci . getKeyGenerator (  )  )  ;", "}", "METHOD_END"], "methodName": ["testKeyStrategy"], "fileName": "org.springframework.cache.config.EnableCachingTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ExpressionCachingIntegrationTests . SharedConfig . class ,    ExpressionCachingIntegrationTests . Spr 1  1  6  9  2 Config . class )  ;", "ExpressionCachingIntegrationTests . BaseDao < ExpressionCachingIntegrationTests . User >    userDao    =     (  ( ExpressionCachingIntegrationTests . BaseDao < ExpressionCachingIntegrationTests . User >  )     ( context . getBean (  \" userDao \"  )  )  )  ;", "ExpressionCachingIntegrationTests . BaseDao < ExpressionCachingIntegrationTests . Order >    orderDao    =     (  ( ExpressionCachingIntegrationTests . BaseDao < ExpressionCachingIntegrationTests . Order >  )     ( context . getBean (  \" orderDao \"  )  )  )  ;", "userDao . persist ( new   ExpressionCachingIntegrationTests . User (  \"  1  \"  )  )  ;", "orderDao . persist ( new   ExpressionCachingIntegrationTests . Order (  \"  2  \"  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["expressionIsCacheBasedOnActualMethod"], "fileName": "org.springframework.cache.config.ExpressionCachingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   sb    =    new   StringBuilder ( methodName )  ;", "for    ( Object   param    :    params )     {", "sb . append ( param )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateKey"], "fileName": "org.springframework.cache.config.SomeCustomKeyGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.cache.config.TestEntity"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.cache.config.TestEntity"}, {"methodBody": ["METHOD_START", "{", "try    {", "clear (  )  ;", "}    catch    ( RuntimeException   ex )     {", "getErrorHandler (  )  . handleCacheClearError ( ex ,     ;", "}", "}", "METHOD_END"], "methodName": ["doClear"], "fileName": "org.springframework.cache.interceptor.AbstractCacheInvoker"}, {"methodBody": ["METHOD_START", "{", "try    {", "evict ( key )  ;", "}    catch    ( RuntimeException   ex )     {", "getErrorHandler (  )  . handleCacheEvictError ( ex ,       key )  ;", "}", "}", "METHOD_END"], "methodName": ["doEvict"], "fileName": "org.springframework.cache.interceptor.AbstractCacheInvoker"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   get ( key )  ;", "}    catch    ( RuntimeException   ex )     {", "getErrorHandler (  )  . handleCacheGetError ( ex ,       key )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["doGet"], "fileName": "org.springframework.cache.interceptor.AbstractCacheInvoker"}, {"methodBody": ["METHOD_START", "{", "try    {", "put ( key ,    result )  ;", "}    catch    ( RuntimeException   ex )     {", "getErrorHandler (  )  . handleCachePutError ( ex ,       key ,    result )  ;", "}", "}", "METHOD_END"], "methodName": ["doPut"], "fileName": "org.springframework.cache.interceptor.AbstractCacheInvoker"}, {"methodBody": ["METHOD_START", "{", "return   this . errorHandler ;", "}", "METHOD_END"], "methodName": ["getErrorHandler"], "fileName": "org.springframework.cache.interceptor.AbstractCacheInvoker"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( errorHandler ,     \" CacheErrorHandler   must   not   be   null \"  )  ;", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.cache.interceptor.AbstractCacheInvoker"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . cacheManager )     !  =    null )  ,     \" No   CacheManager   set \"  )  ;", "return   this . cacheManager ;", "}", "METHOD_END"], "methodName": ["getCacheManager"], "fileName": "org.springframework.cache.interceptor.AbstractCacheResolver"}, {"methodBody": ["METHOD_START", "{", "this . cacheManager    =    cacheManager ;", "}", "METHOD_END"], "methodName": ["setCacheManager"], "fileName": "org.springframework.cache.interceptor.AbstractCacheResolver"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["allowPublicMethodsOnly"], "fileName": "org.springframework.cache.interceptor.AbstractFallbackCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allowPublicMethodsOnly (  )  )     &  &     (  !  ( Modifier . isPublic ( method . getModifiers (  )  )  )  )  )     {", "return   null ;", "}", "Method   specificMethod    =    AopUtils . getMostSpecificMethod ( method ,    targetClass )  ;", "Collection <  >    opDef    =    finds ( specificMethod )  ;", "if    ( opDef    !  =    null )     {", "return   opDef ;", "}", "opDef    =    finds ( specificMethod . getDeclaringClass (  )  )  ;", "if    (  ( opDef    !  =    null )     &  &     ( ClassUtils . isUserLevelMethod ( method )  )  )     {", "return   opDef ;", "}", "if    ( specificMethod    !  =    method )     {", "opDef    =    finds ( method )  ;", "if    ( opDef    !  =    null )     {", "return   opDef ;", "}", "opDef    =    finds ( method . getDeclaringClass (  )  )  ;", "if    (  ( opDef    !  =    null )     &  &     ( ClassUtils . isUserLevelMethod ( method )  )  )     {", "return   opDef ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["computeCacheOperations"], "fileName": "org.springframework.cache.interceptor.AbstractFallbackCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodClassKey ( method ,    targetClass )  ;", "}", "METHOD_END"], "methodName": ["getCacheKey"], "fileName": "org.springframework.cache.interceptor.AbstractFallbackCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "this . cacheOperationSource    =    cacheOperationSource ;", "}", "METHOD_END"], "methodName": ["setCacheOperationSource"], "fileName": "org.springframework.cache.interceptor.BeanFactoryCacheOperationSourceAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setClassFilter ( classFilter )  ;", "}", "METHOD_END"], "methodName": ["setClassFilter"], "fileName": "org.springframework.cache.interceptor.BeanFactoryCacheOperationSourceAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . metadataCache . clear (  )  ;", "this . evaluator . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearMetadataCache"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "for    ( CacheAspectSupport . CacheOperationContext   context    :    contexts )     {", "if    ( isConditionPassing ( context ,    result )  )     {", "Object   key    =    generateKey ( context ,    result )  ;", "putRequests . add ( new   CacheAspectSupport . CachePutRequest ( context ,    key )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["collectPutRequests"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( this . initialized )     {", "Class <  ?  >    targetClass    =    getTargetClass ( target )  ;", "CacheOperationSource   cacheOperationSource    =    getCacheOperationSource (  )  ;", "if    ( cacheOperationSource    !  =    null )     {", "Collection < CacheOperation >    operations    =    cacheOperationSource . getCacheOperations ( method ,    targetClass )  ;", "if    (  !  ( CollectionUtils . isEmpty ( operations )  )  )     {", "return   execute ( invoker ,    method ,    new    . CacheOperationContexts ( operations ,    method ,    args ,    target ,    targetClass )  )  ;", "}", "}", "}", "return   invoker . invoke (  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( contexts . isSynchronized (  )  )     {", ". CacheOperationContext   context    =    contexts . get ( CacheableOperation . class )  . iterator (  )  . next (  )  ;", "if    ( isConditionPassing ( context ,    CacheOperationExpressionEvaluator . NO _ RESULT )  )     {", "Object   key    =    generateKey ( context ,    CacheOperationExpressionEvaluator . NO _ RESULT )  ;", "Cache   cache    =    context . getCaches (  )  . iterator (  )  . next (  )  ;", "try    {", "return   wrapCacheValue ( method ,    cache . get ( key ,     (  )     -  >    unwrapReturnValue ( invokeOperation ( invoker )  )  )  )  ;", "}    catch    ( Cache . ValueRetrievalException   ex )     {", "throw    (  ( CacheOperationInvoker . ThrowableWrapper )     ( ex . getCause (  )  )  )  ;", "}", "} else    {", "return   invokeOperation ( invoker )  ;", "}", "}", "processCacheEvicts ( contexts . get ( CacheEvictOperation . class )  ,    true ,    CacheOperationExpressionEvaluator . NO _ RESULT )  ;", "Cache . ValueWrapper   cacheHit    =    findCachedItem ( contexts . get ( CacheableOperation . class )  )  ;", "List <  . CachePutRequest >    cachePutRequests    =    new   LinkedList <  >  (  )  ;", "if    ( cacheHit    =  =    null )     {", "collectPutRequests ( contexts . get ( CacheableOperation . class )  ,    CacheOperationExpressionEvaluator . NO _ RESULT ,    cachePutRequests )  ;", "}", "Object   cacheValue ;", "Object   returnValue ;", "if    (  (  ( cacheHit    !  =    null )     &  &     ( cachePutRequests . isEmpty (  )  )  )     &  &     (  !  ( hasCachePut ( contexts )  )  )  )     {", "cacheValue    =    cacheHit . get (  )  ;", "returnValue    =    wrapCacheValue ( method ,    cacheValue )  ;", "} else    {", "returnValue    =    invokeOperation ( invoker )  ;", "cacheValue    =    unwrapReturnValue ( returnValue )  ;", "}", "collectPutRequests ( contexts . get ( CachePutOperation . class )  ,    cacheValue ,    cachePutRequests )  ;", "for    (  . CachePutRequest   cachePutRequest    :    cachePutRequests )     {", "cachePutRequest . apply ( cacheValue )  ;", "}", "processCacheEvicts ( contexts . get ( CacheEvictOperation . class )  ,    false ,    cacheValue )  ;", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    CacheOperationExpressionEvaluator . NO _ RESULT ;", "for    (  . CacheOperationContext   context    :    contexts )     {", "if    ( isConditionPassing ( context ,    result )  )     {", "Object   key    =    generateKey ( context ,    result )  ;", "Cache . ValueWrapper   cached    =    findInCaches ( context ,    key )  ;", "if    ( cached    !  =    null )     {", "return   cached ;", "} else    {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" No   cache   entry   for   key    '  \"     +    key )     +     \"  '    in   cache ( s )     \"  )     +     ( context . getCacheNames (  )  )  )  )  ;", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findCachedItem"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "for    ( Cache    :    context . getCaches (  )  )     {", "Cache . ValueWrapper   wrapper    =    doGet (    key )  ;", "if    ( wrapper    !  =    null )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  \" Cache   entry   for   key    '  \"     +    key )     +     \"  '    found   in    '  \"  )     +     ( getName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "return   wrapper ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findInCaches"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "Object   key    =    context . generateKey ( result )  ;", "if    ( key    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  \" Null   key   returned   for      operation    ( maybe   you   are    \"     +     \" using   named   params   on   classes   without   debug   info ?  )     \"  )     +     ( context . metadata . operation )  )  )  ;", "}", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Computed      key    '  \"     +    key )     +     \"  '    for   operation    \"  )     +     ( context . metadata . operation )  )  )  ;", "}", "return   key ;", "}", "METHOD_END"], "methodName": ["generateKey"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" BeanFactory   must   be   set   on      aspect   for    \"     +     ( expectedType . getSimpleName (  )  )  )     +     \"    retrieval \"  )  )  ;", "}", "return   BeanFactoryAnnotationUtils . qualifiedBeanOfType ( this . beanFactory ,    expectedType ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "CacheAspectSupport . CacheOperationCacheKey   cacheKey    =    new   CacheAspectSupport . CacheOperationCacheKey ( operation ,    method ,    targetClass )  ;", "CacheAspectSupport . CacheOperationMetadata   metadata    =    this . metadataCache . get ( cacheKey )  ;", "if    ( metadata    =  =    null )     {", "KeyGenerator   operationKeyGenerator ;", "if    ( StringUtils . hasText ( operation . getKeyGenerator (  )  )  )     {", "operationKeyGenerator    =    getBean ( operation . getKeyGenerator (  )  ,    KeyGenerator . class )  ;", "} else    {", "operationKeyGenerator    =    getKeyGenerator (  )  ;", "}", "CacheResolver   operationCacheResolver ;", "if    ( StringUtils . hasText ( operation . getCacheResolver (  )  )  )     {", "operationCacheResolver    =    getBean ( operation . getCacheResolver (  )  ,    CacheResolver . class )  ;", "} else", "if    ( StringUtils . hasText ( operation . getCacheManager (  )  )  )     {", "CacheManager   cacheManager    =    getBean ( operation . getCacheManager (  )  ,    CacheManager . class )  ;", "operationCacheResolver    =    new   SimpleCacheResolver ( cacheManager )  ;", "} else    {", "operationCacheResolver    =    getCacheResolver (  )  ;", "state (  ( operationCacheResolver    !  =    null )  ,     \" No   CacheResolver / CacheManager   set \"  )  ;", "}", "metadata    =    new   CacheAspectSupport . CacheOperationMetadata ( operation ,    method ,    targetClass ,    operationKeyGenerator ,    operationCacheResolver )  ;", "this . metadataCache . put ( cacheKey ,    metadata )  ;", "}", "return   metadata ;", "}", "METHOD_END"], "methodName": ["getCacheOperationMetadata"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheOperationSource ;", "}", "METHOD_END"], "methodName": ["getCacheOperationSource"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheResolver ;", "}", "METHOD_END"], "methodName": ["getCacheResolver"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "Collection <  ?    extends   Cache >    caches    =    cacheResolver . resolveCaches ( context )  ;", "if    ( caches . isEmpty (  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  \" No   cache   could   be   resolved   for    '  \"     +     ( context . getOperation (  )  )  )     +     \"  '    using   resolver    '  \"  )     +    cacheResolver )     +     \"  '  .    At   least   one   cache   should   be   provided   per   cache   operation .  \"  )  )  ;", "}", "return   caches ;", "}", "METHOD_END"], "methodName": ["getCaches"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . keyGenerator ;", "}", "METHOD_END"], "methodName": ["getKeyGenerator"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "CacheAspectSupport . CacheOperationMetadata   metadata    =    getCacheOperationMetadata ( operation ,    method ,    targetClass )  ;", "return   new   CacheAspectSupport . CacheOperationContext ( metadata ,    args ,    target )  ;", "}", "METHOD_END"], "methodName": ["getOperationContext"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   AopProxyUtils . ultimateTargetClass ( target )  ;", "}", "METHOD_END"], "methodName": ["getTargetClass"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheAspectSupport . CacheOperationContext >    cachePutContexts    =    contexts . get ( CachePutOperation . class )  ;", "Collection < CacheAspectSupport . CacheOperationContext >    excluded    =    new   ArrayList <  >  (  )  ;", "for    ( CacheAspectSupport . CacheOperationContext   context    :    cachePutContexts )     {", "try    {", "if    (  !  ( context . isConditionPassing ( CacheOperationExpressionEvaluator . RESULT _ UNAVAILABLE )  )  )     {", "excluded . add ( context )  ;", "}", "}    catch    ( VariableNotAvailableException   ex )     {", "}", "}", "return    ( cachePutContexts . size (  )  )     !  =     ( excluded . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasCachePut"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   invoker . invoke (  )  ;", "}", "METHOD_END"], "methodName": ["invokeOperation"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "boolean   passing    =    context . isConditionPassing ( result )  ;", "if    (  (  ! passing )     &  &     ( logger . isTraceEnabled (  )  )  )     {", "logger . trace (  (  (  (  \"    condition   failed   on   method    \"     +     ( context . metadata . method )  )     +     \"    for   operation    \"  )     +     ( context . metadata . operation )  )  )  ;", "}", "return   passing ;", "}", "METHOD_END"], "methodName": ["isConditionPassing"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  (  \" Invalidating    \"     +     ( key    !  =    null    ?     (  \"    key    [  \"     +    key )     +     \"  ]  \"     :     \" entire    \"  )  )     +     \"    for   operation    \"  )     +    operation )     +     \"    on   method    \"  )     +     ( context . metadata . method )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["logInvalidating"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "Method   specificMethod    =    ClassUtils . getMostSpecificMethod ( method ,    targetClass )  ;", "return   ClassUtils . getQualifiedMethodName ( specificMethod )  ;", "}", "METHOD_END"], "methodName": ["methodIdentification"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "Object   key    =    null ;", "for    (    cache    :    context . gets (  )  )     {", "if    ( operation . isWide (  )  )     {", "logInvalidating ( context ,    operation ,    null )  ;", "doClear ( cache )  ;", "} else    {", "if    ( key    =  =    null )     {", "key    =    generateKey ( context ,    result )  ;", "}", "logInvalidating ( context ,    operation ,    key )  ;", "doEvict ( cache ,    key )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["performCacheEvict"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "for    ( CacheAspectSupport . CacheOperationContext   context    :    contexts )     {", "CacheEvictOperation   operation    =     (  ( CacheEvictOperation )     ( context . metadata . operation )  )  ;", "if    (  ( beforeInvocation    =  =     ( operation . isBeforeInvocation (  )  )  )     &  &     ( isConditionPassing ( context ,    result )  )  )     {", "performCacheEvict ( context ,    operation ,    result )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processCacheEvicts"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . cacheResolver    =    new   SimpleCacheResolver ( cacheManager )  ;", "}", "METHOD_END"], "methodName": ["setCacheManager"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmptyOperationSources ,     \" At   least    1    CacheOperationSource   needs   to   be   specified \"  )  ;", "thisOperationSource    =     ( OperationSources . length )     >     1  )     ?    new   CompositeCacheOperationSourceOperationSources )     : OperationSources [  0  ]  ;", "}", "METHOD_END"], "methodName": ["setCacheOperationSources"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . cacheResolver    =    cacheResolver ;", "}", "METHOD_END"], "methodName": ["setCacheResolver"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . keyGenerator    =    keyGenerator ;", "}", "METHOD_END"], "methodName": ["setKeyGenerator"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   ObjectUtils . unwrapOptional ( returnValue )  ;", "}", "METHOD_END"], "methodName": ["unwrapReturnValue"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( method . getReturnType (  )  )     =  =     ( Optional . class )  )     &  &     (  ( cacheValue    =  =    null )     |  |     (  ( cacheValue . getClass (  )  )     !  =     ( Optional . class )  )  )  )     {", "return   Optional . ofNullable ( cacheValue )  ;", "}", "return   cacheValue ;", "}", "METHOD_END"], "methodName": ["wrapCacheValue"], "fileName": "org.springframework.cache.interceptor.CacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   evict \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . clear (  )  ;", "this . simpleService . clear (  )  ;", "verify ( this . e )  . handleCacheClearError ( exception ,    cache )  ;", "}", "METHOD_END"], "methodName": ["clearFail"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   evict \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . clear (  )  ;", "this . cacheInterceptor . setErrorHandler ( new   Simple (  )  )  ;", "this . thrown . expect ( is ( exception )  )  ;", "this . simpleService . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearFailProperException"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   evict \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . evict (  0 L )  ;", "this . simpleService . evict (  0 L )  ;", "verify ( this . e )  . handleCacheEvictError ( exception ,    cache ,     0 L )  ;", "}", "METHOD_END"], "methodName": ["evictFail"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   evict \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . evict (  0 L )  ;", "this . cacheInterceptor . setErrorHandler ( new   Simple (  )  )  ;", "this . thrown . expect ( is ( exception )  )  ;", "this . simpleService . evict (  0 L )  ;", "}", "METHOD_END"], "methodName": ["evictFailProperException"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   get \"  )  ;", "willThrow ( exception )  . given ( this )  . get (  0 L )  ;", "willThrow ( exception )  . given ( this )  . put (  0 L ,     0 L )  ;", "Object   counter    =    this . simpleService . get (  0 L )  ;", "willReturn ( new   SimpleValueWrapper (  2 L )  )  . given ( this )  . get (  0 L )  ;", "Object   counter 2     =    this . simpleService . get (  0 L )  ;", "Object   counter 3     =    this . simpleService . get (  0 L )  ;", "assertNotSame ( counter ,    counter 2  )  ;", "assertEquals ( counter 2  ,    counter 3  )  ;", "}", "METHOD_END"], "methodName": ["getAndPutFail"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   get \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . get (  0 L )  ;", "Object   result    =    this . simpleService . get (  0 L )  ;", "verify ( this . e )  . handleCacheGetError ( exception ,    cache ,     0 L )  ;", "verify ( this . cache )  . get (  0 L )  ;", "verify ( this . cache )  . put (  0 L ,    result )  ;", "}", "METHOD_END"], "methodName": ["getFail"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   get \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . get (  0 L )  ;", "this . cacheInterceptor . setErrorHandler ( new   Simple (  )  )  ;", "this . thrown . expect ( is ( exception )  )  ;", "this . simpleService . get (  0 L )  ;", "}", "METHOD_END"], "methodName": ["getFailProperException"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   put \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . put (  0 L ,     0 L )  ;", "this . simpleService . put (  0 L )  ;", "verify ( this . e )  . handleCachePutError ( exception ,    cache ,     0 L ,     0 L )  ;", "}", "METHOD_END"], "methodName": ["putFail"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   put \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . put (  0 L ,     0 L )  ;", "this . cacheInterceptor . setErrorHandler ( new   Simple (  )  )  ;", "this . thrown . expect ( is ( exception )  )  ;", "this . simpleService . put (  0 L )  ;", "}", "METHOD_END"], "methodName": ["putFailProperException"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheErrorHandlerTests . Config . class )  ;", "this . cache    =    context . getBean (  \" mockCache \"  ,    Cache . class )  ;", "this . cacheInterceptor    =    context . getBean ( CacheInterceptor . class )  ;", "this . errorHandler    =    context . getBean ( CacheErrorHandler . class )  ;", "this . simpleService    =    context . getBean ( CacheErrorHandlerTests . SimpleService . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.interceptor.CacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . unavailableVariables . add ( name )  ;", "}", "METHOD_END"], "methodName": ["addUnavailableVariable"], "fileName": "org.springframework.cache.interceptor.CacheEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . beforeInvocation ;", "}", "METHOD_END"], "methodName": ["isBeforeInvocation"], "fileName": "org.springframework.cache.interceptor.CacheEvictOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheWide ;", "}", "METHOD_END"], "methodName": ["isCacheWide"], "fileName": "org.springframework.cache.interceptor.CacheEvictOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . args ;", "}", "METHOD_END"], "methodName": ["getArgs"], "fileName": "org.springframework.cache.interceptor.CacheExpressionRootObject"}, {"methodBody": ["METHOD_START", "{", "return   this . caches ;", "}", "METHOD_END"], "methodName": ["getCaches"], "fileName": "org.springframework.cache.interceptor.CacheExpressionRootObject"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.cache.interceptor.CacheExpressionRootObject"}, {"methodBody": ["METHOD_START", "{", "return   this . method . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getMethodName"], "fileName": "org.springframework.cache.interceptor.CacheExpressionRootObject"}, {"methodBody": ["METHOD_START", "{", "return   this . target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.springframework.cache.interceptor.CacheExpressionRootObject"}, {"methodBody": ["METHOD_START", "{", "return   this . targetClass ;", "}", "METHOD_END"], "methodName": ["getTargetClass"], "fileName": "org.springframework.cache.interceptor.CacheExpressionRootObject"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheManager ;", "}", "METHOD_END"], "methodName": ["getCacheManager"], "fileName": "org.springframework.cache.interceptor.CacheOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheResolver ;", "}", "METHOD_END"], "methodName": ["getCacheResolver"], "fileName": "org.springframework.cache.interceptor.CacheOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . condition ;", "}", "METHOD_END"], "methodName": ["getCondition"], "fileName": "org.springframework.cache.interceptor.CacheOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . key ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "org.springframework.cache.interceptor.CacheOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . keyGenerator ;", "}", "METHOD_END"], "methodName": ["getKeyGenerator"], "fileName": "org.springframework.cache.interceptor.CacheOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.cache.interceptor.CacheOperation"}, {"methodBody": ["METHOD_START", "{", "this . keyCache . clear (  )  ;", "this . conditionCache . clear (  )  ;", "this . unlessCache . clear (  )  ;", "this . targetMethodCache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.cache.interceptor.CacheOperationExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . TRUE . equals ( getExpression ( this . conditionCache ,    methodKey ,    conditionExpression )  . getValue ( evalContext ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["condition"], "fileName": "org.springframework.cache.interceptor.CacheOperationExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "CacheExpressionRootObject   rootObject    =    new   CacheExpressionRootObject ( caches ,    method ,    args ,    target ,    targetClass )  ;", "Method   targetMethod    =    getTargetMethod ( targetClass ,    method )  ;", "CacheEvaluationContext   evaluationContext    =    new   CacheEvaluationContext ( rootObject ,    targetMethod ,    args ,    getParameterNameDiscoverer (  )  )  ;", "if    ( result    =  =     (  . RESULT _ UNAVAILABLE )  )     {", "evaluationContext . addUnavailableVariable (  . RESULT _ VARIABLE )  ;", "} else", "if    ( result    !  =     (  . NO _ RESULT )  )     {", "evaluationContext . setVariable (  . RESULT _ VARIABLE ,    result )  ;", "}", "if    ( beanFactory    !  =    null )     {", "evaluationContext . setBeanResolver ( new   BeanFactoryResolver ( beanFactory )  )  ;", "}", "return   evaluationContext ;", "}", "METHOD_END"], "methodName": ["createEvaluationContext"], "fileName": "org.springframework.cache.interceptor.CacheOperationExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   createEvaluationContext ( caches ,    method ,    args ,    target ,    targetClass ,    CacheOperationExpressionEvaluator . NO _ RESULT ,    beanFactory )  ;", "}", "METHOD_END"], "methodName": ["createEvaluationContext"], "fileName": "org.springframework.cache.interceptor.CacheOperationExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElementKey   methodKey    =    new   AnnotatedElementKey ( method ,    targetClass )  ;", "Method   targetMethod    =    this . targetMethod . get ( methodKey )  ;", "if    ( targetMethod    =  =    null )     {", "targetMethod    =    AopUtils . getMostSpecificMethod ( method ,    targetClass )  ;", "this . targetMethod . put ( methodKey ,    targetMethod )  ;", "}", "return   targetMethod ;", "}", "METHOD_END"], "methodName": ["getTargetMethod"], "fileName": "org.springframework.cache.interceptor.CacheOperationExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   getExpression ( this . keyCache ,    methodKey ,    keyExpression )  . getValue ( evalContext )  ;", "}", "METHOD_END"], "methodName": ["key"], "fileName": "org.springframework.cache.interceptor.CacheOperationExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . TRUE . equals ( getExpression ( this . unlessCache ,    methodKey ,    unlessExpression )  . getValue ( evalContext ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["unless"], "fileName": "org.springframework.cache.interceptor.CacheOperationExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "this . cacheInterceptor . setCacheManager ( cacheManager )  ;", "}", "METHOD_END"], "methodName": ["setCacheManager"], "fileName": "org.springframework.cache.interceptor.CacheProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cacheInterceptor . setCacheOperationSources ( cacheOperationSources )  ;", "}", "METHOD_END"], "methodName": ["setCacheOperationSources"], "fileName": "org.springframework.cache.interceptor.CacheProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cacheInterceptor . setCacheResolver ( cacheResolver )  ;", "}", "METHOD_END"], "methodName": ["setCacheResolver"], "fileName": "org.springframework.cache.interceptor.CacheProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cacheInterceptor . setKeyGenerator ( keyGenerator )  ;", "}", "METHOD_END"], "methodName": ["setKeyGenerator"], "fileName": "org.springframework.cache.interceptor.CacheProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . pointcut    =    pointcut ;", "}", "METHOD_END"], "methodName": ["setPointcut"], "fileName": "org.springframework.cache.interceptor.CacheProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "try    ( AnnotationConfigApplicationContext   applicationContext    =    new   AnnotationConfigApplicationContext ( CacheProxyFactoryBeanTests . CacheProxyFactoryBeanConfiguration . class )  )     {", "CacheProxyFactoryBeanTests . Greeter   greeter    =    applicationContext . getBean (  \" greeter \"  ,    CacheProxyFactoryBeanTests . Greeter . class )  ;", "assertNotNull ( greeter )  ;", "assertFalse ( greeter . isCacheMiss (  )  )  ;", "assertEquals (  \" Hello   John !  \"  ,    greeter . greet (  \" John \"  )  )  ;", "assertTrue ( greeter . isCacheMiss (  )  )  ;", "assertEquals (  \" Hello   Jon !  \"  ,    greeter . greet (  \" Jon \"  )  )  ;", "assertTrue ( greeter . isCacheMiss (  )  )  ;", "assertEquals (  \" Hello   John !  \"  ,    greeter . greet (  \" John \"  )  )  ;", "assertFalse ( greeter . isCacheMiss (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    greeter . greet (  )  )  ;", "assertTrue ( greeter . isCacheMiss (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    greeter . greet (  )  )  ;", "assertFalse ( greeter . isCacheMiss (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configurationClassWithCacheProxyFactoryBean"], "fileName": "org.springframework.cache.interceptor.CacheProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . context )     !  =    null )     {", "this . context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.cache.interceptor.CachePutEvaluationTests"}, {"methodBody": ["METHOD_START", "{", "this . cache . clear (  )  ;", "long   key    =     1  ;", "Long   value    =    this . service . getAndPut ( key )  ;", "assertEquals (  \" Wrong   value   for    @ Cacheable   key \"  ,    value ,    this . cache . get ( key )  . get (  )  )  ;", "assertEquals (  \" Wrong   value   for    @    key \"  ,    value ,    this . cache . get (  ( value    +     1  0  0  )  )  . get (  )  )  ;", "Long   anotherValue    =    this . service . getAndPut ( key )  ;", "assertNotSame ( value ,    anotherValue )  ;", "assertEquals (  \" Wrong   value   for    @    key \"  ,    anotherValue ,    this . cache . get (  ( anotherValue    +     1  0  0  )  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAndPut"], "fileName": "org.springframework.cache.interceptor.CachePutEvaluationTests"}, {"methodBody": ["METHOD_START", "{", "String   key    =     \"  1  \"  ;", "Long   first    =    this . service . getOrPut ( key ,    true )  ;", "Long   second    =    this . service . getOrPut ( key ,    true )  ;", "assertSame ( first ,    second )  ;", "Long   expected    =    first    +     1  ;", "Long   third    =    this . service . getOrPut ( key ,    false )  ;", "assertEquals ( expected ,    third )  ;", "Long   fourth    =    this . service . getOrPut ( key ,    true )  ;", "assertSame ( third ,    fourth )  ;", "}", "METHOD_END"], "methodName": ["mutualGetPutExclusion"], "fileName": "org.springframework.cache.interceptor.CachePutEvaluationTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( CachePutEvaluationTests . Config . class )  ;", "this . cache    =    this . context . getBean ( CacheManager . class )  . getCache (  \" test \"  )  ;", "this . service    =    this . context . getBean ( CachePutEvaluationTests . SimpleService . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.interceptor.CachePutEvaluationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . unless ;", "}", "METHOD_END"], "methodName": ["getUnless"], "fileName": "org.springframework.cache.interceptor.CachePutOperation"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    this . anotherCacheManager . getCache (  \" default \"  )  ;", "Object   key    =    new   Object (  )  ;", "CacheTestUtils . assertCacheMiss ( key ,    cache )  ;", "Object   value    =    this . simpleService . getWithCacheManager ( key )  ;", "CacheTestUtils . assertCacheHit ( key ,    value ,    cache )  ;", "}", "METHOD_END"], "methodName": ["customCacheManager"], "fileName": "org.springframework.cache.interceptor.CacheResolverCustomizationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    this . cacheManager . getCache (  \" primary \"  )  ;", "Object   key    =    new   Object (  )  ;", "CacheTestUtils . assertCacheMiss ( key ,    cache )  ;", "Object   value    =    this . simpleService . getWithCustom ( key )  ;", "CacheTestUtils . assertCacheHit ( key ,    value ,    cache )  ;", "}", "METHOD_END"], "methodName": ["customCacheResolver"], "fileName": "org.springframework.cache.interceptor.CacheResolverCustomizationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    this . cacheManager . getCache (  \" secondary \"  )  ;", "Object   key    =    new   Object (  )  ;", "CacheTestUtils . assertCacheMiss ( key ,    cache )  ;", "Object   value    =    this . simpleService . getWithNamedution ( key )  ;", "CacheTestUtils . assertCacheHit ( key ,    value ,    cache )  ;", "}", "METHOD_END"], "methodName": ["namedResolution"], "fileName": "org.springframework.cache.interceptor.CacheResolverCustomizationTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( CacheResolverCustomizationTests . SimpleService . class ,     \" noCacheResolved \"  ,    Object . class )  ;", "try    {", "this . simpleService . noCacheResolved ( new   Object (  )  )  ;", "fail (  \" Should   have   failed ,    no   cache   resolved \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  \" Reference   to   the   method   must   be   contained   in   the   message \"  ,    ex . getMessage (  )  . contains ( method . toString (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["noCacheResolved"], "fileName": "org.springframework.cache.interceptor.CacheResolverCustomizationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    this . cacheManager . getCache (  \" default \"  )  ;", "Object   key    =    new   Object (  )  ;", "CacheTestUtils . assertCacheMiss ( key ,    cache )  ;", "Object   value    =    this . simpleService . getSimple ( key )  ;", "CacheTestUtils . assertCacheHit ( key ,    value ,    cache )  ;", "}", "METHOD_END"], "methodName": ["noCustomization"], "fileName": "org.springframework.cache.interceptor.CacheResolverCustomizationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   defaultCache    =    this . cacheManager . getCache (  \" default \"  )  ;", "Cache   primaryCache    =    this . cacheManager . getCache (  \" primary \"  )  ;", "Object   key    =    new   Object (  )  ;", "CacheTestUtils . assertCacheMiss ( key ,    defaultCache ,    primaryCache )  ;", "Object   value    =    this . simpleService . getWithRuntimeution ( key ,     \" default \"  )  ;", "CacheTestUtils . assertCacheHit ( key ,    value ,    defaultCache )  ;", "CacheTestUtils . assertCacheMiss ( key ,    primaryCache )  ;", "Object   key 2     =    new   Object (  )  ;", "CacheTestUtils . assertCacheMiss ( key 2  ,    defaultCache ,    primaryCache )  ;", "Object   value 2     =    this . simpleService . getWithRuntimeution ( key 2  ,     \" primary \"  )  ;", "CacheTestUtils . assertCacheHit ( key 2  ,    value 2  ,    primaryCache )  ;", "CacheTestUtils . assertCacheMiss ( key 2  ,    defaultCache )  ;", "}", "METHOD_END"], "methodName": ["runtimeResolution"], "fileName": "org.springframework.cache.interceptor.CacheResolverCustomizationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( CacheResolverCustomizationTests . Config . class )  ;", "this . cacheManager    =    context . getBean (  \" cacheManager \"  ,    CacheManager . class )  ;", "this . anotherCacheManager    =    context . getBean (  \" anotherCacheManager \"  ,    CacheManager . class )  ;", "this . simpleService    =    context . getBean ( CacheResolverCustomizationTests . SimpleService . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.interceptor.CacheResolverCustomizationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . simpleService . unknown ( new   Object (  )  )  ;", "fail (  \" Should   have   failed ,    no   cache   resolver   with   that   name \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "assertEquals (  \" Wrong   bean   name   in   exception \"  ,     \" unknown \"  ,    ex . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unknownCacheResolver"], "fileName": "org.springframework.cache.interceptor.CacheResolverCustomizationTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . context )     !  =    null )     {", "this . context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeContext"], "fileName": "org.springframework.cache.interceptor.CacheSyncFailureTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( CacheSyncFailureTests . Config . class )  ;", "this . simpleService    =    this . context . getBean ( CacheSyncFailureTests . SimpleService . class )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.cache.interceptor.CacheSyncFailureTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \"  @ Cacheable ( sync = true )    only   allows   a   single    \"  )  ;", "this . simpleService . severalCachesSync (  \" key \"  )  ;", "}", "METHOD_END"], "methodName": ["severalCachesSync"], "fileName": "org.springframework.cache.interceptor.CacheSyncFailureTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \"  @ Cacheable ( sync = true )    only   allows   a   single    \"  )  ;", "this . simpleService . severalCachesWithResolvedSync (  \" key \"  )  ;", "}", "METHOD_END"], "methodName": ["severalCachesWithResolvedSync"], "fileName": "org.springframework.cache.interceptor.CacheSyncFailureTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \"  @ Cacheable ( sync = true )    cannot   be   combined   with   other      operations \"  )  ;", "this . simpleService . syncWithAnotherOperation (  \" key \"  )  ;", "}", "METHOD_END"], "methodName": ["syncWithAnotherOperation"], "fileName": "org.springframework.cache.interceptor.CacheSyncFailureTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" Only   one    @ able ( sync = true )    entry   is   allowed \"  )  ;", "this . simpleService . syncWithTwoGetOperations (  \" key \"  )  ;", "}", "METHOD_END"], "methodName": ["syncWithTwoGetOperations"], "fileName": "org.springframework.cache.interceptor.CacheSyncFailureTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \"  @ able ( sync = true )    does   not   support   unless   attribute \"  )  ;", "this . simpleService . unlessSync (  \" key \"  )  ;", "}", "METHOD_END"], "methodName": ["unlessSync"], "fileName": "org.springframework.cache.interceptor.CacheSyncFailureTests"}, {"methodBody": ["METHOD_START", "{", "return   this . unless ;", "}", "METHOD_END"], "methodName": ["getUnless"], "fileName": "org.springframework.cache.interceptor.CacheableOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . sync ;", "}", "METHOD_END"], "methodName": ["isSync"], "fileName": "org.springframework.cache.interceptor.CacheableOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheOperationSources ;", "}", "METHOD_END"], "methodName": ["getCacheOperationSources"], "fileName": "org.springframework.cache.interceptor.CompositeCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "return   createEvaluationContext ( result ,    null )  ;", "}", "METHOD_END"], "methodName": ["createEvaluationContext"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionEvaluatorTests . AnnotatedClass   target    =    new   ExpressionEvaluatorTests . AnnotatedClass (  )  ;", "Method   method    =    ReflectionUtils . findMethod ( ExpressionEvaluatorTests . AnnotatedClass . class ,     \" multipleCaching \"  ,    Object . class ,    Object . class )  ;", "Object [  ]    args    =    new   Object [  ]  {    new   Object (  )  ,    new   Object (  )     }  ;", "Collection < ConcurrentMapCache >    caches    =    Collections . singleton ( new   ConcurrentMapCache (  \" test \"  )  )  ;", "return   this . eval . createEvaluationContext ( caches ,    method ,    args ,    target ,    target . getClass (  )  ,    result ,    beanFactory )  ;", "}", "METHOD_END"], "methodName": ["createEvaluationContext"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ExpressionEvaluatorTests . AnnotatedClass . class ,    name ,    Object . class ,    Object . class )  ;", "return   this . source . getCacheOperations ( method ,    ExpressionEvaluatorTests . AnnotatedClass . class )  ;", "}", "METHOD_END"], "methodName": ["getOps"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   applicationContext    =    new   StaticApplicationContext (  )  ;", "BeanDefinition   beanDefinition    =    new   RootBeanDefinition ( String . class )  ;", "applicationContext . registerBeanDefinition (  \" myBean \"  ,    beanDefinition )  ;", "applicationContext . refresh (  )  ;", "EvaluationContext   context    =    createEvaluationContext ( CacheOperation . NO _ RESULT ,    applicationContext )  ;", "Object   value    =    new   SpelExpressionParser (  )  . parseExpression (  \"  @ myBean . class . getName (  )  \"  )  . getValue ( context )  ;", "assertThat ( value ,    is ( String . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveBeanReference"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionEvaluatorTests . AnnotatedClass   target    =    new   ExpressionEvaluatorTests . AnnotatedClass (  )  ;", "Method   method    =    ReflectionUtils . findMethod ( ExpressionEvaluatorTests . AnnotatedClass . class ,     \" multipleCaching \"  ,    Object . class ,    Object . class )  ;", "Object [  ]    args    =    new   Object [  ]  {    new   Object (  )  ,    new   Object (  )     }  ;", "Collection < ConcurrentMapCache >    caches    =    Collections . singleton ( new   ConcurrentMapCache (  \" test \"  )  )  ;", "EvaluationContext   evalCtx    =    this . eval . createEvaluationContext ( caches ,    method ,    args ,    target ,    target . getClass (  )  ,    null )  ;", "Collection < CacheOperation >    ops    =    getOps (  \" multipleCaching \"  )  ;", "Iterator < CacheOperation >    it    =    ops . iterator (  )  ;", "AnnotatedElementKey   key    =    new   AnnotatedElementKey ( method ,    ExpressionEvaluatorTests . AnnotatedClass . class )  ;", "Object   keyA    =    this . eval . key ( it . next (  )  . getKey (  )  ,    key ,    evalCtx )  ;", "Object   keyB    =    this . eval . key ( it . next (  )  . getKey (  )  ,    key ,    evalCtx )  ;", "assertEquals ( args [  0  ]  ,    keyA )  ;", "assertEquals ( args [  1  ]  ,    keyB )  ;", "}", "METHOD_END"], "methodName": ["testMultipleCachingEval"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CacheOperation >    ops    =    getOps (  \" multipleCaching \"  )  ;", "assertEquals (  2  ,    ops . size (  )  )  ;", "Iterator < CacheOperation >    it    =    ops . iterator (  )  ;", "CacheOperation   next    =    it . next (  )  ;", "assertTrue (  ( next   instanceof   CacheableOperation )  )  ;", "assertTrue ( next . getCacheNames (  )  . contains (  \" test \"  )  )  ;", "assertEquals (  \"  # a \"  ,    next . getKey (  )  )  ;", "next    =    it . next (  )  ;", "assertTrue (  ( next   instanceof   CacheableOperation )  )  ;", "assertTrue ( next . getCacheNames (  )  . contains (  \" test \"  )  )  ;", "assertEquals (  \"  # b \"  ,    next . getKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleCachingSource"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    createEvaluationContext ( CacheOperationExpressionEvaluator . RESULT _ UNAVAILABLE )  ;", "try    {", "new   SpelExpressionParser (  )  . parseExpression (  \"  # result \"  )  . getValue ( context )  ;", "fail (  \" Should   have   failed   to   parse   expression ,    result   not   available \"  )  ;", "}    catch    ( VariableNotAvailableException   e )     {", "assertEquals (  \" wrong   variable   name \"  ,     \" result \"  ,    e . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unavailableReturnValue"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    createEvaluationContext ( null )  ;", "Object   value    =    new   SpelParser (  )  . parse (  \"  # result \"  )  . getValue ( context )  ;", "assertThat ( value ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withNullReturn"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    createEvaluationContext (  \" theResult \"  )  ;", "Object   value    =    new   SpelParser (  )  . parse (  \"  # result \"  )  . getValue ( context )  ;", "assertThat ( value ,    equalTo (  \" theResult \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withReturnValue"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    createEvaluationContext ( CacheOperationExpressionEvaluator . NO _ RESULT )  ;", "Object   value    =    new   SpelExpressionParser (  )  . parseExpression (  \"  # result \"  )  . getValue ( context )  ;", "assertThat ( value ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withoutReturnValue"], "fileName": "org.springframework.cache.interceptor.ExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( NameMatchCacheOperationSource . logger . isDebugEnabled (  )  )     {", "NameMatchCacheOperationSource . logger . debug (  (  (  (  (  \" Adding   method    [  \"     +    methodName )     +     \"  ]    with   cache   operations    [  \"  )     +    ops )     +     \"  ]  \"  )  )  ;", "}", "this . nameMap . put ( methodName ,    ops )  ;", "}", "METHOD_END"], "methodName": ["addCacheMethod"], "fileName": "org.springframework.cache.interceptor.NameMatchCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "return   PatternMatchUtils . simpleMatch ( mappedName ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["isMatch"], "fileName": "org.springframework.cache.interceptor.NameMatchCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "nameMap . forEach ( this :  : addCacheMethod )  ;", "}", "METHOD_END"], "methodName": ["setNameMap"], "fileName": "org.springframework.cache.interceptor.NameMatchCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "this . cacheNames    =    cacheNames ;", "}", "METHOD_END"], "methodName": ["setCacheNames"], "fileName": "org.springframework.cache.interceptor.NamedCacheResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( params . length )     =  =     0  )     {", "return    . EMPTY ;", "}", "if    (  ( params . length )     =  =     1  )     {", "Object   param    =    params [  0  ]  ;", "if    (  ( param    !  =    null )     &  &     (  !  ( param . getClass (  )  . isArray (  )  )  )  )     {", "return   param ;", "}", "}", "return   new    ( params )  ;", "}", "METHOD_END"], "methodName": ["generateKey"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGenerator"}, {"methodBody": ["METHOD_START", "{", "Object   k 1     =    generateKey ( new   Object [  ]  {    new   String [  ]  {     \" a \"  ,     \" b \"     }  ,     \" c \"     }  )  ;", "Object   k 2     =    generateKey ( new   Object [  ]  {    new   String [  ]  {     \" a \"  ,     \" b \"     }  ,     \" c \"     }  )  ;", "Object   k 3     =    generateKey ( new   Object [  ]  {    new   String [  ]  {     \" b \"  ,     \" a \"     }  ,     \" c \"     }  )  ;", "assertThat ( k 1  . hashCode (  )  ,    equalTo ( k 2  . hashCode (  )  )  )  ;", "assertThat ( k 1  . hashCode (  )  ,    not ( equalTo ( k 3  . hashCode (  )  )  )  )  ;", "assertThat ( k 1  ,    equalTo ( k 2  )  )  ;", "assertThat ( k 1  ,    not ( equalTo ( k 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["arrayWithExtraParameter"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . generator . generate ( null ,    null ,    arguments )  ;", "}", "METHOD_END"], "methodName": ["generateKey"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "Object   k 1     =    generateKey ( new   Object [  ]  {     \" a \"  ,    null ,     \" b \"  ,    null    }  )  ;", "Object   k 2     =    generateKey ( new   Object [  ]  {     \" a \"  ,    null ,     \" b \"  ,    null    }  )  ;", "Object   k 3     =    generateKey ( new   Object [  ]  {     \" a \"  ,    null ,     \" b \"     }  )  ;", "assertThat ( k 1  . hashCode (  )  ,    equalTo ( k 2  . hashCode (  )  )  )  ;", "assertThat ( k 1  . hashCode (  )  ,    not ( equalTo ( k 3  . hashCode (  )  )  )  )  ;", "assertThat ( k 1  ,    equalTo ( k 2  )  )  ;", "assertThat ( k 1  ,    not ( equalTo ( k 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleNullValues"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "Object   k 1     =    generateKey ( new   Object [  ]  {     \" a \"  ,     1  ,     \" b \"     }  )  ;", "Object   k 2     =    generateKey ( new   Object [  ]  {     \" a \"  ,     1  ,     \" b \"     }  )  ;", "Object   k 3     =    generateKey ( new   Object [  ]  {     \" b \"  ,     1  ,     \" a \"     }  )  ;", "assertThat ( k 1  . hashCode (  )  ,    equalTo ( k 2  . hashCode (  )  )  )  ;", "assertThat ( k 1  . hashCode (  )  ,    not ( equalTo ( k 3  . hashCode (  )  )  )  )  ;", "assertThat ( k 1  ,    equalTo ( k 2  )  )  ;", "assertThat ( k 1  ,    not ( equalTo ( k 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleValues"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "Object   k 1     =    generateKey ( new   Object [  ]  {        }  )  ;", "Object   k 2     =    generateKey ( new   Object [  ]  {        }  )  ;", "Object   k 3     =    generateKey ( new   Object [  ]  {     \" different \"     }  )  ;", "assertThat ( k 1  . hashCode (  )  ,    equalTo ( k 2  . hashCode (  )  )  )  ;", "assertThat ( k 1  . hashCode (  )  ,    not ( equalTo ( k 3  . hashCode (  )  )  )  )  ;", "assertThat ( k 1  ,    equalTo ( k 2  )  )  ;", "assertThat ( k 1  ,    not ( equalTo ( k 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["noValues"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "Object   k 1     =    generateKey ( new   Object [  ]  {    new   String [  ]  {     \" a \"  ,     \" b \"     }     }  )  ;", "Object   k 2     =    generateKey ( new   Object [  ]  {    new   String [  ]  {     \" a \"  ,     \" b \"     }     }  )  ;", "Object   k 3     =    generateKey ( new   Object [  ]  {    new   String [  ]  {     \" b \"  ,     \" a \"     }     }  )  ;", "assertThat ( k 1  . hashCode (  )  ,    equalTo ( k 2  . hashCode (  )  )  )  ;", "assertThat ( k 1  . hashCode (  )  ,    not ( equalTo ( k 3  . hashCode (  )  )  )  )  ;", "assertThat ( k 1  ,    equalTo ( k 2  )  )  ;", "assertThat ( k 1  ,    not ( equalTo ( k 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["plainArray"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "Object   k 1     =    generateKey ( new   Object [  ]  {    null    }  )  ;", "Object   k 2     =    generateKey ( new   Object [  ]  {    null    }  )  ;", "Object   k 3     =    generateKey ( new   Object [  ]  {     \" different \"     }  )  ;", "assertThat ( k 1  . hashCode (  )  ,    equalTo ( k 2  . hashCode (  )  )  )  ;", "assertThat ( k 1  . hashCode (  )  ,    not ( equalTo ( k 3  . hashCode (  )  )  )  )  ;", "assertThat ( k 1  ,    equalTo ( k 2  )  )  ;", "assertThat ( k 1  ,    not ( equalTo ( k 3  )  )  )  ;", "assertThat ( k 1  ,    instanceOf (  . class )  )  ;", "}", "METHOD_END"], "methodName": ["singleNullValue"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "Object   k 1     =    generateKey ( new   Object [  ]  {     \" a \"     }  )  ;", "Object   k 2     =    generateKey ( new   Object [  ]  {     \" a \"     }  )  ;", "Object   k 3     =    generateKey ( new   Object [  ]  {     \" different \"     }  )  ;", "assertThat ( k 1  . hashCode (  )  ,    equalTo ( k 2  . hashCode (  )  )  )  ;", "assertThat ( k 1  . hashCode (  )  ,    not ( equalTo ( k 3  . hashCode (  )  )  )  )  ;", "assertThat ( k 1  ,    equalTo ( k 2  )  )  ;", "assertThat ( k 1  ,    not ( equalTo ( k 3  )  )  )  ;", "assertThat ( k 1  ,    equalTo (  \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["singleValue"], "fileName": "org.springframework.cache.interceptor.SimpleKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.cache.interceptor.VariableNotAvailableException"}, {"methodBody": ["METHOD_START", "{", "String   name    =    cache . getName (  )  ;", "synchronized ( this . cacheMap )     {", "if    (  ( this . cacheMap . put ( name ,    decorateCache ( cache )  )  )     =  =    null )     {", "updateCacheNames ( name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addCache"], "fileName": "org.springframework.cache.support.AbstractCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   cache ;", "}", "METHOD_END"], "methodName": ["decorateCache"], "fileName": "org.springframework.cache.support.AbstractCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getMissingCache"], "fileName": "org.springframework.cache.support.AbstractCacheManager"}, {"methodBody": ["METHOD_START", "{", "Collection <  ?    extends   Cache > s    =    loadCaches (  )  ;", "synchronized ( thisMap )     {", "thisNames    =    Collections . emptySet (  )  ;", "thisMap . clear (  )  ;", "Set < String > Names    =    new   LinkedHashSet <  > s . size (  )  )  ;", "for    ( Cache    : s )     {", "String   name    =  . getName (  )  ;", "thisMap . put ( name ,    decorateCache )  )  ;", "Names . add ( name )  ;", "}", "thisNames    =    Collections . unmodifiableSetNames )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeCaches"], "fileName": "org.springframework.cache.support.AbstractCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheMap . get ( name )  ;", "}", "METHOD_END"], "methodName": ["lookupCache"], "fileName": "org.springframework.cache.support.AbstractCacheManager"}, {"methodBody": ["METHOD_START", "{", "Set < String >    cacheNames    =    new   LinkedHashSet <  >  (  (  ( this . cacheNames . size (  )  )     +     1  )  )  ;", "cacheNames . addAll ( this . cacheNames )  ;", "cacheNames . add ( name )  ;", "this . cacheNames    =    Collections . unmodifiableSet ( cacheNames )  ;", "}", "METHOD_END"], "methodName": ["updateCacheNames"], "fileName": "org.springframework.cache.support.AbstractCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . allowNullValues )     &  &     ( storeValue    =  =     ( NullValue . INSTANCE )  )  )     {", "return   null ;", "}", "return   storeValue ;", "}", "METHOD_END"], "methodName": ["fromStoreValue"], "fileName": "org.springframework.cache.support.AbstractValueAdaptingCache"}, {"methodBody": ["METHOD_START", "{", "return   this . allowNullValues ;", "}", "METHOD_END"], "methodName": ["isAllowNullValues"], "fileName": "org.springframework.cache.support.AbstractValueAdaptingCache"}, {"methodBody": ["METHOD_START", "{", "if    ( userValue    =  =    null )     {", "if    ( this . allowNullValues )     {", "return   NullValue . INSTANCE ;", "}", "throw   new   IllegalArgumentException (  (  (  \" Cache    '  \"     +     ( getName (  )  )  )     +     \"  '    is   configured   to   not   allow   null   values   but   null   was   provided \"  )  )  ;", "}", "return   userValue ;", "}", "METHOD_END"], "methodName": ["toStoreValue"], "fileName": "org.springframework.cache.support.AbstractValueAdaptingCache"}, {"methodBody": ["METHOD_START", "{", "return   storeValue    !  =    null    ?    new   SimpleValueWrapper ( fromStoreValue ( storeValue )  )     :    null ;", "}", "METHOD_END"], "methodName": ["toValueWrapper"], "fileName": "org.springframework.cache.support.AbstractValueAdaptingCache"}, {"methodBody": ["METHOD_START", "{", "this . cacheManagers . addAll ( cacheManagers )  ;", "}", "METHOD_END"], "methodName": ["setCacheManagers"], "fileName": "org.springframework.cache.support.CompositeCacheManager"}, {"methodBody": ["METHOD_START", "{", "this . fallbackToNoOpCache    =    fallbackToNoOpCache ;", "}", "METHOD_END"], "methodName": ["setFallbackToNoOpCache"], "fileName": "org.springframework.cache.support.CompositeCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   NullValue . INSTANCE ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.springframework.cache.support.NullValue"}, {"methodBody": ["METHOD_START", "{", "this . caches    =    caches ;", "}", "METHOD_END"], "methodName": ["setCaches"], "fileName": "org.springframework.cache.support.SimpleCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   ac ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.context.ACATester"}, {"methodBody": ["METHOD_START", "{", "BeanThatListens   b    =     (  ( BeanThatListens )     ( applicationContext . getBean (  \" beanThatListens \"  )  )  )  ;", "b . zero (  )  ;", "assertTrue (  \"  0    events   before   publication \"  ,     (  ( b . getEventCount (  )  )     =  =     0  )  )  ;", "this . applicationContext . publishEvent ( new    . MyEvent ( this )  )  ;", "assertTrue (  (  \"  1    events   after   publication ,    not    \"     +     ( b . getEventCount (  )  )  )  ,     (  ( b . getEventCount (  )  )     =  =     1  )  )  ;", "}", "METHOD_END"], "methodName": ["beanAutomaticallyHearsEvents"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "LifecycleBean   lb    =     (  ( LifecycleBean )     ( applicationContext . getBean (  \" lifecycle \"  )  )  )  ;", "assertTrue (  \" Not   destroyed \"  ,     (  !  ( lb . isDestroyed (  )  )  )  )  ;", "applicationContext . close (  )  ;", "if    (  ( applicationContext . getParent (  )  )     !  =    null )     {", "(  ( Configurable )     ( applicationContext . getParent (  )  )  )  . close (  )  ;", "}", "assertTrue (  \" Destroyed \"  ,    lb . isDestroyed (  )  )  ;", "applicationContext . close (  )  ;", "if    (  ( applicationContext . getParent (  )  )     !  =    null )     {", "(  ( Configurable )     ( applicationContext . getParent (  )  )  )  . close (  )  ;", "}", "assertTrue (  \" Destroyed \"  ,    lb . isDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["closeTriggersDestroy"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ACATester   aca    =     (  ( ACATester )     ( applicationContext . getBean (  \" aca - prototype \"  )  )  )  ;", "assertTrue (  \" has   had   context   set \"  ,     (  ( aca . ge (  )  )     =  =     ( applicationContext )  )  )  ;", "Object   aca 2     =    applicationContext . getBean (  \" aca - prototype \"  )  ;", "assertTrue (  \" NOT   Same   instance \"  ,     ( aca    !  =    aca 2  )  )  ;", "assertTrue (  \" Says   is   prototype \"  ,     (  !  ( applicationContext . isSingleton (  \" aca - prototype \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contextAwarePrototypeWasCalledBack"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ACATester   aca    =     (  ( ACATester )     ( applicationContext . getBean (  \" aca \"  )  )  )  ;", "assertTrue (  \" has   had   context   set \"  ,     (  ( aca . ge (  )  )     =  =     ( applicationContext )  )  )  ;", "Object   aca 2     =    applicationContext . getBean (  \" aca \"  )  ;", "assertTrue (  \" Same   instance \"  ,     ( aca    =  =    aca 2  )  )  ;", "assertTrue (  \" Says   is   singleton \"  ,    applicationContext . isSingleton (  \" aca \"  )  )  ;", "}", "METHOD_END"], "methodName": ["contextAwareSingletonWasCalledBack"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "listener . zeroCounter (  )  ;", "parentListener . zeroCounter (  )  ;", "assertTrue (  \"  0    events   before   publication \"  ,     (  ( listener . getEventCount (  )  )     =  =     0  )  )  ;", "assertTrue (  \"  0    parent   events   before   publication \"  ,     (  ( parentListener . getEventCount (  )  )     =  =     0  )  )  ;", "this . a . publishEvent ( event )  ;", "assertTrue (  (  \"  1    events   after   publication ,    not    \"     +     ( listener . getEventCount (  )  )  )  ,     (  ( listener . getEventCount (  )  )     =  =     1  )  )  ;", "assertTrue (  \"  1    parent   events   after   publication \"  ,     (  ( parentListener . getEventCount (  )  )     =  =     1  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestEvents"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "doTestEvents ( this . listener ,    this . parentListener ,    new   AbstractApplicationContextTests . MyEvent ( this )  )  ;", "}", "METHOD_END"], "methodName": ["events"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationContextTests . MyEvent   event    =    new   AbstractApplicationContextTests . MyEvent ( this )  ;", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( bos )  ;", "oos . writeObject ( event )  ;", "oos . close (  )  ;", "event    =     (  ( AbstractApplicationContextTests . MyEvent )     ( new   ObjectInputStream ( new   ByteArrayInputStream ( bos . toByteArray (  )  )  )  . readObject (  )  )  )  ;", "doTestEvents ( this . listener ,    this . parentListener ,    event )  ;", "}", "METHOD_END"], "methodName": ["eventsWithNoSource"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "return   applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   dad    =     (  ( TestBean )     ( applicationContext . getBean (  \" father \"  )  )  )  ;", "assertTrue (  \" Dad   has   correct   name \"  ,    dad . getName (  )  . equals (  \" Albert \"  )  )  ;", "}", "METHOD_END"], "methodName": ["grandparentDefinitionFound"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" grandparent   is   null \"  ,     (  ( applicationContext . getParent (  )  . getParent (  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["grandparentNull"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   dad    =    applicationContext . getBean (  \" father \"  ,    TestBean . class )  ;", "assertTrue (  \" Dad   has   correct   name \"  ,    dad . getName (  )  . equals (  \" Albert \"  )  )  ;", "}", "METHOD_END"], "methodName": ["grandparentTypedDefinitionFound"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" message 1  \"  ,    applicationContext . getMessage (  \" code 1  \"  ,    null ,    Locale . getDefault (  )  )  )  ;", "assertEquals (  \" message 2  \"  ,    applicationContext . getMessage (  \" code 2  \"  ,    null ,    Locale . getDefault (  )  )  )  ;", "applicationContext . getMessage (  \" code 0  \"  ,    null ,    Locale . getDefault (  )  )  ;", "}", "METHOD_END"], "methodName": ["messageSource"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =     (  ( TestBean )     ( applicationContext . getParent (  )  . getBean (  \" rod \"  )  )  )  ;", "assertTrue (  \" Parent ' s   name   differs \"  ,    rod . getName (  )  . equals (  \" Roderick \"  )  )  ;", "}", "METHOD_END"], "methodName": ["overrideWorked"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" parent   isn ' t   null \"  ,     (  ( applicationContext . getParent (  )  )     !  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["parentNonNull"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "this . applicationContext    =    createContext (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.context.AbstractApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "return   this . timestamp ;", "}", "METHOD_END"], "methodName": ["getTimestamp"], "fileName": "org.springframework.context.ApplicationEvent"}, {"methodBody": ["METHOD_START", "{", "publishEvent (  (  ( Object )     ( event )  )  )  ;", "}", "METHOD_END"], "methodName": ["publishEvent"], "fileName": "org.springframework.context.ApplicationEventPublisher"}, {"methodBody": ["METHOD_START", "{", "return   eventCount ;", "}", "METHOD_END"], "methodName": ["getEventCount"], "fileName": "org.springframework.context.BeanThatListens"}, {"methodBody": ["METHOD_START", "{", "eventCount    =     0  ;", "}", "METHOD_END"], "methodName": ["zero"], "fileName": "org.springframework.context.BeanThatListens"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.springframework.context.MessageSourceResolvable"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultMessage"], "fileName": "org.springframework.context.MessageSourceResolvable"}, {"methodBody": ["METHOD_START", "{", "return   this . payload ;", "}", "METHOD_END"], "methodName": ["getPayload"], "fileName": "org.springframework.context.PayloadApplicationEvent"}, {"methodBody": ["METHOD_START", "{", "return   eventCount ;", "}", "METHOD_END"], "methodName": ["getEventCount"], "fileName": "org.springframework.context.TestListener"}, {"methodBody": ["METHOD_START", "{", "eventCount    =     0  ;", "}", "METHOD_END"], "methodName": ["zeroCounter"], "fileName": "org.springframework.context.TestListener"}, {"methodBody": ["METHOD_START", "{", "boolean   threw    =    false ;", "try    {", "newParser (  )  . parse ( loadAsConfigurationSource (  . X . class )  ,     \" X \"  )  ;", "}    catch    ( BeanDefinitionParsingException   ex )     {", "assertTrue (  (  \" Wrong   message .    Got :     \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . contains (  (  \" Illegal   attempt   by    @ Configuration   class    '  . Z 2  '     \"     +     \" to   import   class    '  . Z '  \"  )  )  )  ;", "threw    =    true ;", "}", "assertTrue ( threw )  ;", "}", "METHOD_END"], "methodName": ["complexCircularImportIsDetected"], "fileName": "org.springframework.context.annotation.AbstractCircularImportDetectionTests"}, {"methodBody": ["METHOD_START", "{", "boolean   threw    =    false ;", "try    {", "newParser (  )  . parse ( loadAsConfigurationSource (  . A . class )  ,     \" A \"  )  ;", "}    catch    ( BeanDefinitionParsingException   ex )     {", "assertTrue (  (  \" Wrong   message .    Got :     \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . contains (  (  \" Illegal   attempt   by    @ Configuration   class    '  . B '     \"     +     \" to   import   class    '  . A '  \"  )  )  )  ;", "threw    =    true ;", "}", "assertTrue ( threw )  ;", "}", "METHOD_END"], "methodName": ["simpleCircularImportIsDetected"], "fileName": "org.springframework.context.annotation.AbstractCircularImportDetectionTests"}, {"methodBody": ["METHOD_START", "{", "return   AdviceModeImportSelector . DEFAULT _ ADVICE _ MODE _ ATTRIBUTE _ NAME ;", "}", "METHOD_END"], "methodName": ["getAdviceModeAttributeName"], "fileName": "org.springframework.context.annotation.AdviceModeImportSelector"}, {"methodBody": ["METHOD_START", "{", "AnnotatedGenericBeanDefinition   abd    =    new   AnnotatedGenericBeanDefinition ( annotatedClass )  ;", "if    ( this . conditionEvaluator . shouldSkip ( abd . getMetadata (  )  )  )     {", "return ;", "}", "abd . setInstanceSupplier ( instanceSupplier )  ;", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( abd )  ;", "abd . setScope ( scopeMetadata . getScopeName (  )  )  ;", "String   beanName    =     ( name    !  =    null )     ?    name    :    this . beanNameGenerator . generateBeanName ( abd ,    this . registry )  ;", "AnnotationConfigUtils . processCommonDefinitionAnnotations ( abd )  ;", "if    ( qualifiers    !  =    null )     {", "for    ( Class <  ?    extends   Annotation >    qualifier    :    qualifiers )     {", "if    (  ( Primary . class )     =  =    qualifier )     {", "abd . setPrimary ( true )  ;", "} else", "if    (  ( Lazy . class )     =  =    qualifier )     {", "abd . setLazyInit ( true )  ;", "} else    {", "abd . addQualifier ( new   beans . factory . support . AutowireCandidateQualifier ( qualifier )  )  ;", "}", "}", "}", "for    ( BeanDefinitionCustomizer   customizer    :    definitionCustomizers )     {", "customizer . customize ( abd )  ;", "}", "BeanDefinitionHolder   definitionHolder    =    new   BeanDefinitionHolder ( abd ,    beanName )  ;", "definitionHolder    =    AnnotationConfigUtils . applyScopedProxyMode ( scopeMetadata ,    definitionHolder ,    this . registry )  ;", "BeanDefinitionReaderUtils . registerBeanDefinition ( definitionHolder ,    this . registry )  ;", "}", "METHOD_END"], "methodName": ["doRegisterBean"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( registry ,     \" BeanDefinitionRegistry   must   not   be   null \"  )  ;", "if    ( registry   instanceof   EnvironmentCapable )     {", "return    (  ( EnvironmentCapable )     ( registry )  )  . getEnvironment (  )  ;", "}", "return   new   StandardEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["getOrCreateEnvironment"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   this . registry ;", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    annotatedClass    :    annotatedClasses )     {", "registerBean ( annotatedClass )  ;", "}", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "doRegisterBean ( annotatedClass ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "doRegisterBean ( annotatedClass ,    null ,    null ,    qualifiers )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "doRegisterBean ( annotatedClass ,    null ,    name ,    qualifiers )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "doRegisterBean ( annotatedClass ,    instanceSupplier ,    name ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "doRegisterBean ( annotatedClass ,    instanceSupplier ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . beanNameGenerator    =     ( beanNameGenerator    !  =    null )     ?    beanNameGenerator    :    new   AnnotationBeanNameGenerator (  )  ;", "}", "METHOD_END"], "methodName": ["setBeanNameGenerator"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . conditionEvaluator    =    new   ConditionEvaluator ( this . registry ,    environment ,    null )  ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . scopeMetadataResolver    =     ( scopeMetadataResolver    !  =    null )     ?    scopeMetadataResolver    :    new   AnnotationScopeMetadataResolver (  )  ;", "}", "METHOD_END"], "methodName": ["setScopeMetadataResolver"], "fileName": "org.springframework.context.annotation.AnnotatedBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "String   beanClassName    =    definition . getBeanClassName (  )  ;", "Assert . state (  ( beanClassName    !  =    null )  ,     \" No   bean   class   name   set \"  )  ;", "String   shortClassName    =    ClassUtils . getShortName ( beanClassName )  ;", "return   Introspector . decapitalize ( shortClassName )  ;", "}", "METHOD_END"], "methodName": ["buildDefaultBeanName"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGenerator"}, {"methodBody": ["METHOD_START", "{", "return   buildDefaultBeanName ( definition )  ;", "}", "METHOD_END"], "methodName": ["buildDefaultBeanName"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGenerator"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   amd    =    annotatedDef . getMetadata (  )  ;", "Set < String >    types    =    amd . getAnnotationTypes (  )  ;", "String   beanName    =    null ;", "for    ( String   type    :    types )     {", "AnnotationAttributes   attributes    =    AnnotationConfigUtils . attributesFor ( amd ,    type )  ;", "if    (  ( attributes    !  =    null )     &  &     ( isStereotypeWithNameValue ( type ,    amd . getMetaAnnotationTypes ( type )  ,    attributes )  )  )     {", "Object   value    =    attributes . get (  \" value \"  )  ;", "if    ( value   instanceof   String )     {", "String   strVal    =     (  ( String )     ( value )  )  ;", "if    ( StringUtils . hasLength ( strVal )  )     {", "if    (  ( beanName    !  =    null )     &  &     (  !  ( strVal . equals ( beanName )  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" Stereotype   annotations   suggest   inconsistent    \"     +     \" component   names :     '  \"  )     +    beanName )     +     \"  '    versus    '  \"  )     +    strVal )     +     \"  '  \"  )  )  ;", "}", "beanName    =    strVal ;", "}", "}", "}", "}", "return   beanName ;", "}", "METHOD_END"], "methodName": ["determineBeanNameFromAnnotation"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGenerator"}, {"methodBody": ["METHOD_START", "{", "boolean   isStereotype    =     (  (  ( annotationType . equals ( AnnotationBeanNameGenerator . COMPONENT _ ANNOTATION _ CLASSNAME )  )     |  |     ( metaAnnotationTypes . contains ( AnnotationBeanNameGenerator . COMPONENT _ ANNOTATION _ CLASSNAME )  )  )     |  |     ( annotationType . equals (  \" ManagedBean \"  )  )  )     |  |     ( annotationType . equals (  \" Named \"  )  )  ;", "return    ( isStereotype    &  &     ( attributes    !  =    null )  )     &  &     ( attributes . containsKey (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isStereotypeWithNameValue"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGenerator"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . ComposedControllerAnnotationWithBlankName . class )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( bd ,    registry )  ;", "String   expectedGeneratedBeanName    =    this . beanNameGenerator . buildDefaultBeanName ( bd )  ;", "assertEquals ( expectedGeneratedBeanName ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameFromComposedControllerAnnotationWithBlankName"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . ComposedControllerAnnotationWithStringValue . class )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( bd ,    registry )  ;", "assertEquals (  \" restController \"  ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameFromComposedControllerAnnotationWithStringValue"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . ComposedControllerAnnotationWithoutName . class )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( bd ,    registry )  ;", "String   expectedGeneratedBeanName    =    this . beanNameGenerator . buildDefaultBeanName ( bd )  ;", "assertEquals ( expectedGeneratedBeanName ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameFromComposedControllerAnnotationWithoutName"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . ComponentFromNonStringMeta . class )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( bd ,    registry )  ;", "assertEquals (  \" annotationBeanNameGeneratorTests . ComponentFromNonStringMeta \"  ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameFromMetaComponentWithNonStringValue"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . ComponentFromStringMeta . class )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( bd ,    registry )  ;", "assertEquals (  \" henry \"  ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameFromMetaComponentWithStringValue"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . AnonymousComponent . class )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( bd ,    registry )  ;", "assertNotNull (  \" The   generated   beanName   must    * never *    be   null .  \"  ,    beanName )  ;", "assertTrue (  \" The   generated   beanName   must    * never *    be   blank .  \"  ,    StringUtils . hasText ( beanName )  )  ;", "String   expectedGeneratedBeanName    =    this . beanNameGenerator . buildDefaultBeanName ( bd )  ;", "assertEquals ( expectedGeneratedBeanName ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameWithAnonymousComponentYieldsGeneratedBeanName"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition ( DefaultNamedComponent . class )  ;", "String   beanName    =    this . b . generateBeanName ( bd ,    registry )  ;", "assertNotNull (  \" The   generated   beanName   must    * never *    be   null .  \"  ,    beanName )  ;", "assertTrue (  \" The   generated   beanName   must    * never *    be   blank .  \"  ,    StringUtils . hasText ( beanName )  )  ;", "assertEquals (  \" thoreau \"  ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameWithDefaultNamedComponent"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . ComponentWithName . class )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( bd ,    registry )  ;", "assertNotNull (  \" The   generated   beanName   must    * never *    be   null .  \"  ,    beanName )  ;", "assertTrue (  \" The   generated   beanName   must    * never *    be   blank .  \"  ,    StringUtils . hasText ( beanName )  )  ;", "assertEquals (  \" walden \"  ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameWithNamedComponent"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . ComponentWithBlankName . class )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( bd ,    registry )  ;", "assertNotNull (  \" The   generated   beanName   must    * never *    be   null .  \"  ,    beanName )  ;", "assertTrue (  \" The   generated   beanName   must    * never *    be   blank .  \"  ,    StringUtils . hasText ( beanName )  )  ;", "String   expectedGeneratedBeanName    =    this . beanNameGenerator . buildDefaultBeanName ( bd )  ;", "assertEquals ( expectedGeneratedBeanName ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["generateBeanNameWithNamedComponentWhereTheNameIsBlank"], "fileName": "org.springframework.context.annotation.AnnotationBeanNameGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( annotatedClasses ,     \" At   least   one   annotated   class   must   be   specified \"  )  ;", "this . reader . register ( annotatedClasses )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "registerBean ( null ,    annotatedClass ,    constructorArguments )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . reader . doRegisterBean ( annotatedClass ,    null ,    beanName ,    null ,     (    bd )     -  >     {", "for    ( Object   arg    :    constructorArguments )     {", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( arg )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( basePackages ,     \" At   least   one   base   package   must   be   specified \"  )  ;", "this . scanner . scan ( basePackages )  ;", "}", "METHOD_END"], "methodName": ["scan"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . reader . setBeanNameGenerator ( beanNameGenerator )  ;", "this . scanner . setBeanNameGenerator ( beanNameGenerator )  ;", "getBeanFactory (  )  . registerSingleton ( Utils . CONFIGURATION _ BEAN _ NAME _ GENERATOR ,    beanNameGenerator )  ;", "}", "METHOD_END"], "methodName": ["setBeanNameGenerator"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . reader . setScopeMetadataResolver ( scopeMetadataResolver )  ;", "this . scer . setScopeMetadataResolver ( scopeMetadataResolver )  ;", "}", "METHOD_END"], "methodName": ["setScopeMetadataResolver"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AnnotationConfigApplicationContextTests . AutowiredConfig . class )  ;", "assertThat ( context . getBean ( TestBean . class )  . name ,    equalTo (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiringIsEnabledByDefault"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AnnotationConfigApplicationContextTests . Config . class )  ;", "AnnotationConfigApplicationContextTests . Config   configObject    =     (  ( AnnotationConfigApplicationContextTests . Config )     ( context . getBean (  \" annotationConfigApplicationContextTests . Config \"  )  )  )  ;", "assertNotNull ( configObject )  ;", "}", "METHOD_END"], "methodName": ["defaultConfigClassBeanNameIsGeneratedProperly"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AnnotationConfigApplicationContextTests . ConfigWithCustomName . class )  ;", "AnnotationConfigApplicationContextTests . ConfigWithCustomName   configObject    =     (  ( AnnotationConfigApplicationContextTests . ConfigWithCustomName )     ( context . getBean (  \" customConfigBeanName \"  )  )  )  ;", "assertNotNull ( configObject )  ;", "}", "METHOD_END"], "methodName": ["explicitConfigClassBeanNameIsRespected"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AnnotationConfigApplicationContextTests . Config . class )  ;", "TestBean   testBean    =    context . getBean ( TestBean . class )  ;", "assertNotNull ( testBean )  ;", "assertThat ( testBean . name ,    equalTo (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getBeanByType"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AnnotationConfigApplicationContextTests . TwoTestBeanConfig . class )  ;", "try    {", "context . getBean ( TestBean . class )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "assertThat ( ex . getMessage (  )  ,    allOf ( containsString (  (  (  \" No   qualifying   bean   of   type    '  \"     +     ( TestBean . class . getName (  )  )  )     +     \"  '  \"  )  )  ,    containsString (  \" tb 1  \"  )  ,    containsString (  \" tb 2  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getBeanByTypeAmbiguityRaisesException"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AnnotationConfigApplicationContextTests . Config . class )  ;", "Class <  ?  >    targetType    =    Pattern . class ;", "try    {", "context . getBean ( targetType )  ;", "fail (  \" Should   have   thrown   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "assertThat ( ex . getMessage (  )  ,    containsString ( String . format (  \" No   qualifying   bean   of   type    '  % s '  \"  ,    targetType . getName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getBeanByTypeRaisesNoSuchBeanDefinitionException"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . Config . class ,     . NameConfig . class ,     . UntypedFactoryBean . class )  ;", "context . refresh (  )  ;", "context . getBean (  \" testBean \"  )  ;", "context . getBean (  \" name \"  )  ;", "Map < String ,    Object >    beans    =    context . getBeansWithAnnotation ( Configuration . class )  ;", "assertEquals (  2  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBeansWithAnnotation"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", ". BeanC   c    =    new    . BeanC (  )  ;", "context . registerBean (  . BeanA . class ,    c )  ;", "context . registerBean (  . BeanB . class )  ;", "context . refresh (  )  ;", "assertSame ( context . getBean (  . BeanB . class )  ,    context . getBean (  . BeanA . class )  . b )  ;", "assertSame ( c ,    context . getBean (  . BeanA . class )  . c )  ;", "assertSame ( context ,    context . getBean (  . BeanB . class )  . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualBeanWithMixedConstructorArguments"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", ". BeanB   b    =    new    . BeanB (  )  ;", ". BeanC   c    =    new    . BeanC (  )  ;", "context . registerBean (  . BeanA . class ,    b ,    c )  ;", "context . refresh (  )  ;", "assertSame ( b ,    context . getBean (  . BeanA . class )  . b )  ;", "assertSame ( c ,    context . getBean (  . BeanA . class )  . c )  ;", "assertNull ( b . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualBeanWithSpecifiedConstructorArguments"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . registerBean (  . BeanA . class ,     (  )     -  >    new    . BeanA ( context . getBean (  . BeanB . class )  ,    context . getBean (  . BeanC . class )  )  )  ;", "context . registerBean (  . BeanB . class ,     . BeanB :  : new )  ;", "context . registerBean (  . BeanC . class ,     . BeanC :  : new )  ;", "context . refresh (  )  ;", "assertTrue ( context . getBeanFactory (  )  . containsSingleton (  \" annotationConfigApplicationContextTests . BeanA \"  )  )  ;", "assertSame ( context . getBean (  . BeanB . class )  ,    context . getBean (  . BeanA . class )  . b )  ;", "assertSame ( context . getBean (  . BeanC . class )  ,    context . getBean (  . BeanA . class )  . c )  ;", "assertSame ( context ,    context . getBean (  . BeanB . class )  . applicationContext )  ;", "assertArrayEquals ( new   String [  ]  {     \" annotationConfigApplicationContextTests . BeanA \"     }  ,    context . getDefaultListableBeanFactory (  )  . getDependentBeans (  \" annotationConfigApplicationContextTests . BeanB \"  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" annotationConfigApplicationContextTests . BeanA \"     }  ,    context . getDefaultListableBeanFactory (  )  . getDependentBeans (  \" annotationConfigApplicationContextTests . BeanC \"  )  )  ;", "}", "METHOD_END"], "methodName": ["individualBeanWithSupplier"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . registerBean (  . BeanA . class ,     (  )     -  >    new   BeanA ( context . getBean (  . class )  ,    context . getBean (  . class )  )  ,     (    bd )     -  >    bd . setLazyInit ( true )  )  ;", "context . registerBean (  . BeanB . class ,     . BeanB :  : new )  ;", "context . registerBean (  . BeanC . class ,     . BeanC :  : new )  ;", "context . refresh (  )  ;", "assertFalse ( context . getBeanFactory (  )  . containsSingleton (  \" annotationConfigApplicationContextTests . BeanA \"  )  )  ;", "assertSame ( context . getBean (  . BeanB . class )  ,    context . getBean (  . BeanA . class )  . b )  ;", "assertSame ( context . getBean (  . BeanC . class )  ,    context . getBean (  . BeanA . class )  . c )  ;", "assertSame ( context ,    context . getBean (  . BeanB . class )  . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualBeanWithSupplierAndCustomizer"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . BeanA . class ,     . BeanB . class ,     . BeanC . class )  ;", "context . refresh (  )  ;", "assertSame ( context . getBean (  . BeanB . class )  ,    context . getBean (  . BeanA . class )  . b )  ;", "assertSame ( context . getBean (  . BeanC . class )  ,    context . getBean (  . BeanA . class )  . c )  ;", "assertSame ( context ,    context . getBean (  . BeanB . class )  . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualBeans"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", ". BeanC   c    =    new    . BeanC (  )  ;", "context . registerBean (  \" a \"  ,     . BeanA . class ,    c )  ;", "context . registerBean (  \" b \"  ,     . BeanB . class )  ;", "context . refresh (  )  ;", "assertSame ( context . getBean (  \" b \"  ,     . BeanB . class )  ,    context . getBean (  \" a \"  ,     . BeanA . class )  . b )  ;", "assertSame ( c ,    context . getBean (  \" a \"  ,     . BeanA . class )  . c )  ;", "assertSame ( context ,    context . getBean (  \" b \"  ,     . BeanB . class )  . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualNamedBeanWithMixedConstructorArguments"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", ". BeanB   b    =    new    . BeanB (  )  ;", ". BeanC   c    =    new    . BeanC (  )  ;", "context . registerBean (  \" a \"  ,     . BeanA . class ,    b ,    c )  ;", "context . refresh (  )  ;", "assertSame ( b ,    context . getBean (  \" a \"  ,     . BeanA . class )  . b )  ;", "assertSame ( c ,    context . getBean (  \" a \"  ,     . BeanA . class )  . c )  ;", "assertNull ( b . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualNamedBeanWithSpecifiedConstructorArguments"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . registerBean (  \" a \"  ,     . BeanA . class ,     (  )     -  >    new    . BeanA ( context . getBean (  . BeanB . class )  ,    context . getBean (  . BeanC . class )  )  )  ;", "context . registerBean (  \" b \"  ,     . BeanB . class ,     . BeanB :  : new )  ;", "context . registerBean (  \" c \"  ,     . BeanC . class ,     . BeanC :  : new )  ;", "context . refresh (  )  ;", "assertTrue ( context . getBeanFactory (  )  . containsSingleton (  \" a \"  )  )  ;", "assertSame ( context . getBean (  \" b \"  ,     . BeanB . class )  ,    context . getBean (  . BeanA . class )  . b )  ;", "assertSame ( context . getBean (  \" c \"  )  ,    context . getBean (  \" a \"  ,     . BeanA . class )  . c )  ;", "assertSame ( context ,    context . getBean (  \" b \"  ,     . BeanB . class )  . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualNamedBeanWithSupplier"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . registerBean (  \" a \"  ,     . BeanA . class ,     (  )     -  >    new    . BeanA ( context . getBean (  . BeanB . class )  ,    context . getBean (  . BeanC . class )  )  ,     (    bd )     -  >    bd . setLazyInit ( true )  )  ;", "context . registerBean (  \" b \"  ,     . BeanB . class ,     . BeanB :  : new )  ;", "context . registerBean (  \" c \"  ,     . BeanC . class ,     . BeanC :  : new )  ;", "context . refresh (  )  ;", "assertFalse ( context . getBeanFactory (  )  . containsSingleton (  \" a \"  )  )  ;", "assertSame ( context . getBean (  \" b \"  ,     . BeanB . class )  ,    context . getBean (  . BeanA . class )  . b )  ;", "assertSame ( context . getBean (  \" c \"  )  ,    context . getBean (  \" a \"  ,     . BeanA . class )  . c )  ;", "assertSame ( context ,    context . getBean (  \" b \"  ,     . BeanB . class )  . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualNamedBeanWithSupplierAndCustomizer"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . registerBean (  \" a \"  ,     . BeanA . class )  ;", "context . registerBean (  \" b \"  ,     . BeanB . class )  ;", "context . registerBean (  \" c \"  ,     . BeanC . class )  ;", "context . refresh (  )  ;", "assertSame ( context . getBean (  \" b \"  )  ,    context . getBean (  \" a \"  ,     . BeanA . class )  . b )  ;", "assertSame ( context . getBean (  \" c \"  )  ,    context . getBean (  \" a \"  ,     . BeanA . class )  . c )  ;", "assertSame ( context ,    context . getBean (  \" b \"  ,     . BeanB . class )  . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["individualNamedBeans"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AnnotationConfigApplicationContextTests . Config . class )  ;", "context . getBean (  (  ( Class <  ?  >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullGetBeanParameterIsDisallowed"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . AutowiredConfig . class )  ;", "context . getBeanFactory (  )  . addBeanPostProcessor ( new   BeanPostProcessor (  )     {", "@ Override", "public   Object   postProcessBeforeInitialization ( Object   bean ,    String   beanName )     {", "return   bean   instanceof   TestBean    ?    null    :    bean ;", "}", "@ Override", "public   Object   postProcessAfterInitialization ( Object   bean ,    String   beanName )     {", "return   bean ;", "}", "}  )  ;", "context . getBeanFactory (  )  . addBeanPostProcessor ( new   BeanPostProcessor (  )     {", "@ Override", "public   Object   postProcessBeforeInitialization ( Object   bean ,    String   beanName )     {", "bean . getClass (  )  . getName (  )  ;", "return   bean ;", "}", "@ Override", "public   Object   postProcessAfterInitialization ( Object   bean ,    String   beanName )     {", "bean . getClass (  )  . getName (  )  ;", "return   bean ;", "}", "}  )  ;", "context . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["nullReturningBeanPostProcessor"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . Config . class ,     . NameConfig . class )  ;", "context . refresh (  )  ;", "context . getBean (  \" testBean \"  )  ;", "context . getBean (  \" name \"  )  ;", "Map < String ,    Object >    beans    =    context . getBeansWithAnnotation ( Configuration . class )  ;", "assertEquals (  2  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerAndRefresh"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . scan (  \"  6  \"  )  ;", "context . refresh (  )  ;", "context . getBean ( uncapitalize ( ConfigForScanning . class . getSimpleName (  )  )  )  ;", "context . getBean (  \" testBean \"  )  ;", "context . getBean ( uncapitalize ( ComponentForScanning . class . getSimpleName (  )  )  )  ;", "context . getBean ( uncapitalize ( Jsr 3  3  0 NamedForScanning . class . getSimpleName (  )  )  )  ;", "Map < String ,    Object >    beans    =    context . getBeansWithAnnotation ( Configuration . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["scanAndRefresh"], "fileName": "org.springframework.context.annotation.AnnotationConfigApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    !  =    null )     {", "result . add ( Attributes . fromMap ( attributes )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addAttributesIfNotNull"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "ScopedProxyMode   scopedProxyMode    =    metadata . getScopedProxyMode (  )  ;", "if    ( scopedProxyMode . equals ( ScopedProxyMode . NO )  )     {", "return   defini ;", "}", "boolean   proxyTargetClass    =    scopedProxyMode . equals ( ScopedProxyMode . TARGET _ CLASS )  ;", "return   ScopedProxyCreator . createScopedProxy ( defini ,    registry ,    proxyTargetClass )  ;", "}", "METHOD_END"], "methodName": ["applyScopedProxyMode"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationConfigUtils . attributesFor ( metadata ,    annotationClass . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["attributesFor"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationAttributes . fromMap ( metadata . getAnnotationAttributes ( annotationClassName ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["attributesFor"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationConfigUtils . attributesForRepeatable ( metadata ,    containerClass . getName (  )  ,    annotationClass . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["attributesForRepeatable"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "Set < AnnotationAttributes >    result    =    new   LinkedHashSet <  >  (  )  ;", ". addAttributesIfNotNull ( result ,    metadata . getAnnotationAttributes ( annotationClassName ,    false )  )  ;", "Map < String ,    Object >    container    =    metadata . getAnnotationAttributes ( containerClassName ,    false )  ;", "if    (  ( container    !  =    null )     &  &     ( container . containsKey (  \" value \"  )  )  )     {", "for    ( Map < String ,    Object >    containedAttributes    :     (  ( Map < String ,    Object >  [  ]  )     ( container . get (  \" value \"  )  )  )  )     {", ". addAttributesIfNotNull ( result ,    containedAttributes )  ;", "}", "}", "return   Collections . unmodifiableSet ( result )  ;", "}", "METHOD_END"], "methodName": ["attributesForRepeatable"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigUtils . processCommonDefinitionAnnotations ( abd ,    abd . getMetadata (  )  )  ;", "}", "METHOD_END"], "methodName": ["processCommonDefinitionAnnotations"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   lazy    =    AnnotationConfigUtils . attributesFor ( metadata ,    Lazy . class )  ;", "if    ( lazy    !  =    null )     {", "abd . setLazyInit ( lazy . getBoolean (  \" value \"  )  )  ;", "} else", "if    (  ( abd . getMetadata (  )  )     !  =    metadata )     {", "lazy    =    AnnotationConfigUtils . attributesFor ( abd . getMetadata (  )  ,    Lazy . class )  ;", "if    ( lazy    !  =    null )     {", "abd . setLazyInit ( lazy . getBoolean (  \" value \"  )  )  ;", "}", "}", "if    ( metadata . isAnnotated ( Primary . class . getName (  )  )  )     {", "abd . setPrimary ( true )  ;", "}", "AnnotationAttributes   dependsOn    =    AnnotationConfigUtils . attributesFor ( metadata ,    DependsOn . class )  ;", "if    ( dependsOn    !  =    null )     {", "abd . setDependsOn ( dependsOn . getStringArray (  \" value \"  )  )  ;", "}", "if    ( abd   instanceof   AbstractBeanDefinition )     {", "AbstractBeanDefinition   absBd    =     (  ( AbstractBeanDefinition )     ( abd )  )  ;", "AnnotationAttributes   role    =    AnnotationConfigUtils . attributesFor ( metadata ,    Role . class )  ;", "if    ( role    !  =    null )     {", "absBd . setRole ( role . getNumber (  \" value \"  )  . intValue (  )  )  ;", "}", "AnnotationAttributes   description    =    AnnotationConfigUtils . attributesFor ( metadata ,    Description . class )  ;", "if    ( description    !  =    null )     {", "absBd . setDescription ( description . getString (  \" value \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processCommonDefinitionAnnotations"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( registry ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerAnnotationConfigProcessors"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    AnnotationConfigUtils . unwrapDefaultListableBeanFactory ( registry )  ;", "if    ( beanFactory    !  =    null )     {", "if    (  !  (  ( beanFactory . getDependencyComparator (  )  )    instanceof   AnnotationAwareOrderComparator )  )     {", "beanFactory . setDependencyComparator ( INSTANCE )  ;", "}", "if    (  !  (  ( beanFactory . getAutowireCandidateResolver (  )  )    instanceof   ContextAnnotationAutowireCandidateResolver )  )     {", "beanFactory . setAutowireCandidateResolver ( new   ContextAnnotationAutowireCandidateResolver (  )  )  ;", "}", "}", "Set < BeanDefinitionHolder >    beanDefs    =    new   LinkedHashSet <  >  (  4  )  ;", "if    (  !  ( registry . containsBeanDefinition ( AnnotationConfigUtils . CONFIGURATION _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  )     {", "RootBeanDefinition   def    =    new   RootBeanDefinition ( ConfigurationClassPostProcessor . class )  ;", "def . setSource ( source )  ;", "beanDefs . add ( AnnotationConfigUtils . registerPostProcessor ( registry ,    def ,    AnnotationConfigUtils . CONFIGURATION _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "if    (  !  ( registry . containsBeanDefinition ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  )     {", "RootBeanDefinition   def    =    new   RootBeanDefinition ( AutowiredAnnotationBeanPostProcessor . class )  ;", "def . setSource ( source )  ;", "beanDefs . add ( AnnotationConfigUtils . registerPostProcessor ( registry ,    def ,    AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "if    (  !  ( registry . containsBeanDefinition ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  )     {", "RootBeanDefinition   def    =    new   RootBeanDefinition ( RequiredAnnotationBeanPostProcessor . class )  ;", "def . setSource ( source )  ;", "beanDefs . add ( AnnotationConfigUtils . registerPostProcessor ( registry ,    def ,    AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "if    (  ( AnnotationConfigUtils . jsr 2  5  0 Present )     &  &     (  !  ( registry . containsBeanDefinition ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  )  )     {", "RootBeanDefinition   def    =    new   RootBeanDefinition ( CommonAnnotationBeanPostProcessor . class )  ;", "def . setSource ( source )  ;", "beanDefs . add ( AnnotationConfigUtils . registerPostProcessor ( registry ,    def ,    AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "if    (  ( AnnotationConfigUtils . jpaPresent )     &  &     (  !  ( registry . containsBeanDefinition ( AnnotationConfigUtils . PERSISTENCE _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  )  )     {", "RootBeanDefinition   def    =    new   RootBeanDefinition (  )  ;", "try    {", "def . setBeanClass ( ClassUtils . forName ( AnnotationConfigUtils . PERSISTENCE _ ANNOTATION _ PROCESSOR _ CLASS _ NAME ,    AnnotationConfigUtils . class . getClassLoader (  )  )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   IllegalStateException (  (  \" Cannot   load   optional   framework   class :     \"     +     ( AnnotationConfigUtils . PERSISTENCE _ ANNOTATION _ PROCESSOR _ CLASS _ NAME )  )  ,    ex )  ;", "}", "def . setSource ( source )  ;", "beanDefs . add ( AnnotationConfigUtils . registerPostProcessor ( registry ,    def ,    AnnotationConfigUtils . PERSISTENCE _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "if    (  !  ( registry . containsBeanDefinition ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  )     {", "RootBeanDefinition   def    =    new   RootBeanDefinition ( EventListenerMethodProcessor . class )  ;", "def . setSource ( source )  ;", "beanDefs . add ( AnnotationConfigUtils . registerPostProcessor ( registry ,    def ,    AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "if    (  !  ( registry . containsBeanDefinition ( AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  )     {", "RootBeanDefinition   def    =    new   RootBeanDefinition ( DefaultEventListenerFactory . class )  ;", "def . setSource ( source )  ;", "beanDefs . add ( AnnotationConfigUtils . registerPostProcessor ( registry ,    def ,    AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "}", "return   beanDefs ;", "}", "METHOD_END"], "methodName": ["registerAnnotationConfigProcessors"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "definition . setRole ( ROLE _ INFRASTRUCTURE )  ;", "registry . registerBeanDefinition ( beanName ,    definition )  ;", "return   new   beans . factory . config . BeanDefinitionHolder ( definition ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["registerPostProcessor"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( registry   instanceof   DefaultListableBeanFactory )     {", "return    (  ( DefaultListableBeanFactory )     ( registry )  )  ;", "} else", "if    ( registry   instanceof   support . GenericApplicationContext )     {", "return    (  ( support . GenericApplicationContext )     ( registry )  )  . getDefaultListableBeanFactory (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["unwrapDefaultListableBeanFactory"], "fileName": "org.springframework.context.annotation.AnnotationConfigUtils"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "}", "METHOD_END"], "methodName": ["commonAssumptions"], "fileName": "org.springframework.context.annotation.AnnotationProcessorPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ctx )  ;", "ctx . refresh (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . AutowiredAnnotatedTestBean . class )  ;", "rbd . setScope ( SCOPE _ PROTOTYPE )  ;", "ctx . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "ctx . registerBeanDefinition (  \" spouse \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "TestBean   spouse    =     (  ( TestBean )     ( ctx . getBean (  \" spouse \"  )  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( ctx . getBean (  \" test \"  )  )  )  ;", "assertSame ( spouse ,    tb . getSpouse (  )  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     4  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithAutowiredPropertiesIsFastEnough"], "fileName": "org.springframework.context.annotation.AnnotationProcessorPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ctx )  ;", "ctx . refresh (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . AutowiredAnnotatedTestBean . class )  ;", "rbd . setScope ( SCOPE _ PROTOTYPE )  ;", "rbd . getPropertyValues (  )  . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \" spouse \"  )  )  ;", "ctx . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "ctx . registerBeanDefinition (  \" spouse \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "TestBean   spouse    =     (  ( TestBean )     ( ctx . getBean (  \" spouse \"  )  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( ctx . getBean (  \" test \"  )  )  )  ;", "assertSame ( spouse ,    tb . getSpouse (  )  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     6  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithOverriddenAutowiredPropertiesIsFastEnough"], "fileName": "org.springframework.context.annotation.AnnotationProcessorPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ctx )  ;", "ctx . refresh (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . ResourceAnnotatedTestBean . class )  ;", "rbd . setScope ( SCOPE _ PROTOTYPE )  ;", "rbd . getPropertyValues (  )  . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \" spouse \"  )  )  ;", "ctx . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "ctx . registerBeanDefinition (  \" spouse \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "TestBean   spouse    =     (  ( TestBean )     ( ctx . getBean (  \" spouse \"  )  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( ctx . getBean (  \" test \"  )  )  )  ;", "assertSame ( spouse ,    tb . getSpouse (  )  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     4  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithOverriddenResourcePropertiesIsFastEnough"], "fileName": "org.springframework.context.annotation.AnnotationProcessorPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ctx )  ;", "ctx . refresh (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . ResourceAnnotatedTestBean . class )  ;", "rbd . setScope ( SCOPE _ PROTOTYPE )  ;", "ctx . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "ctx . registerBeanDefinition (  \" spouse \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "TestBean   spouse    =     (  ( TestBean )     ( ctx . getBean (  \" spouse \"  )  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( ctx . getBean (  \" test \"  )  )  )  ;", "assertSame ( spouse ,    tb . getSpouse (  )  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     4  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithResourcePropertiesIsFastEnough"], "fileName": "org.springframework.context.annotation.AnnotationProcessorPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( scopeAnnotationType ,     \"  ' scopeAnnotationType '    must   not   be   null \"  )  ;", "this . scopeAnnotationType    =    scopeAnnotationType ;", "}", "METHOD_END"], "methodName": ["setScopeAnnotationType"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolver"}, {"methodBody": ["METHOD_START", "{", "new   AnnotationScopeMetadataResolver ( null )  ;", "}", "METHOD_END"], "methodName": ["ctorWithNullScopedProxyMode"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition ( AnnotationScopeMetadataResolverTests . AnnotatedWithCustomRequestScope . class )  ;", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( bd )  ;", "assertNotNull (  \" resolveScopeMetadata (  .  .  )    must    * never *    return   null .  \"  ,    scopeMetadata )  ;", "assertEquals (  \" request \"  ,    scopeMetadata . getScopeName (  )  )  ;", "assertEquals ( ScopedProxyMode . NO ,    scopeMetadata . getScopedProxyMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["customRequestScope"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   readerFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   reader    =    readerFactory . getMetadataReader (  . AnnotatedWithCustomRequestScope . class . getName (  )  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition ( reader . getAnnotationMetadata (  )  )  ;", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( bd )  ;", "assertNotNull (  \" resolveScopeMetadata (  .  .  )    must    * never *    return   null .  \"  ,    scopeMetadata )  ;", "assertEquals (  \" request \"  ,    scopeMetadata . getScopeName (  )  )  ;", "assertEquals ( ScopedProxyMode . NO ,    scopeMetadata . getScopedProxyMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["customRequestScopeViaAsm"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition ( AnnotationScopeMetadataResolverTests . AnnotatedWithCustomRequestScopeWithAttributeOverride . class )  ;", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( bd )  ;", "assertNotNull (  \" resolveScopeMetadata (  .  .  )    must    * never *    return   null .  \"  ,    scopeMetadata )  ;", "assertEquals (  \" request \"  ,    scopeMetadata . getScopeName (  )  )  ;", "assertEquals ( ScopedProxyMode . TARGET _ CLASS ,    scopeMetadata . getScopedProxyMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["customRequestScopeWithAttribute"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   readerFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   reader    =    readerFactory . getMetadataReader (  . AnnotatedWithCustomRequestScopeWithAttributeOverride . class . getName (  )  )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition ( reader . getAnnotationMetadata (  )  )  ;", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( bd )  ;", "assertNotNull (  \" resolveScopeMetadata (  .  .  )    must    * never *    return   null .  \"  ,    scopeMetadata )  ;", "assertEquals (  \" request \"  ,    scopeMetadata . getScopeName (  )  )  ;", "assertEquals ( ScopedProxyMode . TARGET _ CLASS ,    scopeMetadata . getScopedProxyMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["customRequestScopeWithAttributeViaAsm"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . scopeMetadataResolver    =    new   AnnotationScopeMetadataResolver ( ScopedProxyMode . INTERFACES )  ;", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition (  . AnnotatedWithPrototypeScope . class )  ;", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( bd )  ;", "assertNotNull (  \" resolveScopeMetadata (  .  .  )    must    * never *    return   null .  \"  ,    scopeMetadata )  ;", "assertEquals ( SCOPE _ PROTOTYPE ,    scopeMetadata . getScopeName (  )  )  ;", "assertEquals ( ScopedProxyMode . INTERFACES ,    scopeMetadata . getScopedProxyMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveScopeMetadataShouldApplyScopedProxyModeToPrototype"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition ( AnnotationScopeMetadataResolverTests . AnnotatedWithSingletonScope . class )  ;", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( bd )  ;", "assertNotNull (  \" resolveScopeMetadata (  .  .  )    must    * never *    return   null .  \"  ,    scopeMetadata )  ;", "assertEquals ( SCOPE _ SINGLETON ,    scopeMetadata . getScopeName (  )  )  ;", "assertEquals ( ScopedProxyMode . NO ,    scopeMetadata . getScopedProxyMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveScopeMetadataShouldNotApplyScopedProxyModeToSingleton"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedBeanDefinition   bd    =    new   AnnotatedGenericBeanDefinition ( AnnotationScopeMetadataResolverTests . AnnotatedWithScopedProxy . class )  ;", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( bd )  ;", "assertNotNull (  \" resolveScopeMetadata (  .  .  )    must    * never *    return   null .  \"  ,    scopeMetadata )  ;", "assertEquals (  \" request \"  ,    scopeMetadata . getScopeName (  )  )  ;", "assertEquals ( ScopedProxyMode . TARGET _ CLASS ,    scopeMetadata . getScopedProxyMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveScopeMetadataShouldReadScopedProxyModeFromAnnotation"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "scopeMetadataResolver . setScopeAnnotationType ( null )  ;", "}", "METHOD_END"], "methodName": ["setScopeAnnotationTypeWithNullType"], "fileName": "org.springframework.context.annotation.AnnotationScopeMetadataResolverTests"}, {"methodBody": ["METHOD_START", "{", "AutoProxyLazyInitTests . MyBeanImpl . initialized    =    false ;", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( AutoProxyLazyInitTests . ConfigWithNonStatic . class )  ;", "AutoProxyLazyInitTests . MyBean   bean    =    ctx . getBean (  \" myBean \"  ,    AutoProxyLazyInitTests . MyBean . class )  ;", "assertFalse ( AutoProxyLazyInitTests . MyBeanImpl . initialized )  ;", "bean . doIt (  )  ;", "assertTrue ( AutoProxyLazyInitTests . MyBeanImpl . initialized )  ;", "}", "METHOD_END"], "methodName": ["withNonStaticBeanMethod"], "fileName": "org.springframework.context.annotation.AutoProxyLazyInitTests"}, {"methodBody": ["METHOD_START", "{", "AutoProxyLazyInitTests . MyBeanImpl . initialized    =    false ;", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( AutoProxyLazyInitTests . ConfigWithNonStaticAndInterface . class )  ;", "AutoProxyLazyInitTests . MyBean   bean    =    ctx . getBean (  \" myBean \"  ,    AutoProxyLazyInitTests . MyBean . class )  ;", "assertFalse ( AutoProxyLazyInitTests . MyBeanImpl . initialized )  ;", "bean . doIt (  )  ;", "assertTrue ( AutoProxyLazyInitTests . MyBeanImpl . initialized )  ;", "}", "METHOD_END"], "methodName": ["withNonStaticBeanMethodAndInterface"], "fileName": "org.springframework.context.annotation.AutoProxyLazyInitTests"}, {"methodBody": ["METHOD_START", "{", "AutoProxyLazyInitTests . MyBeanImpl . initialized    =    false ;", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( AutoProxyLazyInitTests . ConfigWithStatic . class )  ;", "AutoProxyLazyInitTests . MyBean   bean    =    ctx . getBean (  \" myBean \"  ,    AutoProxyLazyInitTests . MyBean . class )  ;", "assertFalse ( AutoProxyLazyInitTests . MyBeanImpl . initialized )  ;", "bean . doIt (  )  ;", "assertTrue ( AutoProxyLazyInitTests . MyBeanImpl . initialized )  ;", "}", "METHOD_END"], "methodName": ["withStaticBeanMethod"], "fileName": "org.springframework.context.annotation.AutoProxyLazyInitTests"}, {"methodBody": ["METHOD_START", "{", "AutoProxyLazyInitTests . MyBeanImpl . initialized    =    false ;", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( AutoProxyLazyInitTests . ConfigWithStaticAndInterface . class )  ;", "AutoProxyLazyInitTests . MyBean   bean    =    ctx . getBean (  \" myBean \"  ,    AutoProxyLazyInitTests . MyBean . class )  ;", "assertFalse ( AutoProxyLazyInitTests . MyBeanImpl . initialized )  ;", "bean . doIt (  )  ;", "assertTrue ( AutoProxyLazyInitTests . MyBeanImpl . initialized )  ;", "}", "METHOD_END"], "methodName": ["withStaticBeanMethodAndInterface"], "fileName": "org.springframework.context.annotation.AutoProxyLazyInitTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =    beanMethod . getName (  )  ;", "Bean   bean    =    AnnotatedElementUtils . findMerged ( beanMethod ,    Bean . class )  ;", "if    (  ( bean    !  =    null )     &  &     (  ( bean . name (  )  . length )     >     0  )  )     {", "beanName    =    bean . name (  )  [  0  ]  ;", "}", "return   beanName ;", "}", "METHOD_END"], "methodName": ["determineBeanNameFor"], "fileName": "org.springframework.context.annotation.BeanAnnotationHelper"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . hasAnnotation ( method ,    Bean . class )  ;", "}", "METHOD_END"], "methodName": ["isBeanAnnotated"], "fileName": "org.springframework.context.annotation.BeanAnnotationHelper"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( BeanMethodMetadataTests . Conf . class )  ;", "BeanDefinition   beanDefinition    =    context . getBeanDefinition (  \" myBean \"  )  ;", "assertThat (  \" should   provide   AnnotatedBeanDefinition \"  ,    beanDefinition ,    instanceOf ( AnnotatedBeanDefinition . class )  )  ;", "Map < String ,    Object >    annotationAttributes    =     (  ( AnnotatedBeanDefinition )     ( beanDefinition )  )  . getFactoryMethodMetadata (  )  . getAnnotationAttributes ( BeanMethodMetadataTests . MyAnnotation . class . getName (  )  )  ;", "assertThat ( annotationAttributes . get (  \" value \"  )  ,    equalTo (  \" test \"  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["providesBeanMethodBeanDefinition"], "fileName": "org.springframework.context.annotation.BeanMethodMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( BeanMethodPolymorphismTests . Config . class )  ;", "ctx . getBean (  \" testBean \"  ,    TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["beanMethodDetectedOnSuperClass"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithOverloadingAndAdditionalMetadata . class )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" aString \"  )  )  ;", "assertThat ( ctx . getBean ( String . class )  ,    equalTo (  \" regular \"  )  )  ;", "assertTrue ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" aString \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverloadingWithAdditionalMetadata"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithOverloadingAndAdditionalMetadata . class )  ;", "ctx . getDefaultListableBeanFactory (  )  . registerSingleton (  \" anInt \"  ,     5  )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" aString \"  )  )  ;", "assertThat ( ctx . getBean ( String . class )  ,    equalTo (  \" overloaded 5  \"  )  )  ;", "assertTrue ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" aString \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverloadingWithAdditionalMetadataButOtherMethodExecuted"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . SubConfig . class )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" aString \"  )  )  ;", "assertThat ( ctx . getBean ( String . class )  ,    equalTo (  \" overloaded 5  \"  )  )  ;", "assertTrue ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" aString \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverloadingWithInheritance"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . SubConfigWithList . class )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" aString \"  )  )  ;", "assertThat ( ctx . getBean ( String . class )  ,    equalTo (  \" overloaded 5  \"  )  )  ;", "assertTrue ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" aString \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverloadingWithInheritanceAndList"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithOverloading . class )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( String . class )  ,    equalTo (  \" regular \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverloadingWithoutInheritance"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithOverloading . class )  ;", "ctx . getDefaultListableBeanFactory (  )  . registerSingleton (  \" anInt \"  ,     5  )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( String . class )  ,    equalTo (  \" overloaded 5  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverloadingWithoutInheritanceAndExtraDependency"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . OverridingConfig . class )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "assertEquals (  \" overridden \"  ,    ctx . getBean (  \" testBean \"  ,    TestBean . class )  . toString (  )  )  ;", "assertTrue ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverriding"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . OverridingConfig . class . getName (  )  )  )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "assertEquals (  \" overridden \"  ,    ctx . getBean (  \" testBean \"  ,    TestBean . class )  . toString (  )  )  ;", "assertTrue ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverridingOnASM"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . NarrowedOverridingConfig . class )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "assertEquals (  \" overridden \"  ,    ctx . getBean (  \" testBean \"  ,    TestBean . class )  . toString (  )  )  ;", "assertTrue ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverridingWithNarrowedReturnType"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . NarrowedOverridingConfig . class . getName (  )  )  )  ;", "ctx . setAllowBeanDefinitionOverriding ( false )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "assertEquals (  \" overridden \"  ,    ctx . getBean (  \" testBean \"  ,    TestBean . class )  . toString (  )  )  ;", "assertTrue ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodOverridingWithNarrowedReturnTypeOnASM"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( BeanMethodPolymorphismTests . ShadowConfig . class )  ;", "assertThat ( ctx . getBean ( String . class )  ,    equalTo (  \" shadow \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethodShadowing"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . Config . class )  ;", "ctx . register ( AnnotationAwareAspectJAutoProxyCreator . class )  ;", "ctx . register (  . TestAdvisor . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean (  \" testBean \"  ,    TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["beanMethodThroughAopProxy"], "fileName": "org.springframework.context.annotation.BeanMethodPolymorphismTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . registry . containsBeanDefinition ( beanName )  )  )     {", "return   true ;", "}", "BeanDefinition   existingDef    =    this . registry . getBeanDefinition ( beanName )  ;", "BeanDefinition   originatingDef    =    existingDef . getOriginatingBeanDefinition (  )  ;", "if    ( originatingDef    !  =    null )     {", "existingDef    =    originatingDef ;", "}", "if    ( isCompatible ( beanDefinition ,    existingDef )  )     {", "return   false ;", "}", "throw   new   ConflictingBeanDefinitionException (  (  (  (  (  (  (  (  \" Annotation - specified   bean   name    '  \"     +    beanName )     +     \"  '    for   bean   class    [  \"  )     +     ( beanDefinition . getBeanClassName (  )  )  )     +     \"  ]    conflicts   with   existing ,     \"  )     +     \" non - compatible   bean   definition   of   same   name   and   class    [  \"  )     +     ( existingDef . getBeanClassName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkCandidate"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( basePackages ,     \" At   least   one   base   package   must   be   specified \"  )  ;", "Set < Holder >    beanDefinitions    =    new   LinkedHashSet <  >  (  )  ;", "for    ( String   basePackage    :    basePackages )     {", "Set <  >    candidates    =    findCandidateComponents ( basePackage )  ;", "for    (    candidate    :    candidates )     {", "ScopeMetadata   scopeMetadata    =    this . scopeMetadataResolver . resolveScopeMetadata ( candidate )  ;", "candidate . setScope ( scopeMetadata . getScopeName (  )  )  ;", "String   beanName    =    this . beanNameGenerator . generateBeanName ( candidate ,    this . registry )  ;", "if    ( candidate   instanceof   Abstract )     {", "postProcess (  (  ( Abstract )     ( candidate )  )  ,    beanName )  ;", "}", "if    ( candidate   instanceof   Annotated )     {", "AnnotationConfigUtils . processCommonDefinitionAnnotations (  (  ( Annotated )     ( candidate )  )  )  ;", "}", "if    ( checkCandidate ( beanName ,    candidate )  )     {", "Holder   definitionHolder    =    new   Holder ( candidate ,    beanName )  ;", "definitionHolder    =    AnnotationConfigUtils . applyScopedProxyMode ( scopeMetadata ,    definitionHolder ,    this . registry )  ;", "beanDefinitions . add ( definitionHolder )  ;", "register ( definitionHolder ,    this . registry )  ;", "}", "}", "}", "return   beanDefinitions ;", "}", "METHOD_END"], "methodName": ["doScan"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "return   this . beanDefinitionDefaults ;", "}", "METHOD_END"], "methodName": ["getBeanDefinitionDefaults"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( registry ,     \" BeanDefinitionRegistry   must   not   be   null \"  )  ;", "if    ( registry   instanceof   EnvironmentCapable )     {", "return    (  ( EnvironmentCapable )     ( registry )  )  . getEnvironment (  )  ;", "}", "return   new   StandardEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["getOrCreateEnvironment"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "return    (  (  !  ( existingDefinition   instanceof   ScannedGenericBeanDefinition )  )     |  |     (  (  ( newDefinition . getSource (  )  )     !  =    null )     &  &     ( newDefinition . getSource (  )  . equals ( existingDefinition . getSource (  )  )  )  )  )     |  |     ( newDefinition . equals ( existingDefinition )  )  ;", "}", "METHOD_END"], "methodName": ["isCompatible"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "beanDefinition . applyDefaults ( this . beanDefinitionDefaults )  ;", "if    (  ( this . autowireCandidatePatterns )     !  =    null )     {", "beanDefinition . setAutowireCandidate ( PatternMatchUtils . simpleMatch ( this . autowireCandidatePatterns ,    beanName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["postProcessBeanDefinition"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionReaderUtils . registerBeanDefinition ( definitionHolder ,    registry )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinition"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "int   beanCountAtScanStart    =    this . registry . getBeanDefinitionCount (  )  ;", "doScan ( basePackages )  ;", "if    ( this . includeAnnotationConfig )     {", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( this . registry )  ;", "}", "return    ( this . registry . getBeanDefinitionCount (  )  )     -    beanCountAtScanStart ;", "}", "METHOD_END"], "methodName": ["scan"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "this . autowireCandidatePatterns    =    autowireCandidatePatterns ;", "}", "METHOD_END"], "methodName": ["setAutowireCandidatePatterns"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinitionDefaults    =     ( beanDefinitionDefaults    !  =    null )     ?    beanDefinitionDefaults    :    new   BeanDefinitionDefaults (  )  ;", "}", "METHOD_END"], "methodName": ["setBeanDefinitionDefaults"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "this . beanNameGenerator    =     ( beanNameGenerator    !  =    null )     ?    beanNameGenerator    :    new   AnnotationBeanNameGenerator (  )  ;", "}", "METHOD_END"], "methodName": ["setBeanNameGenerator"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "this . includeAnnotationConfig    =    includeAnnotationConfig ;", "}", "METHOD_END"], "methodName": ["setIncludeAnnotationConfig"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "this . scopeMetadataResolver    =     ( scopeMetadataResolver    !  =    null )     ?    scopeMetadataResolver    :    new   AnnotationScopeMetadataResolver (  )  ;", "}", "METHOD_END"], "methodName": ["setScopeMetadataResolver"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "this . scopeMetadataResolver    =    new   AnnotationScopeMetadataResolver ( scopedProxyMode )  ;", "}", "METHOD_END"], "methodName": ["setScopedProxyMode"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScanner"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( true )  ;", "scanner . setBeanNameGenerator ( new    . TestBeanNameGenerator (  )  )  ;", "scanner . setAutowireCandidatePatterns (  \"  * NoSuchDao \"  )  ;", "scanner . scan (  . BASE _ PACKAGE )  ;", "try    {", "context . refresh (  )  ;", "context . getBean (  \" fooService \"  )  ;", "fail (  \" BeanCreationException   expected ;    fooDao   should   not   have   been   an   autowire - candidate \"  )  ;", "}    catch    ( BeanCreationException   expected )     {", "assertTrue (  (  ( expected . getMostSpecificCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowireCandidatePatternDoesNotMatch"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( true )  ;", "scanner . setBeanNameGenerator ( new    . TestBeanNameGenerator (  )  )  ;", "scanner . setAutowireCandidatePatterns (  \"  * FooDao \"  )  ;", "scanner . scan (  . BASE _ PACKAGE )  ;", "context . refresh (  )  ;", "FooServiceImpl   fooService    =     (  ( FooServiceImpl )     ( context . getBean (  \" fooService \"  )  )  )  ;", "assertEquals (  \" bar \"  ,    fooService . foo (  1  2  3  )  )  ;", "assertEquals (  \" bar \"  ,    fooService . lookupFoo (  1  2  3  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidatePatternMatches"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" myBf \"  ,    new   RootBeanDefinition ( StaticListableBeanFactory . class )  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setBeanNameGenerator ( new    . TestBeanNameGenerator (  )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  3  ,    beanCount )  ;", "context . refresh (  )  ;", "FooServiceImpl   fooService    =    context . getBean (  \" fooService \"  ,    FooServiceImpl . class )  ;", "StaticListableBeanFactory   myBf    =     (  ( StaticListableBeanFactory )     ( context . getBean (  \" myBf \"  )  )  )  ;", "MessageSource   ms    =     (  ( MessageSource )     ( context . getBean (  \" messageSource \"  )  )  )  ;", "assertTrue ( fooService . isInitCalled (  )  )  ;", "assertEquals (  \" bar \"  ,    fooService . foo (  1  2  3  )  )  ;", "assertEquals (  \" bar \"  ,    fooService . lookupFoo (  1  2  3  )  )  ;", "assertSame ( context . getDefaultListableBeanFactory (  )  ,    fooService . beanFactory )  ;", "assertEquals (  2  ,    fooService . listableBeanFactory . size (  )  )  ;", "assertSame ( context . getDefaultListableBeanFactory (  )  ,    fooService . listableBeanFactory . get (  0  )  )  ;", "assertSame ( myBf ,    fooService . listableBeanFactory . get (  1  )  )  ;", "assertSame ( context ,    fooService . resourceLoader )  ;", "assertSame ( context ,    fooService . resourcePatternResolver )  ;", "assertSame ( context ,    fooService . eventPublisher )  ;", "assertSame ( ms ,    fooService . messageSource )  ;", "assertSame ( context ,    fooService . context )  ;", "assertEquals (  1  ,    fooService . configurableContext . length )  ;", "assertSame ( context ,    fooService . configurableContext [  0  ]  )  ;", "assertSame ( context ,    fooService . genericContext )  ;", "}", "METHOD_END"], "methodName": ["testBeanAutowiredWithAnnotationConfigEnabled"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "scanner . setBeanNameGenerator ( new    . TestBeanNameGenerator (  )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  7  ,    beanCount )  ;", "context . refresh (  )  ;", "try    {", "context . getBean (  \" fooService \"  )  ;", "}    catch    ( BeanCreationException   expected )     {", "assertTrue ( expected . contains ( BeanInstantiationException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBeanNotAutowiredWithAnnotationConfigDisabled"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context ,    true )  ;", "scanner . addExcludeFilter ( new   AnnotationTypeFilter ( Aspect . class )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  2  ,    beanCount )  ;", "assertFalse ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationExcludeFilterAndDefaults"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context ,    true )  ;", "scanner . addExcludeFilter ( new   AssignableTypeFilter ( FooService . class )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  2  ,    beanCount )  ;", "assertFalse ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAssignableTypeExcludeFilterAndDefaults"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context ,    true )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "scanner . addExcludeFilter ( new   AssignableTypeFilter ( FooService . class )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  6  ,    beanCount )  ;", "assertFalse ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertFalse ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertFalse ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertFalse ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAssignableTypeExcludeFilterAndDefaultsWithoutPostProcessors"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setBeanNameGenerator ( new    . TestBeanNameGenerator (  )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  3  ,    beanCount )  ;", "assertFalse ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooService \"  )  )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomBeanNameGenerator"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context ,    true )  ;", "scanner . addIncludeFilter ( new   AnnotationTypeFilter ( CustomComponent . class )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  4  ,    beanCount )  ;", "assertTrue ( context . containsBean (  \" messageBean \"  )  )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomIncludeFilterAndDefaults"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context ,    false )  ;", "scanner . addIncludeFilter ( new   AnnotationTypeFilter ( CustomComponent . class )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  7  ,    beanCount )  ;", "assertTrue ( context . containsBean (  \" messageBean \"  )  )  ;", "assertFalse ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertFalse ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertFalse ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertFalse ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertFalse ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomIncludeFilterWithoutDefaultsAndNoPostProcessors"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context ,    false )  ;", "scanner . addIncludeFilter ( new   AnnotationTypeFilter ( CustomComponent . class )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  7  ,    beanCount )  ;", "assertTrue ( context . containsBean (  \" messageBean \"  )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomIncludeFilterWithoutDefaultsButIncludingPostProcessors"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  3  ,    beanCount )  ;", "scanner . scan (  . BASE _ PACKAGE )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" thoreau \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleScan"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   singlePackageContext    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   singlePackageScanner    =    new   ClassPathBeanDefinitionScanner ( singlePackageContext )  ;", "GenericApplicationContext   multiPackageContext    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   multiPackageScanner    =    new   ClassPathBeanDefinitionScanner ( multiPackageContext )  ;", "int   singlePackageBeanCount    =    singlePackageScanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  3  ,    singlePackageBeanCount )  ;", "multiPackageScanner . scan (  . BASE _ PACKAGE ,     \" annotation \"  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleBasePackagesWithDefaultsOnly"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context ,    true )  ;", "scanner . addExcludeFilter ( new   AssignableTypeFilter ( FooService . class )  )  ;", "scanner . addExcludeFilter ( new   AnnotationTypeFilter ( Aspect . class )  )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  1  ,    beanCount )  ;", "assertFalse ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertFalse ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleCustomExcludeFiltersAndDefaults"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "int   initialBeanCount    =    context . getBeanDefinitionCount (  )  ;", "int   scannedBeanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  3  ,    scannedBeanCount )  ;", "assertEquals ( scannedBeanCount ,     (  ( context . getBeanDefinitionCount (  )  )     -    initialBeanCount )  )  ;", "int   addedBeanCount    =    scanner . scan (  \" annotation \"  )  ;", "assertEquals (  (  ( initialBeanCount    +    scannedBeanCount )     +    addedBeanCount )  ,    context . getBeanDefinitionCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleScanCalls"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "try    {", "scanner . scan (  \"  3  \"  )  ;", "scanner . scan ( ClassPathBeanDefinitionScannerTests . BASE _ PACKAGE )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" stubFooDao \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( StubFooDao . class . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndDefaultBeanNameClash"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  7  ,    beanCount )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndNoPostProcessors"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( NamedStubDao . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "context . registerBeanDefinition (  \" myNamedDao \"  ,    bd )  ;", "int   initialBeanCount    =    context . getBeanDefinitionCount (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "int   scannedBeanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  6  ,    scannedBeanCount )  ;", "assertEquals (  ( initialBeanCount    +    scannedBeanCount )  ,    context . getBeanDefinitionCount (  )  )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndOverriddenCompatibleNamedBean"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" myNamedDao \"  ,    new   RootBeanDefinition ( NamedStubDao . class )  )  ;", "int   initialBeanCount    =    context . getBeanDefinitionCount (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "int   scannedBeanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  6  ,    scannedBeanCount )  ;", "assertEquals (  ( initialBeanCount    +    scannedBeanCount )  ,    context . getBeanDefinitionCount (  )  )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndOverriddenEqualNamedBean"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" stubFooDao \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "scanner . scan (  . BASE _ PACKAGE )  ;", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndOverridingBean"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "int   beanCount    =    scanner . scan (  . BASE _ PACKAGE )  ;", "assertEquals (  1  3  ,    beanCount )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" thoreau \"  )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . CONFIGURATION _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . AUTOWIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . REQUIRED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . COMMON _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ PROCESSOR _ BEAN _ NAME )  )  ;", "assertTrue ( context . containsBean ( AnnotationConfigUtils . EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "context . refresh (  )  ;", "FooServiceImpl   fooService    =    context . getBean (  \" fooServiceImpl \"  ,    FooServiceImpl . class )  ;", "assertTrue ( context . getDefaultListableBeanFactory (  )  . containsSingleton (  \" myNamedComponent \"  )  )  ;", "assertEquals (  \" bar \"  ,    fooService . foo (  1  2  3  )  )  ;", "assertEquals (  \" bar \"  ,    fooService . lookupFoo (  1  2  3  )  )  ;", "assertTrue ( context . isPrototype (  \" thoreau \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndPostProcessors"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . scan ( ClassPathBeanDefinitionScannerTests . BASE _ PACKAGE )  ;", "scanner . scan (  \"  5  \"  )  ;", "assertTrue ( context . containsBean (  \" serviceInvocationCounter \"  )  )  ;", "assertTrue ( context . containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( context . containsBean (  \" stubFooDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedComponent \"  )  )  ;", "assertTrue ( context . containsBean (  \" myNamedDao \"  )  )  ;", "assertTrue ( context . containsBean (  \" otherFooDao \"  )  )  ;", "context . refresh (  )  ;", "assertFalse ( context . getBeanFactory (  )  . containsSingleton (  \" otherFooDao \"  )  )  ;", "assertFalse ( context . getBeanFactory (  )  . containsSingleton (  \" fooServiceImpl \"  )  )  ;", "FooServiceImpl   fooService    =    context . getBean (  \" fooServiceImpl \"  ,    FooServiceImpl . class )  ;", "assertTrue ( context . getBeanFactory (  )  . containsSingleton (  \" otherFooDao \"  )  )  ;", "assertEquals (  \" other \"  ,    fooService . foo (  1  2  3  )  )  ;", "assertEquals (  \" other \"  ,    fooService . lookupFoo (  1  2  3  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndPrimaryLazyBean"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "scanner . scan (  . BASE _ PACKAGE )  ;", "scanner . scan (  . BASE _ PACKAGE )  ;", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndSameBeanTwice"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "scanner . setIncludeAnnotationConfig ( false )  ;", "try    {", "scanner . scan (  \"  2  \"  )  ;", "scanner . scan ( ClassPathBeanDefinitionScannerTests . BASE _ PACKAGE )  ;", "fail (  \" Must   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   expected )     {", "assertTrue ( expected . getMessage (  )  . contains (  \" myNamedDao \"  )  )  ;", "assertTrue ( expected . getMessage (  )  . contains ( NamedStubDao . class . getName (  )  )  )  ;", "assertTrue ( expected . getMessage (  )  . contains ( NamedStubDao 2  . class . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSimpleScanWithDefaultFiltersAndSpecifiedBeanNameClash"], "fileName": "org.springframework.context.annotation.ClassPathBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( context )  ;", "context . getBeanFactory (  )  . registerScope (  \" request \"  ,    new   SimpleMapScope (  )  )  ;", "scanner . scan (  . BASE _ PACKAGE )  ;", "context . registerBeanDefinition (  \" clientBean \"  ,    new   RootBeanDefinition (  . QualifiedClientBean . class )  )  ;", "context . refresh (  )  ;", "FactoryMethodComponent   fmc    =    context . getBean (  \" factoryMethodComponent \"  ,    FactoryMethodComponent . class )  ;", "assertFalse ( fmc . getClass (  )  . getName (  )  . contains ( CGLIB _ CLASS _ SEPARATOR )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( context . getBean (  \" publicInstance \"  )  )  )  ;", "assertEquals (  \" publicInstance \"  ,    tb . getName (  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( context . getBean (  \" publicInstance \"  )  )  )  ;", "assertEquals (  \" publicInstance \"  ,    tb 2  . getName (  )  )  ;", "assertSame ( tb 2  ,    tb )  ;", "tb    =     (  ( TestBean )     ( context . getBean (  \" protectedInstance \"  )  )  )  ;", "assertEquals (  \" protectedInstance \"  ,    tb . getName (  )  )  ;", "assertSame ( tb ,    context . getBean (  \" protectedInstance \"  )  )  ;", "assertEquals (  \"  0  \"  ,    tb . getCountry (  )  )  ;", "tb 2     =    context . getBean (  \" protectedInstance \"  ,    TestBean . class )  ;", "assertEquals (  \" protectedInstance \"  ,    tb 2  . getName (  )  )  ;", "assertSame ( tb 2  ,    tb )  ;", "tb    =    context . getBean (  \" privateInstance \"  ,    TestBean . class )  ;", "assertEquals (  \" privateInstance \"  ,    tb . getName (  )  )  ;", "assertEquals (  1  ,    tb . getAge (  )  )  ;", "tb 2     =    context . getBean (  \" privateInstance \"  ,    TestBean . class )  ;", "assertEquals (  2  ,    tb 2  . getAge (  )  )  ;", "assertNotSame ( tb 2  ,    tb )  ;", "Object   bean    =    context . getBean (  \" requestScopedInstance \"  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean )  )  ;", "assertTrue (  ( bean   instanceof   ScopedObject )  )  ;", ". QualifiedClientBean   clientBean    =    context . getBean (  \" clientBean \"  ,     . QualifiedClientBean . class )  ;", "assertSame ( context . getBean (  \" publicInstance \"  )  ,    clientBean . testBean )  ;", "assertSame ( context . getBean (  \" dependencyBean \"  )  ,    clientBean . dependencyBean )  ;", "assertSame ( context ,    clientBean . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["testSingletonScopedFactoryMethod"], "fileName": "org.springframework.context.annotation.ClassPathFactoryBeanDefinitionScannerTests"}, {"methodBody": ["METHOD_START", "{", "Set < BeanDefinition >    candidates    =    new   LinkedHashSet <  >  (  )  ;", "try    {", "Set < String >    types    =    new   HashSet <  >  (  )  ;", "for    ( TypeFilter   filter    :    this . includeFilters )     {", "String   stereotype    =    extractStereotype ( filter )  ;", "if    ( stereotype    =  =    null )     {", "throw   new   IllegalArgumentException (  (  \" Failed   to   extract   stereotype   from    \"     +    filter )  )  ;", "}", "types . addAll ( index . getCandidateTypes ( basePackage ,    stereotype )  )  ;", "}", "boolean   traceEnabled    =    logger . isTraceEnabled (  )  ;", "boolean   debugEnabled    =    logger . isDebugEnabled (  )  ;", "for    ( String   type    :    types )     {", "MetadataReader   metadataReader    =    getMetadataReaderFactory (  )  . getMetadataReader ( type )  ;", "if    ( is ( metadataReader )  )     {", "AnnotatedGenericBeanDefinition   sbd    =    new   AnnotatedGenericBeanDefinition ( metadataReader . getAnnotationMetadata (  )  )  ;", "if    ( is ( sbd )  )     {", "if    ( debugEnabled )     {", "logger . debug (  (  \" Using   candidate   component   class   from   index :     \"     +    type )  )  ;", "}", "candidates . add ( sbd )  ;", "} else    {", "if    ( debugEnabled )     {", "logger . debug (  (  \" Ignored   because   not   a   concrete   top - level   class :     \"     +    type )  )  ;", "}", "}", "} else    {", "if    ( traceEnabled )     {", "logger . trace (  (  \" Ignored   because   matching   an   exclude   filter :     \"     +    type )  )  ;", "}", "}", "}", "}    catch    ( IOException   ex )     {", "throw   new   BeanDefinitionStoreException (  \" I / O   failure   during   classpath   scanning \"  ,    ex )  ;", "}", "return   candidates ;", "}", "METHOD_END"], "methodName": ["addCandidateComponentsFromIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "this . excludeFilters . add (  0  ,    excludeFilter )  ;", "}", "METHOD_END"], "methodName": ["addExcludeFilter"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "this . includeFilters . add ( includeFilter )  ;", "}", "METHOD_END"], "methodName": ["addIncludeFilter"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . metadataReaderFactory )    instanceof   CachingMetadataReaderFactory )     {", "(  ( CachingMetadataReaderFactory )     ( this . metadataReaderFactory )  )  . clearCache (  )  ;", "}", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( filter   instanceof   AnnotationTypeFilter )     {", "return    (  ( AnnotationTypeFilter )     ( filter )  )  . getAnnotationType (  )  . getName (  )  ;", "}", "if    ( filter   instanceof   AssignableTypeFilter )     {", "return    (  ( AssignableTypeFilter )     ( filter )  )  . getTargetType (  )  . getName (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["extractStereotype"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . componentsIndex )     !  =    null )     &  &     ( indexSupportsIncludeFilters (  )  )  )     {", "return   addsFromIndex ( this . componentsIndex ,    basePackage )  ;", "} else    {", "return   scans ( basePackage )  ;", "}", "}", "METHOD_END"], "methodName": ["findCandidateComponents"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . metadataReaderFactory )     =  =    null )     {", "this . metadataReaderFactory    =    new   CachingMetadataReaderFactory (  )  ;", "}", "return   this . metadataReaderFactory ;", "}", "METHOD_END"], "methodName": ["getMetadataReaderFactory"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "return   getResourcePatternResolver (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceLoader"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . resourcePatternResolver )     =  =    null )     {", "this . resourcePatternResolver    =    new   MatchingResourcePatternResolver (  )  ;", "}", "return   this . resourcePatternResolver ;", "}", "METHOD_END"], "methodName": ["getResourcePatternResolver"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( filter   instanceof   AnnotationTypeFilter )     {", "Class <  ?    extends   Annotation >     =     (  ( AnnotationTypeFilter )     ( filter )  )  . getAnnotationType (  )  ;", "return    ( AnnotationUtils . isAnnotationDeclaredLocally ( Indexed . class ,     )     |  |     ( getName (  )  . startsWith (  \" \"  )  )  ;", "}", "if    ( filter   instanceof   AssignableTypeFilter )     {", "Class <  ?  >    target    =     (  ( AssignableTypeFilter )     ( filter )  )  . getTargetType (  )  ;", "return   AnnotationUtils . isAnnotationDeclaredLocally ( Indexed . class ,    target )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["indexSupportsIncludeFilter"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( TypeFilter   includeFilter    :    this . includeFilters )     {", "if    (  !  ( indexSupportsIncludeFilter ( includeFilter )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["indexSupportsIncludeFilters"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    beanDefinition . getMetadata (  )  ;", "return    ( metadata . isIndependent (  )  )     &  &     (  ( metadata . isConcrete (  )  )     |  |     (  ( metadata . isAbstract (  )  )     &  &     ( metadata . hasAnnotatedMethods ( Lookup . class . getName (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCandidateComponent"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( TypeFilter   tf    :    this . excludeFilters )     {", "if    ( tf . match ( metadataReader ,    getMetadataReaderFactory (  )  )  )     {", "return   false ;", "}", "}", "for    ( TypeFilter   tf    :    this . includeFilters )     {", "if    ( tf . match ( metadataReader ,    getMetadataReaderFactory (  )  )  )     {", "return   isCondiMatch ( metadataReader )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isCandidateComponent"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . conditionEvaluator )     =  =    null )     {", "this . conditionEvaluator    =    new   ConditionEvaluator ( getRegistry (  )  ,    this . environment ,    this . resourcePatternResolver )  ;", "}", "return    !  ( this . conditionEvaluator . shouldSkip ( metadataReader . getAMetadata (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isConditionMatch"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "this . includeFilters . add ( new   AnnotationTypeFilter ( Component . class )  )  ;", "ClassLoader   cl    =     . class . getClassLoader (  )  ;", "try    {", "this . includeFilters . add ( new   AnnotationTypeFilter (  (  ( Class <  ?    extends   Annotation >  )     ( ClassUtils . forName (  \" ManagedBean \"  ,    cl )  )  )  ,    false )  )  ;", "logger . debug (  \" JSR -  2  5  0     ' ManagedBean '    found   and   supported   for   component   scanning \"  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "}", "try    {", "this . includeFilters . add ( new   AnnotationTypeFilter (  (  ( Class <  ?    extends   Annotation >  )     ( ClassUtils . forName (  \" Named \"  ,    cl )  )  )  ,    false )  )  ;", "logger . debug (  \" JSR -  3  3  0     ' Named '    annotation   found   and   supported   for   component   scanning \"  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["registerDefaultFilters"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "this . includeFilters . clear (  )  ;", "this . excludeFilters . clear (  )  ;", "if    ( useDefaultFilters )     {", "registerDefaultFilters (  )  ;", "}", "}", "METHOD_END"], "methodName": ["resetFilters"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . convertClassNameToResourcePath ( getEnvironment (  )  . resolveRequiredPlaceholders ( basePackage )  )  ;", "}", "METHOD_END"], "methodName": ["resolveBasePackage"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "Set < BeanDefinition >    candidates    =    new   LinkedHashSet <  >  (  )  ;", "try    {", "String   packageSearchPath    =     (  (  ( ResourcePatternResolver . CLASSPATH _ ALL _ URL _ PREFIX )     +     ( resolveBasePackage ( basePackage )  )  )     +     '  /  '  )     +     ( this . resourcePattern )  ;", "Resource [  ]    resources    =    getResourcePatternResolver (  )  . getResources ( packageSearchPath )  ;", "boolean   traceEnabled    =    logger . isTraceEnabled (  )  ;", "boolean   debugEnabled    =    logger . isDebugEnabled (  )  ;", "for    ( Resource   resource    :    resources )     {", "if    ( traceEnabled )     {", "logger . trace (  (  \" Scanning    \"     +    resource )  )  ;", "}", "if    ( resource . isReadable (  )  )     {", "try    {", "MetadataReader   metadataReader    =    getMetadataReaderFactory (  )  . getMetadataReader ( resource )  ;", "if    ( is ( metadataReader )  )     {", "ScannedGenericBeanDefinition   sbd    =    new   ScannedGenericBeanDefinition ( metadataReader )  ;", "sbd . setResource ( resource )  ;", "sbd . setSource ( resource )  ;", "if    ( is ( sbd )  )     {", "if    ( debugEnabled )     {", "logger . debug (  (  \" Identified   candidate   component   class :     \"     +    resource )  )  ;", "}", "candidates . add ( sbd )  ;", "} else    {", "if    ( debugEnabled )     {", "logger . debug (  (  \" Ignored   because   not   a   concrete   top - level   class :     \"     +    resource )  )  ;", "}", "}", "} else    {", "if    ( traceEnabled )     {", "logger . trace (  (  \" Ignored   because   not   matching   any   filter :     \"     +    resource )  )  ;", "}", "}", "}    catch    ( Throwable   ex )     {", "throw   new   BeanDefinitionStoreException (  (  \" Failed   to   read   candidate   component   class :     \"     +    resource )  ,    ex )  ;", "}", "} else    {", "if    ( traceEnabled )     {", "logger . trace (  (  \" Ignored   because   not   readable :     \"     +    resource )  )  ;", "}", "}", "}", "}    catch    ( IOException   ex )     {", "throw   new   BeanDefinitionStoreException (  \" I / O   failure   during   classpath   scanning \"  ,    ex )  ;", "}", "return   candidates ;", "}", "METHOD_END"], "methodName": ["scanCandidateComponents"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( environment ,     \" Environment   must   not   be   null \"  )  ;", "this . environment    =    environment ;", "thisditionEvaluator    =    null ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "this . metadataReaderFactory    =    metadataReaderFactory ;", "}", "METHOD_END"], "methodName": ["setMetadataReaderFactory"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourcePattern ,     \"  ' resourcePattern '    must   not   be   null \"  )  ;", "this . resourcePattern    =    resourcePattern ;", "}", "METHOD_END"], "methodName": ["setResourcePattern"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "testAntStyle ( provider ,    AnnotatedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["antStylePackageWithIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader ( CandidateComponentsTestClassLoader . disableIndex ( getClass (  )  . getClassLoader (  )  )  )  )  ;", "testAntStyle ( provider ,    ScannedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["antStylePackageWithScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "candidates . forEach (  (    c )     -  >     {", "assertThat ( c ,    is ( instanceOf ( expectedType )  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["assertBeanDefinitionType"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  \" bogus \"  )  ;", "assertEquals (  0  ,    candidates . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["bogusPackageWithIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader ( CandidateComponentsTestClassLoader . disableIndex ( getClass (  )  . getClassLoader (  )  )  )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  \" bogus \"  )  ;", "assertEquals (  0  ,    candidates . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["bogusPackageWithScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDefinition   candidate    :    candidates )     {", "if    ( beanClass . getName (  )  . equals ( candidate . getBeanClassName (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsBeanClass"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "testCustomAnnotationTypeIncludeFilter ( provider ,    AnnotatedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customAnnotationTypeIncludeFilterWithIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader ( CandidateComponentsTestClassLoader . disableIndex ( getClass (  )  . getClassLoader (  )  )  )  )  ;", "testCustomAnnotationTypeIncludeFilter ( provider ,    ScannedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customAnnotationTypeIncludeFilterWithScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "testCustomAssignableTypeIncludeFilter ( provider ,    AnnotatedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customAssignableTypeIncludeFilterWithIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader ( CandidateComponentsTestClassLoader . disableIndex ( getClass (  )  . getClassLoader (  )  )  )  )  ;", "testCustomAssignableTypeIncludeFilter ( provider ,    ScannedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customAssignableTypeIncludeFilterWithScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "provider . addIncludeFilter ( new   AnnotationTypeFilter ( Component . class )  )  ;", "provider . resetFilters ( true )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertBeanDefinitionType ( candidates ,    AnnotatedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customFiltersFollowedByResetUseIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "provider . addIncludeFilter ( new   AssignableTypeFilter ( FooDao . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertTrue ( containsBeanClass ( candidates ,    StubFooDao . class )  )  ;", "assertEquals (  1  ,    candidates . size (  )  )  ;", "assertBeanDefinitionType ( candidates ,    ScannedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customNotSupportedIncludeFilterUseScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "provider . addIncludeFilter ( new   AnnotationTypeFilter ( CustomStereotype . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertTrue ( containsBeanClass ( candidates ,    DefaultNamedComponent . class )  )  ;", "assertEquals (  1  ,    candidates . size (  )  )  ;", "assertBeanDefinitionType ( candidates ,    ScannedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customSupportIncludeFilterWithNonIndexedTypeUseScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "testCustomSupportedIncludeAndExcludeFilter ( provider ,    AnnotatedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customSupportedIncludeAndExcludeFilterWithIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader ( CandidateComponentsTestClassLoader . disableIndex ( getClass (  )  . getClassLoader (  )  )  )  )  ;", "testCustomSupportedIncludeAndExcludeFilter ( provider ,    ScannedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["customSupportedIncludeAndExcludedFilterWithScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "testDefault ( provider ,    AnnotatedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["defaultsWithIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader ( CandidateComponentsTestClassLoader . disableIndex ( getClass (  )  . getClassLoader (  )  )  )  )  ;", "testDefault ( provider ,    ScannedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["defaultsWithScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader (  . TEST _ BASE _ CLASSLOADER )  )  ;", "provider . addExcludeFilter ( new   RegexPatternTypeFilter ( Pattern . compile (  (  (  . TEST _ BASE _ PACKAGE )     +     \"  .  * Named .  *  \"  )  )  )  )  ;", "testExclude ( provider ,    AnnotatedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["excludeFilterWithIndex"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "provider . setResourceLoader ( new   DefaultResourceLoader ( CandidateComponentsTestClassLoader . disableIndex ( getClass (  )  . getClassLoader (  )  )  )  )  ;", "provider . addExcludeFilter ( new   RegexPatternTypeFilter ( Pattern . compile (  (  (  . TEST _ BASE _ PACKAGE )     +     \"  .  * Named .  *  \"  )  )  )  )  ;", "testExclude ( provider ,    ScannedGenericBeanDefinition . class )  ;", "}", "METHOD_END"], "methodName": ["excludeFilterWithScan"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  (  ( ClassPathScanningCandidateComponentProviderTests . TEST _ BASE _ PACKAGE )     +     \"  .  *  *  . sub \"  )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    BarComponent . class )  )  ;", "assertEquals (  1  ,    candidates . size (  )  )  ;", "assertBeanDefinitionType ( candidates ,    expectedBeanDefinitionType )  ;", "}", "METHOD_END"], "methodName": ["testAntStyle"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "provider . addIncludeFilter ( new   AnnotationTypeFilter ( Component . class )  )  ;", "testDefault ( provider ,    expectedBeanDefinitionType )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationTypeIncludeFilter"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "provider . addIncludeFilter ( new   AssignableTypeFilter ( FooService . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertTrue ( containsBeanClass ( candidates ,    AutowiredQualifierFooService . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    FooServiceImpl . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    ScopedProxyTestBean . class )  )  ;", "assertEquals (  3  ,    candidates . size (  )  )  ;", "assertBeanDefinitionType ( candidates ,    expectedBeanDefinitionType )  ;", "}", "METHOD_END"], "methodName": ["testCustomAssignableTypeIncludeFilter"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "provider . addIncludeFilter ( new   AnnotationTypeFilter ( Component . class )  )  ;", "provider . addExcludeFilter ( new   AnnotationTypeFilter ( Service . class )  )  ;", "provider . addExcludeFilter ( new   AnnotationTypeFilter ( Repository . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertTrue ( containsBeanClass ( candidates ,    NamedComponent . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    ServiceInvocationCounter . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    BarComponent . class )  )  ;", "assertEquals (  3  ,    candidates . size (  )  )  ;", "assertBeanDefinitionType ( candidates ,    expectedBeanDefinitionType )  ;", "}", "METHOD_END"], "methodName": ["testCustomSupportedIncludeAndExcludeFilter"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents ( ClassPathScanningCandidateComponentProviderTests . TEST _ BASE _ PACKAGE )  ;", "assertTrue ( containsBeanClass ( candidates ,    DefaultNamedComponent . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    NamedComponent . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    FooServiceImpl . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    StubFooDao . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    NamedStubDao . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    ServiceInvocationCounter . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    BarComponent . class )  )  ;", "assertEquals (  7  ,    candidates . size (  )  )  ;", "assertBeanDefinitionType ( candidates ,    expectedBeanDefinitionType )  ;", "}", "METHOD_END"], "methodName": ["testDefault"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents ( ClassPathScanningCandidateComponentProviderTests . TEST _ BASE _ PACKAGE )  ;", "assertTrue ( containsBeanClass ( candidates ,    FooServiceImpl . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    StubFooDao . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    ServiceInvocationCounter . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    BarComponent . class )  )  ;", "assertEquals (  4  ,    candidates . size (  )  )  ;", "assertBeanDefinitionType ( candidates ,    expectedBeanDefinitionType )  ;", "}", "METHOD_END"], "methodName": ["testExclude"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . addIncludeFilter ( new   AnnotationTypeFilter ( Component . class )  )  ;", "provider . addIncludeFilter ( new   AssignableTypeFilter ( FooServiceImpl . class )  )  ;", "provider . addExcludeFilter ( new   AssignableTypeFilter ( FooService . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertEquals (  6  ,    candidates . size (  )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    NamedComponent . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    ServiceInvocationCounter . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    BarComponent . class )  )  ;", "assertFalse ( containsBeanClass ( candidates ,    FooServiceImpl . class )  )  ;", "}", "METHOD_END"], "methodName": ["testExcludeTakesPrecedence"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    beanClass    =    ClassPathScanningCandidateComponentProviderTests . DefaultAndDevProfileAnnotatedComponent . class ;", "String   beanName    =    ClassPathScanningCandidateComponentProviderTests . DefaultAndDevProfileAnnotatedComponent . BEAN _ NAME ;", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setDefaultProfiles ( ClassPathScanningCandidateComponentProviderTests . TEST _ DEFAULT _ PROFILE _ NAME )  ;", "ctx . register ( beanClass )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( beanName )  ,    is ( true )  )  ;", "}", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setDefaultProfiles ( ClassPathScanningCandidateComponentProviderTests . TEST _ DEFAULT _ PROFILE _ NAME )  ;", "ctx . getEnvironment (  )  . setActiveProfiles (  \" dev \"  )  ;", "ctx . register ( beanClass )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( beanName )  ,    is ( true )  )  ;", "}", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setDefaultProfiles ( ClassPathScanningCandidateComponentProviderTests . TEST _ DEFAULT _ PROFILE _ NAME )  ;", "ctx . getEnvironment (  )  . setActiveProfiles (  \" other \"  )  ;", "ctx . register ( beanClass )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( beanName )  ,    is ( false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIntegrationWithAnnotationConfigApplicationContext_defaultAndDevProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setDefaultProfiles (  . TEST _ DEFAULT _ PROFILE _ NAME )  ;", "ctx . register (  . DefaultProfileAnnotatedComponent . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  . DefaultProfileAnnotatedComponent . BEAN _ NAME )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegrationWithAnnotationConfigApplicationContext_defaultProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setActiveProfiles (  \" other \"  )  ;", "ctx . register ( ProfileMetaAnnotatedComponent . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( ProfileMetaAnnotatedComponent . BEAN _ NAME )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegrationWithAnnotationConfigApplicationContext_invalidMetaAnnotatedProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setActiveProfiles (  \" other \"  )  ;", "ctx . register ( ProfileAnnotatedComponent . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( ProfileAnnotatedComponent . BEAN _ NAME )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegrationWithAnnotationConfigApplicationContext_invalidProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    beanClass    =    ClassPathScanningCandidateComponentProviderTests . MetaProfileAnnotatedComponent . class ;", "String   beanName    =    ClassPathScanningCandidateComponentProviderTests . MetaProfileAnnotatedComponent . BEAN _ NAME ;", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setDefaultProfiles ( ClassPathScanningCandidateComponentProviderTests . TEST _ DEFAULT _ PROFILE _ NAME )  ;", "ctx . register ( beanClass )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( beanName )  ,    is ( true )  )  ;", "}", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setDefaultProfiles ( ClassPathScanningCandidateComponentProviderTests . TEST _ DEFAULT _ PROFILE _ NAME )  ;", "ctx . getEnvironment (  )  . setActiveProfiles (  \" dev \"  )  ;", "ctx . register ( beanClass )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( beanName )  ,    is ( true )  )  ;", "}", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setDefaultProfiles ( ClassPathScanningCandidateComponentProviderTests . TEST _ DEFAULT _ PROFILE _ NAME )  ;", "ctx . getEnvironment (  )  . setActiveProfiles (  \" other \"  )  ;", "ctx . register ( beanClass )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( beanName )  ,    is ( false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIntegrationWithAnnotationConfigApplicationContext_metaProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( ProfileAnnotatedComponent . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( ProfileAnnotatedComponent . BEAN _ NAME )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegrationWithAnnotationConfigApplicationContext_noProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setActiveProfiles ( DevComponent . PROFILE _ NAME )  ;", "ctx . register ( ProfileMetaAnnotatedComponent . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( ProfileMetaAnnotatedComponent . BEAN _ NAME )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegrationWithAnnotationConfigApplicationContext_validMetaAnnotatedProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . getEnvironment (  )  . setActiveProfiles ( ProfileAnnotatedComponent . PROFILE _ NAME )  ;", "ctx . register ( ProfileAnnotatedComponent . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean ( ProfileAnnotatedComponent . BEAN _ NAME )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegrationWithAnnotationConfigApplicationContext_validProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . setActiveProfiles ( ProfileAnnotatedComponent . PROFILE _ NAME )  ;", "provider . setEnvironment ( env )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ PROFILE _ PACKAGE )  ;", "assertThat ( containsBeanClass ( candidates ,    ProfileAnnotatedComponent . class )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["testWithActiveProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . addIncludeFilter ( new   AnnotationTypeFilter ( Aspect . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertEquals (  1  ,    candidates . size (  )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    ServiceInvocationCounter . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWithAspectAnnotationOnly"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . addIncludeFilter ( new   AssignableTypeFilter ( MessageBean . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertEquals (  1  ,    candidates . size (  )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    MessageBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWithClassType"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . addIncludeFilter ( new   AnnotationTypeFilter ( Component . class )  )  ;", "provider . addExcludeFilter ( new   AnnotationTypeFilter ( Repository . class )  )  ;", "provider . addExcludeFilter ( new   AnnotationTypeFilter ( Service . class )  )  ;", "provider . addExcludeFilter ( new   AnnotationTypeFilter ( Controller . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertEquals (  3  ,    candidates . size (  )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    NamedComponent . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    ServiceInvocationCounter . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    BarComponent . class )  )  ;", "assertFalse ( containsBeanClass ( candidates ,    FooServiceImpl . class )  )  ;", "assertFalse ( containsBeanClass ( candidates ,    StubFooDao . class )  )  ;", "assertFalse ( containsBeanClass ( candidates ,    NamedStubDao . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWithComponentAnnotationOnly"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . setActiveProfiles (  \" other \"  )  ;", "provider . setEnvironment ( env )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ PROFILE _ PACKAGE )  ;", "assertThat ( containsBeanClass ( candidates ,    ProfileAnnotatedComponent . class )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testWithInactiveProfile"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . addIncludeFilter ( new   AssignableTypeFilter ( FooDao . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertEquals (  1  ,    candidates . size (  )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    StubFooDao . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWithInterfaceType"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "provider . addIncludeFilter ( new   AnnotationTypeFilter ( Component . class )  )  ;", "provider . addIncludeFilter ( new   AssignableTypeFilter ( FooServiceImpl . class )  )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertEquals (  7  ,    candidates . size (  )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    NamedComponent . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    ServiceInvocationCounter . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    FooServiceImpl . class )  )  ;", "assertTrue ( containsBeanClass ( candidates ,    BarComponent . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWithMultipleMatchingFilters"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( false )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ BASE _ PACKAGE )  ;", "assertEquals (  0  ,    candidates . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithNoFilters"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathScanningCandidateComponentProvider   provider    =    new   ClassPathScanningCandidateComponentProvider ( true )  ;", "Set < BeanDefinition >    candidates    =    provider . findCandidateComponents (  . TEST _ PROFILE _ PACKAGE )  ;", "assertThat ( containsBeanClass ( candidates ,    ProfileAnnotatedComponent . class )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testWithNullEnvironment"], "fileName": "org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests"}, {"methodBody": ["METHOD_START", "{", "Object   resource ;", "Set < String >    autowiredBeanNames ;", "String   name    =    element . name ;", "if    (  (  (  ( this . fallbackToDefaultTypeMatch )     &  &     ( element . isDefaultName )  )     &  &     ( factory   instanceof   AutowireCapableBeanFactory )  )     &  &     (  !  ( factoryainsBean ( name )  )  )  )     {", "autowiredBeanNames    =    new   LinkedHashSet <  >  (  )  ;", "resource    =     (  ( AutowireCapableBeanFactory )     ( factory )  )  . resolveDependency ( element . getDependencyDescriptor (  )  ,    requestingBeanName ,    autowiredBeanNames ,    null )  ;", "if    ( resource    =  =    null )     {", "throw   new   NoSuchBeanDefinitionException ( element . getLookupType (  )  ,     \" No   resolvable   resource   object \"  )  ;", "}", "} else    {", "resource    =    factory . getBean ( name ,    element . lookupType )  ;", "autowiredBeanNames    =    Collections . singleton ( name )  ;", "}", "if    ( factory   instanceof   ConfigurableBeanFactory )     {", "ConfigurableBeanFactory   beanFactory    =     (  ( ConfigurableBeanFactory )     ( factory )  )  ;", "for    ( String   autowiredBeanName    :    autowiredBeanNames )     {", "if    (  ( requestingBeanName    !  =    null )     &  &     ( beanFactoryainsBean ( autowiredBeanName )  )  )     {", "beanFactory . registerDependentBean ( autowiredBeanName ,    requestingBeanName )  ;", "}", "}", "}", "return   resource ;", "}", "METHOD_END"], "methodName": ["autowireResource"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "TargetSource   ts    =    new   TargetSource (  )     {", "@ Override", "public   Class <  ?  >    getTargetClass (  )     {", "return   element . lookupType ;", "}", "@ Override", "public   boolean   isSc (  )     {", "return   false ;", "}", "@ Override", "public   Object   getTarget (  )     {", "return   getResource ( element ,    requestingBeanName )  ;", "}", "@ Override", "public   void   releaseTarget ( Object   target )     {", "}", "}  ;", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTargetSource ( ts )  ;", "if    ( element . lookupType . isInterface (  )  )     {", "pf . addInterface ( element . lookupType )  ;", "}", "ClassLoader   classLoader    =     (  ( this . beanFactory )    instanceof   ConfigurableBeanFactory )     ?     (  ( ConfigurableBeanFactory )     ( this . beanFactory )  )  . getBeanClassLoader (  )     :    null ;", "return   pf . getProxy ( classLoader )  ;", "}", "METHOD_END"], "methodName": ["buildLazyResourceProxy"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "LinkedList < InjectionMetadata . InjectedElement >    elements    =    new   LinkedList <  >  (  )  ;", "Class <  ?  >    targetClass    =    clazz ;", "do    {", "final   LinkedList < InjectionMetadata . InjectedElement >    currElements    =    new   LinkedList <  >  (  )  ;", "ReflectionUtils . doWithLocalFields ( targetClass ,     (    field )     -  >     {", "if    (  (  (  . webServiceRefClass )     !  =    null )     &  &     ( field . isAnnotationPresent (  . webServiceRefClass )  )  )     {", "if    ( Modifier . isStatic ( field . getModifiers (  )  )  )     {", "throw   new   IllegalStateException (  \"  @ WebServiceRef   annotation   is   not   supported   on   static   fields \"  )  ;", "}", "currElements . add ( new   WebServiceRefElement ( field ,    field ,    null )  )  ;", "} else", "if    (  (  (  . ejbRefClass )     !  =    null )     &  &     ( field . isAnnotationPresent (  . ejbRefClass )  )  )     {", "if    ( Modifier . isStatic ( field . getModifiers (  )  )  )     {", "throw   new   IllegalStateException (  \"  @ EJB   annotation   is   not   supported   on   static   fields \"  )  ;", "}", "currElements . add ( new   EjbRefElement ( field ,    field ,    null )  )  ;", "} else", "if    ( field . isAnnotationPresent (  . class )  )     {", "if    ( Modifier . isStatic ( field . getModifiers (  )  )  )     {", "throw   new   IllegalStateException (  \"  @ Resource   annotation   is   not   supported   on   static   fields \"  )  ;", "}", "if    (  !  ( ignoredResourceTypes . contains ( field . getType (  )  . getName (  )  )  )  )     {", "currElements . add ( new   ResourceElement ( field ,    field ,    null )  )  ;", "}", "}", "}  )  ;", "ReflectionUtils . doWithLocalMethods ( targetClass ,     (    method )     -  >     {", "Method   bridgedMethod    =    BridgeMethodResolver . findBridgedMethod ( method )  ;", "if    (  !  ( BridgeMethodResolver . isVisibilityBridgeMethodPair ( method ,    bridgedMethod )  )  )     {", "return ;", "}", "if    ( method . equals ( ClassUtils . getMostSpecificMethod ( method ,    clazz )  )  )     {", "if    (  (  (  . webServiceRefClass )     !  =    null )     &  &     ( bridgedMethod . isAnnotationPresent (  . webServiceRefClass )  )  )     {", "if    ( Modifier . isStatic ( method . getModifiers (  )  )  )     {", "throw   new   IllegalStateException (  \"  @ WebServiceRef   annotation   is   not   supported   on   static   methods \"  )  ;", "}", "if    (  ( method . getParameterCount (  )  )     !  =     1  )     {", "throw   new   IllegalStateException (  (  \"  @ WebServiceRef   annotation   requires   a   single - arg   method :     \"     +    method )  )  ;", "}", "PropertyDescriptor   pd    =    BeanUtils . findPropertyForMethod ( bridgedMethod ,    clazz )  ;", "currElements . add ( new   WebServiceRefElement ( method ,    bridgedMethod ,    pd )  )  ;", "} else", "if    (  (  (  . ejbRefClass )     !  =    null )     &  &     ( bridgedMethod . isAnnotationPresent (  . ejbRefClass )  )  )     {", "if    ( Modifier . isStatic ( method . getModifiers (  )  )  )     {", "throw   new   IllegalStateException (  \"  @ EJB   annotation   is   not   supported   on   static   methods \"  )  ;", "}", "if    (  ( method . getParameterCount (  )  )     !  =     1  )     {", "throw   new   IllegalStateException (  (  \"  @ EJB   annotation   requires   a   single - arg   method :     \"     +    method )  )  ;", "}", "PropertyDescriptor   pd    =    BeanUtils . findPropertyForMethod ( bridgedMethod ,    clazz )  ;", "currElements . add ( new   EjbRefElement ( method ,    bridgedMethod ,    pd )  )  ;", "} else", "if    ( bridgedMethod . isAnnotationPresent (  . class )  )     {", "if    ( Modifier . isStatic ( method . getModifiers (  )  )  )     {", "throw   new   IllegalStateException (  \"  @ Resource   annotation   is   not   supported   on   static   methods \"  )  ;", "}", "Class <  ?  >  [  ]  <  ?  >    paramTypes    =    method . getParameterTypes (  )  ;", "if    ( paramTypes . length    !  =     1  )     {", "throw   new   IllegalStateException (  (  \"  @ Resource   annotation   requires   a   single - arg   method :     \"     +    method )  )  ;", "}", "if    (  !  ( ignoredResourceTypes . contains ( paramTypes [  0  ]  . getName (  )  )  )  )     {", "PropertyDescriptor   pd    =    BeanUtils . findPropertyForMethod ( bridgedMethod ,    clazz )  ;", "currElements . add ( new   ResourceElement ( method ,    bridgedMethod ,    pd )  )  ;", "}", "}", "}", "}  )  ;", "elements . addAll (  0  ,    currElements )  ;", "targetClass    =    targetClass . getSuperclass (  )  ;", "}    while    (  ( targetClass    !  =    null )     &  &     ( targetClass    !  =     ( Object . class )  )     )  ;", "return   new   InjectionMetadata ( clazz ,    elements )  ;", "}", "METHOD_END"], "methodName": ["buildResourceMetadata"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "String   cacheKey    =     ( StringUtils . hasLength ( beanName )  )     ?    beanName    :    clazz . getName (  )  ;", "InjectionMetadata   metadata    =    this . injectionMetadataCache . get ( cacheKey )  ;", "if    ( InjectionMetadata . needsRefresh ( metadata ,    clazz )  )     {", "synchronized ( this . injectionMetadataCache )     {", "metadata    =    this . injectionMetadataCache . get ( cacheKey )  ;", "if    ( InjectionMetadata . needsRefresh ( metadata ,    clazz )  )     {", "if    ( metadata    !  =    null )     {", "metadata . clear ( pvs )  ;", "}", "metadata    =    buildResourceMetadata ( clazz )  ;", "this . injectionMetadataCache . put ( cacheKey ,    metadata )  ;", "}", "}", "}", "return   metadata ;", "}", "METHOD_END"], "methodName": ["findResourceMetadata"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasLength ( element . mappedName )  )     {", "return   this . jndiFactory . getBean ( element . mappedName ,    element . lookupType )  ;", "}", "if    ( this . alwaysUseJndiLookup )     {", "return   this . jndiFactory . getBean ( element . name ,    element . lookupType )  ;", "}", "if    (  ( this . resourceFactory )     =  =    null )     {", "throw   new   NoSuchBeanDefinitionException ( element . lookupType ,     \" No   resource   factory   configured    -    specify   the    ' resourceFactory '    property \"  )  ;", "}", "return   autowireResource ( this . resourceFactory ,    element ,    requestingBeanName )  ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceType ,     \" Ignored   resource   type   must   not   be   null \"  )  ;", "this . ignoredResourceTypes . add ( resourceType )  ;", "}", "METHOD_END"], "methodName": ["ignoreResourceType"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . alwaysUseJndiLookup    =    alwaysUseJndiLookup ;", "}", "METHOD_END"], "methodName": ["setAlwaysUseJndiLookup"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . fallbackToDefaultTypeMatch    =    fallbackToDefaultTypeMatch ;", "}", "METHOD_END"], "methodName": ["setFallbackToDefaultTypeMatch"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( jndiFactory ,     \" BeanFactory   must   not   be   null \"  )  ;", "this . jndiFactory    =    jndiFactory ;", "}", "METHOD_END"], "methodName": ["setJndiFactory"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceFactory ,     \" BeanFactory   must   not   be   null \"  )  ;", "this . resourceFactory    =    resourceFactory ;", "}", "METHOD_END"], "methodName": ["setResourceFactory"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ExtendedEjbInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", "TestBean   tb 3     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 3  \"  ,    tb 3  )  ;", "TestBean   tb 4     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 4  \"  ,    tb 4  )  ;", "NestedTestBean   tb 6     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" xy \"  ,    tb 6  )  ;", "bf . registerAlias (  \" xy \"  ,     \" testBean 9  \"  )  ;", ". ExtendedEjbInjectionBean   bean    =     (  (  . ExtendedEjbInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "assertTrue ( bean . init 2 Called )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb 2  ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb 4  ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb 3  ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( tb 6  ,    bean . testBean 5  )  ;", "assertSame ( tb 6  ,    bean . testBean 6  )  ;", "assertSame ( bf ,    bean . beanFactory )  ;", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "assertTrue ( bean . destroy 2 Called )  ;", "}", "METHOD_END"], "methodName": ["testExtendedEjbInjection"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb \"  ,     \" testBean 3  \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ExtendedResourceInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" annotatedBean 2  \"  ,    new   RootBeanDefinition (  . NamedResourceInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" annotatedBean 3  \"  ,    new   RootBeanDefinition (  . ConvertedResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", "TestBean   tb 3     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 3  \"  ,    tb 3  )  ;", "TestBean   tb 4     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 4  \"  ,    tb 4  )  ;", "NestedTestBean   tb 6     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" value \"  ,     \"  5  \"  )  ;", "bf . registerSingleton (  \" xy \"  ,    tb 6  )  ;", "bf . registerAlias (  \" xy \"  ,     \" testBean 9  \"  )  ;", ". ExtendedResourceInjectionBean   bean    =     (  (  . ExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "assertTrue ( bean . init 2 Called )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb 2  ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb 4  ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb 3  ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( tb 6  ,    bean . testBean 5  )  ;", "assertSame ( tb 6  ,    bean . testBean 6  )  ;", "assertSame ( bf ,    bean . beanFactory )  ;", ". NamedResourceInjectionBean   bean 2     =     (  (  . NamedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean 2  \"  )  )  )  ;", "assertSame ( tb 6  ,    bean 2  . testBean )  ;", ". ConvertedResourceInjectionBean   bean 3     =     (  (  . ConvertedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean 3  \"  )  )  )  ;", "assertSame (  5  ,    bean 3  . value )  ;", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "assertTrue ( bean . destroy 2 Called )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjection"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb \"  ,     \" testBean 3  \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "RootBeanDefinition   annotatedBd    =    new   RootBeanDefinition (  . ExtendedResourceInjectionBean . class )  ;", "TestBean   tb 5     =    new   TestBean (  )  ;", "annotatedBd . getPropertyValues (  )  . add (  \" testBean 2  \"  ,    tb 5  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    annotatedBd )  ;", "bf . registerBeanDefinition (  \" annotatedBean 2  \"  ,    new   RootBeanDefinition (  . NamedResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", "TestBean   tb 3     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 3  \"  ,    tb 3  )  ;", "TestBean   tb 4     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 4  \"  ,    tb 4  )  ;", "NestedTestBean   tb 6     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" xy \"  ,    tb 6  )  ;", ". ExtendedResourceInjectionBean   bean    =     (  (  . ExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "assertTrue ( bean . init 2 Called )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb 5  ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb 4  ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb 3  ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( tb 6  ,    bean . testBean 5  )  ;", "assertSame ( tb 6  ,    bean . testBean 6  )  ;", "assertSame ( bf ,    bean . beanFactory )  ;", "try    {", "bf . getBean (  \" annotatedBean 2  \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getRootCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "NoSuchBeanDefinitionException   innerEx    =     (  ( NoSuchBeanDefinitionException )     ( ex . getRootCause (  )  )  )  ;", "assertEquals (  \" testBean 9  \"  ,    innerEx . getBeanName (  )  )  ;", "}", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "assertTrue ( bean . destroy 2 Called )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjectionWithOverriding"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . LazyResourceCglibInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". LazyResourceCglibInjectionBean   bean    =     (  (  . LazyResourceCglibInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bf . containsSingleton (  \" testBean \"  )  )  ;", "bean . testBean . setName (  \" notLazyAnymore \"  )  ;", "assertTrue ( bf . containsSingleton (  \" testBean \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" notLazyAnymore \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLazyResolutionWithCglibProxy"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . LazyResourceFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". LazyResourceFieldInjectionBean   bean    =     (  (  . LazyResourceFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bf . containsSingleton (  \" testBean \"  )  )  ;", "bean . testBean . setName (  \" notLazyAnymore \"  )  ;", "assertTrue ( bf . containsSingleton (  \" testBean \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" notLazyAnymore \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLazyResolutionWithResourceField"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . LazyResourceMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". LazyResourceMethodInjectionBean   bean    =     (  (  . LazyResourceMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bf . containsSingleton (  \" testBean \"  )  )  ;", "bean . testBean . setName (  \" notLazyAnymore \"  )  ;", "assertTrue ( bf . containsSingleton (  \" testBean \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" notLazyAnymore \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLazyResolutionWithResourceMethod"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . addBeanPostProcessor ( new   CommonAnnotationBeanPostProcessor (  )  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . AnnotatedInitDestroyBean . class )  )  ;", ". AnnotatedInitDestroyBean   bean    =     (  (  . AnnotatedInitDestroyBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "}", "METHOD_END"], "methodName": ["testPostConstructAndPreDestroy"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" bpp 1  \"  ,    new   RootBeanDefinition (  . InitDestroyBeanPostProcessor . class )  )  ;", "ctx . registerBeanDefinition (  \" bpp 2  \"  ,    new   RootBeanDefinition ( CommonAnnotationBeanPostProcessor . class )  )  ;", "ctx . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . AnnotatedInitDestroyBean . class )  )  ;", "ctx . refresh (  )  ;", ". AnnotatedInitDestroyBean   bean    =     (  (  . AnnotatedInitDestroyBean )     ( ctx . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "ctx . close (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "}", "METHOD_END"], "methodName": ["testPostConstructAndPreDestroyWithApplicationContextAndPostProcessor"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "InitDestroyAnnotationBeanPostProcessor   bpp    =    new   InitDestroyAnnotationBeanPostProcessor (  )  ;", "bpp . setInitAnnotationType ( PostConstruct . class )  ;", "bpp . setDestroyAnnotationType ( PreDestroy . class )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . AnnotatedInitDestroyBean . class )  )  ;", ". AnnotatedInitDestroyBean   bean    =     (  (  . AnnotatedInitDestroyBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "}", "METHOD_END"], "methodName": ["testPostConstructAndPreDestroyWithManualConfiguration"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . addBeanPostProcessor ( new    . InitDestroyBeanPostProcessor (  )  )  ;", "bf . addBeanPostProcessor ( new   CommonAnnotationBeanPostProcessor (  )  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . AnnotatedInitDestroyBean . class )  )  ;", ". AnnotatedInitDestroyBean   bean    =     (  (  . AnnotatedInitDestroyBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "}", "METHOD_END"], "methodName": ["testPostConstructAndPreDestroyWithPostProcessor"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . addBeanPostProcessor ( new   CommonAnnotationBeanPostProcessor (  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . NullFactory . class )  ;", "rbd . setFactoryMethodName (  \" create \"  )  ;", "bf . registerBeanDefinition (  \" bean \"  ,    rbd )  ;", "assertEquals (  \" null \"  ,    bf . getBean (  \" bean \"  )  . toString (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testPostProcessorWithNullBean"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setResourceFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", ". ResourceInjectionBean   bean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "assertTrue ( bean . init 2 Called )  ;", "assertTrue ( bean . init 3 Called )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb 2  ,    bean . getTestBean 2  (  )  )  ;", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "assertTrue ( bean . destroy 2 Called )  ;", "assertTrue ( bean . destroy 3 Called )  ;", "}", "METHOD_END"], "methodName": ["testResourceInjection"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "SimpleJndiBeanFactory   resourceFactory    =    new   SimpleJndiBeanFactory (  )  ;", "ExpectedLookupTemplate   jndiTemplate    =    new   ExpectedLookupTemplate (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "jndiTemplate . addObject (  \" java : comp / env / testBean \"  ,    tb )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "jndiTemplate . addObject (  \" java : comp / env / testBean 2  \"  ,    tb 2  )  ;", "resourceFactory . setJndiTemplate ( jndiTemplate )  ;", "bpp . setResourceFactory ( resourceFactory )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ResourceInjectionBean . class )  )  ;", ". ResourceInjectionBean   bean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "assertTrue ( bean . init 2 Called )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb 2  ,    bean . getTestBean 2  (  )  )  ;", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "assertTrue ( bean . destroy 2 Called )  ;", "}", "METHOD_END"], "methodName": ["testResourceInjectionFromJndi"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . DefaultMethodResourceInjectionBean . class )  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", "NestedTestBean   tb 7     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" testBean 7  \"  ,    tb 7  )  ;", ". DefaultMethodResourceInjectionBean   bean    =     (  (  . DefaultMethodResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb 2  ,    bean . getTestBean 2  (  )  )  ;", "assertSame (  2  ,    bean . counter )  ;", "bf . destroySingletons (  )  ;", "assertSame (  3  ,    bean . counter )  ;", "}", "METHOD_END"], "methodName": ["testResourceInjectionWithDefaultMethod"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setResourceFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   abd    =    new   RootBeanDefinition (  . ResourceInjectionBean . class )  ;", "abd . setScope ( SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    abd )  ;", "RootBeanDefinition   tbd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "tbd 1  . setScope ( SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    tbd 1  )  ;", "RootBeanDefinition   tbd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "tbd 2  . setScope ( SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    tbd 2  )  ;", ". ResourceInjectionBean   bean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "assertTrue ( bean . init 2 Called )  ;", "assertTrue ( bean . init 3 Called )  ;", "TestBean   tb    =    bean . getTestBean (  )  ;", "TestBean   tb 2     =    bean . getTestBean 2  (  )  ;", "assertNotNull ( tb )  ;", "assertNotNull ( tb 2  )  ;", ". ResourceInjectionBean   anotherBean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNotSame ( anotherBean ,    bean )  ;", "assertNotSame ( anotherBean . getTestBean (  )  ,    tb )  ;", "assertNotSame ( anotherBean . getTestBean 2  (  )  ,    tb 2  )  ;", "bf . destroyBean (  \" annotatedBean \"  ,    bean )  ;", "assertTrue ( bean . destroyCalled )  ;", "assertTrue ( bean . destroy 2 Called )  ;", "assertTrue ( bean . destroy 3 Called )  ;", "}", "METHOD_END"], "methodName": ["testResourceInjectionWithPrototypes"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   abd    =    new   RootBeanDefinition (  . ExtendedResourceInjectionBean . class )  ;", "abd . setScope ( SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    abd )  ;", "RootBeanDefinition   tbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "tbd . setScope ( SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" testBean 4  \"  ,    tbd )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "bf . registerResolvableDependency ( INestedTestBean . class ,    new   ObjectFactory < Object >  (  )     {", "@ Override", "public   Object   getObject (  )    throws   BeansException    {", "return   new   NestedTestBean (  )  ;", "}", "}  )  ;", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb \"  ,     \" testBean 4  \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( bf )  ;", ". ExtendedResourceInjectionBean   bean    =     (  (  . ExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "INestedTestBean   tb    =    bean . getTestBean 6  (  )  ;", "assertNotNull ( tb )  ;", ". ExtendedResourceInjectionBean   anotherBean    =     (  (  . ExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNotSame ( anotherBean ,    bean )  ;", "assertNotSame ( anotherBean . getTestBean 6  (  )  ,    tb )  ;", "String [  ]    depBeans    =    bf . getDependenciesForBean (  \" annotatedBean \"  )  ;", "assertEquals (  1  ,    depBeans . length )  ;", "assertEquals (  \" testBean 4  \"  ,    depBeans [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testResourceInjectionWithResolvableDependencyType"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp . setResourceFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "CommonAnnotationBeanPostProcessor   bpp 2     =    new   CommonAnnotationBeanPostProcessor (  )  ;", "bpp 2  . setResourceFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp 2  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", ". ResourceInjectionBean   bean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . initCalled )  ;", "assertTrue ( bean . init 2 Called )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb 2  ,    bean . getTestBean 2  (  )  )  ;", "bf . destroySingletons (  )  ;", "assertTrue ( bean . destroyCalled )  ;", "assertTrue ( bean . destroy 2 Called )  ;", "}", "METHOD_END"], "methodName": ["testResourceInjectionWithTwoProcessors"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CommonAnnotationBeanPostProcessor   bpp    =    new   CommonAnnotationBeanPostProcessor (  )  ;", "CommonAnnotationBeanPostProcessor   bpp 2     =     (  ( CommonAnnotationBeanPostProcessor )     ( SerializationTestUtils . serializeAndDeserialize ( bpp )  )  )  ;", ". AnnotatedInitDestroyBean   bean    =    new    . AnnotatedInitDestroyBean (  )  ;", "bpp 2  . postProcessBeforeDestruction ( bean ,     \" annotatedBean \"  )  ;", "assertTrue ( bean . destroyCalled )  ;", "}", "METHOD_END"], "methodName": ["testSerialization"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "InitDestroyAnnotationBeanPostProcessor   bpp    =    new   InitDestroyAnnotationBeanPostProcessor (  )  ;", "bpp . setInitAnnotationType ( PostConstruct . class )  ;", "bpp . setDestroyAnnotationType ( PreDestroy . class )  ;", "InitDestroyAnnotationBeanPostProcessor   bpp 2     =     (  ( InitDestroyAnnotationBeanPostProcessor )     ( SerializationTestUtils . serializeAndDeserialize ( bpp )  )  )  ;", ". AnnotatedInitDestroyBean   bean    =    new    . AnnotatedInitDestroyBean (  )  ;", "bpp 2  . postProcessBeforeDestruction ( bean ,     \" annotatedBean \"  )  ;", "assertTrue ( bean . destroyCalled )  ;", "}", "METHOD_END"], "methodName": ["testSerializationWithManualConfiguration"], "fileName": "org.springframework.context.annotation.CommonAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( ImportingConfig . class . getName (  )  )  )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( SimpleComponent . class )  ;", "}", "METHOD_END"], "methodName": ["circularImportViaComponentScan"], "fileName": "org.springframework.context.annotation.ComponentScanAndImportAnnotationInteractionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . Config 1  . class )  ;", "ctx . register (  . Config 2  . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( SimpleComponent . class )  ;", "}", "METHOD_END"], "methodName": ["componentScanOverlapsWithImport"], "fileName": "org.springframework.context.annotation.ComponentScanAndImportAnnotationInteractionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" config 1  \"  ,    new   RootBeanDefinition (  . Config 1  . class . getName (  )  )  )  ;", "ctx . registerBeanDefinition (  \" config 2  \"  ,    new   RootBeanDefinition (  . Config 2  . class . getName (  )  )  )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( SimpleComponent . class )  ;", "}", "METHOD_END"], "methodName": ["componentScanOverlapsWithImportUsingAsm"], "fileName": "org.springframework.context.annotation.ComponentScanAndImportAnnotationInteractionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . Config 3  . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( SimpleComponent . class )  ;", "}", "METHOD_END"], "methodName": ["componentScanViaImport"], "fileName": "org.springframework.context.annotation.ComponentScanAndImportAnnotationInteractionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . Config 3  . class . getName (  )  )  )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( SimpleComponent . class )  ;", "}", "METHOD_END"], "methodName": ["componentScanViaImportUsingAsm"], "fileName": "org.springframework.context.annotation.ComponentScanAndImportAnnotationInteractionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . scan (  \" componentscan . importing \"  )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( SimpleComponent . class )  ;", "}", "METHOD_END"], "methodName": ["componentScanViaImportUsingScan"], "fileName": "org.springframework.context.annotation.ComponentScanAndImportAnnotationInteractionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  )  ;", "}", "METHOD_END"], "methodName": ["testBean"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotatedConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  )  ;", "}", "METHOD_END"], "methodName": ["testBean"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotatedConfig_WithValueAttribute"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . scan (  _ package . class . getPackage (  )  . getName (  )  )  ;", "ctx . refresh (  )  ;", "assertThat (  \" control   scan   for   example . scannable   package   failed   to   register   FooServiceImpl   bean \"  ,    ctx . containsBean (  \" fooServiceImpl \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["controlScan"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( MultiComponentScan . class )  ;", "assertThat ( ctx . getBean ( CustomScopeAnnotationBean . class )  ,    not ( sameInstance ( ctx . getBean ( CustomScopeAnnotationBean . class )  )  )  )  ;", "assertThat ( ctx . containsBean (  \" scannedComponent \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["multiComponentScan"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" componentScanAnnotatedConfig \"  ,    genericBeanDefinition ( edConfig . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" configurationClassPostProcessor \"  ,    genericBeanDefinition ( ConfigurationClassPostProcessor . class )  . getBeanDefinition (  )  )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext ( bf )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( edConfig . class )  ;", "ctx . getBean ( TestBean . class )  ;", "assertThat (  \" config   class   bean   not   found \"  ,    ctx . containsBeanDefinition (  \" componentScanAnnotatedConfig \"  )  ,    is ( true )  )  ;", "assertThat (  (  \"  @ ComponentScan   annotated    @ Configuration   class   registered    \"     +     \" as   bean   definition   did   not   trigger   component   scanning   as   expected \"  )  ,    ctx . containsBean (  \" fooServiceImpl \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["viaBeanRegistration"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( edConfig . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( edConfig . class )  ;", "ctx . getBean ( TestBean . class )  ;", "assertThat (  \" config   class   bean   not   found \"  ,    ctx . containsBeanDefinition (  \" componentScanAnnotatedConfig \"  )  ,    is ( true )  )  ;", "assertThat (  (  \"  @ ComponentScan   annotated    @ Configuration   class   registered   directly   against    \"     +     \" AnnotationConfigApplicationContext   did   not   trigger   component   scanning   as   expected \"  )  ,    ctx . containsBean (  \" fooServiceImpl \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["viaContextRegistration"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( edConfigWithImplicitBasePackage . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( edConfigWithImplicitBasePackage . class )  ;", "assertThat (  \" config   class   bean   not   found \"  ,    ctx . containsBeanDefinition (  \" componentScanAnnotatedConfigWithImplicitBasePackage \"  )  ,    is ( true )  )  ;", "assertThat (  (  \"  @ ComponentScan   annotated    @ Configuration   class   registered   directly   against    \"     +     \" AnnotationConfigApplicationContext   did   not   trigger   component   scanning   as   expected \"  )  ,    ctx . containsBean (  \" scannedComponent \"  )  ,    is ( true )  )  ;", "assertThat (  \"  @ Bean   method   overrides   scanned   class \"  ,    ctx . getBean ( ConfigurableComponent . class )  . isFlag (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["viaContextRegistration_FromPackageOfConfigClass"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ComposedAnnotationConfig . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean (  . ComposedAnnotationConfig . class )  ;", "ctx . getBean ( SimpleComponent . class )  ;", "ctx . getBean ( ClassWithNestedComponents . NestedComponent . class )  ;", "ctx . getBean ( ClassWithNestedComponents . OtherNestedComponent . class )  ;", "assertThat (  \" config   class   bean   not   found \"  ,    ctx . containsBeanDefinition (  \" componentScanAnnotationIntegrationTests . ComposedAnnotationConfig \"  )  ,    is ( true )  )  ;", "assertThat (  (  \"  @ ComponentScan   annotated    @ Configuration   class   registered   directly   against    \"     +     \" AnnotationConfigApplicationContext   did   not   trigger   component   scanning   as   expected \"  )  ,    ctx . containsBean (  \" simpleComponent \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["viaContextRegistration_WithComposedAnnotation"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( edConfig _ WithValueAttribute . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( edConfig _ WithValueAttribute . class )  ;", "ctx . getBean ( TestBean . class )  ;", "assertThat (  \" config   class   bean   not   found \"  ,    ctx . containsBeanDefinition (  \" componentScanAnnotatedConfig _ WithValueAttribute \"  )  ,    is ( true )  )  ;", "assertThat (  (  \"  @ ComponentScan   annotated    @ Configuration   class   registered   directly   against    \"     +     \" AnnotationConfigApplicationContext   did   not   trigger   component   scanning   as   expected \"  )  ,    ctx . containsBean (  \" fooServiceImpl \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["viaContextRegistration_WithValueAttribute"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ComponentScanWithAwareTypeFilter . class )  ;", "assertTrue ( ctx . getEnvironment (  )  . acceptsProfiles (  \" the - filter - ran \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withAwareTypeFilter"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( WithBasePackagesAndValueAlias . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" fooServiceImpl \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withBasePackagesAndValueAlias"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( WithBeanNameGenerator . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" custom _ fooServiceImpl \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" fooServiceImpl \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomBeanNameGenerator"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ComponentScanWithCustomTypeFilter . class )  ;", "assertFalse ( ctx . getDefaultListableBeanFactory (  )  . containsSingleton (  \" componentScanParserTests . KustomAnnotationAutowiredBean \"  )  )  ;", "ComponentScanParserTests . KustomAnnotationAutowiredBean   testBean    =    ctx . getBean (  \" componentScanParserTests . KustomAnnotationAutowiredBean \"  ,    ComponentScanParserTests . KustomAnnotationAutowiredBean . class )  ;", "assertThat ( testBean . getDependency (  )  ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomTypeFilter"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( WithMultipleAnnotationIncludeFilters 1  . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( DefaultNamedComponent . class )  ;", "ctx . getBean ( MessageBean . class )  ;", "}", "METHOD_END"], "methodName": ["withMultipleAnnotationIncludeFilters1"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( WithMultipleAnnotationIncludeFilters 2  . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( DefaultNamedComponent . class )  ;", "ctx . getBean ( MessageBean . class )  ;", "}", "METHOD_END"], "methodName": ["withMultipleAnnotationIncludeFilters2"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ComponentScanWithScopeResolver . class )  ;", "assertThat ( ctx . getBean ( CustomScopeAnnotationBean . class )  ,    not ( sameInstance ( ctx . getBean ( CustomScopeAnnotationBean . class )  )  )  )  ;", "assertThat ( ctx . containsBean (  \" scannedComponent \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["withScopeResolver"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( WithScopedProxy . class )  ;", "ctx . getBeanFactory (  )  . registerScope (  \" myScope \"  ,    new   SimpleMapScope (  )  )  ;", "ctx . refresh (  )  ;", "FooService   bean    =     (  ( FooService )     ( ctx . getBean (  \" scopedProxyTestBean \"  )  )  )  ;", "assertThat ( AopUtils . isJdkDynamicProxy ( bean )  ,    is ( true )  )  ;", "assertThat ( bean . foo (  1  )  ,    equalTo (  \" bar \"  )  )  ;", "FooService   deserialized    =     (  ( FooService )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertThat ( deserialized ,    notNullValue (  )  )  ;", "assertThat ( deserialized . foo (  1  )  ,    equalTo (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withScopedProxy"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( WithScopedProxyThroughAspectJPattern . class )  ;", "ctx . getBeanFactory (  )  . registerScope (  \" myScope \"  ,    new   SimpleMapScope (  )  )  ;", "ctx . refresh (  )  ;", "FooService   bean    =     (  ( FooService )     ( ctx . getBean (  \" scopedProxyTestBean \"  )  )  )  ;", "assertThat ( AopUtils . isJdkDynamicProxy ( bean )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withScopedProxyThroughAspectJPattern"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( WithScopedProxyThroughRegex . class )  ;", "ctx . getBeanFactory (  )  . registerScope (  \" myScope \"  ,    new   SimpleMapScope (  )  )  ;", "ctx . refresh (  )  ;", "FooService   bean    =     (  ( FooService )     ( ctx . getBean (  \" scopedProxyTestBean \"  )  )  )  ;", "assertThat ( AopUtils . isJdkDynamicProxy ( bean )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withScopedProxyThroughRegex"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathBeanDefinitionScanner   scanner    =    new   ClassPathBeanDefinitionScanner ( this . registry ,    componentScan . getBoolean (  \" useDefaultFilters \"  )  ,    this . environment ,    this . resourceLoader )  ;", "Class <  ?    extends   BeanNameGenerator >    generatorClass    =    componentScan . getClass (  \" nameGenerator \"  )  ;", "boolean   useInheritedGenerator    =     ( BeanNameGenerator . class )     =  =    generatorClass ;", "scanner . setBeanNameGenerator (  ( useInheritedGenerator    ?    this . beanNameGenerator    :    BeanUtils . instantiateClass ( generatorClass )  )  )  ;", "ScopedProxyMode   scopedProxyMode    =    componentScan . getEnum (  \" scopedProxy \"  )  ;", "if    ( scopedProxyMode    !  =     ( ScopedProxyMode . DEFAULT )  )     {", "scanner . setScopedProxyMode ( scopedProxyMode )  ;", "} else    {", "Class <  ?    extends   ScopeMetadataResolver >    resolverClass    =    componentScan . getClass (  \" scopeResolver \"  )  ;", "scanner . setScopeMetadataResolver ( BeanUtils . instantiateClass ( resolverClass )  )  ;", "}", "scanner . setResourcePattern ( componentScan . getString (  \" resourcePattern \"  )  )  ;", "for    ( AnnotationAttributes   filter    :    componentScan . getAnnotationArray (  \" includeFilters \"  )  )     {", "for    ( TypeFilter   typeFilter    :    typeFiltersFor ( filter )  )     {", "scanner . addIncludeFilter ( typeFilter )  ;", "}", "}", "for    ( AnnotationAttributes   filter    :    componentScan . getAnnotationArray (  \" excludeFilters \"  )  )     {", "for    ( TypeFilter   typeFilter    :    typeFiltersFor ( filter )  )     {", "scanner . addExcludeFilter ( typeFilter )  ;", "}", "}", "boolean   lazyInit    =    componentScan . getBoolean (  \" lazyInit \"  )  ;", "if    ( lazyInit )     {", "scanner . getBeanDefinitionDefaults (  )  . setLazyInit ( true )  ;", "}", "Set < String >    basePackages    =    new   LinkedHashSet <  >  (  )  ;", "String [  ]    basePackagesArray    =    componentScan . getStringArray (  \" basePackages \"  )  ;", "for    ( String   pkg    :    basePackagesArray )     {", "String [  ]    tokenized    =    StringUtils . tokenizeToStringArray ( this . environment . resolvePlaceholders ( pkg )  ,    ConfigurableApplicationContext . CONFIG _ LOCATION _ DELIMITERS )  ;", "Collections . addAll ( basePackages ,    tokenized )  ;", "}", "for    ( Class <  ?  >    clazz    :    componentScan . getClassArray (  \" basePackageClasses \"  )  )     {", "basePackages . add ( ClassUtils . getPackageName ( clazz )  )  ;", "}", "if    ( basePackages . isEmpty (  )  )     {", "basePackages . add ( ClassUtils . getPackageName ( declaringClass )  )  ;", "}", "scanner . addExcludeFilter ( new   AbstractTypeHierarchyTraversingFilter ( false ,    false )     {", "@ Override", "protected   boolean   matchClassName ( String   className )     {", "return   declaringClass . equals ( className )  ;", "}", "}  )  ;", "return   scanner . doScan ( StringUtils . toStringArray ( basePackages )  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "List < TypeFilter >    typeFilters    =    new   ArrayList <  >  (  )  ;", "FilterType   filterType    =    filterAttributes . getEnum (  \" type \"  )  ;", "for    ( Class <  ?  >    filterClass    :    filterAttributes . getClassArray (  \" classes \"  )  )     {", "switch    ( filterType )     {", "case   ANNOTATION    :", "Assert . isAssignable ( Annotation . class ,    filterClass ,     \"  @ ComponentScan   ANNOTATION   type   filter   requires   an   annotation   type \"  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Class < Annotation >    annotationType    =     (  ( Class < Annotation >  )     ( filterClass )  )  ;", "typeFilters . add ( new   AnnotationTypeFilter ( annotationType )  )  ;", "break ;", "case   ASSIGNABLE _ TYPE    :", "typeFilters . add ( new   AssignableTypeFilter ( filterClass )  )  ;", "break ;", "case   CUSTOM    :", "Assert . isAssignable ( TypeFilter . class ,    filterClass ,     \"  @ ComponentScan   CUSTOM   type   filter   requires   a   TypeFilter   implementation \"  )  ;", "TypeFilter   filter    =    BeanUtils . instantiateClass ( filterClass ,    TypeFilter . class )  ;", "ParserStrategyUtils . invokeAwareMethods ( filter ,    this . environment ,    this . resourceLoader ,    this . registry )  ;", "typeFilters . add ( filter )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Filter   type   not   supported   with   Class   value :     \"     +    filterType )  )  ;", "}", "}", "for    ( String   expression    :    filterAttributes . getStringArray (  \" pattern \"  )  )     {", "switch    ( filterType )     {", "case   ASPECTJ    :", "typeFilters . add ( new   re . type . filter . AspectJTypeFilter ( expression ,    this . resourceLoader . getClassLoader (  )  )  )  ;", "break ;", "case   REGEX    :", "typeFilters . add ( new   RegexPatternTypeFilter ( Pattern . compile ( expression )  )  )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Filter   type   not   supported   with   String   pattern :     \"     +    filterType )  )  ;", "}", "}", "return   typeFilters ;", "}", "METHOD_END"], "methodName": ["typeFiltersFor"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( LeftConfig . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean (  \" leftConfig \"  )  ;", "ctx . getBean (  \" rightConfig \"  )  ;", "}", "METHOD_END"], "methodName": ["evenCircularScansAreSupported"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationRecursionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( Level 1 Config . class )  ;", "ctx . refresh (  )  ;", "ctx . getBean ( Level 1 Config . class )  ;", "ctx . getBean ( Level 2 Config . class )  ;", "ctx . getBean ( Level 3 Component . class )  ;", "assertThat ( ctx . getBean (  \" level 1 Bean \"  )  ,    sameInstance ( ctx . getBean (  \" level 1 Bean \"  )  )  )  ;", "assertThat ( ctx . getBean (  \" level 2 Bean \"  )  ,    sameInstance ( ctx . getBean (  \" level 2 Bean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["recursion"], "fileName": "org.springframework.context.annotation.ComponentScanAnnotationRecursionTests"}, {"methodBody": ["METHOD_START", "{", "boolean   useDefaultFilters    =    true ;", "if    ( element . hasAttribute (  . USE _ DEFAULT _ FILTERS _ ATTRIBUTE )  )     {", "useDefaultFilters    =    Boolean . valueOf ( element . getAttribute (  . USE _ DEFAULT _ FILTERS _ ATTRIBUTE )  )  ;", "}", "ClassPathBeanDefinitionScanner   scanner    =    createScanner ( parserContext . getReaderContext (  )  ,    useDefaultFilters )  ;", "scanner . setBeanDefinitionDefaults ( parserContext . getDelegate (  )  . getBeanDefinitionDefaults (  )  )  ;", "scanner . setAutowireCandidatePatterns ( parserContext . getDelegate (  )  . getAutowireCandidatePatterns (  )  )  ;", "if    ( element . hasAttribute (  . RESOURCE _ PATTERN _ ATTRIBUTE )  )     {", "scanner . setResourcePattern ( element . getAttribute (  . RESOURCE _ PATTERN _ ATTRIBUTE )  )  ;", "}", "try    {", "parseBeanNameGenerator ( element ,    scanner )  ;", "}    catch    ( Exception   ex )     {", "parserContext . getReaderContext (  )  . error ( ex . getMessage (  )  ,    parserContext . extractSource ( element )  ,    ex . getCause (  )  )  ;", "}", "try    {", "parseScope ( element ,    scanner )  ;", "}    catch    ( Exception   ex )     {", "parserContext . getReaderContext (  )  . error ( ex . getMessage (  )  ,    parserContext . extractSource ( element )  ,    ex . getCause (  )  )  ;", "}", "parseTypeFilters ( element ,    scanner ,    parserContext )  ;", "return   scanner ;", "}", "METHOD_END"], "methodName": ["configureScanner"], "fileName": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathBeanDefinitionScanner ( readerContext . getRegistry (  )  ,    useDefaultFilters ,    readerContext . getEnvironment (  )  ,    readerContext . getResourceLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["createScanner"], "fileName": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   filterType    =    element . getAttribute ( ComponentScanBeanDefinitionParser . FILTER _ TYPE _ ATTRIBUTE )  ;", "String   expression    =    element . getAttribute ( ComponentScanBeanDefinitionParser . FILTER _ EXPRESSION _ ATTRIBUTE )  ;", "expression    =    parserContext . getReaderContext (  )  . getEnvironment (  )  . resolvePlaceholders ( expression )  ;", "if    (  \" annotation \"  . equals ( filterType )  )     {", "return   new   AnnotationTypeFilter (  (  ( Class < Annotation >  )     ( ClassUtils . forName ( expression ,    classLoader )  )  )  )  ;", "} else", "if    (  \" assignable \"  . equals ( filterType )  )     {", "return   new   AssignableTypeFilter ( ClassUtils . forName ( expression ,    classLoader )  )  ;", "} else", "if    (  \" aspectj \"  . equals ( filterType )  )     {", "return   new   AspectJTypeFilter ( expression ,    classLoader )  ;", "} else", "if    (  \" regex \"  . equals ( filterType )  )     {", "return   new   RegexPatternTypeFilter ( compile ( expression )  )  ;", "} else", "if    (  \" custom \"  . equals ( filterType )  )     {", "Class <  ?  >    filterClass    =    ClassUtils . forName ( expression ,    classLoader )  ;", "if    (  !  ( isAssignableFrom ( filterClass )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Class   is   not   assignable   to    [  \"     +     ( getName (  )  )  )     +     \"  ]  :     \"  )     +    expression )  )  ;", "}", "return    (  ( TypeFilter )     ( instantiateClass ( filterClass )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unsupported   filter   type :     \"     +    filterType )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createTypeFilter"], "fileName": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Object   result ;", "try    {", "result    =    ReflectionUtils . accessibleConstructor ( ClassUtils . forName ( className ,    classLoader )  )  . newInstance (  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Class    [  \"     +    className )     +     \"  ]    for   strategy    [  \"  )     +     ( strategyType . getName (  )  )  )     +     \"  ]    not   found \"  )  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Unable   to   instantiate   class    [  \"     +    className )     +     \"  ]    for   strategy    [  \"  )     +     ( strategyType . getName (  )  )  )     +     \"  ]  :    a   zero - argument   constructor   is   required \"  )  ,    ex )  ;", "}", "if    (  !  ( strategyType . isAssignableFrom ( result . getClass (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Provided   class   name   must   be   an   implemen   of    \"     +    strategyType )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["instantiateUserDefinedStrategy"], "fileName": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( element . hasAttribute ( ComponentScanBeanDefinitionParser . NAME _ GENERATOR _ ATTRIBUTE )  )     {", "BeanNameGenerator   beanNameGenerator    =     (  ( BeanNameGenerator )     ( instantiateUserDefinedStrategy ( element . getAttribute ( ComponentScanBeanDefinitionParser . NAME _ GENERATOR _ ATTRIBUTE )  ,    BeanNameGenerator . class ,    scanner . getResourceLoader (  )  . getClassLoader (  )  )  )  )  ;", "scanner . setBeanNameGenerator ( beanNameGenerator )  ;", "}", "}", "METHOD_END"], "methodName": ["parseBeanNameGenerator"], "fileName": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( element . hasAttribute ( ComponentScanBeanDefinitionParser . SCOPE _ RESOLVER _ ATTRIBUTE )  )     {", "if    ( element . hasAttribute ( ComponentScanBeanDefinitionParser . SCOPED _ PROXY _ ATTRIBUTE )  )     {", "throw   new   IllegalArgumentException (  \" Cannot   define   both    ' scope - resolver '    and    ' scoped - proxy '    on    < component - scan >    tag \"  )  ;", "}", "ScopeMetadataResolver   scopeMetadataResolver    =     (  ( ScopeMetadataResolver )     ( instantiateUserDefinedStrategy ( element . getAttribute ( ComponentScanBeanDefinitionParser . SCOPE _ RESOLVER _ ATTRIBUTE )  ,    ScopeMetadataResolver . class ,    scanner . getResourceLoader (  )  . getClassLoader (  )  )  )  )  ;", "scanner . setScopeMetadataResolver ( scopeMetadataResolver )  ;", "}", "if    ( element . hasAttribute ( ComponentScanBeanDefinitionParser . SCOPED _ PROXY _ ATTRIBUTE )  )     {", "String   mode    =    element . getAttribute ( ComponentScanBeanDefinitionParser . SCOPED _ PROXY _ ATTRIBUTE )  ;", "if    (  \" targetClass \"  . equals ( mode )  )     {", "scanner . setScopedProxyMode ( ScopedProxyMode . TARGET _ CLASS )  ;", "} else", "if    (  \" interfaces \"  . equals ( mode )  )     {", "scanner . setScopedProxyMode ( ScopedProxyMode . INTERFACES )  ;", "} else", "if    (  \" no \"  . equals ( mode )  )     {", "scanner . setScopedProxyMode ( ScopedProxyMode . NO )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" scoped - proxy   only   supports    ' no '  ,     ' interfaces '    and    ' targetClass '  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseScope"], "fileName": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   classLoader    =    scanner . getResourceLoader (  )  . getClassLoader (  )  ;", "NodeList   nodeList    =    element . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nodeList . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nodeList . item ( i )  ;", "if    (  ( node . getNodeType (  )  )     =  =     ( Node . ELEMENT _ NODE )  )     {", "String   localName    =    parserContext . getDelegate (  )  . getLocalName ( node )  ;", "try    {", "if    (  . INCLUDE _ FILTER _ ELEMENT . equals ( localName )  )     {", "TypeFilter   typeFilter    =    createTypeFilter (  (  ( Element )     ( node )  )  ,    classLoader ,    parserContext )  ;", "scanner . addIncludeFilter ( typeFilter )  ;", "} else", "if    (  . EXCLUDE _ FILTER _ ELEMENT . equals ( localName )  )     {", "TypeFilter   typeFilter    =    createTypeFilter (  (  ( Element )     ( node )  )  ,    classLoader ,    parserContext )  ;", "scanner . addExcludeFilter ( typeFilter )  ;", "}", "}    catch    ( ClassNotFoundException   ex )     {", "parserContext . getReaderContext (  )  . warning (  (  \" Ignoring   non - present   type   filter   class :     \"     +    ex )  ,    parserContext . extractSource ( element )  )  ;", "}    catch    ( Exception   ex )     {", "parserContext . getReaderContext (  )  . error ( ex . getMessage (  )  ,    parserContext . extractSource ( element )  ,    ex . getCause (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseTypeFilters"], "fileName": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Object   source    =    readerContext . extractSource ( element )  ;", "CompositeComponentDefinition   compositeDef    =    new   CompositeComponentDefinition ( element . getTagName (  )  ,    source )  ;", "for    ( BeanDefinitionHolder   beanDefHolder    :    beanDefinitions )     {", "compositeDef . addNestedComponent ( new   BeanComponentDefinition ( beanDefHolder )  )  ;", "}", "boolean   annotationConfig    =    true ;", "if    ( element . hasAttribute (  . ANNOTATION _ CONFIG _ ATTRIBUTE )  )     {", "annotationConfig    =    Boolean . valueOf ( element . getAttribute (  . ANNOTATION _ CONFIG _ ATTRIBUTE )  )  ;", "}", "if    ( annotationConfig )     {", "Set < BeanDefinitionHolder >    processorDefinitions    =    AnnotationConfigUtils . registerAnnotationConfigProcessors ( readerContext . getRegistry (  )  ,    source )  ;", "for    ( BeanDefinitionHolder   processorDefinition    :    processorDefinitions )     {", "compositeDef . addNestedComponent ( new   BeanComponentDefinition ( processorDefinition )  )  ;", "}", "}", "readerContext . fireComponentRegistered ( compositeDef )  ;", "}", "METHOD_END"], "methodName": ["registerComponents"], "fileName": "org.springframework.context.annotation.ComponentScanBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "ComponentScanParserBeanDefinitionDefaultsTests . DefaultsTestBean . INIT _ COUNT    =     0  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultAutowireByNameTests . xml \"  )  )  ;", "context . refresh (  )  ;", ". DefaultsTestBean   bean    =     (  (  . DefaultsTestBean )     ( context . getBean (  . TEST _ BEAN _ NAME )  )  )  ;", "assertNull (  \" constructor   dependency   should   not   have   been   autowired \"  ,    bean . getConstructorDependency (  )  )  ;", "assertNull (  \" propertyDependency 1    should   not   have   been   autowired \"  ,    bean . getPropertyDependency 1  (  )  )  ;", "assertNotNull (  \" propertyDependency 2    should   have   been   autowired \"  ,    bean . getPropertyDependency 2  (  )  )  ;", "assertEquals (  \" pd 2  \"  ,    bean . getPropertyDependency 2  (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireByName"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultAutowireByTypeTests . xml \"  )  )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" expected   exception   due   to   multiple   matches   for   byType   autowiring \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testAutowireByType"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultAutowireConstructorTests . xml \"  )  )  ;", "context . refresh (  )  ;", ". DefaultsTestBean   bean    =     (  (  . DefaultsTestBean )     ( context . getBean (  . TEST _ BEAN _ NAME )  )  )  ;", "assertNotNull (  \" constructor   dependency   should   have   been   autowired \"  ,    bean . getConstructorDependency (  )  )  ;", "assertEquals (  \" cd \"  ,    bean . getConstructorDependency (  )  . getName (  )  )  ;", "assertNull (  \" property   dependencies   should   not   have   been   autowired \"  ,    bean . getPropertyDependency 1  (  )  )  ;", "assertNull (  \" property   dependencies   should   not   have   been   autowired \"  ,    bean . getPropertyDependency 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireConstructor"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultAutowireNoTests . xml \"  )  )  ;", "context . refresh (  )  ;", ". DefaultsTestBean   bean    =     (  (  . DefaultsTestBean )     ( context . getBean (  . TEST _ BEAN _ NAME )  )  )  ;", "assertNull (  \" no   dependencies   should   have   been   autowired \"  ,    bean . getConstructorDependency (  )  )  ;", "assertNull (  \" no   dependencies   should   have   been   autowired \"  ,    bean . getPropertyDependency 1  (  )  )  ;", "assertNull (  \" no   dependencies   should   have   been   autowired \"  ,    bean . getPropertyDependency 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireNo"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultWithNoOverridesTests . xml \"  )  )  ;", "context . refresh (  )  ;", ". DefaultsTestBean   bean    =     (  (  . DefaultsTestBean )     ( context . getBean (  . TEST _ BEAN _ NAME )  )  )  ;", "assertNull (  \" no   dependencies   should   have   been   autowired \"  ,    bean . getConstructorDependency (  )  )  ;", "assertNull (  \" no   dependencies   should   have   been   autowired \"  ,    bean . getPropertyDependency 1  (  )  )  ;", "assertNull (  \" no   dependencies   should   have   been   autowired \"  ,    bean . getPropertyDependency 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultAutowire"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultWithNoOverridesTests . xml \"  )  )  ;", "context . refresh (  )  ;", ". DefaultsTestBean   bean    =     (  (  . DefaultsTestBean )     ( context . getBean (  . TEST _ BEAN _ NAME )  )  )  ;", "assertNull (  \" constructor   dependency   should   not   have   been   autowired \"  ,    bean . getConstructorDependency (  )  )  ;", "assertNull (  \" property   dependencies   should   not   have   been   autowired \"  ,    bean . getPropertyDependency 1  (  )  )  ;", "assertNull (  \" property   dependencies   should   not   have   been   autowired \"  ,    bean . getPropertyDependency 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultDependencyCheck"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultInitAndDestroyMethodsTests . xml \"  )  )  ;", "context . refresh (  )  ;", ". DefaultsTestBean   bean    =     (  (  . DefaultsTestBean )     ( context . getBean (  . TEST _ BEAN _ NAME )  )  )  ;", "assertTrue (  \" bean   should   have   been   initialized \"  ,    bean . isInitialized (  )  )  ;", "context . close (  )  ;", "assertTrue (  \" bean   should   have   been   destroyed \"  ,    bean . isDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultInitAndDestroyMethodsDefined"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultWithNoOverridesTests . xml \"  )  )  ;", "context . refresh (  )  ;", ". DefaultsTestBean   bean    =     (  (  . DefaultsTestBean )     ( context . getBean (  . TEST _ BEAN _ NAME )  )  )  ;", "assertFalse (  \" bean   should   not   have   been   initialized \"  ,    bean . isInitialized (  )  )  ;", "context . close (  )  ;", "assertFalse (  \" bean   should   not   have   been   destroyed \"  ,    bean . isDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultInitAndDestroyMethodsNotDefined"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultWithNoOverridesTests . xml \"  )  )  ;", "assertFalse (  \" lazy - init   should   be   false \"  ,    context . getBeanDefinition (  . TEST _ BEAN _ NAME )  . isLazyInit (  )  )  ;", "assertEquals (  \" initCount   should   be    0  \"  ,     0  ,     . DefaultsTestBean . INIT _ COUNT )  ;", "context . refresh (  )  ;", "assertEquals (  \" bean   should   have   been   instantiated \"  ,     1  ,     . DefaultsTestBean . INIT _ COUNT )  ;", "}", "METHOD_END"], "methodName": ["testDefaultLazyInit"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultNonExistingInitAndDestroyMethodsTests . xml \"  )  )  ;", "context . refresh (  )  ;", ". DefaultsTestBean   bean    =     (  (  . DefaultsTestBean )     ( context . getBean (  . TEST _ BEAN _ NAME )  )  )  ;", "assertFalse (  \" bean   should   not   have   been   initialized \"  ,    bean . isInitialized (  )  )  ;", "context . close (  )  ;", "assertFalse (  \" bean   should   not   have   been   destroyed \"  ,    bean . isDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultNonExistingInitAndDestroyMethodsDefined"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultLazyInitFalseTests . xml \"  )  )  ;", "assertFalse (  \" lazy - init   should   be   false \"  ,    context . getBeanDefinition (  . TEST _ BEAN _ NAME )  . isLazyInit (  )  )  ;", "assertEquals (  \" initCount   should   be    0  \"  ,     0  ,     . DefaultsTestBean . INIT _ COUNT )  ;", "context . refresh (  )  ;", "assertEquals (  \" bean   should   have   been   instantiated \"  ,     1  ,     . DefaultsTestBean . INIT _ COUNT )  ;", "}", "METHOD_END"], "methodName": ["testLazyInitFalse"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( context )  ;", "reader . loadBeanDefinitions (  (  (  . LOCATION _ PREFIX )     +     \" defaultLazyInitTrueTests . xml \"  )  )  ;", "assertTrue (  \" lazy - init   should   be   true \"  ,    context . getBeanDefinition (  . TEST _ BEAN _ NAME )  . isLazyInit (  )  )  ;", "assertEquals (  \" initCount   should   be    0  \"  ,     0  ,     . DefaultsTestBean . INIT _ COUNT )  ;", "context . refresh (  )  ;", "assertEquals (  \" bean   should   not   have   been   instantiated   yet \"  ,     0  ,     . DefaultsTestBean . INIT _ COUNT )  ;", "context . getBean (  . TEST _ BEAN _ NAME )  ;", "assertEquals (  \" bean   should   have   been   instantiated \"  ,     1  ,     . DefaultsTestBean . INIT _ COUNT )  ;", "}", "METHOD_END"], "methodName": ["testLazyInitTrue"], "fileName": "org.springframework.context.annotation.ComponentScanParserBeanDefinitionDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / context / annotation / scopedProxyDefaultTests . xml \"  )  ;", "context . getBeanFactory (  )  . registerScope (  \" myScope \"  ,    new   SimpleMapScope (  )  )  ;", "ScopedProxyTestBean   bean    =     (  ( ScopedProxyTestBean )     ( context . getBean (  \" scopedProxyTestBean \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( bean )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultScopedProxy"], "fileName": "org.springframework.context.annotation.ComponentScanParserScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / context / annotation / scopedProxyInterfacesTests . xml \"  )  ;", "context . getBeanFactory (  )  . registerScope (  \" myScope \"  ,    new   SimpleMapScope (  )  )  ;", "FooService   bean    =     (  ( FooService )     ( context . getBean (  \" scopedProxyTestBean \"  )  )  )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( bean )  )  ;", "assertEquals (  \" bar \"  ,    bean . foo (  1  )  )  ;", "FooService   deserialized    =     (  ( FooService )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertNotNull ( deserialized )  ;", "assertEquals (  \" bar \"  ,    deserialized . foo (  1  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["testInterfacesScopedProxy"], "fileName": "org.springframework.context.annotation.ComponentScanParserScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( BeanDefinitionParsingException . class )  ;", "exception . expectMessage ( containsString (  \" Cannot   define   both    ' scope - resolver '    and    ' scoped - proxy '    on    < component - scan >    tag \"  )  )  ;", "exception . expectMessage ( containsString (  \" Offending   resource :    class   path   resource    [ org /  / context / annotation / scopedProxyInvalidConfigTests . xml ]  \"  )  )  ;", "new   ClassPathXmlApplicationContext (  \" org /  / context / annotation / scopedProxyInvalidConfigTests . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidConfigScopedProxy"], "fileName": "org.springframework.context.annotation.ComponentScanParserScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / context / annotation / scopedProxyNoTests . xml \"  )  ;", "context . getBeanFactory (  )  . registerScope (  \" myScope \"  ,    new   SimpleMapScope (  )  )  ;", "ScopedProxyTestBean   bean    =     (  ( ScopedProxyTestBean )     ( context . getBean (  \" scopedProxyTestBean \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( bean )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNoScopedProxy"], "fileName": "org.springframework.context.annotation.ComponentScanParserScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / context / annotation / scopedProxyTargetClassTests . xml \"  )  ;", "context . getBeanFactory (  )  . registerScope (  \" myScope \"  ,    new   SimpleMapScope (  )  )  ;", "ScopedProxyTestBean   bean    =     (  ( ScopedProxyTestBean )     ( context . getBean (  \" scopedProxyTestBean \"  )  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean )  )  ;", "assertEquals (  \" bar \"  ,    bean . foo (  1  )  )  ;", "ScopedProxyTestBean   deserialized    =     (  ( ScopedProxyTestBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertNotNull ( deserialized )  ;", "assertEquals (  \" bar \"  ,    deserialized . foo (  1  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTargetClassScopedProxy"], "fileName": "org.springframework.context.annotation.ComponentScanParserScopedProxyTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext    =    loadContext (  \" aspectjTypeFilterTests . xml \"  )  ;", "assertTrue ( containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( containsBean (  \" stubFooDao \"  )  )  ;", "assertFalse ( containsBean (  \" scopedProxyTestBean \"  )  )  ;", "close (  )  ;", "}", "METHOD_END"], "methodName": ["aspectjTypeFilter"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" basePackage \"  ,     \" example . scannable ,    test \"  )  ;", "System . setProperty (  \" scanInclude \"  ,     \" example . scannable . FooService +  \"  )  ;", "System . setProperty (  \" scanExclude \"  ,     \" example .  . Scoped * Test *  \"  )  ;", "try    {", "ClassPathXmlApplicationContext    =    loadContext (  \" aspectjTypeFilterTestsWithPlaceholders . xml \"  )  ;", "assertTrue ( containsBean (  \" fooServiceImpl \"  )  )  ;", "assertTrue ( containsBean (  \" stubFooDao \"  )  )  ;", "assertFalse ( containsBean (  \" scopedProxyTestBean \"  )  )  ;", "close (  )  ;", "}    finally    {", "System . clearProperty (  \" basePackage \"  )  ;", "System . clearProperty (  \" scanInclude \"  )  ;", "System . clearProperty (  \" scanExclude \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["aspectjTypeFilterWithPlaceholders"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "String   xmlLocation    =     \" org / springframework / context / annotation / componentScanRespectsProfileAnnotationTests . xml \"  ;", "{", "GenericXmlApplicationContext   context    =    new   GenericXmlApplicationContext (  )  ;", "context . load ( xmlLocation )  ;", "context . refresh (  )  ;", "assertThat ( context . containsBean ( ProfileAnnotatedComponent . BEAN _ NAME )  ,    is ( false )  )  ;", "context . close (  )  ;", "}", "{", "GenericXmlApplicationContext   context    =    new   GenericXmlApplicationContext (  )  ;", "context . getEnvironment (  )  . setActiveProfiles ( ProfileAnnotatedComponent . PROFILE _ NAME )  ;", "context . load ( xmlLocation )  ;", "context . refresh (  )  ;", "assertThat ( context . containsBean ( ProfileAnnotatedComponent . BEAN _ NAME )  ,    is ( true )  )  ;", "context . close (  )  ;", "}", "{", "ConfigurableApplicationContext   context    =    new   ClassPathXmlApplicationContext ( new   String [  ]  {    xmlLocation    }  ,    false )  ;", "context . getEnvironment (  )  . setActiveProfiles ( ProfileAnnotatedComponent . PROFILE _ NAME )  ;", "context . refresh (  )  ;", "assertThat ( context . containsBean ( ProfileAnnotatedComponent . BEAN _ NAME )  ,    is ( true )  )  ;", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["componentScanRespectsProfileAnnotation"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    loadContext (  \" componentScanWithAutowiredQualifierTests . xml \"  )  ;", "AutowiredQualifierFooService   fooService    =     (  ( AutowiredQualifierFooService )     ( context . getBean (  \" fooService \"  )  )  )  ;", "assertTrue ( fooService . isInitCalled (  )  )  ;", "assertEquals (  \" bar \"  ,    fooService . foo (  1  2  3  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["componentScanWithAutowiredQualifier"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    loadContext (  \" customAnnotationUsedForBothComponentScanAndQualifierTests . xml \"  )  ;", ". KustomAnnotationAutowiredBean   testBean    =     (  (  . KustomAnnotationAutowiredBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", "assertNotNull ( testBean . getDependency (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["customAnnotationUsedForBothComponentScanAndQualifier"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    loadContext (  \" customTypeFilterTests . xml \"  )  ;", ". KustomAnnotationAutowiredBean   testBean    =     (  (  . KustomAnnotationAutowiredBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", "assertNotNull ( testBean . getDependency (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["customTypeFilter"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathXmlApplicationContext ( path ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadContext"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext    =    loadContext (  \" matchingResourcePatternTests . xml \"  )  ;", "assertTrue ( containsBean (  \" fooServiceImpl \"  )  )  ;", "close (  )  ;", "}", "METHOD_END"], "methodName": ["matchingResourcePattern"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext    =    loadContext (  \" nonMatchingResourcePatternTests . xml \"  )  ;", "assertFalse ( containsBean (  \" fooServiceImpl \"  )  )  ;", "close (  )  ;", "}", "METHOD_END"], "methodName": ["nonMatchingResourcePattern"], "fileName": "org.springframework.context.annotation.ComponentScanParserTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / context / annotation / customNameGeneratorTests . xml \"  )  ;", "assertTrue ( context . containsBean (  \" testing . fooServiceImpl \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomBeanNameGenerator"], "fileName": "org.springframework.context.annotation.ComponentScanParserWithUserDefinedStrategiesTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / context / annotation / customScopeResolverTests . xml \"  )  ;", "BeanDefinition   bd    =    context . getBeanFactory (  )  . getBeanDefinition (  \" fooServiceImpl \"  )  ;", "assertEquals (  \" myCustomScope \"  ,    bd . getScope (  )  )  ;", "assertFalse ( bd . isSingleton (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomScopeMetadataResolver"], "fileName": "org.springframework.context.annotation.ComponentScanParserWithUserDefinedStrategiesTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  \" org /  / context / annotation / invalidClassNameScopeResolverTests . xml \"  )  ;", "fail (  \" should   have   failed :    no   such   class \"  )  ;", "}    catch    ( BeansException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testInvalidClassNameScopeMetadataResolver"], "fileName": "org.springframework.context.annotation.ComponentScanParserWithUserDefinedStrategiesTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  \" org /  / context / annotation / invalidConstructorNameGeneratorTests . xml \"  )  ;", "fail (  \" should   have   failed :    no - arg   constructor   is   required \"  )  ;", "}    catch    ( BeansException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testInvalidConstructorBeanNameGenerator"], "fileName": "org.springframework.context.annotation.ComponentScanParserWithUserDefinedStrategiesTests"}, {"methodBody": ["METHOD_START", "{", "CustomAutowireConfigurer   cac    =    new   CustomAutowireConfigurer (  )  ;", "cac . setCustomQualifierTypes ( new   HashSet (  )     {", "{", "add ( ParserTests . CustomAnnotation . class )  ;", "}", "}  )  ;", "return   cac ;", "}", "METHOD_END"], "methodName": ["customAutowireConfigurer"], "fileName": "org.springframework.context.annotation.ComponentScanWithCustomTypeFilter"}, {"methodBody": ["METHOD_START", "{", "return   new   ComponentScanParserTests . KustomAnnotationAutowiredBean (  )  ;", "}", "METHOD_END"], "methodName": ["testBean"], "fileName": "org.springframework.context.annotation.ComponentScanWithCustomTypeFilter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    conditionClass    =    ClassUtils . resolveClassName ( conditionClassName ,    classloader )  ;", "return    (  (  )     ( BeanUtils . instantiateClass ( conditionClass )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCondition"], "fileName": "org.springframework.context.annotation.ConditionEvaluator"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    attributes    =    metadata . getAllAnnotationAttributes ( Conditional . class . getName (  )  ,    true )  ;", "Object   values    =     ( attributes    !  =    null )     ?    attributes . get (  \" value \"  )     :    null ;", "return    (  ( List < String [  ]  >  )     ( values    !  =    null    ?    values    :    Collections . emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getConditionClasses"], "fileName": "org.springframework.context.annotation.ConditionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   shouldSkip ( metadata ,    null )  ;", "}", "METHOD_END"], "methodName": ["shouldSkip"], "fileName": "org.springframework.context.annotation.ConditionEvaluator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( metadata    =  =    null )     |  |     (  !  ( metadata . isAnnotated ( Conditional . class . getName (  )  )  )  )  )     {", "return   false ;", "}", "if    ( phase    =  =    null )     {", "if    (  ( metadata   instanceof   AnnotationMetadata )     &  &     ( ConfigurationClassUtils . isConfigurationCandidate (  (  ( AnnotationMetadata )     ( metadata )  )  )  )  )     {", "return   shouldSkip ( metadata ,    ConfigurationCondition . ConfigurationPhase . PARSE _ CONFIGURATION )  ;", "}", "return   shouldSkip ( metadata ,    ConfigurationCondition . ConfigurationPhase . REGISTER _ BEAN )  ;", "}", "List < Condition >    conditions    =    new   ArrayList <  >  (  )  ;", "for    ( String [  ]    conditionClasses    :    getConditionClasses ( metadata )  )     {", "for    ( String   conditionClass    :    conditionClasses )     {", "Condition   condition    =    getCondition ( conditionClass ,    this . context . getClassLoader (  )  )  ;", "conditions . add ( condition )  ;", "}", "}", "AnnotationAwareOrderComparator . sort ( conditions )  ;", "for    ( Condition   condition    :    conditions )     {", "ConfigurationCondition . ConfigurationPhase   requiredPhase    =    null ;", "if    ( condition   instanceof   ConfigurationCondition )     {", "requiredPhase    =     (  ( ConfigurationCondition )     ( condition )  )  . getConfigurationPhase (  )  ;", "}", "if    (  (  ( requiredPhase    =  =    null )     |  |     ( requiredPhase    =  =    phase )  )     &  &     (  !  ( condition . matches ( this . context ,    metadata )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldSkip"], "fileName": "org.springframework.context.annotation.ConditionEvaluator"}, {"methodBody": ["METHOD_START", "{", "this . beanMethods . add ( method )  ;", "}", "METHOD_END"], "methodName": ["addBeanMethod"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "this . importBeanDefinitionRegistrars . put ( registrar ,    importingClassMetadata )  ;", "}", "METHOD_END"], "methodName": ["addImportBeanDefinitionRegistrar"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "this . importedResources . put ( importedResource ,    readerClass )  ;", "}", "METHOD_END"], "methodName": ["addImportedResource"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return   this . beanMethods ;", "}", "METHOD_END"], "methodName": ["getBeanMethods"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return   this . importBeanDefinitionRegistrars ;", "}", "METHOD_END"], "methodName": ["getImportBeanDefinitionRegistrars"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return   this . importedBy ;", "}", "METHOD_END"], "methodName": ["getImportedBy"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return   this . importedResources ;", "}", "METHOD_END"], "methodName": ["getImportedResources"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return   this . metadata ;", "}", "METHOD_END"], "methodName": ["getMetadata"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return   this . resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getShortName ( getMetadata (  )  . getClassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleName"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . importedBy . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isImported"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "this . importedBy . addAll ( otherConfigClass . importedBy )  ;", "}", "METHOD_END"], "methodName": ["mergeImportedBy"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "this . beanName    =    beanName ;", "}", "METHOD_END"], "methodName": ["setBeanName"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "if    ( getMetadata (  )  . isAnnotated ( Configuration . class . getName (  )  )  )     {", "if    ( getMetadata (  )  . isFinal (  )  )     {", "problemReporter . error ( new    . FinalConfigurationProblem (  )  )  ;", "}", "}", "for    ( BeanMethod   beanMethod    :    this . beanMethods )     {", "beanMethod . validate ( problemReporter )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.springframework.context.annotation.ConfigurationClass"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . TestBeanConfig . class ,     . AutowiredConfigWithBFPPAsInstanceMethod . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean (  . AutowiredConfigWithBFPPAsInstanceMethod . class )  . autowiredTestBean ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiringFailsWithBFPPAsInstanceMethod"], "fileName": "org.springframework.context.annotation.ConfigurationClassAndBFPPTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . TestBeanConfig . class ,     . AutowiredConfigWithBFPPAsStaticMethod . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean (  . AutowiredConfigWithBFPPAsStaticMethod . class )  . autowiredTestBean ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiringSucceedsWithBFPPAsStaticMethod"], "fileName": "org.springframework.context.annotation.ConfigurationClassAndBFPPTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithStaticBeanMethod . class )  ;", "ctx . refresh (  )  ;", "assertThat (  . ConfigWithStaticBeanMethod . testBean (  )  ,    not ( sameInstance (  . ConfigWithStaticBeanMethod . testBean (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["staticBeanMethodsDoNotRespectScoping"], "fileName": "org.springframework.context.annotation.ConfigurationClassAndBFPPTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . registry . containsBeanDefinition ( beanName )  )  )     {", "return   false ;", "}", "BeanDefinition   existingBeanDef    =    this . registry . getBeanDefinition ( beanName )  ;", "if    ( existingBeanDef   instanceof    . ConfigurationClassBeanDefinition )     {", ". ConfigurationClassBeanDefinition   ccbd    =     (  (  . ConfigurationClassBeanDefinition )     ( existingBeanDef )  )  ;", "return   ccbd . getMetadata (  )  . getClassName (  )  . equals ( beanMethod . getConfigurationClass (  )  . getMetadata (  )  . getClassName (  )  )  ;", "}", "if    ( existingBeanDef   instanceof   ScannedGenericBeanDefinition )     {", "return   false ;", "}", "if    (  ( existingBeanDef . getRole (  )  )     >     ( BeanDefinition . ROLE _ APPLICATION )  )     {", "return   false ;", "}", "if    (  (  ( this . registry )    instanceof   DefaultListableBeanFactory )     &  &     (  !  (  (  ( DefaultListableBeanFactory )     ( this . registry )  )  . isAllowBeanDefinitionOverriding (  )  )  )  )     {", "throw   new   BeanDefinitionStoreException ( beanMethod . getConfigurationClass (  )  . getResource (  )  . getDescription (  )  ,    beanName ,     (  \"  @ Bean   definition   illegally   overridden   by   existing   bean   definition :     \"     +    existingBeanDef )  )  ;", "}", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info ( String . format (  (  \" Skipping   bean   definition   for    % s :    a   definition   for   bean    '  % s '     \"     +     \" already   exists .    This   top - level   bean   definition   is   considered   as   an   override .  \"  )  ,    beanMethod ,    beanName )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isOverriddenByExistingDefinition"], "fileName": "org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "ConfigurationClassBeanDefinitionReader . TrackedConditionEvaluator   trackedConditionEvaluator    =    new   ConfigurationClassBeanDefinitionReader . TrackedConditionEvaluator (  )  ;", "for    ( ConfigurationClass   configClass    :    configurationModel )     {", "loadBeanDefinitionsForConfigurationClass ( configClass ,    trackedConditionEvaluator )  ;", "}", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "ConfigurationClass   configClass    =    beanMethod . getConfigurationClass (  )  ;", "MethodMetadata   metadata    =    beanMethod . getMetadata (  )  ;", "String   methodName    =    metadata . getMethodName (  )  ;", "if    ( this . conditionEvaluator . shouldSkip ( metadata ,    ConfigurationCondition . ConfigurationPhase . REGISTER _ BEAN )  )     {", "configClass . skippedBeanMethods . add ( methodName )  ;", "return ;", "}", "if    ( configClass . skippedBeanMethods . contains ( methodName )  )     {", "return ;", "}", "AnnotationAttributes   bean    =    AnnotationConfigUtils . attributesFor ( metadata ,    Bean . class )  ;", "Assert . state (  ( bean    !  =    null )  ,     \" No    @ Bean   annotation   attributes \"  )  ;", "List < String >    names    =    new   ArrayList ( Arrays . asList ( bean . getStringArray (  \" name \"  )  )  )  ;", "String   beanName    =     (  !  ( names . isEmpty (  )  )  )     ?    names . remove (  0  )     :    methodName ;", "for    ( String   alias    :    names )     {", "this . registry . registerAlias ( beanName ,    alias )  ;", "}", "if    ( isOverriddenByExistingDefinition ( beanMethod ,    beanName )  )     {", "if    ( beanName . equals ( beanMethod . getConfigurationClass (  )  . getBeanName (  )  )  )     {", "throw   new   BeanDefinitionStoreException ( beanMethod . getConfigurationClass (  )  . getResource (  )  . getDescription (  )  ,    beanName ,     (  (  \" Bean   name   derived   from    @ Bean   method    '  \"     +     ( beanMethod . getMetadata (  )  . getMethodName (  )  )  )     +     \"  '    clashes   with   bean   name   for   containing   configuration   class ;    please   make   those   names   unique !  \"  )  )  ;", "}", "return ;", "}", ". ConfigurationClassBeanDefinition   beanDef    =    new    . ConfigurationClassBeanDefinition ( configClass ,    metadata )  ;", "beanDef . setResource ( configClass . getResource (  )  )  ;", "beanDef . setSource ( this . sourceExtractor . extractSource ( metadata ,    configClass . getResource (  )  )  )  ;", "if    ( metadata . isStatic (  )  )     {", "beanDef . setBeanClassName ( configClass . getMetadata (  )  . getClassName (  )  )  ;", "beanDef . setFactoryMethodName ( methodName )  ;", "} else    {", "beanDef . setFactoryBeanName ( configClass . getBeanName (  )  )  ;", "beanDef . setUniqueFactoryMethodName ( methodName )  ;", "}", "beanDef . setAutowireMode ( AUTOWIRE _ CONSTRUCTOR )  ;", "beanDef . setAttribute ( SKIP _ REQUIRED _ CHECK _ ATTRIBUTE ,    Boolean . TRUE )  ;", "AnnotationConfigUtils . processCommonDefinitionAnnotations ( beanDef ,    metadata )  ;", "Autowire   autowire    =    bean . getEnum (  \" autowire \"  )  ;", "if    ( autowire . isAutowire (  )  )     {", "beanDef . setAutowireMode ( autowire . value (  )  )  ;", "}", "String   initMethodName    =    bean . getString (  \" initMethod \"  )  ;", "if    ( StringUtils . hasText ( initMethodName )  )     {", "beanDef . setInitMethodName ( initMethodName )  ;", "}", "String   destroyMethodName    =    bean . getString (  \" destroyMethod \"  )  ;", "beanDef . setDestroyMethodName ( destroyMethodName )  ;", "ScopedProxyMode   proxyMode    =    ScopedProxyMode . NO ;", "AnnotationAttributes   attributes    =    AnnotationConfigUtils . attributesFor ( metadata ,    Scope . class )  ;", "if    ( attributes    !  =    null )     {", "beanDef . setScope ( attributes . getString (  \" value \"  )  )  ;", "proxyMode    =    attributes . getEnum (  \" proxyMode \"  )  ;", "if    ( proxyMode    =  =     ( ScopedProxyMode . DEFAULT )  )     {", "proxyMode    =    ScopedProxyMode . NO ;", "}", "}", "BeanDefinition   beanDefToRegister    =    beanDef ;", "if    ( proxyMode    !  =     ( ScopedProxyMode . NO )  )     {", "BeanDefinitionHolder   proxyDef    =    ScopedProxyCreator . createScopedProxy ( new   BeanDefinitionHolder ( beanDef ,    beanName )  ,    this . registry ,     ( proxyMode    =  =     ( ScopedProxyMode . TARGET _ CLASS )  )  )  ;", "beanDefToRegister    =    new    . ConfigurationClassBeanDefinition (  (  ( RootBeanDefinition )     ( proxyDef . getBeanDefinition (  )  )  )  ,    configClass ,    metadata )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( String . format (  \" Registering   bean   definition   for    @ Bean   method    % s .  % s (  )  \"  ,    configClass . getMetadata (  )  . getClassName (  )  ,    beanName )  )  ;", "}", "this . registry . registerBeanDefinition ( beanName ,    beanDefToRegister )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitionsForBeanMethod"], "fileName": "org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    ( trackedConditionEvaluator . shouldSkip ( configClass )  )     {", "String   beanName    =    configClass . getBeanName (  )  ;", "if    (  ( StringUtils . hasLength ( beanName )  )     &  &     ( this . registry . containsBeanDefinition ( beanName )  )  )     {", "this . registry . removeBeanDefinition ( beanName )  ;", "}", "this . importRegistry . removeImportingClass ( configClass . getMetadata (  )  . getClassName (  )  )  ;", "return ;", "}", "if    ( configClass . isImported (  )  )     {", "registerBeanDefinitionForImported ( configClass )  ;", "}", "for    ( BeanMethod   beanMethod    :    configClass . getBeanMethods (  )  )     {", "loadBeanDefinitionsForBeanMethod ( beanMethod )  ;", "}", "loadBeanDefinitionsFromImportedResources ( configClass . getImportedResources (  )  )  ;", "loadBeanDefinitionsFromRegistrars ( configClass . getImportBeanDefinitionRegistrars (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitionsForConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Map < Class <  ?  >  ,    BeanDefinitionReader >    readerInstanceCache    =    new   HashMap <  >  (  )  ;", "importedResources . forEach (  (    resource ,    readerClass )     -  >     {", "if    (  (  . class )     =  =    readerClass )     {", "if    ( StringUtils . endsWithIgnoreCase ( resource ,     \"  . groovy \"  )  )     {", "readerClass    =     . class ;", "} else    {", "readerClass    =     . class ;", "}", "}", "BeanDefinitionReader   reader    =    readerInstanceCache . get ( readerClass )  ;", "if    ( reader    =  =    null )     {", "try    {", "reader    =    readerClass . getConstructor (  . class )  . newInstance ( this . registry )  ;", "if    ( reader   instanceof   AbstractBeanDefinitionReader )     {", "AbstractBeanDefinitionReader   abdr    =     (  ( AbstractBeanDefinitionReader )     ( reader )  )  ;", "abdr . setResourceLoader ( this . resourceLoader )  ;", "abdr . setEnvironment ( this . environment )  ;", "}", "readerInstanceCache . put ( readerClass ,    reader )  ;", "}    catch    (    ex )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   instantiate   BeanDefinitionReader   class    [  \"     +     ( readerClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "reader . loadBeanDefinitions ( resource )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitionsFromImportedResources"], "fileName": "org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "registrars . forEach (  (    registrar ,    metadata )     -  >    registrar . registerBeanDefinitions ( metadata ,    this . registry )  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitionsFromRegistrars"], "fileName": "org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    configClass . getMetadata (  )  ;", "AnnotatedGenericBeanDefinition   configBeanDef    =    new   AnnotatedGenericBeanDefinition ( metadata )  ;", "ScopeMetadata   scopeMetadata    =     . scopeMetadataResolver . resolveScopeMetadata ( configBeanDef )  ;", "configBeanDef . setScope ( scopeMetadata . getScopeName (  )  )  ;", "String   configBeanName    =    this . importBeanNameGenerator . generateBeanName ( configBeanDef ,    this . registry )  ;", "AnnotationConfigUtils . processCommonDefinitionAnnotations ( configBeanDef ,    metadata )  ;", "BeanDefinitionHolder   definitionHolder    =    new   BeanDefinitionHolder ( configBeanDef ,    configBeanName )  ;", "definitionHolder    =    AnnotationConfigUtils . applyScopedProxyMode ( scopeMetadata ,    definitionHolder ,    this . registry )  ;", "this . registry . registerBeanDefinition ( definitionHolder . getBeanName (  )  ,    definitionHolder . getBeanDefinition (  )  )  ;", "configClass . setBeanName ( configBeanName )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Registered   bean   definition   for   imported   class    '  \"     +    configBeanName )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerBeanDefinitionForImportedConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    subclass    =    enhancer . createClass (  )  ;", "Enhancer . registerStaticCallbacks ( subclass ,     . CALLBACKS )  ;", "return   subclass ;", "}", "METHOD_END"], "methodName": ["createClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassEnhancer"}, {"methodBody": ["METHOD_START", "{", "if    ( ConfigurationClassEnhancer . EnhancedConfiguration . class . isAssignableFrom ( configClass )  )     {", "if    ( ConfigurationClassEnhancer . logger . isDebugEnabled (  )  )     {", "ConfigurationClassEnhancer . logger . debug ( String . format (  (  \" Ignoring   request   to   enhance    % s   as   it   has    \"     +     (  (  (  \" already   been   enhanced .    This   usually   indicates   that   more   than   one    \"     +     \" ConfigurationClassPostProcessor   has   been   registered    ( e . g .    via    \"  )     +     \"  < context : annotation - config >  )  .    This   is   harmless ,    but   you   may    \"  )     +     \" want   check   your   configuration   and   remove   one   CCPP   if   possible \"  )  )  ,    configClass . getName (  )  )  )  ;", "}", "return   configClass ;", "}", "Class <  ?  >    enhancedClass    =    createClass ( newEnhancer ( configClass ,    classLoader )  )  ;", "if    ( ConfigurationClassEnhancer . logger . isDebugEnabled (  )  )     {", "ConfigurationClassEnhancer . logger . debug ( String . format (  \" Successfully   enhanced    % s ;    enhanced   class   name   is :     % s \"  ,    configClass . getName (  )  ,    enhancedClass . getName (  )  )  )  ;", "}", "return   enhancedClass ;", "}", "METHOD_END"], "methodName": ["enhance"], "fileName": "org.springframework.context.annotation.ConfigurationClassEnhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer   enhancer    =    new   Enhancer (  )  ;", "enhancer . setSuperclass ( configSuperClass )  ;", "enhancer . setInterfaces ( new   Class <  ?  >  [  ]  {     . EnhancedConfiguration . class    }  )  ;", "enhancer . setUseFactory ( false )  ;", "enhancer . setNamingPolicy ( INSTANCE )  ;", "enhancer . setStrategy ( new    . BeanFactoryAwareGeneratorStrategy ( classLoader )  )  ;", "enhancer . setCallbackFilter (  . CALLBACK _ FILTER )  ;", "enhancer . setCallbackTypes (  . CALLBACK _ FILTER . getCallbackTypes (  )  )  ;", "return   enhancer ;", "}", "METHOD_END"], "methodName": ["newEnhancer"], "fileName": "org.springframework.context.annotation.ConfigurationClassEnhancer"}, {"methodBody": ["METHOD_START", "{", "String   name    =    propertySource . getName (  )  ;", "MutablePropertySources   propertySources    =     (  ( bleEnvironment )     ( this . environment )  )  . getPropertySources (  )  ;", "if    ( this . propertySourceNames . contains ( name )  )     {", "PropertySource <  ?  >    existing    =    propertySources . get ( name )  ;", "if    ( existing    !  =    null )     {", "PropertySource <  ?  >    newSource    =     ( propertySource   instanceof   ResourcePropertySource )     ?     (  ( ResourcePropertySource )     ( propertySource )  )  . withResourceName (  )     :    propertySource ;", "if    ( existing   instanceof   CompositePropertySource )     {", "(  ( CompositePropertySource )     ( existing )  )  . addFirstPropertySource ( newSource )  ;", "} else    {", "if    ( existing   instanceof   ResourcePropertySource )     {", "existing    =     (  ( ResourcePropertySource )     ( existing )  )  . withResourceName (  )  ;", "}", "CompositePropertySource   composite    =    new   CompositePropertySource ( name )  ;", "composite . addPropertySource ( newSource )  ;", "composite . addPropertySource ( existing )  ;", "propertySources . replace ( name ,    composite )  ;", "}", "return ;", "}", "}", "if    ( this . propertySourceNames . isEmpty (  )  )     {", "propertySources . addLast ( propertySource )  ;", "} else    {", "String   firstProcessed    =    this . propertySourceNames . get (  (  ( this . propertySourceNames . size (  )  )     -     1  )  )  ;", "propertySources . addBefore ( firstProcessed ,    propertySource )  ;", "}", "this . propertySourceNames . add ( name )  ;", "}", "METHOD_END"], "methodName": ["addPropertySource"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "if    ( classType    =  =    null )     {", "return   new    . SourceClass ( Object . class )  ;", "}", "try    {", "for    ( Annotation   ann    :    classType . getAnnotations (  )  )     {", "AnnotationUtils . validateAnnotation ( ann )  ;", "}", "return   new    . SourceClass ( classType )  ;", "}    catch    ( Throwable   ex )     {", "return   asSourceClass ( classType . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["asSourceClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "if    ( className    =  =    null )     {", "return   new    . SourceClass ( Object . class )  ;", "}", "if    ( className . startsWith (  \" java \"  )  )     {", "try    {", "return   new    . SourceClass ( ClassUtils . forName ( className ,    this . resourceLoader . getClassLoader (  )  )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   NestedIOException (  (  (  \" Failed   to   load   class    [  \"     +    className )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "return   new    . SourceClass ( this . metadataReaderFactory . getMetadataReader ( className )  )  ;", "}", "METHOD_END"], "methodName": ["asSourceClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    configurationClass . getMetadata (  )  ;", "if    ( metadata   instanceof   StandardAnnotationMetadata )     {", "return   asSourceClass (  (  ( StandardAnnotationMetadata )     ( metadata )  )  . getIntrospectedClass (  )  )  ;", "}", "return   asSourceClass ( metadata . getClassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["asSourceClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "List < ConfigurationClassParser . SourceClass >    annotatedClasses    =    new   ArrayList <  >  ( classNames . length )  ;", "for    ( String   className    :    classNames )     {", "annotatedClasses . add ( asSourceClass ( className )  )  ;", "}", "return   annotatedClasses ;", "}", "METHOD_END"], "methodName": ["asSourceClasses"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "if    ( visited . add ( sourceClass )  )     {", "for    (  . SourceClass   annotation    :    sourceClass . getAnnotations (  )  )     {", "String   annName    =    annotation . getMetadata (  )  . getClassName (  )  ;", "if    (  (  !  ( annName . startsWith (  \" java \"  )  )  )     &  &     (  !  ( annName . equals ( Import . class . getName (  )  )  )  )  )     {", "collectImports ( annotation ,    imports ,    visited )  ;", "}", "}", "imports . addAll ( sourceClass . getAnnotationAttributes ( Import . class . getName (  )  ,     \" value \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["collectImports"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   DeferredImportSelector . Group >    effectiveType    =     ( type    !  =    null )     ?    type    :    ConfigurationClassParser . DefaultDeferredImportSelectorGroup . class ;", "DeferredImportSelector . Group   group    =    BeanUtils . instantiateClass ( effectiveType )  ;", "ParserStrategyUtils . invokeAwareMethods ( group ,    this . environment ,    this . resourceLoader ,    this . registry )  ;", "return   group ;", "}", "METHOD_END"], "methodName": ["createGroup"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "processMemberClasses ( configClass ,    sourceClass )  ;", "for    ( AnnotationAttributes   propertySource    :    AnnotationConfigUtils . attributesForRepeatable ( sourceClass . getMetadata (  )  ,    PropertySources . class ,    PropertySource . class )  )     {", "if    (  ( this . environment )    instanceof   ConfigurableEnvironment )     {", "processPropertySource ( propertySource )  ;", "} else    {", "logger . warn (  (  (  \" Ignoring    @ PropertySource   annotation   on    [  \"     +     ( sourceClass . getMetadata (  )  . getClassName (  )  )  )     +     \"  ]  .    Reason :    Environment   must   implement   ConfigurableEnvironment \"  )  )  ;", "}", "}", "Set < AnnotationAttributes >    componentScans    =    AnnotationConfigUtils . attributesForRepeatable ( sourceClass . getMetadata (  )  ,    ComponentScans . class ,    ComponentScan . class )  ;", "if    (  (  !  ( componentScans . isEmpty (  )  )  )     &  &     (  !  ( this . conditionEvaluator . shouldSkip ( sourceClass . getMetadata (  )  ,    ConfigurationCondiPhase . REGISTER _ BEAN )  )  )  )     {", "for    ( AnnotationAttributes   componentScan    :    componentScans )     {", "Set < BeanDefinitionHolder >    scannedBeanDefinitions    =    this . componentScanParser . parse ( componentScan ,    sourceClass . getMetadata (  )  . getClassName (  )  )  ;", "for    ( BeanDefinitionHolder   holder    :    scannedBeanDefinitions )     {", "if    ( ConfigurationClassUtils . checkConfigurationClassCandidate ( holder . getBeanDefinition (  )  ,    this . metadataReaderFactory )  )     {", "parse ( holder . getBeanDefinition (  )  . getBeanClassName (  )  ,    holder . getBeanName (  )  )  ;", "}", "}", "}", "}", "processImports ( configClass ,    sourceClass ,    getImports ( sourceClass )  ,    true )  ;", "AnnotationAttributes   importResource    =    AnnotationConfigUtils . attributesFor ( sourceClass . getMetadata (  )  ,    ImportResource . class )  ;", "if    ( importResource    !  =    null )     {", "String [  ]    resources    =    importResource . getStringArray (  \" locations \"  )  ;", "Class <  ?    extends   BeanDefinitionReader >    readerClass    =    importResource . getClass (  \" reader \"  )  ;", "for    ( String   resource    :    resources )     {", "String   resolvedResource    =    this . environment . resolveRequiredPlaceholders ( resource )  ;", "configClass . addImportedResource ( resolvedResource ,    readerClass )  ;", "}", "}", "Set < MethodMetadata >    beanMethods    =    retrieveBeanMethodMetadata ( sourceClass )  ;", "for    ( MethodMetadata   methodMetadata    :    beanMethods )     {", "configClass . addBeanMethod ( new   BeanMethod ( methodMetadata ,    configClass )  )  ;", "}", "processInterfaces ( configClass ,    sourceClass )  ;", "if    ( sourceClass . getMetadata (  )  . hasSuperClass (  )  )     {", "String   superclass    =    sourceClass . getMetadata (  )  . getSuperClassName (  )  ;", "if    (  (  ( superclass    !  =    null )     &  &     (  !  ( superclass . startsWith (  \" java \"  )  )  )  )     &  &     (  !  ( this . knownSuperclasses . containsKey ( superclass )  )  )  )     {", "this . knownSuperclasses . put ( superclass ,    configClass )  ;", "return   sourceClass . getSuperClass (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doProcessConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "return   this . configurationClasses . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["getConfigurationClasses"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "return   this . importStack ;", "}", "METHOD_END"], "methodName": ["getImportRegistry"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "Set < ConfigurationClassParser . SourceClass >    imports    =    new   LinkedHashSet <  >  (  )  ;", "Set < ConfigurationClassParser . SourceClass >    visited    =    new   LinkedHashSet <  >  (  )  ;", "collectImports ( sourceClass ,    imports ,    visited )  ;", "return   imports ;", "}", "METHOD_END"], "methodName": ["getImports"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "if    ( this . importStack . contains ( configClass )  )     {", "String   configClassName    =    configClass . getMetadata (  )  . getClassName (  )  ;", "AMetadata   importingClass    =    this . importStack . getImportingClassFor ( configClassName )  ;", "while    ( importingClass    !  =    null )     {", "if    ( configClassName . equals ( importingClass . getClassName (  )  )  )     {", "return   true ;", "}", "importingClass    =    this . importStack . getImportingClassFor ( importingClass . getClassName (  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isChainedImportOnStack"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "processConfigurationClass ( new   ConfigurationClass ( clazz ,    beanName )  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( className ,     \" No   bean   class   name   for   configuration   class   bean   definition \"  )  ;", "MetadataReader   reader    =    this . metadataReaderFactory . getMetadataReader ( className )  ;", "process ( new    ( reader ,    beanName )  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "this . deferredImportSelectors    =    new   LinkedList <  >  (  )  ;", "for    ( BeanDefinitionHolder   holder    :    configCandidates )     {", "BeanDefinition   bd    =    holder . getBeanDefinition (  )  ;", "try    {", "if    ( bd   instanceof   AnnotatedBeanDefinition )     {", "parse (  (  ( AnnotatedBeanDefinition )     ( bd )  )  . getMetadata (  )  ,    holder . getBeanName (  )  )  ;", "} else", "if    (  ( bd   instanceof   beans . factory . support . AbstractBeanDefinition )     &  &     (  (  ( beans . factory . support . AbstractBeanDefinition )     ( bd )  )  . hasBeanClass (  )  )  )     {", "parse (  (  ( beans . factory . support . AbstractBeanDefinition )     ( bd )  )  . getBeanClass (  )  ,    holder . getBeanName (  )  )  ;", "} else    {", "parse ( bd . getBeanClassName (  )  ,    holder . getBeanName (  )  )  ;", "}", "}    catch    ( BeanDefinitionStoreException   ex )     {", "throw   ex ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanDefinitionStoreException (  (  (  \" Failed   to   parse   configuration   class    [  \"     +     ( bd . getBeanClassName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "processDeferredImportSelectors (  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "processConfigurationClass ( new   ConfigurationClass ( metadata ,    beanName )  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "if    ( this . conditionEvaluator . shouldSkip ( configClass . getMetadata (  )  ,    ConfigurationCondition . ConfigurationPhase . PARSE _ CONFIGURATION )  )     {", "return ;", "}", "ConfigurationClass   existingClass    =    this . configurationClasses . get ( configClass )  ;", "if    ( existingClass    !  =    null )     {", "if    ( configClass . isImported (  )  )     {", "if    ( existingClass . isImported (  )  )     {", "existingClass . mergeImportedBy ( configClass )  ;", "}", "return ;", "} else    {", "this . configurationClasses . remove ( configClass )  ;", "this . knownSuperclasses . values (  )  . removeIf ( configClass :  : equals )  ;", "}", "}", ". SourceClass   sourceClass    =    asSourceClass ( configClass )  ;", "do    {", "sourceClass    =    doProcessConfigurationClass ( configClass ,    sourceClass )  ;", "}    while    ( sourceClass    !  =    null    )  ;", "this . configurationClasses . put ( configClass ,    configClass )  ;", "}", "METHOD_END"], "methodName": ["processConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "List < ConfigurationClassParser . DeferredImportSelectorHolder >    deferredImports    =    this . deferredImportSelectors ;", "this . deferredImportSelectors    =    null ;", "if    ( deferredImports    =  =    null )     {", "return ;", "}", "deferredImports . sort ( ConfigurationClassParser . DEFERRED _ IMPORT _ COMPARATOR )  ;", "Map < Object ,    ConfigurationClassParser . DeferredImportSelectorGrouping >    groupings    =    new   LinkedHashMap <  >  (  )  ;", "Map < AnnotationMetadata ,    ConfigurationClass >    configurationClasses    =    new   HashMap <  >  (  )  ;", "for    ( ConfigurationClassParser . DeferredImportSelectorHolder   deferredImport    :    deferredImports )     {", "Class <  ?    extends   DeferredImportSelector . Group >    group    =    deferredImport . getImportSelector (  )  . getImportGroup (  )  ;", "ConfigurationClassParser . DeferredImportSelectorGrouping   grouping    =    groupings . computeIfAbsent (  ( group    =  =    null    ?    deferredImport    :    group )  ,     (    key )     -  >    new   ConfigurationClassParser . DeferredImportSelectorGrouping ( createGroup ( group )  )  )  ;", "grouping . add ( deferredImport )  ;", "configurationClasses . put ( deferredImport . getConfigurationClass (  )  . getMetadata (  )  ,    deferredImport . getConfigurationClass (  )  )  ;", "}", "for    ( ConfigurationClassParser . DeferredImportSelectorGrouping   grouping    :    groupings . values (  )  )     {", "grouping . getImports (  )  . forEach (  (    entry )     -  >     {", "ConfigurationClass   configurationClass    =    configurationClasses . get ( entry . getMetadata (  )  )  ;", "try    {", "processImports ( configurationClass ,    asSourceClass ( configurationClass )  ,    asSourceClasses ( entry . getImportClassName (  )  )  ,    false )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "throw   ex ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanDefinitionStoreException (  (  (  \" Failed   to   process   import   candidates   for   configuration   class    [  \"     +     ( configurationClass . getMetadata (  )  . getClassName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["processDeferredImportSelectors"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "if    ( importCandidates . isEmpty (  )  )     {", "return ;", "}", "if    ( checkForCircularImports    &  &     ( isChainedImportOnStack ( configClass )  )  )     {", "this . problemReporter . error ( new    . CircularImportProblem ( configClass ,    this . importStack )  )  ;", "} else    {", "this . importStack . push ( configClass )  ;", "try    {", "for    (  . SourceClass   candidate    :    importCandidates )     {", "if    ( candidate . isAssignable ( ImportSelector . class )  )     {", "Class <  ?  >    candidateClass    =    candidate . loadClass (  )  ;", "ImportSelector   selector    =    BeanUtils . instantiateClass ( candidateClass ,    ImportSelector . class )  ;", "ParserStrategyUtils . invokeAwareMethods ( selector ,    this . environment ,    this . resourceLoader ,    this . registry )  ;", "if    (  (  ( this . deferredImportSelectors )     !  =    null )     &  &     ( selector   instanceof   DeferredImportSelector )  )     {", "this . deferredImportSelectors . add ( new    . DeferredImportSelectorHolder ( configClass ,     (  ( DeferredImportSelector )     ( selector )  )  )  )  ;", "} else    {", "String [  ]    importClassNames    =    selector . selectImports ( currentSourceClass . getMetadata (  )  )  ;", "Collection <  . SourceClass >    importSourceClasses    =    asSourceClasses ( importClassNames )  ;", "processImports ( configClass ,    currentSourceClass ,    importSourceClasses ,    false )  ;", "}", "} else", "if    ( candidate . isAssignable ( ImportBeanDefinitionRegistrar . class )  )     {", "Class <  ?  >    candidateClass    =    candidate . loadClass (  )  ;", "ImportBeanDefinitionRegistrar   registrar    =    BeanUtils . instantiateClass ( candidateClass ,    ImportBeanDefinitionRegistrar . class )  ;", "ParserStrategyUtils . invokeAwareMethods ( registrar ,    this . environment ,    this . resourceLoader ,    this . registry )  ;", "configClass . addImportBeanDefinitionRegistrar ( registrar ,    currentSourceClass . getMetadata (  )  )  ;", "} else    {", "this . importStack . registerImport ( currentSourceClass . getMetadata (  )  ,    candidate . getMetadata (  )  . getClassName (  )  )  ;", "processConfigurationClass ( candidate . asConfigClass ( configClass )  )  ;", "}", "}", "}    catch    ( BeanDefinitionStoreException   ex )     {", "throw   ex ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanDefinitionStoreException (  (  (  \" Failed   to   process   import   candidates   for   configuration   class    [  \"     +     ( configClass . getMetadata (  )  . getClassName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}    finally    {", "this . importStack . pop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processImports"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "for    ( ConfigurationClassParser . SourceClass   ifc    :    sourceClass . getInterfaces (  )  )     {", "Set < MethodMetadata >    beanMethods    =    retrieveBeanMethodMetadata ( ifc )  ;", "for    ( MethodMetadata   methodMetadata    :    beanMethods )     {", "if    (  !  ( methodMetadata . isAbstract (  )  )  )     {", "configClass . addBeanMethod ( new   BeanMethod ( methodMetadata ,    configClass )  )  ;", "}", "}", "processInterfaces ( configClass ,    ifc )  ;", "}", "}", "METHOD_END"], "methodName": ["processInterfaces"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "Collection < ConfigurationClassParser . SourceClass >    memberClasses    =    sourceClass . getMemberClasses (  )  ;", "if    (  !  ( memberClasses . isEmpty (  )  )  )     {", "List < ConfigurationClassParser . SourceClass >    candidates    =    new   ArrayList <  >  ( memberClasses . size (  )  )  ;", "for    ( ConfigurationClassParser . SourceClass   memberClass    :    memberClasses )     {", "if    (  ( ConfigurationClassUtils . isConfigurationCandidate ( memberClass . getMetadata (  )  )  )     &  &     (  !  ( memberClass . getMetadata (  )  . getClassName (  )  . equals ( configClass . getMetadata (  )  . getClassName (  )  )  )  )  )     {", "candidates . add ( memberClass )  ;", "}", "}", "OrderComparator . sort ( candidates )  ;", "for    ( ConfigurationClassParser . SourceClass   candidate    :    candidates )     {", "if    ( this . importStack . contains ( configClass )  )     {", "this . problemReporter . error ( new   ConfigurationClassParser . CircularImportProblem ( configClass ,    this . importStack )  )  ;", "} else    {", "this . importStack . push ( configClass )  ;", "try    {", "processConfigurationClass ( candidate . asConfigClass ( configClass )  )  ;", "}    finally    {", "this . importStack . pop (  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processMemberClasses"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    propertySource . getString (  \" name \"  )  ;", "if    (  !  ( StringUtils . hasLength ( name )  )  )     {", "name    =    null ;", "}", "String   encoding    =    propertySource . getString (  \" encoding \"  )  ;", "if    (  !  ( StringUtils . hasLength ( encoding )  )  )     {", "encoding    =    null ;", "}", "String [  ]    locations    =    propertySource . getStringArray (  \" value \"  )  ;", "Assert . isTrue (  (  ( locations . length )     >     0  )  ,     \" At   least   one    @ PropertySource ( value )    location   is   required \"  )  ;", "boolean   ignoreResourceNotFound    =    propertySource . getBoolean (  \" ignoreResourceNotFound \"  )  ;", "Class <  ?    extends   PropertySourceFactory >    factoryClass    =    propertySource . getClass (  \" factory \"  )  ;", "PropertySourceFactory   factory    =     ( factoryClass    =  =     ( PropertySourceFactory . class )  )     ?     . DEFAULT _ PROPERTY _ SOURCE _ FACTORY    :    BeanUtils . instantiateClass ( factoryClass )  ;", "for    ( String   location    :    locations )     {", "try    {", "String   resolvedLocation    =    this . environment . resolveRequiredPlaceholders ( location )  ;", "Resource   resource    =    this . resourceLoader . getResource ( resolvedLocation )  ;", "addPropertySource ( factory . createPropertySource ( name ,    new   EncodedResource ( resource ,    encoding )  )  )  ;", "}    catch    ( IllegalArgumentException    |    FileNotFoundException    |    UnknownHostException   ex )     {", "if    ( ignoreResourceNotFound )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  \" Properties   location    [  \"     +    location )     +     \"  ]    not   resolvable :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "} else    {", "throw   ex ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processPropertySource"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   original    =    sourceClass . getMetadata (  )  ;", "Set < MethodMetadata >    beanMethods    =    original . getAnnotatedMethods ( Bean . class . getName (  )  )  ;", "if    (  (  ( beanMethods . size (  )  )     >     1  )     &  &     ( original   instanceof   StandardAnnotationMetadata )  )     {", "try    {", "AnnotationMetadata   asm    =    this . metadataReaderFactory . getMetadataReader ( original . getClassName (  )  )  . getAnnotationMetadata (  )  ;", "Set < MethodMetadata >    asmMethods    =    asm . getAnnotatedMethods ( Bean . class . getName (  )  )  ;", "if    (  ( asmMethods . size (  )  )     >  =     ( beanMethods . size (  )  )  )     {", "Set < MethodMetadata >    selectedMethods    =    new   LinkedHashSet ( asmMethods . size (  )  )  ;", "for    ( MethodMetadata   asmMethod    :    asmMethods )     {", "for    ( MethodMetadata   beanMethod    :    beanMethods )     {", "if    ( beanMethod . getMethodName (  )  . equals ( asmMethod . getMethodName (  )  )  )     {", "selectedMethods . add ( beanMethod )  ;", "break ;", "}", "}", "}", "if    (  ( selectedMethods . size (  )  )     =  =     ( beanMethods . size (  )  )  )     {", "beanMethods    =    selectedMethods ;", "}", "}", "}    catch    ( IOException   ex )     {", "logger . debug (  \" Failed   to   read   class   file   via   ASM   for   determining    @ Bean   method   order \"  ,    ex )  ;", "}", "}", "return   beanMethods ;", "}", "METHOD_END"], "methodName": ["retrieveBeanMethodMetadata"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "for    ( ConfigurationClass   configClass    :    this . configurationClasses . keySet (  )  )     {", "configClass . validate ( this . problemReporter )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.springframework.context.annotation.ConfigurationClassParser"}, {"methodBody": ["METHOD_START", "{", "ConfigurationClassPostConstructAndAutowiringTests . Config 1    config 1     =    ctx . getBean ( ConfigurationClassPostConstructAndAutowiringTests . Config 1  . class )  ;", "TestBean   testBean    =    ctx . getBean ( TestBean . class )  ;", "assertThat ( config 1  . beanMethodCallCount ,    is (  1  )  )  ;", "assertThat ( testBean . getAge (  )  ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["assertions"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostConstructAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . Config 1  . class ,     . Config 2  . class )  ;", "ctx . refresh (  )  ;", "assertions ( ctx )  ;", ". Config 2    config 2     =    ctx . getBean (  . Config 2  . class )  ;", "assertThat ( config 2  . testBean ,    is ( ctx . getBean ( TestBean . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["control"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostConstructAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . Config 2  . class ,     . Config 1  . class )  ;", "ctx . refresh (  )  ;", "assertions ( ctx )  ;", "}", "METHOD_END"], "methodName": ["originalReproCase"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostConstructAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    AbstractBeanDefinition >    configBeanDefs    =    new   LinkedHashMap <  >  (  )  ;", "for    ( String   beanName    :    beanFactory . getBeanDefinitionNames (  )  )     {", "BeanDefinition   beanDef    =    beanFactory . getBeanDefinition ( beanName )  ;", "if    ( Utils . isFull ( beanDef )  )     {", "if    (  !  ( beanDef   instanceof   AbstractBeanDefinition )  )     {", "throw   new   BeanDefinitionStoreException (  (  (  \" Cannot   enhance    @ Configuration   bean   definition    '  \"     +    beanName )     +     \"  '    since   it   is   not   stored   in   an   AbstractBeanDefinition   subclass \"  )  )  ;", "} else", "if    (  ( logger . isWarnEnabled (  )  )     &  &     ( beanFactory . containsSingleton ( beanName )  )  )     {", "logger . warn (  (  (  (  (  \" Cannot   enhance    @ Configuration   bean   definition    '  \"     +    beanName )     +     \"  '    since   its   singleton   instance   has   been   created   too   early .    The   typical   cause    \"  )     +     \" is   a   non - static    @ Bean   method   with   a   BeanDefinitionRegistryPostProcessor    \"  )     +     \" return   type :    Consider   declaring   such   methods   as    ' static '  .  \"  )  )  ;", "}", "configBeanDefs . put ( beanName ,     (  ( AbstractBeanDefinition )     ( beanDef )  )  )  ;", "}", "}", "if    ( configBeanDefs . isEmpty (  )  )     {", "return ;", "}", "Enhancer   enhancer    =    new   Enhancer (  )  ;", "for    ( Map . Entry < String ,    AbstractBeanDefinition >    entry    :    configBeanDefs . entrySet (  )  )     {", "AbstractBeanDefinition   beanDef    =    entry . getValue (  )  ;", "beanDef . setAttribute ( PRESERVE _ TARGET _ CLASS _ ATTRIBUTE ,    Boolean . TRUE )  ;", "try    {", "Class <  ?  >    configClass    =    beanDef . resolveBeanClass ( this . beanClassLoader )  ;", "if    ( configClass    !  =    null )     {", "Class <  ?  >    enhancedClass    =    enhancer . enhance ( configClass ,    this . beanClassLoader )  ;", "if    ( configClass    !  =    enhancedClass )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug ( String . format (  (  \" Replacing   bean   definition    '  % s '    existing   class    '  % s '    with    \"     +     \" enhanced   class    '  % s '  \"  )  ,    entry . getKey (  )  ,    configClass . getName (  )  ,    enhancedClass . getName (  )  )  )  ;", "}", "beanDef . setBeanClass ( enhancedClass )  ;", "}", "}", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  \" Cannot   load   configuration   class :     \"     +     ( beanDef . getBeanClassName (  )  )  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["enhanceConfigurationClasses"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessor"}, {"methodBody": ["METHOD_START", "{", "List < BeanDefinitionHolder >    configCandidates    =    new   ArrayList <  >  (  )  ;", "String [  ]    candidateNames    =    registry . getBeanDefinitionNames (  )  ;", "for    ( String   beanName    :    candidateNames )     {", "BeanDefinition   beanDef    =    registry . getBeanDefinition ( beanName )  ;", "if    (  ( ConfigurationClassUtils . isFullConfigurationClass ( beanDef )  )     |  |     ( ConfigurationClassUtils . isLiteConfigurationClass ( beanDef )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Bean   definition   has   already   been   processed   as   a   configuration   class :     \"     +    beanDef )  )  ;", "}", "} else", "if    ( ConfigurationClassUtils . checkConfigurationClassCandidate ( beanDef ,    this . metadataReaderFactory )  )     {", "configCandidates . add ( new   BeanDefinitionHolder ( beanDef ,    beanName )  )  ;", "}", "}", "if    ( configCandidates . isEmpty (  )  )     {", "return ;", "}", "configCandidates . sort (  (    bd 1  ,    bd 2  )     -  >     {", "int   i 1     =    ConfigurationClassUtils . getOrder ( bd 1  . getBeanDefinition (  )  )  ;", "int   i 2     =    ConfigurationClassUtils . getOrder ( bd 2  . getBeanDefinition (  )  )  ;", "return   Integer . compare ( i 1  ,    i 2  )  ;", "}  )  ;", "SingletonBeanRegistry   sbr    =    null ;", "if    ( registry   instanceof   SingletonBeanRegistry )     {", "sbr    =     (  ( SingletonBeanRegistry )     ( registry )  )  ;", "if    (  !  ( this . localBeanNameGeneratorSet )  )     {", "BeanNameGenerator   generator    =     (  ( BeanNameGenerator )     ( sbr . getSingleton ( AnnotationConfigUtils . CONFIGURATION _ BEAN _ NAME _ GENERATOR )  )  )  ;", "if    ( generator    !  =    null )     {", "this . componentScanBeanNameGenerator    =    generator ;", "this . importBeanNameGenerator    =    generator ;", "}", "}", "}", "if    (  ( this . environment )     =  =    null )     {", "this . environment    =    new   StandardEnvironment (  )  ;", "}", "ConfigurationClassParser   parser    =    new   ConfigurationClassParser ( this . metadataReaderFactory ,    this . problemReporter ,    this . environment ,    this . resourceLoader ,    this . componentScanBeanNameGenerator ,    registry )  ;", "Set < BeanDefinitionHolder >    candidates    =    new   LinkedHashSet ( configCandidates )  ;", "Set < ConfigurationClass >    alreadyParsed    =    new   HashSet ( configCandidates . size (  )  )  ;", "do    {", "parser . parse ( candidates )  ;", "parser . validate (  )  ;", "Set < ConfigurationClass >    configClasses    =    new   LinkedHashSet <  >  ( parser . getConfigurationClasses (  )  )  ;", "configClasses . removeAll ( alreadyParsed )  ;", "if    (  ( this . reader )     =  =    null )     {", "this . reader    =    new   ConfigurationClassBeanDefinitionReader ( registry ,    this . sourceExtractor ,    this . resourceLoader ,    this . environment ,    this . importBeanNameGenerator ,    parser . getImportRegistry (  )  )  ;", "}", "this . reader . loadBeanDefinitions ( configClasses )  ;", "alreadyParsed . addAll ( configClasses )  ;", "candidates . clear (  )  ;", "if    (  ( registry . getBeanDefinitionCount (  )  )     >     ( candidateNames . length )  )     {", "String [  ]    newCandidateNames    =    registry . getBeanDefinitionNames (  )  ;", "Set < String >    oldCandidateNames    =    new   HashSet <  >  ( Arrays . asList ( candidateNames )  )  ;", "Set < String >    alreadyParsedClasses    =    new   HashSet <  >  (  )  ;", "for    ( ConfigurationClass   configurationClass    :    alreadyParsed )     {", "alreadyParsedClasses . add ( configurationClass . getMetadata (  )  . getClassName (  )  )  ;", "}", "for    ( String   candidateName    :    newCandidateNames )     {", "if    (  !  ( oldCandidateNames . contains ( candidateName )  )  )     {", "BeanDefinition   bd    =    registry . getBeanDefinition ( candidateName )  ;", "if    (  ( ConfigurationClassUtils . checkConfigurationClassCandidate ( bd ,    this . metadataReaderFactory )  )     &  &     (  !  ( alreadyParsedClasses . contains ( bd . getBeanClassName (  )  )  )  )  )     {", "candidates . add ( new   BeanDefinitionHolder ( bd ,    candidateName )  )  ;", "}", "}", "}", "candidateNames    =    newCandidateNames ;", "}", "}    while    (  !  ( candidates . isEmpty (  )  )     )  ;", "if    (  ( sbr    !  =    null )     &  &     (  !  ( sbr . containsSingleton (  . IMPORT _ REGISTRY _ BEAN _ NAME )  )  )  )     {", "sbr . registerSingleton (  . IMPORT _ REGISTRY _ BEAN _ NAME ,    parser . getImportRegistry (  )  )  ;", "}", "if    (  ( this . metadataReaderFactory )    instanceof   CachingMetadataReaderFactory )     {", "(  ( CachingMetadataReaderFactory )     ( this . metadataReaderFactory )  )  . clearCache (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processConfigBeanDefinitions"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( beanNameGenerator ,     \" BeanNameGenerator   must   not   be   null \"  )  ;", "this . localBeanNameGeneratorSet    =    true ;", "this . componentScanBeanNameGenerator    =    beanNameGenerator ;", "this . importBeanNameGenerator    =    beanNameGenerator ;", "}", "METHOD_END"], "methodName": ["setBeanNameGenerator"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( metadataReaderFactory ,     \" MetadataReaderFactory   must   not   be   null \"  )  ;", "this . metadataReaderFactory    =    metadataReaderFactory ;", "this . setMetadataReaderFactoryCalled    =    true ;", "}", "METHOD_END"], "methodName": ["setMetadataReaderFactory"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . problemReporter    =     ( problemReporter    !  =    null )     ?    problemReporter    :    new   FailFastProblemReporter (  )  ;", "}", "METHOD_END"], "methodName": ["setProblemReporter"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . sourceExtractor    =     ( sourceExtractor    !  =    null )     ?    sourceExtractor    :    new   PassThroughSourceExtractor (  )  ;", "}", "METHOD_END"], "methodName": ["setSourceExtractor"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessor"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" unloadedConfig \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . UnloadedConfig . class . getName (  )  )  )  ;", "beanFactory . registerBeanDefinition (  \" loadedConfig \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . LoadedConfig . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . getBean (  \" foo \"  )  ;", "beanFactory . getBean (  \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["alreadyLoadedConfigurationClasses"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config \"  ,    beanDefinition )  ;", "pp    =    new    (  )  ;", "pp . setEnvironment ( new   StandardEnvironment (  )  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "SimpleComponent   simpleComponent    =    beanFactory . getBean ( SimpleComponent . class )  ;", "assertNotNull ( simpleComponent )  ;", "}", "METHOD_END"], "methodName": ["assertSupportForComposedAnnotation"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config \"  ,    beanDefinition )  ;", "pp    =    new    (  )  ;", "pp . setEnvironment ( new   StandardEnvironment (  )  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "try    {", "beanFactory . getBean ( SimpleComponent . class )  ;", "fail (  \" Should   have   thrown   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["assertSupportForComposedAnnotationWithExclude"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config 1  \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . OverridingSingletonBeanConfig . class )  )  ;", "beanFactory . registerBeanDefinition (  \" config 2  \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . SingletonBeanConfig . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "ConfigurationClassPostProcessorTests . Foo   foo    =    beanFactory . getBean ( ConfigurationClassPostProcessorTests . Foo . class )  ;", "assertTrue (  ( foo   instanceof   ConfigurationClassPostProcessorTests . ExtendedFoo )  )  ;", "ConfigurationClassPostProcessorTests . Bar   bar    =    beanFactory . getBean ( ConfigurationClassPostProcessorTests . Bar . class )  ;", "assertSame ( foo ,    bar . foo )  ;", "}", "METHOD_END"], "methodName": ["configurationClassesProcessedInCorrectOrder"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config 1  \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . InvalidOverridingSingletonBeanConfig . class )  )  ;", "beanFactory . registerBeanDefinition (  \" config 2  \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . OverridingSingletonBeanConfig . class )  )  ;", "beanFactory . registerBeanDefinition (  \" config 3  \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . SingletonBeanConfig . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "try    {", "beanFactory . getBean ( ConfigurationClassPostProcessorTests . Bar . class )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" OverridingSingletonBeanConfig . foo \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( ConfigurationClassPostProcessorTests . ExtendedFoo . class . getName (  )  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( ConfigurationClassPostProcessorTests . Foo . class . getName (  )  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" InvalidOverridingSingletonBeanConfig \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configurationClassesWithInvalidOverridingForProgrammaticCall"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config 1  \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . OverridingAgainSingletonBeanConfig . class )  )  ;", "beanFactory . registerBeanDefinition (  \" config 2  \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . OverridingSingletonBeanConfig . class )  )  ;", "beanFactory . registerBeanDefinition (  \" config 3  \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . SingletonBeanConfig . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "ConfigurationClassPostProcessorTests . Foo   foo    =    beanFactory . getBean ( ConfigurationClassPostProcessorTests . Foo . class )  ;", "assertTrue (  ( foo   instanceof   ConfigurationClassPostProcessorTests . ExtendedAgainFoo )  )  ;", "ConfigurationClassPostProcessorTests . Bar   bar    =    beanFactory . getBean ( ConfigurationClassPostProcessorTests . Bar . class )  ;", "assertSame ( foo ,    bar . foo )  ;", "}", "METHOD_END"], "methodName": ["configurationClassesWithValidOverridingForProgrammaticCall"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  (  ( getClass (  )  . getName (  )  )     +     \"  . SingletonBeanConfig \"  )  )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", ". Foo   foo    =    beanFactory . getBean (  \" foo \"  ,     . Foo . class )  ;", ". Bar   bar    =    beanFactory . getBean (  \" bar \"  ,     . Bar . class )  ;", "assertSame ( foo ,    bar . foo )  ;", "}", "METHOD_END"], "methodName": ["configurationIntrospectionOfInnerClassesWorksWithDotNameSyntax"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . SingletonBeanConfig . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "ConfigurationClassPostProcessorTests . Foo   foo    =    beanFactory . getBean (  \" foo \"  ,    ConfigurationClassPostProcessorTests . Foo . class )  ;", "ConfigurationClassPostProcessorTests . Bar   bar    =    beanFactory . getBean (  \" bar \"  ,    ConfigurationClassPostProcessorTests . Bar . class )  ;", "assertSame ( foo ,    bar . foo )  ;", "assertTrue ( Arrays . asList ( beanFactory . getDependentBeans (  \" foo \"  )  )  . contains (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["enhancementIsPresentBecauseSingletonSemanticsAreRespected"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryInjectionBean . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "beanFactory . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . RepositoryConfiguration . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", ". RepositoryInjectionBean   bean    =     (  (  . RepositoryInjectionBean )     ( beanFactory . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  \" Repository < String >  \"  ,    bean . stringRepository . toString (  )  )  ;", "assertEquals (  \" Repository < Integer >  \"  ,    bean . integerRepository . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjection"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RepositoryConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( ConfigurationClassPostProcessorTests . Repository . class )  ;", "assertTrue ( ObjectUtils . containsElement ( beanNames ,     \" stringRepo \"  )  )  ;", "beanNames    =    beanFactory . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( ConfigurationClassPostProcessorTests . Repository . class ,    String . class )  )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" stringRepo \"  ,    beanNames [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithEarlyGenericsMatching"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RepositoryConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "DefaultAdvisorAutoProxyCreator   autoProxyCreator    =    new   DefaultAdvisorAutoProxyCreator (  )  ;", "autoProxyCreator . setProxyTargetClass ( true )  ;", "autoProxyCreator . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( autoProxyCreator )  ;", "beanFactory . registerSingleton (  \" traceInterceptor \"  ,    new   DefaultPointcutAdvisor ( new   SimpleTraceInterceptor (  )  )  )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( ConfigurationClassPostProcessorTests . Repository . class )  ;", "assertTrue ( ObjectUtils . containsElement ( beanNames ,     \" stringRepo \"  )  )  ;", "beanNames    =    beanFactory . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( ConfigurationClassPostProcessorTests . Repository . class ,    String . class )  )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" stringRepo \"  ,    beanNames [  0  ]  )  ;", "assertTrue ( AopUtils . isCglibProxy ( beanFactory . getBean (  \" stringRepo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithEarlyGenericsMatchingOnCglibProxy"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RepositoryConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "DefaultAdvisorAutoProxyCreator   autoProxyCreator    =    new   DefaultAdvisorAutoProxyCreator (  )  ;", "autoProxyCreator . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( autoProxyCreator )  ;", "beanFactory . registerSingleton (  \" traceInterceptor \"  ,    new   DefaultPointcutAdvisor ( new   SimpleTraceInterceptor (  )  )  )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( ConfigurationClassPostProcessorTests . RepositoryInterface . class )  ;", "assertTrue ( ObjectUtils . containsElement ( beanNames ,     \" stringRepo \"  )  )  ;", "beanNames    =    beanFactory . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( ConfigurationClassPostProcessorTests . RepositoryInterface . class ,    String . class )  )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" stringRepo \"  ,    beanNames [  0  ]  )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( beanFactory . getBean (  \" stringRepo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithEarlyGenericsMatchingOnJdkProxy"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFactoryBeanInjectionBean . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "beanFactory . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . RepositoryFactoryBeanConfiguration . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . preInstantiateSingletons (  )  ;", ". RepositoryFactoryBeanInjectionBean   bean    =     (  (  . RepositoryFactoryBeanInjectionBean )     ( beanFactory . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( beanFactory . getBean (  \"  & repoFactoryBean \"  )  ,    bean . repositoryFactoryBean )  ;", "assertSame ( beanFactory . getBean (  \"  & repoFactoryBean \"  )  ,    bean . qualifiedRepositoryFactoryBean )  ;", "assertSame ( beanFactory . getBean (  \"  & repoFactoryBean \"  )  ,    bean . prefixQualifiedRepositoryFactoryBean )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithFactoryBean"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . SpecificRepositoryInjectionBean . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "beanFactory . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . SpecificRepositoryConfiguration . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . preInstantiateSingletons (  )  ;", ". SpecificRepositoryInjectionBean   bean    =     (  (  . SpecificRepositoryInjectionBean )     ( beanFactory . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( beanFactory . getBean (  \" genericRepo \"  )  ,    bean . genericRepository )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithImplTypeAtInjectionPoint"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RepositoryConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( ConfigurationClassPostProcessorTests . Repository . class )  ;", "assertTrue ( ObjectUtils . containsElement ( beanNames ,     \" stringRepo \"  )  )  ;", "beanNames    =    beanFactory . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( ConfigurationClassPostProcessorTests . Repository . class ,    String . class )  )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" stringRepo \"  ,    beanNames [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithLateGenericsMatching"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RepositoryConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "DefaultAdvisorAutoProxyCreator   autoProxyCreator    =    new   DefaultAdvisorAutoProxyCreator (  )  ;", "autoProxyCreator . setProxyTargetClass ( true )  ;", "autoProxyCreator . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( autoProxyCreator )  ;", "beanFactory . registerSingleton (  \" traceInterceptor \"  ,    new   DefaultPointcutAdvisor ( new   SimpleTraceInterceptor (  )  )  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( ConfigurationClassPostProcessorTests . Repository . class )  ;", "assertTrue ( ObjectUtils . containsElement ( beanNames ,     \" stringRepo \"  )  )  ;", "beanNames    =    beanFactory . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( ConfigurationClassPostProcessorTests . Repository . class ,    String . class )  )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" stringRepo \"  ,    beanNames [  0  ]  )  ;", "assertTrue ( AopUtils . isCglibProxy ( beanFactory . getBean (  \" stringRepo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithLateGenericsMatchingOnCglibProxy"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RawRepositoryConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "DefaultAdvisorAutoProxyCreator   autoProxyCreator    =    new   DefaultAdvisorAutoProxyCreator (  )  ;", "autoProxyCreator . setProxyTargetClass ( true )  ;", "autoProxyCreator . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( autoProxyCreator )  ;", "beanFactory . registerSingleton (  \" traceInterceptor \"  ,    new   DefaultPointcutAdvisor ( new   SimpleTraceInterceptor (  )  )  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( ConfigurationClassPostProcessorTests . Repository . class )  ;", "assertTrue ( ObjectUtils . containsElement ( beanNames ,     \" stringRepo \"  )  )  ;", "beanNames    =    beanFactory . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( ConfigurationClassPostProcessorTests . Repository . class ,    String . class )  )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" stringRepo \"  ,    beanNames [  0  ]  )  ;", "assertTrue ( AopUtils . isCglibProxy ( beanFactory . getBean (  \" stringRepo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithLateGenericsMatchingOnCglibProxyAndRawFactoryMethod"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RepositoryConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "DefaultAdvisorAutoProxyCreator   autoProxyCreator    =    new   DefaultAdvisorAutoProxyCreator (  )  ;", "autoProxyCreator . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( autoProxyCreator )  ;", "beanFactory . registerSingleton (  \" traceInterceptor \"  ,    new   DefaultPointcutAdvisor ( new   SimpleTraceInterceptor (  )  )  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( ConfigurationClassPostProcessorTests . RepositoryInterface . class )  ;", "assertTrue ( ObjectUtils . containsElement ( beanNames ,     \" stringRepo \"  )  )  ;", "beanNames    =    beanFactory . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( ConfigurationClassPostProcessorTests . RepositoryInterface . class ,    String . class )  )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" stringRepo \"  ,    beanNames [  0  ]  )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( beanFactory . getBean (  \" stringRepo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithLateGenericsMatchingOnJdkProxy"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RawRepositoryConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "DefaultAdvisorAutoProxyCreator   autoProxyCreator    =    new   DefaultAdvisorAutoProxyCreator (  )  ;", "autoProxyCreator . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( autoProxyCreator )  ;", "beanFactory . registerSingleton (  \" traceInterceptor \"  ,    new   DefaultPointcutAdvisor ( new   SimpleTraceInterceptor (  )  )  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( ConfigurationClassPostProcessorTests . RepositoryInterface . class )  ;", "assertTrue ( ObjectUtils . containsElement ( beanNames ,     \" stringRepo \"  )  )  ;", "beanNames    =    beanFactory . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( ConfigurationClassPostProcessorTests . RepositoryInterface . class ,    String . class )  )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" stringRepo \"  ,    beanNames [  0  ]  )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( beanFactory . getBean (  \" stringRepo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithLateGenericsMatchingOnJdkProxyAndRawFactoryMethod"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . RawMatchingConfiguration . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "assertSame ( beanFactory . getBean (  \" rawRepo \"  )  ,    beanFactory . getBean (  \" repoConsumer \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithRawMatch"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryInjectionBean . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "beanFactory . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . ScopedRepositoryConfiguration . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", ". RepositoryInjectionBean   bean    =     (  (  . RepositoryInjectionBean )     ( beanFactory . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  \" Repository < String >  \"  ,    bean . stringRepository . toString (  )  )  ;", "assertEquals (  \" Repository < Integer >  \"  ,    bean . integerRepository . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithScoped"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryInjectionBean . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "beanFactory . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . ScopedProxyRepositoryConfiguration . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . freezeConfiguration (  )  ;", ". RepositoryInjectionBean   bean    =     (  (  . RepositoryInjectionBean )     ( beanFactory . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  \" Repository < String >  \"  ,    bean . stringRepository . toString (  )  )  ;", "assertEquals (  \" Repository < Integer >  \"  ,    bean . integerRepository . toString (  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean . stringRepository )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean . integerRepository )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithScopedProxy"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryInjectionBean . class . getName (  )  )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "beanFactory . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . ScopedProxyRepositoryConfiguration . class . getName (  )  )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . freezeConfiguration (  )  ;", ". RepositoryInjectionBean   bean    =     (  (  . RepositoryInjectionBean )     ( beanFactory . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  \" Repository < String >  \"  ,    bean . stringRepository . toString (  )  )  ;", "assertEquals (  \" Repository < Integer >  \"  ,    bean . integerRepository . toString (  )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean . stringRepository )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( bean . integerRepository )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithScopedProxyUsingAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . WildcardMatchingConfiguration . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "assertSame ( beanFactory . getBean (  \" genericRepo \"  )  ,    beanFactory . getBean (  \" repoConsumer \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithWildcardMatch"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . WildcardWithExtendsConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "assertSame ( beanFactory . getBean (  \" stringRepo \"  )  ,    beanFactory . getBean (  \" repoConsumer \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithWildcardWithExtendsMatch"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . WildcardWithGenericExtendsConfiguration . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "assertSame ( beanFactory . getBean (  \" genericRepo \"  )  ,    beanFactory . getBean (  \" repoConsumer \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericsBasedInjectionWithWildcardWithGenericExtendsMatch"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ConfigWithOrderedInnerClasses . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( new   AutowiredAnnotationBeanPostProcessor (  )  )  ;", "ConfigurationClassPostProcessorTests . Foo   foo    =    beanFactory . getBean ( ConfigurationClassPostProcessorTests . Foo . class )  ;", "assertTrue (  ( foo   instanceof   ConfigurationClassPostProcessorTests . ExtendedFoo )  )  ;", "ConfigurationClassPostProcessorTests . Bar   bar    =    beanFactory . getBean ( ConfigurationClassPostProcessorTests . Bar . class )  ;", "assertSame ( foo ,    bar . foo )  ;", "}", "METHOD_END"], "methodName": ["innerConfigurationClassesProcessedInCorrectOrder"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ConfigWithOrderedNestedClasses . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "ConfigurationClassPostProcessorTests . Foo   foo    =    beanFactory . getBean ( ConfigurationClassPostProcessorTests . Foo . class )  ;", "assertTrue (  ( foo   instanceof   ConfigurationClassPostProcessorTests . ExtendedFoo )  )  ;", "ConfigurationClassPostProcessorTests . Bar   bar    =    beanFactory . getBean ( ConfigurationClassPostProcessorTests . Bar . class )  ;", "assertSame ( foo ,    bar . foo )  ;", "}", "METHOD_END"], "methodName": ["nestedConfigurationClassesProcessedInCorrectOrder"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setResource ( new   DescriptiveResource (  \" XML   or   something \"  )  )  ;", "beanFactory . registerBeanDefinition (  \" bar \"  ,    rbd )  ;", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . SingletonBeanConfig . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . getBean (  \" foo \"  ,     . Foo . class )  ;", "beanFactory . getBean (  \" bar \"  ,    TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["postProcessorDoesNotOverrideRegularBeanDefinitions"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setResource ( new   DescriptiveResource (  \" XML   or   something \"  )  )  ;", "BeanDefinitionHolder   proxied    =    ScopedProxyUtils . createScopedProxy ( new   BeanDefinitionHolder ( rbd ,     \" bar \"  )  ,    beanFactory ,    true )  ;", "beanFactory . registerBeanDefinition (  \" bar \"  ,    proxied . getBeanDefinition (  )  )  ;", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . SingletonBeanConfig . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . getBean (  \" foo \"  ,     . Foo . class )  ;", "beanFactory . getBean (  \" bar \"  ,    TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["postProcessorDoesNotOverrideRegularBeanDefinitionsEvenWithScopedProxy"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setResource ( new   DescriptiveResource (  \" XML   or   something \"  )  )  ;", "beanFactory . registerBeanDefinition (  \" bar \"  ,    rbd )  ;", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . SingletonBeanConfig . class )  )  ;", "beanFactory . setAllowBeanDefinitionOverriding ( false )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "try    {", "pp . postProcessBeanFactory ( beanFactory )  ;", "fail (  \" Should   have   thrown   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" bar \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" SingletonBeanConfig \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( TestBean . class . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["postProcessorFailsOnImplicitOverrideIfOverridingIsNotAllowed"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . SingletonBeanConfig . class )  )  ;", "beanFactory . registerBeanDefinition (  \" parent \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "beanFactory . registerBeanDefinition (  \" child \"  ,    new   ChildBeanDefinition (  \" parent \"  )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "ConfigurationClassPostProcessorTests . Foo   foo    =    beanFactory . getBean (  \" foo \"  ,    ConfigurationClassPostProcessorTests . Foo . class )  ;", "ConfigurationClassPostProcessorTests . Bar   bar    =    beanFactory . getBean (  \" bar \"  ,    ConfigurationClassPostProcessorTests . Bar . class )  ;", "assertSame ( foo ,    bar . foo )  ;", "}", "METHOD_END"], "methodName": ["postProcessorIntrospectsInheritedDefinitionsCorrectly"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setRole ( ROLE _ SUPPORT )  ;", "beanFactory . registerBeanDefinition (  \" bar \"  ,    rbd )  ;", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . SingletonBeanConfig . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", ". Foo   foo    =    beanFactory . getBean (  \" foo \"  ,     . Foo . class )  ;", ". Bar   bar    =    beanFactory . getBean (  \" bar \"  ,     . Bar . class )  ;", "assertSame ( foo ,    bar . foo )  ;", "}", "METHOD_END"], "methodName": ["postProcessorOverridesNonApplicationBeanDefinitions"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ComposedComposedConfigurationWithAttributeOverridesClass . class . getName (  )  )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithComposedComposedConfigurationWithAttributeOverridesUsingAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ComposedComposedConfigurationWithAttributeOverridesClass . class )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithComposedComposedConfigurationWithAttributeOverridesUsingReflection"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ComposedConfigurationClass . class . getName (  )  )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithComposedConfigurationUsingAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ComposedConfigurationClass . class )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithComposedConfigurationUsingReflection"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ComposedConfigurationWithAttributeOverrideForBasePackage . class . getName (  )  )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithComposedConfigurationWithAttributeOverrideForBasePackageUsingAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ComposedConfigurationWithAttributeOverrideForBasePackage . class )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithComposedConfigurationWithAttributeOverrideForBasePackageUsingReflection"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ComposedConfigurationWithAttributeOverrideForExcludeFilter . class . getName (  )  )  ;", "assertSupportForComposedAnnotationWithExclude ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithComposedConfigurationWithAttributeOverrideForExcludeFilterUsingAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . ComposedConfigurationWithAttributeOverrideForExcludeFilter . class )  ;", "assertSupportForComposedAnnotationWithExclude ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithComposedConfigurationWithAttributeOverrideForExcludeFilterUsingReflection"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . SubMetaComponentScanConfigurationWithAttributeOverridesClass . class . getName (  )  )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithMetaComponentScanConfigurationWithAttributeOverridesSubclassUsingAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . SubMetaComponentScanConfigurationWithAttributeOverridesClass . class )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithMetaComponentScanConfigurationWithAttributeOverridesSubclassUsingReflection"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . MetaComponentScanConfigurationWithAttributeOverridesClass . class . getName (  )  )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithMetaComponentScanConfigurationWithAttributeOverridesUsingAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( ConfigurationClassPostProcessorTests . MetaComponentScanConfigurationWithAttributeOverridesClass . class )  ;", "assertSupportForComposedAnnotation ( beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcessorWorksWithMetaComponentScanConfigurationWithAttributeOverridesUsingReflection"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf 1     =    new   DefaultListableBeanFactory (  )  ;", "DefaultListableBeanFactory   bf 2     =    new   DefaultListableBeanFactory (  )  ;", "pp    =    new    (  )  ;", "pp . postProcessBeanFactory ( bf 1  )  ;", "try    {", "pp . postProcessBeanFactory ( bf 1  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "pp . postProcessBeanFactory ( bf 2  )  ;", "try    {", "pp . postProcessBeanFactory ( bf 2  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["processingAllowedOnlyOncePerProcessorRegistryPair"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . ScopedProxyConfigurationClass . class )  )  ;", "beanFactory . registerBeanDefinition (  \" consumer \"  ,    new   RootBeanDefinition (  . ScopedProxyConsumer . class )  )  ;", "ConfigurationClassPostProcessor   pp    =    new   ConfigurationClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "ITestBean   injected    =    beanFactory . getBean (  \" consumer \"  ,     . ScopedProxyConsumer . class )  . testBean ;", "assertTrue (  ( injected   instanceof   ScopedObject )  )  ;", "assertSame ( beanFactory . getBean (  \" scopedClass \"  )  ,    injected )  ;", "assertSame ( beanFactory . getBean ( ITestBean . class )  ,    injected )  ;", "}", "METHOD_END"], "methodName": ["scopedProxyTargetMarkedAsNonAutowireCandidate"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "QualifierAnnotationAutowireCandidateResolver   acr    =    new   QualifierAnnotationAutowireCandidateResolver (  )  ;", "acr . setBeanFactory ( this . beanFactory )  ;", "this . beanFactory . setAutowireCandidateResolver ( acr )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationClassPostProcessorTests . BeanDefinitionRegistryPostProcessorConfig . class )  ;", "assertTrue (  (  ( ctx . getBean (  \" myTestBean \"  )  )    instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanDefinitionRegistryPostProcessorConfig"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationClassPostProcessorTests . BeanLookupConfiguration . class )  ;", "ConfigurationClassPostProcessorTests . BeanLookupConfiguration   bean    =    ctx . getBean ( ConfigurationClassPostProcessorTests . BeanLookupConfiguration . class )  ;", "assertNotNull ( bean . getTestBean (  )  )  ;", "assertSame ( ctx . getBean ( TestBean . class )  ,    bean . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanLookupFromSameConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "beanFactory . registerBeanDefinition (  \" configClass 1  \"  ,    new   RootBeanDefinition (  . A . class )  )  ;", "beanFactory . registerBeanDefinition (  \" configClass 2  \"  ,    new   RootBeanDefinition (  . AStrich . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "try    {", "beanFactory . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" Circular   reference \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCircularDependency"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   AnnotationConfigApplicationContext (  . A . class ,     . AStrich . class )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" Circular   reference \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCircularDependencyWithApplicationContext"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationClassPostProcessorTests . CollectionInjectionConfiguration . class )  ;", "ConfigurationClassPostProcessorTests . CollectionInjectionConfiguration   bean    =    ctx . getBean ( ConfigurationClassPostProcessorTests . CollectionInjectionConfiguration . class )  ;", "assertNotNull ( bean . testBeans )  ;", "assertEquals (  1  ,    bean . testBeans . size (  )  )  ;", "assertSame ( ctx . getBean ( TestBean . class )  ,    bean . testBeans . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionInjectionFromSameConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "beanFactory . addBeanPostProcessor ( new   CommonAnnotationBeanPostProcessor (  )  )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . ConcreteConfigWithDefaultMethods . class )  )  ;", "beanFactory . registerBeanDefinition (  \" serviceBeanProvider \"  ,    new   RootBeanDefinition (  . ServiceBeanProvider . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "beanFactory . getBean (  . ServiceBean . class )  ;", "}", "METHOD_END"], "methodName": ["testConfigWithDefaultMethods"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "beanFactory . addBeanPostProcessor ( new   CommonAnnotationBeanPostProcessor (  )  )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . ConcreteConfigWithDefaultMethods . class . getName (  )  )  )  ;", "beanFactory . registerBeanDefinition (  \" serviceBeanProvider \"  ,    new   RootBeanDefinition (  . ServiceBeanProvider . class . getName (  )  )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "beanFactory . getBean (  . ServiceBean . class )  ;", "}", "METHOD_END"], "methodName": ["testConfigWithDefaultMethodsUsingAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationClassPostProcessorTests . FooBarConfiguration . class )  ;", "assertSame ( ctx . getBean ( ConfigurationClassPostProcessorTests . BarImpl . class )  ,    ctx . getBean ( ConfigurationClassPostProcessorTests . FooImpl . class )  . bar )  ;", "}", "METHOD_END"], "methodName": ["testInjectionPointMatchForNarrowTargetReturnType"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( MyTestBean . class )  ;", "ctx . getBean (  \" myTestBean \"  ,    TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testNameClashBetweenConfigurationClassAndBean"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationClassPostProcessorTests . BeanArgumentConfigWithNull . class )  ;", "ctx . getBean (  \" aFoo \"  )  ;", "}", "METHOD_END"], "methodName": ["testNullArgumentThroughBeanMethodCall"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationClassPostProcessorTests . BeanArgumentConfigWithPrototype . class )  ;", "ctx . getBean ( ConfigurationClassPostProcessorTests . FooFactory . class )  . createFoo ( new   ConfigurationClassPostProcessorTests . BarArgument (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeArgumentThroughBeanMethodCall"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( bpp )  ;", "beanFactory . addBeanPostProcessor ( new   CommonAnnotationBeanPostProcessor (  )  )  ;", "beanFactory . registerBeanDefinition (  \" configClass \"  ,    new   RootBeanDefinition (  . ConcreteConfig . class )  )  ;", "beanFactory . registerBeanDefinition (  \" serviceBeanProvider \"  ,    new   RootBeanDefinition (  . ServiceBeanProvider . class )  )  ;", "new   ConfigurationClassPostProcessor (  )  . postProcessBeanFactory ( beanFactory )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "beanFactory . getBean (  . ServiceBean . class )  ;", "}", "METHOD_END"], "methodName": ["testSelfReferenceExclusionForFactoryMethodOnSameBean"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationClassPostProcessorTests . BeanArgumentConfigWithSingleton . class )  ;", "ctx . getBean ( ConfigurationClassPostProcessorTests . FooFactory . class )  . createFoo ( new   ConfigurationClassPostProcessorTests . BarArgument (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSingletonArgumentThroughBeanMethodCall"], "fileName": "org.springframework.context.annotation.ConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    beanDef . getBeanClassName (  )  ;", "if    (  ( className    =  =    null )     |  |     (  ( beanDef . getFactoryMethodName (  )  )     !  =    null )  )     {", "return   false ;", "}", "AnnotationMetadata   metadata ;", "if    (  ( beanDef   instanceof   AnnotatedBeanDefinition )     &  &     ( className . equals (  (  ( AnnotatedBeanDefinition )     ( beanDef )  )  . getMetadata (  )  . getClassName (  )  )  )  )     {", "metadata    =     (  ( AnnotatedBeanDefinition )     ( beanDef )  )  . getMetadata (  )  ;", "} else", "if    (  ( beanDef   instanceof   AbstractBeanDefinition )     &  &     (  (  ( AbstractBeanDefinition )     ( beanDef )  )  . hasBeanClass (  )  )  )     {", "Class <  ?  >    beanClass    =     (  ( AbstractBeanDefinition )     ( beanDef )  )  . getBeanClass (  )  ;", "metadata    =    new   StandardAnnotationMetadata ( beanClass ,    true )  ;", "} else    {", "try    {", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( className )  ;", "metadata    =    metadataReader . getAnnotationMetadata (  )  ;", "}    catch    ( IOException   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Could   not   find   class   file   for   introspecting   configuration   annotations :     \"     +    className )  ,    ex )  ;", "}", "return   false ;", "}", "}", "if    (  . isFullConfigurationCandidate ( metadata )  )     {", "beanDef . setAttribute (  . CONFIGURATION _ CLASS _ ATTRIBUTE ,     . CONFIGURATION _ CLASS _ FULL )  ;", "} else", "if    (  . isLiteConfigurationCandidate ( metadata )  )     {", "beanDef . setAttribute (  . CONFIGURATION _ CLASS _ ATTRIBUTE ,     . CONFIGURATION _ CLASS _ LITE )  ;", "} else    {", "return   false ;", "}", "Integer   order    =     . getOrder ( metadata )  ;", "if    ( order    !  =    null )     {", "beanDef . setAttribute (  . ORDER _ ATTRIBUTE ,    order )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["checkConfigurationClassCandidate"], "fileName": "org.springframework.context.annotation.ConfigurationClassUtils"}, {"methodBody": ["METHOD_START", "{", "Integer   order    =     (  ( Integer )     ( beanDef . getAttribute ( ConfigurationClassUtils . ORDER _ ATTRIBUTE )  )  )  ;", "return   order    !  =    null    ?    order    :    Ordered . LOWEST _ PRECEDENCE ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.context.annotation.ConfigurationClassUtils"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    orderAttributes    =    metadata . getAnnotationAttributes ( Order . class . getName (  )  )  ;", "return   orderAttributes    !  =    null    ?     (  ( Integer )     ( orderAttributes . get ( VALUE )  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.context.annotation.ConfigurationClassUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( ConfigurationClassUtils . isFullConfigurationCandidate ( metadata )  )     |  |     ( ConfigurationClassUtils . isLiteConfigurationCandidate ( metadata )  )  ;", "}", "METHOD_END"], "methodName": ["isConfigurationCandidate"], "fileName": "org.springframework.context.annotation.ConfigurationClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   metadata . isAnnotated ( Configuration . class . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["isFullConfigurationCandidate"], "fileName": "org.springframework.context.annotation.ConfigurationClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ConfigurationClassUtils . CONFIGURATION _ CLASS _ FULL . equals ( beanDef . getAttribute ( ConfigurationClassUtils . CONFIGURATION _ CLASS _ ATTRIBUTE )  )  ;", "}", "METHOD_END"], "methodName": ["isFullConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( metadata . isInterface (  )  )     {", "return   false ;", "}", "for    ( String   indicator    :     . candidateIndicators )     {", "if    ( metadata . isAnnotated ( indicator )  )     {", "return   true ;", "}", "}", "try    {", "return   metadata . hasAnnotatedMethods ( Bean . class . getName (  )  )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Failed   to   introspect    @ Bean   methods   on   class    [  \"     +     ( metadata . getClassName (  )  )  )     +     \"  ]  :     \"  )     +    ex )  )  ;", "}", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isLiteConfigurationCandidate"], "fileName": "org.springframework.context.annotation.ConfigurationClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ConfigurationClassUtils . CONFIGURATION _ CLASS _ LITE . equals ( beanDef . getAttribute ( ConfigurationClassUtils . CONFIGURATION _ CLASS _ ATTRIBUTE )  )  ;", "}", "METHOD_END"], "methodName": ["isLiteConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ConfigurationClassWithConditionTests . ConfigWithBeanSkipped . class )  ;", "assertEquals (  0  ,    context . getBeansOfType ( ConfigurationClassWithConditionTests . ExampleBean . class )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionOnOverriddenMethodHonored"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . BeanOneConfiguration . class ,     . BeanThreeConfiguration . class )  ;", "ctx . refresh (  )  ;", "assertTrue ( ctx . containsBean (  \" bean 1  \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" bean 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalOnBeanMatch"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . BeanThreeConfiguration . class )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . containsBean (  \" bean 1  \"  )  )  ;", "assertFalse ( ctx . containsBean (  \" bean 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalOnBeanNoMatch"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . BeanOneConfiguration . class ,     . BeanTwoConfiguration . class )  ;", "ctx . refresh (  )  ;", "assertTrue ( ctx . containsBean (  \" bean 1  \"  )  )  ;", "assertFalse ( ctx . containsBean (  \" bean 2  \"  )  )  ;", "assertFalse ( ctx . containsBean (  \" configurationClassWithConditionTests . BeanTwoConfiguration \"  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalOnMissingBeanMatch"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . BeanTwoConfiguration . class )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . containsBean (  \" bean 1  \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" bean 2  \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" configurationClassWithConditionTests . BeanTwoConfiguration \"  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalOnMissingBeanNoMatch"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ConfigurationClassWithConditionTests . ConfigWithAlternativeBeans . class )  ;", "Map < String ,    ConfigurationClassWithConditionTests . ExampleBean >    beans    =    context . getBeansOfType ( ConfigurationClassWithConditionTests . ExampleBean . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "assertEquals (  \" baz \"  ,    beans . keySet (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["configWithAlternativeBeans"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ImportsNotCreated . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["importsNotCreated"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigurationWithMetaCondition . class )  ;", "ctx . refresh (  )  ;", "assertTrue ( ctx . containsBean (  \" bean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["metaConditional"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . ConfigurationWithMetaCondition . class . getName (  )  )  )  ;", "ctx . refresh (  )  ;", "assertTrue ( ctx . containsBean (  \" bean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["metaConditionalWithAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConditionOnMethodConfiguration . class )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . containsBean (  \" bean 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["methodConditional"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . ConditionOnMethodConfiguration . class . getName (  )  )  )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . containsBean (  \" bean 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["methodConditionalWithAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ConfigurationClassWithConditionTests . ConfigWithBeanReactivated . class )  ;", "Map < String ,    ConfigurationClassWithConditionTests . ExampleBean >    beans    =    context . getBeansOfType ( ConfigurationClassWithConditionTests . ExampleBean . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "assertEquals (  \" baz \"  ,    beans . keySet (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["noConditionOnOverriddenMethodHonored"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . NonConfigurationClass . class )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . containsBean (  \" bean 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["nonConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . NonConfigurationClass . class . getName (  )  )  )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . containsBean (  \" bean 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["nonConfigurationClassWithAsm"], "fileName": "org.springframework.context.annotation.ConfigurationClassWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   this . configurationClass ;", "}", "METHOD_END"], "methodName": ["getConfigurationClass"], "fileName": "org.springframework.context.annotation.ConfigurationMethod"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . metadata . getDeclaringClassName (  )  )     +     \"  #  \"  )     +     ( this . metadata . getMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFullyQualifiedMethodName"], "fileName": "org.springframework.context.annotation.ConfigurationMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . metadata ;", "}", "METHOD_END"], "methodName": ["getMetadata"], "fileName": "org.springframework.context.annotation.ConfigurationMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   Location ( this . configurationClass . getResource (  )  ,    this . metadata )  ;", "}", "METHOD_END"], "methodName": ["getResourceLocation"], "fileName": "org.springframework.context.annotation.ConfigurationMethod"}, {"methodBody": ["METHOD_START", "{", "return   fullyQualifiedMethodName . substring (  (  ( fullyQualifiedMethodName . indexOf (  '  #  '  )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getShortMethodName"], "fileName": "org.springframework.context.annotation.ConfigurationMethod"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AppConfig . class )  ;", "ctx . register (  . ConcreteFactoryBeanImplementationConfig . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["withConcreteFactoryBeanImplementationAsReturnType"], "fileName": "org.springframework.context.annotation.ConfigurationWithFactoryBeanAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AppConfig . class )  ;", "ctx . register (  . FactoryBeanCallingConfig . class )  ;", "ctx . refresh (  )  ;", "assertEquals (  \" true \"  ,    ctx . getBean (  \" myString \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withFactoryBeanCallingBean"], "fileName": "org.springframework.context.annotation.ConfigurationWithFactoryBeanAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AppConfig . class )  ;", "ctx . register (  . NonPublicParameterizedFactoryBeanInterfaceConfig . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["withNonPublicParameterizedFactoryBeanInterfaceAsReturnType"], "fileName": "org.springframework.context.annotation.ConfigurationWithFactoryBeanAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AppConfig . class )  ;", "ctx . register (  . ParameterizedFactoryBeanImplementationConfig . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["withParameterizedFactoryBeanImplementationAsReturnType"], "fileName": "org.springframework.context.annotation.ConfigurationWithFactoryBeanAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AppConfig . class )  ;", "ctx . register (  . ParameterizedFactoryBeanInterfaceConfig . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["withParameterizedFactoryBeanInterfaceAsReturnType"], "fileName": "org.springframework.context.annotation.ConfigurationWithFactoryBeanAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AppConfig . class )  ;", "ctx . register (  . RawFactoryBeanInterfaceConfig . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["withRawFactoryBeanInterfaceAsReturnType"], "fileName": "org.springframework.context.annotation.ConfigurationWithFactoryBeanAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AppConfig . class )  ;", "ctx . register (  . WildcardParameterizedFactoryBeanInterfaceConfig . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["withWildcardParameterizedFactoryBeanInterfaceAsReturnType"], "fileName": "org.springframework.context.annotation.ConfigurationWithFactoryBeanAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationWithFactoryBeanAndParametersTests . Config . class ,    ConfigurationWithFactoryBeanAndParametersTests . Bar . class )  ;", "assertNotNull ( ctx . getBean ( ConfigurationWithFactoryBeanAndParametersTests . Bar . class )  . foo )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.context.annotation.ConfigurationWithFactoryBeanAndParametersTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( getBeanFactory (  )  )    instanceof   DefaultListableBeanFactory )  ,     \" BeanFactory   needs   to   be   a   DefaultListableBeanFactory \"  )  ;", "final   DefaultListableBeanFactory   beanFactory    =     (  ( DefaultListableBeanFactory )     ( getBeanFactory (  )  )  )  ;", "TargetSource   ts    =    new   TargetSource (  )     {", "@ Override", "public   Class <  ?  >    getTargetClass (  )     {", "return   descriptor . getDependencyType (  )  ;", "}", "@ Override", "public   boolean   isStatic (  )     {", "return   false ;", "}", "@ Override", "public   Object   getTarget (  )     {", "Object   target    =    beanFactory . doResolveDependency ( descriptor ,    beanName ,    null ,    null )  ;", "if    ( target    =  =    null )     {", "Class <  ?  >    type    =    getTargetClass (  )  ;", "if    (  ( Map . class )     =  =    type )     {", "return   Collections . emptyMap (  )  ;", "} else", "if    (  ( class )     =  =    type )     {", "return   Collections . emptyList (  )  ;", "} else", "if    (  (  ( class )     =  =    type )     |  |     (  ( class )     =  =    type )  )     {", "return   Collections . emptySet (  )  ;", "}", "throw   new   beans . factory . NoSuchBeanDefinitionException ( descriptor . getResolvableType (  )  ,     \" Optional   dependency   not   present   for   lazy   injection   point \"  )  ;", "}", "return   target ;", "}", "@ Override", "public   void   releaseTarget ( Object   target )     {", "}", "}  ;", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTargetSource ( ts )  ;", "Class <  ?  >    dependencyType    =    descriptor . getDependencyType (  )  ;", "if    ( dependencyType . isInterface (  )  )     {", "pf . addInterface ( dependencyType )  ;", "}", "return   pf . getProxy ( beanFactory . getBeanClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildLazyResolutionProxy"], "fileName": "org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( Annotation   ann    :    descriptor . getAnnotations (  )  )     {", "Lazy   lazy    =    AnnotationUtils . getAnnotation ( ann ,    Lazy . class )  ;", "if    (  ( lazy    !  =    null )     &  &     ( lazy . value (  )  )  )     {", "return   true ;", "}", "}", "MethodParameter   methodParam    =    descriptor . getMethodParameter (  )  ;", "if    ( methodParam    !  =    null )     {", "Method   method    =    methodParam . getMethod (  )  ;", "if    (  ( method    =  =    null )     |  |     (  ( void . class )     =  =     ( method . getReturnType (  )  )  )  )     {", "Lazy   lazy    =    AnnotationUtils . getAnnotation ( methodParam . getAnnotatedElement (  )  ,    Lazy . class )  ;", "if    (  ( lazy    !  =    null )     &  &     ( lazy . value (  )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isLazy"], "fileName": "org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getImportGroup"], "fileName": "org.springframework.context.annotation.DeferredImportSelector"}, {"methodBody": ["METHOD_START", "{", "assertNotEquals ( new   DeferredImportSelector . Group . Entry ( mock ( AnnotationMetadata . class )  ,     \" com . example . Test \"  )  ,    new   DeferredImportSelector . Group . Entry ( mock ( AnnotationMetadata . class )  ,     \" com . example . Test \"  )  )  ;", "}", "METHOD_END"], "methodName": ["entryEqualDifferentMetadataAndSameClassName"], "fileName": "org.springframework.context.annotation.DeferredImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    mock ( AnnotationMetadata . class )  ;", "assertNotEquals ( new    . Group . Entry ( metadata ,     \" com . example . Test \"  )  ,    new    . Group . Entry ( metadata ,     \" com . example . AnotherTest \"  )  )  ;", "}", "METHOD_END"], "methodName": ["entryEqualSameMetadataAnDifferentClassName"], "fileName": "org.springframework.context.annotation.DeferredImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    mock ( AnnotationMetadata . class )  ;", ". Group . Entry   entry    =    new    . Group . Entry ( metadata ,     \" com . example . Test \"  )  ;", "assertEquals ( entry ,    entry )  ;", "}", "METHOD_END"], "methodName": ["entryEqualsSameInstance"], "fileName": "org.springframework.context.annotation.DeferredImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    mock ( AnnotationMetadata . class )  ;", "assertEquals ( new    . Group . Entry ( metadata ,     \" com . example . Test \"  )  ,    new    . Group . Entry ( metadata ,     \" com . example . Test \"  )  )  ;", "}", "METHOD_END"], "methodName": ["entryEqualsSameMetadataAndClassName"], "fileName": "org.springframework.context.annotation.DeferredImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( DestroyMethodInferenceTests . Config . class )  ;", "DestroyMethodInferenceTests . WithExplicitDestroyMethod   c 0     =    ctx . getBean ( DestroyMethodInferenceTests . WithExplicitDestroyMethod . class )  ;", "DestroyMethodInferenceTests . WithLocalCloseMethod   c 1     =    ctx . getBean (  \" c 1  \"  ,    DestroyMethodInferenceTests . WithLocalCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithLocalCloseMethod   c 2     =    ctx . getBean (  \" c 2  \"  ,    DestroyMethodInferenceTests . WithLocalCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithInheritedCloseMethod   c 3     =    ctx . getBean (  \" c 3  \"  ,    DestroyMethodInferenceTests . WithInheritedCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithInheritedCloseMethod   c 4     =    ctx . getBean (  \" c 4  \"  ,    DestroyMethodInferenceTests . WithInheritedCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithInheritedCloseMethod   c 5     =    ctx . getBean (  \" c 5  \"  ,    DestroyMethodInferenceTests . WithInheritedCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithNoCloseMethod   c 6     =    ctx . getBean (  \" c 6  \"  ,    DestroyMethodInferenceTests . WithNoCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithLocalShutdownMethod   c 7     =    ctx . getBean (  \" c 7  \"  ,    DestroyMethodInferenceTests . WithLocalShutdownMethod . class )  ;", "DestroyMethodInferenceTests . WithInheritedCloseMethod   c 8     =    ctx . getBean (  \" c 8  \"  ,    DestroyMethodInferenceTests . WithInheritedCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithDisposableBean   c 9     =    ctx . getBean (  \" c 9  \"  ,    DestroyMethodInferenceTests . WithDisposableBean . class )  ;", "assertThat ( c 0  . closed ,    is ( false )  )  ;", "assertThat ( c 1  . closed ,    is ( false )  )  ;", "assertThat ( c 2  . closed ,    is ( false )  )  ;", "assertThat ( c 3  . closed ,    is ( false )  )  ;", "assertThat ( c 4  . closed ,    is ( false )  )  ;", "assertThat ( c 5  . closed ,    is ( false )  )  ;", "assertThat ( c 6  . closed ,    is ( false )  )  ;", "assertThat ( c 7  . closed ,    is ( false )  )  ;", "assertThat ( c 8  . closed ,    is ( false )  )  ;", "assertThat ( c 9  . closed ,    is ( false )  )  ;", "ctx . close (  )  ;", "assertThat (  \" c 0  \"  ,    c 0  . closed ,    is ( true )  )  ;", "assertThat (  \" c 1  \"  ,    c 1  . closed ,    is ( true )  )  ;", "assertThat (  \" c 2  \"  ,    c 2  . closed ,    is ( true )  )  ;", "assertThat (  \" c 3  \"  ,    c 3  . closed ,    is ( true )  )  ;", "assertThat (  \" c 4  \"  ,    c 4  . closed ,    is ( true )  )  ;", "assertThat (  \" c 5  \"  ,    c 5  . closed ,    is ( true )  )  ;", "assertThat (  \" c 6  \"  ,    c 6  . closed ,    is ( false )  )  ;", "assertThat (  \" c 7  \"  ,    c 7  . closed ,    is ( true )  )  ;", "assertThat (  \" c 8  \"  ,    c 8  . closed ,    is ( false )  )  ;", "assertThat (  \" c 9  \"  ,    c 9  . closed ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["beanMethods"], "fileName": "org.springframework.context.annotation.DestroyMethodInferenceTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   GenericXmlApplicationContext ( getClass (  )  ,     \" DestroyMethodInferenceTests - context . xml \"  )  ;", "DestroyMethodInferenceTests . WithLocalCloseMethod   x 1     =    ctx . getBean (  \" x 1  \"  ,    DestroyMethodInferenceTests . WithLocalCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithLocalCloseMethod   x 2     =    ctx . getBean (  \" x 2  \"  ,    DestroyMethodInferenceTests . WithLocalCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithLocalCloseMethod   x 3     =    ctx . getBean (  \" x 3  \"  ,    DestroyMethodInferenceTests . WithLocalCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithNoCloseMethod   x 4     =    ctx . getBean (  \" x 4  \"  ,    DestroyMethodInferenceTests . WithNoCloseMethod . class )  ;", "DestroyMethodInferenceTests . WithInheritedCloseMethod   x 8     =    ctx . getBean (  \" x 8  \"  ,    DestroyMethodInferenceTests . WithInheritedCloseMethod . class )  ;", "assertThat ( x 1  . closed ,    is ( false )  )  ;", "assertThat ( x 2  . closed ,    is ( false )  )  ;", "assertThat ( x 3  . closed ,    is ( false )  )  ;", "assertThat ( x 4  . closed ,    is ( false )  )  ;", "ctx . close (  )  ;", "assertThat ( x 1  . closed ,    is ( false )  )  ;", "assertThat ( x 2  . closed ,    is ( true )  )  ;", "assertThat ( x 3  . closed ,    is ( true )  )  ;", "assertThat ( x 4  . closed ,    is ( false )  )  ;", "assertThat ( x 8  . closed ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["xml"], "fileName": "org.springframework.context.annotation.DestroyMethodInferenceTests"}, {"methodBody": ["METHOD_START", "{", "FooService   fooService    =    ctx . getBean ( FooService . class )  ;", "ServiceInvocCounter   counter    =    ctx . getBean ( ServiceInvocCounter . class )  ;", "assertEquals (  0  ,    counter . getCount (  )  )  ;", "assertTrue ( fooService . isInitCalled (  )  )  ;", "assertEquals (  1  ,    counter . getCount (  )  )  ;", "String   value    =    fooService . foo (  1  )  ;", "assertEquals (  \" bar \"  ,    value )  ;", "assertEquals (  2  ,    counter . getCount (  )  )  ;", "fooService . foo (  1  )  ;", "assertEquals (  3  ,    counter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["aspectIsApplied"], "fileName": "org.springframework.context.annotation.EnableAspectJAutoProxyTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableAspectJAutoProxyTests . ConfigWithCglibProxy . class ,    EnableAspectJAutoProxyTests . SampleService . class ,    EnableAspectJAutoProxyTests . LoggingAspect . class )  ;", "EnableAspectJAutoProxyTests . SampleService   sampleService    =    ctx . getBean ( EnableAspectJAutoProxyTests . SampleService . class )  ;", "sampleService . execute ( new   EnableAspectJAutoProxyTests . SampleDto (  )  )  ;", "sampleService . execute ( new   EnableAspectJAutoProxyTests . SampleInputBean (  )  )  ;", "sampleService . execute (  (  ( EnableAspectJAutoProxyTests . SampleDto )     ( null )  )  )  ;", "sampleService . execute (  (  ( EnableAspectJAutoProxyTests . SampleInputBean )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["withAnnotationOnArgumentAndCglibProxy"], "fileName": "org.springframework.context.annotation.EnableAspectJAutoProxyTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableAspectJAutoProxyTests . ConfigWithJdkProxy . class ,    EnableAspectJAutoProxyTests . SampleService . class ,    EnableAspectJAutoProxyTests . LoggingAspect . class )  ;", "EnableAspectJAutoProxyTests . SampleService   sampleService    =    ctx . getBean ( EnableAspectJAutoProxyTests . SampleService . class )  ;", "sampleService . execute ( new   EnableAspectJAutoProxyTests . SampleDto (  )  )  ;", "sampleService . execute ( new   EnableAspectJAutoProxyTests . SampleInputBean (  )  )  ;", "sampleService . execute (  (  ( EnableAspectJAutoProxyTests . SampleDto )     ( null )  )  )  ;", "sampleService . execute (  (  ( EnableAspectJAutoProxyTests . SampleInputBean )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["withAnnotationOnArgumentAndJdkProxy"], "fileName": "org.springframework.context.annotation.EnableAspectJAutoProxyTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableAspectJAutoProxyTests . ConfigWithCglibProxy . class )  ;", "aspectIsApplied ( ctx )  ;", "assertThat ( AopUtils . isCglibProxy ( ctx . getBean ( FooService . class )  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withCglibProxy"], "fileName": "org.springframework.context.annotation.EnableAspectJAutoProxyTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableAspectJAutoProxyTests . ConfigWithExposedProxy . class )  ;", "aspectIsApplied ( ctx )  ;", "assertThat ( AopUtils . isJdkDynamicProxy ( ctx . getBean ( FooService . class )  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withExposedProxy"], "fileName": "org.springframework.context.annotation.EnableAspectJAutoProxyTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableAspectJAutoProxyTests . ConfigWithJdkProxy . class )  ;", "aspectIsApplied ( ctx )  ;", "assertThat ( AopUtils . isJdkDynamicProxy ( ctx . getBean ( FooService . class )  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withJdkProxy"], "fileName": "org.springframework.context.annotation.EnableAspectJAutoProxyTests"}, {"methodBody": ["METHOD_START", "{", "GenericXmlApplicationContext   ctx    =    new   GenericXmlApplicationContext ( getClass (  )  ,     \" EnableLoadTimeWeavingTests - context . xml \"  )  ;", "ctx . getBean (  \" loadTimeWeaver \"  ,    LoadTimeWeaver . class )  ;", "}", "METHOD_END"], "methodName": ["control"], "fileName": "org.springframework.context.annotation.EnableLoadTimeWeavingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . EnableLTWConfig _ withAjWeavingAutodetect . class )  ;", "ctx . refresh (  )  ;", "LoadTimeWeaver   loadTimeWeaver    =    ctx . getBean (  \" loadTimeWeaver \"  ,    LoadTimeWeaver . class )  ;", "verifyZeroInteractions ( loadTimeWeaver )  ;", "}", "METHOD_END"], "methodName": ["enableLTW_withAjWeavingAutodetect"], "fileName": "org.springframework.context.annotation.EnableLoadTimeWeavingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . EnableLTWConfig _ withAjWeavingDisabled . class )  ;", "ctx . refresh (  )  ;", "LoadTimeWeaver   loadTimeWeaver    =    ctx . getBean (  \" loadTimeWeaver \"  ,    LoadTimeWeaver . class )  ;", "verifyZeroInteractions ( loadTimeWeaver )  ;", "}", "METHOD_END"], "methodName": ["enableLTW_withAjWeavingDisabled"], "fileName": "org.springframework.context.annotation.EnableLoadTimeWeavingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . EnableLTWConfig _ withAjWeavingEnabled . class )  ;", "ctx . refresh (  )  ;", "LoadTimeWeaver   loadTimeWeaver    =    ctx . getBean (  \" loadTimeWeaver \"  ,    LoadTimeWeaver . class )  ;", "verify ( loadTimeWeaver )  . addTransformer ( isA ( ClassFileTransformer . class )  )  ;", "}", "METHOD_END"], "methodName": ["enableLTW_withAjWeavingEnabled"], "fileName": "org.springframework.context.annotation.EnableLoadTimeWeavingTests"}, {"methodBody": ["METHOD_START", "{", "this . fooService    =    fooService ;", "}", "METHOD_END"], "methodName": ["setFooService"], "fileName": "org.springframework.context.annotation.FooServiceDependentConverter"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ImportingConfig . class )  ;", "ctx . refresh (  )  ;", "assertNotNull ( ctx . getBean (  \" importedConfigBean \"  )  )  ;", ". ImportedConfig   importAwareConfig    =    ctx . getBean (  . ImportedConfig . class )  ;", "AnnotationMetadata   importMetadata    =    importAwareConfig . importMetadata ;", "assertThat (  \" import   metadata   was   not   injected \"  ,    importMetadata ,    notNullValue (  )  )  ;", "assertThat ( importMetadata . getClassName (  )  ,    is (  . ImportingConfig . class . getName (  )  )  )  ;", "AnnotationAttributes   importAttribs    =    AnnotationConfigUtils . attributesFor ( importMetadata ,    Import . class )  ;", "Class <  ?  >  [  ]    importedClasses    =    importAttribs . getClassArray (  \" value \"  )  ;", "assertThat ( importedClasses [  0  ]  . getName (  )  ,    is (  . ImportedConfig . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["directlyAnnotatedWithImport"], "fileName": "org.springframework.context.annotation.ImportAwareTests"}, {"methodBody": ["METHOD_START", "{", "ImportAwareTests . ImportedRegistrar . called    =    false ;", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( ImportAwareTests . ImportingRegistrarConfig . class )  ;", "ctx . refresh (  )  ;", "assertNotNull ( ctx . getBean (  \" registrarImportedBean \"  )  )  ;", "assertNotNull ( ctx . getBean (  \" otherImportedConfigBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["importRegistrar"], "fileName": "org.springframework.context.annotation.ImportAwareTests"}, {"methodBody": ["METHOD_START", "{", "ImportAwareTests . ImportedRegistrar . called    =    false ;", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( ImportAwareTests . ImportingRegistrarConfigWithImport . class )  ;", "ctx . refresh (  )  ;", "assertNotNull ( ctx . getBean (  \" registrarImportedBean \"  )  )  ;", "assertNotNull ( ctx . getBean (  \" otherImportedConfigBean \"  )  )  ;", "assertNotNull ( ctx . getBean (  \" importedConfigBean \"  )  )  ;", "assertNotNull ( ctx . getBean ( ImportAwareTests . ImportedConfig . class )  )  ;", "}", "METHOD_END"], "methodName": ["importRegistrarWithImport"], "fileName": "org.springframework.context.annotation.ImportAwareTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . IndirectlyImportingConfig . class )  ;", "ctx . refresh (  )  ;", "assertNotNull ( ctx . getBean (  \" importedConfigBean \"  )  )  ;", ". ImportedConfig   importAwareConfig    =    ctx . getBean (  . ImportedConfig . class )  ;", "AnnotationMetadata   importMetadata    =    importAwareConfig . importMetadata ;", "assertThat (  \" import   metadata   was   not   injected \"  ,    importMetadata ,    notNullValue (  )  )  ;", "assertThat ( importMetadata . getClassName (  )  ,    is (  . IndirectlyImportingConfig . class . getName (  )  )  )  ;", "AnnotationAttributes   enableAttribs    =    AnnotationConfigUtils . attributesFor ( importMetadata ,     . EnableImportedConfig . class )  ;", "String   foo    =    enableAttribs . getString (  \" foo \"  )  ;", "assertThat ( foo ,    is (  \" xyz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["indirectlyAnnotatedWithImport"], "fileName": "org.springframework.context.annotation.ImportAwareTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   importMetadata    =    new   AnnotationConfigApplicationContext ( ImportAwareTests . ConfigurationOne . class ,    ImportAwareTests . ConfigurationTwo . class )  . getBean ( ImportAwareTests . MetadataHolder . class )  . importMetadata ;", "assertEquals ( ImportAwareTests . ConfigurationOne . class ,     (  ( StandardAnnotationMetadata )     ( importMetadata )  )  . getIntrospectedClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["metadataFromImportsOneThenTwo"], "fileName": "org.springframework.context.annotation.ImportAwareTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   importMetadata    =    new   AnnotationConfigApplicationContext ( ImportAwareTests . ConfigurationTwo . class ,    ImportAwareTests . ConfigurationOne . class )  . getBean ( ImportAwareTests . MetadataHolder . class )  . importMetadata ;", "assertEquals ( ImportAwareTests . ConfigurationOne . class ,     (  ( StandardAnnotationMetadata )     ( importMetadata )  )  . getIntrospectedClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["metadataFromImportsTwoThenOne"], "fileName": "org.springframework.context.annotation.ImportAwareTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ImportBeanDefinitionRegistrarTests . Config . class )  ;", "context . getBean ( MessageSource . class )  ;", "assertThat ( ImportBeanDefinitionRegistrarTests . SampleRegistrar . beanFactory ,    is ( context . getBeanFactory (  )  )  )  ;", "assertThat ( ImportBeanDefinitionRegistrarTests . SampleRegistrar . classLoader ,    is ( context . getBeanFactory (  )  . getBeanClassLoader (  )  )  )  ;", "assertThat ( ImportBeanDefinitionRegistrarTests . SampleRegistrar . resourceLoader ,    is ( notNullValue (  )  )  )  ;", "assertThat ( ImportBeanDefinitionRegistrarTests . SampleRegistrar . environment ,    is ( context . getEnvironment (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldInvokeAwareMethodsInImportBeanDefinitionRegistrar"], "fileName": "org.springframework.context.annotation.ImportBeanDefinitionRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "ImportSelectorTests . importFrom . clear (  )  ;", "ImportSelectorTests . SampleImportSelector . cleanup (  )  ;", "ImportSelectorTests . TestImportGroup . cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.springframework.context.annotation.ImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "new   AnnotationConfigApplicationContext ( ImportSelectorTests . IndirectConfig . class )  ;", "Matcher < String >    isFromIndirect    =    equalTo ( ImportSelectorTests . IndirectImport . class . getName (  )  )  ;", "assertThat ( ImportSelectorTests . importFrom . get ( ImportSelectorTests . ImportSelector 1  . class )  ,    isFromIndirect )  ;", "assertThat ( ImportSelectorTests . importFrom . get ( ImportSelectorTests . ImportSelector 2  . class )  ,    isFromIndirect )  ;", "assertThat ( ImportSelectorTests . importFrom . get ( ImportSelectorTests . DeferredImportSelector 1  . class )  ,    isFromIndirect )  ;", "assertThat ( ImportSelectorTests . importFrom . get ( ImportSelectorTests . DeferredImportSelector 2  . class )  ,    isFromIndirect )  ;", "}", "METHOD_END"], "methodName": ["correctMetaDataOnIndirectImports"], "fileName": "org.springframework.context.annotation.ImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    spy ( new   DefaultListableBeanFactory (  )  )  ;", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( beanFactory )  ;", "context . register (  . Config . class )  ;", "context . refresh (  )  ;", "context . getBean (  . Config . class )  ;", "InOrder   ordered    =    inOrder ( beanFactory )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" a \"  )  ,    any (  )  )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" b \"  )  ,    any (  )  )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" d \"  )  ,    any (  )  )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" c \"  )  ,    any (  )  )  ;", "}", "METHOD_END"], "methodName": ["importSelectors"], "fileName": "org.springframework.context.annotation.ImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    spy ( new   DefaultListableBeanFactory (  )  )  ;", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( beanFactory )  ;", "context . register (  . GroupedConfig 1  . class )  ;", "context . register (  . GroupedConfig 2  . class )  ;", "context . refresh (  )  ;", "InOrder   ordered    =    inOrder ( beanFactory )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" c \"  )  ,    any (  )  )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" d \"  )  ,    any (  )  )  ;", "assertThat (  . TestImportGroup . instancesCount . get (  )  ,    equalTo (  1  )  )  ;", "assertThat (  . TestImportGroup . imports . size (  )  ,    equalTo (  2  )  )  ;", "Iterator < AnnotationMetadata >    iterator    =     . TestImportGroup . imports . keySet (  )  . iterator (  )  ;", "assertThat ( iterator . next (  )  . getClassName (  )  ,    equalTo (  . GroupedConfig 2  . class . getName (  )  )  )  ;", "assertThat ( iterator . next (  )  . getClassName (  )  ,    equalTo (  . GroupedConfig 1  . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["importSelectorsSeparateWithGroup"], "fileName": "org.springframework.context.annotation.ImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    spy ( new   DefaultListableBeanFactory (  )  )  ;", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( beanFactory )  ;", "context . register (  . GroupedConfig . class )  ;", "context . refresh (  )  ;", "InOrder   ordered    =    inOrder ( beanFactory )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" a \"  )  ,    any (  )  )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" b \"  )  ,    any (  )  )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" c \"  )  ,    any (  )  )  ;", "ordered . verify ( beanFactory )  . registerBeanDefinition ( eq (  \" d \"  )  ,    any (  )  )  ;", "assertThat (  . TestImportGroup . instancesCount . get (  )  ,    equalTo (  1  )  )  ;", "assertThat (  . TestImportGroup . imports . size (  )  ,    equalTo (  1  )  )  ;", "assertThat (  . TestImportGroup . imports . values (  )  . iterator (  )  . next (  )  . size (  )  ,    equalTo (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["importSelectorsWithGroup"], "fileName": "org.springframework.context.annotation.ImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ImportSelectorTests . GroupedConfig 1  . class )  ;", "assertThat ( ImportSelectorTests . TestImportGroup . beanFactory ,    is ( context . getBeanFactory (  )  )  )  ;", "assertThat ( ImportSelectorTests . TestImportGroup . classLoader ,    is ( context . getBeanFactory (  )  . getBeanClassLoader (  )  )  )  ;", "assertThat ( ImportSelectorTests . TestImportGroup . resourceLoader ,    is ( notNullValue (  )  )  )  ;", "assertThat ( ImportSelectorTests . TestImportGroup . environment ,    is ( context . getEnvironment (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAwareMethodsInImportGroup"], "fileName": "org.springframework.context.annotation.ImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ImportSelectorTests . AwareConfig . class )  ;", "assertThat ( ImportSelectorTests . SampleImportSelector . beanFactory ,    is ( context . getBeanFactory (  )  )  )  ;", "assertThat ( ImportSelectorTests . SampleImportSelector . classLoader ,    is ( context . getBeanFactory (  )  . getBeanClassLoader (  )  )  )  ;", "assertThat ( ImportSelectorTests . SampleImportSelector . resourceLoader ,    is ( notNullValue (  )  )  )  ;", "assertThat ( ImportSelectorTests . SampleImportSelector . environment ,    is ( context . getEnvironment (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAwareMethodsInImportSelector"], "fileName": "org.springframework.context.annotation.ImportSelectorTests"}, {"methodBody": ["METHOD_START", "{", "@ Configuration", "final   class   Config    {  }", "BeanDefinition   configBeanDef    =    rootBeanDefinition ( Config . class )  . getBeanDefinition (  )  ;", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "beanFactory . registerBeanDefinition (  \" config \"  ,    configBeanDef )  ;", "try    {", "PostProcessor   pp    =    new   PostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( BeanDefinitionParsingException   ex )     {", "assertTrue ( ex . getMessage (  )  ,    ex . getMessage (  )  . contains (  \" Remove   the   final   modifier \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configurationClassesMayNotBeFinal"], "fileName": "org.springframework.context.annotation.InvalidConfigurationClassDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "this . scopeMap . put ( annotationType . getName (  )  ,    scopeName )  ;", "}", "METHOD_END"], "methodName": ["registerScope"], "fileName": "org.springframework.context.annotation.Jsr330ScopeMetadataResolver"}, {"methodBody": ["METHOD_START", "{", "this . scopeMap . put ( annotationType ,    scopeName )  ;", "}", "METHOD_END"], "methodName": ["registerScope"], "fileName": "org.springframework.context.annotation.Jsr330ScopeMetadataResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . scopeMap . get ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["resolveScopeName"], "fileName": "org.springframework.context.annotation.Jsr330ScopeMetadataResolver"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ac    =    new   AnnotationConfigApplicationContext (  )  ;", "RootBeanDefinition   abd    =    new   RootBeanDefinition ( annotatedBeanClass )  ;", "abd . setScope ( SCOPE _ PROTOTYPE )  ;", "ac . registerBeanDefinition (  \" annotatedBean \"  ,    abd )  ;", "RootBeanDefinition   tbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "tbd . setLazyInit ( true )  ;", "ac . registerBeanDefinition (  \" testBean \"  ,    tbd )  ;", "ac . refresh (  )  ;", ". TestBeanHolder   bean    =    ac . getBean (  \" annotatedBean \"  ,     . TestBeanHolder . class )  ;", "assertFalse ( ac . getBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "assertNotNull ( bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean (  )  . getName (  )  )  ;", "assertTrue ( ac . getBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( ac . getBean (  \" testBean \"  )  )  )  ;", "tb . setName (  \" tb \"  )  ;", "assertSame (  \" tb \"  ,    bean . getTestBean (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestLazyResourceInjection"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   ContextAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . OptionalFieldResourceInjectionBean . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". OptionalFieldResourceInjectionBean   bean    =     (  (  . OptionalFieldResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNotNull ( bean . getTestBean (  )  )  ;", "assertNotNull ( bean . getTestBeans (  )  )  ;", "assertTrue ( bean . getTestBeans (  )  . isEmpty (  )  )  ;", "try    {", "bean . getTestBean (  )  . getName (  )  ;", "fail (  \" Should   have   thrown   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLazyOptionalResourceInjectionWithNonExistingTarget"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "doTestLazyResourceInjection ( LazyAutowiredAnnotationBeanPostProcessorTests . ConstructorResourceInjectionBean . class )  ;", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithConstructor"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "doTestLazyResourceInjection ( LazyAutowiredAnnotationBeanPostProcessorTests . ConstructorResourceInjectionBeanWithCompositeAnnotation . class )  ;", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithConstructorAndCustomAnnotation"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "doTestLazyResourceInjection ( LazyAutowiredAnnotationBeanPostProcessorTests . ConstructorResourceInjectionBeanWithConstructorLevelLazy . class )  ;", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithConstructorLevelLazy"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "doTestLazyResourceInjection ( LazyAutowiredAnnotationBeanPostProcessorTests . FieldResourceInjectionBean . class )  ;", "AnnotationConfigApplicationContext   ac    =    new   AnnotationConfigApplicationContext (  )  ;", "RootBeanDefinition   abd    =    new   RootBeanDefinition ( LazyAutowiredAnnotationBeanPostProcessorTests . FieldResourceInjectionBean . class )  ;", "abd . setScope ( SCOPE _ PROTOTYPE )  ;", "ac . registerBeanDefinition (  \" annotatedBean \"  ,    abd )  ;", "RootBeanDefinition   tbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "tbd . setLazyInit ( true )  ;", "ac . registerBeanDefinition (  \" testBean \"  ,    tbd )  ;", "ac . refresh (  )  ;", "LazyAutowiredAnnotationBeanPostProcessorTests . FieldResourceInjectionBean   bean    =    ac . getBean (  \" annotatedBean \"  ,    LazyAutowiredAnnotationBeanPostProcessorTests . FieldResourceInjectionBean . class )  ;", "assertFalse ( ac . getBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "assertFalse ( bean . getTestBeans (  )  . isEmpty (  )  )  ;", "assertNull ( bean . getTestBeans (  )  . get (  0  )  . getName (  )  )  ;", "assertTrue ( ac . getBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( ac . getBean (  \" testBean \"  )  )  )  ;", "tb . setName (  \" tb \"  )  ;", "assertSame (  \" tb \"  ,    bean . getTestBean (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithField"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "doTestLazyResourceInjection ( LazyAutowiredAnnotationBeanPostProcessorTests . FieldResourceInjectionBeanWithCompositeAnnotation . class )  ;", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithFieldAndCustomAnnotation"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "doTestLazyResourceInjection ( LazyAutowiredAnnotationBeanPostProcessorTests . MethodResourceInjectionBean . class )  ;", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithMethod"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "doTestLazyResourceInjection ( LazyAutowiredAnnotationBeanPostProcessorTests . MethodResourceInjectionBeanWithCompositeAnnotation . class )  ;", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithMethodAndCustomAnnotation"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "doTestLazyResourceInjection ( LazyAutowiredAnnotationBeanPostProcessorTests . MethodResourceInjectionBeanWithMethodLevelLazy . class )  ;", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithMethodLevelLazy"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   ContextAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . FieldResourceInjectionBean . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". FieldResourceInjectionBean   bean    =     (  (  . FieldResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNotNull ( bean . getTestBean (  )  )  ;", "try    {", "bean . getTestBean (  )  . getName (  )  ;", "fail (  \" Should   have   thrown   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLazyResourceInjectionWithNonExistingTarget"], "fileName": "org.springframework.context.annotation.LazyAutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . beanClassLoader )     !  =    null )  ,     \" No   ClassLoader   set \"  )  ;", "LoadTimeWeaver   loadTimeWeaver    =    null ;", "if    (  ( this . ltwConfigurer )     !  =    null )     {", "loadTimeWeaver    =    this . ltwConfigurer . getLoadTimeWeaver (  )  ;", "}", "if    ( loadTimeWeaver    =  =    null )     {", "loadTimeWeaver    =    new   DefaultContextLoadTimeWeaver ( this . beanClassLoader )  ;", "}", "if    (  ( this . enableLTW )     !  =    null )     {", "Enable . AspectJWeaving   aspectJWeaving    =    this . enableLTW . getEnum (  \" aspectjWeaving \"  )  ;", "switch    ( aspectJWeaving )     {", "case   DISABLED    :", "break ;", "case   AUTODETECT    :", "if    (  ( this . beanClassLoader . getResource ( AspectJWeavingEnabler . ASPECTJ _ AOP _ XML _ RESOURCE )  )     =  =    null )     {", "break ;", "}", "AspectJWeavingEnabler . enableAspectJWeaving ( loadTimeWeaver ,    this . beanClassLoader )  ;", "break ;", "case   ENABLED    :", "AspectJWeavingEnabler . enableAspectJWeaving ( loadTimeWeaver ,    this . beanClassLoader )  ;", "break ;", "}", "}", "return   loadTimeWeaver ;", "}", "METHOD_END"], "methodName": ["loadTimeWeaver"], "fileName": "org.springframework.context.annotation.LoadTimeWeavingConfiguration"}, {"methodBody": ["METHOD_START", "{", "this . ltwConfigurer    =    ltwConfigurer ;", "}", "METHOD_END"], "methodName": ["setLoadTimeWeavingConfigurer"], "fileName": "org.springframework.context.annotation.LoadTimeWeavingConfiguration"}, {"methodBody": ["METHOD_START", "{", "AnnotationMBeanExporter   exporter    =    new   AnnotationMBeanExporter (  )  ;", "Assert . state (  (  ( this . enableMBeanExport )     !  =    null )  ,     \" No   EnableMBeanExport   annotation   found \"  )  ;", "setupDomain ( exporter ,    this . enableMBeanExport )  ;", "setupServer ( exporter ,    this . enableMBeanExport )  ;", "setupRegistrationPolicy ( exporter ,    this . enableMBeanExport )  ;", "return   exporter ;", "}", "METHOD_END"], "methodName": ["mbeanExporter"], "fileName": "org.springframework.context.annotation.MBeanExportConfiguration"}, {"methodBody": ["METHOD_START", "{", "String   defaultDomain    =    enableMBeanExport . getString (  \" defaultDomain \"  )  ;", "if    (  ( StringUtils . hasLength ( defaultDomain )  )     &  &     (  ( this . environment )     !  =    null )  )     {", "defaultDomain    =    this . environment . resolvePlaceholders ( defaultDomain )  ;", "}", "if    ( StringUtils . hasText ( defaultDomain )  )     {", "exporter . setDefaultDomain ( defaultDomain )  ;", "}", "}", "METHOD_END"], "methodName": ["setupDomain"], "fileName": "org.springframework.context.annotation.MBeanExportConfiguration"}, {"methodBody": ["METHOD_START", "{", "RegistrationPolicy   registrationPolicy    =    enableMBeanExport . getEnum (  \" registration \"  )  ;", "exporter . setRegistrationPolicy ( registrationPolicy )  ;", "}", "METHOD_END"], "methodName": ["setupRegistrationPolicy"], "fileName": "org.springframework.context.annotation.MBeanExportConfiguration"}, {"methodBody": ["METHOD_START", "{", "String   server    =    enableMBeanExport . getString (  \" server \"  )  ;", "if    (  ( StringUtils . hasLength ( server )  )     &  &     (  ( this . environment )     !  =    null )  )     {", "server    =    this . environment . resolvePlaceholders ( server )  ;", "}", "if    ( StringUtils . hasText ( server )  )     {", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" No   BeanFactory   set \"  )  ;", "exporter . setServer ( this . beanFactory . getBean ( server ,    MBeanServer . class )  )  ;", "} else    {", ". SpecificPlatform   specificPlatform    =     . SpecificPlatform . get (  )  ;", "if    ( specificPlatform    !  =    null )     {", "MBeanServer   mbeanServer    =    specificPlatform . getMBeanServer (  )  ;", "if    ( mbeanServer    !  =    null )     {", "exporter . setServer ( mbeanServer )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setupServer"], "fileName": "org.springframework.context.annotation.MBeanExportConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  )  ;", "}", "METHOD_END"], "methodName": ["myTestBean"], "fileName": "org.springframework.context.annotation.MyTestBean"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . L 0 Config . L 1 Config . class )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . containsBean (  \" l 0 Bean \"  )  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . class )  ;", "ctx . getBean (  \" l 1 Bean \"  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . L 2 Config . class )  ;", "ctx . getBean (  \" l 2 Bean \"  )  ;", "assertThat ( ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  . getName (  )  ,    is (  \" override - l 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["oneLevelDeep"], "fileName": "org.springframework.context.annotation.NestedConfigurationClassTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . L 0 Config . class )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" nestedConfigurationClassTests . L 0 Config \"  )  )  ;", "ctx . getBean (  . L 0 Config . class )  ;", "ctx . getBean (  \" l 0 Bean \"  )  ;", "assertTrue ( ctx . getBeanFactory (  )  . containsSingleton (  . L 0 Config . L 1 Config . class . getName (  )  )  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . class )  ;", "ctx . getBean (  \" l 1 Bean \"  )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  . L 0 Config . L 1 Config . L 2 Config . class . getName (  )  )  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . L 2 Config . class )  ;", "ctx . getBean (  \" l 2 Bean \"  )  ;", "assertThat ( ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  . getName (  )  ,    is (  \" override - l 0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["twoLevelsDeep"], "fileName": "org.springframework.context.annotation.NestedConfigurationClassTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . S 1 Config . class )  ;", "ctx . refresh (  )  ;", ". S 1 Config   config    =    ctx . getBean (  . S 1 Config . class )  ;", "assertTrue (  ( config    !  =     ( ctx . getBean (  . S 1 Config . class )  )  )  )  ;", "TestBean   tb    =    ctx . getBean (  \" l 0 Bean \"  ,    TestBean . class )  ;", "assertTrue (  ( tb    =  =     ( ctx . getBean (  \" l 0 Bean \"  ,    TestBean . class )  )  )  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . class )  ;", "ctx . getBean (  \" l 1 Bean \"  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . L 2 Config . class )  ;", "ctx . getBean (  \" l 2 Bean \"  )  ;", "TestBean   ob    =    ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  ;", "assertThat ( ob . getName (  )  ,    is (  \" override - s 1  \"  )  )  ;", "assertTrue (  ( ob    =  =     ( ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  )  )  )  ;", "TestBean   pb 1     =    ctx . getBean (  \" prototypeBean \"  ,    TestBean . class )  ;", "TestBean   pb 2     =    ctx . getBean (  \" prototypeBean \"  ,    TestBean . class )  ;", "assertTrue (  ( pb 1     !  =    pb 2  )  )  ;", "assertTrue (  (  ( pb 1  . getFriends (  )  . iterator (  )  . next (  )  )     !  =     ( pb 2  . getFriends (  )  . iterator (  )  . next (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["twoLevelsDeepWithInheritance"], "fileName": "org.springframework.context.annotation.NestedConfigurationClassTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . S 1 ImporterWithProxy . class )  ;", "ctx . refresh (  )  ;", ". S 1 ConfigWithProxy   config    =    ctx . getBean (  . S 1 ConfigWithProxy . class )  ;", "assertTrue (  ( config    =  =     ( ctx . getBean (  . S 1 ConfigWithProxy . class )  )  )  )  ;", "TestBean   tb    =    ctx . getBean (  \" l 0 Bean \"  ,    TestBean . class )  ;", "assertTrue (  ( tb    =  =     ( ctx . getBean (  \" l 0 Bean \"  ,    TestBean . class )  )  )  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . class )  ;", "ctx . getBean (  \" l 1 Bean \"  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . L 2 Config . class )  ;", "ctx . getBean (  \" l 2 Bean \"  )  ;", "TestBean   ob    =    ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  ;", "assertThat ( ob . getName (  )  ,    is (  \" override - s 1  \"  )  )  ;", "assertTrue (  ( ob    =  =     ( ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  )  )  )  ;", "TestBean   pb 1     =    ctx . getBean (  \" prototypeBean \"  ,    TestBean . class )  ;", "TestBean   pb 2     =    ctx . getBean (  \" prototypeBean \"  ,    TestBean . class )  ;", "assertTrue (  ( pb 1     !  =    pb 2  )  )  ;", "assertTrue (  (  ( pb 1  . getFriends (  )  . iterator (  )  . next (  )  )     !  =     ( pb 2  . getFriends (  )  . iterator (  )  . next (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["twoLevelsDeepWithInheritanceAndScopedProxy"], "fileName": "org.springframework.context.annotation.NestedConfigurationClassTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . S 1 Importer . class )  ;", "ctx . refresh (  )  ;", ". S 1 Config   config    =    ctx . getBean (  . S 1 Config . class )  ;", "assertTrue (  ( config    !  =     ( ctx . getBean (  . S 1 Config . class )  )  )  )  ;", "TestBean   tb    =    ctx . getBean (  \" l 0 Bean \"  ,    TestBean . class )  ;", "assertTrue (  ( tb    =  =     ( ctx . getBean (  \" l 0 Bean \"  ,    TestBean . class )  )  )  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . class )  ;", "ctx . getBean (  \" l 1 Bean \"  )  ;", "ctx . getBean (  . L 0 Config . L 1 Config . L 2 Config . class )  ;", "ctx . getBean (  \" l 2 Bean \"  )  ;", "TestBean   ob    =    ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  ;", "assertThat ( ob . getName (  )  ,    is (  \" override - s 1  \"  )  )  ;", "assertTrue (  ( ob    =  =     ( ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  )  )  )  ;", "TestBean   pb 1     =    ctx . getBean (  \" prototypeBean \"  ,    TestBean . class )  ;", "TestBean   pb 2     =    ctx . getBean (  \" prototypeBean \"  ,    TestBean . class )  ;", "assertTrue (  ( pb 1     !  =    pb 2  )  )  ;", "assertTrue (  (  ( pb 1  . getFriends (  )  . iterator (  )  . next (  )  )     !  =     ( pb 2  . getFriends (  )  . iterator (  )  . next (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["twoLevelsDeepWithInheritanceThroughImport"], "fileName": "org.springframework.context.annotation.NestedConfigurationClassTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . L 0 ConfigLight . class )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" nestedConfigurationClassTests . L 0 ConfigLight \"  )  )  ;", "ctx . getBean (  . L 0 ConfigLight . class )  ;", "ctx . getBean (  \" l 0 Bean \"  )  ;", "assertTrue ( ctx . getBeanFactory (  )  . containsSingleton (  . L 0 ConfigLight . L 1 ConfigLight . class . getName (  )  )  )  ;", "ctx . getBean (  . L 0 ConfigLight . L 1 ConfigLight . class )  ;", "ctx . getBean (  \" l 1 Bean \"  )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  . L 0 ConfigLight . L 1 ConfigLight . L 2 ConfigLight . class . getName (  )  )  )  ;", "ctx . getBean (  . L 0 ConfigLight . L 1 ConfigLight . L 2 ConfigLight . class )  ;", "ctx . getBean (  \" l 2 Bean \"  )  ;", "assertThat ( ctx . getBean (  \" overrideBean \"  ,    TestBean . class )  . getName (  )  ,    is (  \" override - l 0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["twoLevelsInLiteMode"], "fileName": "org.springframework.context.annotation.NestedConfigurationClassTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . L 0 ConfigEmpty . class )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" l 0 ConfigEmpty \"  )  )  ;", "Object   l 0 i 1     =    ctx . getBean (  . L 0 ConfigEmpty . class )  ;", "Object   l 0 i 2     =    ctx . getBean (  . L 0 ConfigEmpty . class )  ;", "assertTrue (  ( l 0 i 1     =  =    l 0 i 2  )  )  ;", "Object   l 1 i 1     =    ctx . getBean (  . L 0 ConfigEmpty . L 1 ConfigEmpty . class )  ;", "Object   l 1 i 2     =    ctx . getBean (  . L 0 ConfigEmpty . L 1 ConfigEmpty . class )  ;", "assertTrue (  ( l 1 i 1     !  =    l 1 i 2  )  )  ;", "Object   l 2 i 1     =    ctx . getBean (  . L 0 ConfigEmpty . L 1 ConfigEmpty . L 2 ConfigEmpty . class )  ;", "Object   l 2 i 2     =    ctx . getBean (  . L 0 ConfigEmpty . L 1 ConfigEmpty . L 2 ConfigEmpty . class )  ;", "assertTrue (  ( l 2 i 1     =  =    l 2 i 2  )  )  ;", "assertNotEquals ( l 2 i 1  . toString (  )  ,    l 2 i 2  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["twoLevelsWithNoBeanMethods"], "fileName": "org.springframework.context.annotation.NestedConfigurationClassTests"}, {"methodBody": ["METHOD_START", "{", "if    ( parserStrategyBean   instanceof   Aware )     {", "if    ( parserStrategyBean   instanceof   BeanClassLoaderAware )     {", "ClassLoader   classLoader    =     ( registry   instanceof   ConfigurableBeanFactory )     ?     (  ( ConfigurableBeanFactory )     ( registry )  )  . getBeanClassLoader (  )     :    resourceLoader . getClassLoader (  )  ;", "if    ( classLoader    !  =    null )     {", "(  ( BeanClassLoaderAware )     ( parserStrategyBean )  )  . setBeanClassLoader ( classLoader )  ;", "}", "}", "if    (  ( parserStrategyBean   instanceof   BeanFactoryAware )     &  &     ( registry   instanceof   BeanFactory )  )     {", "(  ( BeanFactoryAware )     ( parserStrategyBean )  )  . setBeanFactory (  (  ( BeanFactory )     ( registry )  )  )  ;", "}", "if    ( parserStrategyBean   instanceof   EnvironmentAware )     {", "(  ( EnvironmentAware )     ( parserStrategyBean )  )  . setEnvironment ( environment )  ;", "}", "if    ( parserStrategyBean   instanceof   ResourceLoaderAware )     {", "(  ( ResourceLoaderAware )     ( parserStrategyBean )  )  . setResourceLoader ( resourceLoader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokeAwareMethods"], "fileName": "org.springframework.context.annotation.ParserStrategyUtils"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PrimitiveBeanLookupAndAutowiringTests . Config . class ,    PrimitiveBeanLookupAndAutowiringTests . AutowiredComponent . class )  ;", "assertThat ( ctx . getBean ( PrimitiveBeanLookupAndAutowiringTests . AutowiredComponent . class )  . b ,    equalTo ( true )  )  ;", "assertThat ( ctx . getBean ( PrimitiveBeanLookupAndAutowiringTests . AutowiredComponent . class )  . i ,    equalTo (  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["primitiveAutowiredInjection"], "fileName": "org.springframework.context.annotation.PrimitiveBeanLookupAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PrimitiveBeanLookupAndAutowiringTests . Config . class )  ;", "boolean   b    =    ctx . getBean (  \" b \"  ,    boolean . class )  ;", "assertThat ( b ,    equalTo ( true )  )  ;", "int   i    =    ctx . getBean (  \" i \"  ,    int . class )  ;", "assertThat ( i ,    equalTo (  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["primitiveLookupByName"], "fileName": "org.springframework.context.annotation.PrimitiveBeanLookupAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PrimitiveBeanLookupAndAutowiringTests . Config . class )  ;", "boolean   b    =    ctx . getBean ( boolean . class )  ;", "assertThat ( b ,    equalTo ( true )  )  ;", "int   i    =    ctx . getBean ( int . class )  ;", "assertThat ( i ,    equalTo (  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["primitiveLookupByType"], "fileName": "org.springframework.context.annotation.PrimitiveBeanLookupAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PrimitiveBeanLookupAndAutowiringTests . Config . class ,    PrimitiveBeanLookupAndAutowiringTests . ResourceComponent . class )  ;", "assertThat ( ctx . getBean ( PrimitiveBeanLookupAndAutowiringTests . ResourceComponent . class )  . b ,    equalTo ( true )  )  ;", "assertThat ( ctx . getBean ( PrimitiveBeanLookupAndAutowiringTests . ResourceComponent . class )  . i ,    equalTo (  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["primitiveResourceInjection"], "fileName": "org.springframework.context.annotation.PrimitiveBeanLookupAndAutowiringTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctxWithoutName    =    new   AnnotationConfigApplicationContext (  )  ;", "MapPropertySource   mySource    =    new   MapPropertySource (  \" mine \"  ,    Collections . singletonMap (  \" testbean . name \"  ,     \" myTestBean \"  )  )  ;", "ctxWithoutName . getEnvironment (  )  . getPropertySources (  )  . addLast ( mySource )  ;", "ctxWithoutName . register (  . ConfigWithFourResourceLocations . class )  ;", "ctxWithoutName . refresh (  )  ;", "assertThat ( ctxWithoutName . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" myTestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["orderingDoesntReplaceExisting"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithImplicitName . class ,     . P 2 Config . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" p 2 TestBean \"  )  )  ;", "}", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . P 2 Config . class ,     . ConfigWithImplicitName . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" p 1 TestBean \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["orderingIsLifo"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctxWithoutName    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithFourResourceLocations . class )  ;", "assertThat ( ctxWithoutName . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" p 4 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["orderingWithAndWithoutNameAndFourResourceLocations"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctxWithName    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithNameAndMultipleResourceLocations . class )  ;", "AnnotationConfigApplicationContext   ctxWithoutName    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithMultipleResourceLocations . class )  ;", "assertThat ( ctxWithoutName . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" p 2 TestBean \"  )  )  ;", "assertThat ( ctxWithName . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" p 2 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["orderingWithAndWithoutNameAndMultipleResourceLocations"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithImplicitName . class ,     . WithCustomFactory . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" P 2 TESTBEAN \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomFactory"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithImplicitName . class ,     . WithCustomFactoryAsMeta . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" P 2 TESTBEAN \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomFactoryAsMeta"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithEmptyResourceLocations . class )  ;", "try    {", "ctx . refresh (  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["withEmptyResourceLocations"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithExplicitName . class )  ;", "ctx . refresh (  )  ;", "assertTrue (  \" property   source   p 1    was   not   added \"  ,    ctx . getEnvironment (  )  . getPropertySources (  )  . contains (  \" p 1  \"  )  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" p 1 TestBean \"  )  )  ;", "String   name ;", "MutablePropertySources   sources    =    ctx . getEnvironment (  )  . getPropertySources (  )  ;", "Iterator < PropertySource <  ?  >  >    iterator    =    sources . iterator (  )  ;", "do    {", "name    =    iterator . next (  )  . getName (  )  ;", "}    while    ( iterator . hasNext (  )     )  ;", "assertThat ( name ,    is (  \" p 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withExplicitName"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithIgnoredPropertySource . class )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 2  \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withIgnoredPropertySource"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithImplicitName . class )  ;", "ctx . refresh (  )  ;", "assertTrue (  \" property   source   p 1    was   not   added \"  ,    ctx . getEnvironment (  )  . getPropertySources (  )  . contains (  \" class   path   resource    [ org / springframework / context / annotation / p 1  . properties ]  \"  )  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" p 1 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withImplicitName"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( BeanDefinitionStoreException . class )  ;", "thrown . expectCause ( isA ( FileNotFoundException . class )  )  ;", "new   AnnotationConfigApplicationContext (  . ConfigWithMissingPropertySource . class )  ;", "}", "METHOD_END"], "methodName": ["withMissingPropertySource"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithMultipleResourceLocations . class )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" p 2 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withMultipleResourceLocations"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithNameAndMultipleResourceLocations . class )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" p 2 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withNameAndMultipleResourceLocations"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithNamedPropertySources . class )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" p 2 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withNamedPropertySources"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithPropertySources . class )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" p 2 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withPropertySources"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithResolvablePlaceholder . class )  ;", "System . setProperty (  \" path . to . properties \"  ,     \" org / springframework / context / annotation \"  )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" p 1 TestBean \"  )  )  ;", "System . clearProperty (  \" path . to . properties \"  )  ;", "}", "METHOD_END"], "methodName": ["withResolvablePlaceholder"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithResolvablePlaceholderAndFactoryBean . class )  ;", "System . setProperty (  \" path . to . properties \"  ,     \" org / springframework / context / annotation \"  )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" p 1 TestBean \"  )  )  ;", "System . clearProperty (  \" path . to . properties \"  )  ;", "}", "METHOD_END"], "methodName": ["withResolvablePlaceholderAndFactoryBean"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( PropertySourceAnnotationTests . ConfigWithSameSourceImportedInDifferentOrder . class )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . containsProperty (  \" from . p 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getEnvironment (  )  . getProperty (  \" testbean . name \"  )  ,    equalTo (  \" p 2 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withSameSourceImportedInDifferentOrder"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithTestProfileBeans . class )  ;", "ctx . refresh (  )  ;", "assertTrue ( ctx . containsBean (  \" testBean \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" testProfileBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withTestProfileBeans"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithUnresolvablePlaceholder . class )  ;", "try    {", "ctx . refresh (  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["withUnresolvablePlaceholder"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithUnresolvablePlaceholderAndDefault . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" p 1 TestBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withUnresolvablePlaceholderAndDefault"], "fileName": "org.springframework.context.annotation.PropertySourceAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    cglibLeaf    =    new   ConfigurationClassEnhancer (  )  . enhance ( ReflectionUtilsIntegrationTests . Leaf . class ,    null )  ;", "int   m 1 MethodCount    =     0  ;", "Method [  ]    methods    =    ReflectionUtils . getUniqueDeclaredMethods ( cglibLeaf )  ;", "for    ( Method   method    :    methods )     {", "if    ( method . getName (  )  . equals (  \" m 1  \"  )  )     {", "m 1 MethodCount +  +  ;", "}", "}", "assertThat ( m 1 MethodCount ,    is (  1  )  )  ;", "for    ( Method   method    :    methods )     {", "if    ( method . getName (  )  . contains (  \" m 1  \"  )  )     {", "assertEquals ( method . getReturnType (  )  ,    Integer . class )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getUniqueDeclaredMethods_withCovariantReturnType_andCglibRewrittenMethodNames"], "fileName": "org.springframework.context.annotation.ReflectionUtilsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . Config . class )  ;", "ctx . refresh (  )  ;", "assertThat (  \" Expected   bean   to   have   ROLE _ APPLICATION \"  ,    ctx . getBeanDefinition (  \" foo \"  )  . getRole (  )  ,    is ( ROLE _ APPLICATION )  )  ;", "assertThat ( ctx . getBeanDefinition (  \" foo \"  )  . getDescription (  )  ,    is (  (  ( Object )     ( null )  )  )  )  ;", "assertThat (  \" Expected   bean   to   have   ROLE _ INFRASTRUCTURE \"  ,    ctx . getBeanDefinition (  \" bar \"  )  . getRole (  )  ,    is ( ROLE _ INFRASTRUCTURE )  )  ;", "assertThat ( ctx . getBeanDefinition (  \" bar \"  )  . getDescription (  )  ,    is (  \" A   Bean   method   with   a   role \"  )  )  ;", "}", "METHOD_END"], "methodName": ["onBeanMethod"], "fileName": "org.springframework.context.annotation.RoleAndDescriptionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( ComponentWithoutRole . class ,    ComponentWithRole . class )  ;", "ctx . refresh (  )  ;", "assertThat (  \" Expected   bean   to   have   ROLE _ APPLICATION \"  ,    ctx . getBeanDefinition (  \" componentWithoutRole \"  )  . getRole (  )  ,    is ( ROLE _ APPLICATION )  )  ;", "assertThat ( ctx . getBeanDefinition (  \" componentWithoutRole \"  )  . get (  )  ,    is (  (  ( Object )     ( null )  )  )  )  ;", "assertThat (  \" Expected   bean   to   have   ROLE _ INFRASTRUCTURE \"  ,    ctx . getBeanDefinition (  \" componentWithRole \"  )  . getRole (  )  ,    is ( ROLE _ INFRASTRUCTURE )  )  ;", "assertThat ( ctx . getBeanDefinition (  \" componentWithRole \"  )  . get (  )  ,    is (  \" A   Component   with   a   role \"  )  )  ;", "}", "METHOD_END"], "methodName": ["onComponentClass"], "fileName": "org.springframework.context.annotation.RoleAndDescriptionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . scan (  \" role \"  )  ;", "ctx . refresh (  )  ;", "assertThat (  \" Expected   bean   to   have   ROLE _ APPLICATION \"  ,    ctx . getBeanDefinition (  \" componentWithoutRole \"  )  . getRole (  )  ,    is ( ROLE _ APPLICATION )  )  ;", "assertThat ( ctx . getBeanDefinition (  \" componentWithoutRole \"  )  . getDescription (  )  ,    is (  (  ( Object )     ( null )  )  )  )  ;", "assertThat (  \" Expected   bean   to   have   ROLE _ INFRASTRUCTURE \"  ,    ctx . getBeanDefinition (  \" componentWithRole \"  )  . getRole (  )  ,    is ( ROLE _ INFRASTRUCTURE )  )  ;", "assertThat ( ctx . getBeanDefinition (  \" componentWithRole \"  )  . getDescription (  )  ,    is (  \" A   Component   with   a   role \"  )  )  ;", "}", "METHOD_END"], "methodName": ["viaComponentScanning"], "fileName": "org.springframework.context.annotation.RoleAndDescriptionAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . scopeName ;", "}", "METHOD_END"], "methodName": ["getScopeName"], "fileName": "org.springframework.context.annotation.ScopeMetadata"}, {"methodBody": ["METHOD_START", "{", "return   this . scopedProxyMode ;", "}", "METHOD_END"], "methodName": ["getScopedProxyMode"], "fileName": "org.springframework.context.annotation.ScopeMetadata"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( scopeName ,     \"  ' scopeName '    must   not   be   null \"  )  ;", "this . scopeName    =    scopeName ;", "}", "METHOD_END"], "methodName": ["setScopeName"], "fileName": "org.springframework.context.annotation.ScopeMetadata"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( scopedProxyMode ,     \"  ' scopedProxyMode '    must   not   be   null \"  )  ;", "this . scopedProxyMode    =    scopedProxyMode ;", "}", "METHOD_END"], "methodName": ["setScopedProxyMode"], "fileName": "org.springframework.context.annotation.ScopeMetadata"}, {"methodBody": ["METHOD_START", "{", "return   ScopedProxyUtils . createScopedProxy ( definitionHolder ,    registry ,    proxyTargetClass )  ;", "}", "METHOD_END"], "methodName": ["createScopedProxy"], "fileName": "org.springframework.context.annotation.ScopedProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   ScopedProxyUtils . getTargetBeanName ( originalBeanName )  ;", "}", "METHOD_END"], "methodName": ["getTargetBeanName"], "fileName": "org.springframework.context.annotation.ScopedProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  {     \" simpleConfigTests . xml \"     }  ;", "}", "METHOD_END"], "methodName": ["getConfigLocations"], "fileName": "org.springframework.context.annotation.SimpleConfigTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( getConfigLocations (  )  ,    getClass (  )  )  ;", "FooService   fooService    =    ctx . getBean (  \" fooServiceImpl \"  ,    FooService . class )  ;", "ServiceInvocationCounter   serviceInvocationCounter    =    ctx . getBean (  \" serviceInvocationCounter \"  ,    ServiceInvocationCounter . class )  ;", "String   value    =    fooService . foo (  1  )  ;", "assertEquals (  \" bar \"  ,    value )  ;", "Future <  ?  >    future    =    fooService . asyncFoo (  1  )  ;", "assertTrue (  ( future   instanceof   FutureTask )  )  ;", "assertEquals (  \" bar \"  ,    future . get (  )  )  ;", "assertEquals (  2  ,    serviceInvocationCounter . getCount (  )  )  ;", "fooService . foo (  1  )  ;", "assertEquals (  3  ,    serviceInvocationCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFooService"], "fileName": "org.springframework.context.annotation.SimpleConfigTests"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  ]  {     \" simpleScanTests . xml \"     }  ;", "}", "METHOD_END"], "methodName": ["getConfigLocations"], "fileName": "org.springframework.context.annotation.SimpleScanTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( getConfigLocations (  )  ,    getClass (  )  )  ;", "FooService   fooService    =     (  ( FooService )     ( ctx . getBean (  \" fooServiceImpl \"  )  )  )  ;", "ServiceInvocationCounter   serviceInvocationCounter    =     (  ( ServiceInvocationCounter )     ( ctx . getBean (  \" serviceInvocationCounter \"  )  )  )  ;", "assertEquals (  0  ,    serviceInvocationCounter . getCount (  )  )  ;", "assertTrue ( fooService . isInitCalled (  )  )  ;", "assertEquals (  1  ,    serviceInvocationCounter . getCount (  )  )  ;", "String   value    =    fooService . foo (  1  )  ;", "assertEquals (  \" bar \"  ,    value )  ;", "assertEquals (  2  ,    serviceInvocationCounter . getCount (  )  )  ;", "fooService . foo (  1  )  ;", "assertEquals (  3  ,    serviceInvocationCounter . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFooService"], "fileName": "org.springframework.context.annotation.SimpleScanTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  1  2  0  2 Tests . Wrapper . class )  ;", "assertEquals (  \" foo \"  ,    context . getBean (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithImporter"], "fileName": "org.springframework.context.annotation.Spr11202Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  1  2  0  2 Tests . Config . class )  ;", "assertEquals (  \" foo \"  ,    context . getBean (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithoutImporter"], "fileName": "org.springframework.context.annotation.Spr11202Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  1  3  1  0 Tests . Config . class )  ;", "Spr 1  1  3  1  0 Tests . StringHolder   holder    =    context . getBean ( Spr 1  1  3  1  0 Tests . StringHolder . class )  ;", "assertEquals (  \" second \"  ,    holder . itemsArray [  0  ]  )  ;", "assertEquals (  \" first \"  ,    holder . itemsArray [  1  ]  )  ;", "assertEquals (  \" unknownOrder \"  ,    holder . itemsArray [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["orderedArray"], "fileName": "org.springframework.context.annotation.Spr11310Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  1  3  1  0 Tests . Config . class )  ;", "Spr 1  1  3  1  0 Tests . StringHolder   holder    =    context . getBean ( Spr 1  1  3  1  0 Tests . StringHolder . class )  ;", "assertEquals (  \" second \"  ,    holder . itemsList . get (  0  )  )  ;", "assertEquals (  \" first \"  ,    holder . itemsList . get (  1  )  )  ;", "assertEquals (  \" unknownOrder \"  ,    holder . itemsList . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["orderedList"], "fileName": "org.springframework.context.annotation.Spr11310Tests"}, {"methodBody": ["METHOD_START", "{", "if    (  (     !  =    null )     {", "close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.context.annotation.Spr12278Tests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( Spr 1  2  2  7  8 Tests . BaseConfiguration . class ,    Spr 1  2  2  7  8 Tests . SingleConstructorComponent . class )  ;", "assertThat ( this . context . getBean ( Spr 1  2  2  7  8 Tests . SingleConstructorComponent . class )  . autowiredName ,    is (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["componentSingleConstructor"], "fileName": "org.springframework.context.annotation.Spr12278Tests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( Spr 1  2  2  7  8 Tests . BaseConfiguration . class ,    Spr 1  2  2  7  8 Tests . TwoConstructorsComponent . class )  ;", "assertThat ( this . context . getBean ( Spr 1  2  2  7  8 Tests . TwoConstructorsComponent . class )  . name ,    is (  \" fallback \"  )  )  ;", "}", "METHOD_END"], "methodName": ["componentTwoConstructorsNoHint"], "fileName": "org.springframework.context.annotation.Spr12278Tests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( BeanCreationException . class )  ;", "thrown . expectMessage ( NoSuchMethodException . class . getName (  )  )  ;", "new   AnnotationConfigApplicationContext (  . BaseConfiguration . class ,     . TwoSpecificConstructorsComponent . class )  ;", "}", "METHOD_END"], "methodName": ["componentTwoSpecificConstructorsNoHint"], "fileName": "org.springframework.context.annotation.Spr12278Tests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this    !  =    null )     {", "thisclose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeContext"], "fileName": "org.springframework.context.annotation.Spr12636Tests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( Spr 1  2  6  3  6 Tests . UserServiceTwo . class ,    Spr 1  2  6  3  6 Tests . UserServiceOne . class ,    Spr 1  2  6  3  6 Tests . UserServiceCollector . class )  ;", "Spr 1  2  6  3  6 Tests . UserServiceCollector   bean    =    this . context . getBean ( Spr 1  2  6  3  6 Tests . UserServiceCollector . class )  ;", "assertSame ( context . getBean (  \" serviceOne \"  ,    Spr 1  2  6  3  6 Tests . UserService . class )  ,    bean . userServices . get (  0  )  )  ;", "assertSame ( context . getBean (  \" serviceTwo \"  ,    Spr 1  2  6  3  6 Tests . UserService . class )  ,    bean . userServices . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["orderOnImplementation"], "fileName": "org.springframework.context.annotation.Spr12636Tests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( Spr 1  2  6  3  6 Tests . UserServiceTwo . class ,    Spr 1  2  6  3  6 Tests . UserServiceOne . class ,    Spr 1  2  6  3  6 Tests . UserServiceCollector . class ,    Spr 1  2  6  3  6 Tests . AsyncConfig . class )  ;", "Spr 1  2  6  3  6 Tests . UserService   serviceOne    =    this . context . getBean (  \" serviceOne \"  ,    Spr 1  2  6  3  6 Tests . UserService . class )  ;", "Spr 1  2  6  3  6 Tests . UserService   serviceTwo    =    this . context . getBean (  \" serviceTwo \"  ,    Spr 1  2  6  3  6 Tests . UserService . class )  ;", "assertTrue ( AopUtils . isAopProxy ( serviceOne )  )  ;", "assertTrue ( AopUtils . isAopProxy ( serviceTwo )  )  ;", "Spr 1  2  6  3  6 Tests . UserServiceCollector   bean    =    this . context . getBean ( Spr 1  2  6  3  6 Tests . UserServiceCollector . class )  ;", "assertSame ( serviceOne ,    bean . userServices . get (  0  )  )  ;", "assertSame ( serviceTwo ,    bean . userServices . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["orderOnImplementationWithProxy"], "fileName": "org.springframework.context.annotation.Spr12636Tests"}, {"methodBody": ["METHOD_START", "{", "new   AnnotationConfigApplicationContext ( Spr 1  5  0  4  2 Tests . PoolingTargetSourceConfig . class )  ;", "}", "METHOD_END"], "methodName": ["poolingTargetSource"], "fileName": "org.springframework.context.annotation.Spr15042Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  5  2  7  5 Tests . ConfigWithAbstractFactoryBean . class )  ;", "assertEquals (  \" x \"  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo . toString (  )  )  ;", "assertSame ( context . getBean ( Spr 1  5  2  7  5 Tests . FooInterface . class )  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo )  ;", "}", "METHOD_END"], "methodName": ["testWithAbstractFactoryBean"], "fileName": "org.springframework.context.annotation.Spr15275Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  5  2  7  5 Tests . ConfigWithAbstractFactoryBeanAsReturnType . class )  ;", "assertEquals (  \" x \"  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo . toString (  )  )  ;", "assertSame ( context . getBean ( Spr 1  5  2  7  5 Tests . FooInterface . class )  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo )  ;", "}", "METHOD_END"], "methodName": ["testWithAbstractFactoryBeanAsReturnType"], "fileName": "org.springframework.context.annotation.Spr15275Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  5  2  7  5 Tests . ConfigWithAbstractFactoryBeanForInterface . class )  ;", "assertEquals (  \" x \"  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo . toString (  )  )  ;", "assertSame ( context . getBean ( Spr 1  5  2  7  5 Tests . FooInterface . class )  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo )  ;", "}", "METHOD_END"], "methodName": ["testWithAbstractFactoryBeanForInterface"], "fileName": "org.springframework.context.annotation.Spr15275Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  5  2  7  5 Tests . ConfigWithFactoryBean . class )  ;", "assertEquals (  \" x \"  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo . toString (  )  )  ;", "assertSame ( context . getBean ( Spr 1  5  2  7  5 Tests . FooInterface . class )  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo )  ;", "}", "METHOD_END"], "methodName": ["testWithFactoryBean"], "fileName": "org.springframework.context.annotation.Spr15275Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  5  2  7  5 Tests . ConfigWithFinalFactoryBean . class )  ;", "assertEquals (  \" x \"  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo . toString (  )  )  ;", "assertSame ( context . getBean ( Spr 1  5  2  7  5 Tests . FooInterface . class )  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo )  ;", "}", "METHOD_END"], "methodName": ["testWithFinalFactoryBean"], "fileName": "org.springframework.context.annotation.Spr15275Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  5  2  7  5 Tests . ConfigWithFinalFactoryBeanAsReturnType . class )  ;", "assertEquals (  \" x \"  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo . toString (  )  )  ;", "assertNotSame ( context . getBean ( Spr 1  5  2  7  5 Tests . FooInterface . class )  ,    context . getBean ( Spr 1  5  2  7  5 Tests . Bar . class )  . foo )  ;", "}", "METHOD_END"], "methodName": ["testWithFinalFactoryBeanAsReturnType"], "fileName": "org.springframework.context.annotation.Spr15275Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   bf    =    new   AnnotationConfigApplicationContext ( Spr 1  6  1  7  9 Tests . AssemblerConfig . class ,    Spr 1  6  1  7  9 Tests . AssemblerInjection . class )  ;", "assertSame ( bf . getBean (  \" someAssembler \"  )  ,    bf . getBean ( Spr 1  6  1  7  9 Tests . AssemblerInjection . class )  . assembler 0  )  ;", "assertSame ( bf . getBean (  \" pageAssembler \"  )  ,    bf . getBean ( Spr 1  6  1  7  9 Tests . AssemblerInjection . class )  . assembler 3  )  ;", "assertSame ( bf . getBean (  \" pageAssembler \"  )  ,    bf . getBean ( Spr 1  6  1  7  9 Tests . AssemblerInjection . class )  . assembler 4  )  ;", "assertSame ( bf . getBean (  \" pageAssembler \"  )  ,    bf . getBean ( Spr 1  6  1  7  9 Tests . AssemblerInjection . class )  . assembler 5  )  ;", "assertSame ( bf . getBean (  \" pageAssembler \"  )  ,    bf . getBean ( Spr 1  6  1  7  9 Tests . AssemblerInjection . class )  . assembler 6  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.context.annotation.Spr16179Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . setAllowBeanDefinitionOverriding ( false )  ;", "context . register (  . UnconditionalImportingConfiguration . class )  ;", "context . refresh (  )  ;", "try    {", "context . getBean (  \" someBean \"  )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["baseConfigurationIsIncludedOnceWhenBothConfigurationClassesAreActive"], "fileName": "org.springframework.context.annotation.Spr16217Tests"}, {"methodBody": ["METHOD_START", "{", "try    ( AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  6  2  1  7 Tests . ParseConfigurationPhaseImportingConfiguration . class )  )     {", "context . getBean (  \" someBean \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["baseConfigurationIsIncludedWhenFirstSuperclassReferenceIsSkippedInParseConfigurationPhase"], "fileName": "org.springframework.context.annotation.Spr16217Tests"}, {"methodBody": ["METHOD_START", "{", "try    ( AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  6  2  1  7 Tests . RegisterBeanPhaseImportingConfiguration . class )  )     {", "context . getBean (  \" someBean \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["baseConfigurationIsIncludedWhenFirstSuperclassReferenceIsSkippedInRegisterBeanPhase"], "fileName": "org.springframework.context.annotation.Spr16217Tests"}, {"methodBody": ["METHOD_START", "{", "debugMethods ( clazz ,    category ,    actualMethods )  ;", "assertTrue (  (  (  (  (  (  (  \" Verify    \"     +    category )     +     \"  :    expected <  \"  )     +    expectedMethods )     +     \"  >    but   got <  \"  )     +    actualMethods )     +     \"  >  .  \"  )  ,    ObjectUtils . nullSafeEquals ( expectedMethods ,    actualMethods )  )  ;", "}", "METHOD_END"], "methodName": ["assertMethodOrdering"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( beanClass )  ;", "beanDefinition . setInitMethodName ( initMethodName )  ;", "beanDefinition . setDestroyMethodName ( destroyMethodName )  ;", "beanFactory . addBeanPostProcessor ( new   CommonAnnotationBeanPostProcessor (  )  )  ;", "beanFactory . registerBeanDefinition (  . LIFECYCLE _ TEST _ BEAN ,    beanDefinition )  ;", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["createBeanFactoryAndRegisterBean"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "if    ( Spr 3  7  7  5 InitDestroyLifecycleTests . logger . isDebugEnabled (  )  )     {", "Spr 3  7  7  5 InitDestroyLifecycleTests . logger . debug (  (  (  (  (  ( clazz . getSimpleName (  )  )     +     \"  :     \"  )     +    category )     +     \"  :     \"  )     +    methodNames )  )  ;", "}", "}", "METHOD_END"], "methodName": ["debugMethods"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    beanClass    =    Spr 3  7  7  5 InitDestroyLifecycleTests . AllInOneBean . class ;", "final   DefaultListableBeanFactory   beanFactory    =    createBeanFactoryAndRegisterBean ( beanClass ,     \" afterPropertiesSet \"  ,     \" destroy \"  )  ;", "final   Spr 3  7  7  5 InitDestroyLifecycleTests . AllInOneBean   bean    =     (  ( Spr 3  7  7  5 InitDestroyLifecycleTests . AllInOneBean )     ( beanFactory . getBean ( Spr 3  7  7  5 InitDestroyLifecycleTests . LIFECYCLE _ TEST _ BEAN )  )  )  ;", "assertMethodOrdering ( beanClass ,     \" init - methods \"  ,    Arrays . asList (  \" afterPropertiesSet \"  )  ,    bean . initMethods )  ;", "beanFactory . destroySingletons (  )  ;", "assertMethodOrdering ( beanClass ,     \" destroy - methods \"  ,    Arrays . asList (  \" destroy \"  )  ,    bean . destroyMethods )  ;", "}", "METHOD_END"], "methodName": ["testAllLifecycleMechanismsAtOnce"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    beanClass    =    Spr 3  7  7  5 InitDestroyLifecycleTests . InitDestroyBean . class ;", "final   DefaultListableBeanFactory   beanFactory    =    createBeanFactoryAndRegisterBean ( beanClass ,     \" afterPropertiesSet \"  ,     \" destroy \"  )  ;", "final   Spr 3  7  7  5 InitDestroyLifecycleTests . InitDestroyBean   bean    =     (  ( Spr 3  7  7  5 InitDestroyLifecycleTests . InitDestroyBean )     ( beanFactory . getBean ( Spr 3  7  7  5 InitDestroyLifecycleTests . LIFECYCLE _ TEST _ BEAN )  )  )  ;", "assertMethodOrdering ( beanClass ,     \" init - methods \"  ,    Arrays . asList (  \" afterPropertiesSet \"  )  ,    bean . initMethods )  ;", "beanFactory . destroySingletons (  )  ;", "assertMethodOrdering ( beanClass ,     \" destroy - methods \"  ,    Arrays . asList (  \" destroy \"  )  ,    bean . destroyMethods )  ;", "}", "METHOD_END"], "methodName": ["testInitDestroyMethods"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    beanClass    =    Spr 3  7  7  5 InitDestroyLifecycleTests . CustomInitializingDisposableBean . class ;", "final   DefaultListableBeanFactory   beanFactory    =    createBeanFactoryAndRegisterBean ( beanClass ,     \" customInit \"  ,     \" customDestroy \"  )  ;", "final   Spr 3  7  7  5 InitDestroyLifecycleTests . CustomInitializingDisposableBean   bean    =     (  ( Spr 3  7  7  5 InitDestroyLifecycleTests . CustomInitializingDisposableBean )     ( beanFactory . getBean ( Spr 3  7  7  5 InitDestroyLifecycleTests . LIFECYCLE _ TEST _ BEAN )  )  )  ;", "assertMethodOrdering ( beanClass ,     \" init - methods \"  ,    Arrays . asList (  \" afterPropertiesSet \"  ,     \" customInit \"  )  ,    bean . initMethods )  ;", "beanFactory . destroySingletons (  )  ;", "assertMethodOrdering ( beanClass ,     \" destroy - methods \"  ,    Arrays . asList (  \" destroy \"  ,     \" customDestroy \"  )  ,    bean . destroyMethods )  ;", "}", "METHOD_END"], "methodName": ["testInitializingDisposableInterfaces"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    beanClass    =    Spr 3  7  7  5 InitDestroyLifecycleTests . InitializingDisposableWithShadowedMethodsBean . class ;", "final   DefaultListableBeanFactory   beanFactory    =    createBeanFactoryAndRegisterBean ( beanClass ,     \" afterPropertiesSet \"  ,     \" destroy \"  )  ;", "final   Spr 3  7  7  5 InitDestroyLifecycleTests . InitializingDisposableWithShadowedMethodsBean   bean    =     (  ( Spr 3  7  7  5 InitDestroyLifecycleTests . InitializingDisposableWithShadowedMethodsBean )     ( beanFactory . getBean ( Spr 3  7  7  5 InitDestroyLifecycleTests . LIFECYCLE _ TEST _ BEAN )  )  )  ;", "assertMethodOrdering ( beanClass ,     \" init - methods \"  ,    Arrays . asList (  \" InitializingBean . afterPropertiesSet \"  )  ,    bean . initMethods )  ;", "beanFactory . destroySingletons (  )  ;", "assertMethodOrdering ( beanClass ,     \" destroy - methods \"  ,    Arrays . asList (  \" DisposableBean . destroy \"  )  ,    bean . destroyMethods )  ;", "}", "METHOD_END"], "methodName": ["testInitializingDisposableInterfacesWithShadowedMethods"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    beanClass    =    Spr 3  7  7  5 InitDestroyLifecycleTests . CustomAnnotatedInitDestroyBean . class ;", "final   DefaultListableBeanFactory   beanFactory    =    createBeanFactoryAndRegisterBean ( beanClass ,     \" customInit \"  ,     \" customDestroy \"  )  ;", "final   Spr 3  7  7  5 InitDestroyLifecycleTests . CustomAnnotatedInitDestroyBean   bean    =     (  ( Spr 3  7  7  5 InitDestroyLifecycleTests . CustomAnnotatedInitDestroyBean )     ( beanFactory . getBean ( Spr 3  7  7  5 InitDestroyLifecycleTests . LIFECYCLE _ TEST _ BEAN )  )  )  ;", "assertMethodOrdering ( beanClass ,     \" init - methods \"  ,    Arrays . asList (  \" postConstruct \"  ,     \" afterPropertiesSet \"  ,     \" customInit \"  )  ,    bean . initMethods )  ;", "beanFactory . destroySingletons (  )  ;", "assertMethodOrdering ( beanClass ,     \" destroy - methods \"  ,    Arrays . asList (  \" preDestroy \"  ,     \" destroy \"  ,     \" customDestroy \"  )  ,    bean . destroyMethods )  ;", "}", "METHOD_END"], "methodName": ["testJsr250Annotations"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    beanClass    =    Spr 3  7  7  5 InitDestroyLifecycleTests . CustomAnnotatedInitDestroyWithShadowedMethodsBean . class ;", "final   DefaultListableBeanFactory   beanFactory    =    createBeanFactoryAndRegisterBean ( beanClass ,     \" customInit \"  ,     \" customDestroy \"  )  ;", "final   Spr 3  7  7  5 InitDestroyLifecycleTests . CustomAnnotatedInitDestroyWithShadowedMethodsBean   bean    =     (  ( Spr 3  7  7  5 InitDestroyLifecycleTests . CustomAnnotatedInitDestroyWithShadowedMethodsBean )     ( beanFactory . getBean ( Spr 3  7  7  5 InitDestroyLifecycleTests . LIFECYCLE _ TEST _ BEAN )  )  )  ;", "assertMethodOrdering ( beanClass ,     \" init - methods \"  ,    Arrays . asList (  \"  @ PostConstruct . afterPropertiesSet \"  ,     \" customInit \"  )  ,    bean . initMethods )  ;", "beanFactory . destroySingletons (  )  ;", "assertMethodOrdering ( beanClass ,     \" destroy - methods \"  ,    Arrays . asList (  \"  @ PreDestroy . destroy \"  ,     \" customDestroy \"  )  ,    bean . destroyMethods )  ;", "}", "METHOD_END"], "methodName": ["testJsr250AnnotationsWithShadowedMethods"], "fileName": "org.springframework.context.annotation.Spr3775InitDestroyLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "Spr 6  6  0  2 Tests . Foo   foo    =    ctx . getBean ( Spr 6  6  0  2 Tests . Foo . class )  ;", "Spr 6  6  0  2 Tests . Bar   bar 1     =    ctx . getBean ( Spr 6  6  0  2 Tests . Bar . class )  ;", "Spr 6  6  0  2 Tests . Bar   bar 2     =    ctx . getBean ( Spr 6  6  0  2 Tests . Bar . class )  ;", "assertThat ( bar 1  ,    is ( bar 2  )  )  ;", "assertThat ( bar 1  ,    is ( foo . bar )  )  ;", "Spr 6  6  0  2 Tests . BarFactory   barFactory 1     =    ctx . getBean ( Spr 6  6  0  2 Tests . BarFactory . class )  ;", "Spr 6  6  0  2 Tests . BarFactory   barFactory 2     =    ctx . getBean ( Spr 6  6  0  2 Tests . BarFactory . class )  ;", "assertThat ( barFactory 1  ,    is ( barFactory 2  )  )  ;", "Spr 6  6  0  2 Tests . Bar   bar 3     =    barFactory 1  . getObject (  )  ;", "Spr 6  6  0  2 Tests . Bar   bar 4     =    barFactory 1  . getObject (  )  ;", "assertThat ( bar 3  ,    is ( not ( bar 4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doAssertions"], "fileName": "org.springframework.context.annotation.Spr6602Tests"}, {"methodBody": ["METHOD_START", "{", "doAssertions ( new   AnnotationConfigApplicationContext ( Spr 6  6  0  2 Tests . FooConfig . class )  )  ;", "}", "METHOD_END"], "methodName": ["testConfigurationClassBehavior"], "fileName": "org.springframework.context.annotation.Spr6602Tests"}, {"methodBody": ["METHOD_START", "{", "doAssertions ( new   ClassPathXmlApplicationContext (  \" Spr 6  6  0  2 Tests - context . xml \"  ,    Spr 6  6  0  2 Tests . class )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlBehavior"], "fileName": "org.springframework.context.annotation.Spr6602Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   bf    =    new   AnnotationConfigApplicationContext (  )  ;", "bf . registerBeanDefinition (  \" fooConfig \"  ,    new   RootBeanDefinition (  . FooConfig . class )  )  ;", "bf . getBeanFactory (  )  . addBeanPostProcessor ( new    . PredictingBPP (  )  )  ;", "bf . refresh (  )  ;", "assertThat ( bf . isTypeMatch (  \"  & foo \"  ,    FactoryBean . class )  ,    is ( true )  )  ;", "@ SuppressWarnings (  \" rawtypes \"  )", "Map < String ,    FactoryBean >    fbBeans    =    bf . getBeansOfType ( FactoryBean . class )  ;", "assertThat (  1  ,    equalTo ( fbBeans . size (  )  )  )  ;", "assertThat (  \"  & foo \"  ,    equalTo ( fbBeans . keySet (  )  . iterator (  )  . next (  )  )  )  ;", "Map < String ,     . AnInterface >    aiBeans    =    bf . getBeansOfType (  . AnInterface . class )  ;", "assertThat (  1  ,    equalTo ( aiBeans . size (  )  )  )  ;", "assertThat (  \"  & foo \"  ,    equalTo ( aiBeans . keySet (  )  . iterator (  )  . next (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findsBeansByTypeIfNotInstantiated"], "fileName": "org.springframework.context.annotation.Spr8954Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   bf    =    new   AnnotationConfigApplicationContext (  )  ;", "bf . registerBeanDefinition (  \" fooConfig \"  ,    new   RootBeanDefinition (  . FooConfig . class )  )  ;", "bf . getBeanFactory (  )  . addBeanPostProcessor ( new    . PredictingBPP (  )  )  ;", "bf . refresh (  )  ;", "assertThat ( bf . getBean (  \" foo \"  )  ,    instanceOf (  . Foo . class )  )  ;", "assertThat ( bf . getBean (  \"  & foo \"  )  ,    instanceOf (  . FooFactoryBean . class )  )  ;", "assertThat ( bf . isTypeMatch (  \"  & foo \"  ,    FactoryBean . class )  ,    is ( true )  )  ;", "@ SuppressWarnings (  \" rawtypes \"  )", "Map < String ,    FactoryBean >    fbBeans    =    bf . getBeansOfType ( FactoryBean . class )  ;", "assertThat (  1  ,    equalTo ( fbBeans . size (  )  )  )  ;", "assertThat (  \"  & foo \"  ,    equalTo ( fbBeans . keySet (  )  . iterator (  )  . next (  )  )  )  ;", "Map < String ,     . AnInterface >    aiBeans    =    bf . getBeansOfType (  . AnInterface . class )  ;", "assertThat (  1  ,    equalTo ( aiBeans . size (  )  )  )  ;", "assertThat (  \"  & foo \"  ,    equalTo ( aiBeans . keySet (  )  . iterator (  )  . next (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.context.annotation.Spr8954Tests"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  \" level 1 Bean \"  )  ;", "}", "METHOD_END"], "methodName": ["level1Bean"], "fileName": "org.springframework.context.annotation.componentscan.level1.Level1Config"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  \" level 2 Bean \"  )  ;", "}", "METHOD_END"], "methodName": ["level2Bean"], "fileName": "org.springframework.context.annotation.componentscan.level2.Level2Config"}, {"methodBody": ["METHOD_START", "{", "return    \" example \"  ;", "}", "METHOD_END"], "methodName": ["exampleBean"], "fileName": "org.springframework.context.annotation.componentscan.simple.SimpleComponent"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( new   ClassPathResource (  \" do _ not _ delete _ me . txt \"  )  . contentLength (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "System . clearProperty (  \" myProp \"  )  ;", "TestBean   testBean    =    getBean (  \" testBean \"  ,    TestBean . class )  ;", "assertNull ( testBean . getName (  )  )  ;", "testBean    =    getBean (  \" testBean 2  \"  ,    TestBean . class )  ;", "assertNull ( testBean . getName (  )  )  ;", "System . setProperty (  \" myProp \"  ,     \" foo \"  )  ;", "testBean    =    getBean (  \" testBean \"  ,    TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" foo \"  )  )  ;", "testBean    =    getBean (  \" testBean 2  \"  ,    TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" foo \"  )  )  ;", "System . clearProperty (  \" myProp \"  )  ;", "testBean    =    getBean (  \" testBean \"  ,    TestBean . class )  ;", "assertNull ( testBean . getName (  )  )  ;", "testBean    =    getBean (  \" testBean 2  \"  ,    TestBean . class )  ;", "assertNull ( testBean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestValueInjection"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions ( new   ClassPathResource (  \" annotation - config . xml \"  ,     . MultipleConstructorConfig . class )  )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext ( factory )  ;", "ctx . registerBeanDefinition (  \" config 1  \"  ,    new   RootBeanDefinition (  . MultipleConstructorConfig . class )  )  ;", "ctx . registerBeanDefinition (  \" config 2  \"  ,    new   RootBeanDefinition (  . ColorConfig . class )  )  ;", "ctx . refresh (  )  ;", "assertSame ( ctx . getBean (  . MultipleConstructorConfig . class )  . colour ,    ctx . getBean ( Colour . class )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredAnnotatedConstructorSupported"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  (  ( AutowiredConfigurationTests . class . getSimpleName (  )  )     +     \"  . xml \"  )  ,    AutowiredConfigurationTests . class )  ;", "assertThat ( context . getBean (  \" colour \"  ,    Colour . class )  ,    equalTo ( RED )  )  ;", "assertThat ( context . getBean (  \" testBean \"  ,    TestBean . class )  . getName (  )  ,    equalTo ( RED . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredConfigurationDependencies"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AutowiredConfigurationTests . AutowiredMethodConfig . class ,    AutowiredConfigurationTests . ColorConfig . class )  ;", "assertThat ( context . getBean ( Colour . class )  ,    equalTo ( RED )  )  ;", "assertThat ( context . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" RED - RED \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredConfigurationMethodDependencies"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AutowiredConfigurationTests . OptionalAutowiredMethodConfig . class ,    AutowiredConfigurationTests . ColorConfig . class )  ;", "assertThat ( context . getBean ( Colour . class )  ,    equalTo ( RED )  )  ;", "assertThat ( context . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" RED - RED \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredConfigurationMethodDependenciesWithOptionalAndAvailable"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AutowiredConfigurationTests . OptionalAutowiredMethodConfig . class )  ;", "assertTrue ( context . getBeansOfType ( Colour . class )  . isEmpty (  )  )  ;", "assertThat ( context . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredConfigurationMethodDependenciesWithOptionalAndNotAvailable"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions ( new   ClassPathResource (  \" annotation - config . xml \"  ,     . AutowiredConstructorConfig . class )  )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext ( factory )  ;", "ctx . registerBeanDefinition (  \" config 1  \"  ,    new   RootBeanDefinition (  . AutowiredConstructorConfig . class )  )  ;", "ctx . registerBeanDefinition (  \" config 2  \"  ,    new   RootBeanDefinition (  . ColorConfig . class )  )  ;", "ctx . refresh (  )  ;", "assertSame ( ctx . getBean (  . AutowiredConstructorConfig . class )  . colour ,    ctx . getBean ( Colour . class )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowiredSingleConstructorSupported"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" AutowiredConfigurationTests - custom . xml \"  ,    AutowiredConfigurationTests . class )  ;", "TestBean   testBean    =    context . getBean (  \" testBean \"  ,    TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" localhost \"  )  )  ;", "assertThat ( testBean . getAge (  )  ,    equalTo ( contentLength (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomPropertiesWithClassPathContext"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "new   XmlBeanDefinitionReader ( context )  . loadBeanDefinitions ( new   ClassPathResource (  \"  - custom . xml \"  ,     . class )  )  ;", "context . refresh (  )  ;", "TestBean   testBean    =    context . getBean (  \" testBean \"  ,    TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" localhost \"  )  )  ;", "assertThat ( testBean . getAge (  )  ,    equalTo ( contentLength (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomPropertiesWithGenericContext"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions ( new   ClassPathResource (  \" annotation - config . xml \"  ,     . ObjectFactoryConstructorConfig . class )  )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext ( factory )  ;", "ctx . registerBeanDefinition (  \" config 1  \"  ,    new   RootBeanDefinition (  . ObjectFactoryConstructorConfig . class )  )  ;", "ctx . registerBeanDefinition (  \" config 2  \"  ,    new   RootBeanDefinition (  . ColorConfig . class )  )  ;", "ctx . refresh (  )  ;", "assertSame ( ctx . getBean (  . ObjectFactoryConstructorConfig . class )  . colour ,    ctx . getBean ( Colour . class )  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryConstructorWithTypeVariable"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" ValueInjectionTests . xml \"  ,    AutowiredConfigurationTests . class )  ;", "doTestValueInjection ( context )  ;", "}", "METHOD_END"], "methodName": ["testValueInjection"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AutowiredConfigurationTests . ValueConfigWithAliasedMetaAnnotation . class )  ;", "doTestValueInjection ( context )  ;", "}", "METHOD_END"], "methodName": ["testValueInjectionWithAliasedMetaAnnotation"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AutowiredConfigurationTests . ValueConfigWithMetaAnnotation . class )  ;", "doTestValueInjection ( context )  ;", "}", "METHOD_END"], "methodName": ["testValueInjectionWithMetaAnnotation"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AutowiredConfigurationTests . ValueConfigWithProviderConstructorArguments . class )  ;", "doTestValueInjection ( context )  ;", "}", "METHOD_END"], "methodName": ["testValueInjectionWithProviderConstructorArguments"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AutowiredConfigurationTests . ValueConfigWithProviderFields . class )  ;", "doTestValueInjection ( context )  ;", "}", "METHOD_END"], "methodName": ["testValueInjectionWithProviderFields"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AutowiredConfigurationTests . ValueConfigWithProviderMethodArguments . class )  ;", "doTestValueInjection ( context )  ;", "}", "METHOD_END"], "methodName": ["testValueInjectionWithProviderMethodArguments"], "fileName": "org.springframework.context.annotation.configuration.AutowiredConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( configClass )  )  ;", "CClassPostProcessor   pp    =    new   CClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( factory )  ;", "return    (  ( AbstractBeanDefinition )     ( factory . getBeanDefinition (  \" foo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["beanDef"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Lazy", "@ C", "class   Config    {", "@ Bean", "Object   foo (  )     {", "return   null ;", "}", "}", "assertTrue (  \"  @ Bean   methods   declared   in   a    @ Lazy    @ C   should   be   lazily   instantiated \"  ,    beanDef ( Config . class )  . isLazyInit (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultLazyConfigurationPropagatesToIndividualBeans"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Configuration", "class   Config    {", "@ Bean", "@ DependsOn (  {     \" bar \"  ,     \" baz \"     }  )", "Object   foo (  )     {", "return   null ;", "}", "}", "assertArrayEquals (  \" dependsOn   metadata   was   not   propagated \"  ,    new   String [  ]  {     \" bar \"  ,     \" baz \"     }  ,    beanDef ( Config . class )  . getDependsOn (  )  )  ;", "}", "METHOD_END"], "methodName": ["dependsOnMetadataIsPropagated"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Configuration", "class   Config    {", "@ Bean ( destroyMethod    =     \" destroy \"  )", "Object   foo (  )     {", "return   null ;", "}", "}", "assertEquals (  \" destroy   method   name   was   not   propagated \"  ,     \" destroy \"  ,    beanDef ( Config . class )  . getDestroyMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["destroyMethodMetadataIsPropagated"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Lazy", "@ C", "class   Config    {", "@ Lazy ( false )", "@ Bean", "Object   foo (  )     {", "return   null ;", "}", "}", "assertFalse (  \"  @ Lazy ( false )     @ Bean   methods   declared   in   a    @ Lazy    @ C   should   be   eagerly   instantiated \"  ,    beanDef ( Config . class )  . isLazyInit (  )  )  ;", "}", "METHOD_END"], "methodName": ["eagerBeanOverridesDefaultLazyConfiguration"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Lazy ( false )", "@ C", "class   Config    {", "@ Bean", "Object   foo (  )     {", "return   null ;", "}", "}", "assertFalse (  \"  @ Lazy ( false )     @ C   should   produce   eager   bean   definitions \"  ,    beanDef ( Config . class )  . isLazyInit (  )  )  ;", "}", "METHOD_END"], "methodName": ["eagerConfigurationProducesEagerBeanDefinitions"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Configuration", "class   Config    {", "@ Bean ( initMethod    =     \" start \"  )", "Object   foo (  )     {", "return   null ;", "}", "}", "assertEquals (  \" init   method   name   was   not   propagated \"  ,     \" start \"  ,    beanDef ( Config . class )  . getInitMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["initMethodMetadataIsPropagated"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Configuration", "class   Config    {", "@ Bean", "Object   foo (  )     {", "return   null ;", "}", "}", "assertFalse (  \"  @ Bean   methods   should   be   non - lazy   by   default \"  ,    beanDef ( Config . class )  . isLazyInit (  )  )  ;", "}", "METHOD_END"], "methodName": ["lazyMetadataIsFalseByDefault"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Configuration", "class   Config    {", "@ Lazy", "@ Bean", "Object   foo (  )     {", "return   null ;", "}", "}", "assertTrue (  \" lazy   metadata   was   not   propagated \"  ,    beanDef ( Config . class )  . isLazyInit (  )  )  ;", "}", "METHOD_END"], "methodName": ["lazyMetadataIsPropagated"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Configuration", "class   Config    {", "@ Bean", "Object   foo (  )     {", "return   null ;", "}", "}", "assertFalse (  \"  @ Bean   methods   should   be   non - primary   by   default \"  ,    beanDef ( Config . class )  . isPrimary (  )  )  ;", "}", "METHOD_END"], "methodName": ["primaryMetadataIsFalseByDefault"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "@ Configuration", "class   Config    {", "@ Primary", "@ Bean", "Object   foo (  )     {", "return   null ;", "}", "}", "assertTrue (  \" primary   metadata   was   not   propagated \"  ,    beanDef ( Config . class )  . isPrimary (  )  )  ;", "}", "METHOD_END"], "methodName": ["primaryMetadataIsPropagated"], "fileName": "org.springframework.context.annotation.configuration.BeanAnnotationAttributePropagationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( BeanMethodQualificationTests . CustomConfig . class ,    BeanMethodQualificationTests . CustomPojo . class )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" testBean 1  \"  )  )  ;", "BeanMethodQualificationTests . CustomPojo   pojo    =    ctx . getBean ( BeanMethodQualificationTests . CustomPojo . class )  ;", "assertThat ( pojo . testBean . getName (  )  ,    equalTo (  \" interesting \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustom"], "fileName": "org.springframework.context.annotation.configuration.BeanMethodQualificationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" customConfig \"  ,    new   RootBeanDefinition (  . CustomConfig . class . getName (  )  )  )  ;", "RootBeanDefinition   customPojo    =    new   RootBeanDefinition (  . CustomPojo . class . getName (  )  )  ;", "customPojo . setLazyInit ( true )  ;", "ctx . registerBeanDefinition (  \" customPojo \"  ,    customPojo )  ;", "ctx . refresh (  )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" testBean 1  \"  )  )  ;", ". CustomPojo   pojo    =    ctx . getBean (  . CustomPojo . class )  ;", "assertThat ( pojo . testBean . getName (  )  ,    equalTo (  \" interesting \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomWithAsm"], "fileName": "org.springframework.context.annotation.configuration.BeanMethodQualificationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( BeanMethodQualificationTests . CustomConfigWithAttributeOverride . class ,    BeanMethodQualificationTests . CustomPojo . class )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" testBeanX \"  )  )  ;", "BeanMethodQualificationTests . CustomPojo   pojo    =    ctx . getBean ( BeanMethodQualificationTests . CustomPojo . class )  ;", "assertThat ( pojo . testBean . getName (  )  ,    equalTo (  \" interesting \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomWithAttributeOverride"], "fileName": "org.springframework.context.annotation.configuration.BeanMethodQualificationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( BeanMethodQualificationTests . ScopedConfig . class ,    BeanMethodQualificationTests . StandardPojo . class )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" testBean 1  \"  )  )  ;", "BeanMethodQualificationTests . StandardPojo   pojo    =    ctx . getBean ( BeanMethodQualificationTests . StandardPojo . class )  ;", "assertThat ( pojo . testBean . getName (  )  ,    equalTo (  \" interesting \"  )  )  ;", "assertThat ( pojo . testBean 2  . getName (  )  ,    equalTo (  \" boring \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testScoped"], "fileName": "org.springframework.context.annotation.configuration.BeanMethodQualificationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( BeanMethodQualificationTests . ScopedProxyConfig . class ,    BeanMethodQualificationTests . StandardPojo . class )  ;", "assertTrue ( ctx . getBeanFactory (  )  . containsSingleton (  \" testBean 1  \"  )  )  ;", "BeanMethodQualificationTests . StandardPojo   pojo    =    ctx . getBean ( BeanMethodQualificationTests . StandardPojo . class )  ;", "assertThat ( pojo . testBean . getName (  )  ,    equalTo (  \" interesting \"  )  )  ;", "assertThat ( pojo . testBean 2  . getName (  )  ,    equalTo (  \" boring \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedProxy"], "fileName": "org.springframework.context.annotation.configuration.BeanMethodQualificationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( BeanMethodQualificationTests . StandardConfig . class ,    BeanMethodQualificationTests . StandardPojo . class )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" testBean 1  \"  )  )  ;", "BeanMethodQualificationTests . StandardPojo   pojo    =    ctx . getBean ( BeanMethodQualificationTests . StandardPojo . class )  ;", "assertThat ( pojo . testBean . getName (  )  ,    equalTo (  \" interesting \"  )  )  ;", "assertThat ( pojo . testBean 2  . getName (  )  ,    equalTo (  \" boring \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandard"], "fileName": "org.springframework.context.annotation.configuration.BeanMethodQualificationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . A . B . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" outer \"  )  ,    is ( false )  )  ;", "assertThat ( ctx . containsBean (  \" imported \"  )  ,    is ( false )  )  ;", "assertThat ( ctx . containsBean (  \" nested \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" nestedBean \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["registerNestedConfig"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationBeanNameTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . A . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" outer \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" imported \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" nested \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" nestedBean \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["registerOuterConfig"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationBeanNameTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . setBeanNameGenerator ( new   AnnotationBeanNameGenerator (  )     {", "@ Override", "public   String   generateBeanName ( BeanDefinition   definition ,    BeanDefinitionRegistry   registry )     {", "return    \" custom -  \"     +     ( super . generateBeanName ( definition ,    registry )  )  ;", "}", "}  )  ;", "ctx . register (  . A . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" custom - outer \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" custom - imported \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" custom - nested \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" nestedBean \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["registerOuterConfig_withBeanNameGenerator"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationBeanNameTests"}, {"methodBody": ["METHOD_START", "{", "assertAdviceWasApplied ( ConfigurationClassAspectIntegrationTests . AspectConfig . class )  ;", "}", "METHOD_END"], "methodName": ["aspectAnnotatedConfiguration"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions ( new   ClassPathResource (  \" aspectj - autoproxy - config . xml \"  ,     . class )  )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext ( factory )  ;", "ctx . addBeanFactoryPostProcessor ( new   ConfigurationClassPostProcessor (  )  )  ;", "ctx . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( configClass )  )  ;", "ctx . refresh (  )  ;", "TestBean   testBean    =    ctx . getBean (  \" testBean \"  ,    TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" name \"  )  )  ;", "testBean . absquatulate (  )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" advisedName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAdviceWasApplied"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertAdviceWasApplied ( ConfigurationClassAspectIntegrationTests . ConfigurationWithAspect . class )  ;", "}", "METHOD_END"], "methodName": ["configurationIncludesAspect"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ConfigurationClassAspectIntegrationTests . Application . class ,    ConfigurationClassAspectIntegrationTests . CountingAspect . class )  ;", "ctx . getBeansOfType ( Runnable . class )  . forEach (  (    k ,    v )     -  >    v . run (  )  )  ;", "}", "METHOD_END"], "methodName": ["withInnerClassAndLambdaExpression"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    testBeanSupplier . get (  )  ;", "BeanFactory   factory    =    initBeanFactory ( testClass )  ;", "assertSame ( testBean ,    factory . getBean ( beanName )  )  ;", "Arrays . stream ( factory . getAliases ( beanName )  )  . map ( factory :  : getBean )  . forEach (  (    alias )     -  >    assertSame ( testBean ,    alias )  )  ;", "exception . expect ( NoSuchBeanDefinitionExceplass )  ;", "factory . getBean (  \" methodName \"  )  ;", "}", "METHOD_END"], "methodName": ["aliasesAreRespected"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "aliasesAreRespected ( ConfigurationClassProcessingTests . ConfigWithBeanWithAliases . class ,     (  )     -  >    ConfigurationClassProcessingTests . ConfigWithBeanWithAliases . testBean ,     \" name 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["aliasesAreRespectedWhenConfiguredViaNameAttribute"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "aliasesAreRespected ( ConfigurationClassProcessingTests . ConfigWithBeanWithAliasesConfiguredViaValueAttribute . class ,     (  )     -  >    ConfigurationClassProcessingTests . ConfigWithBeanWithAliasesConfiguredViaValueAttribute . testBean ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["aliasesAreRespectedWhenConfiguredViaValueAttribute"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ac )  ;", "ac . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . ConfigWithBeanWithProviderImplementation . class )  )  ;", "ac . refresh (  )  ;", "assertSame ( ac . getBean (  \" customName \"  )  ,     . ConfigWithBeanWithProviderImplementation . testBean )  ;", "}", "METHOD_END"], "methodName": ["configWithBeanWithProviderImplementation"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "ListableBeanFactory   factory    =    initBeanFactory ( ConfigurationClassProcessingTests . ConfigWithNonSpecificReturnTypes . class )  ;", "assertEquals ( List . class ,    factory . getType (  \" factoryBean \"  )  )  ;", "assertTrue ( factory . isTypeMatch (  \" factoryBean \"  ,    List . class )  )  ;", "assertEquals ( FactoryBean . class ,    factory . getType (  \"  & factoryBean \"  )  )  ;", "assertTrue ( factory . isTypeMatch (  \"  & factoryBean \"  ,    FactoryBean . class )  )  ;", "assertFalse ( factory . isTypeMatch (  \"  & factoryBean \"  ,    BeanClassLoaderAware . class )  )  ;", "assertFalse ( factory . isTypeMatch (  \"  & factoryBean \"  ,    ListFactoryBean . class )  )  ;", "assertTrue (  (  ( factory . getBean (  \" factoryBean \"  )  )    instanceof   List )  )  ;", "String [  ]    beanNames    =    factory . getBeanNamesForType ( FactoryBean . class )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    factory . getBeanNamesForType ( BeanClassLoaderAware . class )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    factory . getBeanNamesForType ( ListFactoryBean . class )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    factory . getBeanNamesForType ( List . class )  ;", "assertEquals (  \" factoryBean \"  ,    beanNames [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["configWithFactoryBeanReturnType"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   factory    =    initBeanFactory ( ConfigurationClassProcessingTests . ConfigWithNonSpecificReturnTypes . class )  ;", "assertEquals ( Object . class ,    factory . getType (  \" stringBean \"  )  )  ;", "assertFalse ( factory . isTypeMatch (  \" stringBean \"  ,    String . class )  )  ;", "String   stringBean    =    factory . getBean (  \" stringBean \"  ,    String . class )  ;", "assertEquals (  \" foo \"  ,    stringBean )  ;", "}", "METHOD_END"], "methodName": ["configWithObjectReturnType"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ac )  ;", "ac . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition (  . ConfigWithSetWithProviderImplementation . class )  )  ;", "ac . refresh (  )  ;", "assertSame ( ac . getBean (  \" customName \"  )  ,     . ConfigWithSetWithProviderImplementation . set )  ;", "}", "METHOD_END"], "methodName": ["configWithSetWithProviderImplementation"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithPrototypeBean . class ,     . AdaptiveInjectionPoints . class )  ;", "ctx . refresh (  )  ;", ". AdaptiveInjectionPoints   adaptive    =    ctx . getBean (  . AdaptiveInjectionPoints . class )  ;", "assertEquals (  \" adaptiveInjectionPoint 1  \"  ,    adaptive . adaptiveInjectionPoint 1  . getName (  )  )  ;", "assertEquals (  \" setAdaptiveInjectionPoint 2  \"  ,    adaptive . adaptiveInjectionPoint 2  . getName (  )  )  ;", "adaptive    =    ctx . getBean (  . AdaptiveInjectionPoints . class )  ;", "assertEquals (  \" adaptiveInjectionPoint 1  \"  ,    adaptive . adaptiveInjectionPoint 1  . getName (  )  )  ;", "assertEquals (  \" setAdaptiveInjectionPoint 2  \"  ,    adaptive . adaptiveInjectionPoint 2  . getName (  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["configurationWithAdaptivePrototypes"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithFunctionalRegistration . class )  ;", "ctx . refresh (  )  ;", "assertSame ( ctx . getBean (  \" spouse \"  )  ,    ctx . getBean ( TestBean . class )  . getSpouse (  )  )  ;", "assertEquals (  \" functional \"  ,    ctx . getBean ( NestedTestBean . class )  . getCompany (  )  )  ;", "}", "METHOD_END"], "methodName": ["configurationWithFunctionalRegistration"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   factory    =    initBeanFactory ( ConfigurationClassProcessingTests . ConfigWithNullReference . class )  ;", "TestBean   foo    =    factory . getBean (  \" foo \"  ,    TestBean . class )  ;", "assertTrue ( factory . getBean (  \" bar \"  )  . equals ( null )  )  ;", "assertNull ( foo . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["configurationWithNullReference"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithPostProcessor . class )  ;", "RootBeanDefinition   placeholderConfigurer    =    new   RootBeanDefinition ( PropertyPlaceholderConfigurer . class )  ;", "placeholderConfigurer . getPropertyValues (  )  . add (  \" properties \"  ,     \" myProp = myValue \"  )  ;", "ctx . registerBeanDefinition (  \" placeholderConfigurer \"  ,    placeholderConfigurer )  ;", "ctx . refresh (  )  ;", "TestBean   foo    =    ctx . getBean (  \" foo \"  ,    TestBean . class )  ;", "ITestBean   bar    =    ctx . getBean (  \" bar \"  ,    ITestBean . class )  ;", "ITestBean   baz    =    ctx . getBean (  \" baz \"  ,    ITestBean . class )  ;", "assertEquals (  \" foo - processed - myValue \"  ,    foo . getName (  )  )  ;", "assertEquals (  \" bar - processed - myValue \"  ,    bar . getName (  )  )  ;", "assertEquals (  \" baz - processed - myValue \"  ,    baz . getName (  )  )  ;", ". SpousyTestBean   listener    =    ctx . getBean (  \" listenerTestBean \"  ,     . SpousyTestBean . class )  ;", "assertTrue ( listener . refreshed )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["configurationWithPostProcessor"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   factory    =    initBeanFactory ( ConfigurationClassProcessingTests . ConfigWithPrototypeBean . class )  ;", "TestBean   foo    =    factory . getBean (  \" foo \"  ,    TestBean . class )  ;", "ITestBean   bar    =    factory . getBean (  \" bar \"  ,    ITestBean . class )  ;", "ITestBean   baz    =    factory . getBean (  \" baz \"  ,    ITestBean . class )  ;", "assertSame ( foo . getSpouse (  )  ,    bar )  ;", "assertNotSame ( bar . getSpouse (  )  ,    baz )  ;", "}", "METHOD_END"], "methodName": ["configurationWithPrototypeScopedBeans"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "AConfigUtils . registerAConfigProcessors ( ac )  ;", "ac . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( testClass )  )  ;", "ac . refresh (  )  ;", "assertSame ( testBeanSupplier . get (  )  ,    ac . getBean ( beanName )  )  ;", "exception . expect ( NoSuchBeanDefinitionException . class )  ;", "ac . getBean (  \" methodName \"  )  ;", "}", "METHOD_END"], "methodName": ["customBeanNameIsRespected"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "customBeanNameIsRespected ( ConfigurationClassProcessingTests . ConfigWithBeanWithCustomName . class ,     (  )     -  >    ConfigurationClassProcessingTests . ConfigWithBeanWithCustomName . testBean ,     \" customName \"  )  ;", "}", "METHOD_END"], "methodName": ["customBeanNameIsRespectedWhenConfiguredViaNameAttribute"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "customBeanNameIsRespected ( ConfigurationClassProcessingTests . ConfigWithBeanWithCustomNameConfiguredViaValueAttribute . class ,     (  )     -  >    ConfigurationClassProcessingTests . ConfigWithBeanWithCustomNameConfiguredViaValueAttribute . testBean ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["customBeanNameIsRespectedWhenConfiguredViaValueAttribute"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "for    ( Class <  ?  >    configClass    :    configClasses )     {", "String   configBeanName    =    configClass . getName (  )  ;", "factory . registerBeanDefinition ( configBeanName ,    new   RootBeanDefinition ( configClass )  )  ;", "}", "ostProcessor   ccpp    =    new   ostProcessor (  )  ;", "ccpp . postProcessBeanDefinitionRegistry ( factory )  ;", "ccpp . postProcessBeanFactory ( factory )  ;", "RequiredAnnotationBeanPostProcessor   rapp    =    new   RequiredAnnotationBeanPostProcessor (  )  ;", "rapp . setBeanFactory ( factory )  ;", "factory . addBeanPostProcessor ( rapp )  ;", "factory . freezeConfiguration (  )  ;", "return   factory ;", "}", "METHOD_END"], "methodName": ["initBeanFactory"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   factory    =    initBeanFactory ( ConfigurationClassProcessingTests . SimplestPossibleConfig . class )  ;", "String   stringBean    =    factory . getBean (  \" stringBean \"  ,    String . class )  ;", "assertEquals (  \" foo \"  ,    stringBean )  ;", "}", "METHOD_END"], "methodName": ["simplestPossibleConfig"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( BeanDefinitionParsingException . class )  ;", "initBeanFactory (  . ConfigWithFinalBean . class )  ;", "}", "METHOD_END"], "methodName": ["testFinalBeanMethod"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassProcessingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithValueFieldAndPlaceholderConfigurer . class )  ;", "System . setProperty (  \" test . name \"  ,     \" foo \"  )  ;", "ctx . refresh (  )  ;", "System . clearProperty (  \" test . name \"  )  ;", "TestBean   testBean    =    ctx . getBean ( TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["valueFieldsAreNotProcessedWhenPlaceholderConfigurerIsIntegrated"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassWithPlaceholderConfigurerBeanTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithValueField . class )  ;", "ctx . register (  . ConfigWithPlaceholderConfigurer . class )  ;", "System . setProperty (  \" test . name \"  ,     \" foo \"  )  ;", "ctx . refresh (  )  ;", "System . clearProperty (  \" test . name \"  )  ;", "TestBean   testBean    =    ctx . getBean ( TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["valueFieldsAreProcessedWhenPlaceholderConfigurerIsSegregated"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassWithPlaceholderConfigurerBeanTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithValueFieldAndStaticPlaceholderConfigurer . class )  ;", "System . setProperty (  \" test . name \"  ,     \" foo \"  )  ;", "ctx . refresh (  )  ;", "System . clearProperty (  \" test . name \"  )  ;", "TestBean   testBean    =    ctx . getBean ( TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["valueFieldsAreProcessedWhenStaticPlaceholderConfigurerIsIntegrated"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassWithPlaceholderConfigurerBeanTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithValueField . class )  ;", "ctx . register (  . ConfigWithPlaceholderConfigurer . class )  ;", "ctx . refresh (  )  ;", "TestBean   testBean    =    ctx . getBean ( TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["valueFieldsResolveToPlaceholderSpecifiedDefaultValuesWithPlaceholderConfigurer"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassWithPlaceholderConfigurerBeanTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ConfigWithValueField . class )  ;", "ctx . refresh (  )  ;", "TestBean   testBean    =    ctx . getBean ( TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["valueFieldsResolveToPlaceholderSpecifiedDefaultValuesWithoutPlaceholderConfigurer"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationClassWithPlaceholderConfigurerBeanTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . Config . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" customName \"  )  ,    is ( true )  )  ;", "TestBean   a    =    ctx . getBean (  \" a \"  ,    TestBean . class )  ;", "TestBean   b    =    ctx . getBean (  \" b \"  ,    TestBean . class )  ;", "assertThat ( b ,    sameInstance ( a . getSpouse (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["customConfigurationStereotype"], "fileName": "org.springframework.context.annotation.configuration.ConfigurationMetaAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" a \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessor . class )  )  ;", "ctx . registerBeanDefinition (  \" b \"  ,    new   RootBeanDefinition ( ConfigurationClassPostProcessor . class )  )  ;", "ctx . registerBeanDefinition (  \" myConfig \"  ,    new   RootBeanDefinition (  . Config . class )  )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.context.annotation.configuration.DuplicateConfigurationClassPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ImportFromBean . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" importAnnotationDetectionTests . ImportFromBean \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" testBean 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getBean (  \" testBean 1  \"  ,    TestBean . class )  . getName (  )  ,    is (  \"  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["importFromBean"], "fileName": "org.springframework.context.annotation.configuration.ImportAnnotationDetectionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . MultiMetaImportConfigWithLocalImport . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" testBean 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" testBean 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" testBean 3  \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["localAndMetaImportsAreProcessed"], "fileName": "org.springframework.context.annotation.configuration.ImportAnnotationDetectionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . MultiMetaImportConfigWithLocalImportWithBeanOverride . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" testBean 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" testBean 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . getBean (  \" testBean 2  \"  ,    TestBean . class )  . getName (  )  ,    is (  \"  2 a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["localImportIsProcessedLast"], "fileName": "org.springframework.context.annotation.configuration.ImportAnnotationDetectionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . MultiMetaImportConfig . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" testBean 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ctx . containsBean (  \" testBean 2  \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["multipleMetaImportsAreProcessed"], "fileName": "org.springframework.context.annotation.configuration.ImportAnnotationDetectionTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ImportResourceTests . ImportNonXmlResourceConfig . class )  ;", "assertTrue ( ctx . containsBean (  \" propertiesDeclaredBean \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["importNonXmlResource"], "fileName": "org.springframework.context.annotation.configuration.ImportResourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "PropertySource <  ?  >    propertySource    =    new   MapPropertySource (  \" test \"  ,    Collections .  < String ,    Object > singletonMap (  \" test \"  ,     \" springframework \"  )  )  ;", "ctx . getEnvironment (  )  . getPropertySources (  )  . addFirst ( propertySource )  ;", "ctx . register (  . ImportXmlConfig . class )  ;", "ctx . refresh (  )  ;", "assertTrue (  \" did   not   contain   xml - declared   bean \"  ,    ctx . containsBean (  \" xmlDeclaredBean \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["importWithPlaceholder"], "fileName": "org.springframework.context.annotation.configuration.ImportResourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ImportResourceTests . ImportXmlConfig . class )  ;", "assertTrue (  \" did   not   contain   java - declared   bean \"  ,    ctx . containsBean (  \" javaDeclaredBean \"  )  )  ;", "assertTrue (  \" did   not   contain   xml - declared   bean \"  ,    ctx . containsBean (  \" xmlDeclaredBean \"  )  )  ;", "TestBean   tb    =    ctx . getBean (  \" javaDeclaredBean \"  ,    TestBean . class )  ;", "assertEquals (  \" myName \"  ,    tb . getName (  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["importXml"], "fileName": "org.springframework.context.annotation.configuration.ImportResourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ImportResourceTests . FirstLevelSubConfig . class )  ;", "assertTrue ( ctx . containsBean (  \" xmlDeclaredBean \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["importXmlIsInheritedFromSuperclassDeclarations"], "fileName": "org.springframework.context.annotation.configuration.ImportResourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ImportResourceTests . SecondLevelSubConfig . class )  ;", "assertTrue (  \" failed   to   pick   up   second - level - declared   XML   bean \"  ,    ctx . containsBean (  \" secondLevelXmlDeclaredBean \"  )  )  ;", "assertTrue (  \" failed   to   pick   up   parent - declared   XML   bean \"  ,    ctx . containsBean (  \" xmlDeclaredBean \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["importXmlIsMergedFromSuperclassDeclarations"], "fileName": "org.springframework.context.annotation.configuration.ImportResourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ImportResourceTests . ImportXmlAutowiredConfig . class )  ;", "String   name    =    ctx . getBean (  \" xmlBeanName \"  ,    String . class )  ;", "assertThat ( name ,    equalTo (  \" xml . declared \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["importXmlWithAutowiredConfig"], "fileName": "org.springframework.context.annotation.configuration.ImportResourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ImportResourceTests . ImportXmlWithAopNamespaceConfig . class )  ;", "Object   bean    =    ctx . getBean (  \" proxiedXmlBean \"  )  ;", "assertTrue ( AopUtils . isAopProxy ( bean )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["importXmlWithNamespaceConfig"], "fileName": "org.springframework.context.annotation.configuration.ImportResourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ImportResourceTests . ImportXmlWithConfigurationClass . class )  ;", "assertTrue (  \" did   not   contain   java - declared   bean \"  ,    ctx . containsBean (  \" javaDeclaredBean \"  )  )  ;", "assertTrue (  \" did   not   contain   xml - declared   bean \"  ,    ctx . containsBean (  \" xmlDeclaredBean \"  )  )  ;", "TestBean   tb    =    ctx . getBean (  \" javaDeclaredBean \"  ,    TestBean . class )  ;", "assertEquals (  \" myName \"  ,    tb . getName (  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["importXmlWithOtherConfigurationClass"], "fileName": "org.springframework.context.annotation.configuration.ImportResourceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    processConfigurationClasses ( classes )  ;", "assertThat ( beanFactory . getBeanDefinitionCount (  )  ,    equalTo ( expectedCount )  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "for    ( Class <  ?  >    clazz    :    classes )     {", "beanFactory . getBean ( clazz )  ;", "}", "}", "METHOD_END"], "methodName": ["assertBeanDefinitionCount"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "for    ( Class <  ?  >    clazz    :    classes )     {", "beanFactory . registerBeanDefinition ( clazz . getSimpleName (  )  ,    new   RootBeanDefinition ( clazz )  )  ;", "}", "CClassPostProcessor   pp    =    new   CClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["processConfigurationClasses"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . B . class )  ;", "ctx . refresh (  )  ;", "System . out . println ( ctx . getBeanFactory (  )  )  ;", "assertThat ( ctx . getBeanNamesForType (  . B . class )  [  0  ]  ,    is (  \" config - b \"  )  )  ;", "assertThat ( ctx . getBeanNamesForType (  . A . class )  [  0  ]  ,    is (  \" config - a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["reproSpr9023"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     2  ;", "int   beansInClasses    =     2  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,     . OuterConfig . InnerConfig . class )  ;", "}", "METHOD_END"], "methodName": ["testImportAnnotationOnInnerClasses"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     3  ;", "int   beansInClasses    =     3  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,    ImportTests . WithMultipleArgumentsToImportAlass )  ;", "}", "METHOD_END"], "methodName": ["testImportAnnotationWithMultipleArguments"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( ImportTests . WithMultipleArgumentsThatWillCauseDuplication . class )  )  ;", "CClassPostProcessor   pp    =    new   CClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "assertThat ( beanFactory . getBeanDefinitionCount (  )  ,    equalTo (  4  )  )  ;", "assertThat ( beanFactory . getBean (  \" foo \"  ,    ITestBean . class )  . getName (  )  ,    equalTo (  \" foo 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testImportAnnotationWithMultipleArgumentsResultingInOverriddenBeanDefinition"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     4  ;", "int   beansInClasses    =     5  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,     . FirstLevel . class )  ;", "}", "METHOD_END"], "methodName": ["testImportAnnotationWithThreeLevelRecursion"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     2  ;", "int   beansInClasses    =     3  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,     . AppConfig . class )  ;", "}", "METHOD_END"], "methodName": ["testImportAnnotationWithTwoLevelRecursion"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     2  ;", "int   beansInClasses    =     0  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,     . ConfigAnnotated . class )  ;", "}", "METHOD_END"], "methodName": ["testImportNonConfigurationAnnotationClass"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     2  ;", "int   beansInClasses    =     2  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,    ImportTests . CWithImportAnnotation . class )  ;", "}", "METHOD_END"], "methodName": ["testProcessImports"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     2  ;", "int   beansInClasses    =     2  ;", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( ImportTests . CWithImportAnnotation . class . getName (  )  )  )  ;", "CClassPostProcessor   pp    =    new   CClassPostProcessor (  )  ;", "pp . postProcessBeanFactory ( beanFactory )  ;", "assertThat ( beanFactory . getBeanDefinitionCount (  )  ,    equalTo (  ( configClasses    +    beansInClasses )  )  )  ;", "}", "METHOD_END"], "methodName": ["testProcessImportsWithAsm"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     3  ;", "int   beansInClasses    =     3  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,    ImportTests . CWithImportAnnotation . class ,    ImportTests . OtherCWithImportAnnotation . class )  ;", "}", "METHOD_END"], "methodName": ["testProcessImportsWithDoubleImports"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     2  ;", "int   beansInClasses    =     2  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,    ImportTests . CithImportAnnotation . class ,    ImportTests . OtherCclass )  ;", "}", "METHOD_END"], "methodName": ["testProcessImportsWithExplicitOverridingAfter"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "int   configClasses    =     2  ;", "int   beansInClasses    =     2  ;", "assertBeanDefinitionCount (  ( configClasses    +    beansInClasses )  ,    ImportTests . OtherCclass ,    ImportTests . CithImportAnnotation . class )  ;", "}", "METHOD_END"], "methodName": ["testProcessImportsWithExplicitOverridingBefore"], "fileName": "org.springframework.context.annotation.configuration.ImportTests"}, {"methodBody": ["METHOD_START", "{", "this . context . register ( ImportWithConditionTests . ConditionalThenUnconditional . class )  ;", "this . context . refresh (  )  ;", "assertFalse ( this . context . containsBean (  \" beanTwo \"  )  )  ;", "assertTrue ( this . context . containsBean (  \" beanOne \"  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalThenUnconditional"], "fileName": "org.springframework.context.annotation.configuration.ImportWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "this . context . register ( ImportWithConditionTests . UnconditionalThenConditional . class )  ;", "this . context . refresh (  )  ;", "assertFalse ( this . context . containsBean (  \" beanTwo \"  )  )  ;", "assertTrue ( this . context . containsBean (  \" beanOne \"  )  )  ;", "}", "METHOD_END"], "methodName": ["unconditionalThenConditional"], "fileName": "org.springframework.context.annotation.configuration.ImportWithConditionTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( configClasses )  ;", ". Config   config    =    ctx . getBean (  . Config . class )  ;", "TestBean   testBean 1     =    config . autowiredConfig . testBean (  )  ;", "TestBean   testBean 2     =    config . autowiredConfig . testBean (  )  ;", "assertThat (  \" got   two   distinct   instances   of   testBean   when   singleton   scoping   was   expected \"  ,    testBean 1  ,    sameInstance ( testBean 2  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredConfigClassBeanMethodsRespectScoping"], "fileName": "org.springframework.context.annotation.configuration.ImportedConfigurationClassEnhancementTests"}, {"methodBody": ["METHOD_START", "{", "autowiredConfigClassBeanMethodsRespectScoping ( ImportedConfigurationClassEnhancementTests . ConfigThatDoesImport . class )  ;", "}", "METHOD_END"], "methodName": ["autowiredConfigClassBeanMethodsRespectScopingWhenImported"], "fileName": "org.springframework.context.annotation.configuration.ImportedConfigurationClassEnhancementTests"}, {"methodBody": ["METHOD_START", "{", "autowiredConfigClassBeanMethodsRespectScoping ( ImportedConfigurationClassEnhancementTests . ConfigThatDoesNotImport . class ,    ImportedConfigurationClassEnhancementTests . ConfigToBeAutowired . class )  ;", "}", "METHOD_END"], "methodName": ["autowiredConfigClassBeanMethodsRespectScopingWhenRegisteredViaConstructor"], "fileName": "org.springframework.context.annotation.configuration.ImportedConfigurationClassEnhancementTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( configClasses )  ;", ". Config   config    =    ctx . getBean (  . Config . class )  ;", "assertTrue (  \" autowired   config   class   has   not   been   enhanced \"  ,    ClassUtils . isCglibProxy ( config . autowiredConfig )  )  ;", "}", "METHOD_END"], "methodName": ["autowiredConfigClassIsEnhanced"], "fileName": "org.springframework.context.annotation.configuration.ImportedConfigurationClassEnhancementTests"}, {"methodBody": ["METHOD_START", "{", "autowiredConfigClassIsEnhanced ( ImportedConfigurationClassEnhancementTests . ConfigThatDoesImport . class )  ;", "}", "METHOD_END"], "methodName": ["autowiredConfigClassIsEnhancedWhenImported"], "fileName": "org.springframework.context.annotation.configuration.ImportedConfigurationClassEnhancementTests"}, {"methodBody": ["METHOD_START", "{", "autowiredConfigClassIsEnhanced ( ImportedConfigurationClassEnhancementTests . ConfigThatDoesNotImport . class ,    ImportedConfigurationClassEnhancementTests . ConfigToBeAutowired . class )  ;", "}", "METHOD_END"], "methodName": ["autowiredConfigClassIsEnhancedWhenRegisteredViaConstructor"], "fileName": "org.springframework.context.annotation.configuration.ImportedConfigurationClassEnhancementTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( ImportedConfigurationClassEnhancementTests . ConfigThatImportsNonConfigClass . class )  ;", "ImportedConfigurationClassEnhancementTests . ConfigThatImportsNonConfigClass   config    =    ctx . getBean ( ImportedConfigurationClassEnhancementTests . ConfigThatImportsNonConfigClass . class )  ;", "assertSame ( ctx . getBean ( TestBean . class )  ,    config . testBean )  ;", "}", "METHOD_END"], "methodName": ["importingNonConfigurationClassCausesBeanDefinitionParsingException"], "fileName": "org.springframework.context.annotation.configuration.ImportedConfigurationClassEnhancementTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Dependency (  )  ;", "}", "METHOD_END"], "methodName": ["someDependency"], "fileName": "org.springframework.context.annotation.configuration.MyConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   MyPostProcessor ( someDependency (  )  )  ;", "}", "METHOD_END"], "methodName": ["thePostProcessor"], "fileName": "org.springframework.context.annotation.configuration.MyConfig"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ReproConfig . class )  ;", "ctx . refresh (  )  ;", ". Foo   foo 1     =    ctx . getBean (  \" foo 1  \"  ,     . Foo . class )  ;", ". Foo   foo 2     =    ctx . getBean (  \" foo 2  \"  ,     . Foo . class )  ;", "ctx . getBean (  \" packagePrivateBar \"  ,     . Bar . class )  ;", "assertThat ( foo 1  . bar ,    not ( is ( foo 2  . bar )  )  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.context.annotation.configuration.PackagePrivateBeanMethodInheritanceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . WorkaroundConfig . class )  ;", "ctx . refresh (  )  ;", ". Foo   foo 1     =    ctx . getBean (  \" foo 1  \"  ,     . Foo . class )  ;", ". Foo   foo 2     =    ctx . getBean (  \" foo 2  \"  ,     . Foo . class )  ;", "ctx . getBean (  \" protectedBar \"  ,     . Bar . class )  ;", "assertThat ( foo 1  . bar ,    is ( foo 2  . bar )  )  ;", "}", "METHOD_END"], "methodName": ["workaround"], "fileName": "org.springframework.context.annotation.configuration.PackagePrivateBeanMethodInheritanceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "if    (  ( customScope )     !  =    null )     {", "beanFactory . registerScope (  . SCOPE ,    customScope )  ;", "}", "beanFactory . registerBeanDefinition (  \" config \"  ,    new   RootBeanDefinition ( configClass )  )  ;", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( beanFactory )  ;", "ctx . refresh (  )  ;", "return   ctx ;", "}", "METHOD_END"], "methodName": ["createContext"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "String   message    =     \" scope   is   ignored \"  ;", "Object   bean 1     =    ctx . getBean ( beanName )  ;", "Object   bean 2     =    ctx . getBean ( beanName )  ;", "assertSame ( message ,    bean 1  ,    bean 2  )  ;", "Object   bean 3     =    ctx . getBean ( beanName )  ;", "assertSame ( message ,    bean 1  ,    bean 3  )  ;", "customScope . createNewScope    =    true ;", "Object   newBean 1     =    ctx . getBean ( beanName )  ;", "assertNotSame ( message ,    bean 1  ,    newBean 1  )  ;", "Object   sameBean 1     =    ctx . getBean ( beanName )  ;", "assertSame ( message ,    newBean 1  ,    sameBean 1  )  ;", "customScope . createNewScope    =    true ;", "Object   newBean 2     =    ctx . getBean ( beanName )  ;", "assertNotSame ( message ,    newBean 1  ,    newBean 2  )  ;", "customScope . createNewScope    =    true ;", "Object   newBean 3     =    ctx . getBean ( beanName )  ;", "assertNotSame ( message ,    newBean 2  ,    newBean 3  )  ;", "}", "METHOD_END"], "methodName": ["genericTestScope"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "customScope    =    new   ScopingTests . CustomScope (  )  ;", "ctx    =    createContext ( ScopingTests . ScopedConfigurationClass . class )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "if    ( tx )     !  =    null )     {", "txlose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" scopedProxyInterface \"  ;", "Object   bean    =    ctx . getBean (  (  \" scopedTarget .  \"     +    beanName )  )  ;", "assertFalse (  ( bean   instanceof   ScopedObject )  )  ;", "}", "METHOD_END"], "methodName": ["testRawScopes"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "Object   beanAInScope    =    ctx . getBean (  \" scopedClass \"  )  ;", "Object   beanBInScope    =    ctx . getBean (  \" scopedInterface \"  )  ;", "assertNotSame ( beanAInScope ,    beanBInScope )  ;", "customScope . createNewScope    =    true ;", "Object   newBeanAInScope    =    ctx . getBean (  \" scopedClass \"  )  ;", "Object   newBeanBInScope    =    ctx . getBean (  \" scopedInterface \"  )  ;", "assertNotSame ( newBeanAInScope ,    newBeanBInScope )  ;", "assertNotSame ( newBeanAInScope ,    beanAInScope )  ;", "assertNotSame ( newBeanBInScope ,    beanBInScope )  ;", "}", "METHOD_END"], "methodName": ["testSameScopeOnDifferentBeans"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "genericTestScope (  \" scopedClass \"  )  ;", "}", "METHOD_END"], "methodName": ["testScopeOnClasses"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "genericTestScope (  \" scopedInterface \"  )  ;", "}", "METHOD_END"], "methodName": ["testScopeOnInterfaces"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   singleton    =     (  ( TestBean )     ( ctx . getBean (  \" singletonWithScopedInterfaceDep \"  )  )  )  ;", "ITestBean   spouse    =    singleton . getSpouse (  )  ;", "assertTrue (  \" scoped   bean   is   not   wrapped   by   the   scoped - proxy \"  ,     ( spouse   instanceof   ScopedObject )  )  ;", "String   beanName    =     \" scopedProxyInterface \"  ;", "String   scopedBeanName    =     \" scopedTarget .  \"     +    beanName ;", "assertEquals (  . flag ,    spouse . getName (  )  )  ;", "ITestBean   spouseFromBF    =     (  ( ITestBean )     ( ctx . getBean ( scopedBeanName )  )  )  ;", "assertEquals ( spouse . getName (  )  ,    spouseFromBF . getName (  )  )  ;", "assertNotSame ( spouse ,    spouseFromBF )  ;", "customScope . createNewScope    =    true ;", "spouseFromBF    =     (  ( ITestBean )     ( ctx . getBean ( scopedBeanName )  )  )  ;", "assertSame ( spouse . getName (  )  ,    spouseFromBF . getName (  )  )  ;", "assertNotSame ( spouse ,    spouseFromBF )  ;", "spouseFromBF    =     (  ( ITestBean )     ( ctx . getBean ( scopedBeanName )  )  )  ;", "assertSame ( spouse . getName (  )  ,    spouseFromBF . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedProxyConfiguration"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   singleton    =     (  ( TestBean )     ( ctx . getBean (  \" singletonWithScopedClassDep \"  )  )  )  ;", "ITestBean   spouse    =    singleton . getSpouse (  )  ;", "assertTrue (  \" scoped   bean   is   not   wrapped   by   the   scoped - proxy \"  ,     ( spouse   instanceof   ScopedObject )  )  ;", "String   beanName    =     \" scopedProxyClass \"  ;", "String   scopedBeanName    =     \" scopedTarget .  \"     +    beanName ;", "assertEquals (  . flag ,    spouse . getName (  )  )  ;", "TestBean   spouseFromBF    =     (  ( TestBean )     ( ctx . getBean ( scopedBeanName )  )  )  ;", "assertEquals ( spouse . getName (  )  ,    spouseFromBF . getName (  )  )  ;", "assertNotSame ( spouse ,    spouseFromBF )  ;", "customScope . createNewScope    =    true ;", ". flag    =     \" boo \"  ;", "spouseFromBF    =     (  ( TestBean )     ( ctx . getBean ( scopedBeanName )  )  )  ;", "assertSame ( spouse . getName (  )  ,    spouseFromBF . getName (  )  )  ;", "assertNotSame ( spouse ,    spouseFromBF )  ;", "spouseFromBF    =     (  ( TestBean )     ( ctx . getBean ( scopedBeanName )  )  )  ;", "assertSame ( spouse . getName (  )  ,    spouseFromBF . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedProxyConfigurationWithClasses"], "fileName": "org.springframework.context.annotation.configuration.ScopingTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( Spr 1  0  6  6  8 Tests . ChildConfig . class )  ;", "assertNotNull ( context . getBean ( Spr 1  0  6  6  8 Tests . MyComponent . class )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSelfInjectHierarchy"], "fileName": "org.springframework.context.annotation.configuration.Spr10668Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerScope (  \" myTestScope \"  ,    new    . MyTestScope (  )  )  ;", "context . register (  . MyTestConfiguration . class )  ;", "context . refresh (  )  ;", ". Foo   bean 1     =    context . getBean (  \" foo \"  ,     . Foo . class )  ;", ". Foo   bean 2     =    context . getBean (  \" foo \"  ,     . Foo . class )  ;", "assertThat ( bean 1  ,    sameInstance ( bean 2  )  )  ;", "assertThat (  . createCount ,    equalTo (  0  )  )  ;", "assertThat (  . scopeCount ,    equalTo (  0  )  )  ;", "bean 1  . getMessage (  )  ;", "assertThat (  . createCount ,    equalTo (  1  )  )  ;", "assertThat (  . scopeCount ,    equalTo (  1  )  )  ;", "bean 1  . getMessage (  )  ;", "assertThat (  . createCount ,    equalTo (  2  )  )  ;", "assertThat (  . scopeCount ,    equalTo (  2  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSpr10744"], "fileName": "org.springframework.context.annotation.configuration.Spr10744Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( Spr 1  2  5  2  6 Tests . TestContext . class )  ;", "Spr 1  2  5  2  6 Tests . CustomCondition   condition    =    ctx . getBean ( Spr 1  2  5  2  6 Tests . CustomCondition . class )  ;", "condition . setCondition ( true )  ;", "Spr 1  2  5  2  6 Tests . FirstService   firstService    =     (  ( Spr 1  2  5  2  6 Tests . FirstService )     ( ctx . getBean ( Spr 1  2  5  2  6 Tests . Service . class )  )  )  ;", "assertNotNull (  \" FirstService . dependency   is   null \"  ,    firstService . getDependency (  )  )  ;", "condition . setCondition ( false )  ;", "Spr 1  2  5  2  6 Tests . SecondService   secondService    =     (  ( Spr 1  2  5  2  6 Tests . SecondService )     ( ctx . getBean ( Spr 1  2  5  2  6 Tests . Service . class )  )  )  ;", "assertNotNull (  \" SecondService . dependency   is   null \"  ,    secondService . getDependency (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInjection"], "fileName": "org.springframework.context.annotation.configuration.Spr12526Tests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( MyConfig . class )  ;", "assertThat (  \" someDependency   was   not   post   processed \"  ,    ctx . getBeanFactory (  )  . getBeanDefinition (  \" someDependency \"  )  . getDescription (  )  ,    equalTo (  \" post   processed   by   MyPostProcessor \"  )  )  ;", "MyConfig   config    =    ctx . getBean ( MyConfig . class )  ;", "assertTrue (  \" Config   class   was   not   enhanced \"  ,    ClassUtils . isCglibProxy ( config )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.context.annotation.configuration.Spr7167Tests"}, {"methodBody": ["METHOD_START", "{", "return   new   PackagePrivateBeanMethodInheritanceTests . Bar (  )  ;", "}", "METHOD_END"], "methodName": ["packagePrivateBar"], "fileName": "org.springframework.context.annotation.configuration.a.BaseConfig"}, {"methodBody": ["METHOD_START", "{", "return   new   PackagePrivateBeanMethodInheritanceTests . Bar (  )  ;", "}", "METHOD_END"], "methodName": ["protectedBar"], "fileName": "org.springframework.context.annotation.configuration.a.BaseConfig"}, {"methodBody": ["METHOD_START", "{", "return   packagePrivateBar (  )  ;", "}", "METHOD_END"], "methodName": ["reproBar"], "fileName": "org.springframework.context.annotation.configuration.a.BaseConfig"}, {"methodBody": ["METHOD_START", "{", "return   protectedBar (  )  ;", "}", "METHOD_END"], "methodName": ["workaroundBar"], "fileName": "org.springframework.context.annotation.configuration.a.BaseConfig"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . scan (  \"  \"  )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.context.annotation.configuration.spr8955.Spr8955Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . HighLevelConfig . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean (  . LowLevelConfig . class )  . scanned ,    not ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withAsmAnnotationProcessing"], "fileName": "org.springframework.context.annotation.configuration.spr9031.Spr9031Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . LowLevelConfig . class )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean (  . LowLevelConfig . class )  . scanned ,    not ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withoutAsmAnnotationProcessing"], "fileName": "org.springframework.context.annotation.configuration.spr9031.Spr9031Tests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "AnnotatedBeanDefinitionReader   bdr    =    new   AnnotatedBeanDefinitionReader ( ac )  ;", "bdr . setScopeMetadataResolver ( new   Jsr 3  3  0 ScopeMetadataResolver (  )  )  ;", "bdr . registerBean ( Convertible . class )  ;", "bdr . registerBean ( DriversSeat . class ,    Drivers . class )  ;", "bdr . registerBean ( Seat . class ,    Primary . class )  ;", "bdr . registerBean ( V 8 Engine . class )  ;", "bdr . registerBean ( SpareTire . class ,     \" spare \"  )  ;", "bdr . registerBean ( Cupholder . class )  ;", "bdr . registerBean ( Tire . class ,    Primary . class )  ;", "bdr . registerBean ( FuelTank . class )  ;", "ac . refresh (  )  ;", "Car   car    =    ac . getBean ( Car . class )  ;", "return   Tck . testsFor ( car ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["suite"], "fileName": "org.springframework.context.annotation.jsr330.SpringAtInjectTck"}, {"methodBody": ["METHOD_START", "{", "return    \" myBean \"  ;", "}", "METHOD_END"], "methodName": ["myBean"], "fileName": "org.springframework.context.annotation.spr10546.ImportedConfig"}, {"methodBody": ["METHOD_START", "{", "return    \" myBean \"  ;", "}", "METHOD_END"], "methodName": ["myBean"], "fileName": "org.springframework.context.annotation.spr10546.ParentConfig"}, {"methodBody": ["METHOD_START", "{", "context    =    new   AnnotationConfigApplicationContext ( annotatedClasses )  ;", "assertThat ( context . getBean (  \" myBean \"  ,    String . class )  ,    equalTo (  \" myBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertLoadsMyBean"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( AEnclosingConfig . ChildConfig . class ,    AEnclosingConfig . class )  ;", "}", "METHOD_END"], "methodName": ["childConfigFirst"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( AEnclosingConfig . ChildConfig . class )  ;", "}", "METHOD_END"], "methodName": ["childConfigOnly"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "if    (  (     !  =    null )     {", "close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeContext"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( AEnclosingConfig . class ,    AEnclosingConfig . ChildConfig . class )  ;", "}", "METHOD_END"], "methodName": ["enclosingConfigFirstParentDefinesBean"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( Spr 1  0  5  4  6 Tests . AEnclosingWithComponentScanConfig . class ,    Spr 1  0  5  4  6 Tests . AEnclosingWithComponentScanConfig . ChildConfig . class )  ;", "}", "METHOD_END"], "methodName": ["enclosingConfigFirstParentDefinesBeanWithComponentScan"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( Spr 1  0  5  4  6 Tests . AEnclosingWithImportConfig . class ,    Spr 1  0  5  4  6 Tests . AEnclosingWithImportConfig . ChildConfig . class )  ;", "}", "METHOD_END"], "methodName": ["enclosingConfigFirstParentDefinesBeanWithImport"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( Spr 1  0  5  4  6 Tests . AEnclosingWithImportResourceConfig . class ,    Spr 1  0  5  4  6 Tests . AEnclosingWithImportResourceConfig . ChildConfig . class )  ;", "}", "METHOD_END"], "methodName": ["enclosingConfigFirstParentDefinesBeanWithImportResource"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "context    =    ctx ;", "ctx . scan ( AEnclosingConfig . class . getPackage (  )  . getName (  )  )  ;", "ctx . refresh (  )  ;", "assertThat ( context . getBean (  \" myBean \"  ,    String . class )  ,    equalTo (  \" myBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["enclosingConfigFirstParentDefinesBeanWithScanning"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( Spr 1  0  5  4  6 Tests . AEnclosingWithGrandparentConfig . class ,    Spr 1  0  5  4  6 Tests . AEnclosingWithGrandparentConfig . ChildConfig . class )  ;", "}", "METHOD_END"], "methodName": ["enclosingConfigFirstParentWithParentDefinesBean"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( AEnclosingConfig . class )  ;", "}", "METHOD_END"], "methodName": ["enclosingConfigOnly"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "assertLoadsMyBean ( Spr 1  0  5  4  6 Tests . ImportChildConfig . class ,    Spr 1  0  5  4  6 Tests . ChildConfig . class )  ;", "}", "METHOD_END"], "methodName": ["importChildConfigThenChildConfig"], "fileName": "org.springframework.context.annotation.spr10546.Spr10546Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( PropertySourcesPlaceholderConfigurer . class )  ;", "ctx . register (  . ImportConfiguration . class )  ;", "ctx . refresh (  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr12233"], "fileName": "org.springframework.context.annotation.spr12233.Spr12233Tests"}, {"methodBody": ["METHOD_START", "{", "Spr 1  2  3  3  4 Tests . TestImport . scanned    =    false ;", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . scan ( Spr 1  2  3  3  4 Tests . TestImport . class . getPackage (  )  . getName (  )  )  ;", "context . refresh (  )  ;", "context . getBean ( Spr 1  2  3  3  4 Tests . TestConfiguration . class )  ;", "}", "METHOD_END"], "methodName": ["shouldNotScanTwice"], "fileName": "org.springframework.context.annotation.spr12334.Spr12334Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . scan ( getClass (  )  . getPackage (  )  . getName (  )  )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  \" withNestedAnnotation \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.context.annotation.spr8761.Spr8761Tests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( Config . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.context.annotation.spr8808.Spr8808Tests"}, {"methodBody": ["METHOD_START", "{", "return    \" bar \"  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.springframework.context.annotation2.NamedStubDao2"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["nullInstance"], "fileName": "org.springframework.context.annotation4.FactoryMethodComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  \" privateInstance \"  ,     (  ( i )  +  +  )  )  ;", "}", "METHOD_END"], "methodName": ["privateInstance"], "fileName": "org.springframework.context.annotation4.FactoryMethodComponent"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  \" protectedInstance \"  ,     1  )  ;", "tb . setSpouse ( tb )  ;", "tb . setCountry ( country )  ;", "return   tb ;", "}", "METHOD_END"], "methodName": ["protectedInstance"], "fileName": "org.springframework.context.annotation4.FactoryMethodComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  \" publicInstance \"  )  ;", "}", "METHOD_END"], "methodName": ["publicInstance"], "fileName": "org.springframework.context.annotation4.FactoryMethodComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  \" publicInstance \"  )  ;", "}", "METHOD_END"], "methodName": ["publicInstance"], "fileName": "org.springframework.context.annotation4.FactoryMethodComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  \" requestScopedInstance \"  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["requestScopedInstance"], "fileName": "org.springframework.context.annotation4.FactoryMethodComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   DependencyBean (  )  ;", "}", "METHOD_END"], "methodName": ["secondInstance"], "fileName": "org.springframework.context.annotation4.FactoryMethodComponent"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  \" publicInstance \"  )  ;", "}", "METHOD_END"], "methodName": ["getPublicInstance"], "fileName": "org.springframework.context.annotation4.SimpleBean"}, {"methodBody": ["METHOD_START", "{", "return   new   TestBean (  )  ;", "}", "METHOD_END"], "methodName": ["testBean"], "fileName": "org.springframework.context.annotation6.ConfigForScanning"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" contextNamespaceHandlerTests - override . xml \"  ,    getClass (  )  )  ;", "Date   date    =     (  ( Date )     ( applicationContext . getBean (  \" date \"  )  )  )  ;", "Calendar   calendar    =    Calendar . getInstance (  )  ;", "calendar . setTime ( date )  ;", "assertEquals (  4  2  ,    calendar . get ( Calendar . MINUTE )  )  ;", "}", "METHOD_END"], "methodName": ["propertyOverride"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" contextNamespaceHandlerTests - replace . xml \"  ,    getClass (  )  )  ;", "assertEquals (  \" bar \"  ,    applicationContext . getBean (  \" string \"  )  )  ;", "assertEquals (  \" null \"  ,    applicationContext . getBean (  \" nullString \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholder"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockEnvironment   env    =    new   MockEnvironment (  )  . withProperty (  \" foo \"  ,     \" spam \"  )  ;", "GenericXmlApplicationContext   applicationContext    =    new   GenericXmlApplicationContext (  )  ;", "applicationContext . setEnvironment ( env )  ;", "applicationContext . load ( new   ClassPathResource (  \" c - simple . xml \"  ,    getClass (  )  )  )  ;", "applicationContext . refresh (  )  ;", "assertEquals (  \" spam \"  ,    applicationContext . getBean (  \" string \"  )  )  ;", "assertEquals (  \" none \"  ,    applicationContext . getBean (  \" fallback \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderEnvironmentProperties"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" contextNamespaceHandlerTests - replace - ignore . xml \"  ,    getClass (  )  )  ;", "assertEquals (  \"  $  { bar }  \"  ,    applicationContext . getBean (  \" string \"  )  )  ;", "assertEquals (  \" null \"  ,    applicationContext . getBean (  \" nullString \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderIgnored"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" contextNamespaceHandlerTests - location . xml \"  ,    getClass (  )  )  ;", "assertEquals (  \" bar \"  ,    applicationContext . getBean (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    applicationContext . getBean (  \" bar \"  )  )  ;", "assertEquals (  \" maps \"  ,    applicationContext . getBean (  \" spam \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderLocation"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" properties \"  ,     (  \" classpath *  :  / org / springframework / context / config / test -  *  . properties ,  \"     +     (  \" classpath *  :  / org / springframework / context / config / empty -  *  . properties ,  \"     +     \" classpath *  :  / org / springframework / context / config / missing -  *  . properties \"  )  )  )  ;", "try    {", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" c - location - placeholder . xml \"  ,    getClass (  )  )  ;", "assertEquals (  \" bar \"  ,    applicationContext . getBean (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    applicationContext . getBean (  \" bar \"  )  )  ;", "assertEquals (  \" maps \"  ,    applicationContext . getBean (  \" spam \"  )  )  ;", "}    finally    {", "System . clearProperty (  \" properties \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyPlaceholderLocationWithSystemPropertyForMultipleLocations"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" properties \"  ,     \" classpath *  :  / org / springframework / context / config / test -  *  . properties \"  )  ;", "try    {", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" c - location - placeholder . xml \"  ,    getClass (  )  )  ;", "assertEquals (  \" bar \"  ,    applicationContext . getBean (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    applicationContext . getBean (  \" bar \"  )  )  ;", "assertEquals (  \" maps \"  ,    applicationContext . getBean (  \" spam \"  )  )  ;", "}    finally    {", "System . clearProperty (  \" properties \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyPlaceholderLocationWithSystemPropertyForOneLocation"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" c - location - placeholder . xml \"  ,    getClass (  )  )  ;", "assertEquals (  \" bar \"  ,    applicationContext . getBean (  \" foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    applicationContext . getBean (  \" bar \"  )  )  ;", "assertEquals (  \" maps \"  ,    applicationContext . getBean (  \" spam \"  )  )  ;", "}    catch    ( FatalBeanException   ex )     {", "assertTrue (  (  ( ex . getRootCause (  )  )    instanceof   FileNotFoundException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyPlaceholderLocationWithSystemPropertyMissing"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   value    =    System . setProperty (  \" foo \"  ,     \" spam \"  )  ;", "try    {", "ApplicationContext   applicationContext    =    new   ClassPathXmlApplicationContext (  \" c - system . xml \"  ,    getClass (  )  )  ;", "assertEquals (  \" spam \"  ,    applicationContext . getBean (  \" string \"  )  )  ;", "assertEquals (  \" none \"  ,    applicationContext . getBean (  \" fallback \"  )  )  ;", "}    finally    {", "if    ( value    !  =    null )     {", "System . setProperty (  \" foo \"  ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["propertyPlaceholderSystemProperties"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "System . getProperties (  )  . remove (  \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.context.config.ContextNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  \" on \"  . equals ( value )  )     {", "return   true ;", "} else", "if    (  \" off \"  . equals ( value )  )     {", "return   false ;", "} else    {", "ClassLoader   cl    =    parserContext . getReaderContext (  )  . getBeanClassLoader (  )  ;", "return    ( cl    !  =    null )     &  &     (  ( cl . getResource ( weaving . AspectJWeavingEnabler . ASPECTJ _ AOP _ XML _ RESOURCE )  )     !  =    null )  ;", "}", "}", "METHOD_END"], "methodName": ["isAspectJWeavingEnabled"], "fileName": "org.springframework.context.config.LoadTimeWeaverBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . isPresent ( SpringConfiguredBeanDefinitionParser . BEAN _ CONFIGURER _ ASPECT _ CLASS _ NAME ,    beanClassLoader )  ;", "}", "METHOD_END"], "methodName": ["isBeanConfigurerAspectEnabled"], "fileName": "org.springframework.context.config.LoadTimeWeaverBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( MBeanServerBeanDefinitionParser . weblogicPresent )     {", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( JndiObjectFactoryBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" jndiName \"  ,     \" java : comp / env / jmx / runtime \"  )  ;", "return   bd ;", "} else", "if    ( MBeanServerBeanDefinitionParser . webspherePresent )     {", "return   new   RootBeanDefinition ( class )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["findServerForSpecialEnvironment"], "fileName": "org.springframework.context.config.MBeanServerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.context.conversionservice.Bar"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / context / conversionservice / conversionService . xml \"  )  ;", "TestClient   client    =    context . getBean (  \" testClient \"  ,    TestClient . class )  ;", "assertEquals (  2  ,    client . getBars (  )  . size (  )  )  ;", "assertEquals (  \" value 1  \"  ,    client . getBars (  )  . get (  0  )  . getValue (  )  )  ;", "assertEquals (  \" value 2  \"  ,    client . getBars (  )  . get (  1  )  . getValue (  )  )  ;", "assertTrue ( client . isBool (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConfigOk"], "fileName": "org.springframework.context.conversionservice.ConversionServiceContextConfigTests"}, {"methodBody": ["METHOD_START", "{", "return   bars ;", "}", "METHOD_END"], "methodName": ["getBars"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "return   resourceArray ;", "}", "METHOD_END"], "methodName": ["getResourceArray"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "return   resourceList ;", "}", "METHOD_END"], "methodName": ["getResourceList"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "return   resourceMap ;", "}", "METHOD_END"], "methodName": ["getResourceMap"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "return   stringList ;", "}", "METHOD_END"], "methodName": ["getStringList"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "return   bool ;", "}", "METHOD_END"], "methodName": ["isBool"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "this . bars    =    bars ;", "}", "METHOD_END"], "methodName": ["setBars"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "this . bool    =    bool ;", "}", "METHOD_END"], "methodName": ["setBool"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "this . resourceArray    =    resourceArray ;", "}", "METHOD_END"], "methodName": ["setResourceArray"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "this . resourceList    =    resourceList ;", "}", "METHOD_END"], "methodName": ["setResourceList"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "this . resourceMap    =    resourceMap ;", "}", "METHOD_END"], "methodName": ["setResourceMap"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "this . stringList    =    stringList ;", "}", "METHOD_END"], "methodName": ["setStringList"], "fileName": "org.springframework.context.conversionservice.TestClient"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractApplicationEventListenerTests . GenericTestEvent <  >  ( this ,    payload )  ;", "}", "METHOD_END"], "methodName": ["createGenericTestEvent"], "fileName": "org.springframework.context.event.AbstractApplicationEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   ResolvableType . forField (  . TestEvents . class . getField ( fieldName )  )  ;", "}    catch    ( NoSuchFieldException   e )     {", "throw   new   IllegalStateException (  (  (  \" No   such   field   on   Events    '  \"     +    fieldName )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getGenericApplicationEventType"], "fileName": "org.springframework.context.event.AbstractApplicationEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . retrievalMutex )     {", "return   this . defaultRetriever . geListeners (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getApplicationListeners"], "fileName": "org.springframework.context.event.AbstractApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "Object   source    =    event . getSource (  )  ;", "Class <  ?  >    sourceType    =     ( source    !  =    null )     ?    source . getClass (  )     :    null ;", ". ListenerCacheKey   cacheKey    =    new    . ListenerCacheKey ( eventType ,    sourceType )  ;", ". ListenerRetriever   retriever    =    this . retrieverCache . get ( cacheKey )  ;", "if    ( retriever    !  =    null )     {", "return   retriever . getApplicationListeners (  )  ;", "}", "if    (  (  ( this . beanClassLoader )     =  =    null )     |  |     (  ( ClassUtils . isCacheSafe ( event . getClass (  )  ,    this . beanClassLoader )  )     &  &     (  ( sourceType    =  =    null )     |  |     ( ClassUtils . isCacheSafe ( sourceType ,    this . beanClassLoader )  )  )  )  )     {", "synchronized ( this . retrievalMutex )     {", "retriever    =    this . retrieverCache . get ( cacheKey )  ;", "if    ( retriever    !  =    null )     {", "return   retriever . getApplicationListeners (  )  ;", "}", "retriever    =    new    . ListenerRetriever ( true )  ;", "Collection < ApplicationListener <  ?  >  >    listeners    =    retrieveApplicationListeners ( eventType ,    sourceType ,    retriever )  ;", "this . retrieverCache . put ( cacheKey ,    retriever )  ;", "return   listeners ;", "}", "} else    {", "return   retrieveApplicationListeners ( eventType ,    sourceType ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["getApplicationListeners"], "fileName": "org.springframework.context.event.AbstractApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )     =  =    null )     {", "throw   new   IllegalStateException (  (  \"    cannot   retrieve   listener   beans    \"     +     \" because   it   is   not   associated   with   a   BeanFactory \"  )  )  ;", "}", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.context.event.AbstractApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "LinkedList < ApplicationListener <  ?  >  >    allListeners    =    new   LinkedList <  >  (  )  ;", "Set < ApplicationListener <  ?  >  >    listeners ;", "Set < String >    listenerBeans ;", "synchronized ( this . retrievalMutex )     {", "listeners    =    new   LinkedHashSet <  >  ( this . defaultRetriever . applicationListeners )  ;", "listenerBeans    =    new   LinkedHashSet <  >  ( this . defaultRetriever . applicationListenerBeans )  ;", "}", "for    ( ApplicationListener <  ?  >    listener    :    listeners )     {", "if    ( supportsEvent ( listener ,    eventType ,    sourceType )  )     {", "if    ( retriever    !  =    null )     {", "retriever . applicationListeners . add ( listener )  ;", "}", "allListeners . add ( listener )  ;", "}", "}", "if    (  !  ( listenerBeans . isEmpty (  )  )  )     {", "BeanFactory   beanFactory    =    getBeanFactory (  )  ;", "for    ( String   listenerBeanName    :    listenerBeans )     {", "try    {", "Class <  ?  >    listenerType    =    beanFactory . getType ( listenerBeanName )  ;", "if    (  ( listenerType    =  =    null )     |  |     ( supportsEvent ( listenerType ,    eventType )  )  )     {", "ApplicationListener <  ?  >    listener    =    beanFactory . getBean ( listenerBeanName ,    ApplicationListener . class )  ;", "if    (  (  !  ( allListeners . contains ( listener )  )  )     &  &     ( supportsEvent ( listener ,    eventType ,    sourceType )  )  )     {", "if    ( retriever    !  =    null )     {", "retriever . applicationListenerBeans . add ( listenerBeanName )  ;", "}", "allListeners . add ( listener )  ;", "}", "}", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "}", "AnnotationAwareOrderComparator . sort ( allListeners )  ;", "return   allListeners ;", "}", "METHOD_END"], "methodName": ["retrieveApplicationListeners"], "fileName": "org.springframework.context.event.AbstractApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "if    (  ( GenericApplicationListener . class . isAssignableFrom ( listenerType )  )     |  |     ( SmartApplicationListener . class . isAssignableFrom ( listenerType )  )  )     {", "return   true ;", "}", "ResolvableType   declaredEventType    =    GenericApplicationListenerAdapter . resolveDeclaredEventType ( listenerType )  ;", "return    ( declaredEventType    =  =    null )     |  |     ( declaredEventType . isAssignableFrom ( eventType )  )  ;", "}", "METHOD_END"], "methodName": ["supportsEvent"], "fileName": "org.springframework.context.event.AbstractApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationListener   smartListener    =     ( listener   instanceof   GenericApplicationListener )     ?     (  ( GenericApplicationListener )     ( listener )  )     :    new   GenericApplicationListenerAdapter ( listener )  ;", "return    ( smartListener . supportsEventType ( eventType )  )     &  &     ( smartListener . supportsSourceType ( sourceType )  )  ;", "}", "METHOD_END"], "methodName": ["supportsEvent"], "fileName": "org.springframework.context.event.AbstractApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class ,    AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,    new   String [  ]  {     \" first \"  ,     \" second \"     }  )  ;", "AnnotationDrivenEventListenerTests . ReplyEventListener   replyEventListener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertNoEventReceived ( replyEventListener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( replyEventListener ,    event )  ;", "this . eventCollector . assertEvent ( listener ,     \" first \"  ,     \" second \"  )  ;", "this . eventCollector . assertTotalEventsCount (  3  )  ;", "}", "METHOD_END"], "methodName": ["arrayReply"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "loadAsync ( AnnotationDrivenEventListenerTests . AsyncEventListener . class )  ;", "String   threadName    =    Thread . currentThread (  )  . getName (  )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,    threadName )  ;", "AnnotationDrivenEventListenerTests . AsyncEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . AsyncEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent ( event )  ;", "this . countDownLatch . await (  2  ,    TimeUnit . SECONDS )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["asyncProcessingApplied"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "doLoad ( AnnotationDrivenEventListenerTests . AsyncConfigurationWithInterfaces . class ,    AnnotationDrivenEventListenerTests . SimpleProxyTestBean . class )  ;", "String   threadName    =    Thread . currentThread (  )  . getName (  )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,    threadName )  ;", "AnnotationDrivenEventListenerTests . SimpleService   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . SimpleService . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent ( event )  ;", "this . countDownLatch . await (  2  ,    TimeUnit . SECONDS )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["asyncProcessingAppliedWithInterfaceProxy"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "doLoad ( AnnotationDrivenEventListenerTests . AsyncConfigurationWithInterfaces . class ,    AnnotationDrivenEventListenerTests . ScopedProxyTestBean . class )  ;", "String   threadName    =    Thread . currentThread (  )  . getName (  )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,    threadName )  ;", "AnnotationDrivenEventListenerTests . SimpleService   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . SimpleService . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent ( event )  ;", "this . countDownLatch . await (  2  ,    TimeUnit . SECONDS )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["asyncProcessingAppliedWithScopedProxy"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this    !  =    null )     {", "thisclose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeContext"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class ,    AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "Set < Object >    replies    =    new   LinkedHashSet <  >  (  )  ;", "replies . add (  \" first \"  )  ;", "replies . add (  4 L )  ;", "replies . add (  \" third \"  )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,    replies )  ;", "AnnotationDrivenEventListenerTests . ReplyEventListener   replyEventListener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertNoEventReceived ( replyEventListener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( replyEventListener ,    event )  ;", "this . eventCollector . assertEvent ( listener ,     \" first \"  ,     \" third \"  )  ;", "this . eventCollector . assertTotalEventsCount (  3  )  ;", "}", "METHOD_END"], "methodName": ["collectionReply"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class ,    AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,    Arrays . asList ( null ,     \" test \"  )  )  ;", "AnnotationDrivenEventListenerTests . ReplyEventListener   replyEventListener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertNoEventReceived ( replyEventListener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( replyEventListener ,    event )  ;", "this . eventCollector . assertEvent ( listener ,     \" test \"  )  ;", "this . eventCollector . assertTotalEventsCount (  2  )  ;", "}", "METHOD_END"], "methodName": ["collectionReplyNullValue"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "long   maxLong    =    Long . MAX _ VALUE ;", "load (  . ConditionalEventListener . class )  ;", "TestEvent   event    =    new   TestEvent ( this ,     \" KO \"  )  ;", ". TestEventListener   listener    =    this . context . getBean (  . ConditionalEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertTotalEventsCount (  0  )  ;", "this . context . publishEvent (  \" KO \"  )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertTotalEventsCount (  0  )  ;", "this . context . publishEvent ( maxLong )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertTotalEventsCount (  0  )  ;", "this . context . publishEvent (  2  4  .  0  )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertTotalEventsCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["conditionDoesNotMatch"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "validateConditionMatch ( AnnotationDrivenEventListenerTests . ConditionalEventListener . class )  ;", "}", "METHOD_END"], "methodName": ["conditionMatch"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "validateConditionMatch ( AnnotationDrivenEventListenerTests . ConditionalEventListener . class ,    MethodValidationPostProcessor . class )  ;", "}", "METHOD_END"], "methodName": ["conditionMatchWithProxy"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . ContextEventListener . class )  ;", "AnnotationDrivenEventListenerTests . ContextEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ContextEventListener . class )  ;", "List < Object >    events    =    this . eventCollector . getEvents ( listener )  ;", "assertEquals (  \" Wrong   number   of   initial   context   events \"  ,     1  ,    events . size (  )  )  ;", "assertEquals ( ContextRefreshedEvent . class ,    events . get (  0  )  . getClass (  )  )  ;", "this . context . stop (  )  ;", "List < Object >    eventsAfterStop    =    this . eventCollector . getEvents ( listener )  ;", "assertEquals (  \" Wrong   number   of   context   events   on   shutdown \"  ,     2  ,    eventsAfterStop . size (  )  )  ;", "assertEquals ( ContextStoppedEvent . class ,    eventsAfterStop . get (  1  )  . getClass (  )  )  ;", "this . eventCollector . assertTotalEventsCount (  2  )  ;", "}", "METHOD_END"], "methodName": ["contextEventsAreReceived"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( classes )  ;", "this . eventCollector    =    ctx . getBean ( EventCollector . class )  ;", "this . countDownLatch    =    ctx . getBean ( CountDownLatch . class )  ;", "this . context    =    ctx ;", "}", "METHOD_END"], "methodName": ["doLoad"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . AnnotatedProxyTestBean . class )  ;", "AnnotationDrivenEventListenerTests . AnnotatedSimpleService   proxy    =    this . context . getBean ( AnnotationDrivenEventListenerTests . AnnotatedSimpleService . class )  ;", "assertTrue (  \" bean   should   be   a   proxy \"  ,     ( proxy   instanceof   Advised )  )  ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "this . context . publishEvent ( new   ContextRefreshedEvent ( this . context )  )  ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "TestEvent   event    =    new   TestEvent (  )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( proxy . getId (  )  ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["eventListenerWorksWithAnnotatedInterfaceProxy"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . CglibProxyTestBean . class )  ;", "AnnotationDrivenEventListenerTests . CglibProxyTestBean   proxy    =    this . context . getBean ( AnnotationDrivenEventListenerTests . CglibProxyTestBean . class )  ;", "assertTrue (  \" bean   should   be   a   cglib   proxy \"  ,    AopUtils . isCglibProxy ( proxy )  )  ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "this . context . publishEvent ( new   ContextRefreshedEvent ( this . context )  )  ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "TestEvent   event    =    new   TestEvent (  )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( proxy . getId (  )  ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["eventListenerWorksWithCglibProxy"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . CustomScopeTestBean . class )  ;", "AnnotationDrivenEventListenerTests . CustomScope   customScope    =    new   AnnotationDrivenEventListenerTests . CustomScope (  )  ;", "this . context . getBeanFactory (  )  . registerScope (  \" custom \"  ,    customScope )  ;", "AnnotationDrivenEventListenerTests . CustomScopeTestBean   proxy    =    this . context . getBean ( AnnotationDrivenEventListenerTests . CustomScopeTestBean . class )  ;", "assertTrue (  \" bean   should   be   a   cglib   proxy \"  ,    AopUtils . isCglibProxy ( proxy )  )  ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "this . context . publishEvent ( new   ContextRefreshedEvent ( this . context )  )  ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "customScope . active    =    false ;", "this . context . publishEvent ( new   ContextRefreshedEvent ( this . context )  )  ;", "customScope . active    =    true ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "TestEvent   event    =    new   TestEvent (  )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( proxy . getId (  )  ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "try    {", "customScope . active    =    false ;", "this . context . publishEvent ( new   TestEvent (  )  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["eventListenerWorksWithCustomScope"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . ScopedProxyTestBean . class )  ;", "AnnotationDrivenEventListenerTests . SimpleService   proxy    =    this . context . getBean ( AnnotationDrivenEventListenerTests . SimpleService . class )  ;", "assertTrue (  \" bean   should   be   a   proxy \"  ,     ( proxy   instanceof   Advised )  )  ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "this . context . publishEvent ( new   ContextRefreshedEvent ( this . context )  )  ;", "this . eventCollector . assertNoEventReceived ( proxy . getId (  )  )  ;", "TestEvent   event    =    new   TestEvent (  )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( proxy . getId (  )  ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["eventListenerWorksWithSimpleInterfaceProxy"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "loadAsync ( AnnotationDrivenEventListenerTests . ExceptionEventListener . class )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,     \" fail \"  )  ;", "AnnotationDrivenEventListenerTests . ExceptionEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ExceptionEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent ( event )  ;", "this . countDownLatch . await (  2  ,    TimeUnit . SECONDS )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["exceptionNotPropagatedWithAsync"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . ExceptionEventListener . class )  ;", "TestEvent   event    =    new   TestEvent ( this ,     \" fail \"  )  ;", "AnnotationDrivenEventListenerTests . ExceptionEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ExceptionEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "try    {", "this . context . publishEvent ( event )  ;", "fail (  \" An   exception   should   have   thrown \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "assertEquals (  \" Wrong   exception \"  ,     \" Test   exception \"  ,    e . getMessage (  )  )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["exceptionPropagated"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "return   context . getBean ( EventCollector . class )  ;", "}", "METHOD_END"], "methodName": ["getEventCollector"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . GenericEventListener . class )  ;", "AnnotationDrivenEventListenerTests . GenericEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . GenericEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent (  \" TEST \"  )  ;", "this . eventCollector . assertEvent ( listener ,     \" TEST \"  )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithGenericApplicationEvent"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent (  1  2  3 L )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertTotalEventsCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithNonMatchingPayload"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . ResolvableTypeEventListener . class )  ;", "AnnotationDrivenEventListenerTests . ResolvableTypeEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ResolvableTypeEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "GenericEventPojo < String >    event    =    new   GenericEventPojo <  >  (  \" TEST \"  )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithResolvableTypeEvent"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . ResolvableTypeEventListener . class )  ;", "AnnotationDrivenEventListenerTests . ResolvableTypeEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ResolvableTypeEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "GenericEventPojo < Long >    event    =    new   GenericEventPojo <  >  (  1  2  3 L )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertTotalEventsCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithResolvableTypeEventWrongGeneric"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent (  \" test \"  )  ;", "this . eventCollector . assertEvent ( listener ,     \" test \"  )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithSimplePayload"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . EventOnPostConstruct . class ,    AnnotationDrivenEventListenerTests . OrderedTestListener . class )  ;", "AnnotationDrivenEventListenerTests . OrderedTestListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . OrderedTestListener . class )  ;", "assertThat ( listener . order ,    contains (  \" first \"  ,     \" second \"  ,     \" third \"  )  )  ;", "}", "METHOD_END"], "methodName": ["listenersReceiveEarlyEvents"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    allClasses    =    new   ArrayList <  >  (  )  ;", "allClasses . add (  . BasicConfiguration . class )  ;", "allClasses . addAll ( Arrays . asList ( classes )  )  ;", "doLoad ( allClasses . toArray ( new   Class <  ?  >  [ allClasses . size (  )  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    allClasses    =    new   ArrayList <  >  (  )  ;", "allClasses . add (  . AsyncConfiguration . class )  ;", "allClasses . addAll ( Arrays . asList ( classes )  )  ;", "doLoad ( allClasses . toArray ( new   Class <  ?  >  [ allClasses . size (  )  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["loadAsync"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . MetaAnnotationListenerTestBean . class )  ;", "AnnotationDrivenEventListenerTests . MetaAnnotationListenerTestBean   bean    =    this . context . getBean ( AnnotationDrivenEventListenerTests . MetaAnnotationListenerTestBean . class )  ;", "this . eventCollector . assertNoEventReceived ( bean )  ;", "TestEvent   event    =    new   TestEvent (  )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( bean ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["metaAnnotationIsDiscovered"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   failingContext    =    new   AnnotationConfigApplicationContext (  )  ;", "failingContext . register (  . BasicConfiguration . class ,     . InvalidMethodSignatureEventListener . class )  ;", "this . thrown . expect ( BeanInitializationException . class )  ;", "this . thrown . expectMessage (  . InvalidMethodSignatureEventListener . class . getName (  )  )  ;", "this . thrown . expectMessage (  \" cannotBeCalled \"  )  ;", "failingContext . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["methodSignatureNoEvent"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class ,    AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,    null )  ;", "AnnotationDrivenEventListenerTests . ReplyEventListener   replyEventListener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertNoEventReceived ( replyEventListener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( replyEventListener ,    event )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["nullReplyIgnored"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . OrderedTestListener . class )  ;", "AnnotationDrivenEventListenerTests . OrderedTestListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . OrderedTestListener . class )  ;", "assertTrue ( listener . order . isEmpty (  )  )  ;", "this . context . publishEvent (  \" whatever \"  )  ;", "assertThat ( listener . order ,    contains (  \" first \"  ,     \" second \"  ,     \" third \"  )  )  ;", "}", "METHOD_END"], "methodName": ["orderedListeners"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "load (  . CglibProxyWithPrivateMethod . class )  ;", "fail (  \" Should   have   thrown   BeanInitializationException \"  )  ;", "}    catch    ( BeanInitializationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["privateMethodOnCglibProxyFails"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class ,    AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,     \" String \"  )  ;", "AnnotationDrivenEventListenerTests . ReplyEventListener   replyEventListener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertNoEventReceived ( replyEventListener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( replyEventListener ,    event )  ;", "this . eventCollector . assertEvent ( listener ,     \" String \"  )  ;", "this . eventCollector . assertTotalEventsCount (  2  )  ;", "}", "METHOD_END"], "methodName": ["replyWithPayload"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "TestEvent   event    =    new   TestEvent ( this ,     \" test \"  )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "this . eventCollector . clear (  )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["simpleEventJavaConfig"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / context / event / simple - event - configuration . xml \"  )  ;", "TestEvent   event    =    new   TestEvent ( this ,     \" test \"  )  ;", ". TestEventListener   listener    =    this . context . getBean (  . TestEventListener . class )  ;", "this . eventCollector    =    getEventCollector ( this . context )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["simpleEventXmlConfig"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( AnnotationDrivenEventListenerTests . TestEventListener . class ,    AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnotherTestEvent   event    =    new   AnotherTestEvent ( this ,     \" dummy \"  )  ;", "AnnotationDrivenEventListenerTests . ReplyEventListener   replyEventListener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . ReplyEventListener . class )  ;", "AnnotationDrivenEventListenerTests . TestEventListener   listener    =    this . context . getBean ( AnnotationDrivenEventListenerTests . TestEventListener . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . eventCollector . assertNoEventReceived ( replyEventListener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( replyEventListener ,    event )  ;", "this . eventCollector . assertEvent ( listener ,    new   TestEvent ( replyEventListener ,    event . getId (  )  ,     \" dummy \"  )  )  ;", "this . eventCollector . assertTotalEventsCount (  2  )  ;", "}", "METHOD_END"], "methodName": ["simpleReply"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "long   timestamp    =    System . currentTimeMillis (  )  ;", "load ( classes )  ;", "TestEvent   event    =    new   TestEvent ( this ,     \" OK \"  )  ;", ". ConditionalEventInterface   listener    =    this . context . getBean (  . ConditionalEventInterface . class )  ;", "this . eventCollector . assertNoEventReceived ( listener )  ;", "this . context . publishEvent ( event )  ;", "this . eventCollector . assertEvent ( listener ,    event )  ;", "this . eventCollector . assertTotalEventsCount (  1  )  ;", "this . context . publishEvent (  \" OK \"  )  ;", "this . eventCollector . assertEvent ( listener ,    event ,     \" OK \"  )  ;", "this . eventCollector . assertTotalEventsCount (  2  )  ;", "this . context . publishEvent (  \" NOT   OK \"  )  ;", "this . eventCollector . assertTotalEventsCount (  2  )  ;", "this . context . publishEvent ( timestamp )  ;", "this . eventCollector . assertEvent ( listener ,    event ,     \" OK \"  ,    timestamp )  ;", "this . eventCollector . assertTotalEventsCount (  3  )  ;", "this . context . publishEvent (  4  2  .  0  )  ;", "this . eventCollector . assertEvent ( listener ,    event ,     \" OK \"  ,    timestamp ,     4  2  .  0  )  ;", "this . eventCollector . assertTotalEventsCount (  4  )  ;", "}", "METHOD_END"], "methodName": ["validateConditionMatch"], "fileName": "org.springframework.context.event.AnnotationDrivenEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ApplicationContext )     ( getSource (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.context.event.ApplicationContextEvent"}, {"methodBody": ["METHOD_START", "{", "final   Set < ApplicationContextEventTests . MyEvent >    seenEvents    =    new   HashSet <  >  (  )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . addApplicationListener ( new   ApplicationListener < ApplicationContextEventTests . MyEvent >  (  )     {", "@ Override", "public   void   onApplicationEvent ( ApplicationContextEventTests . MyEvent   event )     {", "seenEvents . add ( event )  ;", "}", "}  )  ;", "context . refresh (  )  ;", "ApplicationContextEventTests . MyEvent   event 1     =    new   ApplicationContextEventTests . MyEvent ( context )  ;", "context . publishEvent ( event 1  )  ;", "context . publishEvent ( new   ApplicationContextEventTests . MyOtherEvent ( context )  )  ;", "ApplicationContextEventTests . MyEvent   event 2     =    new   ApplicationContextEventTests . MyEvent ( context )  ;", "context . publishEvent ( event 2  )  ;", "assertSame (  2  ,    seenEvents . size (  )  )  ;", "assertTrue ( seenEvents . contains ( event 1  )  )  ;", "assertTrue ( seenEvents . contains ( event 2  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["anonymousClassAsListener"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" listener \"  ,    new   RootBeanDefinition ( BeanThatListens . class )  )  ;", "context . registerBeanDefinition (  \" messageSource \"  ,    new   RootBeanDefinition ( StaticMessageSource . class )  )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    new   RootBeanDefinition (  . EventPublishingBeanPostProcessor . class )  )  ;", "context . refresh (  )  ;", "context . publishEvent ( new    . MyEvent ( this )  )  ;", "BeanThatListens   listener    =    context . getBean ( BeanThatListens . class )  ;", "assertEquals (  4  ,    listener . getEventCount (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["beanPostProcessorPublishesEvents"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "RootBeanDefinition   listenerDef    =    new   RootBeanDefinition ( TestBean . class )  ;", "listenerDef . getPropertyValues (  )  . add (  \" friends \"  ,    new   RootBeanDefinition ( BeanThatListens . class )  )  ;", "context . registerBeanDefinition (  \" listener \"  ,    listenerDef )  ;", "context . refresh (  )  ;", "context . publishEvent ( new    . MyEvent ( this )  )  ;", "context . publishEvent ( new    . MyEvent ( this )  )  ;", "TestBean   listener    =    context . getBean ( TestBean . class )  ;", "assertEquals (  3  ,     (  ( BeanThatListens )     ( listener . getFriends (  )  . iterator (  )  . next (  )  )  )  . getEventCount (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["innerBeanAsListener"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "final   Set < ApplicationContextEventTests . MyEvent >    seenEvents    =    new   HashSet <  >  (  )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "ApplicationListener < ApplicationContextEventTests . MyEvent >    listener    =    seenEvents :  : add ;", "context . addApplicationListener ( listener )  ;", "context . refresh (  )  ;", "ApplicationContextEventTests . MyEvent   event 1     =    new   ApplicationContextEventTests . MyEvent ( context )  ;", "context . publishEvent ( event 1  )  ;", "context . publishEvent ( new   ApplicationContextEventTests . MyOtherEvent ( context )  )  ;", "ApplicationContextEventTests . MyEvent   event 2     =    new   ApplicationContextEventTests . MyEvent ( context )  ;", "context . publishEvent ( event 2  )  ;", "assertSame (  2  ,    seenEvents . size (  )  )  ;", "assertTrue ( seenEvents . contains ( event 1  )  )  ;", "assertTrue ( seenEvents . contains ( event 2  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["lambdaAsListener"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "final   Set < ApplicationContextEventTests . MyEvent >    seenEvents    =    new   HashSet <  >  (  )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "SimpleApplicationEventMulticaster   multicaster    =    new   SimpleApplicationEventMulticaster (  )  ;", "multicaster . setErrorHandler ( ReflectionUtils :  : rethrowRuntimeException )  ;", "context . getBeanFactory (  )  . registerSingleton ( StaticApplicationContext . APPLICATION _ EVENT _ MULTICASTER _ BEAN _ NAME ,    multicaster )  ;", "ApplicationListener < ApplicationContextEventTests . MyEvent >    listener    =    seenEvents :  : add ;", "context . addApplicationListener ( listener )  ;", "context . refresh (  )  ;", "ApplicationContextEventTests . MyEvent   event 1     =    new   ApplicationContextEventTests . MyEvent ( context )  ;", "context . publishEvent ( event 1  )  ;", "context . publishEvent ( new   ApplicationContextEventTests . MyOtherEvent ( context )  )  ;", "ApplicationContextEventTests . MyEvent   event 2     =    new   ApplicationContextEventTests . MyEvent ( context )  ;", "context . publishEvent ( event 2  )  ;", "assertSame (  2  ,    seenEvents . size (  )  )  ;", "assertTrue ( seenEvents . contains ( event 1  )  )  ;", "assertTrue ( seenEvents . contains ( event 2  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["lambdaAsListenerWithErrorHandler"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "ApplicationListener < ApplicationEvent >    listener    =     (    event )     -  >     {", "throw   new   ClassCastException ( event . getClass (  )  . getName (  )  )  ;", "}  ;", "context . addApplicationListener ( listener )  ;", "context . refresh (  )  ;", "context . publishEvent ( new    . MyEvent ( context )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["lambdaAsListenerWithJava8StyleClassCastMessage"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "ApplicationListener < ApplicationEvent >    listener    =     (    event )     -  >     {", "throw   new   ClassCastException (  (  \" spring . context /  \"     +     ( event . getClass (  )  . getName (  )  )  )  )  ;", "}  ;", "context . addApplicationListener ( listener )  ;", "context . refresh (  )  ;", "context . publishEvent ( new    . MyEvent ( context )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["lambdaAsListenerWithJava9StyleClassCastMessage"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . registerBeanDefinition (  \" broadcaster \"  ,    new   RootBeanDefinition ( BeanThatBroadcasts . class )  )  ;", "RootBeanDefinition   listenerDef    =    new   RootBeanDefinition ( BeanThatListens . class )  ;", "listenerDef . getConstructorArgumentValues (  )  . addGenericArgumentValue ( new   RuntimeBeanReference (  \" broadcaster \"  )  )  ;", "context . registerBeanDefinition (  \" listener \"  ,    listenerDef )  ;", "context . refresh (  )  ;", "BeanThatBroadcasts   broadcaster    =    context . getBean (  \" broadcaster \"  ,    BeanThatBroadcasts . class )  ;", "context . publishEvent ( new    . MyEvent ( context )  )  ;", "assertEquals (  \" The   event   was   not   received   by   the   listener \"  ,     2  ,    broadcaster . receivedCount )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["listenerAndBroadcasterWithCircularReference"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . registerBeanDefinition (  \" listener 1  \"  ,    new   RootBeanDefinition (  . MyOrderedListener 1  . class )  )  ;", "RootBeanDefinition   listener 2     =    new   RootBeanDefinition (  . MyOrderedListener 2  . class )  ;", "listener 2  . getConstructorArgumentValues (  )  . addGenericArgumentValue ( new   RuntimeBeanReference (  \" listener 1  \"  )  )  ;", "listener 2  . setLazyInit ( true )  ;", "context . registerBeanDefinition (  \" listener 2  \"  ,    listener 2  )  ;", "context . refresh (  )  ;", "assertFalse ( context . getDefaultListableBeanFactory (  )  . containsSingleton (  \" listener 2  \"  )  )  ;", ". MyOrderedListener 1    listener 1     =    context . getBean (  \" listener 1  \"  ,     . MyOrderedListener 1  . class )  ;", ". MyOtherEvent   event 1     =    new    . MyOtherEvent ( context )  ;", "context . publishEvent ( event 1  )  ;", "assertFalse ( context . getDefaultListableBeanFactory (  )  . containsSingleton (  \" listener 2  \"  )  )  ;", ". MyEvent   event 2     =    new    . MyEvent ( context )  ;", "context . publishEvent ( event 2  )  ;", "assertTrue ( context . getDefaultListableBeanFactory (  )  . containsSingleton (  \" listener 2  \"  )  )  ;", ". MyEvent   event 3     =    new    . MyEvent ( context )  ;", "context . publishEvent ( event 3  )  ;", ". MyOtherEvent   event 4     =    new    . MyOtherEvent ( context )  ;", "context . publishEvent ( event 4  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 1  )  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 2  )  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 3  )  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 4  )  )  ;", "listener 1  . seenEvents . clear (  )  ;", "context . publishEvent ( event 1  )  ;", "context . publishEvent ( event 2  )  ;", "context . publishEvent ( event 3  )  ;", "context . publishEvent ( event 4  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 1  )  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 2  )  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 3  )  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 4  )  )  ;", "AbstractApplicationEventMulticaster   multicaster    =    context . getBean ( AbstractApplicationEventMulticaster . class )  ;", "assertEquals (  2  ,    multicaster . retrieverCache . size (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["listenersInApplicationContext"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "RootBeanDefinition   nestedChild    =    new   RootBeanDefinition ( StaticApplicationContext . class )  ;", "nestedChild . getPropertyValues (  )  . add (  \" parent \"  ,    context )  ;", "nestedChild . setInitMethodName (  \" refresh \"  )  ;", "context . registerBeanDefinition (  \" nestedChild \"  ,    nestedChild )  ;", "RootBeanDefinition   listener 1 Def    =    new   RootBeanDefinition (  . MyOrderedListener 1  . class )  ;", "listener 1 Def . setDependsOn (  \" nestedChild \"  )  ;", "context . registerBeanDefinition (  \" listener 1  \"  ,    listener 1 Def )  ;", "context . refresh (  )  ;", ". MyOrderedListener 1    listener 1     =    context . getBean (  \" listener 1  \"  ,     . MyOrderedListener 1  . class )  ;", ". MyEvent   event 1     =    new    . MyEvent ( context )  ;", "context . publishEvent ( event 1  )  ;", "assertTrue ( listener 1  . seenEvents . contains ( event 1  )  )  ;", "SimpleApplicationEventMulticaster   multicaster    =    context . getBean ( AbstractApplicationContext . APPLICATION _ EVENT _ MULTICASTER _ BEAN _ NAME ,    SimpleApplicationEventMulticaster . class )  ;", "assertFalse ( multicaster . getApplicationListeners (  )  . isEmpty (  )  )  ;", "context . close (  )  ;", "assertTrue ( multicaster . getApplicationListeners (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["listenersInApplicationContextWithNestedChild"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . registerBeanDefinition (  \" listener \"  ,    new   RootBeanDefinition (  . MyPayloadListener . class )  )  ;", "context . refresh (  )  ;", ". MyPayloadListener   listener    =    context . getBean (  \" listener \"  ,     . MyPayloadListener . class )  ;", "context . publishEvent (  \" event 1  \"  )  ;", "context . publishEvent (  \" event 2  \"  )  ;", "context . publishEvent (  \" event 3  \"  )  ;", "context . publishEvent (  \" event 4  \"  )  ;", "assertTrue ( listener . seenPayloads . contains (  \" event 1  \"  )  )  ;", "assertTrue ( listener . seenPayloads . contains (  \" event 2  \"  )  )  ;", "assertTrue ( listener . seenPayloads . contains (  \" event 3  \"  )  )  ;", "assertTrue ( listener . seenPayloads . contains (  \" event 4  \"  )  )  ;", "AbstractApplicationEventMulticaster   multicaster    =    context . getBean ( AbstractApplicationEventMulticaster . class )  ;", "assertEquals (  2  ,    multicaster . retrieverCache . size (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["listenersInApplicationContextWithPayloadEvents"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "multicastEvent ( true ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    new   AbstractApplicationEventListenerTests . StringEvent ( this ,     \" test \"  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["multicastConcreteTypeGenericListener"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "multicastEvent ( false ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    new   AbstractApplicationEventListenerTests . LongEvent ( this ,     1  2  3 L )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["multicastConcreteWrongTypeGenericListener"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "Listener < Event >    listener    =     (  ( Listener < Event >  )     ( mock ( listenerType )  )  )  ;", "SimpleEventMulticaster   smc    =    new   SimpleEventMulticaster (  )  ;", "smc . addListener ( listener )  ;", "if    ( eventType    !  =    null )     {", "smc . multicastEvent ( event ,    eventType )  ;", "} else    {", "smc . multicastEvent ( event )  ;", "}", "int   invocation    =     ( match )     ?     1     :     0  ;", "verify ( listener ,    times ( invocation )  )  . onEvent ( event )  ;", "}", "METHOD_END"], "methodName": ["multicastEvent"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "multicastEvent ( true ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    createGenericTestEvent (  \" test \"  )  ,    getGenericApplicationEventType (  \" stringEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["multicastGenericEvent"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "multicastEvent ( false ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    createGenericTestEvent (  \" test \"  )  ,    getGenericApplicationEventType (  \" wildcardEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["multicastGenericEventWildcardSubType"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "multicastEvent ( false ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    createGenericTestEvent (  1  2  3 L )  ,    getGenericApplicationEventType (  \" longEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["multicastGenericEventWrongType"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "multicastEvent ( true ,    ApplicationListener . class ,    new   ContextClosedEvent ( new   StaticApplicationContext (  )  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["multicastSimpleEvent"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "multicastEvent ( true ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    new   AbstractApplicationEventListenerTests . SmartGenericTestEvent <  >  ( this ,     \" test \"  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["multicastSmartGenericTypeGenericListener"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "multicastEvent ( false ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    new   AbstractApplicationEventListenerTests . SmartGenericTestEvent <  >  ( this ,     1  2  3 L )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["multicastSmartGenericWrongTypeGenericListener"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "RootBeanDefinition   listener    =    new   RootBeanDefinition (  . MyNonSingletonListener . class )  ;", "listener . setScope ( SCOPE _ PROTOTYPE )  ;", "context . registerBeanDefinition (  \" listener \"  ,    listener )  ;", "context . refresh (  )  ;", ". MyEvent   event 1     =    new    . MyEvent ( context )  ;", "context . publishEvent ( event 1  )  ;", ". MyOtherEvent   event 2     =    new    . MyOtherEvent ( context )  ;", "context . publishEvent ( event 2  )  ;", ". MyEvent   event 3     =    new    . MyEvent ( context )  ;", "context . publishEvent ( event 3  )  ;", ". MyOtherEvent   event 4     =    new    . MyOtherEvent ( context )  ;", "context . publishEvent ( event 4  )  ;", "assertTrue (  . MyNonSingletonListener . seenEvents . contains ( event 1  )  )  ;", "assertTrue (  . MyNonSingletonListener . seenEvents . contains ( event 2  )  )  ;", "assertTrue (  . MyNonSingletonListener . seenEvents . contains ( event 3  )  )  ;", "assertTrue (  . MyNonSingletonListener . seenEvents . contains ( event 4  )  )  ;", ". MyNonSingletonListener . seenEvents . clear (  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["nonSingletonListenerInApplicationContext"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContextEventTests . MyOrderedListener 1    listener 1     =    new   ApplicationContextEventTests . MyOrderedListener 1  (  )  ;", "ApplicationContextEventTests . MyOrderedListener 2    listener 2     =    new   ApplicationContextEventTests . MyOrderedListener 2  ( listener 1  )  ;", "SimpleApplicationEventMulticaster   smc    =    new   SimpleApplicationEventMulticaster (  )  ;", "smc . addApplicationListener ( listener 2  )  ;", "smc . addApplicationListener ( listener 1  )  ;", "smc . multicastEvent ( new   ApplicationContextEventTests . MyEvent ( this )  )  ;", "smc . multicastEvent ( new   ApplicationContextEventTests . MyOtherEvent ( this )  )  ;", "assertEquals (  2  ,    listener 1  . seenEvents . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["orderedListeners"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContextEventTests . MyOrderedListener 3    listener 1     =    new   ApplicationContextEventTests . MyOrderedListener 3  (  )  ;", "ApplicationContextEventTests . MyOrderedListener 4    listener 2     =    new   ApplicationContextEventTests . MyOrderedListener 4  ( listener 1  )  ;", "SimpleApplicationEventMulticaster   smc    =    new   SimpleApplicationEventMulticaster (  )  ;", "smc . addApplicationListener ( listener 2  )  ;", "smc . addApplicationListener ( listener 1  )  ;", "smc . multicastEvent ( new   ApplicationContextEventTests . MyEvent ( this )  )  ;", "smc . multicastEvent ( new   ApplicationContextEventTests . MyOtherEvent ( this )  )  ;", "assertEquals (  2  ,    listener 1  . seenEvents . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["orderedListenersWithAnnotation"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContextEventTests . MyOrderedListener 1    listener 1     =    new   ApplicationContextEventTests . MyOrderedListener 1  (  )  ;", "ApplicationContextEventTests . MyOrderedListener 2    listener 2     =    new   ApplicationContextEventTests . MyOrderedListener 2  ( listener 1  )  ;", "ApplicationListener < ApplicationEvent >    proxy 1     =     (  ( ApplicationListener < ApplicationEvent >  )     ( new   ProxyFactory ( listener 1  )  . getProxy (  )  )  )  ;", "ApplicationListener < ApplicationEvent >    proxy 2     =     (  ( ApplicationListener < ApplicationEvent >  )     ( new   ProxyFactory ( listener 2  )  . getProxy (  )  )  )  ;", "SimpleApplicationEventMulticaster   smc    =    new   SimpleApplicationEventMulticaster (  )  ;", "smc . addApplicationListener ( proxy 1  )  ;", "smc . addApplicationListener ( proxy 2  )  ;", "smc . multicastEvent ( new   ApplicationContextEventTests . MyEvent ( this )  )  ;", "smc . multicastEvent ( new   ApplicationContextEventTests . MyOtherEvent ( this )  )  ;", "assertEquals (  2  ,    listener 1  . seenEvents . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["proxiedListeners"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContextEventTests . MyOrderedListener 1    listener 1     =    new   ApplicationContextEventTests . MyOrderedListener 1  (  )  ;", "ApplicationContextEventTests . MyOrderedListener 2    listener 2     =    new   ApplicationContextEventTests . MyOrderedListener 2  ( listener 1  )  ;", "ApplicationListener < ApplicationEvent >    proxy 1     =     (  ( ApplicationListener < ApplicationEvent >  )     ( new   ProxyFactory ( listener 1  )  . getProxy (  )  )  )  ;", "ApplicationListener < ApplicationEvent >    proxy 2     =     (  ( ApplicationListener < ApplicationEvent >  )     ( new   ProxyFactory ( listener 2  )  . getProxy (  )  )  )  ;", "SimpleApplicationEventMulticaster   smc    =    new   SimpleApplicationEventMulticaster (  )  ;", "smc . addApplicationListener ( listener 1  )  ;", "smc . addApplicationListener ( listener 2  )  ;", "smc . addApplicationListener ( proxy 1  )  ;", "smc . addApplicationListener ( proxy 2  )  ;", "smc . multicastEvent ( new   ApplicationContextEventTests . MyEvent ( this )  )  ;", "smc . multicastEvent ( new   ApplicationContextEventTests . MyOtherEvent ( this )  )  ;", "assertEquals (  2  ,    listener 1  . seenEvents . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["proxiedListenersMixedWithTargetListeners"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "ApplicationListener < ApplicationEvent >    listener    =    mock ( ApplicationListener . class )  ;", "ApplicationEvent   evt    =    new   ContextClosedEvent ( new   Static (  )  )  ;", "SimpleApplicationEventMulticaster   smc    =    new   SimpleApplicationEventMulticaster (  )  ;", "smc . setErrorHandler ( TaskUtils . LOG _ AND _ SUPPRESS _ ERROR _ HANDLER )  ;", "smc . addApplicationListener ( listener )  ;", "willThrow ( new   RuntimeException (  )  )  . given ( listener )  . onApplicationEvent ( evt )  ;", "smc . multicastEvent ( evt )  ;", "}", "METHOD_END"], "methodName": ["simpleApplicationEventMulticasterWithErrorHandler"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "ApplicationListener < ApplicationEvent >    listener    =    mock ( ApplicationListener . class )  ;", "ApplicationEvent   evt    =    new   ContextClosedEvent ( new   Static (  )  )  ;", "SimpleApplicationEventMulticaster   smc    =    new   SimpleApplicationEventMulticaster (  )  ;", "smc . addApplicationListener ( listener )  ;", "RuntimeException   thrown    =    new   RuntimeException (  )  ;", "willThrow ( thrown )  . given ( listener )  . onApplicationEvent ( evt )  ;", "try    {", "smc . multicastEvent ( evt )  ;", "fail (  \" Should   have   thrown   RuntimeException \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertSame ( thrown ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["simpleApplicationEventMulticasterWithException"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "ApplicationListener < ApplicationEvent >    listener    =    mock ( ApplicationListener . class )  ;", "ApplicationEvent   evt    =    new   ContextClosedEvent ( new   Static (  )  )  ;", "SimpleApplicationEventMulticaster   smc    =    new   SimpleApplicationEventMulticaster (  )  ;", "smc . setTaskExecutor ( new   Executor (  )     {", "@ Override", "public   void   execute ( Runnable   command )     {", "command . run (  )  ;", "command . run (  )  ;", "}", "}  )  ;", "smc . addApplicationListener ( listener )  ;", "smc . multicastEvent ( evt )  ;", "verify ( listener ,    times (  2  )  )  . onApplicationEvent ( evt )  ;", "}", "METHOD_END"], "methodName": ["simpleApplicationEventMulticasterWithTaskExecutor"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   invocation    =    mock ( MethodInvocation . class )  ;", "ApplicationContext   ctx    =    mock ( ApplicationContext . class )  ;", "EventPublicationInterceptor   interceptor    =    new   EventPublicationInterceptor (  )  ;", "interceptor . setApplicationEventClass (  . MyEvent . class )  ;", "interceptor . setApplicationEventPublisher ( ctx )  ;", "interceptor . afterPropertiesSet (  )  ;", "given ( invocation . proceed (  )  )  . willReturn ( new   Object (  )  )  ;", "given ( invocation . getThis (  )  )  . willReturn ( new   Object (  )  )  ;", "interceptor . invoke ( invocation )  ;", "verify ( ctx )  . publishEvent ( isA (  . MyEvent . class )  )  ;", "}", "METHOD_END"], "methodName": ["testEventPublicationInterceptor"], "fileName": "org.springframework.context.event.ApplicationContextEventTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    methodDeclaringClass    =    method . getDeclaringClass (  )  ;", "Class <  ?  >    targetBeanClass    =    targetBean . getClass (  )  ;", "if    (  !  ( methodDeclaringClass . isAssignableFrom ( targetBeanClass )  )  )     {", "String   msg    =     (  (  (  (  \" The   event   l   method   class    '  \"     +     ( methodDeclaringClass . getName (  )  )  )     +     \"  '    is   not   an   instance   of   the   actual   bean   class    '  \"  )     +     ( targetBeanClass . getName (  )  )  )     +     \"  '  .    If   the   bean   requires   proxying    \"  )     +     \"  ( e . g .    due   to    @ Transactional )  ,    please   use   class - based   proxying .  \"  ;", "throw   new   IllegalStateException ( getInvocationErrorMessage ( targetBean ,    msg ,    args )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertTargetBean"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "Object   bean    =    getTargetBean (  )  ;", "ReflectionUtils . makeAccessible ( this . bridgedMethod )  ;", "try    {", "return   this . bridgedMethod . invoke ( bean ,    args )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTargetBean ( this . bridgedMethod ,    bean ,    args )  ;", "throw   new   IllegalStateException ( getInvocationErrorMessage ( bean ,    ex . getMessage (  )  ,    args )  ,    ex )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   IllegalStateException ( getInvocationErrorMessage ( bean ,    ex . getMessage (  )  ,    args )  ,    ex )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   targetException    =    ex . getTargetException (  )  ;", "if    ( targetException   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( targetException )  )  ;", "} else    {", "String   msg    =    getInvocationErrorMessage ( bean ,     \" Failed   to   invoke   event   l   method \"  ,    args )  ;", "throw   new   UndeclaredThrowableException ( targetException ,    msg )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . condition ;", "}", "METHOD_END"], "methodName": ["getCondition"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( message )  . append (  \"  \\ n \"  )  ;", "sb . append (  \" Handl   details :     \\ n \"  )  ;", "sb . append (  \" Bean    [  \"  )  . append ( bean . getClass (  )  . getName (  )  )  . append (  \"  ]  \\ n \"  )  ;", "sb . append (  \" Method    [  \"  )  . append ( this . bridgedMethod . toGenericString (  )  )  . append (  \"  ]  \\ n \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDetailedErrorMessage"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( getDetailedErrorMessage ( bean ,    message )  )  ;", "sb . append (  \" Resolved   arguments :     \\ n \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( resolvedArgs . length )  ;    i +  +  )     {", "sb . append (  \"  [  \"  )  . append ( i )  . append (  \"  ]     \"  )  ;", "if    (  ( resolvedArgs [ i ]  )     =  =    null )     {", "sb . append (  \"  [ null ]     \\ n \"  )  ;", "} else    {", "sb . append (  \"  [ type =  \"  )  . append ( resolvedArgs [ i ]  . getClass (  )  . getName (  )  )  . append (  \"  ]     \"  )  ;", "sb . append (  \"  [ value =  \"  )  . append ( resolvedArgs [ i ]  )  . append (  \"  ]  \\ n \"  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getInvocationErrorMessage"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   payloadType    =    null ;", "if    ( event   instanceof   PayloadEvent )     {", "PayloadEvent <  ?  >    payloadEvent    =     (  ( PayloadEvent <  ?  >  )     ( event )  )  ;", "ResolvableType   eventType    =    payloadEvent . getResolvableType (  )  ;", "if    ( eventType    !  =    null )     {", "payloadType    =    eventType . as ( PayloadEvent . class )  . getGeneric (  )  ;", "}", "}", "for    ( ResolvableType   declaredEventType    :    this . declaredEventTypes )     {", "Class <  ?  >    eventClass    =    declaredEventType . getRawClass (  )  ;", "if    (  (  (  ( eventClass    =  =    null )     |  |     (  !  ( Event . class . isAssignableFrom ( eventClass )  )  )  )     &  &     ( payloadType    !  =    null )  )     &  &     ( declaredEventType . isAssignableFrom ( payloadType )  )  )     {", "return   declaredEventType ;", "}", "if    (  ( eventClass    !  =    null )     &  &     ( eventClass . isInstance ( event )  )  )     {", "return   declaredEventType ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getResolvableType"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . applicationContext ,     \" ApplicationContext   must   no   be   null \"  )  ;", "return   this . applicationContext . getBean ( this . beanName )  ;", "}", "METHOD_END"], "methodName": ["getTargetBean"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "if    ( result . getClass (  )  . isArray (  )  )     {", "Object [  ]    s    =    ObjectUtils . toObjectArray ( result )  ;", "for    ( Object       :    s )     {", "publishEvent (  )  ;", "}", "} else", "if    ( result   instanceof   Collection <  ?  >  )     {", "Collection <  ?  >    s    =     (  ( Collection <  ?  >  )     ( result )  )  ;", "for    ( Object       :    s )     {", "publishEvent (  )  ;", "}", "} else    {", "publishEvent ( result )  ;", "}", "}", "METHOD_END"], "methodName": ["handleResult"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "this . applicationContext    =    applicationContext ;", "this . evaluator    =    evaluator ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    args    =    resolveArguments ( event )  ;", "if    ( shouldHandle ( event ,    args )  )     {", "Object   result    =    doInvoke ( args )  ;", "if    ( result    !  =    null )     {", "handleResult ( result )  ;", "} else    {", "logger . trace (  \" No   result   object   given    -    no   result   to   handle \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processEvent"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "if    ( event    !  =    null )     {", "Assert . notNull ( this . applicationContext ,     \" Context   must   not   be   null \"  )  ;", "this . applicationContext . publishEvent ( event )  ;", "}", "}", "METHOD_END"], "methodName": ["publishEvent"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   declaredEventType    =    getResolvableType ( event )  ;", "if    ( declaredEventType    =  =    null )     {", "return   null ;", "}", "if    (  ( this . method . getParameterCount (  )  )     =  =     0  )     {", "return   new   Object [  0  ]  ;", "}", "Class <  ?  >    eventClass    =    declaredEventType . getRawClass (  )  ;", "if    (  (  ( eventClass    =  =    null )     |  |     (  !  ( Event . class . isAssignableFrom ( eventClass )  )  )  )     &  &     ( event   instanceof   PayloadEvent )  )     {", "return   new   Object [  ]  {     (  ( PayloadEvent )     ( event )  )  . getPayload (  )     }  ;", "} else    {", "return   new   Object [  ]  {    event    }  ;", "}", "}", "METHOD_END"], "methodName": ["resolveArguments"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "int   count    =    method . getParameterCount (  )  ;", "if    ( count    >     1  )     {", "throw   new   IllegalStateException (  (  \" Maximum   one   parameter   is   allowed   for   event   l   method :     \"     +    method )  )  ;", "}", "if    (  ( ann    !  =    null )     &  &     (  ( ann . classes (  )  . length )     >     0  )  )     {", "List < ResolvableType >    types    =    new   ArrayList <  >  ( ann . classes (  )  . length )  ;", "for    ( Class <  ?  >    eventType    :    ann . classes (  )  )     {", "types . add ( ResolvableType . forClass ( eventType )  )  ;", "}", "return   types ;", "} else    {", "if    ( count    =  =     0  )     {", "throw   new   IllegalStateException (  (  \" Event   parameter   is   mandatory   for   event   l   method :     \"     +    method )  )  ;", "}", "return   Collections . singletonList ( ResolvableType . forMethodParameter ( method ,     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveDeclaredEventTypes"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "Order   ann    =    AnnotatedElementUtils . findMergedAnnotation ( method ,    Order . class )  ;", "return   ann    !  =    null    ?    ann . value (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["resolveOrder"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "if    ( args    =  =    null )     {", "return   false ;", "}", "String   condition    =    getCondition (  )  ;", "if    ( StringUtils . hasText ( condition )  )     {", "Assert . notNull ( this . evaluator ,     \" EventExpressionEvaluator   must   no   be   null \"  )  ;", "EvaluationContext   evaluationContext    =    this . evaluator . createEvaluationContext ( event ,    this . targetClass ,    this . method ,    args ,    this . aContext )  ;", "return   this . evaluator . condition ( condition ,    this . methodKey ,    evaluationContext )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldHandle"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapter"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericString \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class )  ;", "when ( this . context . getBean (  \" testBean \"  )  )  . thenReturn ( this . sampleEvents )  ;", "ApplicationListenerMethodAdapter   listener    =    new   ApplicationListenerMethodAdapter (  \" testBean \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class ,    method )  ;", "listener . init ( this . context ,    new   EventExpressionEvaluator (  )  )  ;", "AbstractApplicationEventListenerTests . GenericTestEvent < String >    event    =    createGenericTestEvent (  \" test \"  )  ;", "listener . onApplicationEvent ( event )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleGenericString ( event )  ;", "verify ( this . context ,    times (  1  )  )  . getBean (  \" testBean \"  )  ;", "listener . onApplicationEvent ( event )  ;", "verify ( this . sampleEvents ,    times (  2  )  )  . handleGenericString ( event )  ;", "verify ( this . context ,    times (  2  )  )  . getBean (  \" testBean \"  )  ;", "}", "METHOD_END"], "methodName": ["beanInstanceRetrievedAtEveryInvocation"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forClassWithGenerics ( PayloadApplicationEvent . class ,    payloadType )  ;", "}", "METHOD_END"], "methodName": ["createGenericEventType"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ApplicationListenerMethodAdapterTests . StaticApplicationListenerMethodAdapter ( method ,    this . sampleEvents )  ;", "}", "METHOD_END"], "methodName": ["createTestInstance"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericString \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class )  ;", "ApplicationListenerMethodAdapter   adapter    =    createTestInstance ( method )  ;", "assertEquals (  0  ,    adapter . getOrder (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultOrder"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericString \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class )  ;", "supportsEventType ( true ,    method ,    getGenericApplicationEventType (  \" stringEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListener"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericString \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class )  ;", "supportsEventType ( false ,    method ,    getGenericApplicationEventType (  \" longEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListenerWrongParameterizedType"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericString \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class )  ;", "AbstractApplicationEventListenerTests . GenericTestEvent < String >    event    =    createGenericTestEvent (  \" test \"  )  ;", "invokeListener ( method ,    event )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleGenericString ( event )  ;", "}", "METHOD_END"], "methodName": ["invokeListener"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationListenerMethodAdapter   adapter    =    createTestInstance ( method )  ;", "adapter . onApplicationEvent ( event )  ;", "}", "METHOD_END"], "methodName": ["invokeListener"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" generateCheckedException \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class )  ;", "AbstractApplicationEventListenerTests . GenericTestEvent < String >    event    =    createGenericTestEvent (  \" fail \"  )  ;", "this . thrown . expect ( UndeclaredThrowableException . class )  ;", "this . thrown . expectCause ( is ( instanceOf ( IOException . class )  )  )  ;", "invokeListener ( method ,    event )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerCheckedException"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Object   target    =    new   ApplicationListenerMethodAdapterTests . InvalidProxyTestBean (  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( target )  ;", "proxyFactory . addInterface ( ApplicationListenerMethodAdapterTests . SimpleService . class )  ;", "Object   bean    =    proxyFactory . getProxy ( getClass (  )  . getClassLoader (  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . InvalidProxyTestBean . class ,     \" handleIt 2  \"  ,    ApplicationEvent . class )  ;", "ApplicationListenerMethodAdapterTests . StaticApplicationListenerMethodAdapter   listener    =    new   ApplicationListenerMethodAdapterTests . StaticApplicationListenerMethodAdapter ( method ,    bean )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" handleIt 2  \"  )  ;", "listener . onApplicationEvent ( createGenericTestEvent (  \" test \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerInvalidProxy"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" generateRuntimeException \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class )  ;", "AbstractApplicationEventListenerTests . GenericTestEvent < String >    event    =    createGenericTestEvent (  \" fail \"  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" Test   exception \"  )  ;", "this . thrown . expectCause ( is (  (  ( Throwable )     ( isNull (  )  )  )  )  )  ;", "invokeListener ( method ,    event )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerRuntimeException"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleStringAnnotationClasses \"  )  ;", "PayloadApplicationEvent < String >    event    =    new   PayloadApplicationEvent <  >  ( this ,     \" test \"  )  ;", "invokeListener ( method ,    event )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleStringAnnotationClasses (  )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithAnnotationValue"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleStringAnnotationValueAndParameter \"  ,    String . class )  ;", "PayloadApplicationEvent < String >    event    =    new   PayloadApplicationEvent <  >  ( this ,     \" test \"  )  ;", "invokeListener ( method ,    event )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleStringAnnotationValueAndParameter (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithAnnotationValueAndParameter"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericAnyPayload \"  ,    ApplicationListenerMethodAdapterTests . EntityWrapper . class )  ;", "ApplicationListenerMethodAdapterTests . EntityWrapper < String >    payload    =    new   ApplicationListenerMethodAdapterTests . EntityWrapper <  >  (  \" test \"  )  ;", "invokeListener ( method ,    new   PayloadApplicationEvent <  >  ( this ,    payload )  )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleGenericAnyPayload ( payload )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithAnyGenericPayload"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericString \"  ,    AbstractApplicationEventListenerTests . GenericTestEvent . class )  ;", "AbstractApplicationEventListenerTests . GenericTestEvent < String >    event    =    new   AbstractApplicationEventListenerTests . SmartGenericTestEvent <  >  ( this ,     \" test \"  )  ;", "invokeListener ( method ,    event )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleGenericString ( event )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithGenericEvent"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericStringPayload \"  ,    ApplicationListenerMethodAdapterTests . EntityWrapper . class )  ;", "ApplicationListenerMethodAdapterTests . EntityWrapper < String >    payload    =    new   ApplicationListenerMethodAdapterTests . EntityWrapper <  >  (  \" test \"  )  ;", "invokeListener ( method ,    new   PayloadApplicationEvent <  >  ( this ,    payload )  )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleGenericStringPayload ( payload )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithGenericPayload"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleString \"  ,    String . class )  ;", "PayloadApplicationEvent < String >    event    =    new   PayloadApplicationEvent <  >  ( this ,     \" test \"  )  ;", "invokeListener ( method ,    event )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleString (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithPayload"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleString \"  ,    String . class )  ;", "PayloadApplicationEvent < Long >    event    =    new   PayloadApplicationEvent <  >  ( this ,     1  2  3 L )  ;", "invokeListener ( method ,    event )  ;", "verify ( this . sampleEvents ,    never (  )  )  . handleString ( anyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithPayloadWrongType"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleStringOrInteger \"  )  ;", "PayloadApplicationEvent < String >    event    =    new   PayloadApplicationEvent <  >  ( this ,     \" test \"  )  ;", "invokeListener ( method ,    event )  ;", "verify ( this . sampleEvents ,    times (  1  )  )  . handleStringOrInteger (  )  ;", "PayloadApplicationEvent < Integer >    event 2     =    new   PayloadApplicationEvent <  >  ( this ,     1  2  3  )  ;", "invokeListener ( method ,    event 2  )  ;", "verify ( this . sampleEvents ,    times (  2  )  )  . handleStringOrInteger (  )  ;", "PayloadApplicationEvent < Double >    event 3     =    new   PayloadApplicationEvent <  >  ( this ,     2  3  .  2  )  ;", "invokeListener ( method ,    event 3  )  ;", "verify ( this . sampleEvents ,    times (  2  )  )  . handleStringOrInteger (  )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithSeveralTypes"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleGenericStringPayload \"  ,    ApplicationListenerMethodAdapterTests . EntityWrapper . class )  ;", "ApplicationListenerMethodAdapterTests . EntityWrapper < Integer >    payload    =    new   ApplicationListenerMethodAdapterTests . EntityWrapper <  >  (  1  2  3  )  ;", "invokeListener ( method ,    new   PayloadApplicationEvent <  >  ( this ,    payload )  )  ;", "verify ( this . sampleEvents ,    times (  0  )  )  . handleGenericStringPayload ( any (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeListenerWithWrongGenericPayload"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleStringAnnotationClasses \"  )  ;", "supportsEventType ( true ,    method ,    createGenericEventType ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithAnnotationClasses"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleStringAnnotationValue \"  )  ;", "supportsEventType ( true ,    method ,    createGenericEventType ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithAnnotationValue"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleStringAnnotationValueAndParameter \"  ,    String . class )  ;", "supportsEventType ( true ,    method ,    createGenericEventType ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithAnnotationValueAndParameter"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleString \"  ,    String . class )  ;", "supportsEventType ( false ,    method ,    createGenericEventType ( Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithInvalidPayloadAndGenericInformation"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" moreThanOneParameter \"  ,    String . class ,    Integer . class )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "createTestInstance ( method )  ;", "}", "METHOD_END"], "methodName": ["listenerWithMoreThanOneParameter"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" noParameter \"  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "createTestInstance ( method )  ;", "}", "METHOD_END"], "methodName": ["listenerWithNoParameter"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleString \"  ,    String . class )  ;", "supportsEventType ( true ,    method ,    createGenericEventType ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithPayloadAndGenericInformation"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleString \"  ,    String . class )  ;", "supportsEventType ( true ,    method ,    ResolvableType . forClass ( PayloadApplicationEvent . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithPayloadTypeErasure"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleStringOrInteger \"  )  ;", "supportsEventType ( true ,    method ,    createGenericEventType ( String . class )  )  ;", "supportsEventType ( true ,    method ,    createGenericEventType ( Integer . class )  )  ;", "supportsEventType ( false ,    method ,    createGenericEventType ( Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithSeveralTypes"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleString \"  ,    String . class )  ;", "supportsEventType ( true ,    method ,    ResolvableType . forClass ( ApplicationListenerMethodAdapterTests . PayloadTestEvent . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithSubTypeSeveralGenerics"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleString \"  ,    String . class )  ;", "supportsEventType ( true ,    method ,    ResolvableType . forClass ( ApplicationListenerMethodAdapterTests . PayloadStringTestEvent . class )  )  ;", "}", "METHOD_END"], "methodName": ["listenerWithSubTypeSeveralGenericsResolved"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" tooManyParameters \"  ,    String . class ,    String . class )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "createTestInstance ( method )  ;", "}", "METHOD_END"], "methodName": ["listenerWithTooManyParameters"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleRaw \"  ,    ApplicationEvent . class )  ;", "supportsEventType ( true ,    method ,    getGenericApplicationEventType (  \" applicationEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["rawListener"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleRaw \"  ,    ApplicationEvent . class )  ;", "supportsEventType ( true ,    method ,    getGenericApplicationEventType (  \" stringEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["rawListenerWithGenericEvent"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( ApplicationListenerMethodAdapterTests . SampleEvents . class ,     \" handleRaw \"  ,    ApplicationEvent . class )  ;", "ApplicationListenerMethodAdapter   adapter    =    createTestInstance ( method )  ;", "assertEquals (  4  2  ,    adapter . getOrder (  )  )  ;", "}", "METHOD_END"], "methodName": ["specifiedOrder"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationListenerMethodAdapter   adapter    =    createTestInstance ( method )  ;", "assertEquals (  (  (  (  \" Wrong   match   for   event    '  \"     +    eventType )     +     \"  '    on    \"  )     +    method )  ,    match ,    adapter . supportsEventType ( eventType )  )  ;", "}", "METHOD_END"], "methodName": ["supportsEventType"], "fileName": "org.springframework.context.event.ApplicationListenerMethodAdapterTests"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.context.event.DefaultEventListenerFactory"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["supportsMethod"], "fileName": "org.springframework.context.event.DefaultEventListenerFactory"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . TRUE . equals ( getExpression ( this . conditionCache ,    elementKey ,    conditionExpression )  . getValue ( evalContext ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["condition"], "fileName": "org.springframework.context.event.EventExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "Method   targetMethod    =    getTargetMethod ( targetClass ,    method )  ;", "RootObject   root    =    new   RootObject ( event ,    args )  ;", "MethodBasedEvaluationContext   evaluationContext    =    new   MethodBasedEvaluationContext ( root ,    targetMethod ,    args ,    getParameterNameDiscoverer (  )  )  ;", "if    ( beanFactory    !  =    null )     {", "evaluationContext . setBeanResolver ( new   BeanFactoryResolver ( beanFactory )  )  ;", "}", "return   evaluationContext ;", "}", "METHOD_END"], "methodName": ["createEvaluationContext"], "fileName": "org.springframework.context.event.EventExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElementKey   methodKey    =    new   AnnotatedElementKey ( method ,    targetClass )  ;", "Method   targetMethod    =    this . targetMethodCache . get ( methodKey )  ;", "if    ( targetMethod    =  =    null )     {", "targetMethod    =    AopUtils . getMostSpecificMethod ( method ,    targetClass )  ;", "this . targetMethodCache . put ( methodKey ,    targetMethod )  ;", "}", "return   targetMethod ;", "}", "METHOD_END"], "methodName": ["getTargetMethod"], "fileName": "org.springframework.context.event.EventExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   args ;", "}", "METHOD_END"], "methodName": ["getArgs"], "fileName": "org.springframework.context.event.EventExpressionRootObject"}, {"methodBody": ["METHOD_START", "{", "return   event ;", "}", "METHOD_END"], "methodName": ["getEvent"], "fileName": "org.springframework.context.event.EventExpressionRootObject"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . applicationContext )     !  =    null )  ,     \" No   ApplicationContext   set \"  )  ;", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.context.event.EventListenerMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    EventListenerFactory >    beans    =    getApplicationContext (  )  . getBeansOfType ( EventListenerFactory . class )  ;", "List < EventListenerFactory >    factories    =    new   ArrayList <  >  ( beans . values (  )  )  ;", "AnnotationAwareOrderComparator . sort ( factories )  ;", "return   factories ;", "}", "METHOD_END"], "methodName": ["getEventListenerFactories"], "fileName": "org.springframework.context.event.EventListenerMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . nonAnnotatedClasses . contains ( targetType )  )  )     {", "Map < Method ,    EventListener >    annotatedMethods    =    null ;", "try    {", "annotatedMethods    =    MethodIntrospector . selectMethods ( targetType ,     (  ( MethodIntrospector . MetadataLookup < EventListener >  )     (  (    method )     -  >    AnnotatedElementUtils . findMergedAnnotation ( method ,     . class )  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Could   not   resolve   methods   for   bean   with   name    '  \"     +    beanName )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "if    ( CollectionUtils . isEmpty ( annotatedMethods )  )     {", "this . nonAnnotatedClasses . add ( targetType )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" No    @ EventListener   annotations   found   on   bean   class :     \"     +     ( targetType . getName (  )  )  )  )  ;", "}", "} else    {", "ConfigurableApplicationContext   context    =    getApplicationContext (  )  ;", "for    ( Method   method    :    annotatedMethods . keySet (  )  )     {", "for    ( EventListenerFactory   factory    :    factories )     {", "if    ( factory . supportsMethod ( method )  )     {", "Method   methodToUse    =    AopUtils . selectInvocableMethod ( method ,    context . getType ( beanName )  )  ;", "ApplicationListener <  ?  >    applicationListener    =    factory . createApplicationListener ( beanName ,    targetType ,    methodToUse )  ;", "if    ( applicationListener   instanceof   ApplicationAdapter )     {", "(  ( ApplicationAdapter )     ( applicationListener )  )  . init ( context ,    this . evaluator )  ;", "}", "context . addApplicationListener ( applicationListener )  ;", "break ;", "}", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  ( annotatedMethods . size (  )  )     +     \"     @ EventListener   methods   processed   on   bean    '  \"  )     +    beanName )     +     \"  '  :     \"  )     +    annotatedMethods )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processBean"], "fileName": "org.springframework.context.event.EventListenerMethodProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( ApplicationEvent . class )     =  =    applicationEventClass )     |  |     (  !  ( ApplicationEvent . class . isAssignableFrom ( applicationEventClass )  )  )  )     {", "throw   new   IllegalArgumentException (  \"  ' applicationEventClass '    needs   to   extend   ApplicationEvent \"  )  ;", "}", "try    {", "this . applicationEventClassConstructor    =    applicationEventClass . getConstructor ( Object . class )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  \" ApplicationEvent   class    [  \"     +     ( applicationEventClass . getName (  )  )  )     +     \"  ]    does   not   have   the   required   Object   constructor :     \"  )     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setApplicationEventClass"], "fileName": "org.springframework.context.event.EventPublicationInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . publisher    =    mock ( ApplicationEventPublisher . class )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.context.event.EventPublicationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "final   TestListener   listener    =    new   TestListener (  )  ;", "class   TestContext   extends   StaticApplicationContext    {", "@ Override", "protected   void   onRefresh (  )    throws   BeansException    {", "addApplicationListener ( listener )  ;", "}", "}", "StaticApplicationContext   ctx    =    new   TestContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" applicationEventClass \"  ,    TestEvent . class . getName (  )  )  ;", "ctx . registerSingleton (  \" publisher \"  ,    EventPublicationInterceptor . class ,    pvs )  ;", "ctx . registerSingleton (  \" otherListener \"  ,     . FactoryBeanTestListener . class )  ;", "ctx . refresh (  )  ;", "EventPublicationInterceptor   interceptor    =     (  ( EventPublicationInterceptor )     ( ctx . getBean (  \" publisher \"  )  )  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( target )  ;", "factory . addAdvice (  0  ,    interceptor )  ;", "ITestBean   testBean    =     (  ( ITestBean )     ( factory . getProxy (  )  )  )  ;", "testBean . getAge (  )  ;", "assertTrue (  \" Interceptor   must   have   published    2    events \"  ,     (  ( listener . getEventCount (  )  )     =  =     2  )  )  ;", "TestListener   otherListener    =     (  ( TestListener )     ( ctx . getBean (  \"  & otherListener \"  )  )  )  ;", "assertTrue (  \" Interceptor   must   have   published    2    events \"  ,     (  ( otherListener . getEventCount (  )  )     =  =     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testExpectedBehavior"], "fileName": "org.springframework.context.event.EventPublicationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "EventPublicationInterceptor   interceptor    =    new   EventPublicationInterceptor (  )  ;", "interceptor . setApplicationEventPublisher ( this . publisher )  ;", "interceptor . setApplicationEventClass ( ApplicationEvent . class )  ;", "interceptor . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testWithAbstractStraightApplicationEventClassSupplied"], "fileName": "org.springframework.context.event.EventPublicationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "EventPublicationInterceptor   interceptor    =    new   EventPublicationInterceptor (  )  ;", "interceptor . setApplicationEventPublisher ( this . publisher )  ;", "interceptor . setApplicationEventClass (  . TestEventWithNoValidOneArgObjectCtor . class )  ;", "interceptor . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testWithApplicationEventClassThatDoesntExposeAValidCtor"], "fileName": "org.springframework.context.event.EventPublicationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "EventPublicationInterceptor   interceptor    =    new   EventPublicationInterceptor (  )  ;", "interceptor . setApplicationEventPublisher ( this . publisher )  ;", "interceptor . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testWithNoApplicationEventClassSupplied"], "fileName": "org.springframework.context.event.EventPublicationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "EventPublicationInterceptor   interceptor    =    new   EventPublicationInterceptor (  )  ;", "interceptor . setApplicationEventPublisher ( this . publisher )  ;", "interceptor . setApplicationEventClass ( getClass (  )  )  ;", "interceptor . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testWithNonApplicationEventClassSupplied"], "fileName": "org.springframework.context.event.EventPublicationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   resolvableType    =    ResolvableType . forClass ( listenerType )  . as ( ApplicationListener . class )  ;", "return   resolvableType . hasGenerics (  )     ?    resolvableType . getGeneric (  )     :    null ;", "}", "METHOD_END"], "methodName": ["resolveDeclaredEventType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   declaredEventType    =    GenericApplicationListenerAdapter . resolveDeclaredEventType ( listener . getClass (  )  )  ;", "if    (  ( declaredEventType    =  =    null )     |  |     ( declaredEventType . isAssignableFrom ( ResolvableType . forClass ( ApplicationEvent . class )  )  )  )     {", "Class <  ?  >    targetClass    =    AopUtils . getTargetClass ( listener )  ;", "if    ( targetClass    !  =     ( listener . getClass (  )  )  )     {", "declaredEventType    =    GenericApplicationListenerAdapter . resolveDeclaredEventType ( targetClass )  ;", "}", "}", "return   declaredEventType ;", "}", "METHOD_END"], "methodName": ["resolveDeclaredEventType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . RawApplicationListener . class ,    getGenericApplicationEventType (  \" stringEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListenerRawType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationEventListenerTests . GenericTestEvent < String >    stringEvent    =    createGenericTestEvent (  \" test \"  )  ;", "ResolvableType   eventType    =    ResolvableType . forType ( stringEvent . getClass (  )  )  ;", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . Raw . class ,    eventType )  ;", "}", "METHOD_END"], "methodName": ["genericListenerRawTypeTypeErasure"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    getGenericApplicationEventType (  \" stringEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   eventType    =    ResolvableType . forClassWithGenerics ( AbstractApplicationEventListenerTests . GenericTestEvent . class ,    String . class )  ;", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    eventType )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictTypeAndResolvableType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   eventType    =    new   AbstractApplicationEventListenerTests . SmartGenericTestEvent <  >  ( this ,     \" foo \"  )  . getResolvableType (  )  ;", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    eventType )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictTypeAndResolvableTypeProvider"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationEventListenerTests . StringEvent   stringEvent    =    new   AbstractApplicationEventListenerTests . StringEvent ( this ,     \" test \"  )  ;", "ResolvableType   eventType    =    ResolvableType . forType ( stringEvent . getClass (  )  )  ;", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    eventType )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictTypeEventSubType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationEventListenerTests . LongEvent   stringEvent    =    new   AbstractApplicationEventListenerTests . LongEvent ( this ,     1  2  3 L )  ;", "ResolvableType   eventType    =    ResolvableType . forType ( stringEvent . getClass (  )  )  ;", "supportsEventType ( false ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    eventType )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictTypeEventSubTypeNotMatching"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationEventListenerTests . GenericTestEvent < Long >    longEvent    =    createGenericTestEvent (  1  2  3 L )  ;", "ResolvableType   eventType    =    ResolvableType . forType ( longEvent . getClass (  )  )  ;", "supportsEventType ( false ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    eventType )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictTypeNotMatchTypeErasure"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "supportsEventType ( false ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    getGenericApplicationEventType (  \" longEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictTypeNotMatching"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "supportsEventType ( false ,    AbstractApplicationEventListenerTests . ObjectEventListener . class ,    getGenericApplicationEventType (  \" longEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictTypeSubClass"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationEventListenerTests . GenericTestEvent < String >    stringEvent    =    createGenericTestEvent (  \" test \"  )  ;", "ResolvableType   eventType    =    ResolvableType . forType ( stringEvent . getClass (  )  )  ;", "supportsEventType ( false ,    AbstractApplicationEventListenerTests . StringEventListener . class ,    eventType )  ;", "}", "METHOD_END"], "methodName": ["genericListenerStrictTypeTypeErasure"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . UpperBoundEventListener . class ,    getGenericApplicationEventType (  \" illegalStateExceptionEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListenerUpperBoundType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "supportsEventType ( false ,    AbstractApplicationEventListenerTests . UpperBoundEventListener . class ,    getGenericApplicationEventType (  \" ioExceptionEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListenerUpperBoundTypeNotMatching"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . GenericEventListener . class ,    getGenericApplicationEventType (  \" stringEvent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericListenerWildcardType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationEventListenerTests . GenericTestEvent < String >    stringEvent    =    createGenericTestEvent (  \" test \"  )  ;", "ResolvableType   eventType    =    ResolvableType . forType ( stringEvent . getClass (  )  )  ;", "supportsEventType ( true ,    AbstractApplicationEventListenerTests . GenericEventListener . class ,    eventType )  ;", "}", "METHOD_END"], "methodName": ["genericListenerWildcardTypeTypeErasure"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationListener <  ?  >    listener    =    mock ( listenerType )  ;", "adapter    =    new    ( listener )  ;", "assertEquals (  (  (  (  \" Wrong   match   for   event    '  \"     +    eventType )     +     \"  '    on    \"  )     +     ( listenerType . getClass (  )  . getName (  )  )  )  ,    match ,    adapter . supportsEventType ( eventType )  )  ;", "}", "METHOD_END"], "methodName": ["supportsEventType"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SmartApplicationListener   smartListener    =    mock ( SmartApplicationListener . class )  ;", "listener    =    new    ( smartListener )  ;", "ResolvableType   type    =    ResolvableType . forClass ( ApplicationEvent . class )  ;", "listener . supportsEventType ( type )  ;", "verify ( smartListener ,    times (  1  )  )  . supportsEventType ( ApplicationEvent . class )  ;", "}", "METHOD_END"], "methodName": ["supportsEventTypeWithSmartApplicationListener"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SmartApplicationListener   smartListener    =    mock ( SmartApplicationListener . class )  ;", "listener    =    new    ( smartListener )  ;", "listener . supportsSourceType ( Object . class )  ;", "verify ( smartListener ,    times (  1  )  )  . supportsSourceType ( Object . class )  ;", "}", "METHOD_END"], "methodName": ["supportsSourceTypeWithSmartApplicationListener"], "fileName": "org.springframework.context.event.GenericApplicationListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . registerSingleton (  \" lifecycle \"  ,     . LifecycleTestBean . class )  ;", "context . registerSingleton (  \" listener \"  ,     . LifecycleListener . class )  ;", "context . refresh (  )  ;", ". LifecycleTestBean   lifecycleBean    =     (  (  . LifecycleTestBean )     ( context . getBean (  \" lifecycle \"  )  )  )  ;", ". LifecycleListener   listener    =     (  (  . LifecycleListener )     ( context . getBean (  \" listener \"  )  )  )  ;", "assertFalse ( lifecycleBean . isRunning (  )  )  ;", "assertEquals (  0  ,    listener . getStartedCount (  )  )  ;", "context . start (  )  ;", "assertTrue ( lifecycleBean . isRunning (  )  )  ;", "assertEquals (  1  ,    listener . getStartedCount (  )  )  ;", "assertSame ( context ,    listener . getApplicationContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextStartedEvent"], "fileName": "org.springframework.context.event.LifecycleEventTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . registerSingleton (  \" lifecycle \"  ,     . LifecycleTestBean . class )  ;", "context . registerSingleton (  \" listener \"  ,     . LifecycleListener . class )  ;", "context . refresh (  )  ;", ". LifecycleTestBean   lifecycleBean    =     (  (  . LifecycleTestBean )     ( context . getBean (  \" lifecycle \"  )  )  )  ;", ". LifecycleListener   listener    =     (  (  . LifecycleListener )     ( context . getBean (  \" listener \"  )  )  )  ;", "assertFalse ( lifecycleBean . isRunning (  )  )  ;", "context . start (  )  ;", "assertTrue ( lifecycleBean . isRunning (  )  )  ;", "assertEquals (  0  ,    listener . getStoppedCount (  )  )  ;", "context . stop (  )  ;", "assertFalse ( lifecycleBean . isRunning (  )  )  ;", "assertEquals (  1  ,    listener . getStoppedCount (  )  )  ;", "assertSame ( context ,    listener . getApplicationContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextStoppedEvent"], "fileName": "org.springframework.context.event.LifecycleEventTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "listener . on ( event )  ;", "}    catch    ( ClassCastException   ex )     {", "String   msg    =    ex . getMessage (  )  ;", "if    (  ( msg    =  =    null )     |  |     ( matchesClassCastMessage ( msg ,    event . getClass (  )  . getName (  )  )  )  )     {", "Log   logger    =    LogFactory . getLog ( getClass (  )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Non - matching   event   type   for   listener :     \"     +    listener )  ,    ex )  ;", "}", "} else    {", "throw   ex ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInvokeListener"], "fileName": "org.springframework.context.event.SimpleApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "return   this . errorHandler ;", "}", "METHOD_END"], "methodName": ["getErrorHandler"], "fileName": "org.springframework.context.event.SimpleApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "return   this . taskExecutor ;", "}", "METHOD_END"], "methodName": ["getTaskExecutor"], "fileName": "org.springframework.context.event.SimpleApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "ErrorHandler   errorHandler    =    getErrorHandler (  )  ;", "if    ( errorHandler    !  =    null )     {", "try    {", "doInvokeListener ( listener ,     )  ;", "}    catch    ( Throwable   err )     {", "errorHandler . handleError ( err )  ;", "}", "} else    {", "doInvokeListener ( listener ,     )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeListener"], "fileName": "org.springframework.context.event.SimpleApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "if    ( classCastMessage . startsWith ( eventClassName )  )     {", "return   true ;", "}", "int   moduleSeparatorIndex    =    classCastMessage . indexOf (  '  /  '  )  ;", "if    (  ( moduleSeparatorIndex    !  =     (  -  1  )  )     &  &     ( classCastMessage . startsWith ( eventClassName ,     ( moduleSeparatorIndex    +     1  )  )  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matchesClassCastMessage"], "fileName": "org.springframework.context.event.SimpleApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forInstance ( event )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultEventType"], "fileName": "org.springframework.context.event.SimpleApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.context.event.SimpleApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.context.event.SimpleApplicationEventMulticaster"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . delegate )     =  =    null )     {", "throw   new   IllegalStateException (  \" Must   specify   a   delegate   object   or   override   the   onApplicationEventInternal   method \"  )  ;", "}", "this . delegate . onApplicationEvent (  )  ;", "}", "METHOD_END"], "methodName": ["onApplicationEventInternal"], "fileName": "org.springframework.context.event.SourceFilteringListener"}, {"methodBody": ["METHOD_START", "{", "this . content . add ( listener . getId (  )  ,    event )  ;", "}", "METHOD_END"], "methodName": ["addEvent"], "fileName": "org.springframework.context.event.test.EventCollector"}, {"methodBody": ["METHOD_START", "{", "List < Object >    actual    =    this . content . getOrDefault ( listenerId ,    Collections . emptyList (  )  )  ;", "assertEquals (  \" Wrong   number   of   events \"  ,    events . length ,    actual . size (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( events . length )  ;    i +  +  )     {", "assertEquals (  (  \" Wrong   event   at   index    \"     +    i )  ,    events [ i ]  ,    actual . get ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertEvent"], "fileName": "org.springframework.context.event.test.EventCollector"}, {"methodBody": ["METHOD_START", "{", "assertEvent ( listener . getId (  )  ,    events )  ;", "}", "METHOD_END"], "methodName": ["assertEvent"], "fileName": "org.springframework.context.event.test.EventCollector"}, {"methodBody": ["METHOD_START", "{", "List < Object >    events    =    this . content . getOrDefault ( listenerId ,    Collections . emptyList (  )  )  ;", "assertEquals (  (  \" Expected   no   events   but   got    \"     +    events )  ,     0  ,    events . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNoEventReceived"], "fileName": "org.springframework.context.event.test.EventCollector"}, {"methodBody": ["METHOD_START", "{", "assertNoEventReceived ( listener . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNoEventReceived"], "fileName": "org.springframework.context.event.test.EventCollector"}, {"methodBody": ["METHOD_START", "{", "int   actual    =     0  ;", "for    ( Map . Entry < String ,    List < Object >  >    entry    :    thisnt . entrySet (  )  )     {", "actual    +  =    entry . getValue (  )  . size (  )  ;", "}", "assertEquals (  (  (  \" Wrong   number   of   total   events    (  \"     +     ( thisnt . size (  )  )  )     +     \"  )    registered   listener ( s )  \"  )  ,    number ,    actual )  ;", "}", "METHOD_END"], "methodName": ["assertTotalEventsCount"], "fileName": "org.springframework.context.event.test.EventCollector"}, {"methodBody": ["METHOD_START", "{", "this . content . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.context.event.test.EventCollector"}, {"methodBody": ["METHOD_START", "{", "return   this . content . get ( listener . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["getEvents"], "fileName": "org.springframework.context.event.test.EventCollector"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( first ,    second )  ;", "assertEquals ( first . hashCode (  )  ,    second . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertKeyEquals"], "fileName": "org.springframework.context.expression.AnnotatedElementKeyTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( getClass (  )  ,    name . getMethodName (  )  )  ;", "first    =    new    ( m ,    getClass (  )  )  ;", "second    =    new    ( m ,    getClass (  )  )  ;", "assertKeyEquals ( first ,    second )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.springframework.context.expression.AnnotatedElementKeyTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( getClass (  )  ,    name . getMethodName (  )  )  ;", "first    =    new    ( m ,    null )  ;", "second    =    new    ( m ,    null )  ;", "assertKeyEquals ( first ,    second )  ;", "}", "METHOD_END"], "methodName": ["equalsNoTarget"], "fileName": "org.springframework.context.expression.AnnotatedElementKeyTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( getClass (  )  ,    name . getMethodName (  )  )  ;", "first    =    new    ( m ,    getClass (  )  )  ;", "second    =    new    ( m ,    null )  ;", "assertFalse ( first . equals ( second )  )  ;", "}", "METHOD_END"], "methodName": ["noTargetClassNotEquals"], "fileName": "org.springframework.context.expression.AnnotatedElementKeyTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( getClass (  )  ,    name . getMethodName (  )  )  ;", "instance    =    new    ( m ,    getClass (  )  )  ;", "assertKeyEquals ( instance ,    instance )  ;", "}", "METHOD_END"], "methodName": ["sameInstanceEquals"], "fileName": "org.springframework.context.expression.AnnotatedElementKeyTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ac )  ;", "ac . getBeanFactory (  )  . registerScope (  \" myScope \"  ,    new   Scope (  )     {", "@ Override", "public   Object   get ( String   name ,    ObjectFactory <  ?  >    objectFactory )     {", "return   objectFactory . getObject (  )  ;", "}", "@ Override", "public   Object   remove ( String   name )     {", "return   null ;", "}", "@ Override", "public   void   registerDestructionCallback ( String   name ,    Runnable   callback )     {", "}", "@ Override", "public   Object   resolveContextualObject ( String   key )     {", "if    ( key . equals (  \" mySpecialAttr \"  )  )     {", "return    \"  4  2  \"  ;", "} else    {", "return   null ;", "}", "}", "@ Override", "public   String   getConversationId (  )     {", "return   null ;", "}", "}  )  ;", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "Properties   placeholders    =    new   Properties (  )  ;", "placeholders . setProperty (  \" code \"  ,     \"  1  2  3  \"  )  ;", "ppc . setProperties ( placeholders )  ;", "ac . addBeanFactoryPostProcessor ( ppc )  ;", "GenericBeanDefinition   bd 0     =    new   GenericBeanDefinition (  )  ;", "bd 0  . setBeanClass ( TestBean . class )  ;", "bd 0  . getPropertyValues (  )  . add (  \" name \"  ,     \" myName \"  )  ;", "bd 0  . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" original \"  )  )  ;", "ac . registerBeanDefinition (  \" tb 0  \"  ,    bd 0  )  ;", "GenericBeanDefinition   bd 1     =    new   GenericBeanDefinition (  )  ;", "bd 1  . setBeanClassName (  \"  #  { tb 0  . class }  \"  )  ;", "bd 1  . setScope (  \" myScope \"  )  ;", "bd 1  . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" XXX #  { tb 0  . name } YYY #  { mySpecialAttr } ZZZ \"  )  ;", "bd 1  . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \"  #  { mySpecialAttr }  \"  )  ;", "ac . registerBeanDefinition (  \" tb 1  \"  ,    bd 1  )  ;", "GenericBeanDefinition   bd 2     =    new   GenericBeanDefinition (  )  ;", "bd 2  . setBeanClassName (  \"  #  { tb 1  . class . name }  \"  )  ;", "bd 2  . setScope (  \" myScope \"  )  ;", "bd 2  . getPropertyValues (  )  . add (  \" name \"  ,     \"  {    XXX #  { tb 0  . name } YYY #  { mySpecialAttr } ZZZ    }  \"  )  ;", "bd 2  . getPropertyValues (  )  . add (  \" age \"  ,     \"  #  { mySpecialAttr }  \"  )  ;", "bd 2  . getPropertyValues (  )  . add (  \" country \"  ,     \"  $  { code }     #  { systemProperties . country }  \"  )  ;", "ac . registerBeanDefinition (  \" tb 2  \"  ,    bd 2  )  ;", "GenericBeanDefinition   bd 3     =    new   GenericBeanDefinition (  )  ;", "bd 3  . setBeanClass (  . ValueTestBean . class )  ;", "bd 3  . setScope (  \" myScope \"  )  ;", "ac . registerBeanDefinition (  \" tb 3  \"  ,    bd 3  )  ;", "GenericBeanDefinition   bd 4     =    new   GenericBeanDefinition (  )  ;", "bd 4  . setBeanClass (  . ConstructorValueTestBean . class )  ;", "bd 4  . setScope (  \" myScope \"  )  ;", "ac . registerBeanDefinition (  \" tb 4  \"  ,    bd 4  )  ;", "GenericBeanDefinition   bd 5     =    new   GenericBeanDefinition (  )  ;", "bd 5  . setBeanClass (  . MethodValueTestBean . class )  ;", "bd 5  . setScope (  \" myScope \"  )  ;", "ac . registerBeanDefinition (  \" tb 5  \"  ,    bd 5  )  ;", "GenericBeanDefinition   bd 6     =    new   GenericBeanDefinition (  )  ;", "bd 6  . setBeanClass (  . PropertyValueTestBean . class )  ;", "bd 6  . setScope (  \" myScope \"  )  ;", "ac . registerBeanDefinition (  \" tb 6  \"  ,    bd 6  )  ;", "System . getProperties (  )  . put (  \" country \"  ,     \" UK \"  )  ;", "try    {", "ac . refresh (  )  ;", "TestBean   tb 0     =    ac . getBean (  \" tb 0  \"  ,    TestBean . class )  ;", "TestBean   tb 1     =    ac . getBean (  \" tb 1  \"  ,    TestBean . class )  ;", "assertEquals (  \" XXXmyNameYYY 4  2 ZZZ \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  4  2  ,    tb 1  . getAge (  )  )  ;", "TestBean   tb 2     =    ac . getBean (  \" tb 2  \"  ,    TestBean . class )  ;", "assertEquals (  \"  {    XXXmyNameYYY 4  2 ZZZ    }  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  4  2  ,    tb 2  . getAge (  )  )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 2  . getCountry (  )  )  ;", ". ValueTestBean   tb 3     =    ac . getBean (  \" tb 3  \"  ,     . ValueTestBean . class )  ;", "assertEquals (  \" XXXmyNameYYY 4  2 ZZZ \"  ,    tb 3  . name )  ;", "assertEquals (  4  2  ,    tb 3  . age )  ;", "assertEquals (  4  2  ,    tb 3  . ageFactory . getObject (  )  . intValue (  )  )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 3  . country )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 3  . countryFactory . getObject (  )  )  ;", "System . getProperties (  )  . put (  \" country \"  ,     \" US \"  )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 3  . country )  ;", "assertEquals (  \"  1  2  3    US \"  ,    tb 3  . countryFactory . getObject (  )  )  ;", "System . getProperties (  )  . put (  \" country \"  ,     \" UK \"  )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 3  . country )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 3  . countryFactory . getObject (  )  )  ;", "assertSame ( tb 0  ,    tb 3  . tb )  ;", "tb 3     =     (  (  . ValueTestBean )     ( SerializationTestUtils . serializeAndDeserialize ( tb 3  )  )  )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 3  . countryFactory . getObject (  )  )  ;", ". ConstructorValueTestBean   tb 4     =    ac . getBean (  \" tb 4  \"  ,     . ConstructorValueTestBean . class )  ;", "assertEquals (  \" XXXmyNameYYY 4  2 ZZZ \"  ,    tb 4  . name )  ;", "assertEquals (  4  2  ,    tb 4  . age )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 4  . country )  ;", "assertSame ( tb 0  ,    tb 4  . tb )  ;", ". MethodValueTestBean   tb 5     =    ac . getBean (  \" tb 5  \"  ,     . MethodValueTestBean . class )  ;", "assertEquals (  \" XXXmyNameYYY 4  2 ZZZ \"  ,    tb 5  . name )  ;", "assertEquals (  4  2  ,    tb 5  . age )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 5  . country )  ;", "assertSame ( tb 0  ,    tb 5  . tb )  ;", ". PropertyValueTestBean   tb 6     =    ac . getBean (  \" tb 6  \"  ,     . PropertyValueTestBean . class )  ;", "assertEquals (  \" XXXmyNameYYY 4  2 ZZZ \"  ,    tb 6  . name )  ;", "assertEquals (  4  2  ,    tb 6  . age )  ;", "assertEquals (  \"  1  2  3    UK \"  ,    tb 6  . country )  ;", "assertSame ( tb 0  ,    tb 6  . tb )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" country \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["genericApplicationContext"], "fileName": "org.springframework.context.expression.ApplicationContextExpressionTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setScope ( SCOPE _ PROTOTYPE )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \"  #  { systemProperties . name }  \"  )  ;", "rbd . getPropertyValues (  )  . add (  \" country \"  ,     \"  #  { systemProperties . country }  \"  )  ;", "ac . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "ac . refresh (  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "System . getProperties (  )  . put (  \" name \"  ,     \" juergen \"  )  ;", "System . getProperties (  )  . put (  \" country \"  ,     \" UK \"  )  ;", "try    {", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( ac . getBean (  \" test \"  )  )  )  ;", "assertEquals (  \" juergen \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" UK \"  ,    tb . getCountry (  )  )  ;", "}", "sw . stop (  )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" country \"  )  ;", "System . getProperties (  )  . remove (  \" name \"  )  ;", "}", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     6  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["prototypeCreationIsFastEnough"], "fileName": "org.springframework.context.expression.ApplicationContextExpressionTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ac )  ;", "GenericConversionService   cs    =    new   GenericConversionService (  )  ;", "cs . addConverter ( String . class ,    String . class ,    new   Converter < String ,    String >  (  )     {", "@ Override", "public   String   convert ( String   source )     {", "return   source . trim (  )  ;", "}", "}  )  ;", "ac . getBeanFactory (  )  . registerSingleton ( GenericApplicationContext . CONVERSION _ SERVICE _ BEAN _ NAME ,    cs )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . PrototypeTestBean . class )  ;", "rbd . setScope ( SCOPE _ PROTOTYPE )  ;", "rbd . getPropertyValues (  )  . add (  \" country \"  ,     \"  #  { systemProperties . country }  \"  )  ;", "rbd . getPropertyValues (  )  . add (  \" country 2  \"  ,    new   TypedStringValue (  \"  -  #  { systemProperties . country }  -  \"  )  )  ;", "ac . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "ac . refresh (  )  ;", "try    {", "System . getProperties (  )  . put (  \" name \"  ,     \" juergen 1  \"  )  ;", "System . getProperties (  )  . put (  \" country \"  ,     \"    UK 1     \"  )  ;", ". PrototypeTestBean   tb    =     (  (  . PrototypeTestBean )     ( ac . getBean (  \" test \"  )  )  )  ;", "assertEquals (  \" juergen 1  \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" UK 1  \"  ,    tb . getCountry (  )  )  ;", "assertEquals (  \"  - UK 1  -  \"  ,    tb . getCountry 2  (  )  )  ;", "System . getProperties (  )  . put (  \" name \"  ,     \" juergen 2  \"  )  ;", "System . getProperties (  )  . put (  \" country \"  ,     \"       UK 2        \"  )  ;", "tb    =     (  (  . PrototypeTestBean )     ( ac . getBean (  \" test \"  )  )  )  ;", "assertEquals (  \" juergen 2  \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" UK 2  \"  ,    tb . getCountry (  )  )  ;", "assertEquals (  \"  - UK 2  -  \"  ,    tb . getCountry 2  (  )  )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" name \"  )  ;", "System . getProperties (  )  . remove (  \" country \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["prototypeCreationReevaluatesExpressions"], "fileName": "org.springframework.context.expression.ApplicationContextExpressionTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" logfile \"  ,     \" do _ not _ delete _ me . txt \"  )  ;", "try    ( AnnotationConfigApplicationContext   ac    =    new   AnnotationConfigApplicationContext (  . ResourceInjectionBean . class )  )     {", ". ResourceInjectionBean   resourceInjectionBean    =    ac . getBean (  . ResourceInjectionBean . class )  ;", "Resource   resource    =    new   ClassPathResource (  \" do _ not _ delete _ me . txt \"  )  ;", "assertEquals ( resource ,    resourceInjectionBean . resource )  ;", "assertEquals ( resource . getURL (  )  ,    resourceInjectionBean . url )  ;", "assertEquals ( resource . getURI (  )  ,    resourceInjectionBean . uri )  ;", "assertEquals ( resource . getFile (  )  ,    resourceInjectionBean . file )  ;", "assertArrayEquals ( FileCopyUtils . copyToByteArray ( resource . getInputStream (  )  )  ,    FileCopyUtils . copyToByteArray ( resourceInjectionBean . inputStream )  )  ;", "assertEquals ( FileCopyUtils . copyToString ( new   EncodedResource ( resource )  . getReader (  )  )  ,    FileCopyUtils . copyToString ( resourceInjectionBean . reader )  )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" logfile \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resourceInjection"], "fileName": "org.springframework.context.expression.ApplicationContextExpressionTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ac )  ;", "GenericBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setBeanClass ( String . class )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" test -  #  {    T ( System )  . currentTimeMillis (  )     }  \"  )  ;", "ac . registerBeanDefinition (  \" str \"  ,    bd )  ;", "ac . refresh (  )  ;", "String   str    =    ac . getBean (  \" str \"  ,    String . class )  ;", "assertTrue ( str . startsWith (  \" test -  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["stringConcatenationWithDebugLogging"], "fileName": "org.springframework.context.expression.ApplicationContextExpressionTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "AnnotationConfigUtils . registerAnnotationConfigProcessors ( ac )  ;", "GenericBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setBeanClass ( TestBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" country \"  ,     \"  #  { systemProperties . country }  \"  )  ;", "ac . registerBeanDefinition (  \" tb \"  ,    bd )  ;", "SecurityManager   oldSecurityManager    =    System . getSecurityManager (  )  ;", "try    {", "System . setProperty (  \" country \"  ,     \" NL \"  )  ;", "SecurityManager   securityManager    =    new   SecurityManager (  )     {", "@ Override", "public   void   checkPropertiesAccess (  )     {", "throw   new   AccessControlException (  \" Not   Allowed \"  )  ;", "}", "@ Override", "public   void   checkPermission ( Permission   perm )     {", "}", "}  ;", "System . setSecurityManager ( securityManager )  ;", "ac . refresh (  )  ;", "TestBean   tb    =    ac . getBean (  \" tb \"  ,    TestBean . class )  ;", "assertEquals (  \" NL \"  ,    tb . getCountry (  )  )  ;", "}    finally    {", "System . setSecurityManager ( oldSecurityManager )  ;", "System . getProperties (  )  . remove (  \" country \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["systemPropertiesSecurityManager"], "fileName": "org.springframework.context.expression.ApplicationContextExpressionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   CachedExpressionEvaluator . ExpressionKey ( elementKey ,    expression )  ;", "}", "METHOD_END"], "methodName": ["createKey"], "fileName": "org.springframework.context.expression.CachedExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "CachedExpressionEvaluator . ExpressionKey   expressionKey    =    createKey ( elementKey ,    expression )  ;", "Expression   expr    =    cache . get ( expressionKey )  ;", "if    ( expr    =  =    null )     {", "expr    =    getParser (  )  . parseExpression ( expression )  ;", "cache . put ( expressionKey ,    expr )  ;", "}", "return   expr ;", "}", "METHOD_END"], "methodName": ["getExpression"], "fileName": "org.springframework.context.expression.CachedExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["getParameterNameDiscoverer"], "fileName": "org.springframework.context.expression.CachedExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "return   this . parser ;", "}", "METHOD_END"], "methodName": ["getParser"], "fileName": "org.springframework.context.expression.CachedExpressionEvaluator"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" toString \"  )  ;", "e . getTestExpression (  \" true \"  ,    method ,    getClass (  )  )  ;", "e . getTestExpression (  \" true \"  ,    method ,    getClass (  )  )  ;", "e . getTestExpression (  \" true \"  ,    method ,    getClass (  )  )  ;", "hasParsedExpression (  \" true \"  )  ;", "assertEquals (  \" Only   one   expression   should   be   in   cache \"  ,     1  ,    e . testCache . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheExpression"], "fileName": "org.springframework.context.expression.CachedExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" toString \"  )  ;", "e . getTestExpression (  \" true \"  ,    method ,    getClass (  )  )  ;", "e . getTestExpression (  \" true \"  ,    method ,    Object . class )  ;", "assertEquals (  \" Cached   expression   should   be   based   on   type \"  ,     2  ,    e . testCache . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheExpressionBasedOnConcreteType"], "fileName": "org.springframework.context.expression.CachedExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "verify ( expressionEvaluator . getParser (  )  ,    times (  1  )  )  . parseExpression ( expression )  ;", "}", "METHOD_END"], "methodName": ["hasParsedExpression"], "fileName": "org.springframework.context.expression.CachedExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" toString \"  )  ;", "Expression   expression    =    e . getTestExpression (  \" true \"  ,    method ,    getClass (  )  )  ;", "hasParsedExpression (  \" true \"  )  ;", "assertEquals ( true ,    expression . getValue (  )  )  ;", "assertEquals (  \" Expression   should   be   in   cache \"  ,     1  ,    e . testCache . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseNewExpression"], "fileName": "org.springframework.context.expression.CachedExpressionEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  #  { environment [  ' my . name '  ]  }  \"  )  . getBeanDefinition (  )  )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext ( bf )  ;", "ctx . get (  )  . getPropertySources (  )  . addFirst ( new   MockPropertySource (  )  . withProperty (  \" my . name \"  ,     \" myBean \"  )  )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" myBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["braceAccess"], "fileName": "org.springframework.context.expression.EnvironmentAccessorIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setBeanResolver ( new    . SimpleBeanResolver (  )  )  ;", "Expression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ car . colour \"  )  ;", "assertEquals (  \" red \"  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  & car . class . name \"  )  ;", "assertEquals (  . SimpleBeanResolver . CarFactoryBean . class . getName (  )  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ boat . colour \"  )  ;", "assertEquals (  \" blue \"  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  & boat . class . name \"  )  ;", "try    {", "assertEquals (  . SimpleBeanResolver . Boat . class . getName (  )  ,    expr . getValue ( context )  )  ;", "fail (  \" Expected   BeanIsNotAFactoryException \"  )  ;", "}    catch    ( BeanIsNotAFactoryException   binafe )     {", "}", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ truck \"  )  ;", "assertEquals (  \" red \"  ,    expr . getValue ( context )  )  ;", "fail (  \" Expected   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   nsbde )     {", "}", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  & truck \"  )  ;", "assertEquals (  . SimpleBeanResolver . CarFactoryBean . class . getName (  )  ,    expr . getValue ( context )  )  ;", "fail (  \" Expected   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   nsbde )     {", "}", "}", "METHOD_END"], "methodName": ["factoryBeanAccess"], "fileName": "org.springframework.context.expression.FactoryBeanAccessTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "Map < String ,    Map < String ,    Object >  >    map 2     =    new   HashMap <  >  (  )  ;", "map 2  . put (  \" aaa \"  ,    map )  ;", "return   map 2  ;", "}", "METHOD_END"], "methodName": ["getNestedTestMap"], "fileName": "org.springframework.context.expression.MapAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["getSimpleTestMap"], "fileName": "org.springframework.context.expression.MapAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    testMap    =    getSimpleTestMap (  )  ;", "StandardEvaluationContext   sec    =    new   StandardEvaluationContext (  )  ;", "sec . addPropertyAccessor ( new   MapAccessor (  )  )  ;", "SpelExpressionParser   sep    =    new   SpelExpressionParser (  )  ;", "Expression   ex    =    sep . parseExpression (  \" foo \"  )  ;", "assertEquals (  \" bar \"  ,    ex . getValue ( sec ,    testMap )  )  ;", "assertTrue ( SpelCompiler . compile ( ex )  )  ;", "assertEquals (  \" bar \"  ,    ex . getValue ( sec ,    testMap )  )  ;", "ex    =    sep . parseExpression (  \" foo . toUpperCase (  )  \"  )  ;", "assertEquals (  \" BAR \"  ,    ex . getValue ( sec ,    testMap )  )  ;", "assertTrue ( SpelCompiler . compile ( ex )  )  ;", "assertEquals (  \" BAR \"  ,    ex . getValue ( sec ,    testMap )  )  ;", "Map < String ,    Map < String ,    Object >  >    nestedMap    =    getNestedTestMap (  )  ;", "ex    =    sep . parseExpression (  \" aaa . foo . toUpperCase (  )  \"  )  ;", "assertEquals (  \" BAR \"  ,    ex . getValue ( sec ,    nestedMap )  )  ;", "assertTrue ( SpelCompiler . compile ( ex )  )  ;", "assertEquals (  \" BAR \"  ,    ex . getValue ( sec ,    nestedMap )  )  ;", "ex    =    sep . parseExpression (  \" getMap (  )  . foo \"  )  ;", ". MapGetter   mapGetter    =    new    . MapGetter (  )  ;", "assertEquals (  \" bar \"  ,    ex . getValue ( sec ,    mapGetter )  )  ;", "assertTrue ( SpelCompiler . compile ( ex )  )  ;", "assertEquals (  \" bar \"  ,    ex . getValue ( sec ,    mapGetter )  )  ;", "}", "METHOD_END"], "methodName": ["mapAccessorCompilable"], "fileName": "org.springframework.context.expression.MapAccessorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( this . arguments )  )     {", "return ;", "}", "String [  ]    paramNames    =    this . parameterNameDiscoverer . getParameterNames ( this . m )  ;", "int   paramCount    =     ( paramNames    !  =    null )     ?    paramNames . length    :    this . m . getParameterCount (  )  ;", "int   argsCount    =    this . arguments . length ;", "for    ( int   i    =     0  ;    i    <    paramCount ;    i +  +  )     {", "Object   value    =    null ;", "if    (  ( argsCount    >    paramCount )     &  &     ( i    =  =     ( paramCount    -     1  )  )  )     {", "value    =    Arrays . copyOfRange ( this . arguments ,    i ,    argsCount )  ;", "} else", "if    ( argsCount    >    i )     {", "value    =    this . arguments [ i ]  ;", "}", "setVariable (  (  \" a \"     +    i )  ,    value )  ;", "setVariable (  (  \" p \"     +    i )  ,    value )  ;", "if    ( paramNames    !  =    null )     {", "setVariable ( paramNames [ i ]  ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["lazyLoadArguments"], "fileName": "org.springframework.context.expression.MethodBasedEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodBasedEvaluationContext ( this ,    method ,    args ,    this . paramDiscover )  ;", "}", "METHOD_END"], "methodName": ["createEvaluationContext"], "fileName": "org.springframework.context.expression.MethodBasedEvaluationContextTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( MethodBasedEvaluationContextTests . SampleMethods . class ,     \" hello \"  ,    String . class ,    Boolean . class )  ;", "MethodBasedEvaluationContext   context    =    createEvaluationContext ( method ,    null ,    null )  ;", "assertNull ( context . lookupVariable (  \" a 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" foo \"  )  )  ;", "assertNull ( context . lookupVariable (  \" a 1  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 1  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" flag \"  )  )  ;", "}", "METHOD_END"], "methodName": ["nullArgument"], "fileName": "org.springframework.context.expression.MethodBasedEvaluationContextTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( MethodBasedEvaluationContextTests . SampleMethods . class ,     \" hello \"  ,    String . class ,    Boolean . class )  ;", "MethodBasedEvaluationContext   context    =    createEvaluationContext ( method ,     \" test \"  ,    true )  ;", "assertEquals (  \" test \"  ,    context . lookupVariable (  \" a 0  \"  )  )  ;", "assertEquals (  \" test \"  ,    context . lookupVariable (  \" p 0  \"  )  )  ;", "assertEquals (  \" test \"  ,    context . lookupVariable (  \" foo \"  )  )  ;", "assertEquals ( true ,    context . lookupVariable (  \" a 1  \"  )  )  ;", "assertEquals ( true ,    context . lookupVariable (  \" p 1  \"  )  )  ;", "assertEquals ( true ,    context . lookupVariable (  \" flag \"  )  )  ;", "assertNull ( context . lookupVariable (  \" a 2  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleArguments"], "fileName": "org.springframework.context.expression.MethodBasedEvaluationContextTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( MethodBasedEvaluationContextTests . SampleMethods . class ,     \" hello \"  ,    Boolean . class ,    String [  ]  . class )  ;", "MethodBasedEvaluationContext   context    =    createEvaluationContext ( method ,    new   Object [  ]  {    null    }  )  ;", "assertNull ( context . lookupVariable (  \" a 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" flag \"  )  )  ;", "assertNull ( context . lookupVariable (  \" a 1  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 1  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" vararg \"  )  )  ;", "}", "METHOD_END"], "methodName": ["varArgEmpty"], "fileName": "org.springframework.context.expression.MethodBasedEvaluationContextTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( MethodBasedEvaluationContextTests . SampleMethods . class ,     \" hello \"  ,    Boolean . class ,    String [  ]  . class )  ;", "MethodBasedEvaluationContext   context    =    createEvaluationContext ( method ,    null ,     \" hello \"  ,     \" hi \"  )  ;", "assertNull ( context . lookupVariable (  \" a 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" flag \"  )  )  ;", "assertArrayEquals ( new   Object [  ]  {     \" hello \"  ,     \" hi \"     }  ,     (  ( Object [  ]  )     ( context . lookupVariable (  \" a 1  \"  )  )  )  )  ;", "assertArrayEquals ( new   Object [  ]  {     \" hello \"  ,     \" hi \"     }  ,     (  ( Object [  ]  )     ( context . lookupVariable (  \" p 1  \"  )  )  )  )  ;", "assertArrayEquals ( new   Object [  ]  {     \" hello \"  ,     \" hi \"     }  ,     (  ( Object [  ]  )     ( context . lookupVariable (  \" vararg \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["varArgMultiple"], "fileName": "org.springframework.context.expression.MethodBasedEvaluationContextTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( MethodBasedEvaluationContextTests . SampleMethods . class ,     \" hello \"  ,    Boolean . class ,    String [  ]  . class )  ;", "MethodBasedEvaluationContext   context    =    createEvaluationContext ( method ,    null ,    null )  ;", "assertNull ( context . lookupVariable (  \" a 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" flag \"  )  )  ;", "assertNull ( context . lookupVariable (  \" a 1  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 1  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" vararg \"  )  )  ;", "}", "METHOD_END"], "methodName": ["varArgNull"], "fileName": "org.springframework.context.expression.MethodBasedEvaluationContextTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( MethodBasedEvaluationContextTests . SampleMethods . class ,     \" hello \"  ,    Boolean . class ,    String [  ]  . class )  ;", "MethodBasedEvaluationContext   context    =    createEvaluationContext ( method ,    null ,     \" hello \"  )  ;", "assertNull ( context . lookupVariable (  \" a 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" p 0  \"  )  )  ;", "assertNull ( context . lookupVariable (  \" flag \"  )  )  ;", "assertEquals (  \" hello \"  ,    context . lookupVariable (  \" a 1  \"  )  )  ;", "assertEquals (  \" hello \"  ,    context . lookupVariable (  \" p 1  \"  )  )  ;", "assertEquals (  \" hello \"  ,    context . lookupVariable (  \" vararg \"  )  )  ;", "}", "METHOD_END"], "methodName": ["varArgSingle"], "fileName": "org.springframework.context.expression.MethodBasedEvaluationContextTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNullParser ,     \" ExpressionParser   must   not   be   null \"  )  ;", "thisParser    = Parser ;", "}", "METHOD_END"], "methodName": ["setExpressionParser"], "fileName": "org.springframework.context.expression.StandardBeanExpressionResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . hasTextPrefix ,     \" Expression   prefix   must   not   be   empty \"  )  ;", "thisPrefix    = Prefix ;", "}", "METHOD_END"], "methodName": ["setExpressionPrefix"], "fileName": "org.springframework.context.expression.StandardBeanExpressionResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . hasTextSuffix ,     \" Expression   suffix   must   not   be   empty \"  )  ;", "thisSuffix    = Suffix ;", "}", "METHOD_END"], "methodName": ["setExpressionSuffix"], "fileName": "org.springframework.context.expression.StandardBeanExpressionResolver"}, {"methodBody": ["METHOD_START", "{", "new   GenericGroovyApplicationContext (  \" org / springframework / context / groovy / applicationContext - error . groovy \"  )  ;", "}", "METHOD_END"], "methodName": ["testConfigFileParsingError"], "fileName": "org.springframework.context.groovy.GroovyApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericGroovyApplicationContext   ctx    =    new   GenericGroovyApplicationContext (  \" org / springframework / context / groovy / applicationContext . groovy \"  )  ;", "Object   framework    =    ctx . getBean (  \" framework \"  )  ;", "assertNotNull (  \" could   not   find   framework   bean \"  ,    framework )  ;", "assertEquals (  \" Grails \"  ,    framework )  ;", "}", "METHOD_END"], "methodName": ["testLoadingConfigFile"], "fileName": "org.springframework.context.groovy.GroovyApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericGroovyApplicationContext   ctx    =    new   GenericGroovyApplicationContext (  \" org / springframework / context / groovy / applicationContext 2  . groovy \"  ,     \" org / springframework / context / groovy / applicationContext . groovy \"  )  ;", "Object   framework    =    ctx . getBean (  \" framework \"  )  ;", "assertNotNull (  \" could   not   find   framework   bean \"  ,    framework )  ;", "assertEquals (  \" Grails \"  ,    framework )  ;", "Object   company    =    ctx . getBean (  \" company \"  )  ;", "assertNotNull (  \" could   not   find   company   bean \"  ,    company )  ;", "assertEquals (  \" SpringSource \"  ,    company )  ;", "}", "METHOD_END"], "methodName": ["testLoadingMultipleConfigFiles"], "fileName": "org.springframework.context.groovy.GroovyApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericGroovyApplicationContext   ctx    =    new   GenericGroovyApplicationContext (  )  ;", "ctx . load (  . class ,     \" applicationContext 2  . groovy \"  ,     \" applicationContext . groovy \"  )  ;", "ctx . refresh (  )  ;", "Object   framework    =    ctx . getBean (  \" framework \"  )  ;", "assertNotNull (  \" could   not   find   framework   bean \"  ,    framework )  ;", "assertEquals (  \" Grails \"  ,    framework )  ;", "Object   company    =    ctx . getBean (  \" company \"  )  ;", "assertNotNull (  \" could   not   find   company   bean \"  ,    company )  ;", "assertEquals (  \" SpringSource \"  ,    company )  ;", "}", "METHOD_END"], "methodName": ["testLoadingMultipleConfigFilesWithRelativeClass"], "fileName": "org.springframework.context.groovy.GroovyApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "return   LocaleContextHolder . getLocale ( LocaleContextHolder . getLocaleContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLocale"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( localeContext    !  =    null )     {", "Locale   locale    =    localeContext . getLocale (  )  ;", "if    ( locale    !  =    null )     {", "return   locale ;", "}", "}", "return    (  . defaultLocale )     !  =    null    ?     . defaultLocale    :    Locale . getDefault (  )  ;", "}", "METHOD_END"], "methodName": ["getLocale"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContext   localeContext    =    LocaleContextHolder . localeContextHolder . get (  )  ;", "if    ( localeContext    =  =    null )     {", "localeContext    =    LocaleContextHolder . inheritableLocaleContextHolder . get (  )  ;", "}", "return   localeContext ;", "}", "METHOD_END"], "methodName": ["getLocaleContext"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "return   LocaleContextHolder . getTimeZone ( LocaleContextHolder . getLocaleContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTimeZone"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( localeContext   instanceof   TimeZoneAwareLocaleContext )     {", "TimeZone   timeZone    =     (  ( TimeZoneAwareLocaleContext )     ( localeContext )  )  . getTimeZone (  )  ;", "if    ( timeZone    !  =    null )     {", "return   timeZone ;", "}", "}", "return    (  . defaultTimeZone )     !  =    null    ?     . defaultTimeZone    :    TimeZone . getDefault (  )  ;", "}", "METHOD_END"], "methodName": ["getTimeZone"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . localeContextHolder . remove (  )  ;", "LocaleContextHolder . inheritableLocaleContextHolder . remove (  )  ;", "}", "METHOD_END"], "methodName": ["resetLocaleContext"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . defaultLocale    =    locale ;", "}", "METHOD_END"], "methodName": ["setDefaultLocale"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . defaultTimeZone    =    timeZone ;", "}", "METHOD_END"], "methodName": ["setDefaultTimeZone"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( locale ,    false )  ;", "}", "METHOD_END"], "methodName": ["setLocale"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContext   localeContext    =    LocaleContextHolder . getLocaleContext (  )  ;", "TimeZone   timeZone    =     ( localeContext   instanceof   TimeZoneAwareLocaleContext )     ?     (  ( TimeZoneAwareLocaleContext )     ( localeContext )  )  . getTimeZone (  )     :    null ;", "if    ( timeZone    !  =    null )     {", "localeContext    =    new   SimpleTimeZoneAwareLocaleContext ( locale ,    timeZone )  ;", "} else", "if    ( locale    !  =    null )     {", "localeContext    =    new   SimpleLocaleContext ( locale )  ;", "} else    {", "localeContext    =    null ;", "}", "LocaleContextHolder . setLocaleContext ( localeContext ,    inheritable )  ;", "}", "METHOD_END"], "methodName": ["setLocale"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocaleContext ( localeContext ,    false )  ;", "}", "METHOD_END"], "methodName": ["setLocaleContext"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( localeContext    =  =    null )     {", ". resetLocaleContext (  )  ;", "} else    {", "if    ( inheritable )     {", ". inheritable . set ( localeContext )  ;", ". localeContextHolder . remove (  )  ;", "} else    {", ". localeContextHolder . set ( localeContext )  ;", ". inheritable . remove (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setLocaleContext"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setTimeZone ( timeZone ,    false )  ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContext   localeContext    =    LocaleContextHolder . getLocaleContext (  )  ;", "Locale   locale    =     ( localeContext    !  =    null )     ?    localeContext . getLocale (  )     :    null ;", "if    ( timeZone    !  =    null )     {", "localeContext    =    new   SimpleTimeZoneAwareLocaleContext ( locale ,    timeZone )  ;", "} else", "if    ( locale    !  =    null )     {", "localeContext    =    new   SimpleLocaleContext ( locale )  ;", "} else    {", "localeContext    =    null ;", "}", "LocaleContextHolder . setLocaleContext ( localeContext ,    inheritable )  ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.context.i18n.LocaleContextHolder"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertFalse (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMANY )  ;", "assertEquals ( Locale . GERMANY ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertFalse (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertEquals ( Locale . GERMANY ,    LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "LocaleContextHolder . setLocale ( null )  ;", "assertNull ( LocaleContextHolder . getLocaleContext (  )  )  ;", "assertEquals ( Locale . getDefault (  )  ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "LocaleContextHolder . setDefaultLocale ( Locale . GERMAN )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocale (  )  )  ;", "LocaleContextHolder . setDefaultLocale ( null )  ;", "assertEquals ( Locale . getDefault (  )  ,    LocaleContextHolder . getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetLocale"], "fileName": "org.springframework.context.i18n.LocaleContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( Locale . GERMANY )  ;", "assertEquals ( Locale . GERMANY ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertFalse (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertEquals ( Locale . GERMANY ,    LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "LocaleContextHolder . setTimeZone ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  )  ;", "assertEquals ( Locale . GERMANY ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertTrue (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertEquals ( Locale . GERMANY ,    LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  ,     (  ( TimeZoneAwareLocaleContext )     ( LocaleContextHolder . getLocaleContext (  )  )  )  . getTimeZone (  )  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertTrue (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  ,     (  ( TimeZoneAwareLocaleContext )     ( LocaleContextHolder . getLocaleContext (  )  )  )  . getTimeZone (  )  )  ;", "LocaleContextHolder . setTimeZone ( null )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertFalse (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "LocaleContextHolder . setTimeZone ( TimeZone . getTimeZone (  \" GMT +  2  \"  )  )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  2  \"  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertTrue (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertEquals ( Locale . GERMAN ,    LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  2  \"  )  ,     (  ( TimeZoneAwareLocaleContext )     ( LocaleContextHolder . getLocaleContext (  )  )  )  . getTimeZone (  )  )  ;", "LocaleContextHolder . setLocale ( null )  ;", "assertEquals ( Locale . getDefault (  )  ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  2  \"  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertTrue (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertNull ( LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  2  \"  )  ,     (  ( TimeZoneAwareLocaleContext )     ( LocaleContextHolder . getLocaleContext (  )  )  )  . getTimeZone (  )  )  ;", "LocaleContextHolder . setTimeZone ( null )  ;", "assertEquals ( Locale . getDefault (  )  ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertNull ( LocaleContextHolder . getLocaleContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetLocaleAndSetTimeZoneMixed"], "fileName": "org.springframework.context.i18n.LocaleContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "LocaleContext   lc    =    new   SimpleLocaleContext ( Locale . GERMAN )  ;", ". setLocaleContext ( lc )  ;", "assertSame ( lc ,     . getLocaleContext (  )  )  ;", "assertEquals ( Locale . GERMAN ,     . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,     . getTimeZone (  )  )  ;", "lc    =    new   SimpleLocaleContext ( Locale . GERMANY )  ;", ". setLocaleContext ( lc )  ;", "assertSame ( lc ,     . getLocaleContext (  )  )  ;", "assertEquals ( Locale . GERMANY ,     . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,     . getTimeZone (  )  )  ;", ". resetLocaleContext (  )  ;", "assertNull (  . getLocaleContext (  )  )  ;", "assertEquals ( Locale . getDefault (  )  ,     . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,     . getTimeZone (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetLocaleContext"], "fileName": "org.springframework.context.i18n.LocaleContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setTimeZone ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  )  ;", "assertEquals ( Locale . getDefault (  )  ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertTrue (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertNull ( LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  ,     (  ( TimeZoneAwareLocaleContext )     ( LocaleContextHolder . getLocaleContext (  )  )  )  . getTimeZone (  )  )  ;", "LocaleContextHolder . setTimeZone ( TimeZone . getTimeZone (  \" GMT +  2  \"  )  )  ;", "assertEquals ( Locale . getDefault (  )  ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  2  \"  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "assertTrue (  (  ( LocaleContextHolder . getLocaleContext (  )  )    instanceof   TimeZoneAwareLocaleContext )  )  ;", "assertNull ( LocaleContextHolder . getLocaleContext (  )  . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  2  \"  )  ,     (  ( TimeZoneAwareLocaleContext )     ( LocaleContextHolder . getLocaleContext (  )  )  )  . getTimeZone (  )  )  ;", "LocaleContextHolder . setTimeZone ( null )  ;", "assertNull ( LocaleContextHolder . getLocaleContext (  )  )  ;", "assertEquals ( Locale . getDefault (  )  ,    LocaleContextHolder . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "LocaleContextHolder . setDefaultTimeZone ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "LocaleContextHolder . setDefaultTimeZone ( null )  ;", "assertEquals ( TimeZone . getDefault (  )  ,    LocaleContextHolder . getTimeZone (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetTimeZone"], "fileName": "org.springframework.context.i18n.LocaleContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "LocaleContext   lc    =    new   SimpleTimeZoneAwareLocaleContext ( Locale . GERMANY ,    TimeZone . getTimeZone (  \" GMT +  1  \"  )  )  ;", ". setLocaleContext ( lc )  ;", "assertSame ( lc ,     . getLocaleContext (  )  )  ;", "assertEquals ( Locale . GERMANY ,     . getLocale (  )  )  ;", "assertEquals ( TimeZone . getTimeZone (  \" GMT +  1  \"  )  ,     . getTimeZone (  )  )  ;", ". resetLocaleContext (  )  ;", "assertNull (  . getLocaleContext (  )  )  ;", "assertEquals ( Locale . getDefault (  )  ,     . getLocale (  )  )  ;", "assertEquals ( TimeZone . getDefault (  )  ,     . getTimeZone (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetTimeZoneAwareLocaleContext"], "fileName": "org.springframework.context.i18n.LocaleContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "List < CandidateComponentsIndex . Entry >    candidates    =    this . index . get ( stereotype )  ;", "if    ( candidates    !  =    null )     {", "return   candidates . parallelStream (  )  . filter (  (    t )     -  >    t . match ( basePackage )  )  . map (  (    t )     -  >    t . type )  . collect ( Collectors . toSet (  )  )  ;", "}", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getCandidateTypes"], "fileName": "org.springframework.context.index.CandidateComponentsIndex"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    CandidateComponentsIndex . Entry >    index    =    new   LinkedMultiValueMap (  )  ;", "for    ( Properties   entry    :    content )     {", "entry . forEach (  (    type ,    values )     -  >     {", "String [  ]    stereotypes    =     (  ( String )     ( values )  )  . split (  \"  ,  \"  )  ;", "for    ( String   stereotype    :    stereotypes )     {", "index . add ( stereotype ,    new   CandidateComponentsIndex . Entry (  (  ( String )     ( type )  )  )  )  ;", "}", "}  )  ;", "}", "return   index ;", "}", "METHOD_END"], "methodName": ["parseIndex"], "fileName": "org.springframework.context.index.CandidateComponentsIndex"}, {"methodBody": ["METHOD_START", "{", "if    ( CandidateComponentsIndexLoader . shouldIgnoreIndex )     {", "return   null ;", "}", "try    {", "Enumeration < URL >    urls    =    classLoader . getResources ( CandidateComponentsIndexLoader . COMPONENTS _ RESOURCE _ LOCATION )  ;", "if    (  !  ( urls . hasMoreElements (  )  )  )     {", "return   null ;", "}", "List < Properties >    result    =    new   ArrayList <  >  (  )  ;", "while    ( urls . hasMoreElements (  )  )     {", "URL   url    =    urls . nextElement (  )  ;", "Properties   properties    =    PropertiesLoaderUtils . loadProperties ( new   UrlResource ( url )  )  ;", "result . add ( properties )  ;", "}", "if    ( CandidateComponentsIndexLoader . logger . isDebugEnabled (  )  )     {", "CandidateComponentsIndexLoader . logger . debug (  (  (  \" Loaded    \"     +     ( result . size (  )  )  )     +     \"  ]    index ( es )  \"  )  )  ;", "}", "int   totalCount    =    result . stream (  )  . mapToInt ( Properties :  : size )  . sum (  )  ;", "return   totalCount    >     0     ?    new   CandidateComponentsIndex ( result )     :    null ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Unable   to   load   indexes   from   location    [  \"     +     ( CandidateComponentsIndexLoader . COMPONENTS _ RESOURCE _ LOCATION )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doLoadIndex"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoader"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   classLoaderToUse    =    classLoader ;", "if    ( classLoaderToUse    =  =    null )     {", "classLoaderToUse    =     . class . getClassLoader (  )  ;", "}", "return    . cache . computeIfAbsent ( classLoaderToUse ,     :  : doLoadIndex )  ;", "}", "METHOD_END"], "methodName": ["loadIndex"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoader"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    CandidateComponentsIndexLoader . loadIndex ( CandidateComponentsTestClassLoader . index ( getClass (  )  . getClassLoader (  )  ,    new   ClassPathResource (  \" empty - spring . components \"  ,    getClass (  )  )  )  )  ;", "assertThat ( index ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["loadIndexNoEntry"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoaderTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    CandidateComponentsIndexLoader . loadIndex ( CandidateComponentsTestClassLoader . index ( getClass (  )  . getClassLoader (  )  ,    new   ClassPathResource (  \" spring . components \"  ,    getClass (  )  )  )  )  ;", "Set < String >    components    =    index . getCandidateTypes (  \" springframework \"  ,     \" none \"  )  ;", "assertThat ( components ,    hasSize (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["loadIndexNoMatch"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoaderTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    CandidateComponentsIndexLoader . loadIndex ( CandidateComponentsTestClassLoader . index ( getClass (  )  . getClassLoader (  )  ,    new   ClassPathResource (  \" spring . components \"  ,    getClass (  )  )  )  )  ;", "Set < String >    components    =    index . getCandidateTypes (  \" com . example \"  ,     \" foo \"  )  ;", "assertThat ( components ,    hasSize (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["loadIndexNoPackage"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoaderTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    CandidateComponentsIndexLoader . loadIndex ( CandidateComponentsTestClassLoader . disableIndex ( getClass (  )  . getClassLoader (  )  )  )  ;", "assertThat ( index ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["loadIndexNoSpringComponentsResource"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoaderTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    CandidateComponentsIndexLoader . loadIndex ( CandidateComponentsTestClassLoader . index ( getClass (  )  . getClassLoader (  )  ,    new   ClassPathResource (  \" spring . components \"  ,    getClass (  )  )  )  )  ;", "Set < String >    components    =    index . getCandidateTypes (  \" springframework \"  ,     \" foo \"  )  ;", "assertThat ( components ,    containsInAnyOrder (  \" Sample 1  \"  ,     \" Sample 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["loadIndexSeveralMatches"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoaderTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    CandidateComponentsIndexLoader . loadIndex ( CandidateComponentsTestClassLoader . index ( getClass (  )  . getClassLoader (  )  ,    new   ClassPathResource (  \" spring . components \"  ,    getClass (  )  )  )  )  ;", "Set < String >    components    =    index . getCandidateTypes (  \" springframework \"  ,     \" biz \"  )  ;", "assertThat ( components ,    containsInAnyOrder (  \" Sample 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["loadIndexSingleMatch"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoaderTests"}, {"methodBody": ["METHOD_START", "{", "final   IOException   cause    =    new   IOException (  \" test   exception \"  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" Unable   to   load   indexes \"  )  ;", "this . thrown . expectCause ( is ( cause )  )  ;", ". loadIndex ( new   CandidateComponentsTestClassLoader ( getClass (  )  . getClassLoader (  )  ,    cause )  )  ;", "}", "METHOD_END"], "methodName": ["loadIndexWithException"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoaderTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    CandidateComponentsIndexLoader . loadIndex ( null )  ;", "assertThat (  \" No   spring . components   should   be   available   at   the   default   location \"  ,    index ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["validateIndexIsDisabledByDefault"], "fileName": "org.springframework.context.index.CandidateComponentsIndexLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    new   Properties (  )  ;", "properties . put ( key ,    St . join (  \"  ,  \"  ,    stereotypes )  )  ;", "return   properties ;", "}", "METHOD_END"], "methodName": ["createProperties"], "fileName": "org.springframework.context.index.CandidateComponentsIndexTests"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    new   Properties (  )  ;", "properties . put (  \" com . example . service . One \"  ,     \" service \"  )  ;", "properties . put (  \" com . example . service . sub . Two \"  ,     \" service \"  )  ;", "properties . put (  \" com . example . service . Three \"  ,     \" service \"  )  ;", "properties . put (  \" com . example . domain . Four \"  ,     \" ity \"  )  ;", "return   properties ;", "}", "METHOD_END"], "methodName": ["createSampleProperties"], "fileName": "org.springframework.context.index.CandidateComponentsIndexTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    new   CandidateComponentsIndex ( Collections . singletonList ( CandidateComponentsIndexTests . createSampleProperties (  )  )  )  ;", "Set < String >    actual    =    index . getCandidateTypes (  \" com . example . service \"  ,     \" service \"  )  ;", "assertThat ( actual ,    containsInAnyOrder (  \" com . example . service . One \"  ,     \" com . example . service . sub . Two \"  ,     \" com . example . service . Three \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getCandidateTypes"], "fileName": "org.springframework.context.index.CandidateComponentsIndexTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    new   CandidateComponentsIndex ( Collections . singletonList ( CandidateComponentsIndexTests . createSampleProperties (  )  )  )  ;", "Set < String >    actual    =    index . getCandidateTypes (  \" com . example . service \"  ,     \" entity \"  )  ;", "assertThat ( actual ,    hasSize (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getCandidateTypesNoMatch"], "fileName": "org.springframework.context.index.CandidateComponentsIndexTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    new   CandidateComponentsIndex ( Collections . singletonList ( CandidateComponentsIndexTests . createSampleProperties (  )  )  )  ;", "Set < String >    actual    =    index . getCandidateTypes (  \" com . example . service . sub \"  ,     \" service \"  )  ;", "assertThat ( actual ,    containsInAnyOrder (  \" com . example . service . sub . Two \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getCandidateTypesSubPackage"], "fileName": "org.springframework.context.index.CandidateComponentsIndexTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    new   CandidateComponentsIndex ( Collections . singletonList ( CandidateComponentsIndexTests . createSampleProperties (  )  )  )  ;", "Set < String >    actual    =    index . getCandidateTypes (  \" com . example . service . none \"  ,     \" service \"  )  ;", "assertThat ( actual ,    hasSize (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getCandidateTypesSubPackageNoMatch"], "fileName": "org.springframework.context.index.CandidateComponentsIndexTests"}, {"methodBody": ["METHOD_START", "{", "CandidateComponentsIndex   index    =    new   CandidateComponentsIndex ( Arrays . asList ( CandidateComponentsIndexTests . createProperties (  \" com . example . Foo \"  ,     \" service \"  )  ,    CandidateComponentsIndexTests . createProperties (  \" com . example . Foo \"  ,     \" entity \"  )  )  )  ;", "assertThat ( index . getCandidateTypes (  \" com . example \"  ,     \" service \"  )  ,    contains (  \" com . example . Foo \"  )  )  ;", "assertThat ( index . getCandidateTypes (  \" com . example \"  ,     \" entity \"  )  ,    contains (  \" com . example . Foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeCandidateStereotypes"], "fileName": "org.springframework.context.index.CandidateComponentsIndexTests"}, {"methodBody": ["METHOD_START", "{", "return   new   CandidateComponentsTestClassLoader ( classLoader ,    Collections . enumeration ( Collections . emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["disableIndex"], "fileName": "org.springframework.context.index.CandidateComponentsTestClassLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   CandidateComponentsTestClassLoader ( classLoader ,    Collections . enumeration ( Stream . of ( resources )  . map (  (    r )     -  >     {", "try    {", "return   r . getURL (  )  ;", "}    catch    (    ex )     {", "throw   new    < ex > IllegalArgumentException (  (  \" Invalid   resource    \"     +    r )  )  ;", "}", "}  )  . collect ( Collectors . toList (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["index"], "fileName": "org.springframework.context.index.CandidateComponentsTestClassLoader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . active . get (  )  )  )     {", "if    ( this . closed . get (  )  )     {", "throw   new   IllegalStateExcep (  (  ( getDisplayName (  )  )     +     \"    has   been   closed   already \"  )  )  ;", "} else    {", "throw   new   IllegalStateExcep (  (  ( getDisplayName (  )  )     +     \"    has   not   been   refreshed   yet \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertBeanFactoryActive"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . active . set ( false )  ;", "}", "METHOD_END"], "methodName": ["cancelRefresh"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["createEnvironment"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "close (  )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "getBeanFactory (  )  . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["destroyBeans"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . active . get (  )  )     &  &     ( this . closed . compareAndSet ( false ,    true )  )  )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Closing    \"     +     ( this )  )  )  ;", "}", "LiveBeansView . unregister ( this )  ;", "try    {", "publishEvent ( new   ContextClosedEvent ( this )  )  ;", "}    catch    ( Throwable   ex )     {", "logger . warn (  \" Exception   thrown   from   ApplicationListener   handling   ContextClosedEvent \"  ,    ex )  ;", "}", "if    (  ( this . lifecycleProcessor )     !  =    null )     {", "try    {", "this . lifecycleProcessor . onClose (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . warn (  \" Exception   thrown   from   LifecycleProcessor   on   context   close \"  ,    ex )  ;", "}", "}", "destroyBeans (  )  ;", "closeBeanFactory (  )  ;", "onClose (  )  ;", "this . active . set ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["doClose"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( beanFactory . containsBean ( ConfigurableApplicationContext . CONVERSION _ SERVICE _ BEAN _ NAME )  )     &  &     ( beanFactory . isTypeMatch ( ConfigurableApplicationContext . CONVERSION _ SERVICE _ BEAN _ NAME ,    ConversionService . class )  )  )     {", "beanFactory . setConversionService ( beanFactory . getBean ( ConfigurableApplicationContext . CONVERSION _ SERVICE _ BEAN _ NAME ,    ConversionService . class )  )  ;", "}", "if    (  !  ( beanFactory . hasEmbeddedValueResolver (  )  )  )     {", "beanFactory . addEmbeddedValueResolver (  (    strVal )     -  >    getEnvironment (  )  . resolvePlaceholders ( strVal )  )  ;", "}", "String [  ]    weaverAwareNames    =    beanFactory . getBeanNamesForType ( LoadTimeWeaverAware . class ,    false ,    false )  ;", "for    ( String   weaverAwareName    :    weaverAwareNames )     {", "getBean ( weaverAwareName )  ;", "}", "beanFactory . setTempClassLoader ( null )  ;", "beanFactory . freezeConfiguration (  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["finishBeanFactoryInitialization"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "clearResourceCaches (  )  ;", "initLifecycleProcessor (  )  ;", "getLifecycleProcessor (  )  . onRefresh (  )  ;", "publishEvent ( new   ContextRefreshedEvent ( this )  )  ;", "LiveBeansView . register ( this )  ;", "}", "METHOD_END"], "methodName": ["finishRefresh"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . applicationEventMulticaster )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" EventMulticaster   not   initialized    -     \"     +     \" call    ' refresh '    before   multicasting   events   via   the   context :     \"  )     +     ( this )  )  )  ;", "}", "return   this . applicationEventMulticaster ;", "}", "METHOD_END"], "methodName": ["getApplicationEventMulticaster"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationListeners ;", "}", "METHOD_END"], "methodName": ["getApplicationListeners"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactoryPostProcessors ;", "}", "METHOD_END"], "methodName": ["getBeanFactoryPostProcessors"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return    ( getParent (  )  )    instanceof   ConfigurableApplicationContext    ?     (  ( ConfigurableApplicationContext )     ( getParent (  )  )  )  . getBeanFactory (  )     :    getParent (  )  ;", "}", "METHOD_END"], "methodName": ["getInternalParentBeanFactory"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return    ( getParent (  )  )    instanceof   AbstractApplicationContext    ?     (  ( AbstractApplicationContext )     ( getParent (  )  )  )  . messageSource    :    getParent (  )  ;", "}", "METHOD_END"], "methodName": ["getInternalParentMessageSource"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . lifecycleProcessor )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" LifecycleProcessor   not   initialized    -     \"     +     \" call    ' refresh '    before   invoking   lifecycle   methods   via   the    :     \"  )     +     ( this )  )  )  ;", "}", "return   this . lifecycleProcessor ;", "}", "METHOD_END"], "methodName": ["getLifecycleProcessor"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . messageSource )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" MessageSource   not   initialized    -     \"     +     \" call    ' refresh '    before   accessing   messages   via   the    :     \"  )     +     ( this )  )  )  ;", "}", "return   this . messageSource ;", "}", "METHOD_END"], "methodName": ["getMessageSource"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   new   PathMatchingResourcePatternResolver ( this )  ;", "}", "METHOD_END"], "methodName": ["getResourcePatternResolver"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "ConfigurableListableBeanFactory   beanFactory    =    getBeanFactory (  )  ;", "if    ( beanFactory . containsLocalBean (  . APPLICATION _ EVENT _ MULTICASTER _ BEAN _ NAME )  )     {", "this . applicationEventMulticaster    =    beanFactory . getBean (  . APPLICATION _ EVENT _ MULTICASTER _ BEAN _ NAME ,    ApplicationEventMulticaster . class )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Using   ApplicationEventMulticaster    [  \"     +     ( this . applicationEventMulticaster )  )     +     \"  ]  \"  )  )  ;", "}", "} else    {", "this . applicationEventMulticaster    =    new   SimpleApplicationEventMulticaster ( beanFactory )  ;", "beanFactory . registerSingleton (  . APPLICATION _ EVENT _ MULTICASTER _ BEAN _ NAME ,    this . applicationEventMulticaster )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Unable   to   locate   ApplicationEventMulticaster   with   name    '  \"     +     (  . APPLICATION _ EVENT _ MULTICASTER _ BEAN _ NAME )  )     +     \"  '  :    using   default    [  \"  )     +     ( this . applicationEventMulticaster )  )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initApplicationEventMulticaster"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "ConfigurableListableBeanFactory   beanFactory    =    getBeanFactory (  )  ;", "if    ( beanFactory . containsLocalBean (  . LIFECYCLE _ PROCESSOR _ BEAN _ NAME )  )     {", "this . lifecycleProcessor    =    beanFactory . getBean (  . LIFECYCLE _ PROCESSOR _ BEAN _ NAME ,    LifecycleProcessor . class )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Using   LifecycleProcessor    [  \"     +     ( this . lifecycleProcessor )  )     +     \"  ]  \"  )  )  ;", "}", "} else    {", "DefaultLifecycleProcessor   defaultProcessor    =    new   DefaultLifecycleProcessor (  )  ;", "defaultProcessor . setBeanFactory ( beanFactory )  ;", "this . lifecycleProcessor    =    defaultProcessor ;", "beanFactory . registerSingleton (  . LIFECYCLE _ PROCESSOR _ BEAN _ NAME ,    this . lifecycleProcessor )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Unable   to   locate   LifecycleProcessor   with   name    '  \"     +     (  . LIFECYCLE _ PROCESSOR _ BEAN _ NAME )  )     +     \"  '  :    using   default    [  \"  )     +     ( this . lifecycleProcessor )  )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initLifecycleProcessor"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "ConfigurableListableBeanFactory   beanFactory    =    getBeanFactory (  )  ;", "if    ( beanFactory . containsLocalBean (  . MESSAGE _ SOURCE _ BEAN _ NAME )  )     {", "this . messageSource    =    beanFactory . getBean (  . MESSAGE _ SOURCE _ BEAN _ NAME ,    MessageSource . class )  ;", "if    (  (  ( this . parent )     !  =    null )     &  &     (  ( this . messageSource )    instanceof   HierarchicalMessageSource )  )     {", "HierarchicalMessageSource   hms    =     (  ( HierarchicalMessageSource )     ( this . messageSource )  )  ;", "if    (  ( hms . getParentMessageSource (  )  )     =  =    null )     {", "hms . setParentMessageSource ( getInternalParentMessageSource (  )  )  ;", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Using   MessageSource    [  \"     +     ( this . messageSource )  )     +     \"  ]  \"  )  )  ;", "}", "} else    {", "DelegatingMessageSource   dms    =    new   DelegatingMessageSource (  )  ;", "dms . setParentMessageSource ( getInternalParentMessageSource (  )  )  ;", "this . messageSource    =    dms ;", "beanFactory . registerSingleton (  . MESSAGE _ SOURCE _ BEAN _ NAME ,    this . messageSource )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Unable   to   locate   MessageSource   with   name    '  \"     +     (  . MESSAGE _ SOURCE _ BEAN _ NAME )  )     +     \"  '  :    using   default    [  \"  )     +     ( this . messageSource )  )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initMessageSource"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "PostProcessorRegistrationDelegate . invokeBeanFactoryPostProcessors ( beanFactory ,    getBeanFactoryPostProcessors (  )  )  ;", "if    (  (  ( beanFactory . getTempClassLoader (  )  )     =  =    null )     &  &     ( beanFactory . containsBean ( Configurable . LOAD _ TIME _ WEAVER _ BEAN _ NAME )  )  )     {", "beanFactory . addBeanPostProcessor ( new   LoadTimeWeaverAwareProcessor ( beanFactory )  )  ;", "beanFactory . setTempClassLoader ( new   ContextTypeMatchClassLoader ( beanFactory . getBeanClassLoader (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeBeanFactoryPostProcessors"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "refreshBeanFactory (  )  ;", "ConfigurableListableBeanFactory   beanFactory    =    getBeanFactory (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Bean   factory   for    \"     +     ( getDisplayName (  )  )  )     +     \"  :     \"  )     +    beanFactory )  )  ;", "}", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["obtainFreshBeanFactory"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "beanFactory . setBeanClassLoader ( getClassLoader (  )  )  ;", "beanFactory . setBeanExpressionResolver ( new   StandardBeanExpressionResolver ( beanFactory . getBeanClassLoader (  )  )  )  ;", "beanFactory . addPropertyEditorRegistrar ( new   beans . support . ResourceEditorRegistrar ( this ,    getEnvironment (  )  )  )  ;", "beanFactory . addBeanPostProcessor ( new   ApplicationContextAwareProcessor ( this )  )  ;", "beanFactory . ignoreDependencyInterface ( EnvironmentAware . class )  ;", "beanFactory . ignoreDependencyInterface ( EmbeddedValueResolverAware . class )  ;", "beanFactory . ignoreDependencyInterface ( ResourceLoaderAware . class )  ;", "beanFactory . ignoreDependencyInterface ( ApplicationEventPublisherAware . class )  ;", "beanFactory . ignoreDependencyInterface ( MessageSourceAware . class )  ;", "beanFactory . ignoreDependencyInterface ( ApplicationContextAware . class )  ;", "beanFactory . registerResolvableDependency ( BeanFactory . class ,    beanFactory )  ;", "beanFactory . registerResolvableDependency ( ResourceLoader . class ,    this )  ;", "beanFactory . registerResolvableDependency ( ApplicationEventPublisher . class ,    this )  ;", "beanFactory . registerResolvableDependency ( ApplicationContext . class ,    this )  ;", "beanFactory . addBeanPostProcessor ( new   ApplicationListenerDetector ( this )  )  ;", "if    ( beanFactory . containsBean ( ConfigurableApplicationContext . LOAD _ TIME _ WEAVER _ BEAN _ NAME )  )     {", "beanFactory . addBeanPostProcessor ( new   LoadTimeWeaverAwareProcessor ( beanFactory )  )  ;", "beanFactory . setTempClassLoader ( new   ContextTypeMatchClassLoader ( beanFactory . getBeanClassLoader (  )  )  )  ;", "}", "if    (  !  ( beanFactory . containsLocalBean ( ConfigurableApplicationContext . ENVIRONMENT _ BEAN _ NAME )  )  )     {", "beanFactory . registerSingleton ( ConfigurableApplicationContext . ENVIRONMENT _ BEAN _ NAME ,    getEnvironment (  )  )  ;", "}", "if    (  !  ( beanFactory . containsLocalBean ( ConfigurableApplicationContext . SYSTEM _ PROPERTIES _ BEAN _ NAME )  )  )     {", "beanFactory . registerSingleton ( ConfigurableApplicationContext . SYSTEM _ PROPERTIES _ BEAN _ NAME ,    getEnvironment (  )  . getSystemProperties (  )  )  ;", "}", "if    (  !  ( beanFactory . containsLocalBean ( ConfigurableApplicationContext . SYSTEM _ ENVIRONMENT _ BEAN _ NAME )  )  )     {", "beanFactory . registerSingleton ( ConfigurableApplicationContext . SYSTEM _ ENVIRONMENT _ BEAN _ NAME ,    getEnvironment (  )  . getSystemEnvironment (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareBeanFactory"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . startupDate    =    System . currentTimeMillis (  )  ;", "this . closed . set ( false )  ;", "this . active . set ( true )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Refreshing    \"     +     ( this )  )  )  ;", "}", "initPropertySources (  )  ;", "getEnvironment (  )  . validateRequiredProperties (  )  ;", "this . earlyEvents    =    new   LinkedHashSet <  >  (  )  ;", "}", "METHOD_END"], "methodName": ["prepareRefresh"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( event ,     \" Event   must   not   be   null \"  )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Publishing   event   in    \"     +     ( getDisplayName (  )  )  )     +     \"  :     \"  )     +    event )  )  ;", "}", "ApplicationEvent   applicationEvent ;", "if    ( event   instanceof   ApplicationEvent )     {", "applicationEvent    =     (  ( ApplicationEvent )     ( event )  )  ;", "} else    {", "applicationEvent    =    new   PayloadApplicationEvent <  >  ( this ,    event )  ;", "if    ( eventType    =  =    null )     {", "eventType    =     (  ( PayloadApplicationEvent )     ( applicationEvent )  )  . getResolvableType (  )  ;", "}", "}", "if    (  ( this . earlyApplicationEvents )     !  =    null )     {", "this . earlyApplicationEvents . add ( applicationEvent )  ;", "} else    {", "getApplicationEventMulticaster (  )  . multicastEvent ( applicationEvent ,    eventType )  ;", "}", "if    (  ( this . parent )     !  =    null )     {", "if    (  ( this . parent )    instanceof    )     {", "(  (  )     ( this . parent )  )  . publishEvent ( event ,    eventType )  ;", "} else    {", "this . parent . publishEvent ( event )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["publishEvent"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "PostProcessorRegistrationDelegate . registerBeanPostProcessors ( beanFactory ,    this )  ;", "}", "METHOD_END"], "methodName": ["registerBeanPostProcessors"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "for    ( ApplicationListener <  ?  >    listener    :    getApplicationListeners (  )  )     {", "getApplicationEventMulticaster (  )  . addApplicationListener ( listener )  ;", "}", "String [  ]    listenerBeanNames    =    getBeanNamesForType ( ApplicationListener . class ,    true ,    false )  ;", "for    ( String   listenerBeanName    :    listenerBeanNames )     {", "getApplicationEventMulticaster (  )  . addApplicationListenerBean ( listenerBeanName )  ;", "}", "Set < ApplicationEvent >    earlyEventsToProcess    =    this . earlyApplicationEvents ;", "this . earlyApplicationEvents    =    null ;", "if    ( earlyEventsToProcess    !  =    null )     {", "for    ( ApplicationEvent   earlyEvent    :    earlyEventsToProcess )     {", "getApplicationEventMulticaster (  )  . multicastEvent ( earlyEvent )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerListeners"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtils . clearCache (  )  ;", "AnnotUtils . clearCache (  )  ;", "ResolvableType . clearCache (  )  ;", "CachedIntrospectionResults . clearClassLoader ( getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["resetCommonCaches"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( displayName ,     \" Display   name   must   not   be   empty \"  )  ;", "this . displayName    =    displayName ;", "}", "METHOD_END"], "methodName": ["setDisplayName"], "fileName": "org.springframework.context.support.AbstractApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . commonMessages ;", "}", "METHOD_END"], "methodName": ["getCommonMessages"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "if    ( isUseCodeAsDefaultMessage (  )  )     {", "return   code ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultMessage"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "String   defaultMessage    =    resolvable . getDefaultMessage (  )  ;", "String [  ]    codes    =    resolvable . getCodes (  )  ;", "if    ( defaultMessage    !  =    null )     {", "if    (  (  !  ( ObjectUtils . isEmpty ( codes )  )  )     &  &     ( defaultMessage . equals ( codes [  0  ]  )  )  )     {", "return   defaultMessage ;", "}", "return   renderDefaultMessage ( defaultMessage ,    resolvable . getArguments (  )  ,    locale )  ;", "}", "return    !  ( ObjectUtils . isEmpty ( codes )  )     ?    getDefaultMessage ( codes [  0  ]  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDefaultMessage"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "MessageSource   parent    =    getParentMessageSource (  )  ;", "if    ( parent    !  =    null )     {", "if    ( parent   instanceof    )     {", "return    (  (  )     ( parent )  )  . getMessageInternal ( code ,    args ,    locale )  ;", "} else    {", "return   parent . getMessage ( code ,    args ,    null ,    locale )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMessageFromParent"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "if    ( code    =  =    null )     {", "return   null ;", "}", "if    ( locale    =  =    null )     {", "locale    =    Locale . getDefault (  )  ;", "}", "Object [  ]    argsToUse    =    args ;", "if    (  (  !  ( isAlwaysUseMessageFormat (  )  )  )     &  &     ( ObjectUtils . isEmpty ( args )  )  )     {", "String   message    =    resolveCodeWithoutArguments ( code ,    locale )  ;", "if    ( message    !  =    null )     {", "return   message ;", "}", "} else    {", "argsToUse    =    resolveArguments ( args ,    locale )  ;", "MessageFormat   messageFormat    =    resolveCode ( code ,    locale )  ;", "if    ( messageFormat    !  =    null )     {", "synchronized ( messageFormat )     {", "return   messageFormat . format ( argsToUse )  ;", "}", "}", "}", "Properties   commonMessages    =    getCommonMessages (  )  ;", "if    ( commonMessages    !  =    null )     {", "String   commonMessage    =    commonMessages . getProperty ( code )  ;", "if    ( commonMessage    !  =    null )     {", "return   forma ( commonMessage ,    args ,    locale )  ;", "}", "}", "return   geFromParent ( code ,    argsToUse ,    locale )  ;", "}", "METHOD_END"], "methodName": ["getMessageInternal"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   this . useCodeAsDefaultMessage ;", "}", "METHOD_END"], "methodName": ["isUseCodeAsDefaultMessage"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "MessageFormat   messageFormat    =    resolveCode ( code ,    locale )  ;", "if    ( messageFormat    !  =    null )     {", "synchronized ( messageFormat )     {", "return   messageFormat . format ( new   Object [  0  ]  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveCodeWithoutArguments"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . commonMessages    =    commonMessages ;", "}", "METHOD_END"], "methodName": ["setCommonMessages"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . useCodeAsDefaultMessage    =    useCodeAsDefaultMessage ;", "}", "METHOD_END"], "methodName": ["setUseCodeAsDefaultMessage"], "fileName": "org.springframework.context.support.AbstractMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultListableBeanFactory ( getInternalParentBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBeanFactory"], "fileName": "org.springframework.context.support.AbstractRefreshableApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . allowBeanDefinitionOverriding )     !  =    null )     {", "beanFactory . setAllowBeanDefinitionOverriding ( this . allowBeanDefinitionOverriding )  ;", "}", "if    (  ( this . allowCircularReferences )     !  =    null )     {", "beanFactory . setAllowCircularReferences ( this . allowCircularReferences )  ;", "}", "}", "METHOD_END"], "methodName": ["customizeBeanFactory"], "fileName": "org.springframework.context.support.AbstractRefreshableApplicationContext"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . beanFactoryMonitor )     {", "return    ( this . beanFactory )     !  =    null ;", "}", "}", "METHOD_END"], "methodName": ["hasBeanFactory"], "fileName": "org.springframework.context.support.AbstractRefreshableApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . allowBeanDefinitionOverriding    =    allowBeanDefinitionOverriding ;", "}", "METHOD_END"], "methodName": ["setAllowBeanDefinitionOverriding"], "fileName": "org.springframework.context.support.AbstractRefreshableApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . allowCircularReferences    =    allowCircularReferences ;", "}", "METHOD_END"], "methodName": ["setAllowCircularReferences"], "fileName": "org.springframework.context.support.AbstractRefreshableApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return    ( this . configLocations )     !  =    null    ?    this . configLocations    :    getDefaultConfigLocations (  )  ;", "}", "METHOD_END"], "methodName": ["getConfigLocations"], "fileName": "org.springframework.context.support.AbstractRefreshableConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultConfigLocations"], "fileName": "org.springframework.context.support.AbstractRefreshableConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   getEnvironment (  )  . resolveRequiredPlaceholders ( path )  ;", "}", "METHOD_END"], "methodName": ["resolvePath"], "fileName": "org.springframework.context.support.AbstractRefreshableConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "setConfigLocations ( StringUtils . tokenizeToStringArray ( location ,    ConfigurableApplicationContext . CONFIG _ LOCATION _ DELIMITERS )  )  ;", "}", "METHOD_END"], "methodName": ["setConfigLocation"], "fileName": "org.springframework.context.support.AbstractRefreshableConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    ( locations    !  =    null )     {", "Assert . noNullElements ( locations ,     \" Config   locations   must   not   be   null \"  )  ;", "this . configLocations    =    new   String [ locations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( locations . length )  ;    i +  +  )     {", "this . configLocations [ i ]     =    resolvePath ( locations [ i ]  )  . trim (  )  ;", "}", "} else    {", "this . configLocations    =    null ;", "}", "}", "METHOD_END"], "methodName": ["setConfigLocations"], "fileName": "org.springframework.context.support.AbstractRefreshableConfigApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . isEmpty ( basenames )  )  )     {", "for    ( St   basename    :    basenames )     {", "Assert . hasText ( basename ,     \" Basename   must   not   be   empty \"  )  ;", "this . basenameSet . add ( basename . trim (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addBasenames"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   this . basenameSet ;", "}", "METHOD_END"], "methodName": ["getBasenameSet"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheMillis ;", "}", "METHOD_END"], "methodName": ["getCacheMillis"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultEncoding ;", "}", "METHOD_END"], "methodName": ["getDefaultEncoding"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   this . fallbackToSystemLocale ;", "}", "METHOD_END"], "methodName": ["isFallbackToSystemLocale"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "setBasenames ( basename )  ;", "}", "METHOD_END"], "methodName": ["setBasename"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . basenameSet . clear (  )  ;", "addnames ( basenames )  ;", "}", "METHOD_END"], "methodName": ["setBasenames"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . cacheMillis    =    cacheMillis ;", "}", "METHOD_END"], "methodName": ["setCacheMillis"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . cacheMillis    =    cacheSeconds    *     1  0  0  0  ;", "}", "METHOD_END"], "methodName": ["setCacheSeconds"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . defaultEncoding    =    defaultEncoding ;", "}", "METHOD_END"], "methodName": ["setDefaultEncoding"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . fallbackToSystemLocale    =    fallbackToSystemLocale ;", "}", "METHOD_END"], "methodName": ["setFallbackToSystemLocale"], "fileName": "org.springframework.context.support.AbstractResourceBasedMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getConfigResources"], "fileName": "org.springframework.context.support.AbstractXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "reader . setValidating ( this . validating )  ;", "}", "METHOD_END"], "methodName": ["initBeanDefinitionReader"], "fileName": "org.springframework.context.support.AbstractXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    configResources    =    getConfigResources (  )  ;", "if    ( configResources    !  =    null )     {", "reader . loadBeanDefinitions ( configResources )  ;", "}", "String [  ]    configLos    =    getConfigLos (  )  ;", "if    ( configLos    !  =    null )     {", "reader . loadBeanDefinitions ( configLos )  ;", "}", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.context.support.AbstractXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . validating    =    validating ;", "}", "METHOD_END"], "methodName": ["setValidating"], "fileName": "org.springframework.context.support.AbstractXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    ( bean   instanceof   Aware )     {", "if    ( bean   instanceof   EnvironmentAware )     {", "(  ( EnvironmentAware )     ( bean )  )  . setEnvironment ( this . applicationContext . getEnvironment (  )  )  ;", "}", "if    ( bean   instanceof   EmbeddedValueResolverAware )     {", "(  ( EmbeddedValueResolverAware )     ( bean )  )  . setEmbeddedValueResolver ( this . embeddedValueResolver )  ;", "}", "if    ( bean   instanceof   ResourceLoaderAware )     {", "(  ( ResourceLoaderAware )     ( bean )  )  . setResourceLoader ( this . applicationContext )  ;", "}", "if    ( bean   instanceof   ApplicationEventPublisherAware )     {", "(  ( ApplicationEventPublisherAware )     ( bean )  )  . setApplicationEventPublisher ( this . applicationContext )  ;", "}", "if    ( bean   instanceof   MessageSourceAware )     {", "(  ( MessageSourceAware )     ( bean )  )  . setMessageSource ( this . applicationContext )  ;", "}", "if    ( bean   instanceof    )     {", "(  (  )     ( bean )  )  . setApplicationContext ( this . applicationContext )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokeAwareInterfaces"], "fileName": "org.springframework.context.support.ApplicationContextAwareProcessor"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" lifecycleTests . xml \"  ,    getClass (  )  )  ;", "context . start (  )  ;", "LifecycleTestBean   bean 1     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 1  \"  )  )  )  ;", "LifecycleTestBean   bean 2     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 2  \"  )  )  )  ;", "LifecycleTestBean   bean 3     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 3  \"  )  )  )  ;", "LifecycleTestBean   bean 4     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 4  \"  )  )  )  ;", "String   error    =     \" bean   was   not   started \"  ;", "assertTrue ( error ,    bean 1  . isRunning (  )  )  ;", "assertTrue ( error ,    bean 2  . isRunning (  )  )  ;", "assertTrue ( error ,    bean 3  . isRunning (  )  )  ;", "assertTrue ( error ,    bean 4  . isRunning (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeansStart"], "fileName": "org.springframework.context.support.ApplicationContextLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" lifecycleTests . xml \"  ,    getClass (  )  )  ;", "context . start (  )  ;", "LifecycleTestBean   bean 1     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 1  \"  )  )  )  ;", "LifecycleTestBean   bean 2     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 2  \"  )  )  )  ;", "LifecycleTestBean   bean 3     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 3  \"  )  )  )  ;", "LifecycleTestBean   bean 4     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 4  \"  )  )  )  ;", "String   startError    =     \" bean   was   not   started \"  ;", "assertTrue ( startError ,    bean 1  . isRunning (  )  )  ;", "assertTrue ( startError ,    bean 2  . isRunning (  )  )  ;", "assertTrue ( startError ,    bean 3  . isRunning (  )  )  ;", "assertTrue ( startError ,    bean 4  . isRunning (  )  )  ;", "context . stop (  )  ;", "String   stopError    =     \" bean   was   not   stopped \"  ;", "assertFalse ( stopError ,    bean 1  . isRunning (  )  )  ;", "assertFalse ( stopError ,    bean 2  . isRunning (  )  )  ;", "assertFalse ( stopError ,    bean 3  . isRunning (  )  )  ;", "assertFalse ( stopError ,    bean 4  . isRunning (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeansStop"], "fileName": "org.springframework.context.support.ApplicationContextLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" lifecycleTests . xml \"  ,    getClass (  )  )  ;", "context . start (  )  ;", "LifecycleTestBean   bean 1     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 1  \"  )  )  )  ;", "LifecycleTestBean   bean 2     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 2  \"  )  )  )  ;", "LifecycleTestBean   bean 3     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 3  \"  )  )  )  ;", "LifecycleTestBean   bean 4     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 4  \"  )  )  )  ;", "String   notStartedError    =     \" bean   was   not   started \"  ;", "assertTrue ( notStartedError ,     (  ( bean 1  . getStartOrder (  )  )     >     0  )  )  ;", "assertTrue ( notStartedError ,     (  ( bean 2  . getStartOrder (  )  )     >     0  )  )  ;", "assertTrue ( notStartedError ,     (  ( bean 3  . getStartOrder (  )  )     >     0  )  )  ;", "assertTrue ( notStartedError ,     (  ( bean 4  . getStartOrder (  )  )     >     0  )  )  ;", "String   orderError    =     \" dependent   bean   must   start   after   the   bean   it   depends   on \"  ;", "assertTrue ( orderError ,     (  ( bean 2  . getStartOrder (  )  )     >     ( bean 1  . getStartOrder (  )  )  )  )  ;", "assertTrue ( orderError ,     (  ( bean 3  . getStartOrder (  )  )     >     ( bean 2  . getStartOrder (  )  )  )  )  ;", "assertTrue ( orderError ,     (  ( bean 4  . getStartOrder (  )  )     >     ( bean 2  . getStartOrder (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStartOrder"], "fileName": "org.springframework.context.support.ApplicationContextLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" lifecycleTests . xml \"  ,    getClass (  )  )  ;", "context . start (  )  ;", "context . stop (  )  ;", "LifecycleTestBean   bean 1     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 1  \"  )  )  )  ;", "LifecycleTestBean   bean 2     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 2  \"  )  )  )  ;", "LifecycleTestBean   bean 3     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 3  \"  )  )  )  ;", "LifecycleTestBean   bean 4     =     (  ( LifecycleTestBean )     ( context . getBean (  \" bean 4  \"  )  )  )  ;", "String   notStoppedError    =     \" bean   was   not   stopped \"  ;", "assertTrue ( notStoppedError ,     (  ( bean 1  . getStopOrder (  )  )     >     0  )  )  ;", "assertTrue ( notStoppedError ,     (  ( bean 2  . getStopOrder (  )  )     >     0  )  )  ;", "assertTrue ( notStoppedError ,     (  ( bean 3  . getStopOrder (  )  )     >     0  )  )  ;", "assertTrue ( notStoppedError ,     (  ( bean 4  . getStopOrder (  )  )     >     0  )  )  ;", "String   orderError    =     \" dependent   bean   must   stop   before   the   bean   it   depends   on \"  ;", "assertTrue ( orderError ,     (  ( bean 2  . getStopOrder (  )  )     <     ( bean 1  . getStopOrder (  )  )  )  )  ;", "assertTrue ( orderError ,     (  ( bean 3  . getStopOrder (  )  )     <     ( bean 2  . getStopOrder (  )  )  )  )  ;", "assertTrue ( orderError ,     (  ( bean 4  . getStopOrder (  )  )     <     ( bean 2  . getStopOrder (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStopOrder"], "fileName": "org.springframework.context.support.ApplicationContextLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . applicationContext )     =  =    null )     &  &     ( isContextRequired (  )  )  )     {", "throw   new   IllegalStateException (  (  (  \"    instance    [  \"     +     ( this )  )     +     \"  ]    does   not   run   in   an   ApplicationContext \"  )  )  ;", "}", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.context.support.ApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . messageSourceAccessor )     =  =    null )     &  &     ( isContextRequired (  )  )  )     {", "throw   new   IllegalStateException (  (  (  \"    instance    [  \"     +     ( this )  )     +     \"  ]    does   not   run   in   an   ApplicationContext \"  )  )  ;", "}", "return   this . messageSourceAccessor ;", "}", "METHOD_END"], "methodName": ["getMessageSourceAccessor"], "fileName": "org.springframework.context.support.ApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "initApplicationContext (  )  ;", "}", "METHOD_END"], "methodName": ["initApplicationContext"], "fileName": "org.springframework.context.support.ApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isContextRequired"], "fileName": "org.springframework.context.support.ApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    getApplicationContext (  )  ;", "Assert . state (  ( applicationContext    !  =    null )  ,     \" No   ApplicationContext \"  )  ;", "return   applicationContext ;", "}", "METHOD_END"], "methodName": ["obtainApplicationContext"], "fileName": "org.springframework.context.support.ApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "return   ApplicationContext . class ;", "}", "METHOD_END"], "methodName": ["requiredContextClass"], "fileName": "org.springframework.context.support.ApplicationObjectSupport"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  \" Bean    \"     +     ( name )  )  )  ;", "l . output (  )  ;", "}", "METHOD_END"], "methodName": ["output"], "fileName": "org.springframework.context.support.Assembler"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setBeanName"], "fileName": "org.springframework.context.support.Assembler"}, {"methodBody": ["METHOD_START", "{", "this . l    =    l ;", "}", "METHOD_END"], "methodName": ["setLogic"], "fileName": "org.springframework.context.support.Assembler"}, {"methodBody": ["METHOD_START", "{", "this . service    =    service ;", "}", "METHOD_END"], "methodName": ["setService"], "fileName": "org.springframework.context.support.Assembler"}, {"methodBody": ["METHOD_START", "{", "return   messageSource ;", "}", "METHOD_END"], "methodName": ["getMessageSource"], "fileName": "org.springframework.context.support.AutowiredService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . messageSource )     !  =    null )     {", "throw   new   IllegalArgumentException (  \" MessageSource   should   not   be   set   tw \"  )  ;", "}", "this . messageSource    =    messageSource ;", "}", "METHOD_END"], "methodName": ["setMessageSource"], "fileName": "org.springframework.context.support.AutowiredService"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class )  ;", "ac . registerSingleton (  \" tb 2  \"  ,    TestBean . class )  ;", "ac . addBeanFactoryPostProcessor ( new    . PrioritizedBeanDefinitionRegistryPostProcessor (  )  )  ;", ". TestBeanDefinitionRegistryPostProcessor   bdrpp    =    new    . TestBeanDefinitionRegistryPostProcessor (  )  ;", "ac . addBeanFactoryPostProcessor ( bdrpp )  ;", "assertFalse ( bdrpp . wasCalled )  ;", "ac . refresh (  )  ;", "assertTrue ( bdrpp . wasCalled )  ;", "assertTrue ( ac . getBean (  \" bfpp 1  \"  ,     . TestBeanFactoryPostProcessor . class )  . wasCalled )  ;", "assertTrue ( ac . getBean (  \" bfpp 2  \"  ,     . TestBeanFactoryPostProcessor . class )  . wasCalled )  ;", "}", "METHOD_END"], "methodName": ["testBeanDefinitionRegistryPostProcessor"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class )  ;", "ac . registerSingleton (  \" tb 2  \"  ,    TestBean . class )  ;", "ac . registerBeanDefinition (  \" bdrpp 2  \"  ,    new   RootBeanDefinition (  . OuterBeanDefinitionRegistryPostProcessor . class )  )  ;", "ac . refresh (  )  ;", "assertTrue ( ac . getBean (  \" bfpp 1  \"  ,     . TestBeanFactoryPostProcessor . class )  . wasCalled )  ;", "assertTrue ( ac . getBean (  \" bfpp 2  \"  ,     . TestBeanFactoryPostProcessor . class )  . wasCalled )  ;", "}", "METHOD_END"], "methodName": ["testBeanDefinitionRegistryPostProcessorRegisteringAnother"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bfpp \"  ,    new   RootBeanDefinition (  . ListeningBeanFactoryPostProcessor . class )  )  ;", "ac . refresh (  )  ;", "assertTrue (  (  ( ac . getBean (  . ListeningBeanFactoryPostProcessor . class )  . received )    instanceof   ContextRefreshedEvent )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanFactoryPostProcessorAsApplicationListener"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" tb 1  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . registerBeanDefinition (  \" tb 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . registerBeanDefinition (  \" bfpp \"  ,    new   RootBeanDefinition (  . TestBeanFactoryPostProcessor . class )  )  ;", ". TestBeanFactoryPostProcessor   bfpp    =     (  (  . TestBeanFactoryPostProcessor )     ( bf . getBean (  \" bfpp \"  )  )  )  ;", "assertFalse ( bfpp . wasCalled )  ;", "}", "METHOD_END"], "methodName": ["testBeanFactoryPostProcessorNotExecutedByBeanFactory"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . NestingBeanFactoryPostProcessor . class )  ;", "rbd . getPropertyValues (  )  . add (  \" listeningBean \"  ,    new   RootBeanDefinition (  . ListeningBean . class )  )  ;", "ac . registerBeanDefinition (  \" bfpp \"  ,    rbd )  ;", "ac . refresh (  )  ;", "assertTrue (  (  ( ac . getBean (  . NestingBeanFactoryPostProcessor . class )  . getListeningBean (  )  . received )    instanceof   ContextRefreshedEvent )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanFactoryPostProcessorWithInnerBeanAsApplicationListener"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class )  ;", "ac . registerSingleton (  \" tb 2  \"  ,    TestBean . class )  ;", "ac . registerSingleton (  \" bfpp \"  ,     . TestBeanFactoryPostProcessor . class )  ;", "ac . refresh (  )  ;", ". TestBeanFactoryPostProcessor   bfpp    =     (  (  . TestBeanFactoryPostProcessor )     ( ac . getBean (  \" bfpp \"  )  )  )  ;", "assertTrue ( bfpp . wasCalled )  ;", "}", "METHOD_END"], "methodName": ["testDefinedBeanFactoryPostProcessor"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class )  ;", "ac . registerSingleton (  \" tb 2  \"  ,    TestBean . class )  ;", "MutablePropertyValues   pvs 1     =    new   MutablePropertyValues (  )  ;", "pvs 1  . add (  \" initValue \"  ,     \"  $  { key }  \"  )  ;", "ac . registerSingleton (  \" bfpp 1  \"  ,     . TestBeanFactoryPostProcessor . class ,    pvs 1  )  ;", "MutablePropertyValues   pvs 2     =    new   MutablePropertyValues (  )  ;", "pvs 2  . add (  \" properties \"  ,     \" key = value \"  )  ;", "ac . registerSingleton (  \" bfpp 2  \"  ,    PropertyPlaceholderConfigurer . class ,    pvs 2  )  ;", "ac . refresh (  )  ;", ". TestBeanFactoryPostProcessor   bfpp    =     (  (  . TestBeanFactoryPostProcessor )     ( ac . getBean (  \" bfpp 1  \"  )  )  )  ;", "assertEquals (  \" value \"  ,    bfpp . initValue )  ;", "assertTrue ( bfpp . wasCalled )  ;", "}", "METHOD_END"], "methodName": ["testMultipleDefinedBeanFactoryPostProcessors"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class )  ;", "ac . registerSingleton (  \" tb 2  \"  ,    TestBean . class )  ;", "ac . registerBeanDefinition (  \" bdrpp 2  \"  ,    new   RootBeanDefinition (  . PrioritizedOuterBeanDefinitionRegistryPostProcessor . class )  )  ;", "ac . refresh (  )  ;", "assertTrue ( ac . getBean (  \" bfpp 1  \"  ,     . TestBeanFactoryPostProcessor . class )  . wasCalled )  ;", "assertTrue ( ac . getBean (  \" bfpp 2  \"  ,     . TestBeanFactoryPostProcessor . class )  . wasCalled )  ;", "}", "METHOD_END"], "methodName": ["testPrioritizedBeanDefinitionRegistryPostProcessorRegisteringAnother"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class )  ;", "ac . registerSingleton (  \" tb 2  \"  ,    TestBean . class )  ;", ". TestBeanFactoryPostProcessor   bfpp    =    new    . TestBeanFactoryPostProcessor (  )  ;", "ac . addBeanFactoryPostProcessor ( bfpp )  ;", "assertFalse ( bfpp . wasCalled )  ;", "ac . refresh (  )  ;", "assertTrue ( bfpp . wasCalled )  ;", "}", "METHOD_END"], "methodName": ["testRegisteredBeanFactoryPostProcessor"], "fileName": "org.springframework.context.support.BeanFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    beanNamesForType    =    ctx . getBeanNamesForType ( StaticMessageSource . class )  ;", "assertEquals (  1  ,    beanNamesForType . length )  ;", "assertEquals (  \" myMessageSource \"  ,    beanNamesForType [  0  ]  )  ;", "beanNamesForType    =    ctx . getBeanNamesForType ( StaticMessageSource . class ,    true ,    true )  ;", "assertEquals (  1  ,    beanNamesForType . length )  ;", "assertEquals (  \" myMessageSource \"  ,    beanNamesForType [  0  ]  )  ;", "beanNamesForType    =    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( ctx ,    StaticMessageSource . class )  ;", "assertEquals (  1  ,    beanNamesForType . length )  ;", "assertEquals (  \" myMessageSource \"  ,    beanNamesForType [  0  ]  )  ;", "beanNamesForType    =    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( ctx ,    StaticMessageSource . class ,    true ,    true )  ;", "assertEquals (  1  ,    beanNamesForType . length )  ;", "assertEquals (  \" myMessageSource \"  ,    beanNamesForType [  0  ]  )  ;", "Map <  ?  ,    StaticMessageSource >    beansOfType    =    ctx . getBeansOfType ( StaticMessageSource . class )  ;", "assertEquals (  1  ,    beansOfType . size (  )  )  ;", "assertSame ( myMessageSource ,    beansOfType . values (  )  . iterator (  )  . next (  )  )  ;", "beansOfType    =    ctx . getBeansOfType ( StaticMessageSource . class ,    true ,    true )  ;", "assertEquals (  1  ,    beansOfType . size (  )  )  ;", "assertSame ( myMessageSource ,    beansOfType . values (  )  . iterator (  )  . next (  )  )  ;", "beansOfType    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( ctx ,    StaticMessageSource . class )  ;", "assertEquals (  1  ,    beansOfType . size (  )  )  ;", "assertSame ( myMessageSource ,    beansOfType . values (  )  . iterator (  )  . next (  )  )  ;", "beansOfType    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( ctx ,    StaticMessageSource . class ,    true ,    true )  ;", "assertEquals (  1  ,    beansOfType . size (  )  )  ;", "assertSame ( myMessageSource ,    beansOfType . values (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertOneMessageSourceOnly"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "ex . printStackTrace ( new   PrintStream ( baos )  )  ;", "String   dump    =    FileCopyUtils . copyToString ( new   InputStreamReader ( new   ByteArrayInputStream ( baos . toByteArray (  )  )  )  )  ;", "assertTrue ( dumpains (  \" someMessageSource \"  )  )  ;", "assertTrue ( dumpains (  \" useCodeAsDefaultMessage \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkExceptionFromInvalidValueType"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . FQ _ SIMPLE _ CONTEXT )  ;", "assertTrue ( ctx . containsBean (  \" someMessageSource \"  )  )  ;", "ClassPathXmlApplicationContext   child    =    new   ClassPathXmlApplicationContext ( new   String [  ]  {    ClassPathXmlApplicationContextTests . ALIAS _ FOR _ PARENT _ CONTEXT    }  ,    ctx )  ;", "assertTrue ( child . containsBean (  \" someMessageSource \"  )  )  ;", "assertTrue ( child . containsBean (  \" yourMessageSource \"  )  )  ;", "assertTrue ( child . containsBean (  \" myMessageSource \"  )  )  ;", "assertTrue ( child . isSingleton (  \" someMessageSource \"  )  )  ;", "assertTrue ( child . isSingleton (  \" yourMessageSource \"  )  )  ;", "assertTrue ( child . isSingleton (  \" myMessageSource \"  )  )  ;", "assertEquals ( StaticMessageSource . class ,    child . getType (  \" someMessageSource \"  )  )  ;", "assertEquals ( StaticMessageSource . class ,    child . getType (  \" yourMessageSource \"  )  )  ;", "assertEquals ( StaticMessageSource . class ,    child . getType (  \" myMessageSource \"  )  )  ;", "Object   someMs    =    child . getBean (  \" someMessageSource \"  )  ;", "Object   yourMs    =    child . getBean (  \" yourMessageSource \"  )  ;", "Object   myMs    =    child . getBean (  \" myMessageSource \"  )  ;", "assertSame ( someMs ,    yourMs )  ;", "assertSame ( someMs ,    myMs )  ;", "String [  ]    aliases    =    child . getAliases (  \" someMessageSource \"  )  ;", "assertEquals (  2  ,    aliases . length )  ;", "assertEquals (  \" myMessageSource \"  ,    aliases [  0  ]  )  ;", "assertEquals (  \" yourMessageSource \"  ,    aliases [  1  ]  )  ;", "aliases    =    child . getAliases (  \" myMessageSource \"  )  ;", "assertEquals (  2  ,    aliases . length )  ;", "assertEquals (  \" someMessageSource \"  ,    aliases [  0  ]  )  ;", "assertEquals (  \" yourMessageSource \"  ,    aliases [  1  ]  )  ;", "child . close (  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAliasForParentContext"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . FQ _ SIMPLE _ CONTEXT ,    ClassPathXmlApplicationContextTests . ALIAS _ THAT _ OVERRIDES _ PARENT _ CONTEXT )  ;", "Object   myMs    =    ctx . getBean (  \" myMessageSource \"  )  ;", "Object   someMs 2     =    ctx . getBean (  \" someMessageSource \"  )  ;", "assertSame ( myMs ,    someMs 2  )  ;", "assertOneMessageSourceOnly ( ctx ,    myMs )  ;", "}", "METHOD_END"], "methodName": ["testAliasThatOverridesEarlierBean"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . FQ _ SIMPLE _ CONTEXT )  ;", "Object   someMs    =    ctx . getBean (  \" someMessageSource \"  )  ;", "ClassPathXmlApplicationContext   child    =    new   ClassPathXmlApplicationContext ( new   String [  ]  {    ClassPathXmlApplicationContextTests . ALIAS _ THAT _ OVERRIDES _ PARENT _ CONTEXT    }  ,    ctx )  ;", "Object   myMs    =    child . getBean (  \" myMessageSource \"  )  ;", "Object   someMs 2     =    child . getBean (  \" someMessageSource \"  )  ;", "assertSame ( myMs ,    someMs 2  )  ;", "assertNotSame ( someMs ,    someMs 2  )  ;", "assertOneMessageSourceOnly ( child ,    myMs )  ;", "}", "METHOD_END"], "methodName": ["testAliasThatOverridesParent"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . FQ _ CONTEXT _ B ,    ClassPathXmlApplicationContextTests . FQ _ ALIASED _ CONTEXT _ C ,    ClassPathXmlApplicationContextTests . FQ _ CONTEXT _ A )  ;", "assertTrue ( ctx . containsBean (  \" service \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicOne \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicTwo \"  )  )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["testAliasWithPlaceholder"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . CONTEXT _ WILDCARD )  ;", "ClassPathXmlApplicationContext   child    =    new   ClassPathXmlApplicationContext ( new   String [  ]  {    ClassPathXmlApplicationContextTests . CHILD _ WITH _ PROXY _ CONTEXT    }  ,    ctx )  ;", "assertTrue ( AopUtils . isAopProxy ( child . getBean (  \" assemblerOne \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( child . getBean (  \" assemblerTwo \"  )  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testChildWithProxy"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . CONTEXT _ WILDCARD )  ;", "assertTrue ( ctx . containsBean (  \" service \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicOne \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicTwo \"  )  )  ;", "Service   service    =     (  ( Service )     ( ctx . getBean (  \" service \"  )  )  )  ;", "ctx . close (  )  ;", "assertTrue ( service . isProperlyDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConfigLocationPattern"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . CLASS _ WITH _ PLACEHOLDER _ CONTEXT ,    getClass (  )  )  ;", "assertTrue ( ctx . containsBean (  \" someMessageSource \"  )  )  ;", "assertTrue (  (  ( ctx . getBean (  \" someMessageSource \"  )  )    instanceof   StaticMessageSource )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testContextWithClassNameThatContainsPlaceholder"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . INVALID _ CLASS _ CONTEXT ,    getClass (  )  )  ;", "assertTrue ( ctx . containsBean (  \" someMessageSource \"  )  )  ;", "try    {", "ctx . getBean (  \" someMessageSource \"  )  ;", "fail (  \" Should   have   thrown   CannotLoadBeanClassException \"  )  ;", "}    catch    ( CannotLoadBeanClassException   ex )     {", "assertTrue ( ex . contains ( ClassNotFoundException . class )  )  ;", "}", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testContextWithInvalidLazyClass"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext ( new   String [  ]  {    ClassPathXmlApplicationContextTests . INVALID _ VALUE _ TYPE _ CONTEXT    }  ,    false )  ;", "try    {", "context . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . contains ( TypeMismatchException . class )  )  ;", "assertTrue ( ex . toString (  )  . contains (  \" someMessageSource \"  )  )  ;", "assertTrue ( ex . toString (  )  . contains (  \" useCodeAsDefaultMessage \"  )  )  ;", "checkExceptionFromInvalidValueType ( ex )  ;", "checkExceptionFromInvalidValueType ( new   ExceptionInInitializerError ( ex )  )  ;", "assertFalse ( context . isActive (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testContextWithInvalidValueType"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . CONTEXT _ WILDCARD )  ;", "ctx . getBeanFactory (  )  . registerSingleton (  \" manualFBAAL \"  ,    new   FactoryBeanAndApplicationListener (  )  )  ;", "assertEquals (  2  ,    ctx . getBeansOfType ( ApplicationListener . class )  . size (  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBeanAndApplicationListener"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( ctx )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ B ,    getClass (  )  )  )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ C ,    getClass (  )  )  )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ A ,    getClass (  )  )  )  ;", "ctx . refresh (  )  ;", "assertTrue ( ctx . containsBean (  \" service \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicOne \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicTwo \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testGenericApplicationContextWithXmlBeanDefinitions"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . setClassLoader ( null )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( ctx )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ B ,    getClass (  )  )  )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ C ,    getClass (  )  )  )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ A ,    getClass (  )  )  )  ;", "ctx . refresh (  )  ;", "assertEquals ( ObjectUtils . identityToString ( ctx )  ,    ctx . getId (  )  )  ;", "assertEquals ( ObjectUtils . identityToString ( ctx )  ,    ctx . getDisplayName (  )  )  ;", "assertTrue ( ctx . containsBean (  \" service \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicOne \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicTwo \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testGenericApplicationContextWithXmlBeanDefinitionsAndClassLoaderNull"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . setId (  \" testContext \"  )  ;", "ctx . setDisplayName (  \" Test   Context \"  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( ctx )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ B ,    getClass (  )  )  )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ C ,    getClass (  )  )  )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CONTEXT _ A ,    getClass (  )  )  )  ;", "ctx . refresh (  )  ;", "assertEquals (  \" testContext \"  ,    ctx . getId (  )  )  ;", "assertEquals (  \" Test   Context \"  ,    ctx . getDisplayName (  )  )  ;", "assertTrue ( ctx . containsBean (  \" service \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicOne \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicTwo \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testGenericApplicationContextWithXmlBeanDefinitionsAndSpecifiedId"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . CONTEXT _ WILDCARD )  ;", "MessageSource   messageSource    =     (  ( MessageSource )     ( ctx . getBean (  \" messageSource \"  )  )  )  ;", "Service   service 1     =     (  ( Service )     ( ctx . getBean (  \" service \"  )  )  )  ;", "assertEquals ( ctx ,    service 1  . getMessageSource (  )  )  ;", "Service   service 2     =     (  ( Service )     ( ctx . getBean (  \" service 2  \"  )  )  )  ;", "assertEquals ( ctx ,    service 2  . getMessageSource (  )  )  ;", "AutowiredService   autowiredService 1     =     (  ( AutowiredService )     ( ctx . getBean (  \" autowiredService \"  )  )  )  ;", "assertEquals ( messageSource ,    autowiredService 1  . getMessageSource (  )  )  ;", "AutowiredService   autowiredService 2     =     (  ( AutowiredService )     ( ctx . getBean (  \" autowiredService 2  \"  )  )  )  ;", "assertEquals ( messageSource ,    autowiredService 2  . getMessageSource (  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testMessageSourceAware"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . FQ _ CONTEXT _ B ,    ClassPathXmlApplicationContextTests . FQ _ CONTEXT _ C ,    ClassPathXmlApplicationContextTests . FQ _ CONTEXT _ A )  ;", "assertTrue ( ctx . containsBean (  \" service \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicOne \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicTwo \"  )  )  ;", "Service   service    =     (  ( Service )     ( ctx . getBean (  \" service \"  )  )  )  ;", "ctx . refresh (  )  ;", "assertTrue ( service . isProperlyDestroyed (  )  )  ;", "service    =     (  ( Service )     ( ctx . getBean (  \" service \"  )  )  )  ;", "ctx . close (  )  ;", "assertTrue ( service . isProperlyDestroyed (  )  )  ;", "ctx . refresh (  )  ;", "service    =     (  ( Service )     ( ctx . getBean (  \" service \"  )  )  )  ;", "ctx . close (  )  ;", "assertTrue ( service . isProperlyDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleConfigLocations"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( new   String [  ]  {    ClassPathXmlApplicationContextTests . CONTEXT _ B ,    ClassPathXmlApplicationContextTests . CONTEXT _ C ,    ClassPathXmlApplicationContextTests . CONTEXT _ A    }  ,    getClass (  )  )  ;", "assertTrue ( ctx . containsBean (  \" service \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicOne \"  )  )  ;", "assertTrue ( ctx . containsBean (  \" logicTwo \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleConfigLocationsWithClass"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . RESOURCE _ CONTEXT )     {", "@ Override", "public   Resource   getResource ( String   location )     {", "if    ( ClassPathXmlApplicationContextTests . TEST _ PROPERTIES . equals ( location )  )     {", "return   new   ClassPathResource ( ClassPathXmlApplicationContextTests . TEST _ PROPERTIES ,    ClassPathXmlApplicationContextTests . class )  ;", "}", "return   super . getResource ( location )  ;", "}", "}  ;", "ResourceTestBean   resource 1     =     (  ( ResourceTestBean )     ( ctx . getBean (  \" resource 1  \"  )  )  )  ;", "ResourceTestBean   resource 2     =     (  ( ResourceTestBean )     ( ctx . getBean (  \" resource 2  \"  )  )  )  ;", "assertTrue (  (  ( resource 1  . getResource (  )  )    instanceof   ClassPathResource )  )  ;", "StringWriter   writer    =    new   StringWriter (  )  ;", "FileCopyUtils . copy ( new   InputStreamReader ( resource 1  . getResource (  )  . getInputStream (  )  )  ,    writer )  ;", "assertEquals (  \" contexttest \"  ,    writer . toString (  )  )  ;", "writer    =    new   StringWriter (  )  ;", "FileCopyUtils . copy ( new   InputStreamReader ( resource 1  . getInputStream (  )  )  ,    writer )  ;", "assertEquals (  \" test \"  ,    writer . toString (  )  )  ;", "writer    =    new   StringWriter (  )  ;", "FileCopyUtils . copy ( new   InputStreamReader ( resource 2  . getResource (  )  . getInputStream (  )  )  ,    writer )  ;", "assertEquals (  \" contexttest \"  ,    writer . toString (  )  )  ;", "writer    =    new   StringWriter (  )  ;", "FileCopyUtils . copy ( new   InputStreamReader ( resource 2  . getInputStream (  )  )  ,    writer )  ;", "assertEquals (  \" test \"  ,    writer . toString (  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testResourceAndInputStream"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . CONTEXT _ WILDCARD )  ;", "Service   service    =     (  ( Service )     ( ctx . getBean (  \" service \"  )  )  )  ;", "assertEquals (  3  ,    service . getResources (  )  . length )  ;", "List < Resource >    resources    =    Arrays . asList ( service . getResources (  )  )  ;", "assertTrue ( resources . contains ( new   FileSystemResource ( new   ClassPathResource ( ClassPathXmlApplicationContextTests . FQ _ CONTEXT _ A )  . getFile (  )  )  )  )  ;", "assertTrue ( resources . contains ( new   FileSystemResource ( new   ClassPathResource ( ClassPathXmlApplicationContextTests . FQ _ CONTEXT _ B )  . getFile (  )  )  )  )  ;", "assertTrue ( resources . contains ( new   FileSystemResource ( new   ClassPathResource ( ClassPathXmlApplicationContextTests . FQ _ CONTEXT _ C )  . getFile (  )  )  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testResourceArrayPropertyEditor"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . FQ _ SIMPLE _ CONTEXT )  ;", "assertTrue ( ctx . containsBean (  \" someMessageSource \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSingleConfigLocation"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( ClassPathXmlApplicationContextTests . SIMPLE _ CONTEXT ,    getClass (  )  )  ;", "assertTrue ( ctx . containsBean (  \" someMessageSource \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSingleConfigLocationWithClass"], "fileName": "org.springframework.context.support.ClassPathXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultConversionService (  )  ;", "}", "METHOD_END"], "methodName": ["createConversionService"], "fileName": "org.springframework.context.support.ConversionServiceFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . converters    =    converters ;", "}", "METHOD_END"], "methodName": ["setConverters"], "fileName": "org.springframework.context.support.ConversionServiceFactoryBean"}, {"methodBody": ["METHOD_START", "{", "doTestConversionServiceInApplicationContext (  \" conversionService . xml \"  ,    ClassPathResource . class )  ;", "}", "METHOD_END"], "methodName": ["conversionServiceInApplicationContext"], "fileName": "org.springframework.context.support.ConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "doTestConversionServiceInApplicationContext (  \" conversionServiceWithResourceOverriding . xml \"  ,    FileSystemResource . class )  ;", "}", "METHOD_END"], "methodName": ["conversionServiceInApplicationContextWithResourceOverriding"], "fileName": "org.springframework.context.support.ConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ConversionServiceFactoryBean   factory    =    new   ConversionServiceFactoryBean (  )  ;", "factory . afterPropertiesSet (  )  ;", "ConversionService   service    =    factory . getObject (  )  ;", "assertTrue ( service . canConvert ( String . class ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultConversionService"], "fileName": "org.springframework.context.support.ConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ConversionServiceFactoryBean   factory    =    new   ConversionServiceFactoryBean (  )  ;", "Set < Object >    converters    =    new   HashSet <  >  (  )  ;", "converters . add (  \" bogus \"  )  ;", "factory . setConverters ( converters )  ;", "factory . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultConversionServiceWithInvalidSupplements"], "fileName": "org.springframework.context.support.ConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ConversionServiceFactoryBean   factory    =    new   ConversionServiceFactoryBean (  )  ;", "Set < Object >    converters    =    new   HashSet <  >  (  )  ;", "converters . add ( new   Converter < String ,     . Foo >  (  )     {", "@ Override", "public    . Foo   convert ( String   source )     {", "return   new    . Foo (  )  ;", "}", "}  )  ;", "converters . add ( new   ConverterFactory < String ,     . Bar >  (  )     {", "@ Override", "public    < T   extends    . Bar >    Converter < String ,    T >    getConverter ( Class < T >    targetType )     {", "return   new   Converter < String ,    T >  (  )     {", "@ SuppressWarnings (  \" unchecked \"  )", "@ Override", "public   T   convert ( String   source )     {", "return    (  ( T )     ( new    . Bar (  )  )  )  ;", "}", "}  ;", "}", "}  )  ;", "converters . add ( new   GenericConverter (  )     {", "@ Override", "public   Set < ConvertiblePair >    getConvertibleTypes (  )     {", "return   Collections . singleton ( new   ConvertiblePair ( String . class ,     . Baz . class )  )  ;", "}", "@ Override", "@ Nullable", "public   Object   convert (  @ Nullable", "Object   source ,    TypeDescriptor   sourceType ,    TypeDescriptor   targetType )     {", "return   new    . Baz (  )  ;", "}", "}  )  ;", "factory . setConverters ( converters )  ;", "factory . afterPropertiesSet (  )  ;", "ConversionService   service    =    factory . getObject (  )  ;", "assertTrue ( service . canConvert ( String . class ,    Integer . class )  )  ;", "assertTrue ( service . canConvert ( String . class ,     . Foo . class )  )  ;", "assertTrue ( service . canConvert ( String . class ,     . Bar . class )  )  ;", "assertTrue ( service . canConvert ( String . class ,     . Baz . class )  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultConversionServiceWithSupplements"], "fileName": "org.springframework.context.support.ConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( fileName ,    getClass (  )  )  ;", "ResourceTestBean   tb    =    ctx . getBean (  \" resourceTestBean \"  ,    ResourceTestBean . class )  ;", "assertTrue ( resourceClass . isInstance ( tb . getResource (  )  )  )  ;", "assertTrue (  (  ( tb . getResourceArray (  )  . length )     >     0  )  )  ;", "assertTrue ( resourceClass . isInstance ( tb . getResourceArray (  )  [  0  ]  )  )  ;", "assertTrue (  (  ( tb . getResourceMap (  )  . size (  )  )     =  =     1  )  )  ;", "assertTrue ( resourceClass . isInstance ( tb . getResourceMap (  )  . get (  \" key 1  \"  )  )  )  ;", "assertTrue (  (  ( tb . getResourceArrayMap (  )  . size (  )  )     =  =     1  )  )  ;", "assertTrue (  (  ( tb . getResourceArrayMap (  )  . get (  \" key 1  \"  )  . length )     >     0  )  )  ;", "assertTrue ( resourceClass . isInstance ( tb . getResourceArrayMap (  )  . get (  \" key 1  \"  )  [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestConversionServiceInApplicationContext"], "fileName": "org.springframework.context.support.ConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Lifecycle   bean    =    lifecycleBeans . remove ( beanName )  ;", "if    (  ( bean    !  =    null )     &  &     ( bean    !  =     ( this )  )  )     {", "String [  ]    dependenciesForBean    =    getBeanFactory (  )  . getDependenciesForBean ( beanName )  ;", "for    ( String   dependency    :    dependenciesForBean )     {", "doStart ( lifecycleBeans ,    dependency ,    autoStartupOnly )  ;", "}", "if    (  (  !  ( bean . isRunning (  )  )  )     &  &     (  (  (  ! autoStartupOnly )     |  |     (  !  ( bean   instanceof   Smar )  )  )     |  |     (  (  ( Smar )     ( bean )  )  . isAutoStartup (  )  )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Starting   bean    '  \"     +    beanName )     +     \"  '    of   type    [  \"  )     +     ( bean . getClass (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "try    {", "bean . start (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   ApplicationContextException (  (  (  \" Failed   to   start   bean    '  \"     +    beanName )     +     \"  '  \"  )  ,    ex )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Successfully   started   bean    '  \"     +    beanName )     +     \"  '  \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["doStart"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "Lifecycle   bean    =    lifecycleBeans . remove ( beanName )  ;", "if    ( bean    !  =    null )     {", "String [  ]    dependentBeans    =    getBeanFactory (  )  . getDependentBeans ( beanName )  ;", "for    ( String   dependentBean    :    dependentBeans )     {", "doStop ( lifecycleBeans ,    dependentBean ,    latch ,    countDownBeanNames )  ;", "}", "try    {", "if    ( bean . isRunning (  )  )     {", "if    ( bean   instanceof   Smar )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Asking   bean    '  \"     +    beanName )     +     \"  '    of   type    [  \"  )     +     ( bean . getClass (  )  )  )     +     \"  ]    to   stop \"  )  )  ;", "}", "countDownBeanNames . add ( beanName )  ;", "(  ( Smar )     ( bean )  )  . stop (  (  )     -  >     {", "latch . countDown (  )  ;", "countDownBeanNames . remove ( beanName )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Bean    '  \"     +    beanName )     +     \"  '    completed   its   stop   procedure \"  )  )  ;", "}", "}  )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Stopping   bean    '  \"     +    beanName )     +     \"  '    of   type    [  \"  )     +     ( bean . getClass (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "bean . stop (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Successfully   stopped   bean    '  \"     +    beanName )     +     \"  '  \"  )  )  ;", "}", "}", "} else", "if    ( bean   instanceof   Smar )     {", "latch . countDown (  )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Failed   to   stop   bean    '  \"     +    beanName )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["doStop"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "ConfigurableListableBeanFactory   beanFactory    =    this . beanFactory ;", "Assertate (  ( beanFactory    !  =    null )  ,     \" No   BeanFactory   available \"  )  ;", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "ConfigurableListableBeanFactory   beanFactory    =    getBeanFactory (  )  ;", "Map < String ,    Lifecycle >    beans    =    new   LinkedHashMap <  >  (  )  ;", "String [  ]    beanNames    =    beanFactory . getBeanNamesForType ( Lifecycle . class ,    false ,    false )  ;", "for    ( String   beanName    :    beanNames )     {", "String   beanNameToRegister    =    BeanFactoryUtils . transformedBeanName ( beanName )  ;", "boolean   isFactoryBean    =    beanFactory . isFactoryBean ( beanNameToRegister )  ;", "String   beanNameToCheck    =     ( isFactoryBean )     ?     ( BeanFactory . FACTORY _ BEAN _ PREFIX )     +    beanName    :    beanName ;", "if    (  (  ( beanFactory . containsSingleton ( beanNameToRegister )  )     &  &     (  (  ! isFactoryBean )     |  |     ( matchesBeanType ( Lifecycle . class ,    beanNameToCheck ,    beanFactory )  )  )  )     |  |     ( matchesBeanType ( Smar . class ,    beanNameToCheck ,    beanFactory )  )  )     {", "Object   bean    =    beanFactory . getBean ( beanNameToCheck )  ;", "if    (  ( bean    !  =     ( this )  )     &  &     ( bean   instanceof   Lifecycle )  )     {", "beans . put ( beanNameToRegister ,     (  ( Lifecycle )     ( bean )  )  )  ;", "}", "}", "}", "return   beans ;", "}", "METHOD_END"], "methodName": ["getLifecycleBeans"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "return   bean   instanceof   Phased    ?     (  ( Phased )     ( bean )  )  . getPhase (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getPhase"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    beanType    =    beanFactory . getType ( beanName )  ;", "return    ( beanType    !  =    null )     &  &     ( targetType . isAssignableFrom ( beanType )  )  ;", "}", "METHOD_END"], "methodName": ["matchesBeanType"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "this . timeoutPerShutdownPhase    =    timeoutPerShutdownPhase ;", "}", "METHOD_END"], "methodName": ["setTimeoutPerShutdownPhase"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Lifecycle >    lifecycleBeans    =    getLifecycleBeans (  )  ;", "Map < Integer ,     . LifecycleGroup >    phases    =    new   HashMap <  >  (  )  ;", "lifecycleBeans . forEach (  (    beanName ,    bean )     -  >     {", "if    (  (  ! autoStartupOnly )     |  |     (  ( bean   instanceof   SmartLifecycle )     &  &     (  (  ( SmartLifecycle )     ( bean )  )  . isAutoStartup (  )  )  )  )     {", "int   phase    =    getPhase ( bean )  ;", ". LifecycleGroup   group    =    phases . get ( phase )  ;", "if    ( group    =  =    null )     {", "group    =    new    . LifecycleGroup ( phase ,    this . timeoutPerShutdownPhase ,    lifecycleBeans ,    autoStartupOnly )  ;", "phases . put ( phase ,    group )  ;", "}", "group . add ( beanName ,    bean )  ;", "}", "}  )  ;", "if    (  !  ( phases . isEmpty (  )  )  )     {", "List < Integer >    keys    =    new   ArrayList <  >  ( phases . keySet (  )  )  ;", "Collections . sort ( keys )  ;", "for    ( Integer   key    :    keys )     {", "phases . get ( key )  . start (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["startBeans"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Lifecycle >    lifecycleBeans    =    getLifecycleBeans (  )  ;", "Map < Integer ,     . LifecycleGroup >    phases    =    new   HashMap <  >  (  )  ;", "lifecycleBeans . forEach (  (    beanName ,    bean )     -  >     {", "int   shutdownOrder    =    getPhase ( bean )  ;", ". LifecycleGroup   group    =    phases . get ( shutdownOrder )  ;", "if    ( group    =  =    null )     {", "group    =    new    . LifecycleGroup ( shutdownOrder ,    this . timeoutPerShutdownPhase ,    lifecycleBeans ,    false )  ;", "phases . put ( shutdownOrder ,    group )  ;", "}", "group . add ( beanName ,    bean )  ;", "}  )  ;", "if    (  !  ( phases . isEmpty (  )  )  )     {", "List < Integer >    keys    =    new   ArrayList <  >  ( phases . keySet (  )  )  ;", "keys . sort ( Collections . reverseOrder (  )  )  ;", "for    ( Integer   key    :    keys )     {", "phases . get ( key )  . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["stopBeans"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessor"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestLifecycleBean   simpleBean 1     =     . TestLifecycleBean . forStartupTests ( startedBeans )  ;", ". TestLifecycleBean   simpleBean 2     =     . TestLifecycleBean . forStartupTests ( startedBeans )  ;", ". TestSmartLifecycleBean   smartBean 1     =     . TestSmartLifecycleBean . forStartupTests (  5  ,    startedBeans )  ;", ". TestSmartLifecycleBean   smartBean 2     =     . TestSmartLifecycleBean . forStartupTests (  (  -  3  )  ,    startedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" simpleBean 1  \"  ,    simpleBean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" smartBean 1  \"  ,    smartBean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" simpleBean 2  \"  ,    simpleBean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" smartBean 2  \"  ,    smartBean 2  )  ;", "assertFalse ( simpleBean 1  . isRunning (  )  )  ;", "assertFalse ( simpleBean 2  . isRunning (  )  )  ;", "assertFalse ( smartBean 1  . isRunning (  )  )  ;", "assertFalse ( smartBean 2  . isRunning (  )  )  ;", "context . refresh (  )  ;", "assertTrue ( smartBean 1  . isRunning (  )  )  ;", "assertTrue ( smartBean 2  . isRunning (  )  )  ;", "assertFalse ( simpleBean 1  . isRunning (  )  )  ;", "assertFalse ( simpleBean 2  . isRunning (  )  )  ;", "assertEquals (  2  ,    startedBeans . size (  )  )  ;", "assertEquals (  (  -  3  )  ,     . getPhase ( startedBeans . get (  0  )  )  )  ;", "assertEquals (  5  ,     . getPhase ( startedBeans . get (  1  )  )  )  ;", "context . start (  )  ;", "assertTrue ( smartBean 1  . isRunning (  )  )  ;", "assertTrue ( smartBean 2  . isRunning (  )  )  ;", "assertTrue ( simpleBean 1  . isRunning (  )  )  ;", "assertTrue ( simpleBean 2  . isRunning (  )  )  ;", "assertEquals (  4  ,    startedBeans . size (  )  )  ;", "assertEquals (  0  ,     . getPhase ( startedBeans . get (  2  )  )  )  ;", "assertEquals (  0  ,     . getPhase ( startedBeans . get (  3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contextRefreshThenStartWithMixedBeans"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestLifecycleBean   simpleBean 1     =     . TestLifecycleBean . forStartupTests ( startedBeans )  ;", ". TestLifecycleBean   simpleBean 2     =     . TestLifecycleBean . forStartupTests ( startedBeans )  ;", ". TestSmartLifecycleBean   smartBean 1     =     . TestSmartLifecycleBean . forStartupTests (  5  ,    startedBeans )  ;", ". TestSmartLifecycleBean   smartBean 2     =     . TestSmartLifecycleBean . forStartupTests (  (  -  3  )  ,    startedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" simpleBean 1  \"  ,    simpleBean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" smartBean 1  \"  ,    smartBean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" simpleBean 2  \"  ,    simpleBean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" smartBean 2  \"  ,    smartBean 2  )  ;", "assertFalse ( simpleBean 1  . isRunning (  )  )  ;", "assertFalse ( simpleBean 2  . isRunning (  )  )  ;", "assertFalse ( smartBean 1  . isRunning (  )  )  ;", "assertFalse ( smartBean 2  . isRunning (  )  )  ;", "context . refresh (  )  ;", "assertTrue ( smartBean 1  . isRunning (  )  )  ;", "assertTrue ( smartBean 2  . isRunning (  )  )  ;", "assertFalse ( simpleBean 1  . isRunning (  )  )  ;", "assertFalse ( simpleBean 2  . isRunning (  )  )  ;", "assertEquals (  2  ,    startedBeans . size (  )  )  ;", "assertEquals (  (  -  3  )  ,     . getPhase ( startedBeans . get (  0  )  )  )  ;", "assertEquals (  5  ,     . getPhase ( startedBeans . get (  1  )  )  )  ;", "context . stop (  )  ;", "assertFalse ( simpleBean 1  . isRunning (  )  )  ;", "assertFalse ( simpleBean 2  . isRunning (  )  )  ;", "assertFalse ( smartBean 1  . isRunning (  )  )  ;", "assertFalse ( smartBean 2  . isRunning (  )  )  ;", "context . start (  )  ;", "assertTrue ( smartBean 1  . isRunning (  )  )  ;", "assertTrue ( smartBean 2  . isRunning (  )  )  ;", "assertTrue ( simpleBean 1  . isRunning (  )  )  ;", "assertTrue ( simpleBean 2  . isRunning (  )  )  ;", "assertEquals (  6  ,    startedBeans . size (  )  )  ;", "assertEquals (  (  -  3  )  ,     . getPhase ( startedBeans . get (  2  )  )  )  ;", "assertEquals (  0  ,     . getPhase ( startedBeans . get (  3  )  )  )  ;", "assertEquals (  0  ,     . getPhase ( startedBeans . get (  4  )  )  )  ;", "assertEquals (  5  ,     . getPhase ( startedBeans . get (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contextRefreshThenStopAndRestartWithMixedBeans"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    new   RootBeanDefinition ( DefaultLifecycleProcessor . class )  ;", "beanDefinition . getPropertyValues (  )  . addPropertyValue (  \" timeoutPerShutdownPhase \"  ,     1  0  0  0  )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . registerBeanDefinition (  \" lifecycleProcessor \"  ,    beanDefinition )  ;", "context . refresh (  )  ;", "LifecycleProcessor   bean    =    context . getBean (  \" lifecycleProcessor \"  ,    LifecycleProcessor . class )  ;", "Object   contextLifecycleProcessor    =    new   DirectFieldAccessor ( context )  . getPropertyValue (  \" lifecycleProcessor \"  )  ;", "assertNotNull ( contextLifecycleProcessor )  ;", "assertSame ( bean ,    contextLifecycleProcessor )  ;", "assertEquals (  1  0  0  0 L ,    new   DirectFieldAccessor ( contextLifecycleProcessor )  . getPropertyValue (  \" timeoutPerShutdownPhase \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customLifecycleProcessorInstance"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . refresh (  )  ;", "Object   lifecycleProcessor    =    new   DirectFieldAccessor ( context )  . getPropertyValue (  \" lifecycleProcessor \"  )  ;", "assertNotNull ( lifecycleProcessor )  ;", "assertEquals (  . class ,    lifecycleProcessor . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultLifecycleProcessorInstance"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   beanNegative    =     . TestSmartLifecycleBean . forStartupTests (  (  -  9  9  )  ,    startedBeans )  ;", ". TestSmartLifecycleBean   bean 9  9     =     . TestSmartLifecycleBean . forStartupTests (  9  9  ,    startedBeans )  ;", ". TestSmartLifecycleBean   bean 7     =     . TestSmartLifecycleBean . forStartupTests (  7  ,    startedBeans )  ;", ". TestLifecycleBean   simpleBean    =     . TestLifecycleBean . forStartupTests ( startedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanNegative \"  ,    beanNegative )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 7  \"  ,    bean 7  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 9  9  \"  ,    bean 9  9  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" simpleBean \"  ,    simpleBean )  ;", "context . getBeanFactory (  )  . registerDependentBean (  \" bean 7  \"  ,     \" simpleBean \"  )  ;", "context . refresh (  )  ;", "context . stop (  )  ;", "startedBeans . clear (  )  ;", "context . start (  )  ;", "assertTrue ( beanNegative . isRunning (  )  )  ;", "assertTrue ( bean 9  9  . isRunning (  )  )  ;", "assertTrue ( bean 7  . isRunning (  )  )  ;", "assertTrue ( simpleBean . isRunning (  )  )  ;", "assertEquals (  4  ,    startedBeans . size (  )  )  ;", "assertEquals (  (  -  9  9  )  ,     . getPhase ( startedBeans . get (  0  )  )  )  ;", "assertEquals (  7  ,     . getPhase ( startedBeans . get (  1  )  )  )  ;", "assertEquals (  0  ,     . getPhase ( startedBeans . get (  2  )  )  )  ;", "assertEquals (  9  9  ,     . getPhase ( startedBeans . get (  3  )  )  )  ;", "context . stop (  )  ;", "}", "METHOD_END"], "methodName": ["dependencyStartedFirstAndIsSmartLifecycle"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   beanMin    =     . TestSmartLifecycleBean . forStartupTests ( Integer . MIN _ VALUE ,    startedBeans )  ;", ". TestSmartLifecycleBean   bean 7     =     . TestSmartLifecycleBean . forStartupTests (  7  ,    startedBeans )  ;", ". TestLifecycleBean   simpleBean    =     . TestLifecycleBean . forStartupTests ( startedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMin \"  ,    beanMin )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 7  \"  ,    bean 7  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" simpleBean \"  ,    simpleBean )  ;", "context . getBeanFactory (  )  . registerDependentBean (  \" simpleBean \"  ,     \" beanMin \"  )  ;", "context . refresh (  )  ;", "assertTrue ( beanMin . isRunning (  )  )  ;", "assertTrue ( bean 7  . isRunning (  )  )  ;", "assertTrue ( simpleBean . isRunning (  )  )  ;", "assertEquals (  3  ,    startedBeans . size (  )  )  ;", "assertEquals (  0  ,     . getPhase ( startedBeans . get (  0  )  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,     . getPhase ( startedBeans . get (  1  )  )  )  ;", "assertEquals (  7  ,     . getPhase ( startedBeans . get (  2  )  )  )  ;", "context . stop (  )  ;", "}", "METHOD_END"], "methodName": ["dependencyStartedFirstButNotSmartLifecycle"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   beanMin    =     . TestSmartLifecycleBean . forStartupTests ( Integer . MIN _ VALUE ,    startedBeans )  ;", ". TestSmartLifecycleBean   bean 2     =     . TestSmartLifecycleBean . forStartupTests (  2  ,    startedBeans )  ;", ". TestSmartLifecycleBean   bean 9  9     =     . TestSmartLifecycleBean . forStartupTests (  9  9  ,    startedBeans )  ;", ". TestSmartLifecycleBean   beanMax    =     . TestSmartLifecycleBean . forStartupTests ( Integer . MAX _ VALUE ,    startedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMin \"  ,    beanMin )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 2  \"  ,    bean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 9  9  \"  ,    bean 9  9  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMax \"  ,    beanMax )  ;", "context . getBeanFactory (  )  . registerDependentBean (  \" bean 9  9  \"  ,     \" bean 2  \"  )  ;", "context . refresh (  )  ;", "assertTrue ( beanMin . isRunning (  )  )  ;", "assertTrue ( bean 2  . isRunning (  )  )  ;", "assertTrue ( bean 9  9  . isRunning (  )  )  ;", "assertTrue ( beanMax . isRunning (  )  )  ;", "assertEquals (  4  ,    startedBeans . size (  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,     . getPhase ( startedBeans . get (  0  )  )  )  ;", "assertEquals (  9  9  ,     . getPhase ( startedBeans . get (  1  )  )  )  ;", "assertEquals ( bean 9  9  ,    startedBeans . get (  1  )  )  ;", "assertEquals (  2  ,     . getPhase ( startedBeans . get (  2  )  )  )  ;", "assertEquals ( bean 2  ,    startedBeans . get (  2  )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,     . getPhase ( startedBeans . get (  3  )  )  )  ;", "context . stop (  )  ;", "}", "METHOD_END"], "methodName": ["dependencyStartedFirstEvenIfItsPhaseIsHigher"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "CopyOnWriteArrayList < Lifecycle >    stoppedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   beanMin    =     . TestSmartLifecycleBean . forShutdownTests ( Integer . MIN _ VALUE ,     4  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   beanNegative    =     . TestSmartLifecycleBean . forShutdownTests (  (  -  9  9  )  ,     1  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 1     =     . TestSmartLifecycleBean . forShutdownTests (  1  ,     2  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 2     =     . TestSmartLifecycleBean . forShutdownTests (  2  ,     3  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 7     =     . TestSmartLifecycleBean . forShutdownTests (  7  ,     4  0  0  ,    stoppedBeans )  ;", ". TestLifecycleBean   simpleBean    =     . TestLifecycleBean . forShutdownTests ( stoppedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMin \"  ,    beanMin )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanNegative \"  ,    beanNegative )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 1  \"  ,    bean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 2  \"  ,    bean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 7  \"  ,    bean 7  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" simpleBean \"  ,    simpleBean )  ;", "context . getBeanFactory (  )  . registerDependentBean (  \" simpleBean \"  ,     \" beanNegative \"  )  ;", "context . refresh (  )  ;", "assertTrue ( beanMin . isRunning (  )  )  ;", "assertTrue ( beanNegative . isRunning (  )  )  ;", "assertTrue ( bean 1  . isRunning (  )  )  ;", "assertTrue ( bean 2  . isRunning (  )  )  ;", "assertTrue ( bean 7  . isRunning (  )  )  ;", "assertTrue ( simpleBean . isRunning (  )  )  ;", "context . stop (  )  ;", "assertFalse ( beanMin . isRunning (  )  )  ;", "assertFalse ( beanNegative . isRunning (  )  )  ;", "assertFalse ( bean 1  . isRunning (  )  )  ;", "assertFalse ( bean 2  . isRunning (  )  )  ;", "assertFalse ( bean 7  . isRunning (  )  )  ;", "assertFalse ( simpleBean . isRunning (  )  )  ;", "assertEquals (  6  ,    stoppedBeans . size (  )  )  ;", "assertEquals (  7  ,     . getPhase ( stoppedBeans . get (  0  )  )  )  ;", "assertEquals (  2  ,     . getPhase ( stoppedBeans . get (  1  )  )  )  ;", "assertEquals (  1  ,     . getPhase ( stoppedBeans . get (  2  )  )  )  ;", "assertEquals (  (  -  9  9  )  ,     . getPhase ( stoppedBeans . get (  3  )  )  )  ;", "assertEquals (  0  ,     . getPhase ( stoppedBeans . get (  4  )  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,     . getPhase ( stoppedBeans . get (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dependentShutdownFirstAndIsSmartLifecycle"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "CopyOnWriteArrayList < Lifecycle >    stoppedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   bean 1     =     . TestSmartLifecycleBean . forShutdownTests (  1  ,     2  0  0  ,    stoppedBeans )  ;", ". TestLifecycleBean   simpleBean    =     . TestLifecycleBean . forShutdownTests ( stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 2     =     . TestSmartLifecycleBean . forShutdownTests (  2  ,     3  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 7     =     . TestSmartLifecycleBean . forShutdownTests (  7  ,     4  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   beanMin    =     . TestSmartLifecycleBean . forShutdownTests ( Integer . MIN _ VALUE ,     4  0  0  ,    stoppedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMin \"  ,    beanMin )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 1  \"  ,    bean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 2  \"  ,    bean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 7  \"  ,    bean 7  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" simpleBean \"  ,    simpleBean )  ;", "context . getBeanFactory (  )  . registerDependentBean (  \" bean 2  \"  ,     \" simpleBean \"  )  ;", "context . refresh (  )  ;", "assertTrue ( beanMin . isRunning (  )  )  ;", "assertTrue ( bean 1  . isRunning (  )  )  ;", "assertTrue ( bean 2  . isRunning (  )  )  ;", "assertTrue ( bean 7  . isRunning (  )  )  ;", "assertFalse ( simpleBean . isRunning (  )  )  ;", "simpleBean . start (  )  ;", "assertTrue ( simpleBean . isRunning (  )  )  ;", "context . stop (  )  ;", "assertFalse ( beanMin . isRunning (  )  )  ;", "assertFalse ( bean 1  . isRunning (  )  )  ;", "assertFalse ( bean 2  . isRunning (  )  )  ;", "assertFalse ( bean 7  . isRunning (  )  )  ;", "assertFalse ( simpleBean . isRunning (  )  )  ;", "assertEquals (  5  ,    stoppedBeans . size (  )  )  ;", "assertEquals (  7  ,     . getPhase ( stoppedBeans . get (  0  )  )  )  ;", "assertEquals (  0  ,     . getPhase ( stoppedBeans . get (  1  )  )  )  ;", "assertEquals (  2  ,     . getPhase ( stoppedBeans . get (  2  )  )  )  ;", "assertEquals (  1  ,     . getPhase ( stoppedBeans . get (  3  )  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,     . getPhase ( stoppedBeans . get (  4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dependentShutdownFirstButNotSmartLifecycle"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "CopyOnWriteArrayList < Lifecycle >    stoppedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   beanMin    =     . TestSmartLifecycleBean . forShutdownTests ( Integer . MIN _ VALUE ,     1  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 1     =     . TestSmartLifecycleBean . forShutdownTests (  1  ,     2  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 9  9     =     . TestSmartLifecycleBean . forShutdownTests (  9  9  ,     1  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 2     =     . TestSmartLifecycleBean . forShutdownTests (  2  ,     3  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 7     =     . TestSmartLifecycleBean . forShutdownTests (  7  ,     4  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   beanMax    =     . TestSmartLifecycleBean . forShutdownTests ( Integer . MAX _ VALUE ,     4  0  0  ,    stoppedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMin \"  ,    beanMin )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 1  \"  ,    bean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 2  \"  ,    bean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 7  \"  ,    bean 7  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 9  9  \"  ,    bean 9  9  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMax \"  ,    beanMax )  ;", "context . getBeanFactory (  )  . registerDependentBean (  \" bean 9  9  \"  ,     \" bean 2  \"  )  ;", "context . refresh (  )  ;", "assertTrue ( beanMin . isRunning (  )  )  ;", "assertTrue ( bean 1  . isRunning (  )  )  ;", "assertTrue ( bean 2  . isRunning (  )  )  ;", "assertTrue ( bean 7  . isRunning (  )  )  ;", "assertTrue ( bean 9  9  . isRunning (  )  )  ;", "assertTrue ( beanMax . isRunning (  )  )  ;", "context . stop (  )  ;", "assertFalse ( beanMin . isRunning (  )  )  ;", "assertFalse ( bean 1  . isRunning (  )  )  ;", "assertFalse ( bean 2  . isRunning (  )  )  ;", "assertFalse ( bean 7  . isRunning (  )  )  ;", "assertFalse ( bean 9  9  . isRunning (  )  )  ;", "assertFalse ( beanMax . isRunning (  )  )  ;", "assertEquals (  6  ,    stoppedBeans . size (  )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,     . getPhase ( stoppedBeans . get (  0  )  )  )  ;", "assertEquals (  2  ,     . getPhase ( stoppedBeans . get (  1  )  )  )  ;", "assertEquals ( bean 2  ,    stoppedBeans . get (  1  )  )  ;", "assertEquals (  9  9  ,     . getPhase ( stoppedBeans . get (  2  )  )  )  ;", "assertEquals ( bean 9  9  ,    stoppedBeans . get (  2  )  )  ;", "assertEquals (  7  ,     . getPhase ( stoppedBeans . get (  3  )  )  )  ;", "assertEquals (  1  ,     . getPhase ( stoppedBeans . get (  4  )  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,     . getPhase ( stoppedBeans . get (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dependentShutdownFirstEvenIfItsPhaseIsLower"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   lifecycle   instanceof   SmartLifecycle    ?     (  ( SmartLifecycle )     ( lifecycle )  )  . getPhase (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getPhase"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    stoppedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", "Lifecycle   bean 1     =     . TestLifecycleBean . forShutdownTests ( stoppedBeans )  ;", "Lifecycle   bean 2     =     . TestSmartLifecycleBean . forShutdownTests (  5  0  0  ,     2  0  0  ,    stoppedBeans )  ;", "Lifecycle   bean 3     =     . TestSmartLifecycleBean . forShutdownTests ( Integer . MAX _ VALUE ,     1  0  0  ,    stoppedBeans )  ;", "Lifecycle   bean 4     =     . TestLifecycleBean . forShutdownTests ( stoppedBeans )  ;", "Lifecycle   bean 5     =     . TestSmartLifecycleBean . forShutdownTests (  1  ,     2  0  0  ,    stoppedBeans )  ;", "Lifecycle   bean 6     =     . TestSmartLifecycleBean . forShutdownTests (  (  -  1  )  ,     1  0  0  ,    stoppedBeans )  ;", "Lifecycle   bean 7     =     . TestSmartLifecycleBean . forShutdownTests ( Integer . MIN _ VALUE ,     3  0  0  ,    stoppedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 1  \"  ,    bean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 2  \"  ,    bean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 3  \"  ,    bean 3  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 4  \"  ,    bean 4  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 5  \"  ,    bean 5  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 6  \"  ,    bean 6  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 7  \"  ,    bean 7  )  ;", "context . refresh (  )  ;", "assertTrue ( bean 2  . isRunning (  )  )  ;", "assertTrue ( bean 3  . isRunning (  )  )  ;", "assertTrue ( bean 5  . isRunning (  )  )  ;", "assertTrue ( bean 6  . isRunning (  )  )  ;", "assertTrue ( bean 7  . isRunning (  )  )  ;", "assertFalse ( bean 1  . isRunning (  )  )  ;", "assertFalse ( bean 4  . isRunning (  )  )  ;", "bean 1  . start (  )  ;", "bean 4  . start (  )  ;", "assertTrue ( bean 1  . isRunning (  )  )  ;", "assertTrue ( bean 4  . isRunning (  )  )  ;", "context . stop (  )  ;", "assertFalse ( bean 1  . isRunning (  )  )  ;", "assertFalse ( bean 2  . isRunning (  )  )  ;", "assertFalse ( bean 3  . isRunning (  )  )  ;", "assertFalse ( bean 4  . isRunning (  )  )  ;", "assertFalse ( bean 5  . isRunning (  )  )  ;", "assertFalse ( bean 6  . isRunning (  )  )  ;", "assertFalse ( bean 7  . isRunning (  )  )  ;", "assertEquals (  7  ,    stoppedBeans . size (  )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,     . getPhase ( stoppedBeans . get (  0  )  )  )  ;", "assertEquals (  5  0  0  ,     . getPhase ( stoppedBeans . get (  1  )  )  )  ;", "assertEquals (  1  ,     . getPhase ( stoppedBeans . get (  2  )  )  )  ;", "assertEquals (  0  ,     . getPhase ( stoppedBeans . get (  3  )  )  )  ;", "assertEquals (  0  ,     . getPhase ( stoppedBeans . get (  4  )  )  )  ;", "assertEquals (  (  -  1  )  ,     . getPhase ( stoppedBeans . get (  5  )  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,     . getPhase ( stoppedBeans . get (  6  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mixedShutdown"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    stoppedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", "Lifecycle   bean    =    new    . TestLifecycleBean ( null ,    stoppedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean \"  ,    bean )  ;", "context . refresh (  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "bean . start (  )  ;", "assertTrue ( bean . isRunning (  )  )  ;", "context . stop (  )  ;", "assertEquals (  1  ,    stoppedBeans . size (  )  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "assertEquals ( bean ,    stoppedBeans . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["singleLifecycleShutdown"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   bean    =     . TestSmartLifecycleBean . forStartupTests (  1  ,    startedBeans )  ;", "bean . setAutoStartup ( true )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean \"  ,    bean )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "context . refresh (  )  ;", "assertTrue ( bean . isRunning (  )  )  ;", "context . stop (  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "assertEquals (  1  ,    startedBeans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["singleSmartLifecycleAutoStartup"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . DummySmartLifecycleBean . class )  ;", "bd . setLazyInit ( true )  ;", "context . registerBeanDefinition (  \" bean \"  ,    bd )  ;", "context . refresh (  )  ;", ". DummySmartLifecycleBean   bean    =    context . getBean (  \" bean \"  ,     . DummySmartLifecycleBean . class )  ;", "assertTrue ( bean . isRunning (  )  )  ;", "context . stop (  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "}", "METHOD_END"], "methodName": ["singleSmartLifecycleAutoStartupWithLazyInit"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . DummySmartLifecycleFactoryBean . class )  ;", "bd . setLazyInit ( true )  ;", "context . registerBeanDefinition (  \" bean \"  ,    bd )  ;", "context . refresh (  )  ;", ". DummySmartLifecycleFactoryBean   bean    =    context . getBean (  \"  & bean \"  ,     . DummySmartLifecycleFactoryBean . class )  ;", "assertTrue ( bean . isRunning (  )  )  ;", "context . stop (  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "}", "METHOD_END"], "methodName": ["singleSmartLifecycleAutoStartupWithLazyInitFactoryBean"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   bean    =     . TestSmartLifecycleBean . forStartupTests (  1  ,    startedBeans )  ;", "bean . setAutoStartup ( true )  ;", ". TestSmartLifecycleBean   dependency    =     . TestSmartLifecycleBean . forStartupTests (  1  ,    startedBeans )  ;", "dependency . setAutoStartup ( false )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean \"  ,    bean )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" dependency \"  ,    dependency )  ;", "context . getBeanFactory (  )  . registerDependentBean (  \" dependency \"  ,     \" bean \"  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "assertFalse ( dependency . isRunning (  )  )  ;", "context . refresh (  )  ;", "assertTrue ( bean . isRunning (  )  )  ;", "assertFalse ( dependency . isRunning (  )  )  ;", "context . stop (  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "assertFalse ( dependency . isRunning (  )  )  ;", "assertEquals (  1  ,    startedBeans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["singleSmartLifecycleAutoStartupWithNonAutoStartupDependency"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "CopyOnWriteArrayList < Lifecycle >    stoppedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   bean    =     . TestSmartLifecycleBean . forShutdownTests (  9  9  ,     3  0  0  ,    stoppedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean \"  ,    bean )  ;", "context . refresh (  )  ;", "assertTrue ( bean . isRunning (  )  )  ;", "context . stop (  )  ;", "assertEquals (  1  ,    stoppedBeans . size (  )  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "assertEquals ( bean ,    stoppedBeans . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["singleSmartLifecycleShutdown"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   bean    =     . TestSmartLifecycleBean . forStartupTests (  1  ,    startedBeans )  ;", "bean . setAutoStartup ( false )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean \"  ,    bean )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "context . refresh (  )  ;", "assertFalse ( bean . isRunning (  )  )  ;", "assertEquals (  0  ,    startedBeans . size (  )  )  ;", "context . start (  )  ;", "assertTrue ( bean . isRunning (  )  )  ;", "assertEquals (  1  ,    startedBeans . size (  )  )  ;", "context . stop (  )  ;", "}", "METHOD_END"], "methodName": ["singleSmartLifecycleWithoutAutoStartup"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "CopyOnWriteArrayList < Lifecycle >    stoppedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   bean 1     =     . TestSmartLifecycleBean . forShutdownTests (  1  ,     3  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 2     =     . TestSmartLifecycleBean . forShutdownTests (  3  ,     1  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 3     =     . TestSmartLifecycleBean . forShutdownTests (  1  ,     6  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 4     =     . TestSmartLifecycleBean . forShutdownTests (  2  ,     4  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 5     =     . TestSmartLifecycleBean . forShutdownTests (  2  ,     7  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 6     =     . TestSmartLifecycleBean . forShutdownTests ( Integer . MAX _ VALUE ,     2  0  0  ,    stoppedBeans )  ;", ". TestSmartLifecycleBean   bean 7     =     . TestSmartLifecycleBean . forShutdownTests (  3  ,     2  0  0  ,    stoppedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 1  \"  ,    bean 1  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 2  \"  ,    bean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 3  \"  ,    bean 3  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 4  \"  ,    bean 4  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 5  \"  ,    bean 5  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 6  \"  ,    bean 6  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 7  \"  ,    bean 7  )  ;", "context . refresh (  )  ;", "context . stop (  )  ;", "assertEquals ( Integer . MAX _ VALUE ,     . getPhase ( stoppedBeans . get (  0  )  )  )  ;", "assertEquals (  3  ,     . getPhase ( stoppedBeans . get (  1  )  )  )  ;", "assertEquals (  3  ,     . getPhase ( stoppedBeans . get (  2  )  )  )  ;", "assertEquals (  2  ,     . getPhase ( stoppedBeans . get (  3  )  )  )  ;", "assertEquals (  2  ,     . getPhase ( stoppedBeans . get (  4  )  )  )  ;", "assertEquals (  1  ,     . getPhase ( stoppedBeans . get (  5  )  )  )  ;", "assertEquals (  1  ,     . getPhase ( stoppedBeans . get (  6  )  )  )  ;", "}", "METHOD_END"], "methodName": ["smartLifecycleGroupShutdown"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "CopyOnWriteArrayList < Lifecycle >    startedBeans    =    new   CopyOnWriteArrayList <  >  (  )  ;", ". TestSmartLifecycleBean   beanMin    =     . TestSmartLifecycleBean . forStartupTests ( Integer . MIN _ VALUE ,    startedBeans )  ;", ". TestSmartLifecycleBean   bean 1     =     . TestSmartLifecycleBean . forStartupTests (  1  ,    startedBeans )  ;", ". TestSmartLifecycleBean   bean 2     =     . TestSmartLifecycleBean . forStartupTests (  2  ,    startedBeans )  ;", ". TestSmartLifecycleBean   bean 3     =     . TestSmartLifecycleBean . forStartupTests (  3  ,    startedBeans )  ;", ". TestSmartLifecycleBean   beanMax    =     . TestSmartLifecycleBean . forStartupTests ( Integer . MAX _ VALUE ,    startedBeans )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 3  \"  ,    bean 3  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMin \"  ,    beanMin )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 2  \"  ,    bean 2  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" beanMax \"  ,    beanMax )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" bean 1  \"  ,    bean 1  )  ;", "assertFalse ( beanMin . isRunning (  )  )  ;", "assertFalse ( bean 1  . isRunning (  )  )  ;", "assertFalse ( bean 2  . isRunning (  )  )  ;", "assertFalse ( bean 3  . isRunning (  )  )  ;", "assertFalse ( beanMax . isRunning (  )  )  ;", "context . refresh (  )  ;", "assertTrue ( beanMin . isRunning (  )  )  ;", "assertTrue ( bean 1  . isRunning (  )  )  ;", "assertTrue ( bean 2  . isRunning (  )  )  ;", "assertTrue ( bean 3  . isRunning (  )  )  ;", "assertTrue ( beanMax . isRunning (  )  )  ;", "context . stop (  )  ;", "assertEquals (  5  ,    startedBeans . size (  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,     . getPhase ( startedBeans . get (  0  )  )  )  ;", "assertEquals (  1  ,     . getPhase ( startedBeans . get (  1  )  )  )  ;", "assertEquals (  2  ,     . getPhase ( startedBeans . get (  2  )  )  )  ;", "assertEquals (  3  ,     . getPhase ( startedBeans . get (  3  )  )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,     . getPhase ( startedBeans . get (  4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["smartLifecycleGroupStartup"], "fileName": "org.springframework.context.support.DefaultLifecycleProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . codes )     !  =    null )     &  &     (  ( this . codes . length )     >     0  )     ?    this . codes [  (  ( this . codes . length )     -     1  )  ]     :    null ;", "}", "METHOD_END"], "methodName": ["getCode"], "fileName": "org.springframework.context.support.DefaultMessageSourceResolvable"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "result . append (  \" codes    [  \"  )  . append ( StringUtils . arrayToDelimitedString ( this . codes ,     \"  ,  \"  )  )  ;", "result . append (  \"  ]  ;    arguments    [  \"  )  . append ( StringUtils . arrayToDelimitedString ( this . arguments ,     \"  ,  \"  )  )  ;", "result . append (  \"  ]  ;    default   message    [  \"  )  . append ( this . d )  . append (  '  ]  '  )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["resolvableToString"], "fileName": "org.springframework.context.support.DefaultMessageSourceResolvable"}, {"methodBody": ["METHOD_START", "{", "return    ( this . embeddedValueResolver )     !  =    null    ?    this . embeddedValueResolver . resolveStringValue ( value )     :    value ;", "}", "METHOD_END"], "methodName": ["resolveEmbeddedValue"], "fileName": "org.springframework.context.support.EmbeddedValueResolutionSupport"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   parent    =    new   GenericApplicationContext (  )  ;", "parent . refresh (  )  ;", "AnnotationConfigApplicationContext   child    =    new   AnnotationConfigApplicationContext (  )  ;", "child . setParent ( parent )  ;", "child . refresh (  )  ;", "Configurable   env    =    child . getBean ( Configurable . class )  ;", "assertThat (  \" unknown   env \"  ,    env ,    anyOf ( sameInstance ( parent . get (  )  )  ,    sameInstance ( child . get (  )  )  )  )  ;", "assertThat (  \" expected   child   ctx   env \"  ,    env ,    sameInstance ( child . get (  )  )  )  ;", "child . close (  )  ;", "parent . close (  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.context.support.EnvironmentIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "SecurityManager   securityManager    =    new   SecurityManager (  )     {", "@ Override", "public   void   checkPermission ( Permission   perm )     {", "if    (  \" getenv .  *  \"  . equals ( perm . getName (  )  )  )     {", "throw   new   AccessControlException (  \" Accessing   the   system   environment   is   disallowed \"  )  ;", "}", "if    (  (  \" getenv .  \"     +     ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME )  )  . equals ( perm . getName (  )  )  )     {", "throw   new   AccessControlException ( String . format (  \" Accessing   system   environment   variable    [  % s ]    is   disallowed \"  ,    ACTIVE _ PROFILES _ PROPERTY _ NAME )  )  ;", "}", "}", "}  ;", "System . setSecurityManager ( securityManager )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AnnotatedBeanDefinitionReader   reader    =    new   AnnotatedBeanDefinitionReader ( bf )  ;", "reader . register (  . C 1  . class )  ;", "assertThat ( bf . containsBean (  \" c 1  \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["securityManagerDisallowsAccessToSystemEnvironmentAndDisallowsAccessToIndividualKey"], "fileName": "org.springframework.context.support.EnvironmentSecurityManagerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "SecurityManager   securityManager    =    new   SecurityManager (  )     {", "@ Override", "public   void   checkPermission ( Permission   perm )     {", "if    (  \" getenv .  *  \"  . equals ( perm . getName (  )  )  )     {", "throw   new   AccessControlException (  \" Accessing   the   system   environment   is   disallowed \"  )  ;", "}", "}", "}  ;", "System . setSecurityManager ( securityManager )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AnnotatedBeanDefinitionReader   reader    =    new   AnnotatedBeanDefinitionReader ( bf )  ;", "reader . register (  . C 1  . class )  ;", "assertThat ( bf . containsBean (  \" c 1  \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["securityManagerDisallowsAccessToSystemEnvironmentButAllowsAccessToIndividualKeys"], "fileName": "org.springframework.context.support.EnvironmentSecurityManagerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "originalSecurityManager    =    System . getSecurityManager (  )  ;", "env    =    StandardEnvironmentTests . getModifiableSystemEnvironment (  )  ;", "env . put ( ACTIVE _ PROFILES _ PROPERTY _ NAME ,     \" p 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.context.support.EnvironmentSecurityManagerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "env . remove ( ACTIVE _ PROFILES _ PROPERTY _ NAME )  ;", "System . se ( originalSecurityManager )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.context.support.EnvironmentSecurityManagerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getDefaultListableBeanFactory"], "fileName": "org.springframework.context.support.GenericApplicationContext"}, {"methodBody": ["METHOD_START", "{", "registerBean ( null ,    beanClass ,    supplier ,    customizers )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.support.GenericApplicationContext"}, {"methodBody": ["METHOD_START", "{", "registerBean ( null ,    beanClass ,    null ,    customizers )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.support.GenericApplicationContext"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =     ( supplier    !  =    null )     ?    BeanDefinitionBuilder . genericBeanDefinition ( beanClass ,    supplier )     :    BeanDefinitionBuilder . genericBeanDefinition ( beanClass )  ;", "BeanDefinition   beanDefinition    =    builder . applyCustomizers ( customizers )  . getRawBeanDefinition (  )  ;", "String   nameToUse    =     ( beanName    !  =    null )     ?    beanName    :    beanClass . getName (  )  ;", "registerBeanDefinition ( nameToUse ,    beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.support.GenericApplicationContext"}, {"methodBody": ["METHOD_START", "{", "registerBean ( beanName ,    beanClass ,    null ,    customizers )  ;", "}", "METHOD_END"], "methodName": ["registerBean"], "fileName": "org.springframework.context.support.GenericApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . setAllowBeanDefinitionOverriding ( allowBeanDefinitionOverriding )  ;", "}", "METHOD_END"], "methodName": ["setAllowBeanDefinitionOverriding"], "fileName": "org.springframework.context.support.GenericApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . setAllowCircularReferences ( allowCircularReferences )  ;", "}", "METHOD_END"], "methodName": ["setAllowCircularReferences"], "fileName": "org.springframework.context.support.GenericApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . resourceLoader    =    resourceLoader ;", "}", "METHOD_END"], "methodName": ["setResourceLoader"], "fileName": "org.springframework.context.support.GenericApplicationContext"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( String . class )  )  ;", "ac . refresh (  )  ;", "assertSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( String . class )  )  ;", "assertSame ( ac . getAutowireCapableBeanFactory (  )  . getBean (  \" testBean \"  )  ,    ac . getAutowireCapableBeanFactory (  )  . getBean ( String . class )  )  ;", "ac . close (  )  ;", "try    {", "assertSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( String . class )  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "try    {", "assertSame ( ac . getAutowireCapableBeanFactory (  )  . getBean (  \" testBean \"  )  ,    ac . getAutowireCapableBeanFactory (  )  . getBean ( String . class )  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["accessAfterClosing"], "fileName": "org.springframework.context.support.GenericApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( String . class )  )  ;", "ac . refresh (  )  ;", "assertEquals (  \"  \"  ,    ac . getBean (  \" testBean \"  )  )  ;", "assertSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( String . class )  )  ;", "assertSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( CharSequence . class )  )  ;", "try    {", "assertSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( Object . class )  )  ;", "fail (  \" Should   have   thrown   NoUniqueBeanDefinitionException \"  )  ;", "}    catch    ( NoUniqueBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["getBeanForClass"], "fileName": "org.springframework.context.support.GenericApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( String . class ,    RootBeanDefinition . SCOPE _ PROTOTYPE ,    ac :  : toString )  )  ;", "ac . refresh (  )  ;", "assertNotSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean (  \" testBean \"  )  )  ;", "assertEquals ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( String . class )  )  ;", "assertEquals ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( CharSequence . class )  )  ;", "assertEquals ( ac . toString (  )  ,    ac . getBean (  \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withScopedSupplier"], "fileName": "org.springframework.context.support.GenericApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( String . class ,    ac :  : toString )  )  ;", "ac . refresh (  )  ;", "assertSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean (  \" testBean \"  )  )  ;", "assertSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( String . class )  )  ;", "assertSame ( ac . getBean (  \" testBean \"  )  ,    ac . getBean ( CharSequence . class )  )  ;", "assertEquals ( ac . toString (  )  ,    ac . getBean (  \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withSingletonSupplier"], "fileName": "org.springframework.context.support.GenericApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "return   this . metaClass ;", "}", "METHOD_END"], "methodName": ["getMetaClass"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    ( containsBean ( property )  )     {", "return   getBean ( property )  ;", "} else", "if    ( thisWrapper . isReadableProperty ( property )  )     {", "return   thisWrapper . getPropertyValue ( property )  ;", "}", "throw   new   NoSuchBeanDefinitionException ( property )  ;", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . reader ;", "}", "METHOD_END"], "methodName": ["getReader"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . metaClass . invokeMethod ( this ,    name ,    args )  ;", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    resources    =    new   Resource [ resourceNames . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( resourceNames . length )  ;    i +  +  )     {", "resources [ i ]     =    new   ClassPathResource ( resourceNames [ i ]  ,    relativeClass )  ;", "}", "load ( resources )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( resourceLocations )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( resources )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . metaClass    =    metaClass ;", "}", "METHOD_END"], "methodName": ["setMetaClass"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "if    ( newValue   instanceof   BeanDefinition )     {", "registerBeanDefinition ( property ,     (  ( BeanDefinition )     ( newValue )  )  )  ;", "} else    {", "this . metaClass . setProperty ( this ,    property ,    newValue )  ;", "}", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.context.support.GenericGroovyApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . reader ;", "}", "METHOD_END"], "methodName": ["getReader"], "fileName": "org.springframework.context.support.GenericXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    resources    =    new   Resource [ resourceNames . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( resourceNames . length )  ;    i +  +  )     {", "resources [ i ]     =    new   ClassPathResource ( resourceNames [ i ]  ,    relativeClass )  ;", "}", "this . load ( resources )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.context.support.GenericXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( resourceLocations )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.context.support.GenericXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( resources )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.context.support.GenericXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "this . reader . setValidating ( validating )  ;", "}", "METHOD_END"], "methodName": ["setValidating"], "fileName": "org.springframework.context.support.GenericXmlApplicationContext"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   GenericXmlApplicationContext ( GenericXmlApplicationContextTests . RELATIVE _ CLASS ,    GenericXmlApplicationContextTests . RESOURCE _ NAME )  ;", "assertThat ( ctx . containsBean ( GenericXmlApplicationContextTests . TEST _ BEAN _ NAME )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["classRelativeResourceLoading_ctor"], "fileName": "org.springframework.context.support.GenericXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericXmlApplicationContext   ctx    =    new   GenericXmlApplicationContext (  )  ;", "ctx . load (  . RELATIVE _ CLASS ,     . RESOURCE _ NAME )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  . TEST _ BEAN _ NAME )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["classRelativeResourceLoading_load"], "fileName": "org.springframework.context.support.GenericXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   GenericXmlApplicationContext ( GenericXmlApplicationContextTests . FQ _ RESOURCE _ PATH )  ;", "assertThat ( ctx . containsBean ( GenericXmlApplicationContextTests . TEST _ BEAN _ NAME )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["fullyQualifiedResourceLoading_ctor"], "fileName": "org.springframework.context.support.GenericXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "GenericXmlApplicationContext   ctx    =    new   GenericXmlApplicationContext (  )  ;", "ctx . load (  . FQ _ RESOURCE _ PATH )  ;", "ctx . refresh (  )  ;", "assertThat ( ctx . containsBean (  . TEST _ BEAN _ NAME )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["fullyQualifiedResourceLoading_load"], "fileName": "org.springframework.context.support.GenericXmlApplicationContextTests"}, {"methodBody": ["METHOD_START", "{", "return   startOrder ;", "}", "METHOD_END"], "methodName": ["getStartOrder"], "fileName": "org.springframework.context.support.LifecycleTestBean"}, {"methodBody": ["METHOD_START", "{", "return   stopOrder ;", "}", "METHOD_END"], "methodName": ["getStopOrder"], "fileName": "org.springframework.context.support.LifecycleTestBean"}, {"methodBody": ["METHOD_START", "{", "result . append (  '  [  '  )  ;", "if    (  ( arr . length )     >     0  )     {", "result . append (  '  \\  \"  '  )  ;", "}", "result . append ( StUtils . arrayToDelimitedSt ( arr ,     \"  \\  \"  ,     \\  \"  \"  )  )  ;", "if    (  ( arr . length )     >     0  )     {", "result . append (  '  \\  \"  '  )  ;", "}", "result . append (  '  ]  '  )  ;", "}", "METHOD_END"], "methodName": ["appendArray"], "fileName": "org.springframework.context.support.LiveBeansView"}, {"methodBody": ["METHOD_START", "{", "synchronized ( LiveBeansView . applicationContexts )     {", "return   new   LinkedHashSet <  >  ( LiveBeansView . applicationContexts )  ;", "}", "}", "METHOD_END"], "methodName": ["findApplicationContexts"], "fileName": "org.springframework.context.support.LiveBeansView"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  \"  [  \\ n \"  )  ;", "for    ( Iterator < ConfigurableApplicationContext >    it    =     . iterator (  )  ;    it . hasNext (  )  ;  )     {", "ConfigurableApplicationContext    =    it . next (  )  ;", "result . append (  \"  {  \\ n \\  \"  \"  :     \\  \"  \"  )  . append ( getId (  )  )  . append (  \"  \\  \"  ,  \\ n \"  )  ;", "if    (  ( getParent (  )  )     !  =    null )     {", "result . append (  \"  \\  \" parent \\  \"  :     \\  \"  \"  )  . append ( getParent (  )  . getId (  )  )  . append (  \"  \\  \"  ,  \\ n \"  )  ;", "} else    {", "result . append (  \"  \\  \" parent \\  \"  :    null ,  \\ n \"  )  ;", "}", "result . append (  \"  \\  \" beans \\  \"  :     [  \\ n \"  )  ;", "ConfigurableListableBeanFactory   bf    =    getBeanFactory (  )  ;", "String [  ]    beanNames    =    bf . getBeanDefinitionNames (  )  ;", "boolean   elementAppended    =    false ;", "for    ( String   beanName    :    beanNames )     {", "BeanDefinition   bd    =    bf . getBeanDefinition ( beanName )  ;", "if    ( isBeanEligible ( beanName ,    bd ,    bf )  )     {", "if    ( elementAppended )     {", "result . append (  \"  ,  \\ n \"  )  ;", "}", "result . append (  \"  {  \\ n \\  \" bean \\  \"  :     \\  \"  \"  )  . append ( beanName )  . append (  \"  \\  \"  ,  \\ n \"  )  ;", "result . append (  \"  \\  \" aliases \\  \"  :     \"  )  ;", "appendArray ( result ,    bf . getAliases ( beanName )  )  ;", "result . append (  \"  ,  \\ n \"  )  ;", "String   scope    =    bd . getScope (  )  ;", "if    (  !  ( StringUtils . hasText ( scope )  )  )     {", "scope    =    BeanDefinition . SCOPE _ SINGLETON ;", "}", "result . append (  \"  \\  \" scope \\  \"  :     \\  \"  \"  )  . append ( scope )  . append (  \"  \\  \"  ,  \\ n \"  )  ;", "Class <  ?  >    beanType    =    bf . getType ( beanName )  ;", "if    ( beanType    !  =    null )     {", "result . append (  \"  \\  \" type \\  \"  :     \\  \"  \"  )  . append ( beanType . getName (  )  )  . append (  \"  \\  \"  ,  \\ n \"  )  ;", "} else    {", "result . append (  \"  \\  \" type \\  \"  :    null ,  \\ n \"  )  ;", "}", "result . append (  \"  \\  \" resource \\  \"  :     \\  \"  \"  )  . append ( getEscapedResourceDescription ( bd )  )  . append (  \"  \\  \"  ,  \\ n \"  )  ;", "result . append (  \"  \\  \" dependencies \\  \"  :     \"  )  ;", "appendArray ( result ,    bf . getDependenciesForBean ( beanName )  )  ;", "result . append (  \"  \\ n }  \"  )  ;", "elementAppended    =    true ;", "}", "}", "result . append (  \"  ]  \\ n \"  )  ;", "result . append (  \"  }  \"  )  ;", "if    ( it . hasNext (  )  )     {", "result . append (  \"  ,  \\ n \"  )  ;", "}", "}", "result . append (  \"  ]  \"  )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateJson"], "fileName": "org.springframework.context.support.LiveBeansView"}, {"methodBody": ["METHOD_START", "{", "String   resourceDescription    =    bd . getResourceDescription (  )  ;", "if    ( resourceDescription    =  =    null )     {", "return   null ;", "}", "StringBuilder   result    =    new   StringBuilder (  (  ( resourceDescription . length (  )  )     +     1  6  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( resourceDescription . length (  )  )  ;    i +  +  )     {", "char   character    =    resourceDescription . charAt ( i )  ;", "if    ( character    =  =     '  \\  \\  '  )     {", "result . append (  '  /  '  )  ;", "} else", "if    ( character    =  =     '  \"  '  )     {", "result . append (  \"  \\  \\  \"  )  . append (  '  \"  '  )  ;", "} else    {", "result . append ( character )  ;", "}", "}", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getEscapedResourceDescription"], "fileName": "org.springframework.context.support.LiveBeansView"}, {"methodBody": ["METHOD_START", "{", "return    (  ( bd . getRole (  )  )     !  =     ( BeanDefinition . ROLE _ INFRASTRUCTURE )  )     &  &     (  (  !  ( bd . isLazyInit (  )  )  )     |  |     ( bf . containsSingleton ( beanName )  )  )  ;", "}", "METHOD_END"], "methodName": ["isBeanEligible"], "fileName": "org.springframework.context.support.LiveBeansView"}, {"methodBody": ["METHOD_START", "{", "String   mbeanDomain    =    applicationContext . getEnvironment (  )  . getProperty ( LiveBeansView . MBEAN _ DOMAIN _ PROPERTY _ NAME )  ;", "if    ( mbeanDomain    !  =    null )     {", "synchronized ( LiveBeansView . applicationContexts )     {", "if    ( LiveBeansView . applicationContexts . isEmpty (  )  )     {", "try    {", "MBeanServer   server    =    ManagementFactory . getPlatformMBeanServer (  )  ;", "LiveBeansView . applicationName    =    applicationContext . getApplicationName (  )  ;", "server . registerMBean ( new   LiveBeansView (  )  ,    new   ObjectName ( mbeanDomain ,    LiveBeansView . MBEAN _ APPLICATION _ KEY ,    LiveBeansView . applicationName )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   ApplicationContextException (  \" Failed   to   register   LiveBeansView   MBean \"  ,    ex )  ;", "}", "}", "LiveBeansView . applicationContexts . add ( applicationContext )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerApplicationContext"], "fileName": "org.springframework.context.support.LiveBeansView"}, {"methodBody": ["METHOD_START", "{", "synchronized ( LiveBeansView . applicationContexts )     {", "if    (  ( LiveBeansView . applicationContexts . remove ( applicationContext )  )     &  &     ( LiveBeansView . applicationContexts . isEmpty (  )  )  )     {", "try    {", "MBeanServer   server    =    ManagementFactory . getPlatformMBeanServer (  )  ;", "String   mbeanDomain    =    applicationContext . getEnvironment (  )  . getProperty ( LiveBeansView . MBEAN _ DOMAIN _ PROPERTY _ NAME )  ;", "if    ( mbeanDomain    !  =    null )     {", "server . unregisterMBean ( new   ObjectName ( mbeanDomain ,    LiveBeansView . MBEAN _ APPLICATION _ KEY ,    LiveBeansView . applicationName )  )  ;", "}", "}    catch    ( Throwable   ex )     {", "throw   new   ApplicationContextException (  \" Failed   to   unregister   LiveBeansView   MBean \"  ,    ex )  ;", "}    finally    {", "LiveBeansView . applicationName    =    null ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["unregisterApplicationContext"], "fileName": "org.springframework.context.support.LiveBeansView"}, {"methodBody": ["METHOD_START", "{", "Set < ObjectName >    objectNames    =    searchLiveBeansViewMeans (  )  ;", "assertEquals (  1  ,    objectNames . size (  )  )  ;", "assertEquals (  \" Wrong   MBean   name \"  ,    String . format (  \"  % s : application =  % s \"  ,    this . name . getMethodName (  )  ,    applicationName )  ,    objectNames . iterator (  )  . next (  )  . getCanonicalName (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSingleLiveBeansViewMbean"], "fileName": "org.springframework.context.support.LiveBeansViewTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext    =    mock ( ConfigurableApplicationContext . class )  ;", "given ( getEnvironment (  )  )  . willReturn ( this . environment )  ;", "given ( getApplicationName (  )  )  . willReturn ( applicationName )  ;", "return", "}", "METHOD_END"], "methodName": ["createApplicationContext"], "fileName": "org.springframework.context.support.LiveBeansViewTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    createApplicationContext (  \" app \"  )  ;", "assertEquals (  0  ,    searchMeans (  )  . size (  )  )  ;", ". registerApplicationContext ( context )  ;", "assertEquals (  0  ,    searchMeans (  )  . size (  )  )  ;", ". unregisterApplicationContext ( context )  ;", "}", "METHOD_END"], "methodName": ["registerIgnoredIfPropertyIsNotSet"], "fileName": "org.springframework.context.support.LiveBeansViewTests"}, {"methodBody": ["METHOD_START", "{", "this . environment . setProperty ( LiveBeansView . MBEAN _ DOMAIN _ PROPERTY _ NAME ,    this . name . getMethodName (  )  )  ;", "ConfigurableApplicationContext   context    =    createApplicationContext (  \" app \"  )  ;", "ConfigurableApplicationContext   childContext    =    createApplicationContext (  \" child \"  )  ;", "assertEquals (  0  ,    searchLiveBeansViewMeans (  )  . size (  )  )  ;", "LiveBeansView . registerApplicationContext ( context )  ;", "assertSingleLiveBeansViewMbean (  \" app \"  )  ;", "LiveBeansView . registerApplicationContext ( childContext )  ;", "assertEquals (  1  ,    searchLiveBeansViewMeans (  )  . size (  )  )  ;", "LiveBeansView . unregisterApplicationContext ( childContext )  ;", "assertSingleLiveBeansViewMbean (  \" app \"  )  ;", "LiveBeansView . unregisterApplicationContext ( context )  ;", "assertEquals (  0  ,    searchLiveBeansViewMeans (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerUnregisterServeralContexts"], "fileName": "org.springframework.context.support.LiveBeansViewTests"}, {"methodBody": ["METHOD_START", "{", "this . environment . setProperty ( LiveBeansView . MBEAN _ DOMAIN _ PROPERTY _ NAME ,    this . name . getMethodName (  )  )  ;", "ConfigurableApplicationContext   context    =    createApplicationContext (  \" app \"  )  ;", "ConfigurableApplicationContext   childContext    =    createApplicationContext (  \" child \"  )  ;", "assertEquals (  0  ,    searchLiveBeansViewMeans (  )  . size (  )  )  ;", "LiveBeansView . registerApplicationContext ( context )  ;", "assertSingleLiveBeansViewMbean (  \" app \"  )  ;", "LiveBeansView . registerApplicationContext ( childContext )  ;", "assertSingleLiveBeansViewMbean (  \" app \"  )  ;", "LiveBeansView . unregisterApplicationContext ( context )  ;", "LiveBeansView . unregisterApplicationContext ( childContext )  ;", "assertEquals (  0  ,    searchLiveBeansViewMeans (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerUnregisterServeralContextsDifferentOrder"], "fileName": "org.springframework.context.support.LiveBeansViewTests"}, {"methodBody": ["METHOD_START", "{", "this . environment . setProperty ( LiveBeansView . MBEAN _ DOMAIN _ PROPERTY _ NAME ,    this . name . getMethodName (  )  )  ;", "ConfigurableApplicationContext   context    =    createApplicationContext (  \" app \"  )  ;", "assertEquals (  0  ,    searchLiveBeansViewMeans (  )  . size (  )  )  ;", "LiveBeansView . registerApplicationContext ( context )  ;", "assertSingleLiveBeansViewMbean (  \" app \"  )  ;", "LiveBeansView . unregisterApplicationContext ( context )  ;", "assertEquals (  0  ,    searchLiveBeansViewMeans (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerUnregisterSingleContext"], "fileName": "org.springframework.context.support.LiveBeansViewTests"}, {"methodBody": ["METHOD_START", "{", "String   objectName    =    String . format (  \"  % s :  *  ,  % s =  *  \"  ,    this . name . getMethodName (  )  ,    LiveBeansView . MBEAN _ APPLICATION _ KEY )  ;", "return   ManagementFactory . getPlatformMBeanServer (  )  . queryNames ( new   ObjectName ( objectName )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["searchLiveBeansViewMeans"], "fileName": "org.springframework.context.support.LiveBeansViewTests"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  \" Bean    \"     +     ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["output"], "fileName": "org.springframework.context.support.Logic"}, {"methodBody": ["METHOD_START", "{", "this . a    =    a ;", "}", "METHOD_END"], "methodName": ["setAssembler"], "fileName": "org.springframework.context.support.Logic"}, {"methodBody": ["METHOD_START", "{", "return    ( this . defaultLocale )     !  =    null    ?    this . defaultLocale    :    LocaleContextHolder . getLocale (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultLocale"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSource . getMessage ( code ,    null ,    getDefaultLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSource . getMessage ( code ,    args ,    getDefaultLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    this . messageSource . getMessage ( code ,    args ,    defaultMessage ,    getDefaultLocale (  )  )  ;", "return   msg    !  =    null    ?    msg    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    this . messageSource . getMessage ( code ,    args ,    defaultMessage ,    locale )  ;", "return   msg    !  =    null    ?    msg    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSource . getMessage ( code ,    args ,    locale )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    this . messageSource . getMessage ( code ,    null ,    defaultMessage ,    getDefaultLocale (  )  )  ;", "return   msg    !  =    null    ?    msg    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    this . messageSource . getMessage ( code ,    null ,    defaultMessage ,    locale )  ;", "return   msg    !  =    null    ?    msg    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSource . getMessage ( code ,    null ,    locale )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSource . getMessage ( resolvable ,    getDefaultLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSource . getMessage ( resolvable ,    locale )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.context.support.MessageSourceAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   MessageFormat ( msg ,    locale )  ;", "}", "METHOD_END"], "methodName": ["createMessageFormat"], "fileName": "org.springframework.context.support.MessageSourceSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( isAlwaysUseMessageFormat (  )  )  )     &  &     ( ObjectUtils . isEmpty ( args )  )  )     {", "return   msg ;", "}", "MessageFormat   messageFormat    =    null ;", "synchronized ( this . messageFormatsPerMessage )     {", "Map < Locale ,    MessageFormat >    messageFormatsPerLocale    =    this . messageFormatsPerMessage . get ( msg )  ;", "if    ( messageFormatsPerLocale    !  =    null )     {", "messageFormat    =    messageFormatsPerLocale . get ( locale )  ;", "} else    {", "messageFormatsPerLocale    =    new   HashMap <  >  (  )  ;", "this . messageFormatsPerMessage . put ( msg ,    messageFormatsPerLocale )  ;", "}", "if    ( messageFormat    =  =    null )     {", "try    {", "messageFormat    =    createMessageFormat ( msg ,    locale )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "if    ( isAlwaysUseMessageFormat (  )  )     {", "throw   ex ;", "}", "messageFormat    =     . INVALID _ MESSAGE _ FORMAT ;", "}", "messageFormatsPerLocale . put ( locale ,    messageFormat )  ;", "}", "}", "if    ( messageFormat    =  =     (  . INVALID _ MESSAGE _ FORMAT )  )     {", "return   msg ;", "}", "synchronized ( messageFormat )     {", "return   messageFormat . format ( resolveArguments ( args ,    locale )  )  ;", "}", "}", "METHOD_END"], "methodName": ["formatMessage"], "fileName": "org.springframework.context.support.MessageSourceSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . alwaysUseMessageFormat ;", "}", "METHOD_END"], "methodName": ["isAlwaysUseMessageFormat"], "fileName": "org.springframework.context.support.MessageSourceSupport"}, {"methodBody": ["METHOD_START", "{", "return   formatMessage ( defaultMessage ,    args ,    locale )  ;", "}", "METHOD_END"], "methodName": ["renderDefaultMessage"], "fileName": "org.springframework.context.support.MessageSourceSupport"}, {"methodBody": ["METHOD_START", "{", "return   args    !  =    null    ?    args    :    new   Object [  0  ]  ;", "}", "METHOD_END"], "methodName": ["resolveArguments"], "fileName": "org.springframework.context.support.MessageSourceSupport"}, {"methodBody": ["METHOD_START", "{", "this . alwaysUseMessageFormat    =    alwaysUseMessageFormat ;", "}", "METHOD_END"], "methodName": ["setAlwaysUseMessageFormat"], "fileName": "org.springframework.context.support.MessageSourceSupport"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDefinitionRegistryPostProcessor   postProcessor    :    postProcessors )     {", "postProcessor . postProcessBeanDefinitionRegistry ( registry )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeBeanDefinitionRegistryPostProcessors"], "fileName": "org.springframework.context.support.PostProcessorRegistrationDelegate"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanFactoryPostProcessor   postProcessor    :    postProcessors )     {", "postProcessor . postProcessBeanFactory ( beanFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeBeanFactoryPostProcessors"], "fileName": "org.springframework.context.support.PostProcessorRegistrationDelegate"}, {"methodBody": ["METHOD_START", "{", "Set < String >    processedBeans    =    new   HashSet <  >  (  )  ;", "if    ( beanFactory   instanceof   BeanDefinitionRegistry )     {", "BeanDefinitionRegistry   registry    =     (  ( BeanDefinitionRegistry )     ( beanFactory )  )  ;", "List < BeanFactoryPostProcessor >    regularPostProcessors    =    new   LinkedList <  >  (  )  ;", "List < BeanDefinitionRegistryPostProcessor >    registryProcessors    =    new   LinkedList <  >  (  )  ;", "for    ( BeanFactoryPostProcessor   postProcessor    :    beanFactoryPostProcessors )     {", "if    ( postProcessor   instanceof   BeanDefinitionRegistryPostProcessor )     {", "BeanDefinitionRegistryPostProcessor   registryProcessor    =     (  ( BeanDefinitionRegistryPostProcessor )     ( postProcessor )  )  ;", "registryProcessor . postProcessBeanDefinitionRegistry ( registry )  ;", "registryProcessors . add ( registryProcessor )  ;", "} else    {", "regularPostProcessors . add ( postProcessor )  ;", "}", "}", "List < BeanDefinitionRegistryPostProcessor >    currentRegistryProcessors    =    new   ArrayList <  >  (  )  ;", "String [  ]    postProcessorNames    =    beanFactory . getBeanNamesForType ( BeanDefinitionRegistryPostProcessor . class ,    true ,    false )  ;", "for    ( String   ppName    :    postProcessorNames )     {", "if    ( beanFactory . isTypeMatch ( ppName ,    PriorityOrdered . class )  )     {", "currentRegistryProcessors . add ( beanFactory . getBean ( ppName ,    BeanDefinitionRegistryPostProcessor . class )  )  ;", "processedBeans . add ( ppName )  ;", "}", "}", ". sortPostProcessors ( currentRegistryProcessors ,    beanFactory )  ;", "registryProcessors . addAll ( currentRegistryProcessors )  ;", ". invokeBeanDefinitionRegistryPostProcessors ( currentRegistryProcessors ,    registry )  ;", "currentRegistryProcessors . clear (  )  ;", "postProcessorNames    =    beanFactory . getBeanNamesForType ( BeanDefinitionRegistryPostProcessor . class ,    true ,    false )  ;", "for    ( String   ppName    :    postProcessorNames )     {", "if    (  (  !  ( processedBeans . contains ( ppName )  )  )     &  &     ( beanFactory . isTypeMatch ( ppName ,    Ordered . class )  )  )     {", "currentRegistryProcessors . add ( beanFactory . getBean ( ppName ,    BeanDefinitionRegistryPostProcessor . class )  )  ;", "processedBeans . add ( ppName )  ;", "}", "}", ". sortPostProcessors ( currentRegistryProcessors ,    beanFactory )  ;", "registryProcessors . addAll ( currentRegistryProcessors )  ;", ". invokeBeanDefinitionRegistryPostProcessors ( currentRegistryProcessors ,    registry )  ;", "currentRegistryProcessors . clear (  )  ;", "boolean   reiterate    =    true ;", "while    ( reiterate )     {", "reiterate    =    false ;", "postProcessorNames    =    beanFactory . getBeanNamesForType ( BeanDefinitionRegistryPostProcessor . class ,    true ,    false )  ;", "for    ( String   ppName    :    postProcessorNames )     {", "if    (  !  ( processedBeans . contains ( ppName )  )  )     {", "currentRegistryProcessors . add ( beanFactory . getBean ( ppName ,    BeanDefinitionRegistryPostProcessor . class )  )  ;", "processedBeans . add ( ppName )  ;", "reiterate    =    true ;", "}", "}", ". sortPostProcessors ( currentRegistryProcessors ,    beanFactory )  ;", "registryProcessors . addAll ( currentRegistryProcessors )  ;", ". invokeBeanDefinitionRegistryPostProcessors ( currentRegistryProcessors ,    registry )  ;", "currentRegistryProcessors . clear (  )  ;", "}", ". invokeBeanFactoryPostProcessors ( registryProcessors ,    beanFactory )  ;", ". invokeBeanFactoryPostProcessors ( regularPostProcessors ,    beanFactory )  ;", "} else    {", ". invokeBeanFactoryPostProcessors ( beanFactoryPostProcessors ,    beanFactory )  ;", "}", "String [  ]    postProcessorNames    =    beanFactory . getBeanNamesForType ( BeanFactoryPostProcessor . class ,    true ,    false )  ;", "List < BeanFactoryPostProcessor >    priorityOrderedPostProcessors    =    new   ArrayList <  >  (  )  ;", "List < String >    orderedPostProcessorNames    =    new   ArrayList <  >  (  )  ;", "List < String >    nonOrderedPostProcessorNames    =    new   ArrayList <  >  (  )  ;", "for    ( String   ppName    :    postProcessorNames )     {", "if    ( processedBeans . contains ( ppName )  )     {", "} else", "if    ( beanFactory . isTypeMatch ( ppName ,    PriorityOrdered . class )  )     {", "priorityOrderedPostProcessors . add ( beanFactory . getBean ( ppName ,    BeanFactoryPostProcessor . class )  )  ;", "} else", "if    ( beanFactory . isTypeMatch ( ppName ,    Ordered . class )  )     {", "orderedPostProcessorNames . add ( ppName )  ;", "} else    {", "nonOrderedPostProcessorNames . add ( ppName )  ;", "}", "}", ". sortPostProcessors ( priorityOrderedPostProcessors ,    beanFactory )  ;", ". invokeBeanFactoryPostProcessors ( priorityOrderedPostProcessors ,    beanFactory )  ;", "List < BeanFactoryPostProcessor >    orderedPostProcessors    =    new   ArrayList <  >  (  )  ;", "for    ( String   postProcessorName    :    orderedPostProcessorNames )     {", "orderedPostProcessors . add ( beanFactory . getBean ( postProcessorName ,    BeanFactoryPostProcessor . class )  )  ;", "}", ". sortPostProcessors ( orderedPostProcessors ,    beanFactory )  ;", ". invokeBeanFactoryPostProcessors ( orderedPostProcessors ,    beanFactory )  ;", "List < BeanFactoryPostProcessor >    nonOrderedPostProcessors    =    new   ArrayList <  >  (  )  ;", "for    ( String   postProcessorName    :    nonOrderedPostProcessorNames )     {", "nonOrderedPostProcessors . add ( beanFactory . getBean ( postProcessorName ,    BeanFactoryPostProcessor . class )  )  ;", "}", ". invokeBeanFactoryPostProcessors ( nonOrderedPostProcessors ,    beanFactory )  ;", "beanFactory . clearMetadataCache (  )  ;", "}", "METHOD_END"], "methodName": ["invokeBeanFactoryPostProcessors"], "fileName": "org.springframework.context.support.PostProcessorRegistrationDelegate"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanPostProcessor   postProcessor    :    postProcessors )     {", "beanFactory . addBeanPostProcessor ( postProcessor )  ;", "}", "}", "METHOD_END"], "methodName": ["registerBeanPostProcessors"], "fileName": "org.springframework.context.support.PostProcessorRegistrationDelegate"}, {"methodBody": ["METHOD_START", "{", "String [  ]    postProcessorNames    =    beanFactory . getBeanNamesForType ( BeanPostProcessor . class ,    true ,    false )  ;", "int   beanProcessorTargetCount    =     (  ( beanFactory . getBeanPostProcessorCount (  )  )     +     1  )     +     ( postProcessorNames . length )  ;", "beanFactory . addBeanPostProcessor ( new    . BeanPostProcessorChecker ( beanFactory ,    beanProcessorTargetCount )  )  ;", "List < BeanPostProcessor >    priorityOrderedPostProcessors    =    new   ArrayList <  >  (  )  ;", "List < BeanPostProcessor >    internalPostProcessors    =    new   ArrayList <  >  (  )  ;", "List < String >    orderedPostProcessorNames    =    new   ArrayList <  >  (  )  ;", "List < String >    nonOrderedPostProcessorNames    =    new   ArrayList <  >  (  )  ;", "for    ( String   ppName    :    postProcessorNames )     {", "if    ( beanFactory . isTypeMatch ( ppName ,    PriorityOrdered . class )  )     {", "BeanPostProcessor   pp    =    beanFactory . getBean ( ppName ,    BeanPostProcessor . class )  ;", "priorityOrderedPostProcessors . add ( pp )  ;", "if    ( pp   instanceof   MergedBeanDefinitionPostProcessor )     {", "internalPostProcessors . add ( pp )  ;", "}", "} else", "if    ( beanFactory . isTypeMatch ( ppName ,    class )  )     {", "orderedPostProcessorNames . add ( ppName )  ;", "} else    {", "nonOrderedPostProcessorNames . add ( ppName )  ;", "}", "}", ". sortPostProcessors ( priorityOrderedPostProcessors ,    beanFactory )  ;", ". registerBeanPostProcessors ( beanFactory ,    priorityOrderedPostProcessors )  ;", "List < BeanPostProcessor >    orderedPostProcessors    =    new   ArrayList <  >  (  )  ;", "for    ( String   ppName    :    orderedPostProcessorNames )     {", "BeanPostProcessor   pp    =    beanFactory . getBean ( ppName ,    BeanPostProcessor . class )  ;", "orderedPostProcessors . add ( pp )  ;", "if    ( pp   instanceof   MergedBeanDefinitionPostProcessor )     {", "internalPostProcessors . add ( pp )  ;", "}", "}", ". sortPostProcessors ( orderedPostProcessors ,    beanFactory )  ;", ". registerBeanPostProcessors ( beanFactory ,    orderedPostProcessors )  ;", "List < BeanPostProcessor >    nonOrderedPostProcessors    =    new   ArrayList <  >  (  )  ;", "for    ( String   ppName    :    nonOrderedPostProcessorNames )     {", "BeanPostProcessor   pp    =    beanFactory . getBean ( ppName ,    BeanPostProcessor . class )  ;", "nonOrderedPostProcessors . add ( pp )  ;", "if    ( pp   instanceof   MergedBeanDefinitionPostProcessor )     {", "internalPostProcessors . add ( pp )  ;", "}", "}", ". registerBeanPostProcessors ( beanFactory ,    nonOrderedPostProcessors )  ;", ". sortPostProcessors ( internalPostProcessors ,    beanFactory )  ;", ". registerBeanPostProcessors ( beanFactory ,    internalPostProcessors )  ;", "beanFactory . addBeanPostProcessor ( new   ApplicationListenerDetector ( applicationContext )  )  ;", "}", "METHOD_END"], "methodName": ["registerBeanPostProcessors"], "fileName": "org.springframework.context.support.PostProcessorRegistrationDelegate"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    comparatorToUse    =    null ;", "if    ( beanFactory   instanceof   DefaultListableBeanFactory )     {", "comparatorToUse    =     (  ( DefaultListableBeanFactory )     ( beanFactory )  )  . getDependencyComparator (  )  ;", "}", "if    ( comparatorToUse    =  =    null )     {", "comparatorToUse    =    OrderComparator . INSTANCE ;", "}", "ps . sort ( comparatorToUse )  ;", "}", "METHOD_END"], "methodName": ["sortPostProcessors"], "fileName": "org.springframework.context.support.PostProcessorRegistrationDelegate"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" name $  { var }  \"  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class ,    pvs )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" properties \"  ,     \" var =  $  { m } var \\ nm =  $  { var 2  }  \\ nvar 2  =  $  { var }  \"  )  ;", "ac . registerSingleton (  \" configurer 1  \"  ,    PropertyPlaceholder . class ,    pvs )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithMultiLevelCircularReference"], "fileName": "org.springframework.context.support.PropertyResourceConfigurerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" name $  { var }  \"  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class ,    pvs )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" properties \"  ,     \" var =  $  { m } var \\ nm =  $  { var 2  }  \\ nvar 2  =  $  { m }  \"  )  ;", "ac . registerSingleton (  \" configurer 1  \"  ,    PropertyPlaceholder . class ,    pvs )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithNestedCircularReference"], "fileName": "org.springframework.context.support.PropertyResourceConfigurerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" name $  { var }  \"  )  ;", "ac . registerSingleton (  \" tb 1  \"  ,    TestBean . class ,    pvs )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" properties \"  ,     \" var =  $  { m } var \\ nm =  $  { var 2  }  \\ nvar 2  =  $  { m 2  }  \"  )  ;", "ac . registerSingleton (  \" configurer 1  \"  ,    PropertyPlaceholder . class ,    pvs )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "ex . printStackTrace (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithNestedUnresolvableReference"], "fileName": "org.springframework.context.support.PropertyResourceConfigurerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "ac . registerSingleton (  \" tb \"  ,    TestBean . class ,    pvs )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" location \"  ,     \"  $  { user . dir }  / test /  $  { user . dir }  \"  )  ;", "ac . registerSingleton (  \" configurer \"  ,    PropertyPlaceholder . class ,    pvs )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanInitializationException \"  )  ;", "}    catch    ( BeanInitializationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   FileNotFoundException )  )  ;", "String   userDir    =    StringUtils . cleanPath ( System . getProperty (  \" user . dir \"  )  )  ;", "if    ( userDir . startsWith (  \"  /  \"  )  )     {", "userDir    =    userDir . substring (  1  )  ;", "}", "assertTrue (  (  ( ex . getMessage (  )  . contains (  (  ( userDir    +     \"  / test /  \"  )     +    userDir )  )  )     |  |     ( ex . getMessage (  )  . contains (  (  ( userDir    +     \"  / test /  /  \"  )     +    userDir )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithSystemPropertiesInLocation"], "fileName": "org.springframework.context.support.PropertyResourceConfigurerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "ac . registerSingleton (  \" tb \"  ,    TestBean . class ,    pvs )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" location \"  ,     \"  $  { user . dir }  / test \"  )  ;", "ac . registerSingleton (  \" configurer \"  ,    PropertyPlaceholder . class ,    pvs )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanInitializationException \"  )  ;", "}    catch    ( BeanInitializationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   FileNotFoundException )  )  ;", "String   userDir    =    StringUtils . cleanPath ( System . getProperty (  \" user . dir \"  )  )  ;", "if    ( userDir . startsWith (  \"  /  \"  )  )     {", "userDir    =    userDir . substring (  1  )  ;", "}", "assertTrue (  (  ( ex . getMessage (  )  . indexOf ( userDir )  )     !  =     (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithSystemPropertyInLocation"], "fileName": "org.springframework.context.support.PropertyResourceConfigurerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "ac . registerSingleton (  \" tb \"  ,    TestBean . class ,    pvs )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" location \"  ,     \"  $  { myprop }  / test /  $  { myprop }  \"  )  ;", "ac . registerSingleton (  \" configurer \"  ,    PropertyPlaceholder . class ,    pvs )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanInitializationException \"  )  ;", "}    catch    ( BeanInitializationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" myprop \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithUnresolvableSystemPropertiesInLocation"], "fileName": "org.springframework.context.support.PropertyResourceConfigurerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . appliedPropertySources )     !  =    null )  ,     \" PropertySources   have   not   get   been   applied \"  )  ;", "return   this . appliedPropertySources ;", "}", "METHOD_END"], "methodName": ["getAppliedPropertySources"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "propertyResolver . setPlaceholderPrefix ( this . placeholderPrefix )  ;", "propertyResolver . setPlaceholderSuffix ( this . placeholderSuffix )  ;", "propertyResolver . setValueSeparator ( this . valueSeparator )  ;", "StringValueResolver   valueResolver    =     (    strVal )     -  >     {", "String   resolved    =     ( ignoreUnresolvablePlaceholders )     ?    propertyResolver . resolvePlaceholders ( strVal )     :    propertyResolver . resolveRequiredPlaceholders ( strVal )  ;", "if    ( trimValues )     {", "resolved    =    resolved . trim (  )  ;", "}", "return   resolved . equals ( nullValue )     ?    null    :    resolved ;", "}  ;", "doProcessProperties ( beanFactoryToProcess ,    valueResolver )  ;", "}", "METHOD_END"], "methodName": ["processProperties"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . propertySources    =    new   MutablePropertySources ( propertySources )  ;", "}", "METHOD_END"], "methodName": ["setPropertySources"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "ppc . setPlaceholderPrefix (  \"  @  <  \"  )  ;", "ppc . setPlaceholderSuffix (  \"  >  \"  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  @  < key 1  >  \"  )  . addPropertyValue (  \" sex \"  ,     \"  $  { key 2  }  \"  )  . getBeanDefinition (  )  )  ;", "System . setProperty (  \" key 1  \"  ,     \" systemKey 1 Value \"  )  ;", "System . setProperty (  \" key 2  \"  ,     \" systemKey 2 Value \"  )  ;", "ppc . setEnvironment ( new   StandardEnvironment (  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "System . clearProperty (  \" key 1  \"  )  ;", "System . clearProperty (  \" key 2  \"  )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    is (  \" systemKey 1 Value \"  )  )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getSex (  )  ,    is (  \"  $  { key 2  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customPlaceholderPrefixAndSuffix"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addLast ( new   MockPropertySource (  )  . withProperty (  \" my . name \"  ,     \" foo \"  )  )  ;", "ppc    =    new    (  )  ;", "ppc . setPropertySources ( propertySources )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" foo \"  )  )  ;", "assertEquals ( ppc . getAppliedPropertySources (  )  . iterator (  )  . next (  )  ,    propertySources . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["explicitPropertySources"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addLast ( new   MockPropertySource (  )  )  ;", "ppc    =    new    (  )  ;", "ppc . setPropertySources ( propertySources )  ;", "ppc . setEnvironment ( new   MockEnvironment (  )  . withProperty (  \" my . name \"  ,     \" env \"  )  )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \"  $  { my . name }  \"  )  )  ;", "assertEquals ( ppc . getAppliedPropertySources (  )  . iterator (  )  . next (  )  ,    propertySources . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["explicitPropertySourcesExcludesEnvironment"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addLast ( new   MockPropertySource (  )  )  ;", "ppc    =    new    (  )  ;", "ppc . setPropertySources ( propertySources )  ;", "ppc . setProperties ( new   Properties (  )     {", "{", "put (  \" my . name \"  ,     \" local \"  )  ;", "}", "}  )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \"  $  { my . name }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["explicitPropertySourcesExcludesLocalProperties"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "thrown . expect ( IllegalStateException . class )  ;", "ppc . getAppliedPropertySources (  )  ;", "}", "METHOD_END"], "methodName": ["getAppliedPropertySourcesTooEarly"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc    =    new    (  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "}", "METHOD_END"], "methodName": ["ignoreUnresolvablePlaceholders_falseIsDefault"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc    =    new    (  )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \"  $  { my . name }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ignoreUnresolvablePlaceholders_true"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc    =    new    (  )  ;", "ppc . setProperties ( new   Properties (  )     {", "{", "put (  \" my . name \"  ,     \"  $  { bogus }  \"  )  ;", "}", "}  )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \"  $  { bogus }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ignoredNestedUnresolvablePlaceholder"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { foo }  \"  )  . getBeanDefinition (  )  )  ;", "ppc    =    new    (  )  ;", "ppc . setLocalOverride ( override )  ;", "ppc . setProperties ( new   Properties (  )     {", "{", "setProperty (  \" foo \"  ,     \" local \"  )  ;", "}", "}  )  ;", "ppc . setEnvironment ( new   MockEnvironment (  )  . withProperty (  \" foo \"  ,     \" enclosing \"  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "if    ( override )     {", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" local \"  )  )  ;", "} else    {", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" enclosing \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["localPropertiesOverride"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "localPropertiesOverride ( false )  ;", "}", "METHOD_END"], "methodName": ["localPropertiesOverrideFalse"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "localPropertiesOverride ( true )  ;", "}", "METHOD_END"], "methodName": ["localPropertiesOverrideTrue"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "Resource   resource    =    new   ClassPathResource (  \"  . properties \"  ,    this . getClass (  )  )  ;", "ppc . setLocation ( resource )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["localPropertiesViaResource"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "ClassPathResource   doesNotHave    =    new   ClassPathResource (  \" test . properties \"  ,    getClass (  )  )  ;", "ClassPathResource   setToTrue    =    new   ClassPathResource (  \" placeholder . properties \"  ,    getClass (  )  )  ;", "ppc . setLocations ( doesNotHave ,    setToTrue )  ;", "ppc . setIgnoreResourceNotFound ( true )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" jedi \"  ,     \"  $  { jedi : false }  \"  )  . getBeanDefinition (  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . isJedi (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["multipleLocationsWithDefaultResolvedValue"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc    =    new    (  )  ;", "ppc . setProperties ( new   Properties (  )     {", "{", "put (  \" my . name \"  ,     \"  $  { bogus }  \"  )  ;", "}", "}  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "}", "METHOD_END"], "methodName": ["nestedUnresolvablePlaceholder"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "ppc . setNullValue (  \" customNull \"  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc . setEnvironment ( new   MockEnvironment (  )  . withProperty (  \" my . name \"  ,     \" customNull \"  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["nullValueIsPreserved"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setConversionService ( new   DefaultConversionService (  )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition (  . OptionalTestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "MockEnvironment   env    =    new   MockEnvironment (  )  ;", "env . setProperty (  \" my . name \"  ,     \" myValue \"  )  ;", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "ppc . setEnvironment ( env )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean (  . OptionalTestBean . class )  . getName (  )  ,    equalTo ( Optional . of (  \" myValue \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["optionalPropertyWithValue"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setConversionService ( new   DefaultConversionService (  )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition (  . OptionalTestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "MockEnvironment   env    =    new   MockEnvironment (  )  ;", "env . setProperty (  \" my . name \"  ,     \"  \"  )  ;", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "ppc . setEnvironment ( env )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "ppc . setNullValue (  \"  \"  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean (  . OptionalTestBean . class )  . getName (  )  ,    equalTo ( Optional . empty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["optionalPropertyWithoutValue"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "MockEnvironment   env    =    new   MockEnvironment (  )  ;", "env . setProperty (  \" my . name \"  ,     \" myValue \"  )  ;", "ppc    =    new    (  )  ;", "ppc . setEnvironment ( env )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" myValue \"  )  )  ;", "assertThat ( ppc . getAppliedPropertySources (  )  ,    not ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["replacementFromEnvironmentProperties"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "ppc . setTrimValues ( true )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc . setEnvironment ( new   MockEnvironment (  )  . withProperty (  \" my . name \"  ,     \"    myValue       \"  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" myValue \"  )  )  ;", "}", "METHOD_END"], "methodName": ["trimValuesIsApplied"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertySourcesPlaceholderConfigurer   ppc    =    new   PropertySourcesPlaceholderConfigurer (  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc . setEnvironment ( new   MockEnvironment (  )  . withProperty (  \" my . name \"  ,     \"    myValue       \"  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \"    myValue       \"  )  )  ;", "}", "METHOD_END"], "methodName": ["trimValuesIsOffByDefault"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { foo }  \"  )  . getBeanDefinition (  )  )  ;", "ppc    =    new    (  )  ;", "PropertySource <  ?  >    ps    =    new   PropertySource < Object >  (  \" simplePropertySource \"  ,    new   Object (  )  )     {", "@ Override", "public   Object   getProperty ( String   key )     {", "return    \" bar \"  ;", "}", "}  ;", "MockEnvironment   env    =    new   MockEnvironment (  )  ;", "env . getPropertySources (  )  . addFirst ( ps )  ;", "ppc . setEnvironment ( env )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withNonEnumerablePropertySource"], "fileName": "org.springframework.context.support.PropertySourcesPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Map < Locale ,    List < String >  >    localeMap    =    this . cachedFilenames . get ( basename )  ;", "if    ( localeMap    !  =    null )     {", "List < String >    filenames    =    localeMap . get ( locale )  ;", "if    ( filenames    !  =    null )     {", "return   filenames ;", "}", "}", "List < String >    filenames    =    new   ArrayList <  >  (  7  )  ;", "filenames . addAll ( calculateFilenamesForLocale ( basename ,    locale )  )  ;", "if    (  ( isFallbackToSystemLocale (  )  )     &  &     (  !  ( locale . equals ( Locale . getDefault (  )  )  )  )  )     {", "List < String >    fallbackFilenames    =    calculateFilenamesForLocale ( basename ,    Locale . getDefault (  )  )  ;", "for    ( String   fallbackFilename    :    fallbackFilenames )     {", "if    (  !  ( filenamesains ( fallbackFilename )  )  )     {", "filenames . add ( fallbackFilename )  ;", "}", "}", "}", "filenames . add ( basename )  ;", "if    ( localeMap    =  =    null )     {", "localeMap    =    new   ConcurrentHashMap <  >  (  )  ;", "Map < Locale ,    List < String >  >    existing    =    this . cachedFilenames . putIfAbsent ( basename ,    localeMap )  ;", "if    ( existing    !  =    null )     {", "localeMap    =    existing ;", "}", "}", "localeMap . put ( locale ,    filenames )  ;", "return   filenames ;", "}", "METHOD_END"], "methodName": ["calculateAllFilenames"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  3  )  ;", "String   language    =    locale . getLanguage (  )  ;", "String   country    =    locale . getCountry (  )  ;", "String   variant    =    locale . getVariant (  )  ;", "StringBuilder   temp    =    new   StringBuilder ( basename )  ;", "temp . append (  '  _  '  )  ;", "if    (  ( language . length (  )  )     >     0  )     {", "temp . append ( language )  ;", "result . add (  0  ,    temp . toString (  )  )  ;", "}", "temp . append (  '  _  '  )  ;", "if    (  ( country . length (  )  )     >     0  )     {", "temp . append ( country )  ;", "result . add (  0  ,    temp . toString (  )  )  ;", "}", "if    (  (  ( variant . length (  )  )     >     0  )     &  &     (  (  ( language . length (  )  )     >     0  )     |  |     (  ( country . length (  )  )     >     0  )  )  )     {", "temp . append (  '  _  '  )  . append ( variant )  ;", "result . add (  0  ,    temp . toString (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["calculateFilenamesForLocale"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  \" Clearing   entire   resource   bundle   cache \"  )  ;", "this . cachedProperties . clear (  )  ;", "this . cachedMergedProperties . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "clearCache (  )  ;", "if    (  ( getParentMessageSource (  )  )    instanceof    )     {", "(  (  )     ( getParentMessageSource (  )  )  )  . clearCacheIncludingAncestors (  )  ;", "}", "}", "METHOD_END"], "methodName": ["clearCacheIncludingAncestors"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource . PropertiesHolder   mergedHolder    =    this . cachedMergedProperties . get ( locale )  ;", "if    ( mergedHolder    !  =    null )     {", "return   mergedHolder ;", "}", "Properties   mergedProps    =    newProperties (  )  ;", "long   latestTimestamp    =     -  1  ;", "String [  ]    basenames    =    StringUtils . toStringArray ( getBasenameSet (  )  )  ;", "for    ( int   i    =     ( basenames . length )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "List < String >    filenames    =    calculateAllFilenames ( basenames [ i ]  ,    locale )  ;", "for    ( int   j    =     ( filenames . size (  )  )     -     1  ;    j    >  =     0  ;    j -  -  )     {", "String   filename    =    filenames . get ( j )  ;", "ReloadableResourceBundleMessageSource . PropertiesHolder   propHolder    =    getProperties ( filename )  ;", "if    (  ( propHolder . getProperties (  )  )     !  =    null )     {", "mergedProps . putAll ( propHolder . getProperties (  )  )  ;", "if    (  ( propHolder . getFileTimestamp (  )  )     >    latestTimestamp )     {", "latestTimestamp    =    propHolder . getFileTimestamp (  )  ;", "}", "}", "}", "}", "mergedHolder    =    new   ReloadableResourceBundleMessageSource . PropertiesHolder ( mergedProps ,    latestTimestamp )  ;", "ReloadableResourceBundleMessageSource . PropertiesHolder   existing    =    this . cachedMergedProperties . putIfAbsent ( locale ,    mergedHolder )  ;", "if    ( existing    !  =    null )     {", "mergedHolder    =    existing ;", "}", "return   mergedHolder ;", "}", "METHOD_END"], "methodName": ["getMergedProperties"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource . PropertiesHolder   propHolder    =    this . cachedProperties . get ( filename )  ;", "long   originalTimestamp    =     -  2  ;", "if    ( propHolder    !  =    null )     {", "originalTimestamp    =    propHolder . getRefreshTimestamp (  )  ;", "if    (  ( originalTimestamp    =  =     (  -  1  )  )     |  |     ( originalTimestamp    >     (  ( System . currentTimeMillis (  )  )     -     ( getCacheMillis (  )  )  )  )  )     {", "return   propHolder ;", "}", "} else    {", "propHolder    =    new   ReloadableResourceBundleMessageSource . PropertiesHolder (  )  ;", "ReloadableResourceBundleMessageSource . PropertiesHolder   existingHolder    =    this . cachedProperties . putIfAbsent ( filename ,    propHolder )  ;", "if    ( existingHolder    !  =    null )     {", "propHolder    =    existingHolder ;", "}", "}", "if    (  ( this . concurrentRefresh )     &  &     (  ( propHolder . getRefreshTimestamp (  )  )     >  =     0  )  )     {", "if    (  !  ( propHolder . refreshLock . tryLock (  )  )  )     {", "return   propHolder ;", "}", "} else    {", "propHolder . refreshLock . lock (  )  ;", "}", "try    {", "ReloadableResourceBundleMessageSource . PropertiesHolder   existingHolder    =    this . cachedProperties . get ( filename )  ;", "if    (  ( existingHolder    !  =    null )     &  &     (  ( existingHolder . getRefreshTimestamp (  )  )     >    originalTimestamp )  )     {", "return   existingHolder ;", "}", "return   refreshProperties ( filename ,    propHolder )  ;", "}    finally    {", "propHolder . refreshLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    newProperties (  )  ;", "try    ( InputStream   is    =    resource . getInputStream (  )  )     {", "String   resourceFilename    =    resource . getFilename (  )  ;", "if    (  ( resourceFilename    !  =    null )     &  &     ( resourceFilename . endsWith (  . XML _ SUFFIX )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Loading   properties    [  \"     +     ( resource . getFilename (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "this . propertiesPersister . loadFromXml ( props ,    is )  ;", "} else    {", "String   encoding    =    null ;", "if    (  ( this . fileEncodings )     !  =    null )     {", "encoding    =    this . fileEncodings . getProperty ( filename )  ;", "}", "if    ( encoding    =  =    null )     {", "encoding    =    getDefaultEncoding (  )  ;", "}", "if    ( encoding    !  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Loading   properties    [  \"     +     ( resource . getFilename (  )  )  )     +     \"  ]    with   encoding    '  \"  )     +    encoding )     +     \"  '  \"  )  )  ;", "}", "this . propertiesPersister . load ( props ,    new   InputStreamReader ( is ,    encoding )  )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Loading   properties    [  \"     +     ( resource . getFilename (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "this . propertiesPersister . load ( props ,    is )  ;", "}", "}", "return   props ;", "}", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   new   Properties (  )  ;", "}", "METHOD_END"], "methodName": ["newProperties"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "long   refreshTimestamp    =     (  ( getCacheMillis (  )  )     <     0  )     ?     -  1     :    System . currentTimeMillis (  )  ;", "Resource   resource    =    this . resourceLoader . getResource (  ( filename    +     (  . PROPERTIES _ SUFFIX )  )  )  ;", "if    (  !  ( resource . exists (  )  )  )     {", "resource    =    this . resourceLoader . getResource (  ( filename    +     (  . XML _ SUFFIX )  )  )  ;", "}", "if    ( resource . exists (  )  )     {", "long   fileTimestamp    =     -  1  ;", "if    (  ( getCacheMillis (  )  )     >  =     0  )     {", "try    {", "fileTimestamp    =    resource . lastModified (  )  ;", "if    (  ( propHolder    !  =    null )     &  &     (  ( propHolder . getFileTimestamp (  )  )     =  =    fileTimestamp )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Re - caching   properties   for   filename    [  \"     +    filename )     +     \"  ]     -    file   hasn ' t   been   modified \"  )  )  ;", "}", "propHolder . setRefreshTimestamp ( refreshTimestamp )  ;", "return   propHolder ;", "}", "}    catch    ( IOException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  ( resource    +     \"    could   not   be   resolved   in   the   file   system    -    assuming   that   it   hasn ' t   changed \"  )  ,    ex )  ;", "}", "fileTimestamp    =     -  1  ;", "}", "}", "try    {", "Properties   props    =    loadProperties ( resource ,    filename )  ;", "propHolder    =    new    . PropertiesHolder ( props ,    fileTimestamp )  ;", "}    catch    ( IOException   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Could   not   parse   properties   file    [  \"     +     ( resource . getFilename (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "propHolder    =    new    . PropertiesHolder (  )  ;", "}", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" No   properties   file   found   for    [  \"     +    filename )     +     \"  ]     -    neither   plain   properties   nor   XML \"  )  )  ;", "}", "propHolder    =    new    . PropertiesHolder (  )  ;", "}", "propHolder . setRefreshTimestamp ( refreshTimestamp )  ;", "this . cachedProperties . put ( filename ,    propHolder )  ;", "return   propHolder ;", "}", "METHOD_END"], "methodName": ["refreshProperties"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . concurrentRefresh    =    concurrentRefresh ;", "}", "METHOD_END"], "methodName": ["setConcurrentRefresh"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . fileEncodings    =    fileEncodings ;", "}", "METHOD_END"], "methodName": ["setFileEncodings"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . propertiesPersister    =     ( propertiesPersister    !  =    null )     ?    propertiesPersister    :    new   DefaultPropertiesPersister (  )  ;", "}", "METHOD_END"], "methodName": ["setPropertiesPersister"], "fileName": "org.springframework.context.support.ReloadableResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   classLoader    =    getBundleClassLoader (  )  ;", "Assert . state (  ( classLoader    !  =    null )  ,     \" No   bundle   ClassLoader   set \"  )  ;", "return   ResourceBundle . getBundle ( basename ,    locale ,    classLoader ,    new    . MessageSourceControl (  )  )  ;", "}", "METHOD_END"], "methodName": ["doGetBundle"], "fileName": "org.springframework.context.support.ResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "return    ( this . bundleClassLoader )     !  =    null    ?    this . bundleClassLoader    :    this . beanClassLoader ;", "}", "METHOD_END"], "methodName": ["getBundleClassLoader"], "fileName": "org.springframework.context.support.ResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Map < Locale ,    MessageFormat >  >    codeMap    =    this . cachedBundleMessageFormats . get ( bundle )  ;", "Map < Locale ,    MessageFormat >    localeMap    =    null ;", "if    ( codeMap    !  =    null )     {", "localeMap    =    codeMap . get ( code )  ;", "if    ( localeMap    !  =    null )     {", "MessageFormat   result    =    localeMap . get ( locale )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "}", "String   msg    =    getStringOrNull ( bundle ,    code )  ;", "if    ( msg    !  =    null )     {", "if    ( codeMap    =  =    null )     {", "codeMap    =    new   ConcurrentHashMap <  >  (  )  ;", "Map < String ,    Map < Locale ,    MessageFormat >  >    existing    =    this . cachedBundleMessageFormats . putIfAbsent ( bundle ,    codeMap )  ;", "if    ( existing    !  =    null )     {", "codeMap    =    existing ;", "}", "}", "if    ( localeMap    =  =    null )     {", "localeMap    =    new   ConcurrentHashMap <  >  (  )  ;", "Map < Locale ,    MessageFormat >    existing    =    codeMap . putIfAbsent ( code ,    localeMap )  ;", "if    ( existing    !  =    null )     {", "localeMap    =    existing ;", "}", "}", "MessageFormat   result    =    createMessageFormat ( msg ,    locale )  ;", "localeMap . put ( locale ,    result )  ;", "return   result ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getMessageFormat"], "fileName": "org.springframework.context.support.ResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getCacheMillis (  )  )     >  =     0  )     {", "return   doGetBundle ( basename ,    locale )  ;", "} else    {", "Map < Locale ,     >    localeMap    =    this . cacheds . get ( basename )  ;", "if    ( localeMap    !  =    null )     {", "bundle    =    localeMap . get ( locale )  ;", "if    ( bundle    !  =    null )     {", "return   bundle ;", "}", "}", "try    {", "bundle    =    doGetBundle ( basename ,    locale )  ;", "if    ( localeMap    =  =    null )     {", "localeMap    =    new   ConcurrentHashMap <  >  (  )  ;", "Map < Locale ,     >    existing    =    this . cacheds . putIfAbsent ( basename ,    localeMap )  ;", "if    ( existing    !  =    null )     {", "localeMap    =    existing ;", "}", "}", "localeMap . put ( locale ,    bundle )  ;", "return   bundle ;", "}    catch    ( MissingResourceException   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  (  \"     [  \"     +    basename )     +     \"  ]    not   found   for   MessageSource :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "return   null ;", "}", "}", "}", "METHOD_END"], "methodName": ["getResourceBundle"], "fileName": "org.springframework.context.support.ResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "if    ( bundle . containsKey ( key )  )     {", "try    {", "return   bundle . getString ( key )  ;", "}    catch    ( MissingException   ex )     {", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getStringOrNull"], "fileName": "org.springframework.context.support.ResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "return   new   PropertyResourceBundle ( reader )  ;", "}", "METHOD_END"], "methodName": ["loadBundle"], "fileName": "org.springframework.context.support.ResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "this . bundleClassLoader    =    classLoader ;", "}", "METHOD_END"], "methodName": ["setBundleClassLoader"], "fileName": "org.springframework.context.support.ResourceBundleMessageSource"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "if    ( reloadable )     {", "StaticApplicationContext   parent    =    new   StaticApplicationContext (  )  ;", "parent . refresh (  )  ;", "ac . setParent ( parent )  ;", "}", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "String   basepath    =     \" org / springframework / context / support /  \"  ;", "String [  ]    basenames ;", "if    ( reloadable )     {", "basenames    =    new   String [  ]  {     (  \" classpath :  \"     +    basepath )     +     \" messages \"  ,     (  \" classpath :  \"     +    basepath )     +     \" more - messages \"     }  ;", "} else    {", "basenames    =    new   String [  ]  {    basepath    +     \" messages \"  ,    basepath    +     \" more - messages \"     }  ;", "}", "pvs . add (  \" basenames \"  ,    basenames )  ;", "if    (  ! fallbackToSystemLocale )     {", "pvs . add (  \" fallbackToSystemLocale \"  ,    Boolean . FALSE )  ;", "}", "if    ( useCodeAsDefaultMessage )     {", "pvs . add (  \" useCodeAsDefaultMessage \"  ,    Boolean . TRUE )  ;", "}", "if    ( alwaysUseMessageFormat )     {", "pvs . add (  \" alwaysUseMessageFormat \"  ,    Boolean . TRUE )  ;", "}", "Class <  ?  >    clazz    =     ( reloadable )     ?     (  ( Class <  ?  >  )     ( Reloadable . class )  )     :     . class ;", "ac . registerSingleton (  \" messageSource \"  ,    clazz ,    pvs )  ;", "ac . refresh (  )  ;", "Locale . setDefault (  ( expectGermanFallback    ?    Locale . GERMAN    :    Locale . CANADA )  )  ;", "assertEquals (  \" message 1  \"  ,    ac . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  ( fallbackToSystemLocale    &  &    expectGermanFallback    ?     \" nachricht 2  \"     :     \" message 2  \"  )  ,    ac . getMessage (  \" code 2  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ac . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "assertEquals (  \" nochricht 2  \"  ,    ac . getMessage (  \" code 2  \"  ,    null ,    new   Locale (  \" DE \"  ,     \" at \"  )  )  )  ;", "assertEquals (  \" noochricht 2  \"  ,    ac . getMessage (  \" code 2  \"  ,    null ,    new   Locale (  \" DE \"  ,     \" at \"  ,     \" oo \"  )  )  )  ;", "if    ( reloadable )     {", "assertEquals (  \" nachricht 2 xml \"  ,    ac . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMANY )  )  ;", "}", "MessageSourceAccessor   accessor    =    new   MessageSourceAccessor ( ac )  ;", "LocaleContextHolder . setLocale ( new   Locale (  \" DE \"  ,     \" at \"  )  )  ;", "try    {", "assertEquals (  \" nochricht 2  \"  ,    accessor . getMessage (  \" code 2  \"  )  )  ;", "}    finally    {", "LocaleContextHolder . setLocale ( null )  ;", "}", "assertEquals (  \" message 3  \"  ,    ac . getMessage (  \" code 3  \"  ,    null ,    Locale . ENGLISH )  )  ;", "MessageSourceResolvable   resolvable    =    new   DefaultMessageSourceResolvable (  \" code 3  \"  )  ;", "assertEquals (  \" message 3  \"  ,    ac . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "resolvable    =    new   DefaultMessageSourceResolvable ( new   String [  ]  {     \" code 4  \"  ,     \" code 3  \"     }  )  ;", "assertEquals (  \" message 3  \"  ,    ac . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" message 3  \"  ,    ac . getMessage (  \" code 3  \"  ,    null ,    Locale . ENGLISH )  )  ;", "resolvable    =    new   DefaultMessageSourceResolvable ( new   String [  ]  {     \" code 4  \"  ,     \" code 3  \"     }  )  ;", "assertEquals (  \" message 3  \"  ,    ac . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "Object [  ]    args    =    new   Object [  ]  {     \" Hello \"  ,    new   DefaultMessageSourceResolvable ( new   String [  ]  {     \" code 1  \"     }  )     }  ;", "assertEquals (  \" Hello ,    message 1  \"  ,    ac . getMessage (  \" hello \"  ,    args ,    Locale . ENGLISH )  )  ;", "assertNull ( ac . getMessage ( null ,    null ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" default \"  ,    ac . getMessage ( null ,    null ,     \" default \"  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" default \"  ,    ac . getMessage ( null ,    args ,     \" default \"  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \"  {  0  }  ,    default \"  ,    ac . getMessage ( null ,    null ,     \"  {  0  }  ,    default \"  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" Hello ,    default \"  ,    ac . getMessage ( null ,    args ,     \"  {  0  }  ,    default \"  ,    Locale . ENGLISH )  )  ;", "resolvable    =    new   DefaultMessageSourceResolvable ( null ,    null ,     \" default \"  )  ;", "assertEquals (  \" default \"  ,    ac . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "resolvable    =    new   DefaultMessageSourceResolvable ( null ,    args ,     \" default \"  )  ;", "assertEquals (  \" default \"  ,    ac . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "resolvable    =    new   DefaultMessageSourceResolvable ( null ,    null ,     \"  {  0  }  ,    default \"  )  ;", "assertEquals (  \"  {  0  }  ,    default \"  ,    ac . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "resolvable    =    new   DefaultMessageSourceResolvable ( null ,    args ,     \"  {  0  }  ,    default \"  )  ;", "assertEquals (  \" Hello ,    default \"  ,    ac . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" Arg 1  ,    Arg 2  \"  ,    ac . getMessage (  \" hello \"  ,    new   Object [  ]  {     \" Arg 1  \"  ,     \" Arg 2  \"     }  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \"  {  0  }  ,     {  1  }  \"  ,    ac . getMessage (  \" hello \"  ,    null ,    Locale . ENGLISH )  )  ;", "if    ( alwaysUseMessageFormat )     {", "assertEquals (  \" I ' m \"  ,    ac . getMessage (  \" escaped \"  ,    null ,    Locale . ENGLISH )  )  ;", "} else    {", "assertEquals (  \" I '  ' m \"  ,    ac . getMessage (  \" escaped \"  ,    null ,    Locale . ENGLISH )  )  ;", "}", "assertEquals (  \" I ' m \"  ,    ac . getMessage (  \" escaped \"  ,    new   Object [  ]  {     \" some   arg \"     }  ,    Locale . ENGLISH )  )  ;", "try    {", "assertEquals (  \" code 4  \"  ,    ac . getMessage (  \" code 4  \"  ,    null ,    Locale . GERMAN )  )  ;", "if    (  ! useCodeAsDefaultMessage )     {", "fail (  \" Should   have   thrown   NoSuchMessageException \"  )  ;", "}", "}    catch    ( NoSuchMessageException   ex )     {", "if    ( useCodeAsDefaultMessage )     {", "fail (  \" Should   have   returned   code   as   default   message \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doTestMessageAccess"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundle . clearCache (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . refresh (  )  ;", "assertEquals (  \" default \"  ,    ac . get (  \" code 1  \"  ,    null ,     \" default \"  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" default   value \"  ,    ac . get (  \" code 1  \"  ,    new   Object [  ]  {     \" value \"     }  ,     \" default    {  0  }  \"  ,    Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultApplicationContextMessageSource"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "GenericApplicationContext   parent    =    new   GenericApplicationContext (  )  ;", "parent . refresh (  )  ;", "ac . setParent ( parent )  ;", "ac . refresh (  )  ;", "assertEquals (  \" default \"  ,    ac . get (  \" code 1  \"  ,    null ,     \" default \"  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" default   value \"  ,    ac . get (  \" code 1  \"  ,    new   Object [  ]  {     \" value \"     }  ,     \" default    {  0  }  \"  ,    Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultApplicationContextMessageSourceWithParent"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( false ,    true ,    false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithDefaultMessageSource"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( false ,    true ,    true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithDefaultMessageSourceAndFallbackToGerman"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( false ,    false ,    false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithDefaultMessageSourceAndFallbackTurnedOff"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( false ,    false ,    true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithDefaultMessageSourceAndFallbackTurnedOffAndFallbackToGerman"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( false ,    true ,    false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithDefaultMessageSourceAndMessageFormat"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( true ,    true ,    false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithReloadableMessageSource"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( true ,    true ,    true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithReloadableMessageSourceAndFallbackToGerman"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( true ,    false ,    false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithReloadableMessageSourceAndFallbackTurnedOff"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( true ,    false ,    true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithReloadableMessageSourceAndFallbackTurnedOffAndFallbackToGerman"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "doTestMessageAccess ( true ,    true ,    false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testMessageAccessWithReloadableMessageSourceAndMessageFormat"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleMessageSource   ms    =    new   ResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "MessageSourceResourceBundle   rbe    =    new   MessageSourceResourceBundle ( ms ,    Locale . ENGLISH )  ;", "assertEquals (  \" message 1  \"  ,    rbe . getString (  \" code 1  \"  )  )  ;", "assertTrue ( rbe . containsKey (  \" code 1  \"  )  )  ;", "MessageSourceResourceBundle   rbg    =    new   MessageSourceResourceBundle ( ms ,    Locale . GERMAN )  ;", "assertEquals (  \" nachricht 2  \"  ,    rbg . getString (  \" code 2  \"  )  )  ;", "assertTrue ( rbg . containsKey (  \" code 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMessageSourceResourceBundle"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "List < String >    filenames    =    ms . calculateFilenamesForLocale (  \" messages \"  ,    Locale . ENGLISH )  ;", "assertEquals (  1  ,    filenames . size (  )  )  ;", "assertEquals (  \" messages _ en \"  ,    filenames . get (  0  )  )  ;", "filenames    =    ms . calculateFilenamesForLocale (  \" messages \"  ,    Locale . UK )  ;", "assertEquals (  2  ,    filenames . size (  )  )  ;", "assertEquals (  \" messages _ en \"  ,    filenames . get (  1  )  )  ;", "assertEquals (  \" messages _ en _ GB \"  ,    filenames . get (  0  )  )  ;", "filenames    =    ms . calculateFilenamesForLocale (  \" messages \"  ,    new   Locale (  \" en \"  ,     \" GB \"  ,     \" POSIX \"  )  )  ;", "assertEquals (  3  ,    filenames . size (  )  )  ;", "assertEquals (  \" messages _ en \"  ,    filenames . get (  2  )  )  ;", "assertEquals (  \" messages _ en _ GB \"  ,    filenames . get (  1  )  )  ;", "assertEquals (  \" messages _ en _ GB _ POSIX \"  ,    filenames . get (  0  )  )  ;", "filenames    =    ms . calculateFilenamesForLocale (  \" messages \"  ,    new   Locale (  \" en \"  ,     \"  \"  ,     \" POSIX \"  )  )  ;", "assertEquals (  2  ,    filenames . size (  )  )  ;", "assertEquals (  \" messages _ en \"  ,    filenames . get (  1  )  )  ;", "assertEquals (  \" messages _ en _  _ POSIX \"  ,    filenames . get (  0  )  )  ;", "filenames    =    ms . calculateFilenamesForLocale (  \" messages \"  ,    new   Locale (  \"  \"  ,     \" UK \"  ,     \" POSIX \"  )  )  ;", "assertEquals (  2  ,    filenames . size (  )  )  ;", "assertEquals (  \" messages _  _ UK \"  ,    filenames . get (  1  )  )  ;", "assertEquals (  \" messages _  _ UK _ POSIX \"  ,    filenames . get (  0  )  )  ;", "filenames    =    ms . calculateFilenamesForLocale (  \" messages \"  ,    new   Locale (  \"  \"  ,     \"  \"  ,     \" POSIX \"  )  )  ;", "assertEquals (  0  ,    filenames . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceFileNameCalculation"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceStandalone"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "ms . setCacheSeconds (  1  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "Thread . sleep (  1  1  0  0  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceWithCacheSeconds"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "Properties   commonMessages    =    new   Properties (  )  ;", "commonMessages . setProperty (  \" warning \"  ,     \" Do   not   do    {  0  }  \"  )  ;", "ms . setCommonMessages ( commonMessages )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "assertEquals (  \" Do   not   do   this \"  ,    ms . getMessage (  \" warning \"  ,    new   Object [  ]  {     \" this \"     }  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" Do   not   do   that \"  ,    ms . getMessage (  \" warning \"  ,    new   Object [  ]  {     \" that \"     }  ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceWithCommonMessages"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "ms . setDefaultEncoding (  \" ISO -  8  8  5  9  -  1  \"  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceWithDefaultCharset"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "ms . setDefaultEncoding (  \" unicode \"  )  ;", "Properties   fileCharsets    =    new   Properties (  )  ;", "fileCharsets . setProperty (  \" org / springframework / context / support / messages _ de \"  ,     \" unicode \"  )  ;", "ms . setFileEncodings ( fileCharsets )  ;", "ms . setFallbackToSystemLocale ( false )  ;", "try    {", "ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  ;", "fail (  \" Should   have   thrown   NoSuchMessageException \"  )  ;", "}    catch    ( NoSuchMessageException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceWithInappropriateDefaultCharset"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "ms . setFallbackToSystemLocale ( false )  ;", "Properties   fileCharsets    =    new   Properties (  )  ;", "fileCharsets . setProperty (  \" org / springframework / context / support / messages \"  ,     \" unicode \"  )  ;", "ms . setFileEncodings ( fileCharsets )  ;", "try    {", "ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  ;", "fail (  \" Should   have   thrown   NoSuchMessageException \"  )  ;", "}    catch    ( NoSuchMessageException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceWithInappropriateEnglishCharset"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "ms . setFallbackToSystemLocale ( false )  ;", "Properties   fileCharsets    =    new   Properties (  )  ;", "fileCharsets . setProperty (  \" org / springframework / context / support / messages _ de \"  ,     \" unicode \"  )  ;", "ms . setFileEncodings ( fileCharsets )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" message 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceWithInappropriateGermanCharset"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "ms . setCacheSeconds (  1  )  ;", "ms . setConcurrentRefresh ( false )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "Thread . sleep (  1  1  0  0  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceWithNonConcurrentRefresh"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ReloadableResourceBundleMessageSource   ms    =    new   ReloadableResourceBundleMessageSource (  )  ;", "ms . setBasename (  \"       org / springframework / context / support / messages       \"  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testReloadableResourceBundleMessageSourceWithWhitespaceInBasename"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleMessageSource   ms    =    new   ResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceBundleMessageSourceStandalone"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleMessageSource   ms    =    new   ResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "ms . setDefaultEncoding (  \" ISO -  8  8  5  9  -  1  \"  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceBundleMessageSourceWithDefaultCharset"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleMessageSource   ms    =    new   ResourceBundleMessageSource (  )  ;", "ms . setBasename (  \" org / springframework / context / support / messages \"  )  ;", "ms . setDefaultEncoding (  \" argh \"  )  ;", "ms . setFallbackToSystemLocale ( false )  ;", "try    {", "ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  ;", "fail (  \" Should   have   thrown   NoSuchMessageException \"  )  ;", "}    catch    ( NoSuchMessageException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testResourceBundleMessageSourceWithInappropriateDefaultCharset"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleMessageSource   ms    =    new   ResourceBundleMessageSource (  )  ;", "ms . setBasename (  \"       org / springframework / context / support / messages       \"  )  ;", "assertEquals (  \" message 1  \"  ,    ms . getMessage (  \" code 1  \"  ,    null ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" nachricht 2  \"  ,    ms . getMessage (  \" code 2  \"  ,    null ,    Locale . GERMAN )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceBundleMessageSourceWithWhitespaceInBasename"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "GenericApplicationContext   parent    =    new   GenericApplicationContext (  )  ;", "parent . refresh (  )  ;", "ac . setParent ( parent )  ;", "ac . refresh (  )  ;", "assertEquals (  \" default \"  ,    ac . get (  \" code 1  \"  ,    null ,     \" default \"  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" default   value \"  ,    ac . get (  \" code 1  \"  ,    new   Object [  ]  {     \" value \"     }  ,     \" default    {  0  }  \"  ,    Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticApplicationContextMessageSourceWithDefaultParent"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "StaticApplicationContext   parent    =    new   StaticApplicationContext (  )  ;", "parent . refresh (  )  ;", "ac . setParent ( parent )  ;", "ac . refresh (  )  ;", "assertEquals (  \" default \"  ,    ac . get (  \" code 1  \"  ,    null ,     \" default \"  ,    Locale . ENGLISH )  )  ;", "assertEquals (  \" default   value \"  ,    ac . get (  \" code 1  \"  ,    new   Object [  ]  {     \" value \"     }  ,     \" default    {  0  }  \"  ,    Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticApplicationContextMessageSourceWithStaticParent"], "fileName": "org.springframework.context.support.ResourceBundleMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "assertFactoryCountThroughoutLifecycle ( new   ClassPathXmlApplicationContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["abstractRefreshableContext"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  )     {", "@ Override", "protected   void   customizeBeanFactory ( DefaultList   beanFactory )     {", "super . customizeBeanFactory ( beanFactory )  ;", "registerMisconfiguredBeanDefinition ( beanFactory )  ;", "}", "}  ;", "assertFactoryCountThroughoutLifecycle ( ctx )  ;", "}", "METHOD_END"], "methodName": ["abstractRefreshableContextWithMisconfiguredBean"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( serializableFactoryCount (  )  ,    equalTo (  0  )  )  ;", "try    {", "ctx . refresh (  )  ;", "assertThat ( serializableFactoryCount (  )  ,    equalTo (  1  )  )  ;", "ctx . close (  )  ;", "}    catch    ( BeanCreationException   ex )     {", "}    finally    {", "assertThat ( serializableFactoryCount (  )  ,    equalTo (  0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertFactoryCountThroughoutLifecycle"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "assertFactoryCountThroughoutLifecycle ( new   GenericApplicationContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["genericContext"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "registerMisconfiguredBeanDefinition ( ctx )  ;", "assertCountThroughoutLifecycle ( ctx )  ;", "}", "METHOD_END"], "methodName": ["genericContextWithMisconfiguredBean"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    DefaultListableBeanFactory . class . getDeclaredField (  \" serializableFactories \"  )  ;", "field . setAccessible ( true )  ;", "return    (  ( Map <  ?  ,     ?  >  )     ( field . get ( DefaultListableBeanFactory . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSerializableFactoryMap"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "registry . registerBeanDefinition (  \" misconfigured \"  ,    rootBeanDefinition ( Object . class )  . addPropertyValue (  \" nonexistent \"  ,     \" bogus \"  )  . getBeanDefinition (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerMisconfiguredBeanDefinition"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "Map <  ?  ,     ?  >    map    =    SerializableBeanFactoryMemoryLeakTests . getSerializableFactoryMap (  )  ;", "return   map . size (  )  ;", "}", "METHOD_END"], "methodName": ["serializableFactoryCount"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "SerializableBeanFactoryMemoryLeakTests . getSerializableFactoryMap (  )  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["zeroOutFactoryCount"], "fileName": "org.springframework.context.support.SerializableBeanFactoryMemoryLeakTests"}, {"methodBody": ["METHOD_START", "{", "return   messageSource ;", "}", "METHOD_END"], "methodName": ["getMessageSource"], "fileName": "org.springframework.context.support.Service"}, {"methodBody": ["METHOD_START", "{", "return   resources ;", "}", "METHOD_END"], "methodName": ["getResources"], "fileName": "org.springframework.context.support.Service"}, {"methodBody": ["METHOD_START", "{", "return   properlyDestroyed ;", "}", "METHOD_END"], "methodName": ["isProperlyDestroyed"], "fileName": "org.springframework.context.support.Service"}, {"methodBody": ["METHOD_START", "{", "this . resources    =    resources ;", "}", "METHOD_END"], "methodName": ["setResources"], "fileName": "org.springframework.context.support.Service"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" threadScopedObject \"  ;", "TestBean   bean    =     (  ( TestBean )     ( this . applicationContext . getBean ( name )  )  )  ;", "assertNotNull ( bean )  ;", "assertSame ( bean ,    this . applicationContext . getBean ( name )  )  ;", "TestBean   bean 2     =     (  ( TestBean )     ( this . applicationContext . getBean ( name )  )  )  ;", "assertSame ( bean ,    bean 2  )  ;", "}", "METHOD_END"], "methodName": ["getFromScope"], "fileName": "org.springframework.context.support.SimpleThreadScopeTests"}, {"methodBody": ["METHOD_START", "{", "final   TestBean [  ]    beans    =    new   TestBean [  2  ]  ;", "Thread   thread 1     =    new   Thread ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "beans [  0  ]     =    applicationContext . getBean (  \" tdObject \"  ,    TestBean . class )  ;", "}", "}  )  ;", "Thread   thread 2     =    new   Thread ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "beans [  1  ]     =    applicationContext . getBean (  \" tdObject \"  ,    TestBean . class )  ;", "}", "}  )  ;", "thread 1  . start (  )  ;", "thread 2  . start (  )  ;", "Thread . sleep (  2  0  0  )  ;", "assertNotNull ( beans [  0  ]  )  ;", "assertNotNull ( beans [  1  ]  )  ;", "assertNotSame ( beans [  0  ]  ,    beans [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["getMultipleInstances"], "fileName": "org.springframework.context.support.SimpleThreadScopeTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" spr 7  2  8  3  . xml \"  ,    getClass (  )  )  ;", "List <  ?  >    list    =    ctx . getBean (  \" list \"  ,    List . class )  ;", "assertEquals (  2  ,    list . size (  )  )  ;", "assertTrue (  (  ( list . get (  0  )  )    instanceof    . A )  )  ;", "assertTrue (  (  ( list . get (  1  )  )    instanceof    . B )  )  ;", "}", "METHOD_END"], "methodName": ["testListWithInconsistentElementType"], "fileName": "org.springframework.context.support.Spr7283Tests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" spr 7  8  1  6  . xml \"  ,    getClass (  )  )  ;", ". FilterAdapter   adapter    =    ctx . getBean (  . FilterAdapter . class )  ;", "assertEquals (  . Building . class ,    adapter . getSupportedTypes (  )  . get (  \" Building \"  )  )  ;", "assertEquals (  . Entrance . class ,    adapter . getSupportedTypes (  )  . get (  \" Entrance \"  )  )  ;", "assertEquals (  . Dwelling . class ,    adapter . getSupportedTypes (  )  . get (  \" Dwelling \"  )  )  ;", "}", "METHOD_END"], "methodName": ["spr7816"], "fileName": "org.springframework.context.support.Spr7816Tests"}, {"methodBody": ["METHOD_START", "{", "getStaticMessageSource (  )  . addMessage ( code ,    locale ,    defaultMessage )  ;", "}", "METHOD_END"], "methodName": ["addMessage"], "fileName": "org.springframework.context.support.StaticApplicationContext"}, {"methodBody": ["METHOD_START", "{", "return   this . staticMessageSource ;", "}", "METHOD_END"], "methodName": ["getStaticMessageSource"], "fileName": "org.springframework.context.support.StaticApplicationContext"}, {"methodBody": ["METHOD_START", "{", "GenericBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "bd . setBeanClass ( clazz )  ;", "getDefaultListableBeanFactory (  )  . registerBeanDefinition ( name ,    bd )  ;", "}", "METHOD_END"], "methodName": ["registerPrototype"], "fileName": "org.springframework.context.support.StaticApplicationContext"}, {"methodBody": ["METHOD_START", "{", "GenericBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "bd . setBeanClass ( clazz )  ;", "bd . setPropertyValues ( pvs )  ;", "getDefaultListableBeanFactory (  )  . registerBeanDefinition ( name ,    bd )  ;", "}", "METHOD_END"], "methodName": ["registerPrototype"], "fileName": "org.springframework.context.support.StaticApplicationContext"}, {"methodBody": ["METHOD_START", "{", "GenericBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setBeanClass ( clazz )  ;", "getDefaultListableBeanFactory (  )  . registerBeanDefinition ( name ,    bd )  ;", "}", "METHOD_END"], "methodName": ["registerSingleton"], "fileName": "org.springframework.context.support.StaticApplicationContext"}, {"methodBody": ["METHOD_START", "{", "GenericBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setBeanClass ( clazz )  ;", "bd . setPropertyValues ( pvs )  ;", "getDefaultListableBeanFactory (  )  . registerBeanDefinition ( name ,    bd )  ;", "}", "METHOD_END"], "methodName": ["registerSingleton"], "fileName": "org.springframework.context.support.StaticApplicationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( code ,     \" Code   must   not   be   null \"  )  ;", "Assert . notNull ( locale ,     \" Locale   must   not   be   null \"  )  ;", "Assert . notNull ( msg ,     \"    must   not   be   null \"  )  ;", "this . messages . put (  (  ( code    +     '  _  '  )     +     ( locale . toString (  )  )  )  ,    msg )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  (  \" Added   message    [  \"     +    msg )     +     \"  ]    for   code    [  \"  )     +    code )     +     \"  ]    and   Locale    [  \"  )     +    locale )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addMessage"], "fileName": "org.springframework.context.support.StaticMessageSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messages ,     \" Messages   Map   must   not   be   null \"  )  ;", "messages . forEach (  (    code ,    msg )     -  >    addMessage ( code ,    locale ,    msg )  )  ;", "}", "METHOD_END"], "methodName": ["addMessages"], "fileName": "org.springframework.context.support.StaticMessageSource"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" valid   msg   from   staticMsgSource   with   default   msg   passed   in   returned   msg   from   msg   catalog   for   Locale . US \"  ,    sac . getMessage (  \" message . format . example 2  \"  ,    null ,     \" This   is   a   default   msg   if   not   found   in   MessageSource .  \"  ,    Locale . US )  . equals (  \" This   is   a   test   message   in   the   message   catalog   with   no   args .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageWithDefaultPassedInAndFoundInMsgCatalog"], "fileName": "org.springframework.context.support.StaticMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" bogus   msg   from   staticMsgSource   with   default   msg   passed   in   returned   default   msg   for   Locale . US \"  ,    sac . getMessage (  \" bogus . message \"  ,    null ,     \" This   is   a   default   msg   if   not   found   in   MessageSource .  \"  ,    Locale . US )  . equals (  \" This   is   a   default   msg   if   not   found   in   MessageSource .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageWithDefaultPassedInAndNotFoundInMsgCatalog"], "fileName": "org.springframework.context.support.StaticMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    arguments    =    new   Object [  ]  {    new   Integer (  7  )  ,    new   Date ( System . currentTimeMillis (  )  )  ,     \" a   disturbance   in   the   Force \"     }  ;", "sac . get (  \" message . format . example 1  \"  ,    arguments ,    Locale . US )  ;", "assertTrue (  \"  2 nd   search   within   MsgFormat   cache   returned   expected   message   for   Locale . US \"  ,     (  ( sac . get (  \" message . format . example 1  \"  ,    arguments ,    Locale . US )  . indexOf (  \" there   was    \\  \" a   disturbance   in   the   Force \\  \"    on   planet    7  .  \"  )  )     !  =     (  -  1  )  )  )  ;", "Object [  ]    newArguments    =    new   Object [  ]  {    new   Integer (  8  )  ,    new   Date ( System . currentTimeMillis (  )  )  ,     \" a   disturbance   in   the   Force \"     }  ;", "assertTrue (  \"  2 nd   search   within   MsgFormat   cache   with   different   args   returned   expected   message   for   Locale . US \"  ,     (  ( sac . get (  \" message . format . example 1  \"  ,    newArguments ,    Locale . US )  . indexOf (  \" there   was    \\  \" a   disturbance   in   the   Force \\  \"    on   planet    8  .  \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageWithMessageAlreadyLookedFor"], "fileName": "org.springframework.context.support.StaticMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    arguments    =    new   Object [  ]  {    new   Integer (  7  )  ,    new   Date ( System . currentTimeMillis (  )  )  ,     \" a   disturbance   in   the   Force \"     }  ;", "assertTrue (  \" msg   from   staticMsgSource   for   Locale . US   substituting   args   for   placeholders   is   as   expected \"  ,     (  ( sac . get (  \" message . format . example 1  \"  ,    arguments ,    Locale . US )  . indexOf (  \" there   was    \\  \" a   disturbance   in   the   Force \\  \"    on   planet    7  .  \"  )  )     !  =     (  -  1  )  )  )  ;", "assertTrue (  \" msg   from   staticMsgSource   for   Locale . UK   substituting   args   for   placeholders   is   as   expected \"  ,     (  ( sac . get (  \" message . format . example 1  \"  ,    arguments ,    Locale . UK )  . indexOf (  \" there   was    \\  \" a   disturbance   in   the   Force \\  \"    on   station   number    7  .  \"  )  )     !  =     (  -  1  )  )  )  ;", "assertTrue (  \" msg   from   staticMsgSource   for   Locale . US   that   requires   no   args   is   as   expected \"  ,    sac . get (  \" message . format . example 2  \"  ,    null ,    Locale . US )  . equals (  \" This   is   a   test   message   in   the   message   catalog   with   no   args .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageWithNoDefaultPassedInAndFoundInMsgCatalog"], "fileName": "org.springframework.context.support.StaticMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "sac . getMessage (  \" bogus . message \"  ,    null ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["getMessageWithNoDefaultPassedInAndNotFoundInMsgCatalog"], "fileName": "org.springframework.context.support.StaticMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    codes 1     =    new   String [  ]  {     \" message . format . example 3  \"  ,     \" message . format . example 2  \"     }  ;", "MessageSourceResolvable   resolvable 1     =    new   DefaultMessageSourceResolvable ( codes 1  ,    null ,     \" default \"  )  ;", "assertTrue (  \" correct   message   retrieved \"  ,     . MSG _ TXT 3  _ US . equals ( sac . getMessage ( resolvable 1  ,    Locale . US )  )  )  ;", "String [  ]    codes 2     =    new   String [  ]  {     \" message . format . example 9  9  \"  ,     \" message . format . example 2  \"     }  ;", "MessageSourceResolvable   resolvable 2     =    new   DefaultMessageSourceResolvable ( codes 2  ,    null ,     \" default \"  )  ;", "assertTrue (  \" correct   message   retrieved \"  ,     . MSG _ TXT 2  _ US . equals ( sac . getMessage ( resolvable 2  ,    Locale . US )  )  )  ;", "String [  ]    codes 3     =    new   String [  ]  {     \" message . format . example 9  9  \"  ,     \" message . format . example 9  8  \"     }  ;", "MessageSourceResolvable   resolvable 3     =    new   DefaultMessageSourceResolvable ( codes 3  ,    null ,     \" default \"  )  ;", "assertTrue (  \" correct   message   retrieved \"  ,     \" default \"  . equals ( sac . getMessage ( resolvable 3  ,    Locale . US )  )  )  ;", "String [  ]    codes 4     =    new   String [  ]  {     \" message . format . example 9  9  \"  ,     \" message . format . example 9  8  \"     }  ;", "MessageSourceResolvable   resolvable 4     =    new   DefaultMessageSourceResolvable ( codes 4  )  ;", "exception . expect ( NoSuchMessageException . class )  ;", "sac . getMessage ( resolvable 4  ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["messageSourceResolvable"], "fileName": "org.springframework.context.support.StaticMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "StaticMessageSource   source    =    new   StaticMessageSource (  )  ;", "StaticMessageSource   parent    =    new   StaticMessageSource (  )  ;", "source . setParentMessageSource ( parent )  ;", "source . addMessage (  \" param \"  ,    Locale . ENGLISH ,     \" value \"  )  ;", "parent . addMessage (  \" with . param \"  ,    Locale . ENGLISH ,     \" put    {  0  }    here \"  )  ;", "MessageSourceResolvable   resolvable    =    new   DefaultMessageSourceResolvable ( new   String [  ]  {     \" with . param \"     }  ,    new   Object [  ]  {    new   DefaultMessageSourceResolvable (  \" param \"  )     }  )  ;", "assertEquals (  \" put   value   here \"  ,    source . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["nestedMessageSourceWithParamInChild"], "fileName": "org.springframework.context.support.StaticMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "StaticMessageSource   source    =    new   StaticMessageSource (  )  ;", "StaticMessageSource   parent    =    new   StaticMessageSource (  )  ;", "source . setParentMessageSource ( parent )  ;", "parent . addMessage (  \" param \"  ,    Locale . ENGLISH ,     \" value \"  )  ;", "source . addMessage (  \" with . param \"  ,    Locale . ENGLISH ,     \" put    {  0  }    here \"  )  ;", "MessageSourceResolvable   resolvable    =    new   DefaultMessageSourceResolvable ( new   String [  ]  {     \" with . param \"     }  ,    new   Object [  ]  {    new   DefaultMessageSourceResolvable (  \" param \"  )     }  )  ;", "assertEquals (  \" put   value   here \"  ,    source . getMessage ( resolvable ,    Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["nestedMessageSourceWithParamInParent"], "fileName": "org.springframework.context.support.StaticMessageSourceTests"}, {"methodBody": ["METHOD_START", "{", "if    ( weaverToUse    =  =    null )     {", "if    ( InstrumentationLoadTimeWeaver . isInstrumentationAvailable (  )  )     {", "weaverToUse    =    new   InstrumentationLoadTimeWeaver ( beanClassLoader )  ;", "} else    {", "throw   new   IllegalStateException (  \" No   LoadTimeWeaver   available \"  )  ;", "}", "}", "weaverToUse . addTransformer ( new    . AspectJClassBypassingClassFileTransformer ( new   ClassPreProcessorAgentAdapter (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["enableAspectJWeaving"], "fileName": "org.springframework.context.weaving.AspectJWeavingEnabler"}, {"methodBody": ["METHOD_START", "{", "String   name    =    classLoader . getClass (  )  . getName (  )  ;", "try    {", "if    ( name . startsWith (  \" catalina \"  )  )     {", "return   new   TomcatLoadTimeWeaver ( classLoader )  ;", "} else", "if    ( name . startsWith (  \" glassfish \"  )  )     {", "return   new   instrument . classloading . glassfish . GlassFishLoadTimeWeaver ( classLoader )  ;", "} else", "if    ( name . startsWith (  \" modules \"  )  )     {", "return   new   instrument . classloading . jboss . JBossLoadTimeWeaver ( classLoader )  ;", "} else", "if    ( name . startsWith (  \" com . ibm . ws . classloader \"  )  )     {", "return   new   instrument . classloading . websphere . WebSphereLoadTimeWeaver ( classLoader )  ;", "} else", "if    ( name . startsWith (  \" weblogic \"  )  )     {", "return   new   instrument . classloading . weblogic . WebLogicLoadTimeWeaver ( classLoader )  ;", "}", "}    catch    ( Exception   ex )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Could   not   obtain   server - specific   LoadTimeWeaver :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["createServerSpecificLoadTimeWeaver"], "fileName": "org.springframework.context.weaving.DefaultContextLoadTimeWeaver"}, {"methodBody": ["METHOD_START", "{", "if    ( this . refreshHomeOnConnectFailure )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Could   not   connect   to   r   EJB    [  \"     +     ( getJndiName (  )  )  )     +     \"  ]     -    retrying \"  )  ,    ex )  ;", "} else", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Could   not   connect   to   r   EJB    [  \"     +     ( getJndiName (  )  )  )     +     \"  ]     -    retrying \"  )  )  ;", "}", "return   refreshAndRetry ( invocation )  ;", "} else    {", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["handleRemoteConnectFailure"], "fileName": "org.springframework.ejb.access.AbstractRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   RmiClientInterceptorUtils . isConnectFailure ( ex )  ;", "}", "METHOD_END"], "methodName": ["isConnectFailure"], "fileName": "org.springframework.ejb.access.AbstractRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" Trying   to   create   reference   to   r   EJB \"  )  ;", "}", "Object   ejbInstance    =    create (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Obtained   reference   to   r   EJB :     \"     +    ejbInstance )  )  ;", "}", "return   ejbInstance ;", "}", "METHOD_END"], "methodName": ["newSessionBeanInstance"], "fileName": "org.springframework.ejb.access.AbstractRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "refreshHome (  )  ;", "}    catch    ( NamingException   ex )     {", "throw   new   LookupFailureException (  (  (  \" Failed   to   locate   remote   EJB    [  \"     +     ( getJndiName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "return   doInvoke ( invocation )  ;", "}", "METHOD_END"], "methodName": ["refreshAndRetry"], "fileName": "org.springframework.ejb.access.AbstractRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ejb    !  =    null )     &  &     (  !  ( this . homeAsComponent )  )  )     {", "try    {", "ejb . remove (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . warn (  \" Could   not   invoke    ' remove '    on   r   EJB   proxy \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeSessionBeanInstance"], "fileName": "org.springframework.ejb.access.AbstractRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . refreshHomeOnConnectFailure    =    refreshHomeOnConnectFailure ;", "}", "METHOD_END"], "methodName": ["setRefreshHomeOnConnectFailure"], "fileName": "org.springframework.ejb.access.AbstractRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   home    =    getHome (  )  ;", "Method   createMethodToUse    =    this . createMethod ;", "if    ( createMethodToUse    =  =    null )     {", "createMethodToUse    =    getCreateMethod ( home )  ;", "}", "if    ( createMethodToUse    =  =    null )     {", "return   home ;", "}", "return   createMethodToUse . invoke ( home ,     (  ( Object [  ]  )     ( null )  )  )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   EjbAccessException (  \" Could   not      EJB   home   create (  )    method \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.ejb.access.AbstractSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   home . getClass (  )  . getMethod (  \" create \"  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   EjbAException (  (  (  \" EJB   home    [  \"     +    home )     +     \"  ]    has   no   no - arg   create (  )    method \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCreateMethod"], "fileName": "org.springframework.ejb.access.AbstractSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( this . cacheHome )  )     |  |     (  ( this . lookupHomeOnStartup )     &  &     (  !  ( isHomeRefreshable (  )  )  )  )  )     {", "return    ( this . cachedHome )     !  =    null    ?    this . cachedHome    :    lookup (  )  ;", "} else    {", "synchronized ( this . homeMoni )     {", "if    (  ( this . cachedHome )     =  =    null )     {", "this . cachedHome    =    lookup (  )  ;", "this . createMethod    =    getCreateMethod ( this . cachedHome )  ;", "}", "return   this . cachedHome ;", "}", "}", "}", "METHOD_END"], "methodName": ["getHome"], "fileName": "org.springframework.ejb.access.AbstractSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isHomeRefreshable"], "fileName": "org.springframework.ejb.access.AbstractSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . homeMonitor )     {", "Object   home    =    lookup (  )  ;", "if    ( this . cacheHome )     {", "this . cachedHome    =    home ;", "this . createMethod    =    getCreateMethod ( home )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["refreshHome"], "fileName": "org.springframework.ejb.access.AbstractSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . cacheHome    =    cacheHome ;", "}", "METHOD_END"], "methodName": ["setCacheHome"], "fileName": "org.springframework.ejb.access.AbstractSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . exposeAccessContext    =    exposeAccessContext ;", "}", "METHOD_END"], "methodName": ["setExposeAccessContext"], "fileName": "org.springframework.ejb.access.AbstractSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . lookupHomeOnStartup    =    lookupHomeOnStartup ;", "}", "METHOD_END"], "methodName": ["setLookupHomeOnStartup"], "fileName": "org.springframework.ejb.access.AbstractSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   newSessionBeanInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getSessionBeanInstance"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" Trying   to   create   reference   to   l   EJB \"  )  ;", "}", "Object   ejbInstance    =    create (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Obtained   reference   to   l   EJB :     \"     +    ejbInstance )  )  ;", "}", "return   ejbInstance ;", "}", "METHOD_END"], "methodName": ["newSessionBeanInstance"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "removeSessionBeanInstance ( ejb )  ;", "}", "METHOD_END"], "methodName": ["releaseSessionBeanInstance"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ejb    !  =    null )     &  &     (  !  ( this . homeAsComponent )  )  )     {", "try    {", "ejb . remove (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . warn (  \" Could   not   i    ' remove '    on   local   EJB   proxy \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeSessionBeanInstance"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "LocalSlsbInvokerInterceptor   si    =    new   LocalSlsbInvokerInterceptor (  )  ;", "si . setJndiTemplate ( new   JndiTemplate (  )     {", "@ Override", "protected   Context   createInitialContext (  )    throws   NamingException    {", "return   mockCtx ;", "}", "}  )  ;", "si . setJndiName ( jndiName )  ;", "si . setResourceRef ( true )  ;", "si . afterPropertiesSet (  )  ;", "return   si ;", "}", "METHOD_END"], "methodName": ["configuredInterceptor"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "LocalSlsbInvokerInterceptorTests . SlsbHome   mockHome    =    mock ( LocalSlsbInvokerInterceptorTests . SlsbHome . class )  ;", "given ( mockHome . create (  )  )  . willReturn (  (  ( LocalSlsbInvokerInterceptorTests . LocalInterface )     ( ejbInstance )  )  )  ;", "Context   mockCtx    =    mock ( Context . class )  ;", "given ( mockCtx . lookup (  (  \" java : comp / env /  \"     +    jndiName )  )  )  . willReturn ( mockHome )  ;", "return   mockCtx ;", "}", "METHOD_END"], "methodName": ["mockContext"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "testException ( new   LocalSlsbInvokerInterceptorTests . ApplicationException (  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplicationException"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "LocalSlsbInvokerInterceptorTests . LocalInterfaceWithBusinessMethods   ejb    =    mock ( LocalSlsbInvokerInterceptorTests . LocalInterfaceWithBusinessMethods . class )  ;", "given ( ejb . targetMethod (  )  )  . willThrow ( expected )  ;", "String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "LocalSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( new   Class <  ?  >  [  ]  {    LocalSlsbInvokerInterceptorTests . LocalInterfaceWithBusinessMethods . class    }  )  ;", "pf . addAdvice ( si )  ;", "LocalSlsbInvokerInterceptorTests . LocalInterfaceWithBusinessMethods   target    =     (  ( LocalSlsbInvokerInterceptorTests . LocalInterfaceWithBusinessMethods )     ( pf . getProxy (  )  )  )  ;", "try    {", "target . targetMethod (  )  ;", "fail (  \" Should   have   thrown   exception \"  )  ;", "}    catch    ( Exception   thrown )     {", "assertTrue (  ( thrown    =  =    expected )  )  ;", "}", "verify ( mockContext )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testException"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Object   retVal    =    new   Object (  )  ;", ". LocalInterfaceWithBusinessMethods   ejb    =    mock (  . LocalInterfaceWithBusinessMethods . class )  ;", "given ( ejb . targetMethod (  )  )  . willReturn ( retVal )  ;", "String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "LocalSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( new   Class <  ?  >  [  ]  {     . BusinessMethods . class    }  )  ;", "pf . addAdvice ( si )  ;", ". BusinessMethods   target    =     (  (  . BusinessMethods )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  (  ( target . targetMethod (  )  )     =  =    retVal )  )  ;", "verify ( mockContext )  . close (  )  ;", "verify ( ejb )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstance"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Object   retVal    =    new   Object (  )  ;", ". LocalInterface   ejb    =    mock (  . LocalInterface . class )  ;", "given ( ejb . targetMethod (  )  )  . willReturn ( retVal )  ;", "String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "LocalSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( new   Class <  ?  >  [  ]  {     . BusinessMethods . class    }  )  ;", "pf . addAdvice ( si )  ;", ". BusinessMethods   target    =     (  (  . BusinessMethods )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  (  ( target . targetMethod (  )  )     =  =    retVal )  )  ;", "verify ( mockContext )  . close (  )  ;", "verify ( ejb )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithSeparateBusinessMethods"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   NamingException   nex    =    new   NamingException (  )  ;", "final   String   jndiName    =     \" foobar \"  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )    throws   NamingException    {", "assertTrue ( jndiName . equals ( name )  )  ;", "throw   nex ;", "}", "}  ;", "si    =    new    (  )  ;", "si . setJndiName (  \" foobar \"  )  ;", "si . setJndiTemplate ( jt )  ;", "try    {", "si . afterPropertiesSet (  )  ;", "fail (  \" Should   have   failed   with   naming   exception \"  )  ;", "}    catch    ( NamingException   ex )     {", "assertTrue (  ( ex    =  =    nex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testLookupFailure"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "LocalSlsbInvokerInterceptorTests . LocalInterfaceWithBusinessMethods   ejb    =    mock ( LocalSlsbInvokerInterceptorTests . LocalInterfaceWithBusinessMethods . class )  ;", "String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "configuredInterceptor ( mockContext ,    jndiName )  ;", "verify ( mockContext )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPerformsLookup"], "fileName": "org.springframework.ejb.access.LocalSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . businessInterface ;", "}", "METHOD_END"], "methodName": ["getBusinessInterface"], "fileName": "org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . businessInterface    =    businessInterface ;", "}", "METHOD_END"], "methodName": ["setBusinessInterface"], "fileName": "org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "final   String   jndiName    =     \" foo \"  ;", "final   CreateException   cex    =    new   CreateException (  )  ;", "final    . MyHome   home    =    mock (  . MyHome . class )  ;", "given ( home . create (  )  )  . willThrow ( cex )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )    throws   NamingException    {", "assertTrue ( name . equals ( jndiName )  )  ;", "return   home ;", "}", "}  ;", "LocalStatelessSessionProxyFactoryBean   fb    =    new   LocalStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setResourceRef ( false )  ;", "fb . setBusinessInterface (  . MyBusinessMethods . class )  ;", "assertEquals ( fb . getBusinessInterface (  )  ,     . MyBusinessMethods . class )  ;", "fb . setJndiTemplate ( jt )  ;", "fb . afterPropertiesSet (  )  ;", ". MyBusinessMethods   mbm    =     (  (  . MyBusinessMethods )     ( fb . getObject (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( mbm . getClass (  )  )  )  ;", "try    {", "mbm . getValue (  )  ;", "fail (  \" Should   have   failed   to   create   EJB \"  )  ;", "}    catch    ( EjbAccessException   ex )     {", "assertSame ( cex ,    ex . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCreateException"], "fileName": "org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   int   value    =     1  1  ;", "final   String   jndiName    =     \" foo \"  ;", ". MyEjb   myEjb    =    mock (  . MyEjb . class )  ;", "given ( myEjb . getValue (  )  )  . willReturn ( value )  ;", "final    . MyHome   home    =    mock (  . MyHome . class )  ;", "given ( home . create (  )  )  . willReturn ( myEjb )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )    throws   NamingException    {", "assertTrue ( name . equals (  (  \" java : comp / env /  \"     +    jndiName )  )  )  ;", "return   home ;", "}", "}  ;", "LocalStatelessSessionProxyFactoryBean   fb    =    new   LocalStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setResourceRef ( true )  ;", "fb . setBusinessInterface (  . MyBusinessMethods . class )  ;", "fb . setJndiTemplate ( jt )  ;", "fb . afterPropertiesSet (  )  ;", ". MyBusinessMethods   mbm    =     (  (  . MyBusinessMethods )     ( fb . getObject (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( mbm . getClass (  )  )  )  ;", "assertTrue (  (  ( mbm . getValue (  )  )     =  =    value )  )  ;", "verify ( myEjb )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethod"], "fileName": "org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   int   value    =     1  1  ;", "final   String   jndiName    =     \" foo \"  ;", "final    . MyEjb   myEjb    =    mock (  . MyEjb . class )  ;", "given ( myEjb . getValue (  )  )  . willReturn ( value )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )    throws   NamingException    {", "assertTrue ( name . equals (  (  \" java : comp / env /  \"     +    jndiName )  )  )  ;", "return   myEjb ;", "}", "}  ;", "LocalStatelessSessionProxyFactoryBean   fb    =    new   LocalStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setResourceRef ( true )  ;", "fb . setBusinessInterface (  . MyBusinessMethods . class )  ;", "fb . setJndiTemplate ( jt )  ;", "fb . afterPropertiesSet (  )  ;", ". MyBusinessMethods   mbm    =     (  (  . MyBusinessMethods )     ( fb . getObject (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( mbm . getClass (  )  )  )  ;", "assertTrue (  (  ( mbm . getValue (  )  )     =  =    value )  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjb3StyleBean"], "fileName": "org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   String   jndiName    =     \" foo \"  ;", "final    . MyHome   home    =    mock (  . MyHome . class )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )    throws   NamingException    {", "assertTrue ( name . equals (  (  \" java : comp / env /  \"     +    jndiName )  )  )  ;", "return   home ;", "}", "}  ;", "LocalStatelessSessionProxyFactoryBean   fb    =    new   LocalStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setResourceRef ( true )  ;", "fb . setJndiTemplate ( jt )  ;", "assertTrue ( fb . isSingleton (  )  )  ;", "try    {", "fb . afterPropertiesSet (  )  ;", "fail (  \" Should   have   failed   to   create   EJB \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" businessInterface \"  )  )     !  =     1  )  )  ;", "}", "verifyZeroInteractions ( home )  ;", "}", "METHOD_END"], "methodName": ["testNoBusinessInterfaceSpecified"], "fileName": "org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "if    ( this . cacheSessionBean )     {", "synchronized ( this . beanInstanceMonitor )     {", "if    (  ( this . beanInstance )     =  =    null )     {", "this . beanInstance    =    newSessionBeanInstance (  )  ;", "}", "return   this . beanInstance ;", "}", "} else    {", "return   newSessionBeanInstance (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSessionBeanInstance"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . cacheSessionBean )  )     {", "removeSessionBeanInstance ( ejb )  ;", "}", "}", "METHOD_END"], "methodName": ["releaseSessionBeanInstance"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . cacheSessionBean    =    cacheSessionBean ;", "}", "METHOD_END"], "methodName": ["setCacheSessionBean"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptor"}, {"methodBody": ["METHOD_START", "{", "SimpleRemoteSlsbInvokerInterceptor   si    =    createInterceptor (  )  ;", "si . setJndiTemplate ( new   JndiTemplate (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   mockCtx ;", "}", "}  )  ;", "si . setResourceRef ( true )  ;", "si . setJndiName ( jndiName )  ;", "return   si ;", "}", "METHOD_END"], "methodName": ["configuredInterceptor"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "si . afterPropertiesSet (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( new   Class <  ?  >  [  ]  {    ifc    }  )  ;", "pf . addAdvice ( si )  ;", "return   pf . getProxy (  )  ;", "}", "METHOD_END"], "methodName": ["configuredProxy"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleRemoteSlsbInvokerInterceptor (  )  ;", "}", "METHOD_END"], "methodName": ["createInterceptor"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   ejb    =    mock ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  ;", "given ( ejb . targetMethod (  )  )  . willThrow ( expected )  ;", "final   String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "SimpleRemoteSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   target    =     (  ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface )     ( configuredProxy ( si ,    SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  )  )  ;", "try    {", "target . targetMethod (  )  ;", "fail (  \" Should   have   thrown   remote   exception \"  )  ;", "}    catch    ( Exception   thrown )     {", "assertTrue (  ( thrown    =  =    expected )  )  ;", "}", "verify ( mockContext )  . close (  )  ;", "verify ( ejb )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["doTestException"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Object   retVal    =    new   Object (  )  ;", "final    . RemoteInterface   ejb    =    mock (  . RemoteInterface . class )  ;", "given ( ejb . targetMethod (  )  )  . willReturn ( retVal )  ;", "int   lookupCount    =     1  ;", "if    (  ! cacheHome )     {", "lookupCount +  +  ;", "if    ( lookupHomeOnStartup )     {", "lookupCount +  +  ;", "}", "}", "final   String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "SimpleRemoteSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "si . setLookupHomeOnStartup ( lookupHomeOnStartup )  ;", "si . setCacheHome ( cacheHome )  ;", ". RemoteInterface   target    =     (  (  . RemoteInterface )     ( configuredProxy ( si ,     . RemoteInterface . class )  )  )  ;", "assertTrue (  (  ( target . targetMethod (  )  )     =  =    retVal )  )  ;", "assertTrue (  (  ( target . targetMethod (  )  )     =  =    retVal )  )  ;", "verify ( mockContext ,    times ( lookupCount )  )  . close (  )  ;", "verify ( ejb ,    times (  2  )  )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["doTestInvokesMethodOnEjbInstance"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   ejb    =    mock ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  ;", "given ( ejb . targetMethod (  )  )  . willThrow ( new   ConnectException (  \"  \"  )  )  ;", "int   lookupCount    =     2  ;", "if    (  ! cacheHome )     {", "lookupCount +  +  ;", "if    ( lookupHomeOnStartup )     {", "lookupCount +  +  ;", "}", "}", "final   String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "SimpleRemoteSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "si . setRefreshHomeOnConnectFailure ( true )  ;", "si . setLookupHomeOnStartup ( lookupHomeOnStartup )  ;", "si . setCacheHome ( cacheHome )  ;", "SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   target    =     (  ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface )     ( configuredProxy ( si ,    SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  )  )  ;", "try    {", "target . targetMethod (  )  ;", "fail (  \" Should   have   thrown   RemoteException \"  )  ;", "}    catch    ( ConnectException   ex )     {", "}", "verify ( mockContext ,    times ( lookupCount )  )  . close (  )  ;", "verify ( ejb ,    times (  2  )  )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["doTestInvokesMethodOnEjbInstanceWithConnectExceptionWithRefresh"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "SimpleRemoteSlsbInvokerInterceptorTests . SlsbHome   mockHome    =    mock ( SimpleRemoteSlsbInvokerInterceptorTests . SlsbHome . class )  ;", "given ( mockHome . create (  )  )  . willReturn ( ejbInstance )  ;", "Context   mockCtx    =    mock ( Context . class )  ;", "given ( mockCtx . lookup (  (  \" java : comp / env /  \"     +    jndiName )  )  )  . willReturn ( mockHome )  ;", "return   mockCtx ;", "}", "METHOD_END"], "methodName": ["mockContext"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestException ( new   SimpleRemoteSlsbInvokerInterceptorTests . ApplicationException (  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplicationException"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestInvokesMethodOnEjbInstance ( true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstance"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Object   retVal    =    new   Object (  )  ;", "final    . RemoteInterface   ejb    =    mock (  . RemoteInterface . class )  ;", "given ( ejb . targetMethod (  )  )  . willReturn ( retVal )  ;", "final   String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "SimpleRemoteSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", ". BusinessInterface   target    =     (  (  . BusinessInterface )     ( configuredProxy ( si ,     . BusinessInterface . class )  )  )  ;", "assertTrue (  (  ( target . targetMethod (  )  )     =  =    retVal )  )  ;", "verify ( mockContext )  . close (  )  ;", "verify ( ejb )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithBusinessInterface"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   ejb    =    mock ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  ;", "given ( ejb . targetMethod (  )  )  . willThrow ( new   RemoteException (  )  )  ;", "final   String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "SimpleRemoteSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "SimpleRemoteSlsbInvokerInterceptorTests . BusinessInterface   target    =     (  ( SimpleRemoteSlsbInvokerInterceptorTests . BusinessInterface )     ( configuredProxy ( si ,    SimpleRemoteSlsbInvokerInterceptorTests . BusinessInterface . class )  )  )  ;", "try    {", "target . targetMethod (  )  ;", "fail (  \" Should   have   thrown   RemoteAccessException \"  )  ;", "}    catch    ( RemoteAccessException   ex )     {", "}", "verify ( mockContext )  . close (  )  ;", "verify ( ejb )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithBusinessInterfaceWithRemoteException"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestInvokesMethodOnEjbInstanceWithConnectExceptionWithRefresh ( true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithConnectExceptionWithRefresh"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestInvokesMethodOnEjbInstanceWithConnectExceptionWithRefresh ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithConnectExceptionWithRefreshAndLazyLookup"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestInvokesMethodOnEjbInstanceWithConnectExceptionWithRefresh ( false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithConnectExceptionWithRefreshAndLazyLookupAndNoCache"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestInvokesMethodOnEjbInstanceWithConnectExceptionWithRefresh ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithConnectExceptionWithRefreshAndNoCache"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestInvokesMethodOnEjbInstance ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithLazyLookup"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestInvokesMethodOnEjbInstance ( false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithLazyLookupAndNoCache"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestInvokesMethodOnEjbInstance ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithNoCache"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   ejb    =    mock ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  ;", "given ( ejb . targetMethod (  )  )  . willThrow ( new   RemoteException (  )  )  ;", "ejb . remove (  )  ;", "final   String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "SimpleRemoteSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   target    =     (  ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface )     ( configuredProxy ( si ,    SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  )  )  ;", "try    {", "target . targetMethod (  )  ;", "fail (  \" Should   have   thrown   RemoteException \"  )  ;", "}    catch    ( RemoteException   ex )     {", "}", "verify ( mockContext )  . close (  )  ;", "verify ( ejb ,    times (  2  )  )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjbInstanceWithRemoteException"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   NamingException   nex    =    new   NamingException (  )  ;", "final   String   jndiName    =     \" foobar \"  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )    throws   NamingException    {", "assertTrue ( jndiName . equals ( name )  )  ;", "throw   nex ;", "}", "}  ;", "si    =    new    (  )  ;", "si . setJndiName (  \" foobar \"  )  ;", "si . setJndiTemplate ( jt )  ;", "try    {", "si . afterPropertiesSet (  )  ;", "fail (  \" Should   have   failed   with   naming   exception \"  )  ;", "}    catch    ( NamingException   ex )     {", "assertTrue (  ( ex    =  =    nex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testLookupFailure"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   ejb    =    mock ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  ;", "String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "SimpleRemoteSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "configuredProxy ( si ,    SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  ;", "verify ( mockContext )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPerformsLookup"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   ejb    =    mock ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  ;", "String   jndiName    =     \" foobar \"  ;", "Context   mockContext    =    mockContext ( jndiName ,    ejb )  ;", "SimpleRemoteSlsbInvokerInterceptor   si    =    configuredInterceptor ( mockContext ,    jndiName )  ;", "si . setExposeAccessContext ( true )  ;", "SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface   target    =     (  ( SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface )     ( configuredProxy ( si ,    SimpleRemoteSlsbInvokerInterceptorTests . RemoteInterface . class )  )  )  ;", "assertNull ( target . targetMethod (  )  )  ;", "verify ( mockContext ,    times (  2  )  )  . close (  )  ;", "verify ( ejb )  . targetMethod (  )  ;", "}", "METHOD_END"], "methodName": ["testPerformsLookupWithAccessContext"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "doTestException ( new   RemoteException (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRemoteException"], "fileName": "org.springframework.ejb.access.SimpleRemoteSlsbInvokerInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . businessInterface ;", "}", "METHOD_END"], "methodName": ["getBusinessInterface"], "fileName": "org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . businessInterface    =    businessInterface ;", "}", "METHOD_END"], "methodName": ["setBusinessInterface"], "fileName": "org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "final   String   jndiName    =     \" foo \"  ;", "final   CreateException   cex    =    new   CreateException (  )  ;", "final    . MyHome   home    =    mock (  . MyHome . class )  ;", "given ( home . create (  )  )  . willThrow ( cex )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )     {", "assertTrue ( name . equals ( jndiName )  )  ;", "return   home ;", "}", "}  ;", "SimpleRemoteStatelessSessionProxyFactoryBean   fb    =    new   SimpleRemoteStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setBusinessInterface (  . MyBusinessMethods . class )  ;", "assertEquals ( fb . getBusinessInterface (  )  ,     . MyBusinessMethods . class )  ;", "fb . setJndiTemplate ( jt )  ;", "fb . afterPropertiesSet (  )  ;", ". MyBusinessMethods   mbm    =     (  (  . MyBusinessMethods )     ( fb . getObject (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( mbm . getClass (  )  )  )  ;", "try    {", "mbm . getValue (  )  ;", "fail (  \" Should   have   failed   to   create   EJB \"  )  ;", "}    catch    ( RemoteException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testCreateException"], "fileName": "org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   String   jndiName    =     \" foo \"  ;", "final   CreateException   cex    =    new   CreateException (  )  ;", "final    . MyHome   home    =    mock (  . MyHome . class )  ;", "given ( home . create (  )  )  . willThrow ( cex )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )     {", "assertTrue ( name . equals ( jndiName )  )  ;", "return   home ;", "}", "}  ;", "SimpleRemoteStatelessSessionProxyFactoryBean   fb    =    new   SimpleRemoteStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setBusinessInterface (  . MyLocalBusinessMethods . class )  ;", "assertEquals ( fb . getBusinessInterface (  )  ,     . MyLocalBusinessMethods . class )  ;", "fb . setJndiTemplate ( jt )  ;", "fb . afterPropertiesSet (  )  ;", ". MyLocalBusinessMethods   mbm    =     (  (  . MyLocalBusinessMethods )     ( fb . getObject (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( mbm . getClass (  )  )  )  ;", "try    {", "mbm . getValue (  )  ;", "fail (  \" Should   have   failed   to   create   EJB \"  )  ;", "}    catch    ( RemoteAccessException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )     =  =    cex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCreateExceptionWithLocalBusinessInterface"], "fileName": "org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   int   value    =     1  1  ;", "final   String   jndiName    =     \" foo \"  ;", ". MyEjb   myEjb    =    mock (  . MyEjb . class )  ;", "given ( myEjb . getValue (  )  )  . willReturn ( value )  ;", "final    . MyHome   home    =    mock (  . MyHome . class )  ;", "given ( home . create (  )  )  . willReturn ( myEjb )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )     {", "assertTrue ( name . equals (  (  \" java : comp / env /  \"     +    jndiName )  )  )  ;", "return   home ;", "}", "}  ;", "SimpleRemoteStatelessSessionProxyFactoryBean   fb    =    new   SimpleRemoteStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setResourceRef ( true )  ;", "fb . setBusinessInterface (  . MyBusinessMethods . class )  ;", "fb . setJndiTemplate ( jt )  ;", "fb . afterPropertiesSet (  )  ;", ". MyBusinessMethods   mbm    =     (  (  . MyBusinessMethods )     ( fb . getObject (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( mbm . getClass (  )  )  )  ;", "assertEquals (  \" Returns   expected   value \"  ,    value ,    mbm . getValue (  )  )  ;", "verify ( myEjb )  . remove (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethod"], "fileName": "org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   int   value    =     1  1  ;", "final   String   jndiName    =     \" foo \"  ;", "final    . MyEjb   myEjb    =    mock (  . MyEjb . class )  ;", "given ( myEjb . getValue (  )  )  . willReturn ( value )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )     {", "assertTrue ( name . equals (  (  \" java : comp / env /  \"     +    jndiName )  )  )  ;", "return   myEjb ;", "}", "}  ;", "SimpleRemoteStatelessSessionProxyFactoryBean   fb    =    new   SimpleRemoteStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setResourceRef ( true )  ;", "fb . setBusinessInterface (  . MyBusinessMethods . class )  ;", "fb . setJndiTemplate ( jt )  ;", "fb . afterPropertiesSet (  )  ;", ". MyBusinessMethods   mbm    =     (  (  . MyBusinessMethods )     ( fb . getObject (  )  )  )  ;", "assertTrue ( Proxy . isProxyClass ( mbm . getClass (  )  )  )  ;", "assertEquals (  \" Returns   expected   value \"  ,    value ,    mbm . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInvokesMethodOnEjb3StyleBean"], "fileName": "org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   String   jndiName    =     \" foo \"  ;", "final    . MyHome   home    =    mock (  . MyHome . class )  ;", "JndiTemplate   jt    =    new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )    throws   NamingException    {", "assertTrue ( name . equals ( jndiName )  )  ;", "return   home ;", "}", "}  ;", "SimpleRemoteStatelessSessionProxyFactoryBean   fb    =    new   SimpleRemoteStatelessSessionProxyFactoryBean (  )  ;", "fb . setJndiName ( jndiName )  ;", "fb . setJndiTemplate ( jt )  ;", "assertTrue ( fb . isSingleton (  )  )  ;", "try    {", "fb . afterPropertiesSet (  )  ;", "fail (  \" Should   have   failed   to   create   EJB \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" businessInterface \"  )  )     !  =     1  )  )  ;", "}", "verifyZeroInteractions ( home )  ;", "}", "METHOD_END"], "methodName": ["testNoBusinessInterfaceSpecified"], "fileName": "org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "this . reader . setEventListener ( this . eventListener )  ;", "this . reader . loadBeanDefinitions ( new   ClassPathResource (  \" jeeNamespaceHandlerTests . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "ComponentDefinition   component    =    this . eventListener . getComponentDefinition (  \" simple \"  )  ;", "assertTrue (  ( component   instanceof   BeanComponentDefinition )  )  ;", "}", "METHOD_END"], "methodName": ["testJndiLookupComponentEventReceived"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "ComponentDefinition   component    =    this . eventListener . getComponentDefinition (  \" simpleLocalEjb \"  )  ;", "assertTrue (  ( component   instanceof   BeanComponentDefinition )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalSlsbComponentEventReceived"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "ComponentDefinition   component    =    this . eventListener . getComponentDefinition (  \" simpleRemoteEjb \"  )  ;", "assertTrue (  ( component   instanceof   BeanComponentDefinition )  )  ;", "}", "METHOD_END"], "methodName": ["testRemoteSlsbComponentEventReceived"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  (  \" Property    '  \"     +    propertyName )     +     \"  '    incorrect \"  )  ,    expectedValue ,    beanDefinition . getPropertyValues (  )  . getPropertyValue ( propertyName )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertPropertyValue"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "new   XmlBeanDefinitionReader ( ctx )  . loadBeanDefinitions ( new   ClassPathResource (  \" j . xml \"  ,    getClass (  )  )  )  ;", "ctx . refresh (  )  ;", "this . beanFactory    =    ctx . getBeanFactory (  )  ;", "this . beanFactory . getBeanNamesForType ( ITestBean . class )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" complex \"  )  ;", "assertEquals ( JndiObjectFactoryBean . class . get (  )  ,    beanDefinition . getBeanClass (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndi \"  ,     \" jdbc / MyDataSource \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" resourceRef \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" cache \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" lookupOnStartup \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" exposeAccessContext \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" expectedType \"  ,     \" com . myapp . DefaultFoo \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" proxyInterface \"  ,     \" com . myapp . Foo \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" defaultObject \"  ,     \" myValue \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexDefinition"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" complexLocalEjb \"  )  ;", "assertEquals ( LocalStatelessSessionProxyFactoryBean . class . get (  )  ,    beanDefinition . getBeanClass (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" businessInterface \"  ,    ITestBean . class . get (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndi \"  ,     \" ejb / MyLocalBean \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" cacheHome \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" lookupHomeOnStartup \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" resourceRef \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndiEnvironment \"  ,     \" foo = bar \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexLocalSlsb"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" complexRemoteEjb \"  )  ;", "assertEquals ( SimpleRemoteStatelessSessionProxyFactoryBean . class . getName (  )  ,    beanDefinition . getBeanClassName (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" businessInterface \"  ,    ITestBean . class . getName (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndiName \"  ,     \" ejb / MyRemoteBean \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" cacheHome \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" lookupHomeOnStartup \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" resourceRef \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndiEnvironment \"  ,     \" foo = bar \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" homeInterface \"  ,     \" tests . sample . beans . ITestBean \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" refreshHomeOnConnectFailure \"  ,     \" true \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" cacheSessionBean \"  ,     \" true \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplexRemoteSlsb"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   definition    =    this . beanFactory . getMergedBeanDefinition (  \" lazyDataSource \"  )  ;", "assertTrue ( definition . isLazyInit (  )  )  ;", "definition    =    this . beanFactory . getMergedBeanDefinition (  \" lazyLocalBean \"  )  ;", "assertTrue ( definition . isLazyInit (  )  )  ;", "definition    =    this . beanFactory . getMergedBeanDefinition (  \" lazyRemoteBean \"  )  ;", "assertTrue ( definition . isLazyInit (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLazyInitJndiLookup"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" simple \"  )  ;", "assertEquals ( JndiObjectFactoryBean . class . get (  )  ,    beanDefinition . getBeanClass (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndi \"  ,     \" jdbc / MyDataSource \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" resourceRef \"  ,     \" true \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleDefinition"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" simpleLocalEjb \"  )  ;", "assertEquals ( LocalStatelessSessionProxyFactoryBean . class . get (  )  ,    beanDefinition . getBeanClass (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" businessInterface \"  ,    ITestBean . class . get (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndi \"  ,     \" ejb / MyLocalBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleLocalSlsb"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" simpleRemoteEjb \"  )  ;", "assertEquals ( SimpleRemoteStatelessSessionProxyFactoryBean . class . get (  )  ,    beanDefinition . getBeanClass (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" businessInterface \"  ,    ITestBean . class . get (  )  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndi \"  ,     \" ejb / MyRemoteBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleRemoteSlsb"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" withEnvironment \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndiEnvironment \"  ,     \" foo = bar \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" defaultObject \"  ,    new   RuntimeBeanReference (  \" myBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithEnvironment"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" withReferencedEnvironment \"  )  ;", "assertPropertyValue ( beanDefinition ,     \" jndiEnvironment \"  ,    new   RuntimeBeanReference (  \" myEnvironment \"  )  )  ;", "assertFalse ( beanDefinition . getPropertyValues (  ) tains (  \" environmentRef \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithReferencedEnvironment"], "fileName": "org.springframework.ejb.config.JeeNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasLength ( this . pattern )  )     {", "return   new   SimpleDateFormat ( this . pattern ,    locale )  ;", "}", "if    (  (  ( this . iso )     !  =    null )     &  &     (  ( this . iso )     !  =     ( DateTimeFormat . ISO . NONE )  )  )     {", "String   pattern    =     . ISO _ PATTERNS . get ( this . iso )  ;", "if    ( pattern    =  =    null )     {", "throw   new   IllegalStateException (  (  \" Unsupported   ISO   format    \"     +     ( this . iso )  )  )  ;", "}", "SimpleDateFormat   format    =    new   SimpleDateFormat ( pattern )  ;", "format . setTimeZone (  . UTC )  ;", "return   format ;", "}", "if    ( StringUtils . hasLength ( this . stylePattern )  )     {", "int   dateStyle    =    getStylePatternForChar (  0  )  ;", "int   timeStyle    =    getStylePatternForChar (  1  )  ;", "if    (  ( dateStyle    !  =     (  -  1  )  )     &  &     ( timeStyle    !  =     (  -  1  )  )  )     {", "return   DateFormat . getDateTimeInstance ( dateStyle ,    timeStyle ,    locale )  ;", "}", "if    ( dateStyle    !  =     (  -  1  )  )     {", "return   DateFormat . getDateInstance ( dateStyle ,    locale )  ;", "}", "if    ( timeStyle    !  =     (  -  1  )  )     {", "return   DateFormat . getTimeInstance ( timeStyle ,    locale )  ;", "}", "throw   new   IllegalStateException (  (  (  \" Unsupported   style   pattern    '  \"     +     ( this . stylePattern )  )     +     \"  '  \"  )  )  ;", "}", "return   DateFormat . getDateInstance ( this . style ,    locale )  ;", "}", "METHOD_END"], "methodName": ["createDateFormat"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "DateFormat   dateFormat    =    createDateFormat ( locale )  ;", "if    (  ( this . timeZone )     !  =    null )     {", "dateFormat . setTimeZone ( this . timeZone )  ;", "}", "dateFormat . setLenient ( this . lenient )  ;", "return   dateFormat ;", "}", "METHOD_END"], "methodName": ["getDateFormat"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . stylePattern )     !  =    null )     &  &     (  ( this . stylePattern . length (  )  )     >    index )  )     {", "switch    ( this . stylePattern . charAt ( index )  )     {", "case    ' S '     :", "return    . SHORT ;", "case    ' M '     :", "return    . MEDIUM ;", "case    ' L '     :", "return    . LONG ;", "case    ' F '     :", "return    . FULL ;", "case    '  -  '     :", "return    -  1  ;", "}", "}", "throw   new   IllegalStateException (  (  (  \" Unsupported   style   pattern    '  \"     +     ( this . stylePattern )  )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getStylePatternForChar"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "this . iso    =    iso ;", "}", "METHOD_END"], "methodName": ["setIso"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "this . lenient    =    lenient ;", "}", "METHOD_END"], "methodName": ["setLenient"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "this . pattern    =    pattern ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "this . style    =    style ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "this . stylePattern    =    stylePattern ;", "}", "METHOD_END"], "methodName": ["setStylePattern"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "this . timeZone    =    timeZone ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.format.datetime.DateFormatter"}, {"methodBody": ["METHOD_START", "{", "converterRegistry . addConverter ( new   DateFormatterRegistrar . DateToLongConverter (  )  )  ;", "converterRegistry . addConverter ( new   DateFormatterRegistrar . DateToCalendarConverter (  )  )  ;", "converterRegistry . addConverter ( new   DateFormatterRegistrar . CalendarToDateConverter (  )  )  ;", "converterRegistry . addConverter ( new   DateFormatterRegistrar . CalendarToLongConverter (  )  )  ;", "converterRegistry . addConverter ( new   DateFormatterRegistrar . LongToDateConverter (  )  )  ;", "converterRegistry . addConverter ( new   DateFormatterRegistrar . LongToCalendarConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["addDateConverters"], "fileName": "org.springframework.format.datetime.DateFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( dateFormatter ,     \" DateFormatter   must   not   be   null \"  )  ;", "this . dateFormatter    =    dateFormatter ;", "}", "METHOD_END"], "methodName": ["setFormatter"], "fileName": "org.springframework.format.datetime.DateFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "return   getDate ( year ,    month ,    dayOfMonth ,     0  ,     0  ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getDate"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   cal    =    Calendar . getInstance ( Locale . US )  ;", "cal . setTimeZone (  . UTC )  ;", "cal . clear (  )  ;", "cal . set ( Calendar . YEAR ,    year )  ;", "cal . set ( Calendar . MONTH ,    month )  ;", "cal . set ( Calendar . DAY _ OF _ MONTH ,    dayOfMonth )  ;", "cal . set ( Calendar . HOUR ,    hour )  ;", "cal . set ( Calendar . MINUTE ,    minute )  ;", "cal . set ( Calendar . SECOND ,    second )  ;", "cal . set ( Calendar . MILLISECOND ,    millisecond )  ;", "return   cal . getTime (  )  ;", "}", "METHOD_END"], "methodName": ["getDate"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \" Jun    1  ,     2  0  0  9  \"  )  )  ;", "assertThat ( formatter . parse (  \" Jun    1  ,     2  0  0  9  \"  ,    Locale . US )  ,    is ( date )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseDefault"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  \" yyyy - MM - dd \"  )  ;", "formatter . setTimeZone (  . UTC )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \"  2  0  0  9  -  0  6  -  0  1  \"  )  )  ;", "assertThat ( formatter . parse (  \"  2  0  0  9  -  0  6  -  0  1  \"  ,    Locale . US )  ,    is ( date )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseFromPattern"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setStyle ( DateFormat . FULL )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \" Monday ,    June    1  ,     2  0  0  9  \"  )  )  ;", "assertThat ( formatter . parse (  \" Monday ,    June    1  ,     2  0  0  9  \"  ,    Locale . US )  ,    is ( date )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseFull"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setIso ( DateTimeFormat . ISO . DATE )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  ,     1  4  ,     2  3  ,     5  ,     3  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \"  2  0  0  9  -  0  6  -  0  1  \"  )  )  ;", "assertThat ( formatter . parse (  \"  2  0  0  9  -  6  -  0  1  \"  ,    Locale . US )  ,    is ( getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseISODate"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setIso ( DateTimeFormat . ISO . DATE _ TIME )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  ,     1  4  ,     2  3  ,     5  ,     3  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \"  2  0  0  9  -  0  6  -  0  1 T 1  4  :  2  3  :  0  5  .  0  0  3 Z \"  )  )  ;", "assertThat ( formatter . parse (  \"  2  0  0  9  -  0  6  -  0  1 T 1  4  :  2  3  :  0  5  .  0  0  3 Z \"  ,    Locale . US )  ,    is ( date )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseISODateTime"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setIso ( DateTimeFormat . ISO . TIME )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JANUARY ,     1  ,     1  4  ,     2  3  ,     5  ,     3  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \"  1  4  :  2  3  :  0  5  .  0  0  3 Z \"  )  )  ;", "assertThat ( formatter . parse (  \"  1  4  :  2  3  :  0  5  .  0  0  3 Z \"  ,    Locale . US )  ,    is ( getDate (  1  9  7  0  ,    Calendar . JANUARY ,     1  ,     1  4  ,     2  3  ,     5  ,     3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseISOTime"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setStyle ( DateFormat . LONG )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \" June    1  ,     2  0  0  9  \"  )  )  ;", "assertThat ( formatter . parse (  \" June    1  ,     2  0  0  9  \"  ,    Locale . US )  ,    is ( date )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseLong"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setStyle ( DateFormat . MEDIUM )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \" Jun    1  ,     2  0  0  9  \"  )  )  ;", "assertThat ( formatter . parse (  \" Jun    1  ,     2  0  0  9  \"  ,    Locale . US )  ,    is ( date )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseMedium"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setStyle ( DateFormat . SHORT )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  )  ;", "assertThat ( formatter . print ( date ,    Locale . US )  ,    is (  \"  6  /  1  /  0  9  \"  )  )  ;", "assertThat ( formatter . parse (  \"  6  /  1  /  0  9  \"  ,    Locale . US )  ,    is ( date )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPrintAndParseShort"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    chars    =    new   String [  ]  {     \" S \"  ,     \" M \"  ,     \"  -  \"     }  ;", "for    ( String   d    :    chars )     {", "for    ( String   t    :    chars )     {", "String   style    =    d    +    t ;", "if    (  !  ( style . equals (  \"  -  -  \"  )  )  )     {", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  0  ,     1  4  ,     2  3  ,     0  ,     0  )  ;", "if    ( t . equals (  \"  -  \"  )  )     {", "date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  0  )  ;", "} else", "if    ( d . equals (  \"  -  \"  )  )     {", "date    =    getDate (  1  9  7  0  ,    Calendar . JANUARY ,     1  ,     1  4  ,     2  3  ,     0  ,     0  )  ;", "}", "testJodaStylePns ( style ,    Locale . US ,    date )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["shouldSupportJodaStylePatterns"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setStylePattern (  \" OO \"  )  ;", "thrown . expect ( IllegalStateException . class )  ;", "thrown . expectMessage (  \" Unsupported   style   pattern    ' OO '  \"  )  ;", "formatter . parse (  \"  2  0  0  9  \"  ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["shouldThrowOnUnsupportedStylePattern"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setStyle ( DateFormat . SHORT )  ;", "formatter . setStylePattern (  \" L -  \"  )  ;", "formatter . setIso ( DateTimeFormat . ISO . DATE _ TIME )  ;", "formatter . setPattern (  \" yyyy \"  )  ;", "Date   date    =    getDate (  2  0  0  9  ,    Calendar . JUNE ,     1  ,     1  4  ,     2  3  ,     5  ,     3  )  ;", "assertThat (  \" uses   pattern \"  ,    formatter . print ( date ,    Locale . US )  ,    is (  \"  2  0  0  9  \"  )  )  ;", "formatter . setPattern (  \"  \"  )  ;", "assertThat (  \" uses   ISO \"  ,    formatter . print ( date ,    Locale . US )  ,    is (  \"  2  0  0  9  -  0  6  -  0  1 T 1  4  :  2  3  :  0  5  .  0  0  3 Z \"  )  )  ;", "formatter . setIso ( DateTimeFormat . ISO . NONE )  ;", "assertThat (  \" uses   style   pattern \"  ,    formatter . print ( date ,    Locale . US )  ,    is (  \" June    1  ,     2  0  0  9  \"  )  )  ;", "formatter . setStylePattern (  \"  \"  )  ;", "assertThat (  \" uses   style \"  ,    formatter . print ( date ,    Locale . US )  ,    is (  \"  6  /  1  /  0  9  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldUseCorrectOrder"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "formatter . setTimeZone (  . UTC )  ;", "formatter . setStylePattern ( style )  ;", "DateTimeFormatter   jodaFormatter    =    DateTimeFormat . forStyle ( style )  . withLocale ( locale )  . withZone ( UTC )  ;", "String   jodaPrinted    =    jodaFormatter . print ( date . getTime (  )  )  ;", "assertThat (  (  \" Unable   to   print   style   pattern    \"     +    style )  ,    formatter . print ( date ,    locale )  ,    is ( equalTo ( jodaPrinted )  )  )  ;", "assertThat (  (  \" Unable   to   parse   style   pattern    \"     +    style )  ,    formatter . parse ( jodaPrinted ,    locale )  ,    is ( equalTo ( date )  )  )  ;", "}", "METHOD_END"], "methodName": ["testJodaStylePatterns"], "fileName": "org.springframework.format.datetime.DateFormatterTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatterRegistrar   registrar    =    new   DateFormatterRegistrar (  )  ;", "registrar . setFormatter ( new   DateFormatter (  )  )  ;", "setup ( registrar )  ;", "Date   date    =    new   Date (  )  ;", "Object   actual    =    this . conversionService . convert ( date ,    TypeDescriptor . valueOf ( Date . class )  ,    TypeDescriptor . valueOf ( String . class )  )  ;", "String   expected    =    new   DateFormatter (  )  . print ( date ,    Locale . US )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["dateToStringWithGlobalFormat"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    new   Date (  )  ;", "Object   actual    =    this . conversionService . convert ( date ,    TypeDescriptor . valueOf ( Date . class )  ,    TypeDescriptor . valueOf ( String . class )  )  ;", "String   expected    =    date . toString (  )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["dateToStringWithoutGlobalFormat"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatterRegistrar   registrar    =    new   DateFormatterRegistrar (  )  ;", "setup ( registrar )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "registrar . registerFormatters ( conversionService )  ;", ". SimpleDateBean   bean    =    new    . SimpleDateBean (  )  ;", "bean . getChildren (  )  . add ( new    . SimpleDateBean (  )  )  ;", "binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "LocaleContextHolder . setLocale ( Locale . US )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatterRegistrar   registrar    =    new   DateFormatterRegistrar (  )  ;", "DateFormatter   dateFormatter    =    new   DateFormatter (  )  ;", "dateFormatter . setIso ( DateTimeFormat . ISO . DATE _ TIME )  ;", "registrar . setFormatter ( dateFormatter )  ;", "setup ( registrar )  ;", "String   string    =     \"  2  0  0  9  -  0  6  -  0  1 T 1  4  :  2  3  :  0  5  .  0  0  3  +  0  0  :  0  0  \"  ;", "Date   date    =    this . conversionService . convert ( string ,    Date . class )  ;", "assertNotNull ( date )  ;", "}", "METHOD_END"], "methodName": ["stringToDateWithGlobalFormat"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "String   string    =     \" Sat ,     1  2    Aug    1  9  9  5     1  3  :  3  0  :  0  0    GM \"  ;", "Date   date    =    this . conversionService . convert ( string ,    Date . class )  ;", "assertThat ( date ,    equalTo ( new   Date ( string )  )  )  ;", "}", "METHOD_END"], "methodName": ["stringToDateWithoutGlobalFormat"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( null )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" calendarAnnotd \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" calendarAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindCalendarAnnotated"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" Annotated \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" Annotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateAnnotated"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" AnnotatedPattern \"  ,     \"  1  0  /  3  1  /  0  9     1  :  0  5  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9     1  :  0  5  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" AnnotatedPattern \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateAnnotatedPattern"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" Annotated \"  ,     \" Oct   X 3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getFieldErrorCount (  \" Annotated \"  )  )  ;", "assertEquals (  \" Oct   X 3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" Annotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateAnnotatedWithError"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" Annotated \"  ,     \" Oct    0  3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getFieldErrorCount (  \" Annotated \"  )  )  ;", "assertEquals (  \" Oct    0  3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" Annotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateAnnotatedWithFallbackError"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" dateAnnotated \"  ,    new   St [  ]  {     \"  1  0  /  3  1  /  0  9     1  2  :  0  0    PM \"     }  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateArray"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" AnnotatedPattern \"  ,     \"  0  2  /  2  9  /  0  9     1  2  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeOverflow"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" iso \"  ,     \"  2  0  0  9  -  1  0  -  3  1  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" iso \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISODate"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" isoTime \"  ,     \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  .  0  0  0  -  0  8  :  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1 T 2  0  :  0  0  :  0  0  .  0  0  0 Z \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" isoTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISODateTime"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" isoT \"  ,     \"  1  2  :  0  0  :  0  0  .  0  0  0  -  0  5  :  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  7  :  0  0  :  0  0  .  0  0  0 Z \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" isoT \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISOTime"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" millis \"  ,     \"  1  2  5  6  9  6  1  6  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  5  6  9  6  1  6  0  0  \"  ,    binder . getBindResult (  )  . getFieldValue (  \" millis \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLong"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" millisAnnotd \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" millisAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLongAnnotated"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" children [  0  ] Annotated \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" children [  0  ] Annotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindNestedDateAnnotated"], "fileName": "org.springframework.format.datetime.DateFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateFormatter   formatter    =    new   DateFormatter (  )  ;", "String   style    =    resolveEmbeddedValue ( annotation . style (  )  )  ;", "if    ( StringUtils . hasLength ( style )  )     {", "formatter . setStylePattern ( style )  ;", "}", "formatter . setIso ( annotation . iso (  )  )  ;", "String   pattern    =    resolveEmbeddedValue ( annotation . pattern (  )  )  ;", "if    ( StringUtils . hasLength ( pattern )  )     {", "formatter . setPattern ( pattern )  ;", "}", "return   formatter ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.DateTimeFormatAnnotationFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "return   createDateTimeFormatter ( DateTimeFormat . mediumDateTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatter"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   dateTimeFormatter    =    null ;", "if    ( StringUtils . hasLength ( this . pattern )  )     {", "dateTimeFormatter    =    DateTimeFormat . forPattern ( this . pattern )  ;", "} else", "if    (  (  ( this . iso )     !  =    null )     &  &     (  ( this . iso )     !  =     ( annotation . DateTimeFormat . ISO . NONE )  )  )     {", "switch    ( this . iso )     {", "case   DATE    :", "dateTimeFormatter    =    date (  )  ;", "break ;", "case   TIME    :", "dateTimeFormatter    =    time (  )  ;", "break ;", "case   DATE _ TIME    :", "dateTimeFormatter    =    dateTime (  )  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Unsupported   ISO   format :     \"     +     ( this . iso )  )  )  ;", "}", "} else", "if    ( StringUtils . hasLength ( this . style )  )     {", "dateTimeFormatter    =    DateTimeFormat . forStyle ( this . style )  ;", "}", "if    (  ( dateTimeFormatter    !  =    null )     &  &     (  ( this . timeZone )     !  =    null )  )     {", "dateTimeFormatter    =    dateTimeFormatter . withZone ( DateTimeZone . forTimeZone ( this . timeZone )  )  ;", "}", "return   dateTimeFormatter    !  =    null    ?    dateTimeFormatter    :    fallbackFormatter ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatter"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . iso    =    iso ;", "}", "METHOD_END"], "methodName": ["setIso"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . pattern    =    pattern ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . style    =    style ;", "}", "METHOD_END"], "methodName": ["setStyle"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . timeZone    =    timeZone ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "factory . afterPropertiesSet (  )  ;", "assertThat ( factory . getObject (  )  ,    is ( equalTo (  . mediumDateTime (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getObject"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factory . afterPropertiesSet (  )  ;", "formatter    =    factory . getObject (  )  ;", "assertThat ( formatter ,    is ( equalTo ( DateTimeFormat . mediumDateTime (  )  )  )  )  ;", "factory . setStyle (  \" LL \"  )  ;", "assertThat ( factory . getObject (  )  ,    is ( sameInstance ( formatter )  )  )  ;", "}", "METHOD_END"], "methodName": ["getObjectIsAlwaysSingleton"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( factory . getObjectType (  )  ,    is ( equalTo (  (  ( Class )     ( DateTimeFormatter . class )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getObjectType"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( factory . isSingleton (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["isSingleton"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   dateTimeFormatter . withLocale ( Locale . US )  ;", "}", "METHOD_END"], "methodName": ["applyLocale"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( factory . createDateTimeFormatter (  )  ,    is ( equalTo ( DateTimeFormat . mediumDateTime (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatter"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "factory . setStyle (  \" SS \"  )  ;", "String   value    =    applyLocale ( factory . create (  )  )  . print ( dateTime )  ;", "assertTrue ( value . startsWith (  \"  1  0  /  2  1  /  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  1  0    PM \"  )  )  ;", "factory . setIso ( DateTimeFormat . ISO . DATE )  ;", "assertThat ( applyLocale ( factory . create (  )  )  . print ( dateTime )  ,    is (  \"  2  0  0  9  -  1  0  -  2  1  \"  )  )  ;", "factory . setPattern (  \" yyyyMMddHHmmss \"  )  ;", "assertThat ( factory . create (  )  . print ( dateTime )  ,    is (  \"  2  0  0  9  1  0  2  1  1  2  1  0  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterInOrderOfPropertyPriority"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   fallback    =    DateTimeFormat . forStyle (  \" LL \"  )  ;", "DateTimeFormatter   formatter    =    factory . createDateTimeFormatter ( fallback )  ;", "assertThat ( formatter ,    is ( sameInstance ( fallback )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterWithFallback"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   formatter    =    factory . createDateTimeFormatter ( null )  ;", "assertThat ( formatter ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterWithNullFallback"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "factory    =    new   DateTimeFormatterFactory (  \" yyyyMMddHHmmss \"  )  ;", "DateTimeFormatter   formatter    =    factory . createDateTimeFormatter (  )  ;", "assertThat ( formatter . print ( dateTime )  ,    is (  \"  2  0  0  9  1  0  2  1  1  2  1  0  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterWithPattern"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "factory . setPattern (  \" yyyyMMddHHmmss   Z \"  )  ;", "factory . setTimeZone (  . TEST _ TIMEZONE )  ;", "DateTimeZone   dateTimeZone    =    DateTimeZone . forTimeZone (  . TEST _ TIMEZONE )  ;", "DateTime   dateTime    =    new   DateTime (  2  0  0  9  ,     1  0  ,     2  1  ,     1  2  ,     1  0  ,     0  ,     0  ,    dateTimeZone )  ;", "String   offset    =     (  . TEST _ TIMEZONE . equals (  . NEW _ YORK )  )     ?     \"  -  0  4  0  0  \"     :     \"  +  0  2  0  0  \"  ;", "assertThat ( factory . createDateTimeFormatter (  )  . print ( dateTime )  ,    is (  (  \"  2  0  0  9  1  0  2  1  1  2  1  0  0  0     \"     +    offset )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterWithTimeZone"], "fileName": "org.springframework.format.datetime.joda.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatterFactory   factory    =    new   DateTimeFormatterFactory (  )  ;", "String   style    =    resolveEmbeddedValue ( annotation . style (  )  )  ;", "if    ( StringUtils . hasLength ( style )  )     {", "factory . setStyle ( style )  ;", "}", "factory . setIso ( annotation . iso (  )  )  ;", "String   pattern    =    resolveEmbeddedValue ( annotation . pattern (  )  )  ;", "if    ( StringUtils . hasLength ( pattern )  )     {", "factory . setPattern ( pattern )  ;", "}", "return   factory . createDateTimeFormatter (  )  ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaDateTimeFormatAnnotationFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . chronology ;", "}", "METHOD_END"], "methodName": ["getChronology"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . chronology )     !  =    null )     {", "formatter    =    formatter . withChronology ( this . chronology )  ;", "}", "if    (  ( this . timeZone )     !  =    null )     {", "formatter    =    formatter . withZone ( this . timeZone )  ;", "} else    {", "Local   local    =    LocalHolder . getLocal (  )  ;", "if    ( local   instanceof   TimeZoneAwareLocal )     {", "TimeZone   timeZone    =     (  ( TimeZoneAwareLocal )     ( local )  )  . getTimeZone (  )  ;", "if    ( timeZone    !  =    null )     {", "formatter    =    formatter . withZone ( DateTimeZone . forTimeZone ( timeZone )  )  ;", "}", "}", "}", "return   formatter ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContext"}, {"methodBody": ["METHOD_START", "{", "return   this . timeZone ;", "}", "METHOD_END"], "methodName": ["getTimeZone"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContext"}, {"methodBody": ["METHOD_START", "{", "this . chronology    =    chronology ;", "}", "METHOD_END"], "methodName": ["setChronology"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContext"}, {"methodBody": ["METHOD_START", "{", "this . timeZone    =    timeZone ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContext"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   formatterToUse    =     ( locale    !  =    null )     ?    formatter . withLocale ( locale )     :    formatter ;", "JodaTimeContext   context    =     . getJodaTimeContext (  )  ;", "return   context    !  =    null    ?    context . getFormatter ( formatterToUse )     :    formatterToUse ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContextHolder"}, {"methodBody": ["METHOD_START", "{", "return   JodaTimeContextHolder . jodaTimeContextHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["getJodaTimeContext"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContextHolder"}, {"methodBody": ["METHOD_START", "{", "JodaTimeContextHolder . jodaTimeContextHolder . remove (  )  ;", "}", "METHOD_END"], "methodName": ["resetJodaTimeContext"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContextHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( jodaTimeContext    =  =    null )     {", ". resetJodaTimeContext (  )  ;", "} else    {", ". jodaTimeContextHolder . set ( jodaTimeContext )  ;", "}", "}", "METHOD_END"], "methodName": ["setJodaTimeContext"], "fileName": "org.springframework.format.datetime.joda.JodaTimeContextHolder"}, {"methodBody": ["METHOD_START", "{", "DateFormatterRegistrar . addDateConverters ( registry )  ;", "registry . addConverter ( new    . DateTimeToLocalDateConverter (  )  )  ;", "registry . addConverter ( new    . DateTimeToLocalTimeConverter (  )  )  ;", "registry . addConverter ( new    . DateTimeToLocalDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . DateTimeToDateMidnightConverter (  )  )  ;", "registry . addConverter ( new    . DateTimeToMutableDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . DateTimeToInstantConverter (  )  )  ;", "registry . addConverter ( new    . DateTimeToDateConverter (  )  )  ;", "registry . addConverter ( new    . DateTimeToCalendarConverter (  )  )  ;", "registry . addConverter ( new    . DateTimeToLongConverter (  )  )  ;", "registry . addConverter ( new    . DateToReadableInstantConverter (  )  )  ;", "registry . addConverter ( new    . CalendarToReadableInstantConverter (  )  )  ;", "registry . addConverter ( new    . LongToReadableInstantConverter (  )  )  ;", "registry . addConverter ( new    . LocalDateTimeToLocalDateConverter (  )  )  ;", "registry . addConverter ( new    . LocalDateTimeToLocalTimeConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerConverters"], "fileName": "org.springframework.format.datetime.joda.JodaTimeConverters"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    fieldType    :    fieldTypes )     {", "registry . addForFieldType ( fieldType ,    printer ,    parser )  ;", "}", "}", "METHOD_END"], "methodName": ["addFormatterForFields"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   DATE    :", "return   Date . shortDate (  )  ;", "case   TIME    :", "return   Date . shortTime (  )  ;", "default    :", "return   Date . shortDateTime (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFallbackFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   formatter    =    this . formatters . get ( type )  ;", "if    ( formatter    !  =    null )     {", "return   formatter ;", "}", "DateTimeFormatter   fallbackFormatter    =    getFallbackFormatter ( type )  ;", "return   this . factories . get ( type )  . createDateTimeFormatter ( fallbackFormatter )  ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . formatters . put ( JodaTimeFormatterRegistrar . Type . DATE ,    formatter )  ;", "}", "METHOD_END"], "methodName": ["setDateFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . factories . get ( JodaTimeFormatterRegistrar . Type . DATE )  . setStyle (  ( dateStyle    +     \"  -  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setDateStyle"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . formatters . put ( JodaTimeFormatterRegistrar . Type . DATE _ TIME ,    formatter )  ;", "}", "METHOD_END"], "methodName": ["setDateTimeFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . factories . get ( JodaTimeFormatterRegistrar . Type . DATE _ TIME )  . setStyle ( dateTimeStyle )  ;", "}", "METHOD_END"], "methodName": ["setDateTimeStyle"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . formatters . put ( JodaTimeFormatterRegistrar . Type . TIME ,    formatter )  ;", "}", "METHOD_END"], "methodName": ["setTimeFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . factories . get ( JodaTimeFormatterRegistrar . Type . TIME )  . setStyle (  (  \"  -  \"     +    timeStyle )  )  ;", "}", "METHOD_END"], "methodName": ["setTimeStyle"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . factories . get ( JodaTimeFormatterRegistrar . Type . DATE )  . setIso (  ( useIsoFormat    ?    DateTimeFormat . ISO . DATE    :    DateTimeFormat . ISO . NONE )  )  ;", "this . factories . get ( JodaTimeFormatterRegistrar . Type . TIME )  . setIso (  ( useIsoFormat    ?    DateTimeFormat . ISO . TIME    :    DateTimeFormat . ISO . NONE )  )  ;", "this . factories . get ( JodaTimeFormatterRegistrar . Type . DATE _ TIME )  . setIso (  ( useIsoFormat    ?    DateTimeFormat . ISO . DATE _ TIME    :    DateTimeFormat . ISO . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["setUseIsoFormat"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( null )  ;", "ContextHolder . setContext ( null )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "registrar . setDateTimeFormatter ( shortDateTime (  )  )  ;", "setup ( registrar )  ;", "Date   date    =    new   Date (  )  ;", "Object   actual    =    this . conversionService . convert ( date ,    TypeDescriptor . valueOf ( Date . class )  ,    TypeDescriptor . valueOf ( String . class )  )  ;", "String   expected    =    JodaTimeContextHolder . getFormatter ( shortDateTime (  )  ,    Locale . US )  . print ( new   DateTime ( date )  )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["dateToStringWithFormat"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "setup ( registrar )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "registrar . registerFormatters ( conversionService )  ;", ". JodaTimeBean   bean    =    new    . JodaTimeBean (  )  ;", "bean . getChildren (  )  . add ( new    . JodaTimeBean (  )  )  ;", "binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "LocaleContextHolder . setLocale ( Locale . US )  ;", "JodaTimeContext   context    =    new   JodaTimeContext (  )  ;", "context . setTimeZone ( DateTimeZone . forID (  \"  -  0  5  :  0  0  \"  )  )  ;", "JodaTimeContextHolder . setJodaTimeContext ( context )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "DateTimeFormatterFactory   factory    =    new   DateTimeFormatterFactory (  )  ;", "factory . setIso ( DateTimeFormat . ISO . DATE _ TIME )  ;", "registrar . setDateTimeFormatter ( factory . createDateTimeFormatter (  )  )  ;", "setup ( registrar )  ;", "String   string    =     \"  2  0  0  9  -  1  0  -  3  1 T 0  7  :  0  0  :  0  0  .  0  0  0  -  0  5  :  0  0  \"  ;", "Date   date    =    this . conversionService . convert ( string ,    Date . class )  ;", "assertNotNull ( date )  ;", "}", "METHOD_END"], "methodName": ["stringToDateWithGlobalFormat"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "String   string    =     \" Sat ,     1  2    Aug    1  9  9  5     1  3  :  3  0  :  0  0    GM \"  ;", "Date   date    =    this . conversionService . convert ( string ,    Date . class )  ;", "assertThat ( date ,    equalTo ( new   Date ( string )  )  )  ;", "}", "METHOD_END"], "methodName": ["stringToDateWithoutGlobalFormat"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" calendarAnnotd \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" calendarAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindCalendarAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" Annotated \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" Annotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" dateTime \"  ,    new   DateTime (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  ,    ISOChronology . getInstanceUTC (  )  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" dateTime \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \"  1  0  /  3  1  /  0  9  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTime"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" dateTimeAnnotated \"  ,    new   DateTime (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  ,    ISOChronology . getInstanceUTC (  )  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" dateTimeAnnotated \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \" Oct    3  1  ,     2  0  0  9  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" dateTimeAnnotatedDefault \"  ,    new   DateTime (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  ,    ISOChronology . getInstanceUTC (  )  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" dateTimeAnnotatedDefault \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \"  1  0  /  3  1  /  0  9  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeAnnotatedDefault"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" TimeAnnotatedPattern \"  ,     \"  1  0  /  3  1  /  0  9     1  2  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9     1  2  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" TimeAnnotatedPattern \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeAnnotatedPattern"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "registrar . setUseIsoFormat ( true )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" dateTime \"  ,     \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  .  0  0  0 Z \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1 T 0  7  :  0  0  :  0  0  .  0  0  0  -  0  5  :  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" dateTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeISO"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" TimeAnnotatedPattern \"  ,     \"  0  2  /  2  9  /  0  9     1  2  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeOverflow"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "registrar . setDateTimeFormatter ( forPattern (  \" yyyyMMddHHmmss \"  )  )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" dateTime \"  ,     \"  2  0  0  9  1  0  3  1  1  3  0  0  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  1  0  3  1  1  3  0  0  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" dateTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeWithSpecificFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "registrar . setDateTimeStyle (  \" MM \"  )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDateTime \"  ,    new   LocalDateTime (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" localDateTime \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \" Oct    3  1  ,     2  0  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  0  0  :  0  0    PM \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeWithSpecificStyle"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \"  \"  ,     \" Sat ,     1  2    Aug    1  9  9  5     1  3  :  3  0  :  0  0    GMT \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" Sat ,     1  2    Aug    1  9  9  5     1  3  :  3  0  :  0  0    GMT \"  ,    binder . getBindingResult (  )  . getFieldValue (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateWithErrorAvoidingDateConstructor"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DataBinder   binder    =    new   DataBinder ( new   JodaTimeFormattingTests . JodaTimeBean (  )  )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" date \"  ,     \" Sat ,     1  2    Aug    1  9  9  5     1  3  :  3  0  :  0  0    GMT \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateWithoutErrorFallingBackToDateConstructor"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" duration \"  ,     \" PT 7  2  .  3  4  5 S \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" duration \"  )  . toSt (  )  . equals (  \" PT 7  2  .  3  4  5 S \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDuration"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" isoD \"  ,     \"  2  0  0  9  -  1  0  -  3  1  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" isoD \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISODate"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" isoDate \"  ,     \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  .  0  0  0 Z \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1 T 0  7  :  0  0  :  0  0  .  0  0  0  -  0  5  :  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" isoDate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISODateTime"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" iso \"  ,     \"  1  2  :  0  0  :  0  0  .  0  0  0  -  0  5  :  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0  :  0  0  .  0  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" iso \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISOTime"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" instantAnnotd \"  ,     \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  .  0  0  0 Z \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1 T 0  7  :  0  0  :  0  0  .  0  0  0  -  0  5  :  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" instantAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindInstantAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localD \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localD \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDate"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDAnnotd \"  ,     \" Oct    3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" Oct    3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDAnnotd \"  ,     \" Oct    3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" Oct    3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateAnnotatedWithDirectFieldAccess"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDAnnotd \"  ,     \" Oct    0  3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getFieldErrorCount (  \" localDAnnotd \"  )  )  ;", "assertEquals (  \" Oct    0  3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateAnnotatedWithDirectFieldAccessAndError"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDAnnotd \"  ,     \" Oct    0  3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getFieldErrorCount (  \" localDAnnotd \"  )  )  ;", "assertEquals (  \" Oct    0  3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateAnnotatedWithError"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDate \"  ,    new   St [  ]  {     \"  1  0  /  3  1  /  0  9  \"     }  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateArray"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDate \"  ,    new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" localDate \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \"  1  0  /  3  1  /  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  0  0    PM \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateTime"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDateAnnotated \"  ,    new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" localDateAnnotated \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \" Oct    3  1  ,     2  0  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  0  0    PM \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateTimeAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "registrar . setDateFormatter ( forPattern (  \" yyyyMMdd \"  )  )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDate \"  ,     \"  2  0  0  9  1  0  3  1  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  1  0  3  1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateWithSpecificFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "registrar . setDateStyle (  \" L \"  )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDate \"  ,     \" October    3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" October    3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateWithSpecificStyle"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" local \"  ,     \"  1  2  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" local \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTime"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localAnnotated \"  ,     \"  1  2  :  0  0  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTimeAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "registrar . setTimeFormatter ( forPattern (  \" HHmmss \"  )  )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localTime \"  ,     \"  1  3  0  0  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  3  0  0  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTimeWithSpecificFormatter"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "JodaTimeFormatterRegistrar   registrar    =    new   JodaTimeFormatterRegistrar (  )  ;", "registrar . setTimeStyle (  \" M \"  )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localTime \"  ,     \"  1  2  :  0  0  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTimeWithSpecificStyle"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" millis \"  ,     \"  1  2  5  6  9  6  1  6  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  5  6  9  6  1  6  0  0  \"  ,    binder . getBindResult (  )  . getFieldValue (  \" millis \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLong"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" millisAnnotd \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" millisAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLongAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" monthDay \"  ,     \"  -  -  1  2  -  0  3  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" monthDay \"  )  . toSt (  )  . equals (  \"  -  -  1  2  -  0  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindMonthDay"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" mutableDateAnnotated \"  ,     \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  .  0  0  0 Z \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1 T 0  7  :  0  0  :  0  0  .  0  0  0  -  0  5  :  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" mutableDateAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindMutableDateTimeAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" children [  0  ]  . localDAnnotd \"  ,     \" Oct    3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" Oct    3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" children [  0  ]  . localDAnnotd \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindNestedLocalDateAnnotated"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" period \"  ,     \" P 6 Y 3 M 1 D \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" period \"  )  . toSt (  )  . equals (  \" P 6 Y 3 M 1 D \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindPeriod"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" yearMonth \"  ,     \"  2  0  0  7  -  1  2  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" yearMonth \"  )  . toSt (  )  . equals (  \"  2  0  0  7  -  1  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindYearMonth"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( patternForStyle (  \" SS \"  ,    LocaleContextHolder . getLocale (  )  )  )  ;", "System . out . println ( patternForStyle (  \" MM \"  ,    LocaleContextHolder . getLocale (  )  )  )  ;", "System . out . println ( patternForStyle (  \" LL \"  ,    LocaleContextHolder . getLocale (  )  )  )  ;", "System . out . println ( patternForStyle (  \" FF \"  ,    LocaleContextHolder . getLocale (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testJodaTimePatternsForStyle"], "fileName": "org.springframework.format.datetime.joda.JodaTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "return   this . chronology ;", "}", "METHOD_END"], "methodName": ["getChronology"], "fileName": "org.springframework.format.datetime.standard.DateTimeContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . chronology )     !  =    null )     {", "formatter    =    formatter . withChronology ( this . chronology )  ;", "}", "if    (  ( this . timeZone )     !  =    null )     {", "formatter    =    formatter . withZone ( this . timeZone )  ;", "} else    {", "Local   local    =    LocalHolder . getLocal (  )  ;", "if    ( local   instanceof   TimeZoneAwareLocal )     {", "TimeZone   timeZone    =     (  ( TimeZoneAwareLocal )     ( local )  )  . getTimeZone (  )  ;", "if    ( timeZone    !  =    null )     {", "formatter    =    formatter . withZone ( timeZone . toZoneId (  )  )  ;", "}", "}", "}", "return   formatter ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeContext"}, {"methodBody": ["METHOD_START", "{", "return   this . timeZone ;", "}", "METHOD_END"], "methodName": ["getTimeZone"], "fileName": "org.springframework.format.datetime.standard.DateTimeContext"}, {"methodBody": ["METHOD_START", "{", "this . chronology    =    chronology ;", "}", "METHOD_END"], "methodName": ["setChronology"], "fileName": "org.springframework.format.datetime.standard.DateTimeContext"}, {"methodBody": ["METHOD_START", "{", "this . timeZone    =    timeZone ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.format.datetime.standard.DateTimeContext"}, {"methodBody": ["METHOD_START", "{", "return   DateTimeContextHolder . dateTimeContextHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["getDateTimeContext"], "fileName": "org.springframework.format.datetime.standard.DateTimeContextHolder"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   formatterToUse    =     ( locale    !  =    null )     ?    formatter . withLocale ( locale )     :    formatter ;", "DateTimeContext   context    =     . getDateTimeContext (  )  ;", "return   context    !  =    null    ?    context . getFormatter ( formatterToUse )     :    formatterToUse ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeContextHolder"}, {"methodBody": ["METHOD_START", "{", "DateTimeContextHolder . dateTimeContextHolder . remove (  )  ;", "}", "METHOD_END"], "methodName": ["resetDateTimeContext"], "fileName": "org.springframework.format.datetime.standard.DateTimeContextHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( dateTimeContext    =  =    null )     {", ". resetDateTimeContext (  )  ;", "} else    {", ". dateTimeContextHolder . set ( dateTimeContext )  ;", "}", "}", "METHOD_END"], "methodName": ["setDateTimeContext"], "fileName": "org.springframework.format.datetime.standard.DateTimeContextHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( source   instanceof   GregorianCalendar )     {", "return    (  ( GregorianCalendar )     ( source )  )  . toZoned (  )  ;", "} else    {", "return   Zoned . ofInstant ( Instant . ofEpochMilli ( source . getTimeInMillis (  )  )  ,    source . getTimeZone (  )  . toZoneId (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["calendarToZonedDateTime"], "fileName": "org.springframework.format.datetime.standard.DateTimeConverters"}, {"methodBody": ["METHOD_START", "{", "DateFormatterRegistrar . addDateConverters ( registry )  ;", "registry . addConverter ( new    . LocalDateTimeToLocalDateConverter (  )  )  ;", "registry . addConverter ( new    . LocalDateTimeToLocalTimeConverter (  )  )  ;", "registry . addConverter ( new    . ZonedDateTimeToLocalDateConverter (  )  )  ;", "registry . addConverter ( new    . ZonedDateTimeToLocalTimeConverter (  )  )  ;", "registry . addConverter ( new    . ZonedDateTimeToLocalDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . ZonedDateTimeToOffsetDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . ZonedDateTimeToInstantConverter (  )  )  ;", "registry . addConverter ( new    . OffsetDateTimeToLocalDateConverter (  )  )  ;", "registry . addConverter ( new    . OffsetDateTimeToLocalTimeConverter (  )  )  ;", "registry . addConverter ( new    . OffsetDateTimeToLocalDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . OffsetDateTimeToZonedDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . OffsetDateTimeToInstantConverter (  )  )  ;", "registry . addConverter ( new    . CalendarToZonedDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . CalendarToOffsetDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . CalendarToLocalDateConverter (  )  )  ;", "registry . addConverter ( new    . CalendarToLocalTimeConverter (  )  )  ;", "registry . addConverter ( new    . CalendarToLocalDateTimeConverter (  )  )  ;", "registry . addConverter ( new    . CalendarToInstantConverter (  )  )  ;", "registry . addConverter ( new    . LongToInstantConverter (  )  )  ;", "registry . addConverter ( new    . InstantToLongConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerConverters"], "fileName": "org.springframework.format.datetime.standard.DateTimeConverters"}, {"methodBody": ["METHOD_START", "{", "switch    ( c )     {", "case    ' S '     :", "return   Style . SHORT ;", "case    ' M '     :", "return   Style . MEDIUM ;", "case    ' L '     :", "return   Style . LONG ;", "case    ' F '     :", "return   Style . FULL ;", "case    '  -  '     :", "return   null ;", "default    :", "throw   new   IllegalArgumentException (  (  (  \" Invalid   style   character    '  \"     +    c )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convertStyleCharacter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "return   createDateTimeFormatter ( DateTimeFormatter . ofLocalizedDateTime ( FormatStyle . MEDIUM )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   dateTimeFormatter    =    null ;", "if    ( StringUtils . hasLength ( this . pattern )  )     {", "String   patternToUse    =    this . pattern . replace (  \" yy \"  ,     \" uu \"  )  ;", "dateTimeFormatter    =    DateTimeFormatter . ofPattern ( patternToUse )  . withResolverStyle ( ResolverStyle . STRICT )  ;", "} else", "if    (  (  ( this . iso )     !  =    null )     &  &     (  ( this . iso )     !  =     ( annotation . DateTimeFormat . ISO . NONE )  )  )     {", "switch    ( this . iso )     {", "case   DATE    :", "dateTimeFormatter    =    DateTimeFormatter . ISO _ DATE ;", "break ;", "case   TIME    :", "dateTimeFormatter    =    DateTimeFormatter . ISO _ TIME ;", "break ;", "case   DATE _ TIME    :", "dateTimeFormatter    =    DateTimeFormatter . ISO _ DATE _ TIME ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Unsupported   ISO   format :     \"     +     ( this . iso )  )  )  ;", "}", "} else", "if    (  (  ( this . dateStyle )     !  =    null )     &  &     (  ( this . timeStyle )     !  =    null )  )     {", "dateTimeFormatter    =    DateTimeFormatter . ofLocalizedDateTime ( this . dateStyle ,    this . timeStyle )  ;", "} else", "if    (  ( this . dateStyle )     !  =    null )     {", "dateTimeFormatter    =    DateTimeFormatter . ofLocalizedDate ( this . dateStyle )  ;", "} else", "if    (  ( this . timeStyle )     !  =    null )     {", "dateTimeFormatter    =    DateTimeFormatter . ofLocalizedTime ( this . timeStyle )  ;", "}", "if    (  ( dateTimeFormatter    !  =    null )     &  &     (  ( this . timeZone )     !  =    null )  )     {", "dateTimeFormatter    =    dateTimeFormatter . withZone ( this . timeZone . toZoneId (  )  )  ;", "}", "return   dateTimeFormatter    !  =    null    ?    dateTimeFormatter    :    fallbackFormatter ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . dateStyle    =    dateStyle ;", "}", "METHOD_END"], "methodName": ["setDateStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . dateStyle    =    dateTimeStyle ;", "this . timeStyle    =    dateTimeStyle ;", "}", "METHOD_END"], "methodName": ["setDateTimeStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . iso    =    iso ;", "}", "METHOD_END"], "methodName": ["setIso"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . pattern    =    pattern ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( style . length (  )  )     =  =     2  )  ,     \" Style   pattern   must   consist   of   two   characters \"  )  ;", "this . dateStyle    =    convertStyleCharacter ( style . charAt (  0  )  )  ;", "this . timeStyle    =    convertStyleCharacter ( style . charAt (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setStylePattern"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . timeStyle    =    timeStyle ;", "}", "METHOD_END"], "methodName": ["setTimeStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . timeZone    =    timeZone ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "factory . afterPropertiesSet (  )  ;", "assertThat ( factory . getObject (  )  . toString (  )  ,    is ( equalTo (  . ofLocalizedDateTime ( FormatStyle . MEDIUM )  . toString (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getObject"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "factory . afterPropertiesSet (  )  ;", "formatter    =    factory . getObject (  )  ;", "assertThat ( formatter . toString (  )  ,    is ( equalTo (  . ofLocalizedDateTime ( FormatStyle . MEDIUM )  . toString (  )  )  )  )  ;", "factory . setStylePattern (  \" LL \"  )  ;", "assertThat ( factory . getObject (  )  ,    is ( sameInstance ( formatter )  )  )  ;", "}", "METHOD_END"], "methodName": ["getObjectIsAlwaysSingleton"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( factory . getObjectType (  )  ,    is ( equalTo ( DateTimeFormatter . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["getObjectType"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( factory . isSingleton (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["isSingleton"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   dateTimeFormatter . withLocale ( Locale . US )  ;", "}", "METHOD_END"], "methodName": ["applyLocale"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( factory . createDateTimeFormatter (  )  . toString (  )  ,    is ( equalTo ( DateTimeFormatter . ofLocalizedDateTime ( FormatStyle . MEDIUM )  . toString (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "factory . setStylePattern (  \" SS \"  )  ;", "String   value    =    applyLocale ( factory . create (  )  )  . format ( dateTime )  ;", "assertTrue ( value . startsWith (  \"  1  0  /  2  1  /  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  1  0    PM \"  )  )  ;", "factory . setIso ( DateTimeFormat . ISO . DATE )  ;", "assertThat ( applyLocale ( factory . create (  )  )  . format ( dateTime )  ,    is (  \"  2  0  0  9  -  1  0  -  2  1  \"  )  )  ;", "factory . setPattern (  \" yyyyMMddHHmmss \"  )  ;", "assertThat ( factory . create (  )  . format ( dateTime )  ,    is (  \"  2  0  0  9  1  0  2  1  1  2  1  0  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterInOrderOfPropertyPriority"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   fallback    =    DateTimeFormatter . ofLocalizedDateTime ( FormatStyle . LONG )  ;", "DateTimeFormatter   formatter    =    factory . createDateTimeFormatter ( fallback )  ;", "assertThat ( formatter ,    is ( sameInstance ( fallback )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterWithFallback"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   formatter    =    factory . createDateTimeFormatter ( null )  ;", "assertThat ( formatter ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterWithNullFallback"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "factory    =    new   DateTimeFormatterFactory (  \" yyyyMMddHHmmss \"  )  ;", "DateTimeFormatter   formatter    =    factory . createDateTimeFormatter (  )  ;", "assertThat ( formatter . format ( dateTime )  ,    is (  \"  2  0  0  9  1  0  2  1  1  2  1  0  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterWithPattern"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "factory . setPattern (  \" yyyyMMddHHmmss   Z \"  )  ;", "factory . setTimeZone (  . TEST _ TIMEZONE )  ;", "ZoneId   dateTimeZone    =     . TEST _ TIMEZONE . toZoneId (  )  ;", "ZonedDateTime   dateTime    =    ZonedDateTime . of (  2  0  0  9  ,     1  0  ,     2  1  ,     1  2  ,     1  0  ,     0  ,     0  ,    dateTimeZone )  ;", "String   offset    =     (  . TEST _ TIMEZONE . equals (  . NEW _ YORK )  )     ?     \"  -  0  4  0  0  \"     :     \"  +  0  2  0  0  \"  ;", "assertThat ( factory . createDateTimeFormatter (  )  . format ( dateTime )  ,    is (  (  \"  2  0  0  9  1  0  2  1  1  2  1  0  0  0     \"     +    offset )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDateTimeFormatterWithTimeZone"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterFactoryTests"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   DATE    :", "return    . ofLocalizedDate ( FormatStyle . SHORT )  ;", "case   TIME    :", "return    . ofLocalizedTime ( FormatStyle . SHORT )  ;", "default    :", "return    . ofLocalizedDateTime ( FormatStyle . SHORT )  ;", "}", "}", "METHOD_END"], "methodName": ["getFallbackFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatter   formatter    =    this . formatters . get ( type )  ;", "if    ( formatter    !  =    null )     {", "return   formatter ;", "}", "DateTimeFormatter   fallbackFormatter    =    getFallbackFormatter ( type )  ;", "return   this . factories . get ( type )  . createDateTimeFormatter ( fallbackFormatter )  ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . formatters . put ( DateTimeFormatterRegistrar . Type . DATE ,    formatter )  ;", "}", "METHOD_END"], "methodName": ["setDateFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . factories . get ( DateTimeFormatterRegistrar . Type . DATE )  . setDateStyle ( dateStyle )  ;", "}", "METHOD_END"], "methodName": ["setDateStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . formatters . put ( DateTimeFormatterRegistrar . Type . DATE _ TIME ,    formatter )  ;", "}", "METHOD_END"], "methodName": ["setDateTimeFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . factories . get ( DateTimeFormatterRegistrar . Type . DATE _ TIME )  . setDateTimeStyle ( dateTimeStyle )  ;", "}", "METHOD_END"], "methodName": ["setDateTimeStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . formatters . put ( DateTimeFormatterRegistrar . Type . TIME ,    formatter )  ;", "}", "METHOD_END"], "methodName": ["setTimeFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . factories . get ( DateTimeFormatterRegistrar . Type . TIME )  . setTimeStyle ( timeStyle )  ;", "}", "METHOD_END"], "methodName": ["setTimeStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . factories . get ( DateTimeFormatterRegistrar . Type . DATE )  . setIso (  ( useIsoFormat    ?    DateTimeFormat . ISO . DATE    :    DateTimeFormat . ISO . NONE )  )  ;", "this . factories . get ( DateTimeFormatterRegistrar . Type . TIME )  . setIso (  ( useIsoFormat    ?    DateTimeFormat . ISO . TIME    :    DateTimeFormat . ISO . NONE )  )  ;", "this . factories . get ( DateTimeFormatterRegistrar . Type . DATE _ TIME )  . setIso (  ( useIsoFormat    ?    DateTimeFormat . ISO . DATE _ TIME    :    DateTimeFormat . ISO . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["setUseIsoFormat"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( null )  ;", "ContextHolder . setContext ( null )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatterRegistrar   registrar    =    new   DateTimeFormatterRegistrar (  )  ;", "setup ( registrar )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "registrar . registerFormatters ( conversionService )  ;", ". DateTimeBean   bean    =    new    . DateTimeBean (  )  ;", "bean . getChildren (  )  . add ( new    . DateTimeBean (  )  )  ;", "binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "LocaleContextHolder . setLocale ( Locale . US )  ;", "DateTimeContext   context    =    new   DateTimeContext (  )  ;", "context . setTimeZone ( ZoneId . of (  \"  -  0  5  :  0  0  \"  )  )  ;", "DateTimeContextHolder . setDateTimeContext ( context )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" dAnnotatedPattern \"  ,     \"  1  0  /  3  1  /  0  9     1  2  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9     1  2  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" dAnnotatedPattern \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeAnnotatedPattern"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" dAnnotatedPattern \"  ,     \"  0  2  /  2  9  /  0  9     1  2  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeOverflow"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatterRegistrar   registrar    =    new   DateTimeFormatterRegistrar (  )  ;", "registrar . setDateTimeStyle ( FormatStyle . MEDIUM )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDateTime \"  ,    LocalDateTime . of (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" localDateTime \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \" Oct    3  1  ,     2  0  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  0  0  :  0  0    PM \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDateTimeWithSpecificStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" duration \"  ,     \" PT 8 H 6 M 1  2  .  3  4  5 S \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" duration \"  )  . toSt (  )  . equals (  \" PT 8 H 6 M 1  2  .  3  4  5 S \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindDuration"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" iso \"  ,     \"  2  0  0  9  -  1  0  -  3  1  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" iso \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISODate"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" iso \"  ,     \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" iso \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISODateTime"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" iso \"  ,     \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  .  0  0  0 Z \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" iso \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISODateTimeWithZone"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" iso \"  ,     \"  1  2  :  0  0  :  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0  :  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" iso \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISOTime"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" iso \"  ,     \"  1  2  :  0  0  :  0  0  .  0  0  0  -  0  5  :  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0  :  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" iso \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindISOTimeWithZone"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" int \"  ,     \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  :  0  0  .  0  0  0 Z \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" int \"  )  . toString (  )  . startsWith (  \"  2  0  0  9  -  1  0  -  3  1 T 1  2  :  0  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindInstant"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "TimeZone   defaultZone    =    TimeZone . getDefault (  )  ;", "TimeZone . setDefault ( TimeZone . getTimeZone (  \" GMT \"  )  )  ;", "try    {", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" instant \"  ,    new   Date (  1  0  9  ,     9  ,     3  1  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" instant \"  )  . toString (  )  . startsWith (  \"  2  0  0  9  -  1  0  -  3  1  \"  )  )  ;", "}    finally    {", "TimeZone . setDefault ( defaultZone )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindInstantFromJavaUtilDate"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" local \"  ,     \"  1  0  /  3  1  /  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" local \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDate"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localAnnotated \"  ,     \" Oct    3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" Oct    3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateAnnotated"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localAnnotated \"  ,     \" Oct    3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" Oct    3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateAnnotatedWithDirectFieldAccess"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localAnnotated \"  ,     \" Oct    -  3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getFieldErrorCount (  \" localAnnotated \"  )  )  ;", "assertEquals (  \" Oct    -  3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateAnnotatedWithDirectFieldAccessAndError"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localAnnotated \"  ,     \" Oct    -  3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getFieldErrorCount (  \" localAnnotated \"  )  )  ;", "assertEquals (  \" Oct    -  3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateAnnotatedWithError"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" local \"  ,    new   String [  ]  {     \"  1  0  /  3  1  /  0  9  \"     }  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateArray"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDate \"  ,    new   GregorianCale (  2  0  0  9  ,     9  ,     3  1  ,     0  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateFromJavaUtilCalendar"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" local \"  ,    Local . of (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" local \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \"  1  0  /  3  1  /  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  0  0    PM \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateTime"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localAnnotated \"  ,    Local . of (  2  0  0  9  ,     1  0  ,     3  1  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" localAnnotated \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \" Oct    3  1  ,     2  0  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  0  0  :  0  0    PM \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateTimeAnnotated"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" local \"  ,    new   GregorianCalendar (  2  0  0  9  ,     9  ,     3  1  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "String   value    =    binder . getBindingResult (  )  . getFieldValue (  \" local \"  )  . toString (  )  ;", "assertTrue ( value . startsWith (  \"  1  0  /  3  1  /  0  9  \"  )  )  ;", "assertTrue ( value . endsWith (  \"  1  2  :  0  0    PM \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateTimeFromJavaUtilCalendar"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatterRegistrar   registrar    =    new   DateTimeFormatterRegistrar (  )  ;", "registrar . setDateFormatter ( DateTimeFormatter . ofPattern (  \" yyyyMMdd \"  )  )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDate \"  ,     \"  2  0  0  9  1  0  3  1  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  2  0  0  9  1  0  3  1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateWithSpecificFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatterRegistrar   registrar    =    new   DateTimeFormatterRegistrar (  )  ;", "registrar . setDateStyle ( FormatStyle . LONG )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localDate \"  ,     \" October    3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" October    3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localDate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalDateWithSpecificStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" local \"  ,     \"  1  2  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" local \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTime"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localAnnotated \"  ,     \"  1  2  :  0  0  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTimeAnnotated"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localTime \"  ,    new   GregorianCale (  1  9  7  0  ,     0  ,     0  ,     1  2  ,     0  )  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTimeFromJavaUtilCalendar"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatterRegistrar   registrar    =    new   DateTimeFormatterRegistrar (  )  ;", "registrar . setTimeFormatter ( DateTimeFormatter . ofPattern (  \" HHmmss \"  )  )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localTime \"  ,     \"  1  3  0  0  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  3  0  0  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTimeWithSpecificFormatter"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatterRegistrar   registrar    =    new   DateTimeFormatterRegistrar (  )  ;", "registrar . setTimeStyle ( FormatStyle . MEDIUM )  ;", "setup ( registrar )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" localTime \"  ,     \"  1  2  :  0  0  :  0  0    PM \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  2  :  0  0  :  0  0    PM \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" localTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindLocalTimeWithSpecificStyle"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" month \"  ,     \" JULY \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" month \"  )  . toSt (  )  . equals (  \" JULY \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindMonth"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" monthDay \"  ,     \"  -  -  1  2  -  0  3  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" monthDay \"  )  . toSt (  )  . equals (  \"  -  -  1  2  -  0  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindMonthDay"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" month \"  ,     \" July \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" month \"  )  . toSt (  )  . equals (  \" JULY \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindMonthInAnyCase"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" children [  0  ]  . localAnnotated \"  ,     \" Oct    3  1  ,     2  0  0  9  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" Oct    3  1  ,     2  0  0  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" children [  0  ]  . localAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindNestedLocalDateAnnotated"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" period \"  ,     \" P 6 Y 3 M 1 D \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" period \"  )  . toSt (  )  . equals (  \" P 6 Y 3 M 1 D \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindPeriod"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" year \"  ,     \"  2  0  0  7  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" year \"  )  . toSt (  )  . equals (  \"  2  0  0  7  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindYear"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" yearMonth \"  ,     \"  2  0  0  7  -  1  2  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . getFieldValue (  \" yearMonth \"  )  . toSt (  )  . equals (  \"  2  0  0  7  -  1  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindYearMonth"], "fileName": "org.springframework.format.datetime.standard.DateTimeFormattingTests"}, {"methodBody": ["METHOD_START", "{", "DateTimeFormatterFactory   factory    =    new   DateTimeFormatterFactory (  )  ;", "String   style    =    resolveEmbeddedValue ( annotation . style (  )  )  ;", "if    ( StringUtils . hasLength ( style )  )     {", "factory . setStylePattern ( style )  ;", "}", "factory . setIso ( annotation . iso (  )  )  ;", "String   pattern    =    resolveEmbeddedValue ( annotation . pattern (  )  )  ;", "if    ( StringUtils . hasLength ( pattern )  )     {", "factory . setPattern ( pattern )  ;", "}", "return   factory . createDateTimeFormatter (  )  ;", "}", "METHOD_END"], "methodName": ["getFormatter"], "fileName": "org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "return   fieldType . getSimpleName (  )  . startsWith (  \" Local \"  )  ;", "}", "METHOD_END"], "methodName": ["isLocal"], "fileName": "org.springframework.format.datetime.standard.Jsr310DateTimeFormatAnnotationFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "this . lenient    =    lenient ;", "}", "METHOD_END"], "methodName": ["setLenient"], "fileName": "org.springframework.format.number.AbstractNumberFormatter"}, {"methodBody": ["METHOD_START", "{", "this . currency    =    currency ;", "}", "METHOD_END"], "methodName": ["setCurrency"], "fileName": "org.springframework.format.number.CurrencyStyleFormatter"}, {"methodBody": ["METHOD_START", "{", "this . fractionDigits    =    fractionDigits ;", "}", "METHOD_END"], "methodName": ["setFractionDigits"], "fileName": "org.springframework.format.number.CurrencyStyleFormatter"}, {"methodBody": ["METHOD_START", "{", "this . pattern    =    pattern ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "org.springframework.format.number.CurrencyStyleFormatter"}, {"methodBody": ["METHOD_START", "{", "this . roundingMode    =    roundingMode ;", "}", "METHOD_END"], "methodName": ["setRoundingMode"], "fileName": "org.springframework.format.number.CurrencyStyleFormatter"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  $  2  3  .  0  0  \"  ,    formatter . print ( new   BigDecimal (  \"  2  3  \"  )  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["formatValue"], "fileName": "org.springframework.format.number.CurrencyStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "formatter . parse (  \" bogus \"  ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["parseBogusValue"], "fileName": "org.springframework.format.number.CurrencyStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   BigDecimal (  \"  2  3  .  5  6  \"  )  ,    formatter . parse (  \"  $  2  3  .  5  6  \"  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["parseValue"], "fileName": "org.springframework.format.number.CurrencyStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "this . formatter . setRoundingMode ( RoundingMode . DOWN )  ;", "assertEquals ( new   BigDecimal (  \"  2  3  .  5  6  \"  )  ,    formatter . parse (  \"  $  2  3  .  5  6  7  \"  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["parseValueDefaultRoundDown"], "fileName": "org.springframework.format.number.CurrencyStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "formatter . parse (  \"  $  2  3  .  5  6 bogus \"  ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["parseValueNotLenientFailure"], "fileName": "org.springframework.format.number.CurrencyStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   BigDecimal (  \"  2  3  .  0  0  \"  )  ,    formatter . parse (  \"  $  2  3  \"  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["parseWholeValue"], "fileName": "org.springframework.format.number.CurrencyStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "String   pattern    =    resolveEmbeddedValue ( annotation . pattern (  )  )  ;", "if    ( StringUtils . hasLength ( pattern )  )     {", "return   new   NumberStyleFormatter ( pattern )  ;", "} else    {", ". Style   style    =    annotation . style (  )  ;", "if    ( style    =  =     (  . Style . CURRENCY )  )     {", "return   new   CurrencyStyleFormatter (  )  ;", "} else", "if    ( style    =  =     (  . Style . PERCENT )  )     {", "return   new   PercentStyleFormatter (  )  ;", "} else    {", "return   new   NumberStyleFormatter (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["configureFormatterFrom"], "fileName": "org.springframework.format.number.NumberFormatAnnotationFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . setEmbeddedValueResolver ( new   StringValueResolver (  )     {", "@ Override", "public   String   resolveStringValue ( String   strVal )     {", "if    (  \"  $  { pattern }  \"  . equals ( strVal )  )     {", "return    \"  #  ,  #  #  .  0  0  \"  ;", "} else    {", "return   strVal ;", "}", "}", "}  )  ;", "conversionService . addFormatterForFieldType ( Number . class ,    new   NumberStyleFormatter (  )  )  ;", "conversionService . addFormatterForFieldAnnotation ( new   NumberFormatAnnotationFormatterFactory (  )  )  ;", "LocaleContextHolder . setLocale ( Locale . US )  ;", "binder    =    new   DataBinder ( new    . TestBean (  )  )  ;", "binder . setConversionService ( conversionService )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( null )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropyValues   propyValues    =    new   MutablePropyValues (  )  ;", "propyValues . add (  \" currency \"  ,     \"  $  3  ,  3  3  9  .  1  2  \"  )  ;", "bindbind ( propyValues )  ;", "assEquals (  0  ,    bindgetBindingResult (  )  . getErrorCount (  )  )  ;", "assEquals (  \"  $  3  ,  3  3  9  .  1  2  \"  ,    bindgetBindingResult (  )  . getFieldValue (  \" currency \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCurrencyFormatting"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" Default \"  ,     \"  3  ,  3  3  9  .  1  2  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  3  ,  3  3  9  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" Default \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultNumberFormatting"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" DefaultAnnotated \"  ,     \"  3  ,  3  3  9  .  1  2  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  3  ,  3  3  9  .  1  2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" DefaultAnnotated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultNumberFormattingAnnotated"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" patternArray \"  ,    new   St [  ]  {     \"  1  ,  2  5  .  0  0  \"  ,     \"  2  ,  3  5  .  0  0  \"     }  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  ,  2  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" patternArray [  0  ]  \"  )  )  ;", "assertEquals (  \"  2  ,  3  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" patternArray [  1  ]  \"  )  )  ;", "propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" patternArray [  0  ]  \"  ,     \"  1  ,  2  5  .  0  0  \"  )  ;", "propertyValues . add (  \" patternArray [  1  ]  \"  ,     \"  2  ,  3  5  .  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  ,  2  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" patternArray [  0  ]  \"  )  )  ;", "assertEquals (  \"  2  ,  3  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" patternArray [  1  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternArrayFormatting"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" pern \"  ,     \"  1  ,  2  5  .  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  ,  2  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" pern \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternFormatting"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" pernList 2  [  0  ]  \"  ,     \"  1  ,  2  5  .  0  0  \"  )  ;", "propertyValues . add (  \" pernList 2  [  1  ]  \"  ,     \"  2  ,  3  5  .  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  ,  2  5  .  0  0  ,  2  ,  3  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" pernList 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternList2FormattingList"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" pernList 2  [  0  ]  \"  ,     \"  1  ,  2  5  .  0  0  \"  )  ;", "propertyValues . add (  \" pernList 2  [  1  ]  \"  ,     \"  2  ,  3  5  .  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  ,  2  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" pernList 2  [  0  ]  \"  )  )  ;", "assertEquals (  \"  2  ,  3  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" pernList 2  [  1  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternList2FormattingListElement"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" patternList \"  ,    new   St [  ]  {     \"  1  ,  2  5  .  0  0  \"  ,     \"  2  ,  3  5  .  0  0  \"     }  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  ,  2  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" patternList [  0  ]  \"  )  )  ;", "assertEquals (  \"  2  ,  3  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" patternList [  1  ]  \"  )  )  ;", "propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" patternList [  0  ]  \"  ,     \"  1  ,  2  5  .  0  0  \"  )  ;", "propertyValues . add (  \" patternList [  1  ]  \"  ,     \"  2  ,  3  5  .  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  ,  2  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" patternList [  0  ]  \"  )  )  ;", "assertEquals (  \"  2  ,  3  5  .  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" patternList [  1  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternListFormatting"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropyValues   propyValues    =    new   MutablePropyValues (  )  ;", "propyValues . add (  \" pent \"  ,     \"  5  3  %  \"  )  ;", "bindbind ( propyValues )  ;", "assEquals (  0  ,    bindgetBindingResult (  )  . getErrorCount (  )  )  ;", "assEquals (  \"  5  3  %  \"  ,    bindgetBindingResult (  )  . getFieldValue (  \" pent \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPercentFormatting"], "fileName": "org.springframework.format.number.NumberFormattingTests"}, {"methodBody": ["METHOD_START", "{", "this . pattern    =    pattern ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "org.springframework.format.number.NumberStyleFormatter"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  2  3  .  5  6  \"  ,    formatter . print ( new   BigDecimal (  \"  2  3  .  5  6  \"  )  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["formatValue"], "fileName": "org.springframework.format.number.NumberStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "formatter . parse (  \" bogus \"  ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["parseBogusValue"], "fileName": "org.springframework.format.number.NumberStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "formatter . parse (  \"  2  3  .  5  6 bogus \"  ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["parsePercentValueNotLenientFailure"], "fileName": "org.springframework.format.number.NumberStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   BigDecimal (  \"  2  3  .  5  6  \"  )  ,    formatter . parse (  \"  2  3  .  5  6  \"  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["parseValue"], "fileName": "org.springframework.format.number.NumberStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  2  3  %  \"  ,    formatter . print ( new   BigDecimal (  \"  .  2  3  \"  )  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["formatValue"], "fileName": "org.springframework.format.number.PercentStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "formatter . parse (  \" bogus \"  ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["parseBogusValue"], "fileName": "org.springframework.format.number.PercentStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "formatter . parse (  \"  2  3  .  5  6  % bogus \"  ,    Locale . US )  ;", "}", "METHOD_END"], "methodName": ["parsePercentValueNotLenientFailure"], "fileName": "org.springframework.format.number.PercentStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   BigDecimal (  \"  .  2  3  5  6  \"  )  ,    formatter . parse (  \"  2  3  .  5  6  %  \"  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["parseValue"], "fileName": "org.springframework.format.number.PercentStyleFormatterTests"}, {"methodBody": ["METHOD_START", "{", "String   pattern    =    resolveEmbeddedValue ( annotation . pattern (  )  )  ;", "if    ( StringUtils . hasLength ( pattern )  )     {", "return   new    . PatternDecoratingFormatter ( pattern )  ;", "} else    {", "NumberFormat . Style   style    =    annotation . style (  )  ;", "if    ( style    =  =     ( NumberFormat . Style . NUMBER )  )     {", "return   new    . NumberDecoratingFormatter ( new   NumberStyleFormatter (  )  )  ;", "} else", "if    ( style    =  =     ( NumberFormat . Style . PERCENT )  )     {", "return   new    . NumberDecoratingFormatter ( new   PercentStyleFormatter (  )  )  ;", "} else    {", "return   new    . NumberDecoratingFormatter ( new   CurrencyStyleFormatter (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["configureFormatterFrom"], "fileName": "org.springframework.format.number.money.Jsr354NumberFormatAnnotationFormatterFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . formatName )     !  =    null )     {", "return   MonetaryFormats . get ( this . formatName )  ;", "} else    {", "return   MonetaryFormats . get ( locale )  ;", "}", "}", "METHOD_END"], "methodName": ["getMonetaryAmountFormat"], "fileName": "org.springframework.format.number.money.MonetaryAmountFormatter"}, {"methodBody": ["METHOD_START", "{", "this . formatName    =    formatName ;", "}", "METHOD_END"], "methodName": ["setFormatName"], "fileName": "org.springframework.format.number.money.MonetaryAmountFormatter"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( Locale . US )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.format.number.money.MoneyFormattingTests"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( null )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.format.number.money.MoneyFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MoneyFormattingTests . MoneyHolder   bean    =    new   MoneyFormattingTests . MoneyHolder (  )  ;", "DataBinder   binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" amount \"  ,     \" USD    1  0  .  5  0  \"  )  ;", "propertyValues . add (  \" unit \"  ,     \" USD \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" USD 1  0  .  5  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertEquals (  \" USD \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" unit \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     1  0  .  5  )  )  ;", "assertEquals (  \" USD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "LocaleContextHolder . setLocale ( Locale . CANADA )  ;", "binder . bind ( propertyValues )  ;", "LocaleContextHolder . setLocale ( Locale . US )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" USD 1  0  .  5  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertEquals (  \" USD \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" unit \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     1  0  .  5  )  )  ;", "assertEquals (  \" USD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAmountAndUnit"], "fileName": "org.springframework.format.number.money.MoneyFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MoneyFormattingTests . FormattedMoneyHolder 1    bean    =    new   MoneyFormattingTests . FormattedMoneyHolder 1  (  )  ;", "DataBinder   binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" amount \"  ,     \"  $  1  0  .  5  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  $  1  0  .  5  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     1  0  .  5  )  )  ;", "assertEquals (  \" USD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "LocaleContextHolder . setLocale ( Locale . CANADA )  ;", "binder . bind ( propertyValues )  ;", "LocaleContextHolder . setLocale ( Locale . US )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  $  1  0  .  5  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     1  0  .  5  )  )  ;", "assertEquals (  \" CAD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAmountWithNumberFormat1"], "fileName": "org.springframework.format.number.money.MoneyFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MoneyFormattingTests . FormattedMoneyHolder 2    bean    =    new   MoneyFormattingTests . FormattedMoneyHolder 2  (  )  ;", "DataBinder   binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" amount \"  ,     \"  1  0  .  5  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  .  5  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     1  0  .  5  )  )  ;", "assertEquals (  \" USD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAmountWithNumberFormat2"], "fileName": "org.springframework.format.number.money.MoneyFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MoneyFormattingTests . FormattedMoneyHolder 3    bean    =    new   MoneyFormattingTests . FormattedMoneyHolder 3  (  )  ;", "DataBinder   binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" amount \"  ,     \"  1  0  %  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  1  0  %  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     0  .  1  )  )  ;", "assertEquals (  \" USD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAmountWithNumberFormat3"], "fileName": "org.springframework.format.number.money.MoneyFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MoneyFormattingTests . FormattedMoneyHolder 4    bean    =    new   MoneyFormattingTests . FormattedMoneyHolder 4  (  )  ;", "DataBinder   binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" amount \"  ,     \"  0  1  0  .  5  0  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \"  0  1  0  .  5  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     1  0  .  5  )  )  ;", "assertEquals (  \" USD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAmountWithNumberFormat4"], "fileName": "org.springframework.format.number.money.MoneyFormattingTests"}, {"methodBody": ["METHOD_START", "{", "MoneyFormattingTests . FormattedMoneyHolder 5    bean    =    new   MoneyFormattingTests . FormattedMoneyHolder 5  (  )  ;", "DataBinder   binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   propertyValues    =    new   MutablePropertyValues (  )  ;", "propertyValues . add (  \" amount \"  ,     \" USD    1  0  .  5  0  \"  )  ;", "binder . bind ( propertyValues )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" USD    0  1  0  .  5  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     1  0  .  5  )  )  ;", "assertEquals (  \" USD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "LocaleContextHolder . setLocale ( Locale . CANADA )  ;", "binder . bind ( propertyValues )  ;", "LocaleContextHolder . setLocale ( Locale . US )  ;", "assertEquals (  0  ,    binder . getBindingResult (  )  . getErrorCount (  )  )  ;", "assertEquals (  \" USD    0  1  0  .  5  0  0  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" amount \"  )  )  ;", "assertTrue (  (  ( bean . getAmount (  )  . getNumber (  )  . doubleValue (  )  )     =  =     1  0  .  5  )  )  ;", "assertEquals (  \" USD \"  ,    bean . getAmount (  )  . getCurrency (  )  . getCurrencyCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAmountWithNumberFormat5"], "fileName": "org.springframework.format.number.money.MoneyFormattingTests"}, {"methodBody": ["METHOD_START", "{", "formatterRegistry . addFormatterForFieldAnnotation ( new   NumberFormatAnnotationFormatterFactory (  )  )  ;", "if    (  . jsr 3  5  4 Present )     {", "formatterRegistry . addFormatter ( new   CurrencyUnitFormatter (  )  )  ;", "formatterRegistry . addFormatter ( new   MonetaryAmountFormatter (  )  )  ;", "formatterRegistry . addFormatterForFieldAnnotation ( new   Jsr 3  5  4 NumberFormatAnnotationFormatterFactory (  )  )  ;", "}", "new   DateTimeFormatterRegistrar (  )  . registerFormatters ( formatterRegistry )  ;", "if    (  . jodaTimePresent )     {", "new   JodaTimeFormatterRegistrar (  )  . registerFormatters ( formatterRegistry )  ;", "} else    {", "new   DateFormatterRegistrar (  )  . registerFormatters ( formatterRegistry )  ;", "}", "}", "METHOD_END"], "methodName": ["addDefaultFormatters"], "fileName": "org.springframework.format.support.DefaultFormattingConversionService"}, {"methodBody": ["METHOD_START", "{", "return   FormattingConversionService . getFieldType ( this . formatter )  ;", "}", "METHOD_END"], "methodName": ["getFieldType"], "fileName": "org.springframework.format.support.FormatterPropertyEditorAdapter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Annotation >    annotationType    =     (  ( Class <  ?    extends   Annotation >  )     ( GenericTypeResolver . resolveTypeArgument ( factory . getClass (  )  ,    AnnotationFormatterFactory . class )  )  )  ;", "if    ( annotationType    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Unable   to   extract   parameterized   Annotation   type   argument   from    \"     +     \" AnnotationFormatterFactory    [  \"  )     +     ( factory . getClass (  )  . getName (  )  )  )     +     \"  ]  ;    does   the   factory   parameterize   the    < A   extends   Annotation >    generic   type ?  \"  )  )  ;", "}", "return   annotationType ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.springframework.format.support.FormattingConversionService"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    fieldType    =    GenericTypeResolver . resolveTypeArgument ( formatter . getClass (  )  ,    Formatter . class )  ;", "if    (  ( fieldType    =  =    null )     &  &     ( formatter   instanceof   DecoratingProxy )  )     {", "fieldType    =    GenericTypeResolver . resolveTypeArgument (  (  ( DecoratingProxy )     ( formatter )  )  . getDecoratedClass (  )  ,    Formatter . class )  ;", "}", "if    ( fieldType    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  \" Unable   to   extract   the   parameterized   field   type   from   Formatter    [  \"     +     ( formatter . getClass (  )  . getName (  )  )  )     +     \"  ]  ;    does   the   class   parameterize   the    < T >    generic   type ?  \"  )  )  ;", "}", "return   fieldType ;", "}", "METHOD_END"], "methodName": ["getFieldType"], "fileName": "org.springframework.format.support.FormattingConversionService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . formatters )     !  =    null )     {", "for    ( Object   formatter    :    this . formatters )     {", "if    ( formatter   instanceof   Formatter <  ?  >  )     {", "conversionService . addFormatter (  (  ( Formatter <  ?  >  )     ( formatter )  )  )  ;", "} else", "if    ( formatter   instanceof   AnnotationFormatterFactory <  ?  >  )     {", "conversionService . addFormatterForFieldAnnotation (  (  ( AnnotationFormatterFactory <  ?  >  )     ( formatter )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Custom   formatters   must   be   implementations   of   Formatter   or   AnnotationFormatterFactory \"  )  ;", "}", "}", "}", "if    (  ( this . formatterRegistrars )     !  =    null )     {", "for    ( FormatterRegistrar   registrar    :    this . formatterRegistrars )     {", "registrar . registerFormatters ( conversionService )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerFormatters"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . converters    =    converters ;", "}", "METHOD_END"], "methodName": ["setConverters"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . formatterRegistrars    =    formatterRegistrars ;", "}", "METHOD_END"], "methodName": ["setFormatterRegistrars"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . formatters    =    formatters ;", "}", "METHOD_END"], "methodName": ["setFormatters"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . registerDefaultFormatters    =    registerDefaultFormatters ;", "}", "METHOD_END"], "methodName": ["setRegisterDefaultFormatters"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBean"}, {"methodBody": ["METHOD_START", "{", "FormattingConversionServiceFactoryBean   factory    =    new   FormattingConversionServiceFactoryBean (  )  ;", "Set < Object >    formatters    =    new   HashSet <  >  (  )  ;", "formatters . add ( new    . TestBeanFormatter (  )  )  ;", "formatters . add ( new    . SpecialIntAnnotationFormatterFactory (  )  )  ;", "factory . setFormatters ( formatters )  ;", "factory . afterPropertiesSet (  )  ;", "FormattingConversionService   fcs    =    factory . getObject (  )  ;", ". TestBean   testBean    =    fcs . convert (  \"  5  \"  ,     . TestBean . class )  ;", "assertEquals (  5  ,    testBean . getSpecialInt (  )  )  ;", "assertEquals (  \"  5  \"  ,    fcs . convert ( testBean ,    String . class )  )  ;", "TypeDescriptor   descriptor    =    new   TypeDescriptor (  . TestBean . class . getDeclaredField (  \" specialInt \"  )  )  ;", "Object   value    =    fcs . convert (  \"  :  5  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    descriptor )  ;", "assertEquals (  5  ,    value )  ;", "value    =    fcs . convert (  5  ,    descriptor ,    TypeDescriptor . valueOf ( String . class )  )  ;", "assertEquals (  \"  :  5  \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["testCustomFormatter"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FormattingConversionServiceFactoryBean   factory    =    new   FormattingConversionServiceFactoryBean (  )  ;", "factory . setRegisterDefaultFormatters ( false )  ;", "factory . afterPropertiesSet (  )  ;", "FormattingConversionService   fcs    =    factory . getObject (  )  ;", "TypeDescriptor   descriptor    =    new   TypeDescriptor (  . TestBean . class . getDeclaredField (  \" pattern \"  )  )  ;", "try    {", "fcs . convert (  \"  1  5  ,  0  0  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    descriptor )  ;", "fail (  \" This   format   should   not   be   parseable \"  )  ;", "}    catch    ( ConversionFailedException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   NumberFormatException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDefaultFormattersOff"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FormattingConversionServiceFactoryBean   factory    =    new   FormattingConversionServiceFactoryBean (  )  ;", "factory . afterPropertiesSet (  )  ;", "FormattingConversionService   fcs    =    factory . getObject (  )  ;", "TypeDescriptor   descriptor    =    new   TypeDescriptor (  . TestBean . class . getDeclaredField (  \" pattern \"  )  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "Object   value    =    fcs . convert (  \"  1  5  ,  0  0  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    descriptor )  ;", "assertEquals (  1  5  .  0  ,    value )  ;", "value    =    fcs . convert (  1  5  .  0  ,    descriptor ,    TypeDescriptor . valueOf ( String . class )  )  ;", "assertEquals (  \"  1  5  \"  ,    value )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDefaultFormattersOn"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FormattingConversionServiceFactoryBean   factory    =    new   FormattingConversionServiceFactoryBean (  )  ;", "Set < FormatterRegistrar >    registrars    =    new   HashSet <  >  (  )  ;", "registrars . add ( new    . TestFormatterRegistrar (  )  )  ;", "factory . setFormatterRegistrars ( registrars )  ;", "factory . afterPropertiesSet (  )  ;", "FormattingConversionService   fcs    =    factory . getObject (  )  ;", ". TestBean   testBean    =    fcs . convert (  \"  5  \"  ,     . TestBean . class )  ;", "assertEquals (  5  ,    testBean . getSpecialInt (  )  )  ;", "assertEquals (  \"  5  \"  ,    fcs . convert ( testBean ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testFormatterRegistrar"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FormattingConversionServiceFactoryBean   factory    =    new   FormattingConversionServiceFactoryBean (  )  ;", "Set < Object >    formatters    =    new   HashSet <  >  (  )  ;", "formatters . add ( new   Object (  )  )  ;", "factory . setFormatters ( formatters )  ;", "try    {", "factory . afterPropertiesSet (  )  ;", "fail (  \" Expected   formatter   to   be   rejected \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testInvalidFormatter"], "fileName": "org.springframework.format.support.FormattingConversionServiceFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addConverter ( new   Converter < Date ,    Long >  (  )     {", "@ Override", "public   Long   convert ( Date   source )     {", "return   source . getTime (  )  ;", "}", "}  )  ;", "formattingService . addConverter ( new   Converter < DateTime ,    Date >  (  )     {", "@ Override", "public   Date   convert ( DateTime   source )     {", "return   source . toDate (  )  ;", "}", "}  )  ;", "String   formatted    =     (  ( String )     ( formattingService . convert ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  . toDateTimeAtCurrentTime (  )  . toDate (  )  ,    new   TypeDescriptor ( modelClass . getField (  \" date \"  )  )  ,    TypeDescriptor . valueOf ( String . class )  )  )  )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    formatted )  ;", "LocalDate   date    =    new   LocalDate ( formattingService . convert (  \"  1  0  /  3  1  /  0  9  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( modelClass . getField (  \" date \"  )  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  ,    date )  ;", "List < Date >    dates    =    new   ArrayList <  >  (  )  ;", "dates . add ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  . toDateTimeAtCurrentTime (  )  . toDate (  )  )  ;", "dates . add ( new   LocalDate (  2  0  0  9  ,     1  1  ,     1  )  . toDateTimeAtCurrentTime (  )  . toDate (  )  )  ;", "dates . add ( new   LocalDate (  2  0  0  9  ,     1  1  ,     2  )  . toDateTimeAtCurrentTime (  )  . toDate (  )  )  ;", "formatted    =     (  ( String )     ( formattingService . convert ( dates ,    new   TypeDescriptor ( modelClass . getField (  \" dates \"  )  )  ,    TypeDescriptor . valueOf ( String . class )  )  )  )  ;", "assertEquals (  \"  1  0  -  3  1  -  0  9  ,  1  1  -  1  -  0  9  ,  1  1  -  2  -  0  9  \"  ,    formatted )  ;", "dates    =     (  ( List < Date >  )     ( formattingService . convert (  \"  1  0  -  3  1  -  0  9  ,  1  1  -  1  -  0  9  ,  1  1  -  2  -  0  9  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( modelClass . getField (  \" dates \"  )  )  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  ,    new   LocalDate ( dates . get (  0  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  1  ,     1  )  ,    new   LocalDate ( dates . get (  1  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  1  ,     2  )  ,    new   LocalDate ( dates . get (  2  )  )  )  ;", "Object   model    =    modelClass . newInstance (  )  ;", "ConfigurablePropertyAccessor   accessor    =     ( directFieldAccess )     ?    PropertyAccessorFactory . forDirectFieldAccess ( model )     :    PropertyAccessorFactory . forBeanPropertyAccess ( model )  ;", "accessor . setConversionService ( formattingService )  ;", "accessor . setPropertyValue (  \" dates \"  ,     \"  1  0  -  3  1  -  0  9  ,  1  1  -  1  -  0  9  ,  1  1  -  2  -  0  9  \"  )  ;", "dates    =     (  ( List < Date >  )     ( accessor . getPropertyValue (  \" dates \"  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  ,    new   LocalDate ( dates . get (  0  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  1  ,     1  )  ,    new   LocalDate ( dates . get (  1  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  1  ,     2  )  ,    new   LocalDate ( dates . get (  2  )  )  )  ;", "if    (  ! directFieldAccess )     {", "accessor . setPropertyValue (  \" dates [  0  ]  \"  ,     \"  1  0  -  3  0  -  0  9  \"  )  ;", "accessor . setPropertyValue (  \" dates [  1  ]  \"  ,     \"  1  0  -  1  -  0  9  \"  )  ;", "accessor . setPropertyValue (  \" dates [  2  ]  \"  ,     \"  1  0  -  2  -  0  9  \"  )  ;", "dates    =     (  ( List < Date >  )     ( accessor . getPropertyValue (  \" dates \"  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  0  )  ,    new   LocalDate ( dates . get (  0  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     1  )  ,    new   LocalDate ( dates . get (  1  )  )  )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     2  )  ,    new   LocalDate ( dates . get (  2  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestFormatFieldForAnnotation"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldAnnotation ( new   JodaDateTimeFormatAnnotationFormatterFactory (  )  )  ;", "doTestFormatFieldForAnnotation (  . Model . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["formatFieldForAnnotation"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldAnnotation ( new   JodaDateTimeFormatAnnotationFormatterFactory (  )  )  ;", "doTestFormatFieldForAnnotation (  . Model . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["formatFieldForAnnotationWithDirectFieldAccess"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" dateStyle \"  ,     \" S -  \"  )  ;", "props . setProperty (  \" datePattern \"  ,     \" M - d - yy \"  )  ;", "ppc . setProperties ( props )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" ppc \"  ,    ppc )  ;", "context . refresh (  )  ;", "context . getBeanFactory (  )  . initializeBean ( formattingService ,     \" formattingService \"  )  ;", "formattingService . addFormatterForFieldAnnotation ( new   JodaDateTimeFormatAnnotationFormatterFactory (  )  )  ;", "doTestFormatFieldForAnnotation (  . ModelWithPlaceholders . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["formatFieldForAnnotationWithPlaceholders"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" dateStyle \"  ,     \" S -  \"  )  ;", "props . setProperty (  \" datePattern \"  ,     \" M - d - yy \"  )  ;", "ppc . setProperties ( props )  ;", "context . registerBeanDefinition (  \" formattingService \"  ,    new   RootBeanDefinition ( FormattingConversionServiceFactoryBean . class )  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" ppc \"  ,    ppc )  ;", "context . refresh (  )  ;", "formattingService    =    context . getBean (  \" formattingService \"  ,    FormattingConversionService . class )  ;", "doTestFormatFieldForAnnotation (  . ModelWithPlaceholders . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["formatFieldForAnnotationWithPlaceholdersAndFactoryBean"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldAnnotation ( new   JodaDateTimeFormatAnnotationFormatterFactory (  )     {", "@ Override", "public   Printer <  ?  >    getPrinter ( DateTimeFormat   annotation ,    Class <  ?  >    fieldType )     {", "assertEquals (  . MyDate . class ,    fieldType )  ;", "return   super . getPrinter ( annotation ,    fieldType )  ;", "}", "}  )  ;", "formattingService . addConverter ( new   Converter <  . MyDate ,    Long >  (  )     {", "@ Override", "public   Long   convert (  . MyDate   source )     {", "return   source . getTime (  )  ;", "}", "}  )  ;", "formattingService . addConverter ( new   Converter <  . MyDate ,    Date >  (  )     {", "@ Override", "public   Date   convert (  . MyDate   source )     {", "return   source ;", "}", "}  )  ;", "formattingService . convert ( new    . MyDate (  )  ,    new   TypeDescriptor (  . ModelWithSubclassField . class . getField (  \" date \"  )  )  ,    TypeDescriptor . valueOf ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["formatFieldForAnnotationWithSubclassAsFieldType"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldType ( Number . class ,    new   NumberStyleFormatter (  )  )  ;", "String   formatted    =    formattingService . convert (  3  ,    String . class )  ;", "assertEquals (  \"  3  \"  ,    formatted )  ;", "Integer   i    =    formattingService . convert (  \"  3  \"  ,    Integer . class )  ;", "assertEquals ( new   Integer (  3  )  ,    i )  ;", "}", "METHOD_END"], "methodName": ["formatFieldForTypeWithFormatter"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addConverter ( new   Converter < DateTime ,    LocalDate >  (  )     {", "@ Override", "public   LocalDate   convert ( DateTime   source )     {", "return   source . toLocalDate (  )  ;", "}", "}  )  ;", "formattingService . addFormatterForFieldType ( LocalDate . class ,    new   ReadablePartialPrinter ( DateTimeFormat . shortDate (  )  )  ,    new   DateTimeParser ( DateTimeFormat . shortDate (  )  )  )  ;", "String   formatted    =    formattingService . convert ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  ,    String . class )  ;", "assertEquals (  \"  1  0  /  3  1  /  0  9  \"  ,    formatted )  ;", "LocalDate   date    =    formattingService . convert (  \"  1  0  /  3  1  /  0  9  \"  ,    LocalDate . class )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  ,    date )  ;", "}", "METHOD_END"], "methodName": ["formatFieldForTypeWithPrinterParserWithCoercion"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ac    =    new   AnnotationConfigApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" valueBean \"  ,    new   RootBeanDefinition (  . ValueBean . class )  )  ;", "ac . registerBeanDefinition (  \" conversionService \"  ,    new   RootBeanDefinition ( FormattingConversionServiceFactoryBean . class )  )  ;", "ac . refresh (  )  ;", ". ValueBean   valueBean    =    ac . getBean (  . ValueBean . class )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  ,    new   LocalDate ( valueBean . date )  )  ;", "}", "METHOD_END"], "methodName": ["formatFieldForValueInjection"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ac    =    new   AnnotationConfigApplicationContext (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MetaValueBean . class )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "ac . registerBeanDefinition (  \" valueBean \"  ,    bd )  ;", "ac . registerBeanDefinition (  \" conversionService \"  ,    new   RootBeanDefinition ( FormattingConversionServiceFactoryBean . class )  )  ;", "ac . registerBeanDefinition (  \" ppc \"  ,    new   RootBeanDefinition ( PropertyPlaceholderConfigurer . class )  )  ;", "ac . refresh (  )  ;", "System . setProperty (  \" myDate \"  ,     \"  1  0  -  3  1  -  0  9  \"  )  ;", "System . setProperty (  \" myNumber \"  ,     \"  9  9  .  9  9  %  \"  )  ;", "try    {", ". MetaValueBean   valueBean    =    ac . getBean (  . MetaValueBean . class )  ;", "assertEquals ( new   LocalDate (  2  0  0  9  ,     1  0  ,     3  1  )  ,    new   LocalDate ( valueBean . date )  )  ;", "assertEquals ( Double . valueOf (  0  .  9  9  9  9  )  ,    valueBean . number )  ;", "}    finally    {", "System . clearProperty (  \" myDate \"  )  ;", "System . clearProperty (  \" myNumber \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["formatFieldForValueInjectionUsingMetaAnnotations"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addConverter ( new   FormattingConversionServiceTests . IntegerConverter (  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    formattingService . convert (  \"  1  \"  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["introspectedConverter"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addConverterFactory ( new   FormattingConversionServiceTests . IntegerConverterFactory (  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    formattingService . convert (  \"  1  \"  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["introspectedConverterFactory"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatter ( new   NumberStyleFormatter (  )  )  ;", "assertNull ( formattingService . convert ( null ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["introspectedFormatter"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldType ( Number . class ,    new   NumberStyleFormatter (  )  )  ;", "assertNull ( formattingService . convert (  \"                 \"  ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseBlankString"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldType ( Number . class ,    new   NumberStyleFormatter (  )  )  ;", "assertNull ( formattingService . convert (  \"  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseEmptyString"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( formattingService . convert (  \"  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseEmptyStringDefault"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldType ( Number . class ,    new   NumberStyleFormatter (  )  )  ;", "assertNull ( formattingService . convert ( null ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseNull"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( formattingService . convert ( null ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseNullDefault"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldType ( Integer . class ,    new   NumberStyleFormatter (  )  )  ;", "assertNull ( formattingService . convert ( null ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( int . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseNullPrimitiveProperty"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldType ( Integer . class ,    new   FormattingConversionServiceTests . NullReturningFormatter (  )  )  ;", "assertNull ( formattingService . convert (  \"  1  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseParserReturnsNull"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldType ( Number . class ,    new   NumberStyleFormatter (  )  )  ;", "assertEquals (  \"  \"  ,    formattingService . convert ( null ,    TypeDescriptor . valueOf ( Integer . class )  ,    TypeDescriptor . valueOf ( String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["printNull"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    formattingService . convert ( null ,    TypeDescriptor . valueOf ( Integer . class )  ,    TypeDescriptor . valueOf ( String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["printNullDefault"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Converter <  ?  ,     ?  >    converter    =    new   FormattingConversionServiceTests . IntegerConverter (  )  ;", "formattingService . addConverter (  (  ( Converter <  ?  ,     ?  >  )     ( new   ProxyFactory ( converter )  . getProxy (  )  )  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    formattingService . convert (  \"  1  \"  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["proxiedConverter"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "ConverterFactory <  ?  ,     ?  >    converterFactory    =    new   FormattingConversionServiceTests . IntegerConverterFactory (  )  ;", "formattingService . addConverterFactory (  (  ( ConverterFactory <  ?  ,     ?  >  )     ( new   ProxyFactory ( converterFactory )  . getProxy (  )  )  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    formattingService . convert (  \"  1  \"  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["proxiedConverterFactory"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Formatter <  ?  >    formatter    =    new   NumberStyleFormatter (  )  ;", "fService . addFormatter (  (  ( Formatter <  ?  >  )     ( new   ProxyFactory ( formatter )  . getProxy (  )  )  )  )  ;", "assertNull ( fService . convert ( null ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["proxiedFormatter"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService . addFormatterForFieldType ( clazz ,    new   Formatter < T >  (  )     {", "@ Override", "public   T   parse ( String   text ,    Locale   locale )    throws   ParseException    {", "return   defaultValue ;", "}", "@ Override", "public   String   print ( T   t ,    Locale   locale )     {", "return   defaultValue . toString (  )  ;", "}", "@ Override", "public   String   toString (  )     {", "return   defaultValue . toString (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerDefaultValue"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "registerDefaultValue ( Date . class ,    new   Date (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerDefaultValueViaFormatter"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "formattingService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( formattingService )  ;", "LocaleContextHolder . setLocale ( Locale . US )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "LocaleContextHolder . setLocale ( null )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.format.support.FormattingConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   loader    =    new   SimpleInstrumentableClassLoader ( ClassUtils . getDefaultClassLoader (  )  )  ;", "ReflectiveLoadTimeWeaver   handler    =    new   ReflectiveLoadTimeWeaver ( loader )  ;", "assertSame ( loader ,    handler . getInstrumentableClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultLoadTimeWeaver"], "fileName": "org.springframework.instrument.classloading.InstrumentableClassLoaderTests"}, {"methodBody": ["METHOD_START", "{", "if    ( InstrumentationLoadTimeWeaver . AGENT _ CLASS _ PRESENT )     {", "return   InstrumentationLoadTimeWeaver . InstrumentationAccessor . getInstrumentation (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getInstrumentation"], "fileName": "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"}, {"methodBody": ["METHOD_START", "{", "return    ( InstrumentationLoadTimeWeaver . getInstrumentation (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isInstrumentationAvailable"], "fileName": "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . transformers )     {", "if    (  (  ( this . i )     !  =    null )     &  &     (  !  ( this . transformers . isEmpty (  )  )  )  )     {", "for    ( int   i    =     ( this . transformers . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "this . i . removeTransformer ( this . transformers . get ( i )  )  ;", "}", "this . transformers . clear (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeTransformers"], "fileName": "org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"}, {"methodBody": ["METHOD_START", "{", "new   ReflectiveLoadTimeWeaver ( new   ReflectiveLoadTimeWeaverTests . JustAddTransformerClassLoader (  )  )  . addTransformer ( null )  ;", "}", "METHOD_END"], "methodName": ["testAddTransformerWithNullTransformer"], "fileName": "org.springframework.instrument.classloading.ReflectiveLoadTimeWeaverTests"}, {"methodBody": ["METHOD_START", "{", "ReflectiveLoadTimeWeaverTests . JustAddTransformerClassLoader   classLoader    =    new   ReflectiveLoadTimeWeaverTests . JustAddTransformerClassLoader (  )  ;", "ReflectiveLoadTimeWeaver   weaver    =    new   ReflectiveLoadTimeWeaver ( classLoader )  ;", "weaver . addTransformer ( new   ClassFileTransformer (  )     {", "@ Override", "public   byte [  ]    transform ( ClassLoader   loader ,    String   className ,    Class <  ?  >    classBeingRedefined ,    ProtectionDomain   protectionDomain ,    byte [  ]    classfileBuffer )     {", "return    \" CAFEDEAD \"  . getBytes (  )  ;", "}", "}  )  ;", "assertEquals (  1  ,    classLoader . getNumTimesGetThrowawayClassLoaderCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithClassLoaderThatDoesNotExposeAGetThrowawayClassLoaderMethodIsOkay"], "fileName": "org.springframework.instrument.classloading.ReflectiveLoadTimeWeaverTests"}, {"methodBody": ["METHOD_START", "{", "new   ReflectiveLoadTimeWeaver ( getClass (  )  . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithClassLoaderThatDoesNotExposeAnAddTransformerMethod"], "fileName": "org.springframework.instrument.classloading.ReflectiveLoadTimeWeaverTests"}, {"methodBody": ["METHOD_START", "{", "new   ReflectiveLoadTimeWeaver ( null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullClassLoader"], "fileName": "org.springframework.instrument.classloading.ReflectiveLoadTimeWeaverTests"}, {"methodBody": ["METHOD_START", "{", "ReflectiveLoadTimeWeaver   weaver    =    new   ReflectiveLoadTimeWeaver ( new   ReflectiveLoadTimeWeaverTests . JustAddTransformerClassLoader (  )  )  ;", "ClassLoader   throwawayClassLoader    =    weaver . getThrowawayClassLoader (  )  ;", "assertNotNull ( throwawayClassLoader )  ;", "}", "METHOD_END"], "methodName": ["testGetThrowawayClassLoaderWithClassLoaderThatDoesNotExposeAGetThrowawayClassLoaderMethodYieldsFallbackClassLoader"], "fileName": "org.springframework.instrument.classloading.ReflectiveLoadTimeWeaverTests"}, {"methodBody": ["METHOD_START", "{", "ReflectiveLoadTimeWeaverTests . TotallyCompliantClassLoader   classLoader    =    new   ReflectiveLoadTimeWeaverTests . TotallyCompliantClassLoader (  )  ;", "ReflectiveLoadTimeWeaver   weaver    =    new   ReflectiveLoadTimeWeaver ( classLoader )  ;", "ClassLoader   throwawayClassLoader    =    weaver . getThrowawayClassLoader (  )  ;", "assertNotNull ( throwawayClassLoader )  ;", "assertEquals (  1  ,    classLoader . getNumTimesGetThrowawayClassLoaderCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetThrowawayClassLoaderWithTotallyCompliantClassLoader"], "fileName": "org.springframework.instrument.classloading.ReflectiveLoadTimeWeaverTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \" Other   ClassLoader   must   not   be   null \"  )  ;", "this . overrides . putAll ( other . overrides )  ;", "}", "METHOD_END"], "methodName": ["copyOverrides"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "this . overrides . put ( oldPath ,    newPath )  ;", "}", "METHOD_END"], "methodName": ["override"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "this . overrides . put ( oldPath ,    null )  ;", "}", "METHOD_END"], "methodName": ["suppress"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "int   elts    =     0  ;", "while    ( e . hasMoreEles (  )  )     {", "e . nextEle (  )  ;", "+  + elts ;", "}", "return   elts ;", "}", "METHOD_END"], "methodName": ["countElements"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( thisClassLoader . getResource ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "overridingLoader . override ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE ,    null )  ;", "assertNull ( overridingLoader . getResource ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotFindExistingResourceWithGetResourceAndNullOverride"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( thisClassLoader . getResourceAsStream ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "overridingLoader . override ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE ,    null )  ;", "assertNull ( overridingLoader . getResourceAsStream ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotFindExistingResourceWithGetResourceAsStreamAndNullOverride"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( thisClassLoader . getResources ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "overridingLoader . override ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE ,    null )  ;", "assertEquals (  0  ,    countElements ( overridingLoader . getResources ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotFindExistingResourceWithGetResourcesAndNullOverride"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( thisClassLoader . getResource ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "assertNotNull ( overridingLoader . getResource ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["testFindsExistingResourceWithGetResourceAndNoOverrides"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( thisClassLoader . getResourceAsStream ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "assertNotNull ( overridingLoader . getResourceAsStream ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["testFindsExistingResourceWithGetResourceAsStreamAndNoOverrides"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( thisClassLoader . getResources ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "assertNotNull ( overridingLoader . getResources ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  ;", "assertEquals (  1  ,    countElements ( overridingLoader . getResources ( ResourceOverridingShadowingClassLoaderTests . EXISTING _ RESOURCE )  )  )  ;", "}", "METHOD_END"], "methodName": ["testFindsExistingResourceWithGetResourcesAndNoOverrides"], "fileName": "org.springframework.instrument.classloading.ResourceOverridingShadowingClassLoaderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( transformer ,     \" Transformer   must   not   be   null \"  )  ;", "thisFileTransformers . add ( transformer )  ;", "}", "METHOD_END"], "methodName": ["addTransformer"], "fileName": "org.springframework.instrument.classloading.ShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "String   internalName    =    StringUtils . replace ( name ,     \"  .  \"  ,     \"  /  \"  )  ;", "try    {", "for    ( ClassFileTransformer   transformer    :    thisFileTransformers )     {", "byte [  ]    transformed    =    transformer . transform ( this ,    internalName ,    null ,    null ,    bytes )  ;", "bytes    =     ( transformed    !  =    null )     ?    transformed    :    bytes ;", "}", "return   bytes ;", "}    catch    ( IllegalClassFormatException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["applyTransformers"], "fileName": "org.springframework.instrument.classloading.ShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \" Other   ClassLoader   must   not   be   null \"  )  ;", "this . classFileTransformers . addAll ( other . classFileTransformers )  ;", "}", "METHOD_END"], "methodName": ["copyTransformers"], "fileName": "org.springframework.instrument.classloading.ShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "String   internalName    =     ( StringUtils . replace ( name ,     \"  .  \"  ,     \"  /  \"  )  )     +     \"  . class \"  ;", "InputStream   is    =    this . enclos . getResourceAsStream ( internalName )  ;", "if    ( is    =  =    null )     {", "throw   new   ClassNotFoundException ( name )  ;", "}", "try    {", "byte [  ]    bytes    =    FileCopyUtils . copyToByteArray ( is )  ;", "bytes    =    applyTransformers ( name ,    bytes )  ;", "Class <  ?  >    cls    =    defineClass ( name ,    bytes ,     0  ,    bytes . length )  ;", "if    (  ( cls . getPackage (  )  )     =  =    null )     {", "int   packageSeparator    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( packageSeparator    !  =     (  -  1  )  )     {", "String   packageName    =    name . substring (  0  ,    packageSeparator )  ;", "definePackage ( packageName ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  ;", "}", "}", "this . classCache . put ( name ,    cls )  ;", "return   cls ;", "}    catch    ( IOException   ex )     {", "throw   new   ClassNotFoundException (  (  (  \" Cannot   load   resource   for   class    [  \"     +    name )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doLoadClass"], "fileName": "org.springframework.instrument.classloading.ShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "return    !  ( isExcluded ( className )  )  ;", "}", "METHOD_END"], "methodName": ["isEligibleForShadowing"], "fileName": "org.springframework.instrument.classloading.ShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "return    (  (  !  ( className . equals ( getClass (  )  . getName (  )  )  )  )     &  &     (  !  ( className . endsWith (  \" ShadowingClassLoader \"  )  )  )  )     &  &     ( isEligibleForShadowing ( className )  )  ;", "}", "METHOD_END"], "methodName": ["shouldShadow"], "fileName": "org.springframework.instrument.classloading.ShadowingClassLoader"}, {"methodBody": ["METHOD_START", "{", "this . weavingTransformer . addTransformer ( transformer )  ;", "}", "METHOD_END"], "methodName": ["addTransformer"], "fileName": "org.springframework.instrument.classloading.SimpleInstrumentableClassLoader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( transformer ,     \" Transformer   must   not   be   null \"  )  ;", "this . transformers . add ( transformer )  ;", "}", "METHOD_END"], "methodName": ["addTransformer"], "fileName": "org.springframework.instrument.classloading.WeavingTransformer"}, {"methodBody": ["METHOD_START", "{", "String   internalName    =    className . replace (  \"  .  \"  ,     \"  /  \"  )  ;", "return   tIfNecessary ( className ,    internalName ,    bytes ,    null )  ;", "}", "METHOD_END"], "methodName": ["transformIfNecessary"], "fileName": "org.springframework.instrument.classloading.WeavingTransformer"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    result    =    bytes ;", "for    ( ClassFile   cft    :    this . transformers )     {", "try    {", "byte [  ]    transformed    =    cft . transform ( this . classLoader ,    internalName ,    null ,    pd ,    result )  ;", "if    ( transformed    !  =    null )     {", "result    =    transformed ;", "}", "}    catch    ( IllegalClassFormatException   ex )     {", "throw   new   IllegalStateException (  \" Class   file   transformation   failed \"  ,    ex )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["transformIfNecessary"], "fileName": "org.springframework.instrument.classloading.WeavingTransformer"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( transformer ,     \" ClassFileTransformer   must   not   be   null \"  )  ;", "try    {", "InvocationHandler   adapter    =    new   PreProcessorAdapter ( transformer ,    this . classLoader )  ;", "Object   adapterInstance    =    Proxy . newProxyInstance ( this . wlPreProcessorClass . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    this . wlPreProcessorClass    }  ,    adapter )  ;", "this . addPreProcessorMethod . invoke ( this . classLoader ,    adapterInstance )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   IllegalStateException (  \" WebLogic   addInstanceClassPreProcessor   method   threw   exception \"  ,    ex . getCause (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Could   not   invoke   WebLogic   addInstanceClassPreProcessor   method \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["addTransformer"], "fileName": "org.springframework.instrument.classloading.weblogic.WebLogicClassLoaderAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . classLoader ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.springframework.instrument.classloading.weblogic.WebLogicClassLoaderAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   classFinder    =    this . getClassFinderMethod . invoke ( this . classLoader )  ;", "Object   parent    =    this . getParentMethod . invoke ( this . classLoader )  ;", "return    (  ( ClassLoader )     ( this . wlGenerConstructor . newInstance ( classFinder ,    parent )  )  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   IllegalStateException (  \" WebLogic   Gener   constructor   failed \"  ,    ex . getCause (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Could   not   construct   WebLogic   Gener \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getThrowawayClassLoader"], "fileName": "org.springframework.instrument.classloading.weblogic.WebLogicClassLoaderAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "byte [  ]    result    =    this . transformer . transform ( this . loader ,    Name ,    null ,    null ,    Bytes )  ;", "return   result    !  =    null    ?    result    :    Bytes ;", "}    catch    ( IllegalClassFormatException   ex )     {", "throw   new   IllegalStateException (  \" Cannot   transform   due   to   illegal      format \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["preProcess"], "fileName": "org.springframework.instrument.classloading.weblogic.WebLogicClassPreProcessorAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( transformer ,     \" ClassFileTransformer   must   not   be   null \"  )  ;", "try    {", "InvocationHandler   adapter    =    new   PreDefinePlugin ( transformer )  ;", "Object   adapterInstance    =    Proxy . newProxyInstance ( this . wsPreProcessorClass . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    this . wsPreProcessorClass    }  ,    adapter )  ;", "this . addPreDefinePlugin . invoke ( this . classLoader ,    adapterInstance )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   IllegalStateException (  \" WebSphere   addPreDefinePlugin   method   threw   exception \"  ,    ex . getCause (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Could   not   invoke   WebSphere   addPreDefinePlugin   method \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["addTransformer"], "fileName": "org.springframework.instrument.classloading.websphere.WebSphereClassLoaderAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . classLoader ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.springframework.instrument.classloading.websphere.WebSphereClassLoaderAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "loader    =    this . cloneConstructor . newInstance ( get (  )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( this . transformerList . get ( loader )  )  )  ;", "list . clear (  )  ;", "return   loader ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   IllegalStateException (  \" WebSphere   Compound   constructor   failed \"  ,    ex . getCause (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Could   not   construct   WebSphere   Compound \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getThrowawayClassLoader"], "fileName": "org.springframework.instrument.classloading.websphere.WebSphereClassLoaderAdapter"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    result    =    transformer . transform ( classLoader ,    className . replace (  '  .  '  ,     '  /  '  )  ,    null ,    null ,    classfileBuffer )  ;", "return   result    !  =    null    ?    result    :    classfileBuffer ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.springframework.instrument.classloading.websphere.WebSphereClassPreDefinePlugin"}, {"methodBody": ["METHOD_START", "{", "return    \" org / springframework / jmx / applicationContext . xml \"  ;", "}", "METHOD_END"], "methodName": ["getApplicationContextPath"], "fileName": "org.springframework.jmx.AbstractJmxTests"}, {"methodBody": ["METHOD_START", "{", "return   this . ctx ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.springframework.jmx.AbstractJmxTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( message ,    getServer (  )  . isRegistered ( objectName )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsNotRegistered"], "fileName": "org.springframework.jmx.AbstractMBeanServerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( message ,    getServer (  )  . isRegistered ( objectName )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsRegistered"], "fileName": "org.springframework.jmx.AbstractMBeanServerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . server ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.springframework.jmx.AbstractMBeanServerTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "new   XmlBeanDefinitionReader ( ctx )  . loadBeanDefinitions ( configLocation )  ;", "ctx . getDefaultListableBeanFactory (  )  . registerSingleton (  \" s \"  ,    this . s )  ;", "ctx . refresh (  )  ;", "return   ctx ;", "}", "METHOD_END"], "methodName": ["loadContext"], "fileName": "org.springframework.jmx.AbstractMBeanServerTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServerFactory . releaseMBeanServer ( getServer (  )  )  ;", "MBeanTestUtils . reses (  )  ;", "}", "METHOD_END"], "methodName": ["releaseServer"], "fileName": "org.springframework.jmx.AbstractMBeanServerTests"}, {"methodBody": ["METHOD_START", "{", "this . server    =    MBeanServerFactory . createMBeanServer (  )  ;", "try    {", "onSetUp (  )  ;", "}    catch    ( Exception   ex )     {", "releaseServer (  )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jmx.AbstractMBeanServerTests"}, {"methodBody": ["METHOD_START", "{", "exporter . afterPropertiesSet (  )  ;", "exporter . afterSletonsInstantiated (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.springframework.jmx.AbstractMBeanServerTests"}, {"methodBody": ["METHOD_START", "{", "releaseServer (  )  ;", "onTearDown (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.jmx.AbstractMBeanServerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . nickName ;", "}", "METHOD_END"], "methodName": ["getNickName"], "fileName": "org.springframework.jmx.JmxTestBean"}, {"methodBody": ["METHOD_START", "{", "return   isSuperman ;", "}", "METHOD_END"], "methodName": ["isSuperman"], "fileName": "org.springframework.jmx.JmxTestBean"}, {"methodBody": ["METHOD_START", "{", "this . nickName    =    nickName ;", "}", "METHOD_END"], "methodName": ["setNickName"], "fileName": "org.springframework.jmx.JmxTestBean"}, {"methodBody": ["METHOD_START", "{", "this . isSuperman    =    superman ;", "}", "METHOD_END"], "methodName": ["setSuperman"], "fileName": "org.springframework.jmx.JmxTestBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . connector )     !  =    null )     {", "try    {", "this . connector . close (  )  ;", "}    catch    ( IOException   ex )     {", ". logger . debug (  \" Could   not   close   JMX   connector \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.jmx.access.ConnectorDelegate"}, {"methodBody": ["METHOD_START", "{", "if    ( serviceUrl    !  =    null )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Connecting   to   remote   MBeanServer   at   URL    [  \"     +    serviceUrl )     +     \"  ]  \"  )  )  ;", "}", "try    {", "this . connector    =    JMXConnectorFactory . connect ( serviceUrl ,    environment )  ;", "return   this . connector . getMBeanServerConnection (  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   MBeanServerNotFoundException (  (  (  \" Could   not   connect   to   remote   MBeanServer    [  \"     +    serviceUrl )     +     \"  ]  \"  )  ,    ex )  ;", "}", "} else    {", ". logger . debug (  \" Attempting   to   locate   local   MBeanServer \"  )  ;", "return   JmxUtils . locateMBeanServer ( agentId )  ;", "}", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.jmx.access.ConnectorDelegate"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetType    =    targetClass . getComponentType (  )  ;", "Method   fromMethod    =    targetType . getMethod (  \" from \"  ,    array . getClass (  )  . getComponentType (  )  )  ;", "Object   resultArray    =    Array . newInstance ( targetType ,    array . length )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "Array . set ( resultArray ,    i ,    ReflectionUtils . invokeMethod ( fromMethod ,    null ,    array [ i ]  )  )  ;", "}", "return   resultArray ;", "}", "METHOD_END"], "methodName": ["convertDataArrayToTargetArray"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Method   fromMethod    =    elementType . getMethod (  \" from \"  ,    array . getClass (  )  . getComponentType (  )  )  ;", "Collection < Object >    resultColl    =    CollectionFactory . createCollection ( collectionType ,    Array . getLength ( array )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "resultColl . add ( ReflectionUtils . invokeMethod ( fromMethod ,    null ,    array [ i ]  )  )  ;", "}", "return   resultColl ;", "}", "METHOD_END"], "methodName": ["convertDataArrayToTargetCollection"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetClass    =    parameter . getParameterType (  )  ;", "try    {", "if    ( result    =  =    null )     {", "return   null ;", "}", "if    ( ClassUtils . isAssignableValue ( targetClass ,    result )  )     {", "return   result ;", "}", "if    ( result   instanceof   CompositeData )     {", "Method   fromMethod    =    targetClass . getMethod (  \" from \"  ,    CompositeData . class )  ;", "return   ReflectionUtils . invokeMethod ( fromMethod ,    null ,    result )  ;", "} else", "if    ( result   instanceof   CompositeData [  ]  )     {", "CompositeData [  ]    array    =     (  ( CompositeData [  ]  )     ( result )  )  ;", "if    ( targetClass . isArray (  )  )     {", "return   convertDataArrayToTargetArray ( array ,    targetClass )  ;", "} else", "if    ( isAssignableFrom ( targetClass )  )     {", "Class <  ?  >    elementType    =    core . ResolvableType . forMethodParameter ( parameter )  . asCollection (  )  . resolveGeneric (  )  ;", "if    ( elementType    !  =    null )     {", "return   convertDataArrayToTargetCollection ( array ,    targetClass ,    elementType )  ;", "}", "}", "} else", "if    ( result   instanceof   TabularData )     {", "Method   fromMethod    =    targetClass . getMethod (  \" from \"  ,    class )  ;", "return   ReflectionUtils . invokeMethod ( fromMethod ,    null ,    result )  ;", "} else", "if    ( result   instanceof   TabularData [  ]  )     {", "TabularData [  ]    array    =     (  ( TabularData [  ]  )     ( result )  )  ;", "if    ( targetClass . isArray (  )  )     {", "return   convertDataArrayToTargetArray ( array ,    targetClass )  ;", "} else", "if    ( isAssignableFrom ( targetClass )  )     {", "Class <  ?  >    elementType    =    core . ResolvableType . forMethodParameter ( parameter )  . asCollection (  )  . resolveGeneric (  )  ;", "if    ( elementType    !  =    null )     {", "return   convertDataArrayToTargetCollection ( array ,    targetClass ,    elementType )  ;", "}", "}", "}", "throw   new   InvocationFailureException (  (  (  (  (  \" Incompatible   result   value    [  \"     +    result )     +     \"  ]    for   target   type    [  \"  )     +     ( targetClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   InvocationFailureException (  (  (  (  (  \" Could   not   obtain    ' from ( CompositeData )  '     /     ' from ( TabularData )  '    method   on   target   type    [  \"     +     ( targetClass . getName (  )  )  )     +     \"  ]    for   conversion   of   MXBean   data   structure    [  \"  )     +    result )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convertResultValueIfNecessary"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    invocation . getMethod (  )  ;", "try    {", "Object   result ;", "if    (  ( this . invocationHandler )     !  =    null )     {", "result    =    this . invocationHandler . invoke ( invocation . getThis (  )  ,    method ,    invocation . getArguments (  )  )  ;", "} else    {", "PropertyDescriptor   pd    =    BeanUtils . findPropertyForMethod ( method )  ;", "if    ( pd    !  =    null )     {", "result    =    invokeAttribute ( pd ,    invocation )  ;", "} else    {", "result    =    invokeOperation ( method ,    invocation . getArguments (  )  )  ;", "}", "}", "return   convertResultValueIfNecessary ( result ,    new   MethodParameter ( method ,     (  -  1  )  )  )  ;", "}    catch    ( MBeanException   ex )     {", "throw   ex . getTargetException (  )  ;", "}    catch    ( RuntimeMBeanException   ex )     {", "throw   ex . getTargetException (  )  ;", "}    catch    ( RuntimeErrorException   ex )     {", "throw   ex . getTargetError (  )  ;", "}    catch    ( RuntimeOperationsException   ex )     {", "RuntimeException   rex    =    ex . getTargetException (  )  ;", "if    ( rex   instanceof   RuntimeMBeanException )     {", "throw    (  ( RuntimeMBeanException )     ( rex )  )  . getTargetException (  )  ;", "} else", "if    ( rex   instanceof   RuntimeErrorException )     {", "throw    (  ( RuntimeErrorException )     ( rex )  )  . getTargetError (  )  ;", "} else    {", "throw   rex ;", "}", "}    catch    ( OperationsException   ex )     {", "if    ( ReflectionUtils . declaresException ( method ,    ex . getClass (  )  )  )     {", "throw   ex ;", "} else    {", "throw   new   InvalidInvocationException ( ex . getMessage (  )  )  ;", "}", "}    catch    ( JMException   ex )     {", "if    ( ReflectionUtils . declaresException ( method ,    ex . getClass (  )  )  )     {", "throw   ex ;", "} else    {", "throw   new   InvocationFailureException (  \" JMX      failed \"  ,    ex )  ;", "}", "}    catch    ( IOException   ex )     {", "if    ( ReflectionUtils . declaresException ( method ,    ex . getClass (  )  )  )     {", "throw   ex ;", "} else    {", "throw   new   MBeanConnectFailureException (  \" I / O   failure   during   JMX    \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . environment ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . managementInterface ;", "}", "METHOD_END"], "methodName": ["getManagementInterface"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( this . refreshOnConnectFailure )     {", "St   msg    =     \" Could   not   connect   to   JMX   server    -    retrying \"  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . warn ( msg ,    ex )  ;", "} else", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn ( msg )  ;", "}", "prepare (  )  ;", "return   doInvoke ( invocation )  ;", "} else    {", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["handleConnectFailure"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . serverToUse )     !  =    null )  ,     \" No   MBeanServerConnection   available \"  )  ;", "String   attributeName    =    JmxUtils . getAttributeName ( pd ,    this . useStrictCasing )  ;", "MBeanAttributeInfo   inf    =    this . allowedAttributes . get ( attributeName )  ;", "if    ( inf    =  =    null )     {", "throw   new   InvalidInvocationException (  (  (  \" Attribute    '  \"     +     ( pd . getName (  )  )  )     +     \"  '    is   not   exposed   on   the   management   interface \"  )  )  ;", "}", "if    ( invocation . getMethod (  )  . equals ( pd . getReadMethod (  )  )  )     {", "if    ( inf . isReadable (  )  )     {", "return   this . serverToUse . getAttribute ( this . objectName ,    attributeName )  ;", "} else    {", "throw   new   InvalidInvocationException (  (  (  \" Attribute    '  \"     +    attributeName )     +     \"  '    is   not   readable \"  )  )  ;", "}", "} else", "if    ( invocation . getMethod (  )  . equals ( pd . getWriteMethod (  )  )  )     {", "if    ( inf . isWritable (  )  )     {", "this . serverToUse . setAttribute ( this . objectName ,    new   Attribute ( attributeName ,    invocation . getArguments (  )  [  0  ]  )  )  ;", "return   null ;", "} else    {", "throw   new   InvalidInvocationException (  (  (  \" Attribute    '  \"     +    attributeName )     +     \"  '    is   not   writable \"  )  )  ;", "}", "} else    {", "throw   new   IllegalStateException (  (  (  \" Method    [  \"     +     ( invocation . getMethod (  )  )  )     +     \"  ]    is   neither   a   bean   property   getter   nor   a   setter \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeAttribute"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . serverToUse )     !  =    null )  ,     \" No   MBeanServerConnection   available \"  )  ;", ". MethodCacheKey   key    =    new    . MethodCacheKey ( method . getName (  )  ,    method . getParameterTypes (  )  )  ;", "MBeanOperationInfo   info    =    this . allowedOperations . get ( key )  ;", "if    ( info    =  =    null )     {", "throw   new   InvalidInvocationException (  (  (  \" Operation    '  \"     +     ( method . getName (  )  )  )     +     \"  '    is   not   exposed   on   the   management   interface \"  )  )  ;", "}", "String [  ]    signature ;", "synchronized ( this . signatureCache )     {", "signature    =    this . signatureCache . get ( method )  ;", "if    ( signature    =  =    null )     {", "signature    =    JmxUtils . getMethodSignature ( method )  ;", "this . signatureCache . put ( method ,    signature )  ;", "}", "}", "return   this . serverToUse . invoke ( this . objectName ,    method . getName (  )  ,    args ,    signature )  ;", "}", "METHOD_END"], "methodName": ["invokeOperation"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . preparationMonitor )     {", "return    ( this . serverToUse )     !  =    null ;", "}", "}", "METHOD_END"], "methodName": ["isPrepared"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . preparationMonitor )     {", "if    (  ( this . server )     !  =    null )     {", "this . serverToUse    =    this . server ;", "} else    {", "this . serverToUse    =    null ;", "this . serverToUse    =    this . connector . connect ( this . serviceUrl ,    this . environment ,    this . agentId )  ;", "}", "this . invocationHandler    =    null ;", "if    ( this . useStrictCasing )     {", "Assert . state (  (  ( this . objectName )     !  =    null )  ,     \" No   ObjectName   set \"  )  ;", "this . invocationHandler    =    new   MBeanServerInvocationHandler ( this . serverToUse ,    this . objectName ,     (  (  ( this . managemface )     !  =    null )     &  &     ( JMX . isMXBeanInterface ( this . managemface )  )  )  )  ;", "} else    {", "retrieveMBeanInfo ( this . serverToUse )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "MBeanInfo   info    =    server . getMBeanInfo ( this . objectName )  ;", "MBeanAttributeInfo [  ]    attributeInfo    =    info . getAttributes (  )  ;", "this . allowedAttributes    =    new   HashMap <  >  ( attributeInfo . length )  ;", "for    ( MBeanAttributeInfo   infoEle    :    attributeInfo )     {", "this . allowedAttributes . put ( infoEle . getName (  )  ,    infoEle )  ;", "}", "MBeanOperationInfo [  ]    operationInfo    =    info . getOperations (  )  ;", "this . allowedOperations    =    new   HashMap <  >  ( operationInfo . length )  ;", "for    ( MBeanOperationInfo   infoEle    :    operationInfo )     {", "Class <  ?  >  [  ]    paramTypes    =    JmxUtils . parameterInfoToTypes ( infoEle . getSignature (  )  ,    this . beanClassLoader )  ;", "this . allowedOperations . put ( new    . MethodCacheKey ( infoEle . getName (  )  ,    paramTypes )  ,    infoEle )  ;", "}", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   MBeanInfoRetrievalException (  \" Unable   to   locate   class   specified   in   method   signature \"  ,    ex )  ;", "}    catch    ( IntrospectionException   ex )     {", "throw   new   MBeanInfoRetrievalException (  (  (  \" Unable   to   obtain   MBean   info   for   bean    [  \"     +     ( this . objectName )  )     +     \"  ]  \"  )  ,    ex )  ;", "}    catch    ( InstanceNotFoundException   ex )     {", "throw   new   MBeanInfoRetrievalException (  (  (  \" Unable   to   obtain   MBean   info   for   bean    [  \"     +     ( this . objectName )  )     +     \"  ]  :    it   is   likely   that   this   bean   was   unregistered   during   the   proxy   creation   process \"  )  ,    ex )  ;", "}    catch    ( ReflectionException   ex )     {", "throw   new   MBeanInfoRetrievalException (  (  (  \" Unable   to   read   MBean   info   for   bean    [     \"     +     ( this . objectName )  )     +     \"  ]  \"  )  ,    ex )  ;", "}    catch    ( IOException   ex )     {", "throw   new   MBeanInfoRetrievalException (  (  \" An   IOException   occurred   when   communicating   with   the    \"     +     (  \" MBeanServer .    It   is   likely   that   you   are   communicating   with   a   remote   MBeanServer .     \"     +     \" Check   the   inner   exception   for   exact   details .  \"  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["retrieveMBeanInfo"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . agentId    =    agentId ;", "}", "METHOD_END"], "methodName": ["setAgentId"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . connectOnStartup    =    connectOnStartup ;", "}", "METHOD_END"], "methodName": ["setConnectOnStartup"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . environment    =    environment ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . managementInterface    =    managementInterface ;", "}", "METHOD_END"], "methodName": ["setManagementInterface"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . objectName    =    ObjectNameManager . getInstance ( objectName )  ;", "}", "METHOD_END"], "methodName": ["setObjectName"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . refreshOnConnectFailure    =    refreshOnConnectFailure ;", "}", "METHOD_END"], "methodName": ["setRefreshOnConnectFailure"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . server    =    server ;", "}", "METHOD_END"], "methodName": ["setServer"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . serviceUrl    =    new   JMXServiceURL ( url )  ;", "}", "METHOD_END"], "methodName": ["setServiceUrl"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . useStrictCasing    =    useStrictCasing ;", "}", "METHOD_END"], "methodName": ["setUseStrictCasing"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "MBeanProxyFactoryBean   factory    =    new   MBeanProxyFactoryBean (  )  ;", "factory . setServer ( getServerConnection (  )  )  ;", "factory . setProxyInterface ( IJmxTestBean . class )  ;", "factory . setObjectName (  . OBJECT _ NAME )  ;", "factory . afterPropertiesSet (  )  ;", "return    (  ( IJmxTestBean )     ( factory . getObject (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   getServer (  )  ;", "}", "METHOD_END"], "methodName": ["getServerConnection"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy 1     =    getProxy (  )  ;", "IJmxTestBean   proxy 2     =    getProxy (  )  ;", "assertNotSame (  \" The   proxies   should   NOT   be   the   same \"  ,    proxy 1  ,    proxy 2  )  ;", "assertSame (  \" The   proxy   classes   should   be   the   same \"  ,    proxy 1  . getClass (  )  ,    proxy 2  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDifferentProxiesSameClass"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy 1     =    getProxy (  )  ;", "int   age    =    proxy 1  . getAge (  )  ;", "assertEquals (  \" The   age   should   be    1  0  0  \"  ,     1  0  0  ,    age )  ;", "}", "METHOD_END"], "methodName": ["testGetAttributeValue"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy    =    getProxy (  )  ;", "int   result    =    proxy . add (  1  ,     2  )  ;", "assertEquals (  \" The   operation   should   return    3  \"  ,     3  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testInvokeArgs"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy    =    getProxy (  )  ;", "long   result    =    proxy . myOperation (  )  ;", "assertEquals (  \" The   operation   should   return    1  \"  ,     1  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testInvokeNoArgs"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   bean    =    getProxy (  )  ;", "bean . dontExposeMe (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokeUnexposedMethodWithException"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy    =    getProxy (  )  ;", "assertTrue (  \" The   proxy   class   should   be   different   than   the   base   class \"  ,     (  ( proxy . getClass (  )  )     !  =     ( IJmxTestBean . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyClassIsDifferent"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy    =    getProxy (  )  ;", "proxy . setName (  \" Rob   Harrop \"  )  ;", "assertEquals (  \" The   name   of   the   bean   should   have   been   updated \"  ,     \" Rob   Harrop \"  ,    target . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeValue"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy    =    getProxy (  )  ;", "proxy . setName (  \" Juergen   Class \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeValueWithCheckedException"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy    =    getProxy (  )  ;", "proxy . setName (  \" Juergen   IO \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeValueWithIOException"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy    =    getProxy (  )  ;", "proxy . setName (  \" Juergen \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttributeValueWithRuntimeException"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "IJmxTestBean   proxy    =    getProxy (  )  ;", "proxy . setAge (  9  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testSetReadOnlyAttribute"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( runTests )  ;", "Assume . group ( JMXMP )  ;", "final   int   port    =    SocketUtils . findAvailableTcpPort (  )  ;", "JMXServiceURL   url    =    new   JMXServiceURL (  (  \" service : jmx : jmxmp :  /  / localhost :  \"     +    port )  )  ;", "JMXConnectorServer   connector    =    JMXConnectorServerFactory . newJMXConnectorServer ( url ,    null ,    getServer (  )  )  ;", "MBeanProxyFactoryBean   factory    =    new   MBeanProxyFactoryBean (  )  ;", "factory . setServiceUrl ( url . toString (  )  )  ;", "factory . setProxyInterface ( IJmxTestBean . class )  ;", "factory . setObjectName (  . OBJECT _ NAME )  ;", "factory . setConnectOnStartup ( false )  ;", "factory . setRefreshOnConnectFailure ( true )  ;", "factory . afterPropertiesSet (  )  ;", "IJmxTestBean   bean    =     (  ( IJmxTestBean )     ( factory . getObject (  )  )  )  ;", "try    {", "connector . start (  )  ;", "}    catch    ( BindException   ex )     {", "System . out . println (  (  (  (  \" Skipping   remainder   of   JMX   LazyConnectionToRemote   test   because   binding   to   local   port    [  \"     +    port )     +     \"  ]    failed :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "return ;", "}", "try    {", "assertEquals (  \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "assertEquals (  1  0  0  ,    bean . getAge (  )  )  ;", "}    finally    {", "connector . stop (  )  ;", "}", "try    {", "bean . getName (  )  ;", "}    catch    ( JmxException   ex )     {", "}", "connector    =    JMXConnectorServerFactory . newJMXConnectorServer ( url ,    null ,    getServer (  )  )  ;", "connector . start (  )  ;", "try    {", "assertEquals (  \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "assertEquals (  1  0  0  ,    bean . getAge (  )  )  ;", "}    finally    {", "connector . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTestLazyConnectionToRemote"], "fileName": "org.springframework.jmx.access.MBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . proxyInterface    =    proxyInterface ;", "}", "METHOD_END"], "methodName": ["setProxyInterface"], "fileName": "org.springframework.jmx.access.MBeanProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . environment ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.springframework.jmx.access.NotificationListenerRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . server )     =  =    null )     {", "this . server    =    this . connector . connect ( this . serviceUrl ,    this . environment ,    this . agentId )  ;", "}", "try    {", "this . actualObjectNames    =    getResolvedObjectNames (  )  ;", "if    (  ( this . actualObjectNames )     !  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Registering      for   MBeans    \"     +     ( Arrays . asList ( this . actualObjectNames )  )  )  )  ;", "}", "for    ( ObjectName   actualObjectName    :    this . actualObjectNames )     {", "this . server . add ( actualObjectName ,    get (  )  ,    getNotificationFilter (  )  ,    getHandback (  )  )  ;", "}", "}", "}    catch    ( IOException   ex )     {", "throw   new   MBeanServerNotFoundException (  (  (  \" Could   not   connect   to   remote   MBeanServer   at   URL    [  \"     +     ( this . serviceUrl )  )     +     \"  ]  \"  )  ,    ex )  ;", "}    catch    ( Exception   ex )     {", "throw   new   JmxException (  \" Unable   to   register    \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.jmx.access.NotificationListenerRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . agentId    =    agentId ;", "}", "METHOD_END"], "methodName": ["setAgentId"], "fileName": "org.springframework.jmx.access.NotificationListenerRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . environment    =    environment ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.springframework.jmx.access.NotificationListenerRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . server    =    server ;", "}", "METHOD_END"], "methodName": ["setServer"], "fileName": "org.springframework.jmx.access.NotificationListenerRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . serviceUrl    =    new   JMXServiceURL ( url )  ;", "}", "METHOD_END"], "methodName": ["setServiceUrl"], "fileName": "org.springframework.jmx.access.NotificationListenerRegistrar"}, {"methodBody": ["METHOD_START", "{", "return   new   JMXServiceURL ( RemoteMBeanClientInterceptorTests . SERVICE _ URL )  ;", "}", "METHOD_END"], "methodName": ["getServiceUrl"], "fileName": "org.springframework.jmx.access.RemoteMBeanClientInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Date   end    =    df . parse (  \"  2  0  0  4  /  1  1  /  1  3  \"  )  ;", "turn   end ;", "}", "METHOD_END"], "methodName": ["getEndDate"], "fileName": "org.springframework.jmx.export.CustomEditorConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Date   start    =    df . parse (  \"  2  0  0  4  /  1  0  /  1  2  \"  )  ;", "return   start ;", "}", "METHOD_END"], "methodName": ["getStartDate"], "fileName": "org.springframework.jmx.export.CustomEditorConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   oname    =    new   ObjectName (  \" bean : name = dateRange \"  )  ;", "Date   startJmx    =     (  ( Date )     ( getServer (  )  . getAttribute ( oname ,     \" StartDate \"  )  )  )  ;", "Date   endJmx    =     (  ( Date )     ( getServer (  )  . getAttribute ( oname ,     \" EndDate \"  )  )  )  ;", "assertEquals (  \" startDate    \"  ,    getStartDate (  )  ,    startJmx )  ;", "assertEquals (  \" endDate    \"  ,    getEndDate (  )  ,    endJmx )  ;", "}", "METHOD_END"], "methodName": ["testDatesInJmx"], "fileName": "org.springframework.jmx.export.CustomEditorConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DateRange   dr    =     (  ( DateRange )     ( getContext (  )  . getBean (  \" dateRange \"  )  )  )  ;", "assertEquals (  \" startDate    \"  ,    getStartDate (  )  ,    dr . getStartDate (  )  )  ;", "assertEquals (  \" endDate    \"  ,    getEndDate (  )  ,    dr . getEndDate (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetDates"], "fileName": "org.springframework.jmx.export.CustomEditorConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "return   endDate ;", "}", "METHOD_END"], "methodName": ["getEndDate"], "fileName": "org.springframework.jmx.export.DateRange"}, {"methodBody": ["METHOD_START", "{", "return   startDate ;", "}", "METHOD_END"], "methodName": ["getStartDate"], "fileName": "org.springframework.jmx.export.DateRange"}, {"methodBody": ["METHOD_START", "{", "this . endDate    =    endDate ;", "}", "METHOD_END"], "methodName": ["setEndDate"], "fileName": "org.springframework.jmx.export.DateRange"}, {"methodBody": ["METHOD_START", "{", "this . startDate    =    startDate ;", "}", "METHOD_END"], "methodName": ["setStartDate"], "fileName": "org.springframework.jmx.export.DateRange"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.jmx.export.ExceptionOnInitBean"}, {"methodBody": ["METHOD_START", "{", "this . exceptOnInit    =    exceptOnInit ;", "}", "METHOD_END"], "methodName": ["setExceptOnInit"], "fileName": "org.springframework.jmx.export.ExceptionOnInitBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.jmx.export.ExceptionOnInitBean"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jmx / export / lazyInit . xml \"  )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" testBean \"  )  )  ;", "assertFalse ( ctx . getBeanFactory (  )  . containsSingleton (  \" testBean 2  \"  )  )  ;", "try    {", "MBeanServer   server    =     (  ( MBeanServer )     ( ctx . getBean (  \" server \"  )  )  )  ;", "ObjectName   oname    =    ObjectNameManager . getInstance (  \" bean : name = testBean 2  \"  )  ;", "String   name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,     \" foo \"  ,    name )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeOnLazyInitBean"], "fileName": "org.springframework.jmx.export.LazyInitMBeanTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetClass    =    AopUtils . getTargetClass ( bean )  ;", "if    ( targetClass    !  =     ( bean . getClass (  )  )  )     {", "Class <  ?  >    ifc    =    JmxUtils . getMXBeanInterface ( targetClass )  ;", "if    ( ifc    !  =    null )     {", "if    (  !  ( ifc . isInstance ( bean )  )  )     {", "throw   new   NotCompliantception (  (  (  \" Managed   bean    [  \"     +    bean )     +     \"  ]    has   a   target   class   with   an   MXBean   interface   but   does   not   expose   it   in   the   proxy \"  )  )  ;", "}", "return   new   StandardMBean ( bean ,     (  ( Class < Object >  )     ( ifc )  )  ,    true )  ;", "} else    {", "ifc    =    JmxUtils . getMBeanInterface ( targetClass )  ;", "if    ( ifc    !  =    null )     {", "if    (  !  ( ifc . isInstance ( bean )  )  )     {", "throw   new   NotCompliantception (  (  (  \" Managed   bean    [  \"     +    bean )     +     \"  ]    has   a   target   class   with   an   MBean   interface   but   does   not   expose   it   in   the   proxy \"  )  )  ;", "}", "return   new   StandardMBean ( bean ,     (  ( Class < Object >  )     ( ifc )  )  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["adaptMBeanIfPossible"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( excludedBean ,     \" ExcludedBean   must   not   be   null \"  )  ;", "this . excludedBeans . add ( excludedBean )  ;", "}", "METHOD_END"], "methodName": ["addExcludedBean"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" No   BeanFactory   set \"  )  ;", "Set < String >    beanNames    =    new   LinkedHashSet ( this . beanFactory . getBeanDefinitionCount (  )  )  ;", "Collections . addAll ( beanNames ,    this . beanFactory . getBeanDefinitionNames (  )  )  ;", "if    (  ( this . beanFactory )    instanceof   ConfigurableBeanFactory )     {", "Collections . addAll ( beanNames ,     (  ( ConfigurableBeanFactory )     ( this . beanFactory )  )  . getSingletonNames (  )  )  ;", "}", "for    ( String   beanName    :    beanNames )     {", "if    (  (  !  ( isExcluded ( beanName )  )  )     &  &     (  !  ( isBeanDefinitionAbstract ( this . beanFactory ,    beanName )  )  )  )     {", "try    {", "Class <  ?  >    beanClass    =    this . beanFactory . getType ( beanName )  ;", "if    (  ( beanClass    !  =    null )     &  &     ( callback . include ( beanClass ,    beanName )  )  )     {", "boolean   lazyInit    =    isBeanDefinitionLazyInit ( this . beanFactory ,    beanName )  ;", "Object   beanInstance    =    null ;", "if    (  ! lazyInit )     {", "beanInstance    =    this . beanFactory . getBean ( beanName )  ;", "if    (  !  ( beanClass . isInstance ( beanInstance )  )  )     {", "continue ;", "}", "}", "if    (  (  (  !  ( ScopedProxyUtils . isScopedTarget ( beanName )  )  )     &  &     (  !  ( beans . containsValue ( beanName )  )  )  )     &  &     (  ( beanInstance    =  =    null )     |  |     (  !  ( CollectionUtils . containsInstance ( beans . values (  )  ,    beanInstance )  )  )  )  )     {", "beans . put ( beanName ,     ( beanInstance    !  =    null    ?    beanInstance    :    beanName )  )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" Bean   with   name    '  \"     +    beanName )     +     \"  '    has   been   autodetected   for   JMX   exposure \"  )  )  ;", "}", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Bean   with   name    '  \"     +    beanName )     +     \"  '    is   already   registered   for   JMX   exposure \"  )  )  ;", "}", "}", "}", "}    catch    ( CannotLoadBeanClassException   ex )     {", "if    ( this . allowEagerInit )     {", "throw   ex ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["autodetect"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "try    {", "ModelMBean   mbean    =    createModelMBean (  )  ;", "mbean . setModelMBeanInfo ( getMBeanInfo ( managedResource ,    beanKey )  )  ;", "mbean . setManagedResource ( managedResource ,     . MR _ TYPE _ OBJECT _ REFERENCE )  ;", "return   mbean ;", "}    catch    ( Throwable   ex )     {", "throw   new   MBeanExportException (  (  (  (  (  \" Could   not   create   ModelMBean   for   managed   resource    [  \"     +    managedResource )     +     \"  ]    with   key    '  \"  )     +    beanKey )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createAndConfigureMBean"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "return   this . exposeManagedResourceClassLoader    ?    new   SpringModelMBean (  )     :    new   RequiredModelMBean (  )  ;", "}", "METHOD_END"], "methodName": ["createModelMBean"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    this . assembler . getMBeanInfo ( managedBean ,    beanKey )  ;", "if    (  (  ( logger . isWarnEnabled (  )  )     &  &     ( ObjectUtils . isEmpty ( info . getAttributes (  )  )  )  )     &  &     ( ObjectUtils . isEmpty ( info . getOperations (  )  )  )  )     {", "logger . warn (  (  (  \" Bean   with   key    '  \"     +    beanKey )     +     \"  '    has   been   registered   as   an   MBean   but   has   no   exposed   attributes   or   operations \"  )  )  ;", "}", "return   info ;", "}", "METHOD_END"], "methodName": ["getMBeanInfo"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    ( bean   instanceof   SelfNaming )     {", "return    (  ( SelfNaming )     ( bean )  )  . getObjectName (  )  ;", "} else    {", "return   this . namingStrategy . getObjectName ( bean ,    beanKey )  ;", "}", "}", "METHOD_END"], "methodName": ["getObjectName"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    ( managedResource   instanceof   NotificationPublisherAware )     {", "(  ( NotificationPublisherAware )     ( managedResource )  )  . setNotificationPublisher ( new   ModelNotificationPublisher ( model ,    objectName ,    managedResource )  )  ;", "}", "}", "METHOD_END"], "methodName": ["injectNotificationPublisherIfNecessary"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( beanFactory   instanceof   ConfigurableListableBeanFactory )     &  &     ( beanFactory . containsBeanDefinition ( beanName )  )  )     &  &     (  (  ( ConfigurableListableBeanFactory )     ( beanFactory )  )  . getBeanDefinition ( beanName )  . isAbstract (  )  )  ;", "}", "METHOD_END"], "methodName": ["isBeanDefinitionAbstract"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( beanFactory   instanceof   ConfigurableListableBeanFactory )     &  &     ( beanFactory . containsBeanDefinition ( beanName )  )  )     &  &     (  (  ( ConfigurableListableBeanFactory )     ( beanFactory )  )  . getBeanDefinition ( beanName )  . isLazyInit (  )  )  ;", "}", "METHOD_END"], "methodName": ["isBeanDefinitionLazyInit"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . excludedBeans . contains ( beanName )  )     |  |     (  ( beanName . startsWith ( FACTORY _ BEAN _ PREFIX )  )     &  &     ( this . excludedBeans . contains ( beanName . substring ( FACTORY _ BEAN _ PREFIX . length (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isExcluded"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "return   JmxUtils . isMBean ( beanClass )  ;", "}", "METHOD_END"], "methodName": ["isMBean"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . listeners )     !  =    null )     {", "for    ( Listener   listener    :    this . listeners )     {", "listener . mbeanRegistered ( objectName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["notifyListenersOfRegistration"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . listeners )     !  =    null )     {", "for    ( Listener   listener    :    this . listeners )     {", "listener . mbeanUnregistered ( objectName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["notifyListenersOfUnregistration"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    getObjectName ( bean ,    beanKey )  ;", "Object   mbeanToExpose    =    null ;", "if    ( is ( bean . getClass (  )  )  )     {", "mbeanToExpose    =    bean ;", "} else    {", "Dynamic   adaptedBean    =    adaptIfPossible ( bean )  ;", "if    ( adaptedBean    !  =    null )     {", "mbeanToExpose    =    adaptedBean ;", "}", "}", "if    ( mbeanToExpose    !  =    null )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  (  \" Located       '  \"     +    beanKey )     +     \"  '  :    registering   with   JMX   server   as       [  \"  )     +    objectName )     +     \"  ]  \"  )  )  ;", "}", "doRegister ( mbeanToExpose ,    objectName )  ;", "} else    {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  (  \" Located   managed   bean    '  \"     +    beanKey )     +     \"  '  :    registering   with   JMX   server   as       [  \"  )     +    objectName )     +     \"  ]  \"  )  )  ;", "}", "Model   mbean    =    createAndConfigure ( bean ,    beanKey )  ;", "doRegister ( mbean ,    objectName )  ;", "injectNotificationPublisherIfNecessary ( bean ,    mbean ,    objectName )  ;", "}", "return   objectName ;", "}", "METHOD_END"], "methodName": ["registerBeanInstance"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( mapValue   instanceof   String )     {", "if    (  ( this . beanFactory )     =  =    null )     {", "throw   new   Exception (  \" Cannot   resolve   bean   names   if   not   running   in   a   BeanFactory \"  )  ;", "}", "String   beanName    =     (  ( String )     ( mapValue )  )  ;", "if    ( isBeanDefinitionLazyInit ( this . beanFactory ,    beanName )  )     {", "ObjectName   objectName    =    registerLazyInit ( beanName ,    beanKey )  ;", "replaceNotificationListenerBeanNameKeysIfNecessary ( beanName ,    objectName )  ;", "return   objectName ;", "} else    {", "Object   bean    =    this . beanFactory . getBean ( beanName )  ;", "ObjectName   objectName    =    registerBeanInstance ( bean ,    beanKey )  ;", "replaceNotificationListenerBeanNameKeysIfNecessary ( beanName ,    objectName )  ;", "return   objectName ;", "}", "} else    {", "if    (  ( this . beanFactory )     !  =    null )     {", "Map < String ,     ?  >    beansOfSameType    =    this . beanFactory . getBeansOfType ( mapValue . getClass (  )  ,    false ,    this . allowEagerInit )  ;", "for    ( Map . Entry < String ,     ?  >    entry    :    beansOfSameType . entrySet (  )  )     {", "if    (  ( entry . getValue (  )  )     =  =    mapValue )     {", "String   beanName    =    entry . getKey (  )  ;", "ObjectName   objectName    =    registerBeanInstance ( mapValue ,    beanKey )  ;", "replaceNotificationListenerBeanNameKeysIfNecessary ( beanName ,    objectName )  ;", "return   objectName ;", "}", "}", "}", "return   registerBeanInstance ( mapValue ,    beanKey )  ;", "}", "}    catch    ( Throwable   ex )     {", "throw   new   UnableToRegisterMBeanException (  (  (  (  (  \" Unable   to   register   MBean    [  \"     +    mapValue )     +     \"  ]    with   key    '  \"  )     +    beanKey )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["registerBeanNameOrInstance"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beans )     =  =    null )     {", "this . beans    =    new   HashMap <  >  (  )  ;", "if    (  ( this . autodetectMode )     =  =    null )     {", "this . autodetectMode    =     . AUTODETECT _ ALL ;", "}", "}", "int   mode    =     (  ( this . autodetectMode )     !  =    null )     ?    this . autodetectMode    :     . AUTODETECT _ NONE ;", "if    ( mode    !  =     (  . AUTODETECT _ NONE )  )     {", "if    (  ( this . beanFactory )     =  =    null )     {", "throw   new   MBeanExportException (  \" Cannot   autodetect   MBeans   if   not   running   in   a   BeanFactory \"  )  ;", "}", "if    (  ( mode    =  =     (  . AUTODETECT _ MBEAN )  )     |  |     ( mode    =  =     (  . AUTODETECT _ ALL )  )  )     {", "logger . debug (  \" Autodetecting   user - defined   JMX   MBeans \"  )  ;", "autodetect ( this . beans ,     (    beanClass ,    beanName )     -  >    isMBean ( beanClass )  )  ;", "}", "if    (  (  ( mode    =  =     (  . AUTODETECT _ ASSEMBLER )  )     |  |     ( mode    =  =     (  . AUTODETECT _ ALL )  )  )     &  &     (  ( this . assembler )    instanceof   AutodetectCapableMBeanInfoAssembler )  )     {", "autodetect ( this . beans ,     (  ( AutodetectCapableMBeanInfoAssembler )     ( this . assembler )  )  :  : includeBean )  ;", "}", "}", "if    (  !  ( this . beans . isEmpty (  )  )  )     {", "this . beans . forEach (  (    beanName ,    instance )     -  >    registerBeanNameOrInstance ( instance ,    beanName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerBeans"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" No   BeanFactory   set \"  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setProxyTargetClass ( true )  ;", "proxyFactory . setFrozen ( true )  ;", "if    ( isMBean ( this . beanFactory . getType ( beanName )  )  )     {", "LazyInitTargetSource   targetSource    =    new   LazyInitTargetSource (  )  ;", "targetSource . setTargetBeanName ( beanName )  ;", "targetSource . setBeanFactory ( this . beanFactory )  ;", "proxyFactory . setTargetSource ( targetSource )  ;", "Object   proxy    =    proxyFactory . getProxy ( this . beanClassLoader )  ;", "ObjectName   objectName    =    getObjectName ( proxy ,    beanKey )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Located   MBean    '  \"     +    beanKey )     +     \"  '  :    registering   with   JMX   server   as   lazy - init   MBean    [  \"  )     +    objectName )     +     \"  ]  \"  )  )  ;", "}", "doRegister ( proxy ,    objectName )  ;", "return   objectName ;", "} else    {", ". NotificationPublisherAwareLazyTargetSource   targetSource    =    new    . NotificationPublisherAwareLazyTargetSource (  )  ;", "targetSource . setTargetBeanName ( beanName )  ;", "targetSource . setBeanFactory ( this . beanFactory )  ;", "proxyFactory . setTargetSource ( targetSource )  ;", "Object   proxy    =    proxyFactory . getProxy ( this . beanClassLoader )  ;", "ObjectName   objectName    =    getObjectName ( proxy ,    beanKey )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Located   simple   bean    '  \"     +    beanKey )     +     \"  '  :    registering   with   JMX   server   as   lazy - init   MBean    [  \"  )     +    objectName )     +     \"  ]  \"  )  )  ;", "}", "ModelMBean   mbean    =    createAndConfigureMBean ( proxy ,    beanKey )  ;", "targetSource . setModelMBean ( mbean )  ;", "targetSource . setObjectName ( objectName )  ;", "doRegister ( mbean ,    objectName )  ;", "return   objectName ;", "}", "}", "METHOD_END"], "methodName": ["registerLazyInit"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . notificationListeners )     !  =    null )     {", "Assert . state (  (  ( this . server )     !  =    null )  ,     \" No   MBeanServer   available \"  )  ;", "for    ( NotificationListenerBean   bean    :    this . notificationListeners )     {", "try    {", "ObjectName [  ]    mappedObjectNames    =    bean . getResolvedObjectNames (  )  ;", "if    ( mappedObjectNames    =  =    null )     {", "mappedObjectNames    =    getRegisteredObjectNames (  )  ;", "}", "if    (  ( this . registeredNotificationListeners . put ( bean ,    mappedObjectNames )  )     =  =    null )     {", "for    ( ObjectName   mappedObjectName    :    mappedObjectNames )     {", "this . server . addNotificationListener ( mappedObjectName ,    bean . getNotificationListener (  )  ,    bean . getNotificationFilter (  )  ,    bean . getHandback (  )  )  ;", "}", "}", "}    catch    ( Throwable   ex )     {", "throw   new   Exception (  \" Unable   to   register   NotificationListener \"  ,    ex )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["registerNotificationListeners"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . notificationListeners )     !  =    null )     {", "for    ( NotificationListener   notificationListener    :    this . notificationListeners )     {", "notificationListener . replaceObjectName ( beanName ,    objectName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["replaceNotificationListenerBeanNameKeysIfNecessary"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . allowEagerInit    =    allowEagerInit ;", "}", "METHOD_END"], "methodName": ["setAllowEagerInit"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . assembler    =    assembler ;", "}", "METHOD_END"], "methodName": ["setAssembler"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . autodetectMode    =     ( autodetect )     ?    MBeanExporter . AUTODETECT _ ALL    :    MBeanExporter . AUTODETECT _ NONE ;", "}", "METHOD_END"], "methodName": ["setAutodetect"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( MBeanExporter . constants . getValues ( MBeanExporter . CONSTANT _ PREFIX _ AUTODETECT )  . contains ( autodetectMode )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   values   of   autodetect   constants   allowed \"  )  ;", "}", "this . autodetectMode    =    autodetectMode ;", "}", "METHOD_END"], "methodName": ["setAutodetectMode"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( constantName . startsWith ( MBeanExporter . CONSTANT _ PREFIX _ AUTODETECT )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   autodetect   constants   allowed \"  )  ;", "}", "this . autodetectMode    =     (  ( Integer )     ( MBeanExporter . constants . asNumber ( constantName )  )  )  ;", "}", "METHOD_END"], "methodName": ["setAutodetectModeName"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . beans    =    beans ;", "}", "METHOD_END"], "methodName": ["setBeans"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . ensureUniqueRuntimeObjectNames    =    ensureUniqueRuntimeObjectNames ;", "}", "METHOD_END"], "methodName": ["setEnsureUniqueRuntimeObjectNames"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . excludedBeans . clear (  )  ;", "Collections . addAll ( this . excludedBeans ,    excludedBeans )  ;", "}", "METHOD_END"], "methodName": ["setExcludedBeans"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . exposeManagedResourceClassLoader    =    exposeManagedResourceClassLoader ;", "}", "METHOD_END"], "methodName": ["setExposeManagedResourceClassLoader"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . listeners    =    listeners ;", "}", "METHOD_END"], "methodName": ["setListeners"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . namingStrategy    =    namingStrategy ;", "}", "METHOD_END"], "methodName": ["setNamingStrategy"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( listeners ,     \"  ' listeners '    must   not   be   null \"  )  ;", "List < NotificationListenerBean >    notificationListeners    =    new   ArrayList <  >  ( listeners . size (  )  )  ;", "listeners . forEach (  (    key ,    listener )     -  >     {", "NotificationListenerBean   bean    =    new   NotificationListenerBean ( listener )  ;", "if    (  ( key    !  =    null )     &  &     (  !  (  . WILDCARD . equals ( key )  )  )  )     {", "bean . setMappedObjectName ( key )  ;", "}", "notificationListeners . add ( bean )  ;", "}  )  ;", "this . notificationListeners    =    notificationListeners . toArray ( new   NotificationListenerBean [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["setNotificationListenerMappings"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "this . notificationListeners    =    notificationListeners ;", "}", "METHOD_END"], "methodName": ["setNotificationListeners"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . server )     !  =    null )     {", "this . registeredNotificationListeners . forEach (  (    bean ,    mappedObjectNs )     -  >     {", "for    ( ObjectN   mappedObjectN    :    mappedObjectNs )     {", "try    {", "this . server . removeNotificationListener ( mappedObjectN ,    bean . getNotificationListener (  )  ,    bean . getNotificationFilter (  )  ,    bean . getHandback (  )  )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" Unable   to   unregister   NotificationListener \"  ,    ex )  ;", "}", "}", "}", "}  )  ;", "}", "this . registeredNotificationListeners . clear (  )  ;", "}", "METHOD_END"], "methodName": ["unregisterNotificationListeners"], "fileName": "org.springframework.jmx.export.MBeanExporter"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Domain   is   incorrect \"  ,    objectNameTemplate . getDomain (  )  ,    registeredName . getDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertObjectNameMatchesTemplate"], "fileName": "org.springframework.jmx.export.MBeanExporterOperationsTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance (  \" spring : name = Foo \"  )  ;", "ModelMBeanInfo   info    =    new   ModelMBeanInfoSupport (  \" myClass \"  ,     \" myDescription \"  ,    null ,    null ,    null ,    null )  ;", "RequiredModelMBean   bean    =    new   RequiredModelMBean ( info )  ;", "exporter    =    new    (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . registerManagedResource ( bean ,    objectName )  ;", "MBeanInfo   infoFromServer    =    getServer (  )  . getMBeanInfo ( objectName )  ;", "assertEquals ( info ,    infoFromServer )  ;", "}", "METHOD_END"], "methodName": ["testRegisterExistingMBeanWithUserSuppliedObjectName"], "fileName": "org.springframework.jmx.export.MBeanExporterOperationsTests"}, {"methodBody": ["METHOD_START", "{", "final   ObjectName   objectNameTemplate    =    ObjectNameManager . getInstance (  \" spring : type = Test \"  )  ;", "exporter    =    new    (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setNamingStrategy ( new   ObjectNamingStrategy (  )     {", "@ Override", "public   ObjectName   getObjectName ( Object   managedBean ,    String   beanKey )     {", "return   objectNameTemplate ;", "}", "}  )  ;", "JmxTestBean   bean 1     =    new   JmxTestBean (  )  ;", "JmxTestBean   bean 2     =    new   JmxTestBean (  )  ;", "ObjectName   reg 1     =    exporter . registerManagedResource ( bean 1  )  ;", "ObjectName   reg 2     =    exporter . registerManagedResource ( bean 2  )  ;", "assertIsRegistered (  \" Bean    1    not   registered   with   MBeanServer \"  ,    reg 1  )  ;", "assertIsRegistered (  \" Bean    2    not   registered   with   MBeanServer \"  ,    reg 2  )  ;", "assertObjectNameMatchesTemplate ( objectNameTemplate ,    reg 1  )  ;", "assertObjectNameMatchesTemplate ( objectNameTemplate ,    reg 2  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterManagedResourceWithGeneratedObjectName"], "fileName": "org.springframework.jmx.export.MBeanExporterOperationsTests"}, {"methodBody": ["METHOD_START", "{", "final   ObjectName   objectNameTemplate    =    ObjectNameManager . getInstance (  \" spring : type = Test \"  )  ;", "exporter    =    new    (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setEnsureUniqueRuntimeObjectNames ( false )  ;", "exporter . setNamingStrategy ( new   ObjectNamingStrategy (  )     {", "@ Override", "public   ObjectName   getObjectName ( Object   managedBean ,    String   beanKey )     {", "return   objectNameTemplate ;", "}", "}  )  ;", "JmxTestBean   bean 1     =    new   JmxTestBean (  )  ;", "JmxTestBean   bean 2     =    new   JmxTestBean (  )  ;", "ObjectName   reg 1     =    exporter . registerManagedResource ( bean 1  )  ;", "assertIsRegistered (  \" Bean    1    not   registered   with   MBeanServer \"  ,    reg 1  )  ;", "try    {", "exporter . registerManagedResource ( bean 2  )  ;", "fail (  \" Shouldn ' t   be   able   to   register   a   runtime   MBean   with   a   reused   ObjectName .  \"  )  ;", "}    catch    ( MBeanExportException   e )     {", "assertEquals (  \" Incorrect   root   cause \"  ,    InstanceAlreadyExistsException . class ,    e . getCause (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRegisterManagedResourceWithGeneratedObjectNameWithoutUniqueness"], "fileName": "org.springframework.jmx.export.MBeanExporterOperationsTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance (  \" spring : name = Foo \"  )  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "bean . setName (  \" Rob   Harrop \"  )  ;", "exporter    =    new    (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . registerManagedResource ( bean ,    objectName )  ;", "String   name    =     (  ( String )     ( getServer (  )  . getAttribute ( objectName ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Incorrect   name   on   MBean \"  ,    name ,    bean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterManagedResourceWithUserSuppliedObjectName"], "fileName": "org.springframework.jmx.export.MBeanExporterOperationsTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   desired    =    ObjectNameManager . getInstance ( MBeanExporterTests . OBJECT _ NAME )  ;", "assertEquals (  \" Incorrect   number   of   registrations \"  ,     1  ,    listener . getRegistered (  )  . size (  )  )  ;", "assertEquals (  \" Incorrect   number   of   unregistrations \"  ,     1  ,    listener . getUnregistered (  )  . size (  )  )  ;", "assertEquals (  \" Incorrect   ObjectName   in   register \"  ,    desired ,    listener . getRegistered (  )  . get (  0  )  )  ;", "assertEquals (  \" Incorrect   ObjectName   in   unregister \"  ,    desired ,    listener . getUnregistered (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertListener"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  . OBJECT _ NAME ,    new   JmxTestBean (  )  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["getBeanMap"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathXmlApplicationContext ( context ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    load (  \" autodetectLazyMBeans . xml \"  )  ;", "try    {", "ctx . getBean (  \" e \"  )  ;", "MBeanServer   server    =    ctx . getBean (  \" server \"  ,    MBeanServer . class )  ;", "ObjectName   oname    =    ObjectNameManager . getInstance (  \" spring : mbean = true \"  )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "String   name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,     \" Rob   Harrop \"  ,    name )  ;", "oname    =    ObjectNameManager . getInstance (  \" spring : mbean = another \"  )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,     \" Juergen   Hoeller \"  ,    name )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutodetectLazyMBeans"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    load (  \" autodetectMBeans . xml \"  )  ;", "try    {", "ctx . getBean (  \" e \"  )  ;", "MBeanServer   server    =    ctx . getBean (  \" server \"  ,    MBeanServer . class )  ;", "ObjectInstance   instance    =    server . getObjectInstance ( ObjectNameManager . getInstance (  \" spring : mbean = true \"  )  )  ;", "assertNotNull ( instance )  ;", "instance    =    server . getObjectInstance ( ObjectNameManager . getInstance (  \" spring : mbean 2  = true \"  )  )  ;", "assertNotNull ( instance )  ;", "instance    =    server . getObjectInstance ( ObjectNameManager . getInstance (  \" spring : mbean 3  = true \"  )  )  ;", "assertNotNull ( instance )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutodetectMBeans"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    load (  \" autodetectNoMBeans . xml \"  )  ;", "try    {", "ctx . getBean (  \" e \"  )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutodetectNoMBeans"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    load (  \" autodetectMBeans . xml \"  )  ;", "try    {", "ctx . getBean (  \" e \"  )  ;", "MBeanServer   server    =    ctx . getBean (  \" server \"  ,    MBeanServer . class )  ;", "ObjectInstance   instance    =    server . getObjectInstance ( ObjectNameManager . getInstance (  \" spring : mbean = true \"  )  )  ;", "assertNotNull ( instance )  ;", "thrown . expect ( InstanceNotFoundException . class )  ;", "server . getObjectInstance ( ObjectNameManager . getInstance (  \" spring : mbean = false \"  )  )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutodetectWithExclude"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" charlesDexterWard \"  ;", "BeanDefinitionBuilder   testBean    =    BeanDefinitionBuilder . rootBeanDefinition ( JmxTestBean . class )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition ( beanName ,    testBean . getBeanDefinition (  )  )  ;", "factory . preInstantiateSingletons (  )  ;", "Object   testBeanInstance    =    factory . getBean ( beanName )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "Map < String ,    Object >    beansToExport    =    new   HashMap <  >  (  )  ;", "beansToExport . put (  \" test : what = ever \"  ,    testBeanInstance )  ;", "exporter . setBeans ( beansToExport )  ;", "exporter . setBeanFactory ( factory )  ;", ". StubNotificationListener   listener    =    new    . StubNotificationListener (  )  ;", "exporter . setNotificationListenerMappings ( Collections . singletonMap ( beanName ,    listener )  )  ;", "start ( exporter )  ;", "}", "METHOD_END"], "methodName": ["testBeanNameCanBeUsedInNotificationListenersMap"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( MBeanExporterTests . Person . class )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition ( MBeanExporterTests . OBJECT _ NAME ,    builder . getBeanDefinition (  )  )  ;", "String   exportedBeanName    =     \" spring : type = TestBean \"  ;", "factory . registerSingleton ( exportedBeanName ,    new   TestBean (  )  )  ;", "String   notToBeExportedBeanName    =     \" spring : type = NotToBeExported \"  ;", "factory . registerSingleton ( notToBeExportedBeanName ,    new   TestBean (  )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setAssembler ( new   MBeanExporterTests . NamedBeanAutodetectCapableMBeanInfoAssemblerStub ( exportedBeanName )  )  ;", "exporter . setBeanFactory ( factory )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ ALL )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Bona   fide   MBean   not   autodetected   in    ( AUTODETECT _ ALL )    mode \"  ,    ObjectNameManager . getInstance ( MBeanExporterTests . OBJECT _ NAME )  )  ;", "assertIsRegistered (  \" Bean   not   autodetected   in    ( AUTODETECT _ ALL )    mode \"  ,    ObjectNameManager . getInstance ( exportedBeanName )  )  ;", "assertIsNotRegistered (  \" Bean   autodetected   and   did   not   satisfy   the   autodetect   info   assembler \"  ,    ObjectNameManager . getInstance ( notToBeExportedBeanName )  )  ;", "}", "METHOD_END"], "methodName": ["testBonaFideMBeanAndRegularBeanExporterWithAutodetectAll"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( MBeanExporterTests . Person . class )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition ( MBeanExporterTests . OBJECT _ NAME ,    builder . getBeanDefinition (  )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "Map < String ,    Object >    beansToExport    =    new   HashMap <  >  (  )  ;", "beansToExport . put ( MBeanExporterTests . OBJECT _ NAME ,    MBeanExporterTests . OBJECT _ NAME )  ;", "exporter . setBeans ( beansToExport )  ;", "exporter . setAssembler ( new   MBeanExporterTests . NamedBeanAutodetectCapableMBeanInfoAssemblerStub ( MBeanExporterTests . OBJECT _ NAME )  )  ;", "exporter . setBeanFactory ( factory )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ ASSEMBLER )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Explicitly   exported   bona   fide   MBean   obviously   not   exported .  \"  ,    ObjectNameManager . getInstance ( MBeanExporterTests . OBJECT _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testBonaFideMBeanExplicitlyExportedAndAutodetectionIsOn"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( MBeanExporterTests . Person . class )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition (  \"  ^  &  _ invalidObjectName _  (  *  \"  ,    builder . getBeanDefinition (  )  )  ;", "String   exportedBeanName    =     \" export . me . please \"  ;", "factory . registerSingleton ( exportedBeanName ,    new   TestBean (  )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "Map < String ,    Object >    beansToExport    =    new   HashMap <  >  (  )  ;", "beansToExport . put ( MBeanExporterTests . OBJECT _ NAME ,    exportedBeanName )  ;", "exporter . setBeans ( beansToExport )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setBeanFactory ( factory )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ NONE )  ;", "start ( exporter )  ;", "}", "METHOD_END"], "methodName": ["testBonaFideMBeanIsNotExportedWhenAutodetectIsTotallyTurnedOff"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( MBeanExporterTests . Person . class )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition ( MBeanExporterTests . OBJECT _ NAME ,    builder . getBeanDefinition (  )  )  ;", "String   exportedBeanName    =     \" spring : type = TestBean \"  ;", "factory . registerSingleton ( exportedBeanName ,    new   TestBean (  )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setAssembler ( new   MBeanExporterTests . NamedBeanAutodetectCapableMBeanInfoAssemblerStub ( exportedBeanName )  )  ;", "exporter . setBeanFactory ( factory )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ ASSEMBLER )  ;", "start ( exporter )  ;", "assertIsNotRegistered (  \" Bona   fide   MBean   was   autodetected   in   AUTODETECT _ ASSEMBLER   mode    -    must   not   have   been \"  ,    ObjectNameManager . getInstance ( MBeanExporterTests . OBJECT _ NAME )  )  ;", "assertIsRegistered (  \" Bean   not   autodetected   in   AUTODETECT _ ASSEMBLER   mode \"  ,    ObjectNameManager . getInstance ( exportedBeanName )  )  ;", "}", "METHOD_END"], "methodName": ["testBonaFideMBeanIsNotExportedWithAutodetectAssembler"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "bean . setName (  \" Rob   Harrop \"  )  ;", "ProxyFactory   factory    =    new   ProxyFactory (  )  ;", "factory . setTarget ( bean )  ;", "factory . addAdvice ( new   NopInterceptor (  )  )  ;", "factory . setInterfaces ( IJmxTestBean . class )  ;", "IJmxTestBean   proxy    =     (  ( IJmxTestBean )     ( factory . getProxy (  )  )  )  ;", "String   name    =     \" bean : mmm = whatever \"  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( name ,    proxy )  ;", "exporter    =    new    (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . registerBeans (  )  ;", "ObjectName   oname    =    ObjectName . getInstance ( name )  ;", "Object   nameValue    =    server . getAttribute ( oname ,     \" Name \"  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    nameValue )  ;", "}", "METHOD_END"], "methodName": ["testExportJdkProxy"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "String   firstBeanName    =     \" spring : type = TestBean \"  ;", "factory . registerSingleton ( firstBeanName ,    new   TestBean (  \" test \"  )  )  ;", "String   secondBeanName    =     \" spring : type = TestBean 2  \"  ;", "factory . registerSingleton ( secondBeanName ,    new   TestBean (  \" test 2  \"  )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setAssembler ( new    . NamedBeanAutodetectCapableMBeanInfoAssemblerStub ( firstBeanName ,    secondBeanName )  )  ;", "exporter . setBeanFactory ( factory )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ ALL )  ;", "exporter . addExcludedBean ( secondBeanName )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Bean   not   autodetected   in    ( AUTODETECT _ ALL )    mode \"  ,    ObjectNameManager . getInstance ( firstBeanName )  )  ;", "assertIsNotRegistered (  \" Bean   should   have   been   excluded \"  ,    ObjectNameManager . getInstance ( secondBeanName )  )  ;", "}", "METHOD_END"], "methodName": ["testIgnoreBeanName"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition (  \" spring : type = FactoryBean \"  ,    new   RootBeanDefinition (  . NullSomethingFactoryBean . class )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setBeanFactory ( factory )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ ALL )  ;", "start ( exporter )  ;", "assertIsNotRegistered (  \" Null   FactoryBean   object   not   registered \"  ,    ObjectNameManager . getInstance (  \" spring : type = FactoryBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testIgnoreNullObjectFromFactoryBean"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setBeans ( getBeanMap (  )  )  ;", "exporter . setServer ( this . server )  ;", ". MockMBeanExporterListener   listener    =    new    . MockMBeanExporterListener (  )  ;", "exporter . setListeners ( listener )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" The   bean   was   not   registered   with   the   MBeanServer \"  ,    ObjectNameManager . getInstance (  . OBJECT _ NAME )  )  ;", "this . server . unregisterMBean ( new   ObjectName (  . OBJECT _ NAME )  )  ;", "exporter . destroy (  )  ;", "assertEquals (  \" Listener   should   not   have   been   invoked    ( MBean   previously   unregistered   by   external   agent )  \"  ,     0  ,    listener . getUnregistered (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMBeanIsNotUnregisteredSpuriouslyIfSomeExternalProcessHasUnregisteredMBean"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder 1     =    BeanDefinitionBuilder . rootBeanDefinition ( MBeanExporterTests . Person . class )  ;", "BeanDefinitionBuilder   builder 2     =    BeanDefinitionBuilder . rootBeanDefinition ( MBeanExporterTests . RuntimeExceptionThrowingConstructorBean . class )  ;", "String   objectName 1     =     \" spring : test = bean 1  \"  ;", "String   objectName 2     =     \" spring : test = bean 2  \"  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition ( objectName 1  ,    builder 1  . getBeanDefinition (  )  )  ;", "factory . registerBeanDefinition ( objectName 2  ,    builder 2  . getBeanDefinition (  )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "Map < String ,    Object >    beansToExport    =    new   HashMap <  >  (  )  ;", "beansToExport . put ( objectName 1  ,    objectName 1  )  ;", "beansToExport . put ( objectName 2  ,    objectName 2  )  ;", "exporter . setBeans ( beansToExport )  ;", "exporter . setBeanFactory ( factory )  ;", "try    {", "start ( exporter )  ;", "fail (  \" Must   have   failed   during   creation   of   RuntimeExceptionThrowingConstructorBean \"  )  ;", "}    catch    ( RuntimeException   expected )     {", "}", "assertIsNotRegistered (  \" Must   have   unregistered   all   previously   registered   MBeans   due   to   RuntimeException \"  ,    ObjectNameManager . getInstance ( objectName 1  )  )  ;", "assertIsNotRegistered (  \" Must   have   never   registered   this   MBean   due   to   RuntimeException \"  ,    ObjectNameManager . getInstance ( objectName 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testMBeanIsUnregisteredForRuntimeExceptionDuringInitialization"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ ALL )  ;", "thrown . expect ( MBeanExportException . class )  ;", "start ( exporter )  ;", "}", "METHOD_END"], "methodName": ["testNotRunningInBeanFactoryAndAutodetectionIsOn"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put (  . OBJECT _ NAME ,     \" beanName \"  )  ;", "exporter . setBeans ( beans )  ;", "thrown . expect ( MBeanExportException . class )  ;", "start ( exporter )  ;", "}", "METHOD_END"], "methodName": ["testNotRunningInBeanFactoryAndPassedBeanNameToExport"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( MBeanExporterTests . Person . class )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition ( MBeanExporterTests . OBJECT _ NAME ,    builder . getBeanDefinition (  )  )  ;", "String   exportedBeanName    =     \" spring : type = TestBean \"  ;", "factory . registerSingleton ( exportedBeanName ,    new   TestBean (  )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setAssembler ( new   MBeanExporterTests . NamedBeanAutodetectCapableMBeanInfoAssemblerStub ( exportedBeanName )  )  ;", "exporter . setBeanFactory ( factory )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ MBEAN )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Bona   fide   MBean   not   autodetected   in   AUTODETECT _ MBEAN   mode \"  ,    ObjectNameManager . getInstance ( MBeanExporterTests . OBJECT _ NAME )  )  ;", "assertIsNotRegistered (  \" Bean   autodetected   and    ( only )    AUTODETECT _ MBEAN   mode   is   on \"  ,    ObjectNameManager . getInstance ( exportedBeanName )  )  ;", "}", "METHOD_END"], "methodName": ["testOnlyBonaFideMBeanIsExportedWhenAutodetectIsMBeanOnly"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition (  \" spring : type = FactoryBean \"  ,    new   RootBeanDefinition (  . ProperSomethingFactoryBean . class )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setBeanFactory ( factory )  ;", "exporter . setAutodetectMode ( MBeanExporter . AUTODETECT _ ALL )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Non - null   FactoryBean   object   registered \"  ,    ObjectNameManager . getInstance (  \" spring : type = FactoryBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterFactoryBean"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance ( MBeanExporterTests . OBJECT _ NAME )  ;", "MBeanExporterTests . Person   preRegistered    =    new   MBeanExporterTests . Person (  )  ;", "preRegistered . setName (  \" Rob   Harrop \"  )  ;", "server . registerMBean ( preRegistered ,    objectName )  ;", "MBeanExporterTests . Person   springRegistered    =    new   MBeanExporterTests . Person (  )  ;", "springRegistered . setName (  \" Sally   Greenwood \"  )  ;", "String   objectName 2     =     \" spring : test = equalBean \"  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . toString (  )  ,    springRegistered )  ;", "beans . put ( objectName 2  ,    springRegistered )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setRegistrationPolicy ( RegistrationPolicy . IGNORE _ EXISTING )  ;", "start ( exporter )  ;", "ObjectInstance   instance    =    server . getObjectInstance ( objectName )  ;", "assertNotNull ( instance )  ;", "ObjectInstance   instance 2     =    server . getObjectInstance ( new   ObjectName ( objectName 2  )  )  ;", "assertNotNull ( instance 2  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    server . getAttribute ( objectName ,     \" Name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterIgnoreExisting"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    NotificationListener >    listeners    =    new   HashMap <  >  (  )  ;", "NotificationListener   dummyListener    =    new   NotificationListener (  )     {", "@ Override", "public   void   handleNotification ( Notification   notification ,    Object   handback )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "listeners . put (  \" spring : type = Test \"  ,    dummyListener )  ;", "exporter    =    new    (  )  ;", "exporter . setBeans ( getBeanMap (  )  )  ;", "exporter . setServer ( server )  ;", "exporter . setNotificationListenerMappings ( listeners )  ;", "try    {", "start ( exporter )  ;", "fail (  (  \" Must   have   thrown   an   MBeanExportException   when   registering   a    \"     +     \" NotificationListener   on   a   non - existent   MBean .  \"  )  )  ;", "}    catch    ( MBeanExportException   expected )     {", "assertTrue ( expected . contains ( InstanceNotFoundException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerForNonExistentMBean"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    NotificationListener >    listeners    =    new   HashMap <  >  (  )  ;", "listeners . put (  \"  *  \"  ,    null )  ;", "exporter    =    new    (  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "exporter . setNotificationListenerMappings ( listeners )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNullNotificationListenerType"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance ( MBeanExporterTests . OBJECT _ NAME )  ;", "MBeanExporterTests . Person   preRegistered    =    new   MBeanExporterTests . Person (  )  ;", "preRegistered . setName (  \" Rob   Harrop \"  )  ;", "server . registerMBean ( preRegistered ,    objectName )  ;", "MBeanExporterTests . Person   springRegistered    =    new   MBeanExporterTests . Person (  )  ;", "springRegistered . setName (  \" Sally   Greenwood \"  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . toString (  )  ,    springRegistered )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setRegistrationPolicy ( RegistrationPolicy . REPLACE _ EXISTING )  ;", "start ( exporter )  ;", "ObjectInstance   instance    =    server . getObjectInstance ( objectName )  ;", "assertNotNull ( instance )  ;", "assertEquals (  \" Sally   Greenwood \"  ,    server . getAttribute ( objectName ,     \" Name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterReplaceExisting"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance ( MBeanExporterTests . OBJECT _ NAME )  ;", "MBeanExporterTests . SelfNamingTestBean   testBean    =    new   MBeanExporterTests . SelfNamingTestBean (  )  ;", "testBean . setObjectName ( objectName )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put (  \" foo \"  ,    testBean )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "start ( exporter )  ;", "ObjectInstance   instance    =    server . getObjectInstance ( objectName )  ;", "assertNotNull ( instance )  ;", "}", "METHOD_END"], "methodName": ["testSelfNaming"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "exporter . setAutodetectModeName (  \" That   Hansel   is .  .  .     * sssooo *    hot   right   now !  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAutodetectModeNameToARubbishValue"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "exporter . setAutodetectModeName (  \"        \\ t \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAutodetectModeNameToAWhitespacedString"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "exporter . setAutodetectModeName (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAutodetectModeNameToAnEmptyString"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "exporter . setAutodetectMode (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAutodetectModeToOutOfRangeNegativeValue"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "exporter . setAutodetectMode (  5  )  ;", "}", "METHOD_END"], "methodName": ["testSetAutodetectModeToOutOfRangePositiveValue"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" spring : name = dynBean \"  ,    new   TestDynamicMBean (  )  )  ;", ". InvokeDetectAssembler   asm    =    new    . InvokeDetectAssembler (  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( map )  ;", "exporter . setAssembler ( asm )  ;", "try    {", "start ( exporter )  ;", "Object   name    =    server . getAttribute ( ObjectNameManager . getInstance (  \" spring : name = dynBean \"  )  ,     \" Name \"  )  ;", "assertEquals (  \" The   name   attribute   is   incorrect \"  ,     \" Rob   Harrop \"  ,    name )  ;", "assertFalse (  \" Assembler   should   not   have   been   invoked \"  ,    asm . invoked )  ;", "}    finally    {", "exporter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUserCreatedMBeanRegWithDynamicMBean"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" charlesDexterWard \"  ;", "BeanDefinitionBuilder   testBean    =    BeanDefinitionBuilder . rootBeanDefinition ( JmxTestBean . class )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition ( beanName ,    testBean . getBeanDefinition (  )  )  ;", "factory . preInstantiateSingletons (  )  ;", "Object   testBeanInstance    =    factory . getBean ( beanName )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "Map < String ,    Object >    beansToExport    =    new   HashMap <  >  (  )  ;", "beansToExport . put (  \" test : what = ever \"  ,    testBeanInstance )  ;", "exporter . setBeans ( beansToExport )  ;", "exporter . setBeanFactory ( factory )  ;", ". StubNotificationListener   listener    =    new    . StubNotificationListener (  )  ;", "exporter . setNotificationListenerMappings ( Collections . singletonMap (  \"  *  \"  ,    listener )  )  ;", "start ( exporter )  ;", "}", "METHOD_END"], "methodName": ["testWildcardCanBeUsedInNotificationListenersMap"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" Rob   Harrop \"  ;", "String   otherName    =     \" Juergen   Hoeller \"  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "bean . setName ( name )  ;", "ObjectName   objectName    =    ObjectNameManager . getInstance (  \" spring : type = Test \"  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . toString (  )  ,    bean )  ;", "exporter    =    new    (  )  ;", "exporter . setServer ( getServer (  )  )  ;", "exporter . setBeans ( beans )  ;", "exporter . setExposeManagedResourceClassLoader ( true )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Bean   instance   not   registered \"  ,    objectName )  ;", "Object   result    =    server . invoke ( objectName ,     \" add \"  ,    new   Object [  ]  {    new   Integer (  2  )  ,    new   Integer (  3  )     }  ,    new   String [  ]  {    int . class . getName (  )  ,    int . class . getName (  )     }  )  ;", "assertEquals (  \" Incorrect   result   return   from   add \"  ,    result ,    new   Integer (  5  )  )  ;", "assertEquals (  \" Incorrect   attribute   value \"  ,    name ,    server . getAttribute ( objectName ,     \" Name \"  )  )  ;", "server . setAttribute ( objectName ,    new   Attribute (  \" Name \"  ,    otherName )  )  ;", "assertEquals (  \" Incorrect   updated   name .  \"  ,    otherName ,    bean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithExposeClassLoader"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporterTests . MockMBeanExporterListener   listener 1     =    new   MBeanExporterTests . MockMBeanExporterListener (  )  ;", "MBeanExporterTests . MockMBeanExporterListener   listener 2     =    new   MBeanExporterTests . MockMBeanExporterListener (  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setBeans ( getBeanMap (  )  )  ;", "exporter . setServer ( server )  ;", "exporter . setListeners ( listener 1  ,    listener 2  )  ;", "start ( exporter )  ;", "exporter . destroy (  )  ;", "assertListener ( listener 1  )  ;", "assertListener ( listener 2  )  ;", "}", "METHOD_END"], "methodName": ["testWithMBeanExporterListeners"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setBeans ( getBeanMap (  )  )  ;", "exporter . setServer ( server )  ;", "try    {", "start ( exporter )  ;", "assertIsRegistered (  \" The   bean   was   not   registered   with   the   MBeanServer \"  ,    ObjectNameManager . getInstance (  . OBJECT _ NAME )  )  ;", "}    finally    {", "exporter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithSuppliedMBeanServer"], "fileName": "org.springframework.jmx.export.MBeanExporterTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . mappedObjectNames )     !  =    null )     &  &     ( this . mappedObjectNames . contains ( originalName )  )  )     {", "this . mappedObjectNames . remove ( originalName )  ;", "this . mappedObjectNames . add ( newName )  ;", "}", "}", "METHOD_END"], "methodName": ["replaceObjectName"], "fileName": "org.springframework.jmx.export.NotificationListenerBean"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   Bean (  )  . afterPropertiesSet (  )  ;", "fail (  \" Must   have   thrown   an   IllegalArgumentException    ( no      supplied )  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testCreationWithNoNotificationListenerSet"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . getCanonicalName (  )  ,    bean )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "start ( exporter )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "NotificationListenerRegistrar   registrar    =    new   NotificationListenerRegistrar (  )  ;", "registrar . setServer ( server )  ;", "registrar . setNotificationListener ( listener )  ;", "registrar . setMappedObjectName ( objectName )  ;", "registrar . afterPropertiesSet (  )  ;", "String   attributeName    =     \" Name \"  ;", "server . setAttribute ( objectName ,    new   Attribute ( attributeName ,     \" Rob   Harrop \"  )  )  ;", "assertEquals (  \" Listener   not   notified \"  ,     1  ,    listener . getCount ( attributeName )  )  ;", "registrar . destroy (  )  ;", "server . setAttribute ( objectName ,    new   Attribute ( attributeName ,     \" Rob   Harrop \"  )  )  ;", "assertEquals (  \" Listener   notified   after   destruction \"  ,     1  ,    listener . getCount ( attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["testNotificationListenerRegistrar"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", "ObjectName   objectName 2     =    ObjectName . getInstance (  \" spring : name = Test 2  \"  )  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "JmxTestBean   bean 2     =    new   JmxTestBean (  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . getCanonicalName (  )  ,    bean )  ;", "beans . put ( objectName 2  . getCanonicalName (  )  ,    bean 2  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "start ( exporter )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "NotificationListenerRegistrar   registrar    =    new   NotificationListenerRegistrar (  )  ;", "registrar . setServer ( server )  ;", "registrar . setNotificationListener ( listener )  ;", "registrar . setMappedObjectNames (  \" spring : name = Test \"  ,     \" spring : name = Test 2  \"  )  ;", "registrar . afterPropertiesSet (  )  ;", "String   attributeName    =     \" Name \"  ;", "server . setAttribute ( objectName ,    new   Attribute ( attributeName ,     \" Rob   Harrop \"  )  )  ;", "assertEquals (  \" Listener   not   notified \"  ,     1  ,    listener . getCount ( attributeName )  )  ;", "registrar . destroy (  )  ;", "server . setAttribute ( objectName ,    new   Attribute ( attributeName ,     \" Rob   Harrop \"  )  )  ;", "assertEquals (  \" Listener   notified   after   destruction \"  ,     1  ,    listener . getCount ( attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["testNotificationListenerRegistrarWithMultipleNames"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . getCanonicalName (  )  ,    bean )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "NotificationListenerBean   listenerBean    =    new   NotificationListenerBean (  )  ;", "listenerBean . setNotificationListener ( listener )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListeners ( new   NotificationListenerBean [  ]  {    listenerBean    }  )  ;", "start ( exporter )  ;", "String   attributeName    =     \" Name \"  ;", "server . setAttribute ( objectName ,    new   Attribute ( attributeName ,     \" Rob   Harrop \"  )  )  ;", "assertEquals (  \" Listener   not   notified \"  ,     1  ,    listener . getCount ( attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerForAllMBeans"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . getCanonicalName (  )  ,    bean )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "Map   notificationListeners    =    new   HashMap (  )  ;", "notificationListeners . put ( objectName ,    listener )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListenerMappings ( notificationListeners )  ;", "start ( exporter )  ;", "String   attributeName    =     \" Name \"  ;", "server . setAttribute ( objectName ,    new   Attribute ( attributeName ,     \" Rob   Harrop \"  )  )  ;", "assertEquals (  \" Listener   not   notified \"  ,     1  ,    listener . getCount ( attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerForMBean"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" testBean \"  ;", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", ". SelfNamingTestBean   testBean    =    new    . SelfNamingTestBean (  )  ;", "testBean . setObjectName ( objectName )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerSingleton ( beanName ,    testBean )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( beanName ,    testBean )  ;", "Map   listenerMappings    =    new   HashMap (  )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "listenerMappings . put ( beanName ,    listener )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListenerMappings ( listenerMappings )  ;", "exporter . setBeanFactory ( factory )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Should   have   registered   MBean \"  ,    objectName )  ;", "server . setAttribute ( objectName ,    new   Attribute (  \" Age \"  ,    new   Integer (  7  7  )  )  )  ;", "assertEquals (  \" Listener   not   notified \"  ,     1  ,    listener . getCount (  \" Age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerWithBeanNameAndBeanInstanceInBeansMap"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" testBean \"  ;", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", ". SelfNamingTestBean   testBean    =    new    . SelfNamingTestBean (  )  ;", "testBean . setObjectName ( objectName )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerSingleton ( beanName ,    testBean )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( beanName ,    beanName )  ;", "Map   listenerMappings    =    new   HashMap (  )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "listenerMappings . put ( beanName ,    listener )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListenerMappings ( listenerMappings )  ;", "exporter . setBeanFactory ( factory )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Should   have   registered   MBean \"  ,    objectName )  ;", "server . setAttribute ( objectName ,    new   Attribute (  \" Age \"  ,    new   Integer (  7  7  )  )  )  ;", "assertEquals (  \" Listener   not   notified \"  ,     1  ,    listener . getCount (  \" Age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerWithBeanNameAndBeanNameInBeansMap"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" testBean \"  ;", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", ". SelfNamingTestBean   testBean    =    new    . SelfNamingTestBean (  )  ;", "testBean . setObjectName ( objectName )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerSingleton ( beanName ,    testBean )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( beanName ,    testBean )  ;", "Map   listenerMappings    =    new   HashMap (  )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "listenerMappings . put ( beanName ,    listener )  ;", "listenerMappings . put ( objectName ,    listener )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListenerMappings ( listenerMappings )  ;", "exporter . setBeanFactory ( factory )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Should   have   registered   MBean \"  ,    objectName )  ;", "server . setAttribute ( objectName ,    new   Attribute (  \" Age \"  ,    new   Integer (  7  7  )  )  )  ;", "assertEquals (  \" Listener   should   have   been   notified   exactly   once \"  ,     1  ,    listener . getCount (  \" Age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerWithBeanNameBeforeObjectNameMappedToSameBeanInstance"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . getCanonicalName (  )  ,    bean )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "NotificationListenerBean   listenerBean    =    new   NotificationListenerBean (  )  ;", "listenerBean . setNotificationListener ( listener )  ;", "listenerBean . setNotificationFilter ( new   NotificationFilter (  )     {", "@ Override", "public   boolean   isNotificationEnabled ( Notification   notification )     {", "if    ( notification   instanceof   AttributeChangeNotification )     {", "AttributeChangeNotification   changeNotification    =     (  ( AttributeChangeNotification )     ( notification )  )  ;", "return    \" Name \"  . equals ( changeNotification . getAttributeName (  )  )  ;", "} else    {", "return   false ;", "}", "}", "}  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListeners ( new   NotificationListenerBean [  ]  {    listenerBean    }  )  ;", "start ( exporter )  ;", "String   nameAttribute    =     \" Name \"  ;", "String   ageAttribute    =     \" Age \"  ;", "server . setAttribute ( objectName ,    new   Attribute ( nameAttribute ,     \" Rob   Harrop \"  )  )  ;", "server . setAttribute ( objectName ,    new   Attribute ( ageAttribute ,    new   Integer (  9  0  )  )  )  ;", "assertEquals (  \" Listener   not   notified   for   Name \"  ,     1  ,    listener . getCount ( nameAttribute )  )  ;", "assertEquals (  \" Listener   incorrectly   notified   for   Age \"  ,     0  ,    listener . getCount ( ageAttribute )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerWithFilter"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "String   objectName    =     \" spring : name = Test \"  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName ,    bean )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "Object   handback    =    new   Object (  )  ;", "NotificationListenerBean   listenerBean    =    new   NotificationListenerBean (  )  ;", "listenerBean . setNotificationListener ( listener )  ;", "listenerBean . setMappedObjectName (  \" spring : name = Test \"  )  ;", "listenerBean . setHandback ( handback )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListeners ( new   NotificationListenerBean [  ]  {    listenerBean    }  )  ;", "start ( exporter )  ;", "String   attributeName    =     \" Name \"  ;", "server . setAttribute ( ObjectNameManager . getInstance (  \" spring : name = Test \"  )  ,    new   Attribute ( attributeName ,     \" Rob   Harrop \"  )  )  ;", "assertEquals (  \" Listener   not   notified \"  ,     1  ,    listener . getCount ( attributeName )  )  ;", "assertEquals (  \" Handback   object   not   transmitted   correctly \"  ,    handback ,    listener . getLastHandback ( attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerWithHandback"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" testBean \"  ;", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", ". SelfNamingTestBean   testBean    =    new    . SelfNamingTestBean (  )  ;", "testBean . setObjectName ( objectName )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerSingleton ( beanName ,    testBean )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( beanName ,    testBean )  ;", "Map   listenerMappings    =    new   HashMap (  )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "listenerMappings . put ( objectName ,    listener )  ;", "listenerMappings . put ( beanName ,    listener )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListenerMappings ( listenerMappings )  ;", "exporter . setBeanFactory ( factory )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Should   have   registered   MBean \"  ,    objectName )  ;", "server . setAttribute ( objectName ,    new   Attribute (  \" Age \"  ,    new   Integer (  7  7  )  )  )  ;", "assertEquals (  \" Listener   should   have   been   notified   exactly   once \"  ,     1  ,    listener . getCount (  \" Age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerWithObjectNameBeforeBeanNameMappedToSameBeanInstance"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName 1     =     \" testBean 1  \"  ;", "String   beanName 2     =     \" testBean 2  \"  ;", "ObjectName   objectName 1     =    ObjectName . getInstance (  \" spring : name = Test 1  \"  )  ;", "ObjectName   objectName 2     =    ObjectName . getInstance (  \" spring : name = Test 2  \"  )  ;", ". SelfNamingTestBean   testBean 1     =    new    . SelfNamingTestBean (  )  ;", "testBean 1  . setObjectName ( objectName 1  )  ;", ". SelfNamingTestBean   testBean 2     =    new    . SelfNamingTestBean (  )  ;", "testBean 2  . setObjectName ( objectName 2  )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerSingleton ( beanName 1  ,    testBean 1  )  ;", "factory . registerSingleton ( beanName 2  ,    testBean 2  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( beanName 1  ,    testBean 1  )  ;", "beans . put ( beanName 2  ,    testBean 2  )  ;", "Map   listenerMappings    =    new   HashMap (  )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "listenerMappings . put ( beanName 1  ,    listener )  ;", "listenerMappings . put ( beanName 2  ,    listener )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListenerMappings ( listenerMappings )  ;", "exporter . setBeanFactory ( factory )  ;", "start ( exporter )  ;", "assertIsRegistered (  \" Should   have   registered   MBean \"  ,    objectName 1  )  ;", "assertIsRegistered (  \" Should   have   registered   MBean \"  ,    objectName 2  )  ;", "server . setAttribute ( ObjectNameManager . getInstance ( objectName 1  )  ,    new   Attribute (  \" Age \"  ,    new   Integer (  7  7  )  )  )  ;", "assertEquals (  \" Listener   not   notified   for   testBean 1  \"  ,     1  ,    listener . getCount (  \" Age \"  )  )  ;", "server . setAttribute ( ObjectNameManager . getInstance ( objectName 2  )  ,    new   Attribute (  \" Age \"  ,    new   Integer (  3  3  )  )  )  ;", "assertEquals (  \" Listener   not   notified   for   testBean 2  \"  ,     2  ,    listener . getCount (  \" Age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerWithTwoBeanNamesMappedToDifferentBeanInstances"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectName . getInstance (  \" spring : name = Test \"  )  ;", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName . getCanonicalName (  )  ,    bean )  ;", ". CountingAttributeChangeNotificationListener   listener    =    new    . CountingAttributeChangeNotificationListener (  )  ;", "Map   notificationListeners    =    new   HashMap (  )  ;", "notificationListeners . put (  \"  *  \"  ,    listener )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setServer ( server )  ;", "exporter . setBeans ( beans )  ;", "exporter . setNotificationListenerMappings ( notificationListeners )  ;", "start ( exporter )  ;", "String   attributeName    =     \" Name \"  ;", "server . setAttribute ( objectName ,    new   Attribute ( attributeName ,     \" Rob   Harrop \"  )  )  ;", "assertEquals (  \" Listener   not   notified \"  ,     1  ,    listener . getCount ( attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterNotificationListenerWithWildcard"], "fileName": "org.springframework.jmx.export.NotificationListenerTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    loadContext (  \" org / springframework / jmx / export / notificationPublisherLazyTests . xml \"  )  ;", "assertFalse (  \" Should   not   have   instantiated   the   bean   yet \"  ,    ctx . getBeanFactory (  )  . containsSingleton (  \" publisher \"  )  )  ;", "server . getAttribute ( ObjectNameManager . getInstance (  \" spring : type = Publisher \"  )  ,     \" Name \"  )  ;", "this . server . addNotificationListener ( ObjectNameManager . getInstance (  \" spring : type = Publisher \"  )  ,    listener ,    null ,    null )  ;", ". MyNotificationPublisher   publisher    =     (  (  . MyNotificationPublisher )     ( ctx . getBean (  \" publisher \"  )  )  )  ;", "assertNotNull (  \" NotificationPublisher   should   not   be   null \"  ,    publisher . getNotificationPublisher (  )  )  ;", "publisher . sendNotification (  )  ;", "assertEquals (  \" Notification   not   sent \"  ,     1  ,    listener . count )  ;", "}", "METHOD_END"], "methodName": ["testLazyInit"], "fileName": "org.springframework.jmx.export.NotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    loadContext (  \" org / springframework / jmx / export / notificationPublisherTests . xml \"  )  ;", "this . server . addNotificationListener ( ObjectNameManager . getInstance (  \" spring : type = PublisherMBean \"  )  ,    listener ,    null ,    null )  ;", ". MyNotificationPublisherMBean   publisher    =     (  (  . MyNotificationPublisherMBean )     ( ctx . getBean (  \" publisherMBean \"  )  )  )  ;", "publisher . sendNotification (  )  ;", "assertEquals (  \" Notification   not   sent \"  ,     1  ,    listener . count )  ;", "}", "METHOD_END"], "methodName": ["testMBean"], "fileName": "org.springframework.jmx.export.NotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    loadContext (  \" org / springframework / jmx / export / notificationPublisherTests . xml \"  )  ;", "this . server . addNotificationListener ( ObjectNameManager . getInstance (  \" spring : type = Publisher \"  )  ,    listener ,    null ,    null )  ;", ". MyNotificationPublisher   publisher    =     (  (  . MyNotificationPublisher )     ( ctx . getBean (  \" publisher \"  )  )  )  ;", "assertNotNull (  \" NotificationPublisher   should   not   be   null \"  ,    publisher . getNotificationPublisher (  )  )  ;", "publisher . sendNotification (  )  ;", "assertEquals (  \" Notification   not   sent \"  ,     1  ,    listener . count )  ;", "}", "METHOD_END"], "methodName": ["testSimpleBean"], "fileName": "org.springframework.jmx.export.NotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    loadContext (  \" org / springframework / jmx / export / notificationPublisherTests . xml \"  )  ;", "MBeanExporter   exporter    =     (  ( MBeanExporter )     ( ctx . getBean (  \" exporter \"  )  )  )  ;", ". MyNotificationPublisher   publisher    =    new    . MyNotificationPublisher (  )  ;", "exporter . registerManagedResource ( publisher ,    ObjectNameManager . getInstance (  \" spring : type = Publisher 2  \"  )  )  ;", "this . server . addNotificationListener ( ObjectNameManager . getInstance (  \" spring : type = Publisher 2  \"  )  ,    listener ,    null ,    null )  ;", "assertNotNull (  \" NotificationPublisher   should   not   be   null \"  ,    publisher . getNotificationPublisher (  )  )  ;", "publisher . sendNotification (  )  ;", "assertEquals (  \" Notification   not   sent \"  ,     1  ,    listener . count )  ;", "}", "METHOD_END"], "methodName": ["testSimpleBeanRegisteredManually"], "fileName": "org.springframework.jmx.export.NotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   oname    =    new   ObjectName (  \" bean : name = proxyTestBean 1  \"  )  ;", "Object   name    =    getServer (  )  . getAttribute ( oname ,     \" Name \"  )  ;", "Integer   age    =     (  ( Integer )     ( getServer (  )  . getAttribute ( oname ,     \" Age \"  )  )  )  ;", "assertEquals (  \" Name   is   incorrect   in   JMX \"  ,     \" Rob   Harrop \"  ,    name )  ;", "assertEquals (  \" Age   is   incorrect   in   JMX \"  ,     1  0  0  ,    age . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertiesCorrectInJmx"], "fileName": "org.springframework.jmx.export.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "IJmxTestBean   bean    =     (  ( IJmxTestBean )     ( getContext (  )  . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" Name   is   incorrect \"  ,     \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "assertEquals (  \" Age   is   incorrect \"  ,     1  0  0  ,    bean . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertiesReplaced"], "fileName": "org.springframework.jmx.export.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( failOnInit )     {", "throw   new   IllegalArgumentException (  \" Fail   on   initialization \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setFailOnInit"], "fileName": "org.springframework.jmx.export.TestDynamicMBean"}, {"methodBody": ["METHOD_START", "{", "if    ( ann    =  =    null )     {", "return   null ;", "}", "T   bean    =    BeanUtils . instantiateClass ( beanClass )  ;", "BeanUtils . copyPropertiesToBean ( ann ,    bean )  ;", "return   bean ;", "}", "METHOD_END"], "methodName": ["copyPropertiesToBean"], "fileName": "org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"}, {"methodBody": ["METHOD_START", "{", "T [  ]    beans    =     (  ( T [  ]  )     ( Array . newInstance ( beanClass ,    anns . size (  )  )  )  )  ;", "int   i    =     0  ;", "for    ( Annotation   ann    :    anns )     {", "beans [  ( i +  +  )  ]     =     . copyPropertiesToBean ( ann ,    beanClass )  ;", "}", "return   beans ;", "}", "METHOD_END"], "methodName": ["copyPropertiesToBeanArray"], "fileName": "org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jmx / export / annotation / componentScan . xml \"  )  ;", "try    {", "MBeanServer   server    =     (  ( MBeanServer )     ( ctx . getBean (  \" server \"  )  )  )  ;", "ObjectName   oname    =    ObjectNameManager . getInstance (  \" bean : name = testBean 4  \"  )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "String   name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertNull ( name )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["componentScan"], "fileName": "org.springframework.jmx.export.annotation.AnnotationLazyInitMBeanTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" domain \"  ,     \" bean \"  )  ;", "ConfigurableApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" org /  / jmx / export / annotation / lazyAssembling . xml \"  )  ;", "try    {", "MBeanServer   server    =     (  ( MBeanServer )     ( ctx . getBean (  \" server \"  )  )  )  ;", "ObjectName   oname    =    ObjectNameManager . getInstance (  \" bean : name = testBean 4  \"  )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "String   name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,     \" TEST \"  ,    name )  ;", "oname    =    ObjectNameManager . getInstance (  \" bean : name = testBean 5  \"  )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,     \" FACTORY \"  ,    name )  ;", "oname    =    ObjectNameManager . getInstance (  \" spring : mbean = true \"  )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,     \" Rob   Harrop \"  ,    name )  ;", "oname    =    ObjectNameManager . getInstance (  \" spring : mbean = another \"  )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,     \" Juergen   Hoeller \"  ,    name )  ;", "}    finally    {", "System . clearProperty (  \" domain \"  )  ;", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["lazyAssembling"], "fileName": "org.springframework.jmx.export.annotation.AnnotationLazyInitMBeanTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jmx / export / annotation / lazyNaming . xml \"  )  ;", "try    {", "MBeanServer   server    =     (  ( MBeanServer )     ( ctx . getBean (  \" server \"  )  )  )  ;", "ObjectName   oname    =    ObjectNameManager . getInstance (  \" bean : name = testBean 4  \"  )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "String   name    =     (  ( String )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,     \" TEST \"  ,    name )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["lazyNaming"], "fileName": "org.springframework.jmx.export.annotation.AnnotationLazyInitMBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . metadataNamingStrategy . setDefaultDomain ( defaultDomain )  ;", "}", "METHOD_END"], "methodName": ["setDefaultDomain"], "fileName": "org.springframework.jmx.export.annotation.AnnotationMBeanExporter"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    inf . getAttribute (  \" Colour \"  )  ;", "assertTrue (  \" The   name   attribute   should   be   writable \"  ,    attr . isWritable (  )  )  ;", "assertTrue (  \" The   name   attribute   should   be   readable \"  ,    attr . isReadable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeFromInterface"], "fileName": "org.springframework.jmx.export.annotation.AnnotationMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanOperationInfo   op    =    inf . getOperation (  \" fromInterface \"  )  ;", "assertNotNull ( op )  ;", "}", "METHOD_END"], "methodName": ["testOperationFromInterface"], "fileName": "org.springframework.jmx.export.annotation.AnnotationMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanOperationInfo   op    =    inf . getOperation (  \" getExpensiveToCalculate \"  )  ;", "assertNotNull ( op )  ;", "}", "METHOD_END"], "methodName": ["testOperationOnGetter"], "fileName": "org.springframework.jmx.export.annotation.AnnotationMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "Object   bean    =    getContext (  )  . getBean (  \" testInterfaceBean \"  )  ;", "ModelMBeanInfo   inf    =    get (  )  . getMBeanInfo ( bean ,     \" bean : name = interfaceTestBean \"  )  ;", "assertNotNull ( inf )  ;", "assertEquals (  \" My   Managed   Bean \"  ,    inf . getDescription (  )  )  ;", "ModelMBeanOperationInfo   op    =    inf . getOperation (  \" foo \"  )  ;", "assertNotNull (  \" foo   operation   not   exposed \"  ,    op )  ;", "assertEquals (  \" invoke   foo \"  ,    op . getDescription (  )  )  ;", "assertNull (  \" doNotExpose   operation   should   not   be   exposed \"  ,    inf . getOperation (  \" doNotExpose \"  )  )  ;", "ModelMBeanAttributeInfo   attr    =    inf . getAttribute (  \" Bar \"  )  ;", "assertNotNull (  \" bar   attribute   not   exposed \"  ,    attr )  ;", "assertEquals (  \" Bar   description \"  ,    attr . getDescription (  )  )  ;", "ModelMBeanAttributeInfo   attr 2     =    inf . getAttribute (  \" CacheEntries \"  )  ;", "assertNotNull (  \" cacheEntries   attribute   not   exposed \"  ,    attr 2  )  ;", "assertEquals (  \" Metric   Type   should   be   COUNTER \"  ,     \" COUNTER \"  ,    attr 2  . getDescriptor (  )  . getFieldValue (  \" metricType \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegistrationOnInterface"], "fileName": "org.springframework.jmx.export.annotation.AnnotationMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "return    3  ;", "}", "METHOD_END"], "methodName": ["getCacheEntries"], "fileName": "org.springframework.jmx.export.annotation.AnnotationTestBean"}, {"methodBody": ["METHOD_START", "{", "return   this . nickName ;", "}", "METHOD_END"], "methodName": ["getNickName"], "fileName": "org.springframework.jmx.export.annotation.AnnotationTestBean"}, {"methodBody": ["METHOD_START", "{", "return    1  0  0 L ;", "}", "METHOD_END"], "methodName": ["getQueueSize"], "fileName": "org.springframework.jmx.export.annotation.AnnotationTestBean"}, {"methodBody": ["METHOD_START", "{", "return   isSuperman ;", "}", "METHOD_END"], "methodName": ["isSuperman"], "fileName": "org.springframework.jmx.export.annotation.AnnotationTestBean"}, {"methodBody": ["METHOD_START", "{", "this . nickName    =    nickName ;", "}", "METHOD_END"], "methodName": ["setNickName"], "fileName": "org.springframework.jmx.export.annotation.AnnotationTestBean"}, {"methodBody": ["METHOD_START", "{", "this . isSuperman    =    superman ;", "}", "METHOD_END"], "methodName": ["setSuperman"], "fileName": "org.springframework.jmx.export.annotation.AnnotationTestBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . ct    !  =    null )     {", "this . ctclose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeContext"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "this . ctx    =    new   AnnotationConfigApplicationContext ( config )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "load ( EnableMBeanExportConfigurationTests . ComponentScanConfiguration . class )  ;", "MBeanServer   server    =     (  ( MBeanServer )     ( this . ctx . getBean (  \" server \"  )  )  )  ;", "validateMBeanAttribute ( server ,     \" bean : name = testBean 4  \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testComponentScan"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" domain \"  ,     \" bean \"  )  ;", "load (  . LazyAssemblingConfiguration . class )  ;", "try    {", "MBeanServer   server    =     (  ( MBeanServer )     ( this . ctx . getBean (  \" server \"  )  )  )  ;", "validateMBeanAttribute ( server ,     \" bean : name = testBean 4  \"  ,     \" TEST \"  )  ;", "validateMBeanAttribute ( server ,     \" bean : name = testBean 5  \"  ,     \" FACTORY \"  )  ;", "validateMBeanAttribute ( server ,     \" spring : mbean = true \"  ,     \" Rob   Harrop \"  )  ;", "validateMBeanAttribute ( server ,     \" spring : mbean = another \"  ,     \" Juergen   Hoeller \"  )  ;", "}    finally    {", "System . clearProperty (  \" domain \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testLazyAssembling"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "load ( EnableMBeanExportConfigurationTests . LazyNamingConfiguration . class )  ;", "validateAnnotationTestBean (  )  ;", "}", "METHOD_END"], "methodName": ["testLazyNaming"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "load ( EnableMBeanExportConfigurationTests . ProxyConfiguration . class )  ;", "validateAnnotationTestBean (  )  ;", "}", "METHOD_END"], "methodName": ["testOnlyTargetClassIsExposed"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "load ( EnableMBeanExportConfigurationTests . PackagePrivateExtensionConfiguration . class )  ;", "validateAnnotationTestBean (  )  ;", "}", "METHOD_END"], "methodName": ["testPackagePrivateClassExtensionCanBeExposed"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( InvalidMetadataException . class )  ;", "this . thrown . expectMessage (  . PackagePrivateTestBean . class . getName (  )  )  ;", "this . thrown . expectMessage (  \" must   be   public \"  )  ;", "new   AnnotationConfigApplicationContext (  . PackagePrivateConfiguration . class )  ;", "}", "METHOD_END"], "methodName": ["testPackagePrivateExtensionCantBeExposed"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( InvalidMetadataException . class )  ;", "this . thrown . expectMessage (  . PackagePrivateAnnotationTestBean . class . getName (  )  )  ;", "this . thrown . expectMessage (  \" must   be   public \"  )  ;", "new   AnnotationConfigApplicationContext (  . PackagePrivateInterfaceImplementationConfiguration . class )  ;", "}", "METHOD_END"], "methodName": ["testPackagePrivateImplementationCantBeExposed"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MockEnvironment   env    =    new   MockEnvironment (  )  ;", "env . setProperty (  \" serverName \"  ,     \" server \"  )  ;", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . setEnvironment ( env )  ;", "context . register (  . PlaceholderBasedConfiguration . class )  ;", "context . refresh (  )  ;", "this . ctx    =    context ;", "validateAnnotationTestBean (  )  ;", "}", "METHOD_END"], "methodName": ["testPlaceholderBased"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServer   server    =     (  ( MBeanServer )     ( this . ctx . getBean (  \" server \"  )  )  )  ;", "validatAttribute ( server ,     \" bean : name = testBean 4  \"  ,     \" TEST \"  )  ;", "}", "METHOD_END"], "methodName": ["validateAnnotationTestBean"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   oname    =    ObjectNameManager . getInstance ( objectName )  ;", "assertNotNull ( server . getObjectInstance ( oname )  )  ;", "St   name    =     (  ( St )     ( server . getAttribute ( oname ,     \" Name \"  )  )  )  ;", "assertEquals (  \" Invalid   name   returned \"  ,    expected ,    name )  ;", "}", "METHOD_END"], "methodName": ["validateMBeanAttribute"], "fileName": "org.springframework.jmx.export.annotation.EnableMBeanExportConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" MXBean   annotation   not   detected   correctly \"  ,    JmxUtils . isMBean ( JmxUtilsAnnotationTests . FooX . class )  )  ;", "}", "METHOD_END"], "methodName": ["annotatedMXBean"], "fileName": "org.springframework.jmx.export.annotation.JmxUtilsAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" MXBean   annotation   not   detected   correctly \"  ,    JmxUtils . isMBean ( JmxUtilsAnnotationTests . FooNotX . class )  )  ;", "}", "METHOD_END"], "methodName": ["notMXBean"], "fileName": "org.springframework.jmx.export.annotation.JmxUtilsAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "CapableMBeanInfoAssembler   assembler    =    getAssembler (  )  ;", "assertTrue (  \" The   bean   should   be   included \"  ,    assembler . includeBean ( bean . getClass (  )  ,     \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["autodetect"], "fileName": "org.springframework.jmx.export.assembler.AbstractAutodetectTests"}, {"methodBody": ["METHOD_START", "{", "if    ( mapValue   instanceof   ManagedNotification )     {", "ManagedNotification   mn    =     (  ( ManagedNotification )     ( mapValue )  )  ;", "return   new   ModelNotificationInfo [  ]  {    JmxMetadataUtils . convertToModelNotificationInfo ( mn )     }  ;", "} else", "if    ( mapValue   instanceof   Collection )     {", "Collection <  ?  >    col    =     (  ( Collection <  ?  >  )     ( mapValue )  )  ;", "List < ModelNotificationInfo >    result    =    new   ArrayList <  >  (  )  ;", "for    ( Object   colValue    :    col )     {", "if    (  !  ( colValue   instanceof   ManagedNotification )  )     {", "throw   new   IllegalArgumentException (  \" Property    ' notificationInfoMappings '    only   accepts   ManagedNotifications   for   Map   values \"  )  ;", "}", "ManagedNotification   mn    =     (  ( ManagedNotification )     ( colValue )  )  ;", "result . add ( JmxMetadataUtils . convertToModelNotificationInfo ( mn )  )  ;", "}", "return   result . toArray ( new   ModelNotificationInfo [  0  ]  )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Property    ' notificationInfoMappings '    only   accepts   ManagedNotifications   for   Map   values \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["extractNotificationMetadata"], "fileName": "org.springframework.jmx.export.assembler.AbstractConfigurableMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "notificationInfoMappings . forEach (  (    beanKey ,    result )     -  >    this . notificationInfoMappings . put ( beanKey ,    extractNotificationMetadata ( result )  )  )  ;", "}", "METHOD_END"], "methodName": ["setNotificationInfoMappings"], "fileName": "org.springframework.jmx.export.assembler.AbstractConfigurableMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanNotificationInfo [  ]    infos    =    new   ModelMBeanNotificationInfo [ notificationInfos . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( notificationInfos . length )  ;    i +  +  )     {", "ManagedNotification   notificationInfo    =    notificationInfos [ i ]  ;", "infos [ i ]     =    JmxMetadataUtils . convertToModelMBeanNotificationInfo ( notificationInfo )  ;", "}", "this . notificationInfos    =    infos ;", "}", "METHOD_END"], "methodName": ["setNotificationInfos"], "fileName": "org.springframework.jmx.export.assembler.AbstractConfigurableMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "Object   bean    =    getContext (  )  . getBean (  \" testBean \"  )  ;", "return    (  ( IJmxBean )     ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "return   getServer (  )  . getMBeanInfo ( ObjectNameManager . getInstance ( getObjectName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMBeanInfo"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "IJmxTestBean   bean    =    getBean (  )  ;", "ModelMBeanInfo   info    =    get (  )  . getMBeanInfo ( bean ,    getObjectName (  )  )  ;", "return   info ;", "}", "METHOD_END"], "methodName": ["getMBeanInfoFromAssembler"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "return   getServer (  )  . getObjectInstance ( ObjectNameManager . getInstance ( getObjectName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getObjectInstance"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanOperationInfo   get    =    info . getOperation (  \" getName \"  )  ;", "assertNotNull (  \" get   operation   should   not   be   null \"  ,    get )  ;", "assertEquals (  \" get   operation   should   have   visibility   of   four \"  ,    get . getDescriptor (  )  . getFieldValue (  \" visibility \"  )  ,    new   Integer (  4  )  )  ;", "assertEquals (  \" get   operation   should   have   role    \\  \" getter \\  \"  \"  ,     \" getter \"  ,    get . getDescriptor (  )  . getFieldValue (  \" role \"  )  )  ;", "ModelMBeanOperationInfo   set    =    info . getOperation (  \" setName \"  )  ;", "assertNotNull (  \" set   operation   should   not   be   null \"  ,    set )  ;", "assertEquals (  \" set   operation   should   have   visibility   of   four \"  ,    set . getDescriptor (  )  . getFieldValue (  \" visibility \"  )  ,    new   Integer (  4  )  )  ;", "assertEquals (  \" set   operation   should   have   role    \\  \" setter \\  \"  \"  ,     \" setter \"  ,    set . getDescriptor (  )  . getFieldValue (  \" role \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeHasCorrespondingOperations"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute (  . NAME _ ATTRIBUTE )  ;", "Descriptor   desc    =    attr . getDescriptor (  )  ;", "assertNotNull (  \" getMethod   field   should   not   be   null \"  ,    desc . getFieldValue (  \" getMethod \"  )  )  ;", "assertNotNull (  \" setMethod   field   should   not   be   null \"  ,    desc . getFieldValue (  \" setMethod \"  )  )  ;", "assertEquals (  \" getMethod   field   has   incorrect   value \"  ,     \" getName \"  ,    desc . getFieldValue (  \" getMethod \"  )  )  ;", "assertEquals (  \" setMethod   field   has   incorrect   value \"  ,     \" setName \"  ,    desc . getFieldValue (  \" setMethod \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeInfoHasDescriptors"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "assertNotNull (  \" The   MBean   description   should   not   be   null \"  ,    info . getDescription (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDescriptionNotNull"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance ( getObjectName (  )  )  ;", "getBean (  )  . setName (  \" John   Smith \"  )  ;", "Object   val    =    getServer (  )  . getAttribute ( objectName ,     . NAME _ ATTRIBUTE )  ;", "assertEquals (  \" Incorrect   result \"  ,     \" John   Smith \"  ,    val )  ;", "}", "METHOD_END"], "methodName": ["testGetAttribute"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "MBeanAttributeInfo [  ]    inf    =    info . getAttributes (  )  ;", "assertEquals (  \" Invalid   number   of   Attributes   returned \"  ,    getExpectedAttributeCount (  )  ,    inf . length )  ;", "for    ( int   x    =     0  ;    x    <     ( inf . length )  ;    x +  +  )     {", "assertNotNull (  \" MBeanAttributeInfo   should   not   be   null \"  ,    inf [ x ]  )  ;", "assertNotNull (  \" Description   for   MBeanAttributeInfo   should   not   be   null \"  ,    inf [ x ]  . getDescription (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetMBeanAttributeInfo"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "assertNotNull (  \" MBeanInfo   should   not   be   null \"  ,    info )  ;", "}", "METHOD_END"], "methodName": ["testGetMBeanInfo"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "MBeanOperationInfo [  ]    inf    =    info . getOperations (  )  ;", "assertEquals (  \" Invalid   number   of   Operations   returned \"  ,    getExpectedOperationCount (  )  ,    inf . length )  ;", "for    ( int   x    =     0  ;    x    <     ( inf . length )  ;    x +  +  )     {", "assertNotNull (  \" MBeanOperationInfo   should   not   be   null \"  ,    inf [ x ]  )  ;", "assertNotNull (  \" Description   for   MBeanOperationInfo   should   not   be   null \"  ,    inf [ x ]  . getDescription (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetMBeanOperationInfo"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectInstance   instance    =    getObjectInstance (  )  ;", "rtNotNull (  \" Bean   should   not   be   null \"  ,    instance )  ;", "}", "METHOD_END"], "methodName": ["testMBeanRegistration"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =     (  ( ModelMBeanInfo )     ( getMBeanInfo (  )  )  )  ;", "MBeanNotificationInfo [  ]    notifications    =    info . getNotifications (  )  ;", "rtEquals (  \" Incorrect   number   of   notifications \"  ,     1  ,    notifications . length )  ;", "rtEquals (  \" Incorrect   notification   name \"  ,     \" My   Notification \"  ,    notifications [  0  ]  . getName (  )  )  ;", "String [  ]    notifTypes    =    notifications [  0  ]  . getNotifTypes (  )  ;", "rtEquals (  \" Incorrect   number   of   notification   types \"  ,     2  ,    notifTypes . length )  ;", "rtEquals (  \" Notification   type . foo   not   found \"  ,     \" type . foo \"  ,    notifTypes [  0  ]  )  ;", "rtEquals (  \" Notification   type . bar   not   found \"  ,     \" type . bar \"  ,    notifTypes [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testNotificationMetadata"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance ( getObjectName (  )  )  ;", "Object   result    =    getServer (  )  . invoke ( objectName ,     \" add \"  ,    new   Object [  ]  {    new   Integer (  2  0  )  ,    new   Integer (  3  0  )     }  ,    new   St [  ]  {     \" int \"  ,     \" int \"     }  )  ;", "assertEquals (  \" Incorrect   result \"  ,    new   Integer (  5  0  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testOperationInvocation"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "IJmxTestBean   bean    =    getBean (  )  ;", "assertNotNull ( bean )  ;", "MBeanInfo   inf    =    getMBeanInfo (  )  ;", "assertEquals (  \" Incorrect   number   of   attributes   registered \"  ,    getExpectedAttributeCount (  )  ,    inf . getAttributes (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testRegisterAttributes"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "IJmxTestBean   bean    =    getBean (  )  ;", "assertNotNull ( bean )  ;", "MBeanInfo   inf    =    getMBeanInfo (  )  ;", "assertEquals (  \" Incorrect   number   of   operations   registered \"  ,    getExpectedOperationCount (  )  ,    inf . getOperations (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testRegisterOperations"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance ( getObjectName (  )  )  ;", "getServer (  )  . setAttribute ( objectName ,    new   Attribute (  . NAME _ ATTRIBUTE ,     \" Rob   Harrop \"  )  )  ;", "IJmxTestBean   bean    =     (  ( IJmxTestBean )     ( getContext (  )  . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAttribute"], "fileName": "org.springframework.jmx.export.assembler.AbstractJmxAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "return   getTargetClass ( managedBean )  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.springframework.jmx.export.assembler.AbstractMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   JmxUtils . getClassToExpose ( beanClass )  ;", "}", "METHOD_END"], "methodName": ["getClassToExpose"], "fileName": "org.springframework.jmx.export.assembler.AbstractMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   JmxUtils . getClassToExpose ( managedBean )  ;", "}", "METHOD_END"], "methodName": ["getClassToExpose"], "fileName": "org.springframework.jmx.export.assembler.AbstractMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelMBeanConstructorInfo [  0  ]  ;", "}", "METHOD_END"], "methodName": ["getConstructorInfo"], "fileName": "org.springframework.jmx.export.assembler.AbstractMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "String   targetClassName    =    getTargetClass ( managedBean )  . getName (  )  ;", "if    ( AopUtils . isAopProxy ( managedBean )  )     {", "return    \" Proxy   for    \"     +    targetClassName ;", "}", "return   targetClassName ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.springframework.jmx.export.assembler.AbstractMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelMBeanNotificationInfo [  0  ]  ;", "}", "METHOD_END"], "methodName": ["getNotificationInfo"], "fileName": "org.springframework.jmx.export.assembler.AbstractMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   AopUtils . getTargetClass ( managedBean )  ;", "}", "METHOD_END"], "methodName": ["getTargetClass"], "fileName": "org.springframework.jmx.export.assembler.AbstractMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   new   JmxTestBean (  )  ;", "}", "METHOD_END"], "methodName": ["createJmxTestBean"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    inf . getAttribute ( AbstractJmx . NAME _ ATTRIBUTE )  ;", "assertEquals (  \" The   description   for   the   name   attribute   is   incorrect \"  ,     \" The   Name   Attribute \"  ,    attr . getDescription (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptionOnGetter"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    inf . getAttribute ( AbstractJmx . AGE _ ATTRIBUTE )  ;", "assertEquals (  \" The   description   for   the   age   attribute   is   incorrect \"  ,     \" The   Age   Attribute \"  ,    attr . getDescription (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptionOnSetter"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "Descriptor   desc    =    info . getAttribute ( AbstractJmx . NAME _ ATTRIBUTE )  . getDescriptor (  )  ;", "assertEquals (  \" Default   value   should   be   foo \"  ,     \" foo \"  ,    desc . getFieldValue (  \" default \"  )  )  ;", "assertEquals (  \" Currency   Time   Limit   should   be    2  0  \"  ,     \"  2  0  \"  ,    desc . getFieldValue (  \" currencyTimeLimit \"  )  )  ;", "assertEquals (  \" Persist   Policy   should   be   OnUpdate \"  ,     \" OnUpdate \"  ,    desc . getFieldValue (  \" persistPolicy \"  )  )  ;", "assertEquals (  \" Persist   Period   should   be    3  0  0  \"  ,     \"  3  0  0  \"  ,    desc . getFieldValue (  \" persistPeriod \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAttributeDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "assertEquals (  \" The   descriptions   are   not   the   same \"  ,     \" My   Managed   Bean \"  ,    info . getDescription (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDescription"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "Descriptor   desc    =    info . getMBeanDescriptor (  )  ;", "assertEquals (  \" Logging   should   be   set   to   true \"  ,     \" true \"  ,    desc . getFieldValue (  \" log \"  )  )  ;", "assertEquals (  \" Log   file   should   be   jmx . log \"  ,     \" jmx . log \"  ,    desc . getFieldValue (  \" logFile \"  )  )  ;", "assertEquals (  \" Currency   Time   Limit   should   be    1  5  \"  ,     \"  1  5  \"  ,    desc . getFieldValue (  \" currencyTimeLimit \"  )  )  ;", "assertEquals (  \" Persist   Policy   should   be   OnUpdate \"  ,     \" OnUpdate \"  ,    desc . getFieldValue (  \" persistPolicy \"  )  )  ;", "assertEquals (  \" Persist   Period   should   be    2  0  0  \"  ,     \"  2  0  0  \"  ,    desc . getFieldValue (  \" persistPeriod \"  )  )  ;", "assertEquals (  \" Persist   Location   should   be   foo \"  ,     \"  .  / foo \"  ,    desc . getFieldValue (  \" persistLocation \"  )  )  ;", "assertEquals (  \" Persist   Name   should   be   bar \"  ,     \" bar . jmx \"  ,    desc . getFieldValue (  \" persistName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testManagedResourceDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   metric    =    inf . getAttribute (  . QUEUE _ SIZE _ METRIC )  ;", "ModelMBeanOperationInfo   operation    =    inf . getOperation (  \" getQueueSize \"  )  ;", "assertEquals (  \" The   description   for   the   queue   size   metric   is   incorrect \"  ,     \" The   QueueSize   metric \"  ,    metric . getDescription (  )  )  ;", "assertEquals (  \" The   description   for   the   getter   operation   of   the   queue   size   metric   is   incorrect \"  ,     \" The   QueueSize   metric \"  ,    operation . getDescription (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMetricDescription"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "Descriptor   desc    =    info . getAttribute (  . QUEUE _ SIZE _ METRIC )  . getDescriptor (  )  ;", "assertEquals (  \" Currency   Time   Limit   should   be    2  0  \"  ,     \"  2  0  \"  ,    desc . getFieldValue (  \" currencyTimeLimit \"  )  )  ;", "assertEquals (  \" Persist   Policy   should   be   OnUpdate \"  ,     \" OnUpdate \"  ,    desc . getFieldValue (  \" persistPolicy \"  )  )  ;", "assertEquals (  \" Persist   Period   should   be    3  0  0  \"  ,     \"  3  0  0  \"  ,    desc . getFieldValue (  \" persistPeriod \"  )  )  ;", "assertEquals (  \" Unit   should   be   messages \"  ,     \" messages \"  ,    desc . getFieldValue (  \" units \"  )  )  ;", "assertEquals (  \" Display   Name   should   be   Queue   Size \"  ,     \" Queue   Size \"  ,    desc . getFieldValue (  \" displayName \"  )  )  ;", "assertEquals (  \" Metric   Type   should   be   COUNTER \"  ,     \" COUNTER \"  ,    desc . getFieldValue (  \" metricType \"  )  )  ;", "assertEquals (  \" Metric   Category   should   be   utilization \"  ,     \" utilization \"  ,    desc . getFieldValue (  \" metricCategory \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMetricDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "Descriptor   desc    =    info . getAttribute (  . CACHE _ ENTRIES _ METRIC )  . getDescriptor (  )  ;", "assertNull (  \" Currency   Time   Limit   should   not   be   populated \"  ,    desc . getFieldValue (  \" currencyTimeLimit \"  )  )  ;", "assertNull (  \" Persist   Policy   should   not   be   populated \"  ,    desc . getFieldValue (  \" persistPolicy \"  )  )  ;", "assertNull (  \" Persist   Period   should   not   be   populated \"  ,    desc . getFieldValue (  \" persistPeriod \"  )  )  ;", "assertNull (  \" Unit   should   not   be   populated \"  ,    desc . getFieldValue (  \" units \"  )  )  ;", "assertEquals (  \" Display   Name   should   be   populated   by   default   via   JMX \"  ,     . CACHE _ ENTRIES _ METRIC ,    desc . getFieldValue (  \" displayName \"  )  )  ;", "assertEquals (  \" Metric   Type   should   be   GAUGE \"  ,     \" GAUGE \"  ,    desc . getFieldValue (  \" metricType \"  )  )  ;", "assertNull (  \" Metric   Category   should   not   be   populated \"  ,    desc . getFieldValue (  \" metricCategory \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMetricDescriptorDefaults"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "Descriptor   desc    =    info . getOperation (  \" myOperation \"  )  . getDescriptor (  )  ;", "assertEquals (  \" Currency   Time   Limit   should   be    3  0  \"  ,     \"  3  0  \"  ,    desc . getFieldValue (  \" currencyTimeLimit \"  )  )  ;", "assertEquals (  \" Role   should   be    \\  \" operation \\  \"  \"  ,     \" operation \"  ,    desc . getFieldValue (  \" role \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testOperationDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanOperationInfo   oper    =    info . getOperation (  \" add \"  )  ;", "MBeanParameterInfo [  ]    params    =    oper . getSignature (  )  ;", "assertEquals (  \" Invalid   number   of   params \"  ,     2  ,    params . length )  ;", "assertEquals (  \" Incorrect   name   for   x   param \"  ,     \" x \"  ,    params [  0  ]  . getName (  )  )  ;", "assertEquals (  \" Incorrect   type   for   x   param \"  ,    int . class . getName (  )  ,    params [  0  ]  . getType (  )  )  ;", "assertEquals (  \" Incorrect   name   for   y   param \"  ,     \" y \"  ,    params [  1  ]  . getName (  )  )  ;", "assertEquals (  \" Incorrect   type   for   y   param \"  ,    int . class . getName (  )  ,    params [  1  ]  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOperationParameterMetadata"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    inf . getAttribute ( AbstractJmx . AGE _ ATTRIBUTE )  ;", "assertFalse (  \" The   age   attribute   should   not   be   writable \"  ,    attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReadOnlyAttribute"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    inf . getAttribute ( AbstractJmx . NAME _ ATTRIBUTE )  ;", "assertTrue (  \" The   name   attribute   should   be   writable \"  ,    attr . isWritable (  )  )  ;", "assertTrue (  \" The   name   attribute   should   be   readable \"  ,    attr . isReadable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReadWriteAttribute"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "IJmxTestBean   tb    =    createJmxTestBean (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTarget ( tb )  ;", "pf . addAdvice ( new   NopInterceptor (  )  )  ;", "Object   proxy    =    pf . getProxy (  )  ;", "MetadataMBeanInfoAssembler    =     (  ( MetadataMBeanInfoAssembler )     ( getAssembler (  )  )  )  ;", "MBeanExporter   exporter    =    new   MBeanExporter (  )  ;", "exporter . setBeanFactory ( getContext (  )  )  ;", "exporter . setAssembler (  ;", "String   objectName    =     \" spring : bean = test , proxy = true \"  ;", "Map < String ,    Object >    beans    =    new   HashMap <  >  (  )  ;", "beans . put ( objectName ,    proxy )  ;", "exporter . setBeans ( beans )  ;", "start ( exporter )  ;", "MBeanInfo   inf    =    getServer (  )  . getMBeanInfo ( ObjectNameManager . getInstance ( objectName )  )  ;", "assertEquals (  \" Incorrect   number   of   operations \"  ,    getExpectedOperationCount (  )  ,    inf . getOperations (  )  . length )  ;", "assertEquals (  \" Incorrect   number   of   attributes \"  ,    getExpectedAttributeCount (  )  ,    inf . getAttributes (  )  . length )  ;", "assertTrue (  \" Not   included   in   autodetection \"  ,    includeBean ( proxy . getClass (  )  ,     \" some   bean   name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithCglibProxy"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute (  \" Superman \"  )  ;", "assertNotNull (  \" Attribute   should   not   be   null \"  ,    attr )  ;", "}", "METHOD_END"], "methodName": ["testWithOnlyGetter"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    inf . getAttribute (  \" NickName \"  )  ;", "assertNotNull (  \" Attribute   should   not   be   null \"  ,    attr )  ;", "}", "METHOD_END"], "methodName": ["testWithOnlySetter"], "fileName": "org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( currencyTimeLimit    >     0  )     {", "desc . setField (  . FIELD _ CURRENCY _ TIME _ LIMIT ,    Integer . toString ( currencyTimeLimit )  )  ;", "} else", "if    ( currencyTimeLimit    =  =     0  )     {", "desc . setField (  . FIELD _ CURRENCY _ TIME _ LIMIT ,    Integer . toString ( Integer . MAX _ VALUE )  )  ;", "} else    {", "applyDefaultCurrencyTimeLimit ( desc )  ;", "}", "}", "METHOD_END"], "methodName": ["applyCurrencyTimeLimit"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getDefaultCurrencyTimeLimit (  )  )     !  =    null )     {", "desc . setField (  . FIELD _ CURRENCY _ TIME _ LIMIT ,    getDefaultCurrencyTimeLimit (  )  . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyDefaultCurrencyTimeLimit"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "MBeanParameterInfo [  ]    params    =    getOperationParameters ( method ,    beanKey )  ;", "if    (  ( params . length )     =  =     0  )     {", "return   new   ModelMBeanOperationInfo ( getOperationDescription ( method ,    beanKey )  ,    method )  ;", "} else    {", "return   new   ModelMBeanOperationInfo ( method . getName (  )  ,    getOperationDescription ( method ,    beanKey )  ,    getOperationParameters ( method ,    beanKey )  ,    method . getReturnType (  )  . getName (  )  ,    MBeanOperationInfo . UNKNOWN )  ;", "}", "}", "METHOD_END"], "methodName": ["createModelMBeanOperationInfo"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   propertyDescriptor . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeDescription"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "if    ( AopUtils . isJdkDynamicProxy ( managedBean )  )     {", "return   AopProxyUtils . proxiedUserInterfaces ( managedBean )  [  0  ]  ;", "}", "return   getClassToExpose ( managedBean )  ;", "}", "METHOD_END"], "methodName": ["getClassForDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultCurrencyTimeLimit ;", "}", "METHOD_END"], "methodName": ["getDefaultCurrencyTimeLimit"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   method . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getOperationDescription"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "ParameterNameDiscoverer   paramNameDiscoverer    =    getParameterNameDiscoverer (  )  ;", "String [  ]    paramNames    =     ( paramNameDiscoverer    !  =    null )     ?    paramNameDiscoverer . getParameterNames ( method )     :    null ;", "if    ( paramNames    =  =    null )     {", "return   new   ParameterInfo [  0  ]  ;", "}", "ParameterInfo [  ]    info    =    new   ParameterInfo [ paramNames . length ]  ;", "Class <  ?  >  [  ]    typeParameters    =    method . getParameterTypes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( info . length )  ;    i +  +  )     {", "info [ i ]     =    new   ParameterInfo ( paramNames [ i ]  ,    typeParameters [ i ]  . getName (  )  ,    paramNames [ i ]  )  ;", "}", "return   info ;", "}", "METHOD_END"], "methodName": ["getOperationParameters"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["getParameterNameDiscoverer"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   this . exposeClassDescriptor ;", "}", "METHOD_END"], "methodName": ["isExposeClassDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   this . useStrictCasing ;", "}", "METHOD_END"], "methodName": ["isUseStrictCasing"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "applyDefaultCurrencyTimeLimit ( desc )  ;", "}", "METHOD_END"], "methodName": ["populateAttributeDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "applyDefaultCurrencyTimeLimit ( desc )  ;", "}", "METHOD_END"], "methodName": ["populateOperationDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . defaultCurrencyTimeLimit    =    defaultCurrencyTimeLimit ;", "}", "METHOD_END"], "methodName": ["setDefaultCurrencyTimeLimit"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . exposeClassDescriptor    =    exposeClassDescriptor ;", "}", "METHOD_END"], "methodName": ["setExposeClassDescriptor"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameDiscoverer    =    parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["setParameterNameDiscoverer"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . useStrictCasing    =    useStrictCasing ;", "}", "METHOD_END"], "methodName": ["setUseStrictCasing"], "fileName": "org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    ifaces    =    null ;", "if    (  ( this . resolvedMappings )     !  =    null )     {", "ifaces    =    this . resolvedMappings . get ( beanKey )  ;", "}", "if    ( ifaces    =  =    null )     {", "ifaces    =    this . manageds ;", "if    ( ifaces    =  =    null )     {", "ifaces    =    ClassUtils . getAllsForClass ( method . getDeclaringClass (  )  )  ;", "}", "}", "for    ( Class <  ?  >    ifc    :    ifaces )     {", "for    ( Method   ifcMethod    :    ifc . getMethods (  )  )     {", "if    (  ( ifcMethod . getName (  )  . equals ( method . getName (  )  )  )     &  &     ( Arrays . equals ( ifcMethod . getParameterTypes (  )  ,    method . getParameterTypes (  )  )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isDeclaredInInterface"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( method . getModifiers (  )  )     &     ( Modifier . PUBLIC )  )     >     0  )     &  &     ( isDeclaredInInterface ( method ,    beanKey )  )  ;", "}", "METHOD_END"], "methodName": ["isPublicInInterface"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes    =    new   Class <  ?  >  [ classNames . length ]  ;", "for    ( int   x    =     0  ;    x    <     ( classes . length )  ;    x +  +  )     {", "Class <  ?  >    cls    =    ClassUtils . resolveClassName ( classNames [ x ]  . trim (  )  ,    this . beanClassLoader )  ;", "if    (  !  ( cls . is (  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Class    [  \"     +     ( classNames [ x ]  )  )     +     \"  ]    mapped   to   bean   key    [  \"  )     +    beanKey )     +     \"  ]    is   no   interface \"  )  )  ;", "}", "classes [ x ]     =    cls ;", "}", "return   classes ;", "}", "METHOD_END"], "methodName": ["resolveClassNames"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Class <  ?  >  [  ]  >    resolvedMappings    =    new   HashMap <  >  ( mappings . size (  )  )  ;", "for    ( Enumeration <  ?  >    en    =    mappings . propertyNames (  )  ;    en . hasMoreElements (  )  ;  )     {", "String   beanKey    =     (  ( String )     ( en . nextElement (  )  )  )  ;", "String [  ]    classNames    =    StringUtils . commaDelimitedListToStringArray ( mappings . getProperty ( beanKey )  )  ;", "Class <  ?  >  [  ]    classes    =    resolveClassNames ( classNames ,    beanKey )  ;", "resolvedMappings . put ( beanKey ,    classes )  ;", "}", "return   resolvedMappings ;", "}", "METHOD_END"], "methodName": ["resolveInterfaceMappings"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . interfaceMappings    =    mappings ;", "}", "METHOD_END"], "methodName": ["setInterfaceMappings"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "if    ( managedInterfaces    !  =    null )     {", "for    ( Class <  ?  >    ifc    :    managedInterfaces )     {", "if    (  !  ( ifc . isInterface (  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Management   interface    [  \"     +     ( ifc . getName (  )  )  )     +     \"  ]    is   not   an   interface \"  )  )  ;", "}", "}", "}", "this . managedInterfaces    =    managedInterfaces ;", "}", "METHOD_END"], "methodName": ["setManagedInterfaces"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute ( AbstractJmxAssemblerTests . AGE _ ATTRIBUTE )  ;", "assertTrue ( attr . isReadable (  )  )  ;", "assertFalse ( attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAgeIsReadOnly"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerCustomTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Nick   Name   should   not   be   null \"  ,    attr )  ;", "assertTrue (  \" Nick   Name   should   be   writable \"  ,    attr . isWritable (  )  )  ;", "assertTrue (  \" Nick   Name   should   be   readab ; e \"  ,    attr . isReadable (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNickName"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "return   getWithMapping ( InterfaceBasedMBeanInfoAssemblerMappedTests . OBJECT _ NAME ,    mapping )  ;", "}", "METHOD_END"], "methodName": ["getWithMapping"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "InterfaceBasedMBeanInfoAssembler   assembler    =    new   InterfaceBasedMBeanInfoAssembler (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( name ,    mapping )  ;", "assembler . setInterfaceMappings ( props )  ;", "assembler . afterPropertiesSet (  )  ;", "return   assembler ;", "}", "METHOD_END"], "methodName": ["getWithMapping"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute ( AbstractJmxAssemblerTests . AGE _ ATTRIBUTE )  ;", "assertTrue (  \" Age   is   not   readable \"  ,    attr . isReadable (  )  )  ;", "assertFalse (  \" Age   is   not   writable \"  ,    attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAgeIsReadOnly"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =     (  ( ModelMBeanInfo )     ( getMBeanInfo (  )  )  )  ;", "MBeanAttributeInfo   attr    =    inf . getAttribute (  \" NickName \"  )  ;", "assertNickName ( attr )  ;", "}", "METHOD_END"], "methodName": ["testNickNameIsExposed"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "InterfaceBasedMBeanInfoAssembler   assembler    =    getWithMapping (  \" foobar \"  ,     \" ICustomJmxBean \"  )  ;", "assembler . setManagedInterfaces ( new   Class <  ?  >  [  ]  {    IAdditionalTestMethods . class    }  )  ;", "ModelMBeanInfo   inf    =    assembler . getMBeanInfo ( getBean (  )  ,    getObjectName (  )  )  ;", "MBeanAttributeInfo   attr    =    inf . getAttribute (  \" NickName \"  )  ;", "assertNickName ( attr )  ;", "}", "METHOD_END"], "methodName": ["testWithFallThrough"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "getWithing (  \" JmxTestBean \"  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testWithNonInterface"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "getWithing (  \" com . foo . bar . Unknown \"  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testWithUnknownClass"], "fileName": "org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "return    ( obtainAttributeSource (  )  . getManagedAttribute ( method )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasManagedAttribute"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return    ( obtainAttributeSource (  )  . getManagedMetric ( method )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasManagedMetric"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return    ( obtainAttributeSource (  )  . getManagedOperation ( method )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasManagedOperation"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . attributeSource )     !  =    null )  ,     \" No   JmxAttributeSource   set \"  )  ;", "return   this . attributeSource ;", "}", "METHOD_END"], "methodName": ["obtainAttributeSource"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "applyCurrencyTimeLimit ( desc ,    resolveIntDescriptor ( gma . getCurrencyTimeLimit (  )  ,    sma . getCurrencyTimeLimit (  )  )  )  ;", "Object   defaultValue    =    resolveObjectDescriptor ( gma . getDefaultValue (  )  ,    sma . getDefaultValue (  )  )  ;", "desc . setField ( AbstractReflective . FIELD _ DEFAULT ,    defaultValue )  ;", "String   persistPolicy    =    resolveStringDescriptor ( gma . getPersistPolicy (  )  ,    sma . getPersistPolicy (  )  )  ;", "if    ( StringUtils . hasLength ( persistPolicy )  )     {", "desc . setField ( AbstractReflective . FIELD _ PERSIST _ POLICY ,    persistPolicy )  ;", "}", "int   persistPeriod    =    resolveIntDescriptor ( gma . getPersistPeriod (  )  ,    sma . getPersistPeriod (  )  )  ;", "if    ( persistPeriod    >  =     0  )     {", "desc . setField ( AbstractReflective . FIELD _ PERSIST _ PERIOD ,    Integer . toString ( persistPeriod )  )  ;", "}", "}", "METHOD_END"], "methodName": ["populateAttributeDescriptor"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "applyCurrencyTimeLimit ( desc ,    metric . getCurrencyTimeLimit (  )  )  ;", "if    ( StringUtils . hasLength ( metric . getPersistPolicy (  )  )  )     {", "desc . setField ( AbstractReflective . FIELD _ PERSIST _ POLICY ,    metric . getPersistPolicy (  )  )  ;", "}", "if    (  ( metric . getPersistPeriod (  )  )     >  =     0  )     {", "desc . setField ( AbstractReflective . FIELD _ PERSIST _ PERIOD ,    Integer . toString ( metric . getPersistPeriod (  )  )  )  ;", "}", "if    ( StringUtils . hasLength ( metric . getDisplayName (  )  )  )     {", "desc . setField ( AbstractReflective . FIELD _ DISPLAY _ NAME ,    metric . getDisplayName (  )  )  ;", "}", "if    ( StringUtils . hasLength ( metric . getUnit (  )  )  )     {", "desc . setField ( AbstractReflective . FIELD _ UNITS ,    metric . getUnit (  )  )  ;", "}", "if    ( StringUtils . hasLength ( metric . getCategory (  )  )  )     {", "desc . setField ( AbstractReflective . FIELD _ METRIC _ CATEGORY ,    metric . getCategory (  )  )  ;", "}", "desc . setField ( AbstractReflective . FIELD _ METRIC _ TYPE ,    metric . getMetricType (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["populateMetricDescriptor"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   getter    >  =    setter    ?    getter    :    setter ;", "}", "METHOD_END"], "methodName": ["resolveIntDescriptor"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   getter    !  =    null    ?    getter    :    setter ;", "}", "METHOD_END"], "methodName": ["resolveObjectDescriptor"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . hasLength ( getter )     ?    getter    :    setter ;", "}", "METHOD_END"], "methodName": ["resolveStringDescriptor"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeSource ,     \" JmxAttributeSource   must   not   be   null \"  )  ;", "this . attributeSource    =    attributeSource ;", "}", "METHOD_END"], "methodName": ["setAttributeSource"], "fileName": "org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . ignoredMethodMappings )     !  =    null )     {", "Set < String >    methodNames    =    this . ignoredMethodMappings . get ( beanKey )  ;", "if    ( methodNames    !  =    null )     {", "return    !  ( methodNames . contains ( method . getName (  )  )  )  ;", "}", "}", "if    (  ( this . ignoredMethods )     !  =    null )     {", "return    !  ( this . ignoredMethods . contains ( method . getName (  )  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isNotIgnored"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . ignoredMethodMappings    =    new   HashMap <  >  (  )  ;", "for    ( Enumeration <  ?  >    en    =    mappings . keys (  )  ;    en . hasMoreElements (  )  ;  )     {", "String   beanKey    =     (  ( String )     ( en . nextElement (  )  )  )  ;", "String [  ]    methodNames    =    StringUtils . commaDelimitedListToStringArray ( mappings . getProperty ( beanKey )  )  ;", "this . ignoredMethodMappings . put ( beanKey ,    new   HashSet <  >  ( Arrays . asList ( methodNames )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setIgnoredMethodMappings"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . ignoredMethods    =    new   HashSet <  >  ( Arrays . asList ( ignoredMethodNames )  )  ;", "}", "METHOD_END"], "methodName": ["setIgnoredMethods"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute ( AbstractJmxAssemblerTests . AGE _ ATTRIBUTE )  ;", "assertTrue (  \" Age   is   not   readable \"  ,    attr . isReadable (  )  )  ;", "assertFalse (  \" Age   is   not   writable \"  ,    attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAgeIsReadOnly"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssemblerComboTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =     (  ( ModelMBeanInfo )     ( getMBeanInfo (  )  )  )  ;", "MBeanAttributeInfo   attr    =    inf . getAttribute (  \" NickName \"  )  ;", "assertNotNull (  \" Nick   Name   should   not   be   null \"  ,    attr )  ;", "assertTrue (  \" Nick   Name   should   be   writable \"  ,    attr . isWritable (  )  )  ;", "assertTrue (  \" Nick   Name   should   be   readable \"  ,    attr . isReadable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNickNameIsExposed"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssemblerComboTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute ( AbstractJmxAssemblerTests . AGE _ ATTRIBUTE )  ;", "assertTrue (  \" Age   is   not   readable \"  ,    attr . isReadable (  )  )  ;", "assertFalse (  \" Age   is   not   writable \"  ,    attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAgeIsReadOnly"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =     (  ( ModelMBeanInfo )     ( getMBeanInfo (  )  )  )  ;", "MBeanAttributeInfo   attr    =    inf . getAttribute (  \" NickName \"  )  ;", "assertNotNull (  \" Nick   Name   should   not   be   null \"  ,    attr )  ;", "assertTrue (  \" Nick   Name   should   be   writable \"  ,    attr . isWritable (  )  )  ;", "assertTrue (  \" Nick   Name   should   be   readable \"  ,    attr . isReadable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNickNameIsExposed"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute ( AbstractJmxAssemblerTests . AGE _ ATTRIBUTE )  ;", "assertTrue (  \" Age   is   not   readable \"  ,    attr . isReadable (  )  )  ;", "assertTrue (  \" Age   is   not   writable \"  ,    attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAgeIsReadOnly"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssemblerNotMappedTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =     (  ( ModelMBeanInfo )     ( getMBeanInfo (  )  )  )  ;", "MBeanAttributeInfo   attr    =    inf . getAttribute (  \" NickName \"  )  ;", "assertNotNull (  \" Nick   Name   should   not   be   null \"  ,    attr )  ;", "assertTrue (  \" Nick   Name   should   be   writable \"  ,    attr . isWritable (  )  )  ;", "assertTrue (  \" Nick   Name   should   be   readable \"  ,    attr . isReadable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNickNameIsExposed"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssemblerNotMappedTests"}, {"methodBody": ["METHOD_START", "{", "final   String   beanKey    =     \" myTestBean \"  ;", "assembler    =    new    (  )  ;", "Properties   ignored    =    new   Properties (  )  ;", "ignored . setProperty ( beanKey ,     \" dontExposeMe , setSuperman \"  )  ;", "assembler . setIgnoredMethodMappings ( ignored )  ;", "Method   method    =    JmxTestBean . class . getMethod (  \" dontExposeMe \"  )  ;", "assertFalse ( assembler . isNotIgnored ( method ,    beanKey )  )  ;", "assertTrue ( assembler . isNotIgnored ( method ,     \" someOtherBeanKey \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsNotIgnoredDoesntIgnoreUnspecifiedBeanMethods"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute (  \" Superman \"  )  ;", "assertTrue ( attr . isReadable (  )  )  ;", "assertFalse ( attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSupermanIsReadOnly"], "fileName": "org.springframework.jmx.export.assembler.MethodExclusionMBeanInfoAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . methodMappings )     !  =    null )     {", "Set < String >    ms    =    this . methodMappings . get ( beanKey )  ;", "if    ( ms    !  =    null )     {", "return   ms . contains ( method . getName (  )  )  ;", "}", "}", "return    (  ( this . managedMethods )     !  =    null )     &  &     ( this . managedMethods . contains ( method . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isMatch"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . managedMethods    =    new   HashSet <  >  ( Arrays . asList ( methodNames )  )  ;", "}", "METHOD_END"], "methodName": ["setManagedMethods"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "this . methodMappings    =    new   HashMap <  >  (  )  ;", "for    ( Enumeration <  ?  >    en    =    mappings . keys (  )  ;    en . hasMoreElements (  )  ;  )     {", "String   beanKey    =     (  ( String )     ( en . nextElement (  )  )  )  ;", "String [  ]    ms    =    StringUtils . commaDelimitedListToStringArray ( mappings . getProperty ( beanKey )  )  ;", "this . methodMappings . put ( beanKey ,    new   HashSet <  >  ( Arrays . asList ( ms )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setMethodMappings"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Nick   Name   should   not   be   null \"  ,    attr )  ;", "assertTrue (  \" Nick   Name   should   be   writable \"  ,    attr . isWritable (  )  )  ;", "assertTrue (  \" Nick   Name   should   be   readable \"  ,    attr . isReadable (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNickName"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "return   getWithMapping ( MethodNameBasedMBeanInfoAssemblerMappedTests . OBJECT _ NAME ,    mapping )  ;", "}", "METHOD_END"], "methodName": ["getWithMapping"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "MethodNameBasedMBeanInfoAssembler   assembler    =    new   MethodNameBasedMBeanInfoAssembler (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( name ,    mapping )  ;", "assembler . setMethodMappings ( props )  ;", "return   assembler ;", "}", "METHOD_END"], "methodName": ["getWithMapping"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute ( AbstractJmxAssemblerTests . AGE _ ATTRIBUTE )  ;", "assertTrue (  \" Age   is   not   readable \"  ,    attr . isReadable (  )  )  ;", "assertFalse (  \" Age   is   not   writable \"  ,    attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAgeIsReadOnly"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   inf    =     (  ( ModelMBeanInfo )     ( getMBeanInfo (  )  )  )  ;", "MBeanAttributeInfo   attr    =    inf . getAttribute (  \" NickName \"  )  ;", "assertNickName ( attr )  ;", "}", "METHOD_END"], "methodName": ["testNickNameIsExposed"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "MethodNameBasedMBeanInfoAssembler   assembler    =    getWithMapping (  \" foobar \"  ,     \" add , myOperation , getName , setName , getAge \"  )  ;", "assembler . setManagedMethods (  \" getNickName \"  ,     \" setNickName \"  )  ;", "ModelMBeanInfo   inf    =    assembler . getMBeanInfo ( getBean (  )  ,    getObjectName (  )  )  ;", "MBeanAttributeInfo   attr    =    inf . getAttribute (  \" NickName \"  )  ;", "assertNickName ( attr )  ;", "}", "METHOD_END"], "methodName": ["testWithFallThrough"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssemblerMappedTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "ModelMBeanAttributeInfo   attr    =    info . getAttribute ( AbstractJmx . AGE _ ATTRIBUTE )  ;", "assertTrue ( attr . isReadable (  )  )  ;", "assertFalse ( attr . isWritable (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAgeIsReadOnly"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanInfo   info    =    getMBeanInfoFromAssembler (  )  ;", "MBeanOperationInfo   operationSetAge    =    info . getOperation (  \" setName \"  )  ;", "assertEquals (  \" name \"  ,    operationSetAge . getSignature (  )  [  0  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetNameParameterIsNamed"], "fileName": "org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssemblerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . currencyTimeLimit ;", "}", "METHOD_END"], "methodName": ["getCurrencyTimeLimit"], "fileName": "org.springframework.jmx.export.metadata.AbstractJmxAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.springframework.jmx.export.metadata.AbstractJmxAttribute"}, {"methodBody": ["METHOD_START", "{", "this . currencyTimeLimit    =    currencyTimeLimit ;", "}", "METHOD_END"], "methodName": ["setCurrencyTimeLimit"], "fileName": "org.springframework.jmx.export.metadata.AbstractJmxAttribute"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.springframework.jmx.export.metadata.AbstractJmxAttribute"}, {"methodBody": ["METHOD_START", "{", "String [  ]    notifTypes    =    notificationInfo . getNotificationTypes (  )  ;", "if    ( Object . isEmpty ( notifTypes )  )     {", "throw   new   IllegalArgumentException (  \" Must   specify   at   least   one   notification   type \"  )  ;", "}", "String   name    =    notificationInfo . getName (  )  ;", "if    (  !  ( String . hasText ( name )  )  )     {", "throw   new   IllegalArgumentException (  \" Must   specify   notification   name \"  )  ;", "}", "String   description    =    notificationInfo . getDescription (  )  ;", "return   new   ModelMBeanNotificationInfo ( notifTypes ,    name ,    description )  ;", "}", "METHOD_END"], "methodName": ["convertToModelMBeanNotificationInfo"], "fileName": "org.springframework.jmx.export.metadata.JmxMetadataUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultValue ;", "}", "METHOD_END"], "methodName": ["getDefaultValue"], "fileName": "org.springframework.jmx.export.metadata.ManagedAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . persistPeriod ;", "}", "METHOD_END"], "methodName": ["getPersistPeriod"], "fileName": "org.springframework.jmx.export.metadata.ManagedAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . persistPolicy ;", "}", "METHOD_END"], "methodName": ["getPersistPolicy"], "fileName": "org.springframework.jmx.export.metadata.ManagedAttribute"}, {"methodBody": ["METHOD_START", "{", "this . defaultValue    =    defaultValue ;", "}", "METHOD_END"], "methodName": ["setDefaultValue"], "fileName": "org.springframework.jmx.export.metadata.ManagedAttribute"}, {"methodBody": ["METHOD_START", "{", "this . persistPeriod    =    persistPeriod ;", "}", "METHOD_END"], "methodName": ["setPersistPeriod"], "fileName": "org.springframework.jmx.export.metadata.ManagedAttribute"}, {"methodBody": ["METHOD_START", "{", "this . persistPolicy    =    persistPolicy ;", "}", "METHOD_END"], "methodName": ["setPersistPolicy"], "fileName": "org.springframework.jmx.export.metadata.ManagedAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . category ;", "}", "METHOD_END"], "methodName": ["getCategory"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "return   this . displayName ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "return   this . metricType ;", "}", "METHOD_END"], "methodName": ["getMetricType"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "return   this . persistPeriod ;", "}", "METHOD_END"], "methodName": ["getPersistPeriod"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "return   this . persistPolicy ;", "}", "METHOD_END"], "methodName": ["getPersistPolicy"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "return   this . unit ;", "}", "METHOD_END"], "methodName": ["getUnit"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "this . category    =    category ;", "}", "METHOD_END"], "methodName": ["setCategory"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "this . displayName    =    displayName ;", "}", "METHOD_END"], "methodName": ["setDisplayName"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( metricType ,     \" MetricType   must   not   be   null \"  )  ;", "this . metricType    =    metricType ;", "}", "METHOD_END"], "methodName": ["setMetricType"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "this . persistPeriod    =    persistPeriod ;", "}", "METHOD_END"], "methodName": ["setPersistPeriod"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "this . persistPolicy    =    persistPolicy ;", "}", "METHOD_END"], "methodName": ["setPersistPolicy"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "this . unit    =    unit ;", "}", "METHOD_END"], "methodName": ["setUnit"], "fileName": "org.springframework.jmx.export.metadata.ManagedMetric"}, {"methodBody": ["METHOD_START", "{", "return   this . description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.springframework.jmx.export.metadata.ManagedNotification"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.jmx.export.metadata.ManagedNotification"}, {"methodBody": ["METHOD_START", "{", "return   this . notificationTypes ;", "}", "METHOD_END"], "methodName": ["getNotificationTypes"], "fileName": "org.springframework.jmx.export.metadata.ManagedNotification"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.springframework.jmx.export.metadata.ManagedNotification"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.jmx.export.metadata.ManagedNotification"}, {"methodBody": ["METHOD_START", "{", "this . notificationTypes    =    StringUtils . commaDelimitedListToStringArray ( notificationType )  ;", "}", "METHOD_END"], "methodName": ["setNotificationType"], "fileName": "org.springframework.jmx.export.metadata.ManagedNotification"}, {"methodBody": ["METHOD_START", "{", "this . notificationTypes    =    notificationTypes ;", "}", "METHOD_END"], "methodName": ["setNotificationTypes"], "fileName": "org.springframework.jmx.export.metadata.ManagedNotification"}, {"methodBody": ["METHOD_START", "{", "return   this . description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.springframework.jmx.export.metadata.ManagedOperationParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . index ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "org.springframework.jmx.export.metadata.ManagedOperationParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.jmx.export.metadata.ManagedOperationParameter"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.springframework.jmx.export.metadata.ManagedOperationParameter"}, {"methodBody": ["METHOD_START", "{", "this . index    =    index ;", "}", "METHOD_END"], "methodName": ["setIndex"], "fileName": "org.springframework.jmx.export.metadata.ManagedOperationParameter"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.jmx.export.metadata.ManagedOperationParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . logFile ;", "}", "METHOD_END"], "methodName": ["getLogFile"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "return   this . objectName ;", "}", "METHOD_END"], "methodName": ["getObjectName"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "return   this . persistLocation ;", "}", "METHOD_END"], "methodName": ["getPersistLocation"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "return   this . persistName ;", "}", "METHOD_END"], "methodName": ["getPersistName"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "return   this . persistPeriod ;", "}", "METHOD_END"], "methodName": ["getPersistPeriod"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "return   this . persistPolicy ;", "}", "METHOD_END"], "methodName": ["getPersistPolicy"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "return   this . log ;", "}", "METHOD_END"], "methodName": ["isLog"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "this . log    =    log ;", "}", "METHOD_END"], "methodName": ["setLog"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "this . logFile    =    logFile ;", "}", "METHOD_END"], "methodName": ["setLogFile"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "this . objectName    =    objectName ;", "}", "METHOD_END"], "methodName": ["setObjectName"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "this . persistLocation    =    persistLocation ;", "}", "METHOD_END"], "methodName": ["setPersistLocation"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "this . persistName    =    persistName ;", "}", "METHOD_END"], "methodName": ["setPersistName"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "this . persistPeriod    =    persistPeriod ;", "}", "METHOD_END"], "methodName": ["setPersistPeriod"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "this . persistPolicy    =    persistPolicy ;", "}", "METHOD_END"], "methodName": ["setPersistPolicy"], "fileName": "org.springframework.jmx.export.metadata.ManagedResource"}, {"methodBody": ["METHOD_START", "{", "ObjectNamingStrategy   strat    =    getStrategy (  )  ;", "ObjectName   objectName    =    strat . getObjectName ( getManagedResource (  )  ,    getKey (  )  )  ;", "assertEquals ( objectName . getCanonicalName (  )  ,    getCorrectObjectName (  )  )  ;", "}", "METHOD_END"], "methodName": ["naming"], "fileName": "org.springframework.jmx.export.naming.AbstractNamingStrategyTests"}, {"methodBody": ["METHOD_START", "{", "JmxTestBean   bean    =    new   JmxTestBean (  )  ;", "strategy    =    new    (  )  ;", "ObjectName   objectName    =    strategy . getObjectName ( bean ,     \" null \"  )  ;", "assertEquals (  \" Domain   is   incorrect \"  ,    bean . getClass (  )  . getPackage (  )  . getName (  )  ,    objectName . getDomain (  )  )  ;", "assertEquals (  \" Type   property   is   incorrect \"  ,    ClassUtils . getShortName ( bean . getClass (  )  )  ,    objectName . getKeyProperty (  . TYPE _ KEY )  )  ;", "assertEquals (  \" HashCode   property   is   incorrect \"  ,    ObjectUtils . getIdentityHexString ( bean )  ,    objectName . getKeyProperty (  . HASH _ CODE _ KEY )  )  ;", "}", "METHOD_END"], "methodName": ["naming"], "fileName": "org.springframework.jmx.export.naming.IdentityNamingStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . mappingLocations    =    new   Resource [  ]  {    location    }  ;", "}", "METHOD_END"], "methodName": ["setMappingLocation"], "fileName": "org.springframework.jmx.export.naming.KeyNamingStrategy"}, {"methodBody": ["METHOD_START", "{", "this . mappingLocations    =    mappingLocations ;", "}", "METHOD_END"], "methodName": ["setMappingLocations"], "fileName": "org.springframework.jmx.export.naming.KeyNamingStrategy"}, {"methodBody": ["METHOD_START", "{", "this . mappings    =    mappings ;", "}", "METHOD_END"], "methodName": ["setMappings"], "fileName": "org.springframework.jmx.export.naming.KeyNamingStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeSource ,     \" JmxAttributeSource   must   not   be   null \"  )  ;", "this . attributeSource    =    attributeSource ;", "}", "METHOD_END"], "methodName": ["setAttributeSource"], "fileName": "org.springframework.jmx.export.naming.MetadataNamingStrategy"}, {"methodBody": ["METHOD_START", "{", "this . defaultDomain    =    defaultDomain ;", "}", "METHOD_END"], "methodName": ["setDefaultDomain"], "fileName": "org.springframework.jmx.export.naming.MetadataNamingStrategy"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( notification . getSource (  )  )     =  =    null )     |  |     ( notification . getSource (  )  . equals ( this . managedResource )  )  )     {", "notification . setSource ( this . objectName )  ;", "}", "}", "METHOD_END"], "methodName": ["replaceNotificationSourceIfNecessary"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisher"}, {"methodBody": ["METHOD_START", "{", "return   ObjectName . getInstance (  \" foo : type = bar \"  )  ;", "}", "METHOD_END"], "methodName": ["createObjectName"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "new   ModelMBeanNotificationPublisher ( null ,    ModelMBeanNotificationPublisherTests . createObjectName (  )  ,    this )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullMBean"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "new   ModelMBeanNotificationPublisher ( new   SpringModelMBean (  )  ,    ModelMBeanNotificationPublisherTests . createObjectName (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullManagedResource"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "new   ModelMBeanNotificationPublisher ( new   SpringModelMBean (  )  ,    null ,    this )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullObjectName"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanNotificationPublisherTests . StubSpringModelMBean   mbean    =    new   ModelMBeanNotificationPublisherTests . StubSpringModelMBean (  )  ;", "Notification   notification    =    new   AttributeChangeNotification ( mbean ,     1  8  7  2  ,    System . currentTimeMillis (  )  ,     \" Shall   we   break   for   some   tea ?  \"  ,     \" agree \"  ,     \" Boolean \"  ,    Boolean . FALSE ,    Boolean . TRUE )  ;", "ObjectName   objectName    =    ModelMBeanNotificationPublisherTests . createObjectName (  )  ;", "NotificationPublisher   publisher    =    new   ModelMBeanNotificationPublisher ( mbean ,    objectName ,    mbean )  ;", "publisher . sendNotification ( notification )  ;", "assertNotNull ( mbean . getActualNotification (  )  )  ;", "assertTrue (  (  ( mbean . getActualNotification (  )  )    instanceof   AttributeChangeNotification )  )  ;", "assertSame (  \" The   exact   same   Notification   is   not   being   passed   through   from   the   publisher   to   the   mbean .  \"  ,    notification ,    mbean . getActualNotification (  )  )  ;", "assertSame (  \" The    ' source '    property   of   the   Notification   is   not   being   set   to   the   ObjectName   of   the   associated   MBean .  \"  ,    objectName ,    mbean . getActualNotification (  )  . getSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSendAttributeChangeNotification"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanNotificationPublisherTests . StubSpringModelMBean   mbean    =    new   ModelMBeanNotificationPublisherTests . StubSpringModelMBean (  )  ;", "Notification   notification    =    new   AttributeChangeNotification ( this ,     1  8  7  2  ,    System . currentTimeMillis (  )  ,     \" Shall   we   break   for   some   tea ?  \"  ,     \" agree \"  ,     \" Boolean \"  ,    Boolean . FALSE ,    Boolean . TRUE )  ;", "ObjectName   objectName    =    ModelMBeanNotificationPublisherTests . createObjectName (  )  ;", "NotificationPublisher   publisher    =    new   ModelMBeanNotificationPublisher ( mbean ,    objectName ,    mbean )  ;", "publisher . sendNotification ( notification )  ;", "assertNotNull ( mbean . getActualNotification (  )  )  ;", "assertTrue (  (  ( mbean . getActualNotification (  )  )    instanceof   AttributeChangeNotification )  )  ;", "assertSame (  \" The   exact   same   Notification   is   not   being   passed   through   from   the   publisher   to   the   mbean .  \"  ,    notification ,    mbean . getActualNotification (  )  )  ;", "assertSame (  \" The    ' source '    property   of   the   Notification   is    * wrongly *    being   set   to   the   ObjectName   of   the   associated   MBean .  \"  ,    this ,    mbean . getActualNotification (  )  . getSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSendAttributeChangeNotificationWhereSourceIsNotTheManagedResource"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "NotificationPublisher   publisher    =    new   ModelMBeanNotificationPublisher ( new   SpringModelMBean (  )  ,    ModelMBeanNotificationPublisherTests . createObjectName (  )  ,    this )  ;", "publisher . sendNotification ( null )  ;", "}", "METHOD_END"], "methodName": ["testSendNullNotification"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "ModelMBeanNotificationPublisherTests . StubSpringModelMBean   mbean    =    new   ModelMBeanNotificationPublisherTests . StubSpringModelMBean (  )  ;", "Notification   notification    =    new   Notification (  \" network . alarm . router \"  ,    mbean ,     1  8  7  2  )  ;", "ObjectName   objectName    =    ModelMBeanNotificationPublisherTests . createObjectName (  )  ;", "NotificationPublisher   publisher    =    new   ModelMBeanNotificationPublisher ( mbean ,    objectName ,    mbean )  ;", "publisher . sendNotification ( notification )  ;", "assertNotNull ( mbean . getActualNotification (  )  )  ;", "assertSame (  \" The   exact   same   Notification   is   not   being   passed   through   from   the   publisher   to   the   mbean .  \"  ,    notification ,    mbean . getActualNotification (  )  )  ;", "assertSame (  \" The    ' source '    property   of   the   Notification   is   not   being   set   to   the   ObjectName   of   the   associated   MBean .  \"  ,    objectName ,    mbean . getActualNotification (  )  . getSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSendVanillaNotification"], "fileName": "org.springframework.jmx.export.notification.ModelMBeanNotificationPublisherTests"}, {"methodBody": ["METHOD_START", "{", "this . daemon    =    daemon ;", "}", "METHOD_END"], "methodName": ["setDaemon"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "CollectionUtils . mergePropertiesIntoMap ( environment ,    this . environment )  ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( environment    !  =    null )     {", "this . environment . putAll ( environment )  ;", "}", "}", "METHOD_END"], "methodName": ["setEnvironmentMap"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . forwarder    =    forwarder ;", "}", "METHOD_END"], "methodName": ["setForwarder"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . objectName    =    ObjectNameManager . getInstance ( objectName )  ;", "}", "METHOD_END"], "methodName": ["setObjectName"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . serviceUrl    =    serviceUrl ;", "}", "METHOD_END"], "methodName": ["setServiceUrl"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . threaded    =    threaded ;", "}", "METHOD_END"], "methodName": ["setThreaded"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "JMXServiceURL   serviceURL    =    new   JMXServiceURL ( ConnectorServerFactoryBean . DEFAULT _ SERVICE _ URL )  ;", "JMXConnector   connector    =    JMXConnectorFactory . connect ( serviceURL )  ;", "assertNotNull (  \" Client   Connector   should   not   be   null \"  ,    connector )  ;", "MBeanServerConnection   connection    =    connector . getMBeanServerConnection (  )  ;", "assertNotNull (  \" MBeanServerConnection   should   not   be   null \"  ,    connection )  ;", "assertEquals (  \" Registered   MBean   count   should   be   the   same \"  ,    hostedServer . getMBeanCount (  )  ,    connection . getMBeanCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkServerConnection"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ConnectorServerFactoryBean   bean    =    new   ConnectorServerFactoryBean (  )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "getServer (  )  . getObjectInstance ( ObjectName . getInstance (  . OBJECT _ NAME )  )  ;", "fail (  \" Instance   should   not   be   found \"  )  ;", "}    catch    ( InstanceNotFoundException   ex )     {", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["noRegisterWithMBeanServer"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Thread . sleep (  1  )  ;", "ConnectorServerFactoryBean   bean    =    new   ConnectorServerFactoryBean (  )  ;", "bean . setObjectName (  . OBJECT _ NAME )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "ObjectInstance   instance    =    getServer (  )  . getObjectInstance ( ObjectName . getInstance (  . OBJECT _ NAME )  )  ;", "assertNotNull (  \" ObjectInstance   should   not   be   null \"  ,    instance )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerWithMBeanServer"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ConnectorServerFactoryBean   bean    =    new   ConnectorServerFactoryBean (  )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "checkServerConnection ( getServer (  )  )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startupWithLocatedServer"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Thread . sleep (  1  )  ;", "bean    =    new    (  )  ;", "bean . setServer ( getServer (  )  )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "checkServerConnection ( getServer (  )  )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startupWithSuppliedServer"], "fileName": "org.springframework.jmx.support.ConnectorServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Hashtable < String ,    String >    keyProperties    =    objectName . getKeyPropertyList (  )  ;", "keyProperties . put (  . IDENTITY _ OBJECT _ NAME _ KEY ,    ObjectUtils . getIdentityHexString ( managedResource )  )  ;", "return   ObjectNameManager . getInstance ( objectName . getDomain (  )  ,    keyProperties )  ;", "}", "METHOD_END"], "methodName": ["appendIdentityToObjectName"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( useStrictCasing )     {", "return   String . capitalize ( property . getName (  )  )  ;", "} else    {", "return   property . getName (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAttributeName"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getUserClass ( clazz )  ;", "}", "METHOD_END"], "methodName": ["getClassToExpose"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getUserClass ( managedBean )  ;", "}", "METHOD_END"], "methodName": ["getClassToExpose"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( clazz    =  =    null )     |  |     (  ( clazz . getSuperclass (  )  )     =  =    null )  )     {", "return   null ;", "}", "String   mbeanInterfaceName    =     ( clazz . getName (  )  )     +     (  . MBEAN _ SUFFIX )  ;", "Class <  ?  >  [  ]    implementedInterfaces    =    clazz . getInterfaces (  )  ;", "for    ( Class <  ?  >    iface    :    implementedInterfaces )     {", "if    ( iface . getName (  )  . equals ( mbeanInterfaceName )  )     {", "return   iface ;", "}", "}", "return    . getMBeanInterface ( clazz . getSuperclass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMBeanInterface"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( clazz    =  =    null )     |  |     (  ( clazz . getSuperclass (  )  )     =  =    null )  )     {", "return   null ;", "}", "Class <  ?  >  [  ]    implementedInterfaces    =    clazz . getInterfaces (  )  ;", "for    ( Class <  ?  >    iface    :    implementedInterfaces )     {", "if    ( JMX . isMXBeanInterface ( iface )  )     {", "return   iface ;", "}", "}", "return    . getMXBeanInterface ( clazz . getSuperclass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMXBeanInterface"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    types    =    method . getParameterTypes (  )  ;", "String [  ]    signature    =    new   String [ types . length ]  ;", "for    ( int   x    =     0  ;    x    <     ( types . length )  ;    x +  +  )     {", "signature [ x ]     =    types [ x ]  . getName (  )  ;", "}", "return   signature ;", "}", "METHOD_END"], "methodName": ["getMethodSignature"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( clazz    !  =    null )     &  &     (  ( DynamicMBean . class . isAssignableFrom ( clazz )  )     |  |     (  (  ( JmxUtils . getMBeanInterface ( clazz )  )     !  =    null )     |  |     (  ( JmxUtils . getMXBeanInterface ( clazz )  )     !  =    null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isMBean"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "return   JmxUtils . locateMBeanServer ( null )  ;", "}", "METHOD_END"], "methodName": ["locateMBeanServer"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "MBeanServer   server    =    null ;", "if    (  !  (  \"  \"  . equals ( agentId )  )  )     {", "List < MBeanServer >    servers    =    MBeanServerFactory . findMBeanServer ( agentId )  ;", "if    (  !  ( CollectionUtils . isEmpty ( servers )  )  )     {", "if    (  (  ( servers . size (  )  )     >     1  )     &  &     (  . logger . isWarnEnabled (  )  )  )     {", ". logger . warn (  (  (  \" Found   more   than   one   MBeanServer   instance \"     +     ( agentId    !  =    null    ?     (  \"    with   agent   id    [  \"     +    agentId )     +     \"  ]  \"     :     \"  \"  )  )     +     \"  .    Returning   first   from   list .  \"  )  )  ;", "}", "server    =    servers . get (  0  )  ;", "}", "}", "if    (  ( server    =  =    null )     &  &     (  !  ( StringUtils . hasLength ( agentId )  )  )  )     {", "try    {", "server    =    ManagementFactory . getPlatformMBeanServer (  )  ;", "}    catch    ( SecurityException   ex )     {", "throw   new   MBeanServerNotFoundException (  (  \" No   specific   MBeanServer   found ,     \"     +     \" and   not   allowed   to   obtain   the   Java   platform   MBeanServer \"  )  ,    ex )  ;", "}", "}", "if    ( server    =  =    null )     {", "throw   new   MBeanServerNotFoundException (  (  \" Unable   to   locate   an   MBeanServer   instance \"     +     ( agentId    !  =    null    ?     (  \"    with   agent   id    [  \"     +    agentId )     +     \"  ]  \"     :     \"  \"  )  )  )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Found   MBeanServer :     \"     +    server )  )  ;", "}", "return   server ;", "}", "METHOD_END"], "methodName": ["locateMBeanServer"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "return   JmxUtils . parameterInfoToTypes ( paramInfo ,    ClassUtils . getDefaultClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterInfoToTypes"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    types    =    null ;", "if    (  ( paramInfo    !  =    null )     &  &     (  ( paramInfo . length )     >     0  )  )     {", "types    =    new   Class <  ?  >  [ paramInfo . length ]  ;", "for    ( int   x    =     0  ;    x    <     ( paramInfo . length )  ;    x +  +  )     {", "types [ x ]     =    Class . forName ( paramInfo [ x ]  . getType (  )  ,    classLoader )  ;", "}", "}", "return   types ;", "}", "METHOD_END"], "methodName": ["parameterInfoToTypes"], "fileName": "org.springframework.jmx.support.JmxUtils"}, {"methodBody": ["METHOD_START", "{", "ObjectName   objectName    =    ObjectNameManager . getInstance (  \" spring : type = Test \"  )  ;", "Object   managedResource    =    new   Object (  )  ;", "ObjectName   uniqueName    =     . appendIdentityToObjectName ( objectName ,    managedResource )  ;", "String   typeProperty    =     \" type \"  ;", "assertEquals (  \" Domain   of   transformed   name   is   incorrect \"  ,    objectName . getDomain (  )  ,    uniqueName . getDomain (  )  )  ;", "assertEquals (  \" Type   key   is   incorrect \"  ,    objectName . getKeyProperty ( typeProperty )  ,    uniqueName . getKeyProperty (  \" type \"  )  )  ;", "assertEquals (  \" Identity   key   is   incorrect \"  ,    ObjectUtils . getIdentityHexString ( managedResource )  ,    uniqueName . getKeyProperty (  . IDENTITY _ OBJECT _ NAME _ KEY )  )  ;", "}", "METHOD_END"], "methodName": ["testAppendIdentityToObjectName"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "PropertyDescriptor   pd    =    new   BeanWrapperImpl ( JmxUtilsTests . AttributeTestBean . class )  . getPropertyDescriptor (  \" name \"  )  ;", "String   attributeName    =    JmxUtils . getAttributeName ( pd ,    true )  ;", "assertEquals (  \" Incorrect   casing   on   attribute   name \"  ,     \" Name \"  ,    attributeName )  ;", "}", "METHOD_END"], "methodName": ["testGetAttributeNameWithStrictCasing"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "PropertyDescriptor   pd    =    new   BeanWrapperImpl ( JmxUtilsTests . AttributeTestBean . class )  . getPropertyDescriptor (  \" name \"  )  ;", "String   attributeName    =    JmxUtils . getAttributeName ( pd ,    false )  ;", "assertEquals (  \" Incorrect   casing   on   attribute   name \"  ,     \" name \"  ,    attributeName )  ;", "}", "METHOD_END"], "methodName": ["testGetAttributeNameWithoutStrictCasing"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( JmxUtils . isMBean ( JmxUtilsTests . JmxClass . class )  )  ;", "assertFalse ( JmxUtils . isMBean ( JmxUtilsTests . SpecializedJmxInterface . class )  )  ;", "assertFalse ( JmxUtils . isMBean ( JmxUtilsTests . JmxInterface . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIsMBean"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DynamicMBean   mbean    =    new   TestDynamicMBean (  )  ;", "assertTrue (  \" Dynamic   MBean   not   detected   correctly \"  ,     . isMBean ( mbean . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsMBeanWithDynamicMBean"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StandardMBean   mbean    =    new   JmxUtilsTests . StandardMBeanImpl (  )  ;", "assertTrue (  \" Standard   MBean   not   detected   correctly \"  ,    JmxUtils . isMBean ( mbean . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsMBeanWithStandardMBeanInherited"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StandardMBean   mbean    =    new   StandardMBean ( new   JmxTestBean (  )  ,    IJmxTestBean . class )  ;", "assertTrue (  \" Standard   MBean   not   detected   correctly \"  ,     . isMBean ( mbean . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsMBeanWithStandardMBeanWrapper"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServer   server    =    null ;", "try    {", "server    =     . locateMBeanServer (  )  ;", "}    finally    {", "if    ( server    !  =    null )     {", "MBeanServerFactory . releaseMBeanServer ( server )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testLocatePlatformMBeanServer"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" Object   incorrectly   identified   as   an   MBean \"  ,    JmxUtils . isMBean ( Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["testNotAnMBean"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "JmxUtilsTests . Foo   foo    =    new   JmxUtilsTests . Foo (  )  ;", "assertTrue (  \" Simple   MBean   not   detected   correctly \"  ,    JmxUtils . isMBean ( foo . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleMBean"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "JmxUtilsTests . Bar   bar    =    new   JmxUtilsTests . Bar (  )  ;", "JmxUtilsTests . Abc   abc    =    new   JmxUtilsTests . Abc (  )  ;", "assertTrue (  \" Simple   MBean    ( through   inheritance )    not   detected   correctly \"  ,    JmxUtils . isMBean ( bar . getClass (  )  )  )  ;", "assertTrue (  \" Simple   MBean    ( through    2    levels   of   inheritance )    not   detected   correctly \"  ,    JmxUtils . isMBean ( abc . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleMBeanThroughInheritance"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "JmxUtilsTests . FooX   foo    =    new   JmxUtilsTests . FooX (  )  ;", "assertTrue (  \" Simple   MXBean   not   detected   correctly \"  ,    JmxUtils . isMBean ( foo . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleMXBean"], "fileName": "org.springframework.jmx.support.JmxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . server )     !  =    null )  ,     \" No   MBeanServer   set \"  )  ;", "ObjectName   actualObjectName ;", "synchronized ( this . registeredBeans )     {", "ObjectInstance   registeredBean    =    null ;", "try    {", "registeredBean    =    this . server . registerMBean ( mbean ,    objectName )  ;", "}    catch    ( InstanceAlreadyExistsException   ex )     {", "if    (  ( this . registrationPolicy )     =  =     ( Policy . IGNORE _ EXISTING )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Ignoring   existing   MBean   at    [  \"     +    objectName )     +     \"  ]  \"  )  )  ;", "}", "} else", "if    (  ( this . registrationPolicy )     =  =     ( Policy . REPLACE _ EXISTING )  )     {", "try    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Replacing   existing   MBean   at    [  \"     +    objectName )     +     \"  ]  \"  )  )  ;", "}", "this . server . unregisterMBean ( objectName )  ;", "registeredBean    =    this . server . registerMBean ( mbean ,    objectName )  ;", "}    catch    ( InstanceNotFoundException   ex 2  )     {", "logger . error (  (  (  \" Unable   to   replace   existing   MBean   at    [  \"     +    objectName )     +     \"  ]  \"  )  ,    ex 2  )  ;", "throw   ex ;", "}", "} else    {", "throw   ex ;", "}", "}", "actualObjectName    =     ( registeredBean    !  =    null )     ?    registeredBean . getObjectName (  )     :    null ;", "if    ( actualObjectName    =  =    null )     {", "actualObjectName    =    objectName ;", "}", "this . registeredBeans . add ( actualObjectName )  ;", "}", "onRegister ( actualObjectName ,    mbean )  ;", "}", "METHOD_END"], "methodName": ["doRegister"], "fileName": "org.springframework.jmx.support.MBeanRegistrationSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . server )     !  =    null )  ,     \" No   MBeanServer   set \"  )  ;", "boolean   actuallyUnregistered    =    false ;", "synchronized ( this . registeredBeans )     {", "if    ( this . registeredBeans . remove ( objectName )  )     {", "try    {", "if    ( this . server . isered ( objectName )  )     {", "this . server . unregisterMBean ( objectName )  ;", "actuallyUnregistered    =    true ;", "} else    {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  (  \" Could   not   unregister   MBean    [  \"     +    objectName )     +     \"  ]    as   said   MBean    \"  )     +     \" is   not   registered    ( perhaps   already   unregistered   by   an   external   process )  \"  )  )  ;", "}", "}", "}    catch    ( JMException   ex )     {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  (  \" Could   not   unregister   MBean    [  \"     +    objectName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "}", "if    ( actuallyUnregistered )     {", "onUnregister ( objectName )  ;", "}", "}", "METHOD_END"], "methodName": ["doUnregister"], "fileName": "org.springframework.jmx.support.MBeanRegistrationSupport"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . registeredBeans )     {", "return   this . registeredBeans . toArray ( new   ObjectName [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["getRegisteredObjectNames"], "fileName": "org.springframework.jmx.support.MBeanRegistrationSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . server ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.springframework.jmx.support.MBeanRegistrationSupport"}, {"methodBody": ["METHOD_START", "{", "onRegister ( objectName )  ;", "}", "METHOD_END"], "methodName": ["onRegister"], "fileName": "org.springframework.jmx.support.MBeanRegistrationSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( registrationPolicy ,     \" RegistrationPolicy   must   not   be   null \"  )  ;", "this . registrationPolicy    =    registrationPolicy ;", "}", "METHOD_END"], "methodName": ["setRegistrationPolicy"], "fileName": "org.springframework.jmx.support.MBeanRegistrationSupport"}, {"methodBody": ["METHOD_START", "{", "this . server    =    server ;", "}", "METHOD_END"], "methodName": ["setServer"], "fileName": "org.springframework.jmx.support.MBeanRegistrationSupport"}, {"methodBody": ["METHOD_START", "{", "Set < ObjectName >    snapshot ;", "synchronized ( this . reredBeans )     {", "snapshot    =    new   LinkedHashSet <  >  ( this . reredBeans )  ;", "}", "if    (  !  ( snapshot . isEmpty (  )  )  )     {", "logger . info (  \" Unrering   JMX - exposed   beans \"  )  ;", "}", "for    ( ObjectName   objectName    :    snapshot )     {", "doUnrer ( objectName )  ;", "}", "}", "METHOD_END"], "methodName": ["unregisterBeans"], "fileName": "org.springframework.jmx.support.MBeanRegistrationSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . serviceUrl )     !  =    null )  ,     \" No   JMXServiceURL   set \"  )  ;", "this . connector    =    JMXConnectorFactory . connect ( this . serviceUrl ,    this . environment )  ;", "this . connection    =    this . connector . get (  )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . connectorTargetSource    =    new   MBeanServerConnectionFactoryBean . JMXConnectorLazyInitTargetSource (  )  ;", "TargetSource   connectionTargetSource    =    new   MBeanServerConnectionFactoryBean . MBeanServerConnectionLazyInitTargetSource (  )  ;", "this . connector    =     (  ( JMXConnector )     ( new   ProxyFactory ( JMXConnector . class ,    this . connectorTargetSource )  . getProxy ( this . beanClassLoader )  )  )  ;", "this . connection    =     (  ( MBeanServerConnection )     ( new   ProxyFactory ( MBeanServerConnection . class ,    connectionTargetSource )  . getProxy ( this . beanClassLoader )  )  )  ;", "}", "METHOD_END"], "methodName": ["createLazyConnection"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . connectOnStartup    =    connectOnStartup ;", "}", "METHOD_END"], "methodName": ["setConnectOnStartup"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBean"}, {"methodBody": ["METHOD_START", "{", "CollectionUtils . mergePropertiesIntoMap ( environment ,    this . environment )  ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( environment    !  =    null )     {", "this . environment . putAll ( environment )  ;", "}", "}", "METHOD_END"], "methodName": ["setEnvironmentMap"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . serviceUrl    =    new   JMXServiceURL ( url )  ;", "}", "METHOD_END"], "methodName": ["setServiceUrl"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   JMXConnectorServerFactory . newJMXConnectorServer ( getJMXServiceUrl (  )  ,    null ,    getServer (  )  )  ;", "}", "METHOD_END"], "methodName": ["getConnectorServer"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JMXServiceURL ( serviceUrl )  ;", "}", "METHOD_END"], "methodName": ["getJMXServiceUrl"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( JMXMP )  ;", "JMXConnectorServer   connectorServer    =    getConnectorServer (  )  ;", "connectorServer . start (  )  ;", "try    {", "bean    =    new    (  )  ;", "bean . setServiceUrl ( serviceUrl )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "MBeanServerConnection   connection    =    bean . getObject (  )  ;", "assertNotNull (  \" Connection   should   not   be   null \"  ,    connection )  ;", "assertEquals (  \" MBean   count   should   be   the   same \"  ,    getServer (  )  . getMBeanCount (  )  ,    connection . getMBeanCount (  )  )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}    finally    {", "connectorServer . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTestValidConnection"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( JMXMP )  ;", "bean    =    new    (  )  ;", "bean . setServiceUrl ( serviceUrl )  ;", "bean . setConnectOnStartup ( false )  ;", "bean . afterPropertiesSet (  )  ;", "MBeanServerConnection   connection    =    bean . getObject (  )  ;", "assertTrue ( AopUtils . isAopProxy ( connection )  )  ;", "JMXConnectorServer   connector    =    null ;", "try    {", "connector    =    getConnectorServer (  )  ;", "connector . start (  )  ;", "assertEquals (  \" Incorrect   MBean   count \"  ,    getServer (  )  . getMBeanCount (  )  ,    connection . getMBeanCount (  )  )  ;", "}    finally    {", "bean . destroy (  )  ;", "if    ( connector    !  =    null )     {", "connector . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testTestWithLazyConnection"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServerConnectionFactoryBean   bean    =    new   MBeanServerConnectionFactoryBean (  )  ;", "bean . setServiceUrl ( serviceUrl )  ;", "bean . setConnectOnStartup ( false )  ;", "bean . afterPropertiesSet (  )  ;", "MBeanServerConnection   connection    =    bean . getObject (  )  ;", "assertTrue ( AopUtils . isAopProxy ( connection )  )  ;", "bean . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["testWithLazyConnectionAndNoAccess"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServerConnectionFactoryBean   bean    =    new   MBeanServerConnectionFactoryBean (  )  ;", "bean . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testWithNoServiceUrl"], "fileName": "org.springframework.jmx.support.MBeanServerConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "if    ( registerWithFactory )     {", "return    . createMBeanServer ( defaultDomain )  ;", "} else    {", "return    . newMBeanServer ( defaultDomain )  ;", "}", "}", "METHOD_END"], "methodName": ["createMBeanServer"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   JmxUtils . locateMBeanServer ( agentId )  ;", "}", "METHOD_END"], "methodName": ["locateMBeanServer"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . agentId    =    agentId ;", "}", "METHOD_END"], "methodName": ["setAgentId"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . defaultDomain    =    defaultDomain ;", "}", "METHOD_END"], "methodName": ["setDefaultDomain"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . locateExistingServerIfPossible    =    locateExistingServerIfPossible ;", "}", "METHOD_END"], "methodName": ["setLocateExistingServerIfPossible"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . registerWithFactory    =    registerWithFactory ;", "}", "METHOD_END"], "methodName": ["setRegisterWithFactory"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "testCreation ( true ,     \" The   server   should   be   available   in   the   list \"  )  ;", "}", "METHOD_END"], "methodName": ["createMBeanServer"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServerFactoryBean   bean    =    new   MBeanServerFactoryBean (  )  ;", "bean . setDefaultDomain (  \" foo \"  )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "MBeanServer   server    =    bean . getObject (  )  ;", "assertEquals (  \" The   default   domain   should   be   foo \"  ,     \" foo \"  ,    server . getDefaultDomain (  )  )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["defaultDomain"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServerFactoryBean   bean    =    new   MBeanServerFactoryBean (  )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "MBeanServer   server    =    bean . getObject (  )  ;", "assertNotNull (  \" The   MBeanServer   should   not   be   null \"  ,    server )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getObject"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "testCreation ( false ,     \" The   server   should   not   be   available   in   the   list \"  )  ;", "}", "METHOD_END"], "methodName": ["newMBeanServer"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanTestUtils . resetMBeanServers (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanTestUtils . resetMBeanServers (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServerFactoryBean   bean    =    new   MBeanServerFactoryBean (  )  ;", "bean . setRegisterWithFactory ( referenceShouldExist )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "MBeanServer   server    =    bean . getObject (  )  ;", "List < MBeanServer >    servers    =    MBeanServerFactory . findMBeanServer ( null )  ;", "boolean   found    =    false ;", "for    ( MBeanServer   candidate    :    servers )     {", "if    ( candidate    =  =    server )     {", "found    =    true ;", "break ;", "}", "}", "if    (  !  ( found    =  =    referenceShouldExist )  )     {", "fail ( failMsg )  ;", "}", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCreation"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServerFactoryBean   bean    =    new   MBeanServerFactoryBean (  )  ;", "bean . setAgentId (  \"  \"  )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "assertSame ( ManagementFactory . getPlatformMBeanServer (  )  ,    bean . getObject (  )  )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["withEmptyAgentIdAndFallbackToPlatformServer"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServer   server    =    MBeanServerFactory . createMBeanServer (  )  ;", "try    {", "bean    =    new    (  )  ;", "bean . setLocateExistingServerIfPossible ( true )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "MBeanServer   otherServer    =    bean . getObject (  )  ;", "assertSame (  \" Existing   MBeanServer   not   located \"  ,    server ,    otherServer )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}    finally    {", "MBeanServerFactory . releaseMBeanServer ( server )  ;", "}", "}", "METHOD_END"], "methodName": ["withLocateExistingAndExistingServer"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServerFactoryBean   bean    =    new   MBeanServerFactoryBean (  )  ;", "bean . setLocateExistingServerIfPossible ( true )  ;", "bean . afterPropertiesSet (  )  ;", "try    {", "assertSame ( ManagementFactory . getPlatformMBeanServer (  )  ,    bean . getObject (  )  )  ;", "}    finally    {", "bean . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["withLocateExistingAndFallbackToPlatformServer"], "fileName": "org.springframework.jmx.support.MBeanServerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   this . handback ;", "}", "METHOD_END"], "methodName": ["getHandback"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . notificationFilter ;", "}", "METHOD_END"], "methodName": ["getNotificationFilter"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . notificationListener ;", "}", "METHOD_END"], "methodName": ["getNotificationListener"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . mappedObjectNames )     =  =    null )     {", "return   null ;", "}", "ObjectName [  ]    resolved    =    new   ObjectName [ this . mappedObjectNames . size (  )  ]  ;", "int   i    =     0  ;", "for    ( Object   objectName    :    this . mappedObjectNames )     {", "resolved [ i ]     =    ObjectNameManager . getInstance ( objectName )  ;", "i +  +  ;", "}", "return   resolved ;", "}", "METHOD_END"], "methodName": ["getResolvedObjectNames"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "this . handback    =    handback ;", "}", "METHOD_END"], "methodName": ["setHandback"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "this . mappedObjectNames    =     ( mappedObjectName    !  =    null )     ?    new   LinkedHashSet <  >  ( Collections . singleton ( mappedObjectName )  )     :    null ;", "}", "METHOD_END"], "methodName": ["setMappedObjectName"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "this . mappedObjectNames    =    new   LinkedHashSet <  >  ( Arrays . asList ( mappedObjectNames )  )  ;", "}", "METHOD_END"], "methodName": ["setMappedObjectNames"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "this . notificationFilter    =    notificationFilter ;", "}", "METHOD_END"], "methodName": ["setNotificationFilter"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "this . notificationListener    =    notificationListener ;", "}", "METHOD_END"], "methodName": ["setNotificationListener"], "fileName": "org.springframework.jmx.support.NotificationListenerHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( objectName   instanceof   ObjectName )     {", "return    (  ( ObjectName )     ( objectName )  )  ;", "}", "if    (  !  ( objectName   instanceof   String )  )     {", "throw   new   MalformedObjectNameException (  (  (  \" Invalid   ObjectName   value   type    [  \"     +     ( objectName . getClass (  )  . getName (  )  )  )     +     \"  ]  :    only   ObjectName   and   String   supported .  \"  )  )  ;", "}", "return    . getInstance (  (  ( String )     ( objectName )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jmx.support.ObjectNameManager"}, {"methodBody": ["METHOD_START", "{", "return   ObjectName . getInstance ( objectName )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jmx.support.ObjectNameManager"}, {"methodBody": ["METHOD_START", "{", "return   ObjectName . getInstance ( domainName ,    key ,    value )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jmx.support.ObjectNameManager"}, {"methodBody": ["METHOD_START", "{", "return   ObjectName . getInstance ( domainName ,    properties )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jmx.support.ObjectNameManager"}, {"methodBody": ["METHOD_START", "{", "return   this . jndiTemplate . getEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["getJndiEnvironment"], "fileName": "org.springframework.jndi.JndiAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . jndiTemplate ;", "}", "METHOD_END"], "methodName": ["getJndiTemplate"], "fileName": "org.springframework.jndi.JndiAccessor"}, {"methodBody": ["METHOD_START", "{", "this . jndiTemplate    =    new   JndiTemplate ( jndiEnvironment )  ;", "}", "METHOD_END"], "methodName": ["setJndiEnvironment"], "fileName": "org.springframework.jndi.JndiAccessor"}, {"methodBody": ["METHOD_START", "{", "this . jndiTemplate    =     ( jndiTemplate    !  =    null )     ?    jndiTemplate    :    new   JndiTemplate (  )  ;", "}", "METHOD_END"], "methodName": ["setJndiTemplate"], "fileName": "org.springframework.jndi.JndiAccessor"}, {"methodBody": ["METHOD_START", "{", "JndiLocatorDelegate   jndiLocator    =    new   JndiLocatorDelegate (  )  ;", "jndiLocator . setResourceRef ( true )  ;", "return   jndiLocator ;", "}", "METHOD_END"], "methodName": ["createDefaultResourceRefLocator"], "fileName": "org.springframework.jndi.JndiLocatorDelegate"}, {"methodBody": ["METHOD_START", "{", "if    ( JndiLocatorDelegate . shouldIgnoreDefaultJndiEnvironment )     {", "return   false ;", "}", "try    {", "new   InitialContext (  )  . getEnvironment (  )  ;", "return   true ;", "}    catch    ( Throwable   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isDefaultJndiEnvironmentAvailable"], "fileName": "org.springframework.jndi.JndiLocatorDelegate"}, {"methodBody": ["METHOD_START", "{", "Field   builderField    =    NamingManager . class . getDeclaredField (  \" initctx _ factory _ builder \"  )  ;", "builderField . setAccessible ( true )  ;", "Object   oldBuilder    =    builderField . get ( null )  ;", "builderField . set ( null ,    null )  ;", "try    {", "assertThat (  . isDefaultJndiEnvironmentAvailable (  )  ,    equalTo ( false )  )  ;", "}    finally    {", "builderField . set ( null ,    oldBuilder )  ;", "}", "}", "METHOD_END"], "methodName": ["isDefaultJndiEnvironmentAvailableFalse"], "fileName": "org.springframework.jndi.JndiLocatorDelegateTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( isResourceRef (  )  )     &  &     (  !  ( jndiName . startsWith ( JndiLocatorSupport . CONTAINER _ PREFIX )  )  )  )     &  &     (  ( jndiName . indexOf (  '  :  '  )  )     =  =     (  -  1  )  )  )     {", "jndiName    =     ( JndiLocatorSupport . CONTAINER _ PREFIX )     +    jndiName ;", "}", "return   jndiName ;", "}", "METHOD_END"], "methodName": ["convertJndiName"], "fileName": "org.springframework.jndi.JndiLocatorSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceRef ;", "}", "METHOD_END"], "methodName": ["isResourceRef"], "fileName": "org.springframework.jndi.JndiLocatorSupport"}, {"methodBody": ["METHOD_START", "{", "return   lookup ( jndiName ,    null )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.springframework.jndi.JndiLocatorSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( jndiName ,     \"  ' jndiName '    must   not   be   null \"  )  ;", "String   convertedName    =    convertJndiName ( jndiName )  ;", "T   jndiObject ;", "try    {", "jndiObject    =    getJndiTemplate (  )  . lookup ( convertedName ,    requiredType )  ;", "}    catch    ( NamingException   ex )     {", "if    (  !  ( convertedName . equals ( jndiName )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  \" Converted   JNDI   name    [  \"     +    convertedName )     +     \"  ]    not   found    -    trying   original   name    [  \"  )     +    jndiName )     +     \"  ]  .     \"  )     +    ex )  )  ;", "}", "jndiObject    =    getJndiTemplate (  )  . lookup ( jndiName ,    requiredType )  ;", "} else    {", "throw   ex ;", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" ed   object   with   JNDI   name    [  \"     +    convertedName )     +     \"  ]  \"  )  )  ;", "}", "return   jndiObject ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.springframework.jndi.JndiLocatorSupport"}, {"methodBody": ["METHOD_START", "{", "this . resourceRef    =    resourceRef ;", "}", "METHOD_END"], "methodName": ["setResourceRef"], "fileName": "org.springframework.jndi.JndiLocatorSupport"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . createCompositeInterface ( interfaces ,    this . beanClassLoader )  ;", "}", "METHOD_END"], "methodName": ["createCompositeInterface"], "fileName": "org.springframework.jndi.JndiObjectFactoryBean"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   originalClassLoader    =    ClassUtils . overrideThreadContextClassLoader ( this . beanClassLoader )  ;", "try    {", "return   lookup (  )  ;", "}    catch    ( TypeMismatchNamingException   ex )     {", "throw   ex ;", "}    catch    ( NamingException   ex )     {", "if    (  ( this . default )     !  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" JNDI   lookup   failed    -    returning   specified   default   object   instead \"  ,    ex )  ;", "} else", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" JNDI   lookup   failed    -    returning   specified   default   object   instead :     \"     +    ex )  )  ;", "}", "return   this . default ;", "}", "throw   ex ;", "}    finally    {", "if    ( originalClassLoader    !  =    null )     {", "Thread . currentThread (  )  . setContextClassLoader ( originalClassLoader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["lookupWithFallback"], "fileName": "org.springframework.jndi.JndiObjectFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cache    =    cache ;", "}", "METHOD_END"], "methodName": ["setCache"], "fileName": "org.springframework.jndi.JndiObjectFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . defaultObject    =    defaultObject ;", "}", "METHOD_END"], "methodName": ["setDefaultObject"], "fileName": "org.springframework.jndi.JndiObjectFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . exposeAccessContext    =    exposeAccessContext ;", "}", "METHOD_END"], "methodName": ["setExposeAccessContext"], "fileName": "org.springframework.jndi.JndiObjectFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . lookupOnStartup    =    lookupOnStartup ;", "}", "METHOD_END"], "methodName": ["setLookupOnStartup"], "fileName": "org.springframework.jndi.JndiObjectFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . proxyInterfaces    =    new   Class <  ?  >  [  ]  {    proxyInterface    }  ;", "}", "METHOD_END"], "methodName": ["setProxyInterface"], "fileName": "org.springframework.jndi.JndiObjectFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . proxyInterfaces    =    proxyInterfaces ;", "}", "METHOD_END"], "methodName": ["setProxyInterfaces"], "fileName": "org.springframework.jndi.JndiObjectFactoryBean"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setLookupOnStartup ( false )  ;", "try    {", "jof . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLazyLookupWithoutProxyInterface"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "Object   o    =    new   Object (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,    o )  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setResourceRef ( false )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )     =  =    o )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithArbitraryNameAndResourceRefFalse"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,     \"  \"  )  )  ;", "jof . setJndiName (  \" myFoo \"  )  ;", "jof . setExpectedType ( String . class )  ;", "jof . setDefaultObject (  \" myString \"  )  ;", "jof . afterPropertiesSet (  )  ;", "assertEquals (  \" myString \"  ,    jof . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithDefaultObject"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,     \"  \"  )  )  ;", "jof . setJndiName (  \" myFoo \"  )  ;", "jof . setExpectedType ( String . class )  ;", "jof . setDefaultObject (  \" myString \"  )  ;", "jof . afterPropertiesSet (  )  ;", "assertEquals (  \" myString \"  ,    jof . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithDefaultObjectAndExpectedType"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,     \"  \"  )  )  ;", "jof . setJndiName (  \" myFoo \"  )  ;", "jof . setExpectedType ( Integer . class )  ;", "jof . setDefaultObject (  \"  5  \"  )  ;", "jof . afterPropertiesSet (  )  ;", "assertEquals ( new   Integer (  5  )  ,    jof . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithDefaultObjectAndExpectedTypeConversion"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,     \"  \"  )  )  ;", "jof . setJndiName (  \" myFoo \"  )  ;", "jof . setExpectedType ( Integer . class )  ;", "jof . setDefaultObject (  \"  5  \"  )  ;", "jof . setBeanFactory ( new   DefaultListableBeanFactory (  )  )  ;", "jof . afterPropertiesSet (  )  ;", "assertEquals ( new   Integer (  5  )  ,    jof . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithDefaultObjectAndExpectedTypeConversionViaBeanFactory"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,     \"  \"  )  )  ;", "jof . setJndiName (  \" myFoo \"  )  ;", "jof . setExpectedType ( Boolean . class )  ;", "jof . setDefaultObject (  \"  5  \"  )  ;", "try    {", "jof . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLookupWithDefaultObjectAndExpectedTypeNoMatch"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "String   s    =     \"  \"  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,    s )  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setExpectedType ( String . class )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )     =  =    s )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithExpectedTypeAndMatch"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,    new   Object (  )  )  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setExpectedType ( String . class )  ;", "try    {", "jof . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   NamingException \"  )  ;", "}    catch    ( NamingException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" String \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testLookupWithExpectedTypeAndNoMatch"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "final   Context   mockCtx    =    mock ( Context . class )  ;", "given ( mockCtx . lookup (  \" foo \"  )  )  . willReturn ( tb )  ;", "jof . setJndiTemplate ( new   JndiTemplate (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   mockCtx ;", "}", "}  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setProxyInterface ( ITestBean . class )  ;", "jof . setExposeAccessContext ( true )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( jof . getObject (  )  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "proxy . setAge (  9  9  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "proxy . equals ( proxy )  ;", "proxy . hashCode (  )  ;", "proxy . toString (  )  ;", "verify ( mockCtx ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithExposeAccessContext"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "Object   o    =    new   Object (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" java : comp / env / foo \"  ,    o )  )  ;", "jof . setJndiName (  \" java : comp / env / foo \"  )  ;", "jof . setResourceRef ( false )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )     =  =    o )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithFullNameAndResourceRefFalse"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "Object   o    =    new   Object (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" java : comp / env / foo \"  ,    o )  )  ;", "jof . setJndiName (  \" java : comp / env / foo \"  )  ;", "jof . setResourceRef ( true )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )     =  =    o )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithFullNameAndResourceRefTrue"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,    tb )  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setProxyInterface ( ITestBean . class )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( jof . getObject (  )  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "proxy . setAge (  9  9  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithProxyInterface"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,    tb )  )  ;", "jof . setJndiName (  \" myFoo \"  )  ;", "jof . setProxyInterface ( ITestBean . class )  ;", "jof . setDefaultObject ( Boolean . TRUE )  ;", "try    {", "jof . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLookupWithProxyInterfaceAndDefaultObject"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,    tb )  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setExpectedType ( TestBean . class )  ;", "jof . setProxyInterface ( ITestBean . class )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( jof . getObject (  )  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "proxy . setAge (  9  9  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithProxyInterfaceAndExpectedTypeAndMatch"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" foo \"  ,    tb )  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setExpectedType ( DerivedTestBean . class )  ;", "jof . setProxyInterface ( ITestBean . class )  ;", "try    {", "jof . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   NamingException \"  )  ;", "}    catch    ( NamingException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" DerivedTestBean \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testLookupWithProxyInterfaceAndExpectedTypeAndNoMatch"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "final   TestBean   tb    =    new   TestBean (  )  ;", "jof . setJndiTemplate ( new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )     {", "if    (  \" foo \"  . equals ( name )  )     {", "tb . setName (  \" tb \"  )  ;", "return   tb ;", "}", "return   null ;", "}", "}  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setProxyInterface ( ITestBean . class )  ;", "jof . setLookupOnStartup ( false )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( jof . getObject (  )  )  )  ;", "assertNull ( tb . getName (  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "proxy . setAge (  9  9  )  ;", "assertEquals (  \" tb \"  ,    tb . getName (  )  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithProxyInterfaceAndLazyLookup"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "final   TestBean   tb    =    new   TestBean (  )  ;", "jof . setJndiTemplate ( new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )     {", "if    (  \" foo \"  . equals ( name )  )     {", "tb . setName (  \" tb \"  )  ;", "tb . setAge (  (  ( tb . getAge (  )  )     +     1  )  )  ;", "return   tb ;", "}", "return   null ;", "}", "}  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setProxyInterface ( ITestBean . class )  ;", "jof . setLookupOnStartup ( false )  ;", "jof . setCache ( false )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( jof . getObject (  )  )  )  ;", "assertNull ( tb . getName (  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "proxy . returnsThis (  )  ;", "assertEquals (  \" tb \"  ,    tb . getName (  )  )  ;", "assertEquals (  1  ,    tb . getAge (  )  )  ;", "proxy . returnsThis (  )  ;", "assertEquals (  2  ,    tb . getAge (  )  )  ;", "proxy . haveBirthday (  )  ;", "assertEquals (  4  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithProxyInterfaceWithLazyLookupAndNotCache"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "final   TestBean   tb    =    new   TestBean (  )  ;", "jof . setJndiTemplate ( new   JndiTemplate (  )     {", "@ Override", "public   Object   lookup ( String   name )     {", "if    (  \" foo \"  . equals ( name )  )     {", "tb . setName (  \" tb \"  )  ;", "tb . setAge (  (  ( tb . getAge (  )  )     +     1  )  )  ;", "return   tb ;", "}", "return   null ;", "}", "}  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setProxyInterface ( ITestBean . class )  ;", "jof . setCache ( false )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )    instanceof   ITestBean )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( jof . getObject (  )  )  )  ;", "assertEquals (  \" tb \"  ,    tb . getName (  )  )  ;", "assertEquals (  1  ,    tb . getAge (  )  )  ;", "proxy . returnsThis (  )  ;", "assertEquals (  2  ,    tb . getAge (  )  )  ;", "proxy . haveBirthday (  )  ;", "assertEquals (  4  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithProxyInterfaceWithNotCache"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "Object   o    =    new   Object (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" java : foo \"  ,    o )  )  ;", "jof . setJndiName (  \" java : foo \"  )  ;", "jof . setResourceRef ( false )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )     =  =    o )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithSchemeNameAndResourceRefFalse"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "Object   o    =    new   Object (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" java : foo \"  ,    o )  )  ;", "jof . setJndiName (  \" java : foo \"  )  ;", "jof . setResourceRef ( true )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )     =  =    o )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithSchemeNameAndResourceRefTrue"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "Object   o    =    new   Object (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" java : comp / env / foo \"  ,    o )  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setResourceRef ( false )  ;", "try    {", "jof . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   NamingException \"  )  ;", "}    catch    ( NamingException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLookupWithShortNameAndResourceRefFalse"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "Object   o    =    new   Object (  )  ;", "jof . setJndiTemplate ( new   ExpectedLookupTemplate (  \" java : comp / env / foo \"  ,    o )  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setResourceRef ( true )  ;", "jof . afterPropertiesSet (  )  ;", "assertTrue (  (  ( jof . getObject (  )  )     =  =    o )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupWithShortNameAndResourceRefTrue"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "try    {", "jof . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testNoJndiName"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "JndiObjectFactoryBean   jof    =    new   JndiObjectFactoryBean (  )  ;", "jof . setJndiName (  \" foo \"  )  ;", "jof . setCache ( false )  ;", "jof . setLookupOnStartup ( false )  ;", "try    {", "jof . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testNotCacheWithoutProxyInterface"], "fileName": "org.springframework.jndi.JndiObjectFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   this . expectedType ;", "}", "METHOD_END"], "methodName": ["getExpectedType"], "fileName": "org.springframework.jndi.JndiObjectLocator"}, {"methodBody": ["METHOD_START", "{", "return   this . jndiName ;", "}", "METHOD_END"], "methodName": ["getJndiName"], "fileName": "org.springframework.jndi.JndiObjectLocator"}, {"methodBody": ["METHOD_START", "{", "String   jndiName    =    getJndiName (  )  ;", "Assert . state (  ( jndiName    !  =    null )  ,     \" No   JNDI   name   specified \"  )  ;", "return   lookup ( jndiName ,    getExpectedType (  )  )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.springframework.jndi.JndiObjectLocator"}, {"methodBody": ["METHOD_START", "{", "this . expectedType    =    expectedType ;", "}", "METHOD_END"], "methodName": ["setExpectedType"], "fileName": "org.springframework.jndi.JndiObjectLocator"}, {"methodBody": ["METHOD_START", "{", "this . jndiName    =    jndiName ;", "}", "METHOD_END"], "methodName": ["setJndiName"], "fileName": "org.springframework.jndi.JndiObjectLocator"}, {"methodBody": ["METHOD_START", "{", "this . cache    =    cache ;", "}", "METHOD_END"], "methodName": ["setCache"], "fileName": "org.springframework.jndi.JndiObjectTargetSource"}, {"methodBody": ["METHOD_START", "{", "this . lookupOnStartup    =    lookupOnStartup ;", "}", "METHOD_END"], "methodName": ["setLookupOnStartup"], "fileName": "org.springframework.jndi.JndiObjectTargetSource"}, {"methodBody": ["METHOD_START", "{", "final   SimpleNamingContext   context    =    new   SimpleNamingContext (  )  ;", "context . bind (  \" java : comp / env / p 1  \"  ,     \" v 1  \"  )  ;", "JndiTemplate   jndiTemplate    =    new   JndiTemplate (  )     {", "@ Override", "protected   Context   createInitialContext (  )    throws   NamingException    {", "return   context ;", "}", "}  ;", "JndiLocatorDelegate   jndiLocator    =    new   JndiLocatorDelegate (  )  ;", "jndiLocator . setResourceRef ( true )  ;", "jndiLocator . setJndiTemplate ( jndiTemplate )  ;", "ps    =    new    (  \" jndiProperties \"  ,    jndiLocator )  ;", "assertThat ( ps . getProperty (  \" p 1  \"  )  ,    equalTo (  \" v 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["nameBoundWithPrefix"], "fileName": "org.springframework.jndi.JndiPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleNamingContext   context    =    new   SimpleNamingContext (  )  ;", "context . bind (  \" p 1  \"  ,     \" v 1  \"  )  ;", "JndiTemplate   jndiTemplate    =    new   JndiTemplate (  )     {", "@ Override", "protected   Context   createInitialContext (  )    throws   NamingException    {", "return   context ;", "}", "}  ;", "JndiLocatorDelegate   jndiLocator    =    new   JndiLocatorDelegate (  )  ;", "jndiLocator . setResourceRef ( true )  ;", "jndiLocator . setJndiTemplate ( jndiTemplate )  ;", "ps    =    new    (  \" jndiProperties \"  ,    jndiLocator )  ;", "assertThat ( ps . getProperty (  \" p 1  \"  )  ,    equalTo (  \" v 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["nameBoundWithoutPrefix"], "fileName": "org.springframework.jndi.JndiPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "JndiPropertySource   ps    =    new   JndiPropertySource (  \" jndiProperties \"  )  ;", "assertThat ( ps . getProperty (  \" bogus \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["nonExistentProperty"], "fileName": "org.springframework.jndi.JndiPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "JndiLocatorDelegate   jndiLocator    =    new   JndiLocatorDelegate (  )     {", "@ Override", "public   Object   lookup ( String   jndiName )    throws   NamingException    {", "assertEquals (  \" my : key \"  ,    jndiName )  ;", "return    \" my : value \"  ;", "}", "}  ;", "jndiLocator . setResourceRef ( false )  ;", "ps    =    new    (  \" jndiProperties \"  ,    jndiLocator )  ;", "assertThat ( ps . getProperty (  \" my : key \"  )  ,    equalTo (  \" my : value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyWithColonInNonResourceRefMode"], "fileName": "org.springframework.jndi.JndiPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "JndiLocatorDelegate   jndiLocator    =    new   JndiLocatorDelegate (  )     {", "@ Override", "public   Object   lookup ( String   jndiName )    throws   NamingException    {", "throw   new   IllegalStateException (  \" Should   not   get   called \"  )  ;", "}", "}  ;", "jndiLocator . setResourceRef ( true )  ;", "ps    =    new    (  \" jndiProperties \"  ,    jndiLocator )  ;", "assertThat ( ps . getProperty (  \" propertyKey : defaultValue \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyWithDefaultClauseInResourceRefMode"], "fileName": "org.springframework.jndi.JndiPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Bind   JNDI   object   with   name    [  \"     +    name )     +     \"  ]  \"  )  )  ;", "}", "execute (  (    ctx )     -  >     {", "ctx . bind ( name ,    object )  ;", "return   null ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "Hashtable <  ?  ,     ?  >    icEnv    =    null ;", "Properties   env    =    getEnvironnt (  )  ;", "if    ( env    !  =    null )     {", "icEnv    =    new   Hashtable <  >  ( env . size (  )  )  ;", "CollectionUtils . rgePropertiesIntoMap ( env ,    icEnv )  ;", "}", "return   new   InitialContext ( icEnv )  ;", "}", "METHOD_END"], "methodName": ["createInitialContext"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "Context   ctx    =    getContext (  )  ;", "try    {", "return   contextCallback . doInContext ( ctx )  ;", "}    finally    {", "releaseContext ( ctx )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "return   createInitialContext (  )  ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . environment ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Look   up   JNDI   object   with   name    [  \"     +    name )     +     \"  ]  \"  )  )  ;", "}", "Object   result    =    execute (  (    ctx )     -  >    ctx . lookup ( name )  )  ;", "if    ( result    =  =    null )     {", "throw   new   NameNotFoundException (  (  (  \" JNDI   object   with    [  \"     +    name )     +     \"  ]    not   found :    JNDI   implementation   returned   null \"  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "Object   jndiObject    =    lookup ( name )  ;", "if    (  ( requiredType    !  =    null )     &  &     (  !  ( requiredType . isInstance ( jndiObject )  )  )  )     {", "throw   new   TypeMismatchNamingException ( name ,    requiredType ,    jndiObject . getClass (  )  )  ;", "}", "return    (  ( T )     ( jndiObject )  )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Rebind   JNDI   object   with   name    [  \"     +    name )     +     \"  ]  \"  )  )  ;", "}", "execute (  (    ctx )     -  >     {", "ctx . rebind ( name ,    object )  ;", "return   null ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( ctx    !  =    null )     {", "try    {", "ctx . close (  )  ;", "}    catch    ( NamException   ex )     {", "logger . debug (  \" Could   not   close   JNDI   InitialContext \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["releaseContext"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "this . environment    =    environment ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Unbind   JNDI   object   with   name    [  \"     +    name )     +     \"  ]  \"  )  )  ;", "}", "execute (  (    ctx )     -  >     {", "ctx . unbind ( name )  ;", "return   null ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "org.springframework.jndi.JndiTemplate"}, {"methodBody": ["METHOD_START", "{", "JndiTemplateEditor   je    =    new   JndiTemplateEditor (  )  ;", "je . setAsText (  \" jndiInitialSomethingOrOther = myjndi . CompleteRubbish \\ nfoo = bar \"  )  ;", "JndiTemplate   jt    =     (  ( JndiTemplate )     ( je . getValue (  )  )  )  ;", "assertTrue (  (  ( jt . getEnvironment (  )  . size (  )  )     =  =     2  )  )  ;", "assertTrue ( jt . getEnvironment (  )  . getProperty (  \" jndiInitialSomethingOrOther \"  )  . equals (  \" myjndi . CompleteRubbish \"  )  )  ;", "assertTrue ( jt . getEnvironment (  )  . getProperty (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnvironment"], "fileName": "org.springframework.jndi.JndiTemplateEditorTests"}, {"methodBody": ["METHOD_START", "{", "JndiTemplateEditor   je    =    new   JndiTemplateEditor (  )  ;", "je . setAsText (  \"  \"  )  ;", "JndiTemplate   jt    =     (  ( JndiTemplate )     ( je . getValue (  )  )  )  ;", "assertTrue (  (  ( jt . getEnvironment (  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyStringMeansNullEnvironment"], "fileName": "org.springframework.jndi.JndiTemplateEditorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  )  . setAsText ( null )  ;", "fail (  \" Null   is   illegal \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testNullIsIllegalArgument"], "fileName": "org.springframework.jndi.JndiTemplateEditorTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    new   Object (  )  ;", "String   name    =     \" foo \"  ;", "final   Context   context    =    mock ( Context . class )  ;", "jt    =    new    (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   context ;", "}", "}  ;", "jt . bind ( name ,    o )  ;", "verify ( context )  . bind ( name ,    o )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBind"], "fileName": "org.springframework.jndi.JndiTemplateTests"}, {"methodBody": ["METHOD_START", "{", "NameNotFoundException   ne    =    new   NameNotFoundException (  )  ;", "String   name    =     \" foo \"  ;", "final   Context   context    =    mock ( Context . class )  ;", "given ( context . lookup ( name )  )  . willThrow ( ne )  ;", "jt    =    new    (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   context ;", "}", "}  ;", "try    {", "jt . lookup ( name )  ;", "fail (  \" Should   have   thrown   NamingException \"  )  ;", "}    catch    ( NameNotFoundException   ex )     {", "}", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testLookupFails"], "fileName": "org.springframework.jndi.JndiTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    new   Object (  )  ;", "String   name    =     \" foo \"  ;", "final   Context   context    =    mock ( Context . class )  ;", "given ( context . lookup ( name )  )  . willReturn ( o )  ;", "jt    =    new    (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   context ;", "}", "}  ;", "try    {", "jt . lookup ( name ,    String . class )  ;", "fail (  \" Should   have   thrown   TypeMismatchNamingException \"  )  ;", "}    catch    ( TypeMismatchNamingException   ex )     {", "}", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testLookupFailsWithTypeMismatch"], "fileName": "org.springframework.jndi.JndiTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "final   Context   context    =    mock ( Context . class )  ;", "given ( context . lookup ( name )  )  . willReturn ( null )  ;", "jt    =    new    (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   context ;", "}", "}  ;", "try    {", "jt . lookup ( name )  ;", "fail (  \" Should   have   thrown   NamingException \"  )  ;", "}    catch    ( NameNotFoundException   ex )     {", "}", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testLookupReturnsNull"], "fileName": "org.springframework.jndi.JndiTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    new   Object (  )  ;", "String   name    =     \" foo \"  ;", "final   Context   context    =    mock ( Context . class )  ;", "given ( context . lookup ( name )  )  . willReturn ( o )  ;", "jt    =    new    (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   context ;", "}", "}  ;", "Object   o 2     =    jt . lookup ( name )  ;", "assertEquals ( o ,    o 2  )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testLookupSucceeds"], "fileName": "org.springframework.jndi.JndiTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    new   Object (  )  ;", "String   name    =     \" foo \"  ;", "final   Context   context    =    mock ( Context . class )  ;", "jt    =    new    (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   context ;", "}", "}  ;", "jt . rebind ( name ,    o )  ;", "verify ( context )  . rebind ( name ,    o )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testRebind"], "fileName": "org.springframework.jndi.JndiTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" something \"  ;", "final   Context   context    =    mock ( Context . class )  ;", "jt    =    new    (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return   context ;", "}", "}  ;", "jt . unbind ( name )  ;", "verify ( context )  . unbind ( name )  ;", "verify ( context )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testUnbind"], "fileName": "org.springframework.jndi.JndiTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SimpleNamingContextBuilder   builder    =    SimpleNamingContextBuilder . emptyActivatedContextBuilder (  )  ;", "String   name    =     \" foo \"  ;", "Object   o    =    new   Object (  )  ;", "builder . bind ( name ,    o )  ;", "Context   ctx    =    new   InitialContext (  )  ;", "assertTrue (  (  ( ctx . lookup ( name )  )     =  =    o )  )  ;", "ctx . unbind ( name )  ;", "try    {", "ctx    =    new   InitialContext (  )  ;", "ctx . lookup ( name )  ;", "fail (  \" Should   have   thrown   NamingException \"  )  ;", "}    catch    ( NamingException   ex )     {", "}", "builder    =    SimpleNamingContextBuilder . emptyActivatedContextBuilder (  )  ;", "try    {", "ctx    =    new   InitialContext (  )  ;", "ctx . lookup ( name )  ;", "fail (  \" Should   have   thrown   NamingException \"  )  ;", "}    catch    ( NamingException   ex )     {", "}", "Object   o 2     =    new   Object (  )  ;", "builder . bind ( name ,    o 2  )  ;", "assertEquals ( ctx . lookup ( name )  ,    o 2  )  ;", "}", "METHOD_END"], "methodName": ["testCreateInitialContext"], "fileName": "org.springframework.jndi.SimpleNamingContextTests"}, {"methodBody": ["METHOD_START", "{", "SimpleNamingContextBuilder   builder    =    new   SimpleNamingContextBuilder (  )  ;", "InitialContextFactory   factory    =    builder . createInitialContextFactory ( null )  ;", "DataSource   ds    =    new    . StubDataSource (  )  ;", "builder . bind (  \" java : comp / env / jdbc / myds \"  ,    ds )  ;", "Object   obj    =    new   Object (  )  ;", "builder . bind (  \" myobject \"  ,    obj )  ;", "Context   context 1     =    factory . getInitialContext ( null )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     (  ( context 1  . lookup (  \" java : comp / env / jdbc / myds \"  )  )     =  =    ds )  )  ;", "assertTrue (  \" Correct   Object   registered \"  ,     (  ( context 1  . lookup (  \" myobject \"  )  )     =  =    obj )  )  ;", "Hashtable < String ,    String >    env 2     =    new   Hashtable <  >  (  )  ;", "env 2  . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "Context   context 2     =    factory . getInitialContext ( env 2  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     (  ( context 2  . lookup (  \" java : comp / env / jdbc / myds \"  )  )     =  =    ds )  )  ;", "assertTrue (  \" Correct   Object   registered \"  ,     (  ( context 2  . lookup (  \" myobject \"  )  )     =  =    obj )  )  ;", "assertTrue (  \" Correct   environment \"  ,     (  ( context 2  . getEnvironment (  )  )     !  =    env 2  )  )  ;", "assertTrue (  \" Correct   key 1  \"  ,     \" value 1  \"  . equals ( context 2  . getEnvironment (  )  . get (  \" key 1  \"  )  )  )  ;", "Integer   i    =    new   Integer (  0  )  ;", "context 1  . rebind (  \" myinteger \"  ,    i )  ;", "String   s    =     \"  \"  ;", "context 2  . bind (  \" mystring \"  ,    s )  ;", "Context   context 3     =     (  ( Context )     ( context 2  . lookup (  \"  \"  )  )  )  ;", "context 3  . rename (  \" java : comp / env / jdbc / myds \"  ,     \" jdbc / myds \"  )  ;", "context 3  . unbind (  \" myobject \"  )  ;", "assertTrue (  \" Correct   environment \"  ,     (  ( context 3  . getEnvironment (  )  )     !  =     ( context 2  . getEnvironment (  )  )  )  )  ;", "context 3  . addToEnvironment (  \" key 2  \"  ,     \" value 2  \"  )  ;", "assertTrue (  \" key 2    added \"  ,     \" value 2  \"  . equals ( context 3  . getEnvironment (  )  . get (  \" key 2  \"  )  )  )  ;", "context 3  . removeFromEnvironment (  \" key 1  \"  )  ;", "assertTrue (  \" key 1    removed \"  ,     (  ( context 3  . getEnvironment (  )  . get (  \" key 1  \"  )  )     =  =    null )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     (  ( context 1  . lookup (  \" jdbc / myds \"  )  )     =  =    ds )  )  ;", "try    {", "context 1  . lookup (  \" myobject \"  )  ;", "fail (  \" Should   have   thrown   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   ex )     {", "}", "assertTrue (  \" Correct   Integer   registered \"  ,     (  ( context 1  . lookup (  \" myinteger \"  )  )     =  =    i )  )  ;", "assertTrue (  \" Correct   String   registered \"  ,     (  ( context 1  . lookup (  \" mystring \"  )  )     =  =    s )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     (  ( context 2  . lookup (  \" jdbc / myds \"  )  )     =  =    ds )  )  ;", "try    {", "context 2  . lookup (  \" myobject \"  )  ;", "fail (  \" Should   have   thrown   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   ex )     {", "}", "assertTrue (  \" Correct   Integer   registered \"  ,     (  ( context 2  . lookup (  \" myinteger \"  )  )     =  =    i )  )  ;", "assertTrue (  \" Correct   String   registered \"  ,     (  ( context 2  . lookup (  \" mystring \"  )  )     =  =    s )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     (  ( context 3  . lookup (  \" jdbc / myds \"  )  )     =  =    ds )  )  ;", "try    {", "context 3  . lookup (  \" myobject \"  )  ;", "fail (  \" Should   have   thrown   NameNotFoundException \"  )  ;", "}    catch    ( NameNotFoundException   ex )     {", "}", "assertTrue (  \" Correct   Integer   registered \"  ,     (  ( context 3  . lookup (  \" myinteger \"  )  )     =  =    i )  )  ;", "assertTrue (  \" Correct   String   registered \"  ,     (  ( context 3  . lookup (  \" mystring \"  )  )     =  =    s )  )  ;", "Map < String ,    Binding >    bindingMap    =    new   HashMap <  >  (  )  ;", "NamingEnumeration <  ?  >    bindingEnum    =    context 3  . listBindings (  \"  \"  )  ;", "while    ( bindingEnum . hasMoreElements (  )  )     {", "Binding   binding    =     (  ( Binding )     ( bindingEnum . nextElement (  )  )  )  ;", "bindingMap . put ( binding . getName (  )  ,    binding )  ;", "}", "assertTrue (  \" Correct   jdbc   subcontext \"  ,     (  ( bindingMap . get (  \" jdbc \"  )  . getObject (  )  )    instanceof   Context )  )  ;", "assertTrue (  \" Correct   jdbc   subcontext \"  ,    SimpleNamingContext . class . getName (  )  . equals ( bindingMap . get (  \" jdbc \"  )  . getClassName (  )  )  )  ;", "Context   jdbcContext    =     (  ( Context )     ( context 3  . lookup (  \" jdbc \"  )  )  )  ;", "jdbcContext . bind (  \" mydsX \"  ,    ds )  ;", "Map < String ,    Binding >    subBindingMap    =    new   HashMap <  >  (  )  ;", "NamingEnumeration <  ?  >    subBindingEnum    =    jdbcContext . listBindings (  \"  \"  )  ;", "while    ( subBindingEnum . hasMoreElements (  )  )     {", "Binding   binding    =     (  ( Binding )     ( subBindingEnum . nextElement (  )  )  )  ;", "subBindingMap . put ( binding . getName (  )  ,    binding )  ;", "}", "assertTrue (  \" Correct   DataSource   registered \"  ,    ds . equals ( subBindingMap . get (  \" myds \"  )  . getObject (  )  )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     . StubDataSource . class . getName (  )  . equals ( subBindingMap . get (  \" myds \"  )  . getClassName (  )  )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,    ds . equals ( subBindingMap . get (  \" mydsX \"  )  . getObject (  )  )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     . StubDataSource . class . getName (  )  . equals ( subBindingMap . get (  \" mydsX \"  )  . getClassName (  )  )  )  ;", "assertTrue (  \" Correct   Integer   registered \"  ,    i . equals ( bindingMap . get (  \" myinteger \"  )  . getObject (  )  )  )  ;", "assertTrue (  \" Correct   Integer   registered \"  ,    Integer . class . getName (  )  . equals ( bindingMap . get (  \" myinteger \"  )  . getClassName (  )  )  )  ;", "assertTrue (  \" Correct   String   registered \"  ,    s . equals ( bindingMap . get (  \" mystring \"  )  . getObject (  )  )  )  ;", "assertTrue (  \" Correct   String   registered \"  ,    String . class . getName (  )  . equals ( bindingMap . get (  \" mystring \"  )  . getClassName (  )  )  )  ;", "context 1  . createSubcontext (  \" jdbc \"  )  . bind (  \" sub / subds \"  ,    ds )  ;", "Map < String ,    String >    pairMap    =    new   HashMap <  >  (  )  ;", "NamingEnumeration <  ?  >    pairEnum    =    context 2  . list (  \" jdbc \"  )  ;", "while    ( pairEnum . hasMore (  )  )     {", "NameClassPair   pair    =     (  ( NameClassPair )     ( pairEnum . next (  )  )  )  ;", "pairMap . put ( pair . getName (  )  ,    pair . getClassName (  )  )  ;", "}", "assertTrue (  \" Correct   sub   subcontext \"  ,    SimpleNamingContext . class . getName (  )  . equals ( pairMap . get (  \" sub \"  )  )  )  ;", "Context   subContext    =     (  ( Context )     ( context 2  . lookup (  \" jdbc / sub \"  )  )  )  ;", "Map < String ,    String >    subPairMap    =    new   HashMap <  >  (  )  ;", "NamingEnumeration <  ?  >    subPairEnum    =    subContext . list (  \"  \"  )  ;", "while    ( subPairEnum . hasMoreElements (  )  )     {", "NameClassPair   pair    =     (  ( NameClassPair )     ( subPairEnum . next (  )  )  )  ;", "subPairMap . put ( pair . getName (  )  ,    pair . getClassName (  )  )  ;", "}", "assertTrue (  \" Correct   DataSource   registered \"  ,     . StubDataSource . class . getName (  )  . equals ( subPairMap . get (  \" subds \"  )  )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     . StubDataSource . class . getName (  )  . equals ( pairMap . get (  \" myds \"  )  )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     . StubDataSource . class . getName (  )  . equals ( pairMap . get (  \" mydsX \"  )  )  )  ;", "pairMap . clear (  )  ;", "pairEnum    =    context 1  . list (  \" jdbc /  \"  )  ;", "while    ( pairEnum . hasMore (  )  )     {", "NameClassPair   pair    =     (  ( NameClassPair )     ( pairEnum . next (  )  )  )  ;", "pairMap . put ( pair . getName (  )  ,    pair . getClassName (  )  )  ;", "}", "assertTrue (  \" Correct   DataSource   registered \"  ,     . StubDataSource . class . getName (  )  . equals ( pairMap . get (  \" myds \"  )  )  )  ;", "assertTrue (  \" Correct   DataSource   registered \"  ,     . StubDataSource . class . getName (  )  . equals ( pairMap . get (  \" mydsX \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamingContextBuilder"], "fileName": "org.springframework.jndi.SimpleNamingContextTests"}, {"methodBody": ["METHOD_START", "{", "return   this . actualType ;", "}", "METHOD_END"], "methodName": ["getActualType"], "fileName": "org.springframework.jndi.TypeMismatchNamingException"}, {"methodBody": ["METHOD_START", "{", "return   this . requiredType ;", "}", "METHOD_END"], "methodName": ["getRequiredType"], "fileName": "org.springframework.jndi.TypeMismatchNamingException"}, {"methodBody": ["METHOD_START", "{", "this . shareableResources . add ( shareableResource )  ;", "}", "METHOD_END"], "methodName": ["addShareableResource"], "fileName": "org.springframework.jndi.support.SimpleJndiBeanFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . singletonObjects )     {", "if    ( this . singletonObjects . containsKey ( name )  )     {", "Object   Object    =    this . singletonObjects . get ( name )  ;", "if    (  ( requiredType    !  =    null )     &  &     (  !  ( requiredType . isInstance ( Object )  )  )  )     {", "throw   new   TypeMismatchNamingException ( convertJndiName ( name )  ,    requiredType ,     ( Object    !  =    null    ?    Object . getClass (  )     :    null )  )  ;", "}", "return    (  ( T )     ( Object )  )  ;", "}", "T   Object    =    lookup ( name ,    requiredType )  ;", "this . singletonObjects . put ( name ,    Object )  ;", "return   Object ;", "}", "}", "METHOD_END"], "methodName": ["doGetSingleton"], "fileName": "org.springframework.jndi.support.SimpleJndiBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( isSingleton ( name )  )     {", "return   doGetSingleton ( name ,    null )  . getClass (  )  ;", "} else    {", "synchronized ( this . resourceTypes )     {", "if    ( this . resourceTypes . containsKey ( name )  )     {", "return   this . resourceTypes . get ( name )  ;", "} else    {", "Class <  ?  >    type    =    lookup ( name ,    null )  . getClass (  )  ;", "this . resourceTypes . put ( name ,    type )  ;", "return   type ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["doGetType"], "fileName": "org.springframework.jndi.support.SimpleJndiBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Collections . addAll ( this . shareableResources ,    shareableResources )  ;", "}", "METHOD_END"], "methodName": ["setShareableResources"], "fileName": "org.springframework.jndi.support.SimpleJndiBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . propertySource . setProperty ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.mock.env.MockEnvironment"}, {"methodBody": ["METHOD_START", "{", "setProperty ( key ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withProperty"], "fileName": "org.springframework.mock.env.MockEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   RmiClientInterceptorUtils . convertRmiAccessException ( method ,    ex ,    isConnectFailure ( ex )  ,    getJndiName (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertRmiAccessException"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   getRemoteInvocationFactory (  )  . createRemoteInvocation ( methodInvocation )  ;", "}", "METHOD_END"], "methodName": ["createRemoteInvocation"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( stub   instanceof   RmiInvocationHandler )     {", "try    {", "return   doInvoke ( invocation ,     (  ( RmiInvocationHandler )     ( stub )  )  )  ;", "}    catch    ( RemoteException   ex )     {", "throw   convertRmiAccessException ( ex ,    invocation . getMethod (  )  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   ex . getTargetException (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   RemoteInvocationFailureException (  (  (  (  (  \" Invocation   of   method    [  \"     +     ( invocation . getMethod (  )  )  )     +     \"  ]    failed   in   RMI   service    [  \"  )     +     ( getJndiName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "} else    {", "try    {", "return   Utils . invokeRemoteMethod ( invocation ,    stub )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   targetEx    =    ex . getTargetException (  )  ;", "if    ( targetEx   instanceof   RemoteException )     {", "throw   convertRmiAccessException (  (  ( RemoteException )     ( targetEx )  )  ,    invocation . getMethod (  )  )  ;", "} else    {", "throw   targetEx ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( AopUtils . isToStringMethod ( methodInvocation . getMethod (  )  )  )     {", "return    (  \" RMI   invoker   proxy   for   service   URL    [  \"     +     ( getJndiName (  )  )  )     +     \"  ]  \"  ;", "}", "return   invocationHandler . invoke ( createRemoteInvocation ( methodInvocation )  )  ;", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . remoteInvocationFactory ;", "}", "METHOD_END"], "methodName": ["getRemoteInvocationFactory"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . serviceInterface ;", "}", "METHOD_END"], "methodName": ["getServiceInterface"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( this . cacheStub )  )     |  |     (  ( this . lookupStubOnStartup )     &  &     (  !  ( this . refreshStubOnConnectFailure )  )  )  )     {", "return    ( this . cachedStub )     !  =    null    ?    this . cachedStub    :    lookupStub (  )  ;", "} else    {", "synchronized ( this . stubMonitor )     {", "if    (  ( this . cachedStub )     =  =    null )     {", "this . cachedStub    =    lookupStub (  )  ;", "}", "return   this . cachedStub ;", "}", "}", "}", "METHOD_END"], "methodName": ["getStub"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( this . refreshStubOnConnectFailure )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Could   not   connect   to   RMI   service    [  \"     +     ( getName (  )  )  )     +     \"  ]     -    retrying \"  )  ,    ex )  ;", "} else", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Could   not   connect   to   RMI   service    [  \"     +     ( getName (  )  )  )     +     \"  ]     -    retrying \"  )  )  ;", "}", "return   refreshAndRetry ( invocation )  ;", "} else    {", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["handleRemoteConnectFailure"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   RmiClientInterceptorUtils . isConnectFailure ( ex )  ;", "}", "METHOD_END"], "methodName": ["isConnectFailure"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   lookup (  )  ;", "}    catch    ( NamingExion   ex )     {", "throw   new   RemoteLookupFailureExion (  (  (  \" JNDI   lookup   for   RMI   service    [  \"     +     ( getJndiName (  )  )  )     +     \"  ]    failed \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupStub"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( this . lookupStubOnStartup )     {", "Object   eObj    =    lookupStub (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "if    ( eObj   instanceof   RmiInvocationHandler )     {", "logger . debug (  (  (  \" JNDI   RMI   object    [  \"     +     ( getJndiName (  )  )  )     +     \"  ]    is   an   RMI   invoker \"  )  )  ;", "} else", "if    (  ( getServiceInterface (  )  )     !  =    null )     {", "boolean   isImpl    =    getServiceInterface (  )  . isInstance ( eObj )  ;", "logger . debug (  (  (  (  (  (  (  \" Using   service   interface    [  \"     +     ( getServiceInterface (  )  . getName (  )  )  )     +     \"  ]    for   JNDI   RMI   object    [  \"  )     +     ( getJndiName (  )  )  )     +     \"  ]     -     \"  )     +     (  ! isImpl    ?     \" not    \"     :     \"  \"  )  )     +     \" directly   implemented \"  )  )  ;", "}", "}", "if    ( this . cacheStub )     {", "this . cachedStub    =    eObj ;", "}", "}", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Object   freshStub ;", "synchronized ( this . stubMoni )     {", "this . cachedStub    =    null ;", "freshStub    =    lookupStub (  )  ;", "if    ( this . cacheStub )     {", "this . cachedStub    =    freshStub ;", "}", "}", "return   doInvoke ( invocation ,    freshStub )  ;", "}", "METHOD_END"], "methodName": ["refreshAndRetry"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . cacheStub    =    cacheStub ;", "}", "METHOD_END"], "methodName": ["setCacheStub"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . exposeAccessContext    =    exposeAccessContext ;", "}", "METHOD_END"], "methodName": ["setExposeAccessContext"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . lookupStubOnStartup    =    lookupStubOnStartup ;", "}", "METHOD_END"], "methodName": ["setLookupStubOnStartup"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . refreshStubOnConnectFailure    =    refreshStubOnConnectFailure ;", "}", "METHOD_END"], "methodName": ["setRefreshStubOnConnectFailure"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . remoteInvocationFactory    =    remoteInvocationFactory ;", "}", "METHOD_END"], "methodName": ["setRemoteInvocationFactory"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( serviceInterface ,     \"  ' serviceInterface '    must   not   be   null \"  )  ;", "Assert . isTrue ( serviceInterface . isInterface (  )  ,     \"  ' serviceInterface '    must   be   an   interface \"  )  ;", "this . serviceInterface    =    serviceInterface ;", "}", "METHOD_END"], "methodName": ["setServiceInterface"], "fileName": "org.springframework.remoting.rmi.JndiRmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( method    !  =    null )     {", "try    {", "method . invoke ( null ,    this . edObject )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   targetEx    =    ex . getTargetException (  )  ;", "if    ( targetEx   instanceof   RemoteException )     {", "throw    (  ( RemoteException )     ( targetEx )  )  ;", "}", "ReflectionUtils . rethrowRuntimeException ( targetEx )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" PortableRemoteObject   invocation   failed \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokePortableRemoteObject"], "fileName": "org.springframework.remoting.rmi.JndiRmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . jndiName )     =  =    null )     {", "throw   new   IllegalArgumentException (  \" Property    ' jndiName '    is   required \"  )  ;", "}", "this . exportedObject    =    getObjectToExport (  )  ;", "invokePortableRemoteObject (  . exportObject )  ;", "rebind (  )  ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.remoting.rmi.JndiRmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" Binding   RMI   s   to   JNDI   location    [  \"     +     ( this . jndiName )  )     +     \"  ]  \"  )  )  ;", "}", "this . jndiTemplate . rebind ( this . jndiName ,    this . exportedObject )  ;", "}", "METHOD_END"], "methodName": ["rebind"], "fileName": "org.springframework.remoting.rmi.JndiRmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . jndiTemplate    =    new   JndiTemplate ( jndiEnvironment )  ;", "}", "METHOD_END"], "methodName": ["setJndiEnvironment"], "fileName": "org.springframework.remoting.rmi.JndiRmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . jndiName    =    jndiName ;", "}", "METHOD_END"], "methodName": ["setJndiName"], "fileName": "org.springframework.remoting.rmi.JndiRmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . jndiTemplate    =     ( jndiTemplate    !  =    null )     ?    jndiTemplate    :    new   JndiTemplate (  )  ;", "}", "METHOD_END"], "methodName": ["setJndiTemplate"], "fileName": "org.springframework.remoting.rmi.JndiRmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "return   new   CodebaseAwareObjectInputStream ( is ,    getBeanClassLoader (  )  ,    isAcceptProxyClasses (  )  )  ;", "}", "METHOD_END"], "methodName": ["createObjectInputStream"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "return   new   ObjectOutputStream ( os )  ;", "}", "METHOD_END"], "methodName": ["createObjectOutputStream"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "Object   obj    =    ois . readObject (  )  ;", "if    (  !  ( obj   instanceof    )  )     {", "throw   new   RemoteException (  (  (  (  \" Deserialized   object   needs   to   be   assignable   to   type    [  \"     +     (  . class . getName (  )  )  )     +     \"  ]  :     \"  )     +     ( ClassUtils . getDescriptiveType ( obj )  )  )  )  ;", "}", "return    (  (  )     ( obj )  )  ;", "}", "METHOD_END"], "methodName": ["doReadRemoteInvocation"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "oos . writeObject ( result )  ;", "}", "METHOD_END"], "methodName": ["doWriteRemoteInvocationResult"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "return   this . contentType ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . proxy )     =  =    null )     {", "throw   new   IllegalStateException (  (  ( ClassUtils . getShortName ( getClass (  )  )  )     +     \"    has   not   been   inited \"  )  )  ;", "}", "return   this . proxy ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "return   this . acceptProxyClasses ;", "}", "METHOD_END"], "methodName": ["isAcceptProxyClasses"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "this . proxy    =    getProxyForService (  )  ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "this . acceptProxyClasses    =    acceptProxyClasses ;", "}", "METHOD_END"], "methodName": ["setAcceptProxyClasses"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( contentType ,     \"  ' contentType '    must   not   be   null \"  )  ;", "this . contentType    =    contentType ;", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.remoting.rmi.RemoteInvocationSerializingExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( getService (  )  )    instanceof   Remote )     &  &     (  (  ( getServiceInterface (  )  )     =  =    null )     |  |     ( Remote . class . isAssignableFrom ( getServiceInterface (  )  )  )  )  )     {", "return    (  ( Remote )     ( getService (  )  )  )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" RMI   service    [  \"     +     ( getService (  )  )  )     +     \"  ]    is   an   RMI   invoker \"  )  )  ;", "}", "return   new   RmiInvocationWrapper ( getProxyForService (  )  ,    this )  ;", "}", "}", "METHOD_END"], "methodName": ["getObjectToExport"], "fileName": "org.springframework.remoting.rmi.RmiBasedExporter"}, {"methodBody": ["METHOD_START", "{", "if    ( stub   instanceof   RmiInvocationHandler )     {", "try    {", "return   doInvoke ( invocation ,     (  ( RmiInvocationHandler )     ( stub )  )  )  ;", "}    catch    ( RemoteException   ex )     {", "throw   Utils . convertRmiAccessException ( invocation . getMethod (  )  ,    ex ,    isConnectFailure ( ex )  ,    getServiceUrl (  )  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   exToThrow    =    ex . getTargetException (  )  ;", "RemoteInvocationUtils . fillInClientStackTraceIfPossible ( exToThrow )  ;", "throw   exToThrow ;", "}    catch    ( Throwable   ex )     {", "throw   new   RemoteInvocationFailureException (  (  (  (  (  \" Invocation   of   method    [  \"     +     ( invocation . getMethod (  )  )  )     +     \"  ]    failed   in   RMI   service    [  \"  )     +     ( getServiceUrl (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "} else    {", "try    {", "return   Utils . invokeRemoteMethod ( invocation ,    stub )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   targetEx    =    ex . getTargetException (  )  ;", "if    ( targetEx   instanceof   RemoteException )     {", "RemoteException   rex    =     (  ( RemoteException )     ( targetEx )  )  ;", "throw   Utils . convertRmiAccessException ( invocation . getMethod (  )  ,    rex ,    isConnectFailure ( rex )  ,    getServiceUrl (  )  )  ;", "} else    {", "throw   targetEx ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( AopUtils . isToStringMethod ( methodInvocation . getMethod (  )  )  )     {", "return    (  \" RMI   invoker   proxy   for   service   URL    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]  \"  ;", "}", "return   invocationHandler . invoke ( createRemoteInvocation ( methodInvocation )  )  ;", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( this . cacheStub )  )     |  |     (  ( this . lookupStubOnStartup )     &  &     (  !  ( this . refreshStubOnConnectFailure )  )  )  )     {", "return    ( this . cachedStub )     !  =    null    ?    this . cachedStub    :    lookupStub (  )  ;", "} else    {", "synchronized ( this . stubMonitor )     {", "if    (  ( this . cachedStub )     =  =    null )     {", "this . cachedStub    =    lookupStub (  )  ;", "}", "return   this . cachedStub ;", "}", "}", "}", "METHOD_END"], "methodName": ["getStub"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( this . refreshStubOnConnectFailure )     {", "St   msg    =     (  \" Could   not   connect   to   RMI   service    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]     -    retrying \"  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . warn ( msg ,    ex )  ;", "} else", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn ( msg )  ;", "}", "return   refreshAndRetry ( invocation )  ;", "} else    {", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["handleRemoteConnectFailure"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   RmiClientInterceptorUtils . isConnectFailure ( ex )  ;", "}", "METHOD_END"], "methodName": ["isConnectFailure"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "Remote   stub    =    null ;", "if    (  ( this . registryClientSocketFactory )     !  =    null )     {", "URL   url    =    new   URL ( null ,    getServiceUrl (  )  ,    new    . DummyURLStreamHandler (  )  )  ;", "String   protocol    =    url . getProtocol (  )  ;", "if    (  ( protocol    !  =    null )     &  &     (  !  (  \" rmi \"  . equals ( protocol )  )  )  )     {", "throw   new   MalformedURLException (  (  (  \" Invalid   URL   scheme    '  \"     +    protocol )     +     \"  '  \"  )  )  ;", "}", "String   host    =    url . getHost (  )  ;", "int   port    =    url . getPort (  )  ;", "String   name    =    url . getPath (  )  ;", "if    (  ( name    !  =    null )     &  &     ( name . startsWith (  \"  /  \"  )  )  )     {", "name    =    name . substring (  1  )  ;", "}", "Registry   registry    =    LocateRegistry . getRegistry ( host ,    port ,    this . registryClientSocketFactory )  ;", "stub    =    registry . lookup ( name )  ;", "} else    {", "stub    =    Naming . lookup ( getServiceUrl (  )  )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Located   RMI   stub   with   URL    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   stub ;", "}    catch    ( MalformedURLException   ex )     {", "throw   new   RemoteLookupFailureException (  (  (  \" Service   URL    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]    is   invalid \"  )  ,    ex )  ;", "}    catch    ( NotBoundException   ex )     {", "throw   new   RemoteLookupFailureException (  (  (  \" Could   not   find   RMI   service    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]    in   RMI   registry \"  )  ,    ex )  ;", "}    catch    ( RemoteException   ex )     {", "throw   new   RemoteLookupFailureException (  \" Lookup   of   RMI   stub   failed \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupStub"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( this . lookupStubOnStartup )     {", "Remote   eObj    =    lookupStub (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "if    ( eObj   instanceof   RmiInvocationHandler )     {", "logger . debug (  (  (  \" RMI   stub    [  \"     +     ( getServiceUrl (  )  )  )     +     \"  ]    is   an   RMI   invoker \"  )  )  ;", "} else", "if    (  ( getServiceInterface (  )  )     !  =    null )     {", "boolean   isImpl    =    getServiceInterface (  )  . isInstance ( eObj )  ;", "logger . debug (  (  (  (  (  (  (  \" Using   service   interface    [  \"     +     ( getServiceInterface (  )  . getName (  )  )  )     +     \"  ]    for   RMI   stub    [  \"  )     +     ( getServiceUrl (  )  )  )     +     \"  ]     -     \"  )     +     (  ! isImpl    ?     \" not    \"     :     \"  \"  )  )     +     \" directly   implemented \"  )  )  ;", "}", "}", "if    ( this . cacheStub )     {", "this . cachedStub    =    eObj ;", "}", "}", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Remote   freshStub    =    null ;", "synchronized ( this . stubMonitor )     {", "this . cachedStub    =    null ;", "freshStub    =    lookupStub (  )  ;", "if    ( this . cacheStub )     {", "this . cachedStub    =    freshStub ;", "}", "}", "return   doInvoke ( invocation ,    freshStub )  ;", "}", "METHOD_END"], "methodName": ["refreshAndRetry"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . cacheStub    =    cacheStub ;", "}", "METHOD_END"], "methodName": ["setCacheStub"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . lookupStubOnStartup    =    lookupStubOnStartup ;", "}", "METHOD_END"], "methodName": ["setLookupStubOnStartup"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . refreshStubOnConnectFailure    =    refreshStubOnConnectFailure ;", "}", "METHOD_END"], "methodName": ["setRefreshStubOnConnectFailure"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . registryClientSocketFactory    =    registryClientSocketFactory ;", "}", "METHOD_END"], "methodName": ["setRegistryClientSocketFactory"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( RmiClientInterceptorUtils . logger . isDebugEnabled (  )  )     {", "RmiClientInterceptorUtils . logger . debug ( message ,    ex )  ;", "}", "if    ( ReflectionUtils . declaresException ( method ,    RemoteException . class )  )     {", "return   new   RemoteException ( message ,    ex )  ;", "} else    {", "return   new   RemoteAccessException ( message ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["convertRmiAccessException"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptorUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( RmiClientInterceptorUtils . logger . isDebugEnabled (  )  )     {", "RmiClientInterceptorUtils . logger . debug (  (  (  \" Remote   service    [  \"     +    serviceName )     +     \"  ]    threw   exception \"  )  ,    ex )  ;", "}", "if    ( ReflectionUtils . declaresException ( method ,    ex . getClass (  )  )  )     {", "return   ex ;", "} else    {", "if    ( isConnectFailure )     {", "return   new   RemoteConnectFailureException (  (  (  \" Could   not   connect   to   remote   service    [  \"     +    serviceName )     +     \"  ]  \"  )  ,    ex )  ;", "} else    {", "return   new   RemoteAccessException (  (  (  \" Could   not   access   remote   service    [  \"     +    serviceName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["convertRmiAccessException"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptorUtils"}, {"methodBody": ["METHOD_START", "{", "return   RmiClientInterceptorUtils . convertRmiAccessException ( method ,    ex ,    RmiClientInterceptorUtils . isConnectFailure ( ex )  ,    serviceName )  ;", "}", "METHOD_END"], "methodName": ["convertRmiAccessException"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptorUtils"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    invocation . getMethod (  )  ;", "try    {", "if    ( method . getDeclaClass (  )  . isInstance ( stub )  )     {", "return   method . invoke ( stub ,    invocation . getArguments (  )  )  ;", "} else    {", "Method   stubMethod    =    stub . getClass (  )  . getMethod ( method . getName (  )  ,    method . getParameterTypes (  )  )  ;", "return   stubMethod . invoke ( stub ,    invocation . getArguments (  )  )  ;", "}", "}    catch    ( InvocationTargetException   ex )     {", "throw   ex ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   RemoteProxyFailureException (  (  \" No   matching   RMI   stub   method   found   for :     \"     +    method )  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   RemoteProxyFailureException (  (  \" Invocation   of   RMI   stub   method   failed :     \"     +    method )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeRemoteMethod"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptorUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( ex   instanceof   ConnectException )     |  |     ( ex   instanceof   ConnectIOException )  )     |  |     ( ex   instanceof   UnknownHostException )  )     |  |     ( ex   instanceof   NoSuchObjectException )  )     |  |     ( ex   instanceof   StubNotFoundException )  )     |  |     (  ( ex . getCause (  )  )    instanceof   SocketException )  ;", "}", "METHOD_END"], "methodName": ["isConnectFailure"], "fileName": "org.springframework.remoting.rmi.RmiClientInterceptorUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . port ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( this . alwaysCreate )     {", "logger . info (  \" Creating   new   RMI   registry \"  )  ;", "this . created    =    true ;", "return   Locate . create ( registryPort )  ;", "}", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" Looking   for   RMI   registry   at   port    '  \"     +    registryPort )     +     \"  '  \"  )  )  ;", "}", "synchronized ( Locate . class )     {", "try    {", "reg    =    Locate . get ( registryPort )  ;", "test ( reg )  ;", "return   reg ;", "}    catch    ( RemoteException   ex )     {", "logger . debug (  \" RMI   registry   access   threw   exception \"  ,    ex )  ;", "logger . info (  \" Could   not   detect   RMI   registry    -    creating   new   one \"  )  ;", "this . created    =    true ;", "return   Locate . create ( registryPort )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( clientSocketFactory    !  =    null )     {", "if    ( this . alwaysCreate )     {", "logger . info (  \" Creating   new   RMI   registry \"  )  ;", "this . created    =    true ;", "return   Locate . create ( registryPort ,    clientSocketFactory ,    serverSocketFactory )  ;", "}", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" Looking   for   RMI   registry   at   port    '  \"     +    registryPort )     +     \"  '  ,    using   custom   socket   factory \"  )  )  ;", "}", "synchronized ( Locate . class )     {", "try    {", "reg    =    Locate . get ( null ,    registryPort ,    clientSocketFactory )  ;", "test ( reg )  ;", "return   reg ;", "}    catch    ( RemoteException   ex )     {", "logger . debug (  \" RMI   registry   access   threw   exception \"  ,    ex )  ;", "logger . info (  \" Could   not   detect   RMI   registry    -    creating   new   one \"  )  ;", "this . created    =    true ;", "return   Locate . create ( registryPort ,    clientSocketFactory ,    serverSocketFactory )  ;", "}", "}", "} else    {", "return   get ( registryPort )  ;", "}", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( registryHost    !  =    null )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  (  \" Looking   for   RMI   registry   at   port    '  \"     +    registryPort )     +     \"  '    of   host    [  \"  )     +    registryHost )     +     \"  ]  \"  )  )  ;", "}", "reg    =    Locate . get ( registryHost ,    registryPort ,    clientSocketFactory )  ;", "test ( reg )  ;", "return   reg ;", "} else    {", "return   get ( registryPort ,    clientSocketFactory ,    serverSocketFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . alwaysCreate    =    alwaysCreate ;", "}", "METHOD_END"], "methodName": ["setAlwaysCreate"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . clientSocketFactory    =    clientSocketFactory ;", "}", "METHOD_END"], "methodName": ["setClientSocketFactory"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . host    =    host ;", "}", "METHOD_END"], "methodName": ["setHost"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . port    =    port ;", "}", "METHOD_END"], "methodName": ["setPort"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . serverSocketFactory    =    serverSocketFactory ;", "}", "METHOD_END"], "methodName": ["setServerSocketFactory"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "registry . list (  )  ;", "}", "METHOD_END"], "methodName": ["testRegistry"], "fileName": "org.springframework.remoting.rmi.RmiRegistryFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( this . alwaysCreateRegistry )     {", "logger . info (  \" Crea   new   RMI   registry \"  )  ;", "return   LocateRegistry . createRegistry ( registryPort )  ;", "}", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" Looking   for   RMI   registry   at   port    '  \"     +    registryPort )     +     \"  '  \"  )  )  ;", "}", "synchronized ( LocateRegistry . class )     {", "try    {", "Registry   reg    =    LocateRegistry . getRegistry ( registryPort )  ;", "testRegistry ( reg )  ;", "return   reg ;", "}    catch    ( RemoteException   ex )     {", "logger . debug (  \" RMI   registry   access   threw   exception \"  ,    ex )  ;", "logger . info (  \" Could   not   detect   RMI   registry    -    crea   new   one \"  )  ;", "return   LocateRegistry . createRegistry ( registryPort )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "if    ( clientSocketFactory    !  =    null )     {", "if    ( this . alwaysCreateRegistry )     {", "logger . info (  \" Crea   new   RMI   registry \"  )  ;", "return   LocateRegistry . createRegistry ( registryPort ,    clientSocketFactory ,    serverSocketFactory )  ;", "}", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" Looking   for   RMI   registry   at   port    '  \"     +    registryPort )     +     \"  '  ,    using   custom   socket   factory \"  )  )  ;", "}", "synchronized ( LocateRegistry . class )     {", "try    {", "Registry   reg    =    LocateRegistry . getRegistry ( null ,    registryPort ,    clientSocketFactory )  ;", "testRegistry ( reg )  ;", "return   reg ;", "}    catch    ( RemoteException   ex )     {", "logger . debug (  \" RMI   registry   access   threw   exception \"  ,    ex )  ;", "logger . info (  \" Could   not   detect   RMI   registry    -    crea   new   one \"  )  ;", "return   LocateRegistry . createRegistry ( registryPort ,    clientSocketFactory ,    serverSocketFactory )  ;", "}", "}", "} else    {", "return   getRegistry ( registryPort )  ;", "}", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "if    ( registryHost    !  =    null )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  (  \" Looking   for   RMI   registry   at       '  \"     +    registryPort )     +     \"  '    of   host    [  \"  )     +    registryHost )     +     \"  ]  \"  )  )  ;", "}", "Registry   reg    =    LocateRegistry . getRegistry ( registryHost ,    registryPort ,    clientSocketFactory )  ;", "testRegistry ( reg )  ;", "return   reg ;", "} else    {", "return   getRegistry ( registryPort ,    clientSocketFactory ,    serverSocketFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "checkService (  )  ;", "if    (  ( this . serviceName )     =  =    null )     {", "throw   new   IllegalArgumentException (  \" Property    ' serviceName '    is   required \"  )  ;", "}", "if    (  ( this . clientSocketFactory )    instanceof   RMIServerSocketFactory )     {", "this . serverSocketFactory    =     (  ( RMIServerSocketFactory )     ( this . clientSocketFactory )  )  ;", "}", "if    (  (  (  ( this . clientSocketFactory )     !  =    null )     &  &     (  ( this . serverSocketFactory )     =  =    null )  )     |  |     (  (  ( this . clientSocketFactory )     =  =    null )     &  &     (  ( this . serverSocketFactory )     !  =    null )  )  )     {", "throw   new   IllegalArgumentException (  \" Both   RMIClientSocketFactory   and   RMIServerSocketFactory   or   none   required \"  )  ;", "}", "if    (  ( this . registryClientSocketFactory )    instanceof   RMIServerSocketFactory )     {", "this . registryServerSocketFactory    =     (  ( RMIServerSocketFactory )     ( this . registryClientSocketFactory )  )  ;", "}", "if    (  (  ( this . registryClientSocketFactory )     =  =    null )     &  &     (  ( this . registryServerSocketFactory )     !  =    null )  )     {", "throw   new   IllegalArgumentException (  \" RMIServerSocketFactory   without   RMIClientSocketFactory   for   registry   not   supported \"  )  ;", "}", "this . createdRegistry    =    false ;", "if    (  ( this . registry )     =  =    null )     {", "this . registry    =    getRegistry ( this . registryHost ,    this . registryPort ,    this . registryClientSocketFactory ,    this . registryServerSocketFactory )  ;", "this . createdRegistry    =    true ;", "}", "this . exportedObject    =    getObjectToExport (  )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  \" Binding   service    '  \"     +     ( this . serviceName )  )     +     \"  '    to   RMI   registry :     \"  )     +     ( this . registry )  )  )  ;", "}", "if    (  ( this . clientSocketFactory )     !  =    null )     {", "UnicastRemoteObject . exportObject ( this . exportedObject ,    this . servicePort ,    this . clientSocketFactory ,    this . serverSocketFactory )  ;", "} else    {", "UnicastRemoteObject . exportObject ( this . exportedObject ,    this . servicePort )  ;", "}", "try    {", "if    ( this . replaceExistingBinding )     {", "this . registry . rebind ( this . serviceName ,    this . exportedObject )  ;", "} else    {", "this . registry . bind ( this . serviceName ,    this . exportedObject )  ;", "}", "}    catch    ( AlreadyBoundException   ex )     {", "unexportObjectSilently (  )  ;", "throw   new   IllegalStateException (  (  (  (  \" Already   an   RMI   object   bound   for   name    '  \"     +     ( this . serviceName )  )     +     \"  '  :     \"  )     +     ( ex . toString (  )  )  )  )  ;", "}    catch    ( RemoteException   ex )     {", "unexportObjectSilently (  )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . alwaysCreateRegistry    =    alwaysCreateRegistry ;", "}", "METHOD_END"], "methodName": ["setAlwaysCreateRegistry"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . clientSocketFactory    =    clientSocketFactory ;", "}", "METHOD_END"], "methodName": ["setClientSocketFactory"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . registry    =    registry ;", "}", "METHOD_END"], "methodName": ["setRegistry"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . registryClientSocketFactory    =    registryClientSocketFactory ;", "}", "METHOD_END"], "methodName": ["setRegistryClientSocketFactory"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . registryHost    =    registryHost ;", "}", "METHOD_END"], "methodName": ["setRegistryHost"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . registryPort    =    registryPort ;", "}", "METHOD_END"], "methodName": ["setRegistryPort"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . registryServerSocketFactory    =    registryServerSocketFactory ;", "}", "METHOD_END"], "methodName": ["setRegistryServerSocketFactory"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . replaceExistingBinding    =    replaceExistingBinding ;", "}", "METHOD_END"], "methodName": ["setReplaceExistingBinding"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . serverSocketFactory    =    serverSocketFactory ;", "}", "METHOD_END"], "methodName": ["setServerSocketFactory"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . serviceName    =    serviceName ;", "}", "METHOD_END"], "methodName": ["setServiceName"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . servicePort    =    servicePort ;", "}", "METHOD_END"], "methodName": ["setServicePort"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "registry . list (  )  ;", "}", "METHOD_END"], "methodName": ["testRegistry"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "try    {", "UnicastRemoteObject . unexportObject ( this . edObject ,    true )  ;", "}    catch    ( NoSuchObjectException   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" RMI   object   for   service    '  \"     +     ( this . serviceName )  )     +     \"  '    isn ' t   ed   anymore \"  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["unexportObjectSilently"], "fileName": "org.springframework.remoting.rmi.RmiServiceExporter"}, {"methodBody": ["METHOD_START", "{", "RmiSupportTests . CountingRmiProxyFactoryBean   factory    =    new   RmiSupportTests . CountingRmiProxyFactoryBean (  )  ;", "factory . setServiceInterface ( RmiSupportTests . IBusinessBean . class )  ;", "factory . setServiceUrl (  \" rmi :  /  / localhost :  1  0  9  0  / test \"  )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   RmiSupportTests . IBusinessBean )  )  ;", "RmiSupportTests . IBusinessBean   proxy    =     (  ( RmiSupportTests . IBusinessBean )     ( factory . getObject (  )  )  )  ;", "assertFalse (  ( proxy   instanceof   RmiSupportTests . IRemoteBean )  )  ;", "try    {", "proxy . setName ( rmiExceptionClass . getName (  )  )  ;", "fail (  (  \" Should   have   thrown    \"     +     ( rmiExceptionClass . getName (  )  )  )  )  ;", "}    catch    ( Exception   ex )     {", "if    ( springExceptionClass . isInstance ( ex )  )     {", "} else    {", "throw   ex ;", "}", "}", "assertEquals (  1  ,    factory . counter )  ;", "}", "METHOD_END"], "methodName": ["doTestRmiProxyFactoryBeanWithBusinessInterfaceAndException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "RmiSupportTests . CountingRmiProxyFactoryBean   factory    =    new   RmiSupportTests . CountingRmiProxyFactoryBean (  )  ;", "factory . setServiceInterface ( RmiSupportTests . IBusinessBean . class )  ;", "factory . setServiceUrl (  \" rmi :  /  / localhost :  1  0  9  0  / test \"  )  ;", "factory . setRefreshStubOnConnectFailure ( true )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   RmiSupportTests . IBusinessBean )  )  ;", "RmiSupportTests . IBusinessBean   proxy    =     (  ( RmiSupportTests . IBusinessBean )     ( factory . getObject (  )  )  )  ;", "assertFalse (  ( proxy   instanceof   RmiSupportTests . IRemoteBean )  )  ;", "try    {", "proxy . setName ( rmiExceptionClass . getName (  )  )  ;", "fail (  (  \" Should   have   thrown    \"     +     ( rmiExceptionClass . getName (  )  )  )  )  ;", "}    catch    ( Exception   ex )     {", "if    ( springExceptionClass . isInstance ( ex )  )     {", "} else    {", "throw   ex ;", "}", "}", "if    ( RemoteConnectFailureException . class . isAssignableFrom ( springExceptionClass )  )     {", "assertEquals (  2  ,    factory . counter )  ;", "} else    {", "assertEquals (  1  ,    factory . counter )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestRmiProxyFactoryBeanWithBusinessInterfaceAndExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "RmiSupportTests . CountingRmiProxyFactoryBean   factory    =    new   RmiSupportTests . CountingRmiProxyFactoryBean (  )  ;", "factory . setServiceInterface ( RmiSupportTests . IRemoteBean . class )  ;", "factory . setServiceUrl (  \" rmi :  /  / localhost :  1  0  9  0  / test \"  )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   RmiSupportTests . IRemoteBean )  )  ;", "RmiSupportTests . IRemoteBean   proxy    =     (  ( RmiSupportTests . IRemoteBean )     ( factory . getObject (  )  )  )  ;", "try    {", "proxy . setName ( exceptionClass . getName (  )  )  ;", "fail (  (  \" Should   have   thrown    \"     +     ( exceptionClass . getName (  )  )  )  )  ;", "}    catch    ( Exception   ex )     {", "if    ( exceptionClass . isInstance ( ex )  )     {", "} else    {", "throw   ex ;", "}", "}", "assertEquals (  1  ,    factory . counter )  ;", "}", "METHOD_END"], "methodName": ["doTestRmiProxyFactoryBeanWithException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "RmiSupportTests . CountingRmiProxyFactoryBean   factory    =    new   RmiSupportTests . CountingRmiProxyFactoryBean (  )  ;", "factory . setServiceInterface ( RmiSupportTests . IRemoteBean . class )  ;", "factory . setServiceUrl (  \" rmi :  /  / localhost :  1  0  9  0  / test \"  )  ;", "factory . setRefreshStubOnConnectFailure ( true )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   RmiSupportTests . IRemoteBean )  )  ;", "RmiSupportTests . IRemoteBean   proxy    =     (  ( RmiSupportTests . IRemoteBean )     ( factory . getObject (  )  )  )  ;", "try    {", "proxy . setName ( exceptionClass . getName (  )  )  ;", "fail (  (  \" Should   have   thrown    \"     +     ( exceptionClass . getName (  )  )  )  )  ;", "}    catch    ( Exception   ex )     {", "if    ( exceptionClass . isInstance ( ex )  )     {", "} else    {", "throw   ex ;", "}", "}", "assertEquals (  2  ,    factory . counter )  ;", "}", "METHOD_END"], "methodName": ["doTestRmiProxyFactoryBeanWithExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "final   RmiSupportTests . RemoteBean   rb    =    new   RmiSupportTests . RemoteBean (  )  ;", "final   Method   setNameMethod    =    rb . getClass (  )  . getDeclaredMethod (  \" setName \"  ,    String . class )  ;", "MethodInvocation   mi    =    new   MethodInvocation (  )     {", "@ Override", "public   Method   getMethod (  )     {", "return   setNameMethod ;", "}", "@ Override", "public   Object [  ]    getArguments (  )     {", "return   new   Object [  ]  {     \" bla \"     }  ;", "}", "@ Override", "public   Object   proceed (  )    throws   Throwable    {", "throw   new   UnsupportedOperationException (  )  ;", "}", "@ Override", "public   Object   getThis (  )     {", "return   rb ;", "}", "@ Override", "public   AccessibleObject   getStaticPart (  )     {", "return   setNameMethod ;", "}", "}  ;", "RemoteInvocation   inv    =    new   RemoteInvocation ( mi )  ;", "assertEquals (  \" setName \"  ,    inv . getMethodName (  )  )  ;", "assertEquals (  \" bla \"  ,    inv . getArguments (  )  [  0  ]  )  ;", "assertEquals ( String . class ,    inv . getParameterTypes (  )  [  0  ]  )  ;", "inv    =    new   RemoteInvocation (  )  ;", "inv . setArguments ( new   Object [  ]  {     \" bla \"     }  )  ;", "assertEquals (  \" bla \"  ,    inv . getArguments (  )  [  0  ]  )  ;", "inv . setMethodName (  \" setName \"  )  ;", "assertEquals (  \" setName \"  ,    inv . getMethodName (  )  )  ;", "inv . setParameterTypes ( new   Class <  ?  >  [  ]  {    String . class    }  )  ;", "assertEquals ( String . class ,    inv . getParameterTypes (  )  [  0  ]  )  ;", "inv    =    new   RemoteInvocation (  \" setName \"  ,    new   Class <  ?  >  [  ]  {    String . class    }  ,    new   Object [  ]  {     \" bla \"     }  )  ;", "assertEquals (  \" bla \"  ,    inv . getArguments (  )  [  0  ]  )  ;", "assertEquals (  \" setName \"  ,    inv . getMethodName (  )  )  ;", "assertEquals ( String . class ,    inv . getParameterTypes (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["remoteInvocation"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "RmiClientInterceptor   client    =    new   RmiClientInterceptor (  )  ;", "client . setServiceInterface (  . IRemoteBean . class )  ;", "try    {", "client . afterPropertiesSet (  )  ;", "fail (  \" url   isn ' t   set ,    expected   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["rmiClientInterceptorRequiresUrl"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "String   serviceUrl    =     \" rmi :  /  / localhost :  1  0  9  0  / test \"  ;", "RmiProxyFactoryBean   factory    =    new   RmiProxyFactoryBean (  )     {", "@ Override", "protected   Remote   lookupStub (  )     {", "return   new   RmiInvocationHandler (  )     {", "@ Override", "public   String   getTargetInterfaceName (  )     {", "return   null ;", "}", "@ Override", "public   Object   invoke ( RemoteInvocation   invocation )    throws   RemoteException    {", "throw   new   RemoteException (  )  ;", "}", "}  ;", "}", "}  ;", "factory . setServiceInterface (  . IBusinessBean . class )  ;", "factory . setServiceUrl ( serviceUrl )  ;", "factory . afterPropertiesSet (  )  ;", ". IBusinessBean   proxy    =     (  (  . IBusinessBean )     ( factory . getObject (  )  )  )  ;", "assertTrue ( proxy . toString (  )  . contains (  \" RMI   invoker \"  )  )  ;", "assertTrue ( proxy . toString (  )  . contains ( serviceUrl )  )  ;", "assertEquals ( proxy . hashCode (  )  ,    proxy . hashCode (  )  )  ;", "assertTrue ( proxy . equals ( proxy )  )  ;", "try    {", "proxy . setName (  \" test \"  )  ;", "fail (  \" Should   have   thrown   RemoteAccessException \"  )  ;", "}    catch    ( RemoteAccessException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["rmiInvokerWithSpecialLocalMethods"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "RmiSupportTests . CountingRmiProxyFactoryBean   factory    =    new   RmiSupportTests . CountingRmiProxyFactoryBean (  )  ;", "factory . setServiceInterface ( RmiSupportTests . IRemoteBean . class )  ;", "factory . setServiceUrl (  \" rmi :  /  / localhost :  1  0  9  0  / test \"  )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  \" Correct   singleton   value \"  ,    factory . isSingleton (  )  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   RmiSupportTests . IRemoteBean )  )  ;", "RmiSupportTests . IRemoteBean   proxy    =     (  ( RmiSupportTests . IRemoteBean )     ( factory . getObject (  )  )  )  ;", "proxy . setName (  \" myName \"  )  ;", "assertEquals (  \" myName \"  ,    RmiSupportTests . RemoteBean . name )  ;", "assertEquals (  1  ,    factory . counter )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBean"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "RmiSupportTests . CountingRmiProxyFactoryBean   factory    =    new   RmiSupportTests . CountingRmiProxyFactoryBean (  )  ;", "factory . setServiceInterface ( RmiSupportTests . IBusinessBean . class )  ;", "factory . setServiceUrl (  \" rmi :  /  / localhost :  1  0  9  0  / test \"  )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   RmiSupportTests . IBusinessBean )  )  ;", "RmiSupportTests . IBusinessBean   proxy    =     (  ( RmiSupportTests . IBusinessBean )     ( factory . getObject (  )  )  )  ;", "assertFalse (  ( proxy   instanceof   RmiSupportTests . IRemoteBean )  )  ;", "proxy . setName (  \" myName \"  )  ;", "assertEquals (  \" myName \"  ,    RmiSupportTests . RemoteBean . name )  ;", "assertEquals (  1  ,    factory . counter )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterface"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndException ( ConnectException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndConnectException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndExceptionAndRefresh ( ConnectException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndConnectExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndException ( ConnectIOException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndConnectIOException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndExceptionAndRefresh ( ConnectIOException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndConnectIOExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndExceptionAndRefresh ( NoSuchObjectException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndNoSuchObjectExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndException ( NoSuchObjectException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndNoSuchObjectExceptionException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndException ( RemoteException . class ,    RemoteAccessException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndRemoteException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndExceptionAndRefresh ( RemoteException . class ,    RemoteAccessException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndRemoteExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndException ( StubNotFoundException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndStubNotFoundException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndExceptionAndRefresh ( StubNotFoundException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndStubNotFoundExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndException ( UnknownHostException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndUnknownHostException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithBusinessInterfaceAndExceptionAndRefresh ( UnknownHostException . class ,    RemoteConnectFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithBusinessInterfaceAndUnknownHostExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithException ( ConnectException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithConnectException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithExceptionAndRefresh ( ConnectException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithConnectExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithException ( ConnectIOException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithConnectIOException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithExceptionAndRefresh ( ConnectIOException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithConnectIOExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithException ( MarshalException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithMarshalException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithException ( NoSuchObjectException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithNoSuchObjectException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithExceptionAndRefresh ( NoSuchObjectException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithNoSuchObjectExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithException ( RemoteException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithRemoteException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithException ( StubNotFoundException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithStubNotFoundException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithExceptionAndRefresh ( StubNotFoundException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithStubNotFoundExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithException ( UnknownHostException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithUnknownHostException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithExceptionAndRefresh ( UnknownHostException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithUnknownHostExceptionAndRefresh"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestRmiProxyFactoryBeanWithException ( UnmarshalException . class )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithUnmarshalException"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "RmiSupportTests . CountingRmiProxyFactoryBean   factory    =    new   RmiSupportTests . CountingRmiProxyFactoryBean (  )  ;", "factory . setServiceInterface ( RmiSupportTests . IWrongBusinessBean . class )  ;", "factory . setServiceUrl (  \" rmi :  /  / localhost :  1  0  9  0  / test \"  )  ;", "factory . afterPropertiesSet (  )  ;", "assertTrue (  (  ( factory . getObject (  )  )    instanceof   RmiSupportTests . IWrongBusinessBean )  )  ;", "RmiSupportTests . IWrongBusinessBean   proxy    =     (  ( RmiSupportTests . IWrongBusinessBean )     ( factory . getObject (  )  )  )  ;", "assertFalse (  ( proxy   instanceof   RmiSupportTests . IRemoteBean )  )  ;", "try    {", "proxy . setOtherName (  \" name \"  )  ;", "fail (  \" Should   have   thrown   RemoteProxyFailureException \"  )  ;", "}    catch    ( RemoteProxyFailureException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   NoSuchMethodException )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" setOtherName \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" IWrongBusinessBean \"  )  )  ;", "}", "assertEquals (  1  ,    factory . counter )  ;", "}", "METHOD_END"], "methodName": ["rmiProxyFactoryBeanWithWrongBusinessInterface"], "fileName": "org.springframework.remoting.rmi.RmiSupportTests"}, {"methodBody": ["METHOD_START", "{", "return   this . serviceInterface ;", "}", "METHOD_END"], "methodName": ["getServiceInterface"], "fileName": "org.springframework.remoting.support.RemoteAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( serviceInterface ,     \"  ' serviceInterface '    must   not   be   null \"  )  ;", "Assert . isTrue ( serviceInterface . isInterface (  )  ,     \"  ' serviceInterface '    must   be   an   interface \"  )  ;", "this . serviceInterface    =    serviceInterface ;", "}", "METHOD_END"], "methodName": ["setServiceInterface"], "fileName": "org.springframework.remoting.support.RemoteAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( getService (  )  ,     \" Property    ' service '    is   required \"  )  ;", "}", "METHOD_END"], "methodName": ["checkService"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    serviceInterface    =    getServiceInterface (  )  ;", "Assert . notNull ( serviceInterface ,     \" Property    ' serviceInterface '    is   required \"  )  ;", "Object   service    =    getService (  )  ;", "if    ( service   instanceof   St )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Service    [  \"     +    service )     +     \"  ]    is   a   St    \"  )     +     \" rather   than   an   actual   service   reference :    Have   you   accidentally   specified    \"  )     +     \" the   service   bean   name   as   value   instead   of   as   reference ?  \"  )  )  ;", "}", "if    (  !  ( serviceInterface . isInstance ( service )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Service   interface    [  \"     +     ( serviceInterface . getName (  )  )  )     +     \"  ]    needs   to   be   implemented   by   service    [  \"  )     +    service )     +     \"  ]    of   class    [  \"  )     +     ( service . getClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkServiceInterface"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getShortName ( getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getExporterName"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "checkService (  )  ;", "checkServiceInterface (  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . addInterface ( getServiceInterface (  )  )  ;", "if    (  ( this . registerTraceInterceptor )     !  =    null    ?    this . registerTraceInterceptor    :     ( this . interceptors )     =  =    null )     {", "proxyFactory . addAdvice ( new   RemoteInvocationTraceInterceptor ( getName (  )  )  )  ;", "}", "if    (  ( this . interceptors )     !  =    null )     {", "AdvisorAdapterRegistry   adapterRegistry    =    GlobalAdvisorAdapterRegistry . getInstance (  )  ;", "for    ( Object   interceptor    :    this . interceptors )     {", "proxyFactory . addAdvisor ( adapterRegistry . wrap ( interceptor )  )  ;", "}", "}", "proxyFactory . setTarget ( getService (  )  )  ;", "proxyFactory . setOpaque ( true )  ;", "return   proxyFactory . getProxy ( getBeanClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["getProxyForService"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "return   this . service ;", "}", "METHOD_END"], "methodName": ["getService"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "return   this . serviceInterface ;", "}", "METHOD_END"], "methodName": ["getServiceInterface"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "this . interceptors    =    interceptors ;", "}", "METHOD_END"], "methodName": ["setInterceptors"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "this . registerTraceInterceptor    =    registerTraceInterceptor ;", "}", "METHOD_END"], "methodName": ["setRegisterTraceInterceptor"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "this . service    =    service ;", "}", "METHOD_END"], "methodName": ["setService"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( serviceInterface ,     \"  ' serviceInterface '    must   not   be   null \"  )  ;", "Assert . isTrue ( serviceInterface . isInterface (  )  ,     \"  ' serviceInterface '    must   be   an   interface \"  )  ;", "this . serviceInterface    =    serviceInterface ;", "}", "METHOD_END"], "methodName": ["setServiceInterface"], "fileName": "org.springframework.remoting.support.RemoteExporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . attributes )     =  =    null )     {", "this . attributes    =    new   HashMap <  >  (  )  ;", "}", "if    ( this . attributes . containsKey ( key )  )     {", "throw   new   IllegalStateExcep (  (  (  \" There   is   already   an   attribute   with   key    '  \"     +    key )     +     \"  '    bound \"  )  )  ;", "}", "this . attributes . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["addAttribute"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "return   this . arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . attributes )     =  =    null )     {", "return   null ;", "}", "return   this . attributes . get ( key )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "return   this . attributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "return   this . methodName ;", "}", "METHOD_END"], "methodName": ["getMethodName"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterTypes ;", "}", "METHOD_END"], "methodName": ["getParameterTypes"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    targetObject . getClass (  )  . getMethod ( this . methodName ,    this . parameterTypes )  ;", "return   method . invoke ( targetObject ,    this . arguments )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "this . arguments    =    arguments ;", "}", "METHOD_END"], "methodName": ["setArguments"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "this . attributes    =    attributes ;", "}", "METHOD_END"], "methodName": ["setAttributes"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "this . methodName    =    methodName ;", "}", "METHOD_END"], "methodName": ["setMethodName"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "this . parameterTypes    =    parameterTypes ;", "}", "METHOD_END"], "methodName": ["setParameterTypes"], "fileName": "org.springframework.remoting.support.RemoteInvocation"}, {"methodBody": ["METHOD_START", "{", "return   getRemoteInvocationFactory (  )  . createRemoteInvocation ( methodInvocation )  ;", "}", "METHOD_END"], "methodName": ["createRemoteInvocation"], "fileName": "org.springframework.remoting.support.RemoteInvocationBasedAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . remoteInvocationFactory ;", "}", "METHOD_END"], "methodName": ["getRemoteInvocationFactory"], "fileName": "org.springframework.remoting.support.RemoteInvocationBasedAccessor"}, {"methodBody": ["METHOD_START", "{", "return   result . recreate (  )  ;", "}", "METHOD_END"], "methodName": ["recreateRemoteInvocationResult"], "fileName": "org.springframework.remoting.support.RemoteInvocationBasedAccessor"}, {"methodBody": ["METHOD_START", "{", "this . remoteInvocationFactory    =     ( remoteInvocationFactory    !  =    null )     ?    remoteInvocationFactory    :    new   DefaultRemoteInvocationFactory (  )  ;", "}", "METHOD_END"], "methodName": ["setRemoteInvocationFactory"], "fileName": "org.springframework.remoting.support.RemoteInvocationBasedAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . remoteInvocationExecutor ;", "}", "METHOD_END"], "methodName": ["getRemoteInvocationExecutor"], "fileName": "org.springframework.remoting.support.RemoteInvocationBasedExporter"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Executing    \"     +    invocation )  )  ;", "}", "try    {", "return   getExecutor (  )  . invoke ( invocation ,    targetObject )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . warn (  (  \" Could   not   find   target   method   for    \"     +    invocation )  ,    ex )  ;", "}", "throw   ex ;", "}    catch    ( IllegalAccessException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . warn (  (  \" Could   not   access   target   method   for    \"     +    invocation )  ,    ex )  ;", "}", "throw   ex ;", "}    catch    ( InvocationTargetException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Target   method   failed   for    \"     +    invocation )  ,    ex . getTargetException (  )  )  ;", "}", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.remoting.support.RemoteInvocationBasedExporter"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   value    =    invoke ( invocation ,    targetObject )  ;", "return   new   Result ( value )  ;", "}    catch    ( Throwable   ex )     {", "return   new   Result ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeAndCreateResult"], "fileName": "org.springframework.remoting.support.RemoteInvocationBasedExporter"}, {"methodBody": ["METHOD_START", "{", "this . remoteInvocationExecutor    =    remoteInvocationExecutor ;", "}", "METHOD_END"], "methodName": ["setRemoteInvocationExecutor"], "fileName": "org.springframework.remoting.support.RemoteInvocationBasedExporter"}, {"methodBody": ["METHOD_START", "{", "return   this . exception ;", "}", "METHOD_END"], "methodName": ["getException"], "fileName": "org.springframework.remoting.support.RemoteInvocationResult"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.remoting.support.RemoteInvocationResult"}, {"methodBody": ["METHOD_START", "{", "return    ( this . exception )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasException"], "fileName": "org.springframework.remoting.support.RemoteInvocationResult"}, {"methodBody": ["METHOD_START", "{", "return    ( this . exception )    instanceof   InvocationTargetException ;", "}", "METHOD_END"], "methodName": ["hasInvocationTargetException"], "fileName": "org.springframework.remoting.support.RemoteInvocationResult"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . exception )     !  =    null )     {", "Throwable   exToThrow    =    this . exception ;", "if    (  ( this . exception )    instanceof   InvocationTargetException )     {", "exToThrow    =     (  ( InvocationTargetException )     ( this . exception )  )  . getTargetException (  )  ;", "}", "Utils . fillInClientStackTraceIfPossible ( exToThrow )  ;", "throw   exToThrow ;", "} else    {", "return   this . value ;", "}", "}", "METHOD_END"], "methodName": ["recreate"], "fileName": "org.springframework.remoting.support.RemoteInvocationResult"}, {"methodBody": ["METHOD_START", "{", "this . exception    =    exception ;", "}", "METHOD_END"], "methodName": ["setException"], "fileName": "org.springframework.remoting.support.RemoteInvocationResult"}, {"methodBody": ["METHOD_START", "{", "this . value    =    value ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.springframework.remoting.support.RemoteInvocationResult"}, {"methodBody": ["METHOD_START", "{", "if    ( ex    !  =    null )     {", "StackTraceElement [  ]    clientStack    =    new   Throwable (  )  . getStackTrace (  )  ;", "Set < Throwable >    visitedExceps    =    new   HashSet <  >  (  )  ;", "Throwable   exToUpdate    =    ex ;", "while    (  ( exToUpdate    !  =    null )     &  &     (  !  ( visitedExceps . contains ( exToUpdate )  )  )  )     {", "StackTraceElement [  ]    serverStack    =    exToUpdate . getStackTrace (  )  ;", "StackTraceElement [  ]    combinedStack    =    new   StackTraceElement [  ( serverStack . length )     +     ( clientStack . length )  ]  ;", "System . arraycopy ( serverStack ,     0  ,    combinedStack ,     0  ,    serverStack . length )  ;", "System . arraycopy ( clientStack ,     0  ,    combinedStack ,    serverStack . length ,    clientStack . length )  ;", "exToUpdate . setStackTrace ( combinedStack )  ;", "visitedExceps . add ( exToUpdate )  ;", "exToUpdate    =    exToUpdate . getCause (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["fillInClientStackTraceIfPossible"], "fileName": "org.springframework.remoting.support.RemoteInvocationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "throw   new   IllegalStateException (  \" Mmm \"  )  ;", "}    catch    ( Exception   ex )     {", "int   originalStackTraceLngth    =    ex . getStackTrace (  )  . length ;", ". fillInClientStackTraceIfPossible ( ex )  ;", "assertTrue (  \" Stack   trace   not   being   filled   in \"  ,     (  ( ex . getStackTrace (  )  . length )     >    originalStackTraceLngth )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fillInClientStackTraceIfPossibleSunnyDay"], "fileName": "org.springframework.remoting.support.RemoteInvocationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "RemoteInvocationUtils . fillInClientStackTraceIfPossible ( null )  ;", "}", "METHOD_END"], "methodName": ["fillInClientStackTraceIfPossibleWithNullThrowable"], "fileName": "org.springframework.remoting.support.RemoteInvocationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . beanClassLoader ;", "}", "METHOD_END"], "methodName": ["getBeanClassLoader"], "fileName": "org.springframework.remoting.support.RemotingSupport"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . overrideThreadContextClassLoader ( getBeanClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["overrideThreadContextClassLoader"], "fileName": "org.springframework.remoting.support.RemotingSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( original    !  =    null )     {", "Thread . currentThread (  )  . setContextClassLoader ( original )  ;", "}", "}", "METHOD_END"], "methodName": ["resetThreadContextClassLoader"], "fileName": "org.springframework.remoting.support.RemotingSupport"}, {"methodBody": ["METHOD_START", "{", "this . authenticator    =    authenticator ;", "}", "METHOD_END"], "methodName": ["setAuthenticator"], "fileName": "org.springframework.remoting.support.SimpleHttpServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . backlog    =    backlog ;", "}", "METHOD_END"], "methodName": ["setBacklog"], "fileName": "org.springframework.remoting.support.SimpleHttpServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . contexts    =    contexts ;", "}", "METHOD_END"], "methodName": ["setContexts"], "fileName": "org.springframework.remoting.support.SimpleHttpServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . executor    =    executor ;", "}", "METHOD_END"], "methodName": ["setExecutor"], "fileName": "org.springframework.remoting.support.SimpleHttpServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . filters    =    filters ;", "}", "METHOD_END"], "methodName": ["setFilters"], "fileName": "org.springframework.remoting.support.SimpleHttpServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . hostname    =    hostname ;", "}", "METHOD_END"], "methodName": ["setHostname"], "fileName": "org.springframework.remoting.support.SimpleHttpServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . port    =    port ;", "}", "METHOD_END"], "methodName": ["setPort"], "fileName": "org.springframework.remoting.support.SimpleHttpServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . shutdownDelay    =    shutdownDelay ;", "}", "METHOD_END"], "methodName": ["setShutdownDelay"], "fileName": "org.springframework.remoting.support.SimpleHttpServerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . serviceUrl ;", "}", "METHOD_END"], "methodName": ["getServiceUrl"], "fileName": "org.springframework.remoting.support.UrlBasedRemoteAccessor"}, {"methodBody": ["METHOD_START", "{", "this . serviceUrl    =    serviceUrl ;", "}", "METHOD_END"], "methodName": ["setServiceUrl"], "fileName": "org.springframework.remoting.support.UrlBasedRemoteAccessor"}, {"methodBody": ["METHOD_START", "{", "return   schedule ( task ,    Date . from ( startTime )  )  ;", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "org.springframework.scheduling.TaskScheduler"}, {"methodBody": ["METHOD_START", "{", "return   scheduleAtFixedRate ( task ,    period . toMillis (  )  )  ;", "}", "METHOD_END"], "methodName": ["scheduleAtFixedRate"], "fileName": "org.springframework.scheduling.TaskScheduler"}, {"methodBody": ["METHOD_START", "{", "return   scheduleAtFixedRate ( task ,    Date . from ( startTime )  ,    period . toMillis (  )  )  ;", "}", "METHOD_END"], "methodName": ["scheduleAtFixedRate"], "fileName": "org.springframework.scheduling.TaskScheduler"}, {"methodBody": ["METHOD_START", "{", "return   scheduleWithFixedDelay ( task ,    delay . toMillis (  )  )  ;", "}", "METHOD_END"], "methodName": ["scheduleWithFixedDelay"], "fileName": "org.springframework.scheduling.TaskScheduler"}, {"methodBody": ["METHOD_START", "{", "return   scheduleWithFixedDelay ( task ,    Date . from ( startTime )  ,    delay . toMillis (  )  )  ;", "}", "METHOD_END"], "methodName": ["scheduleWithFixedDelay"], "fileName": "org.springframework.scheduling.TaskScheduler"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( configurers )  )     {", "return ;", "}", "if    (  ( configurers . size (  )  )     >     1  )     {", "throw   new   IllegalStateException (  \" Only   one   er   may   exist \"  )  ;", "}", "er   configurer    =    configurers . iterator (  )  . next (  )  ;", "this . executor    =    configurer . getAsyncExecutor (  )  ;", "this . exceptionHandler    =    configurer . getAsyncUncaughtExceptionHandler (  )  ;", "}", "METHOD_END"], "methodName": ["setConfigurers"], "fileName": "org.springframework.scheduling.annotation.AbstractAsyncConfiguration"}, {"methodBody": ["METHOD_START", "{", "AnnotationAsyncExecutionInterceptor   i    =    new   AnnotationAsyncExecutionInterceptor ( null )  ;", "{", "class   C    {", "@ Async (  \" qMethod \"  )", "void   m (  )     {", "}", "}", "assertThat ( i . getExecutorQualifier ( C . class . getDeclaredMethod (  \" m \"  )  )  ,    is (  \" qMethod \"  )  )  ;", "}", "{", "@ Async (  \" qClass \"  )", "class   C    {", "void   m (  )     {", "}", "}", "assertThat ( i . getExecutorQualifier ( C . class . getDeclaredMethod (  \" m \"  )  )  ,    is (  \" qClass \"  )  )  ;", "}", "{", "@ Async (  \" qClass \"  )", "class   C    {", "@ Async (  \" qMethod \"  )", "void   m (  )     {", "}", "}", "assertThat ( i . getExecutorQualifier ( C . class . getDeclaredMethod (  \" m \"  )  )  ,    is (  \" qMethod \"  )  )  ;", "}", "{", "@ Async (  \" qClass \"  )", "class   C    {", "@ Async", "void   m (  )     {", "}", "}", "assertThat ( i . getExecutorQualifier ( C . class . getDeclaredMethod (  \" m \"  )  )  ,    is (  \"  \"  )  )  ;", "}", "{", "@  . MyAsync", "class   C    {", "void   m (  )     {", "}", "}", "assertThat ( i . getExecutorQualifier ( C . class . getDeclaredMethod (  \" m \"  )  )  ,    is (  \" qMeta \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetExecutorQualifier"], "fileName": "org.springframework.scheduling.annotation.AnnotationAsyncExecutionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotationAsyncExecutionInterceptor ( executor ,    exceptionHandler )  ;", "}", "METHOD_END"], "methodName": ["buildAdvice"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor"}, {"methodBody": ["METHOD_START", "{", "ComposablePointcut   result    =    null ;", "for    ( Class <  ?    extends   Annotation >    aType    :    aTypes )     {", "Pointcut   cpc    =    new   AnnotationMatchingPointcut ( aType ,    true )  ;", "Pointcut   mpc    =    new   AnnotationMatchingPointcut ( null ,    aType ,    true )  ;", "if    ( result    =  =    null )     {", "result    =    new   ComposablePointcut ( cpc )  ;", "} else    {", "result . union ( cpc )  ;", "}", "result    =    result . union ( mpc )  ;", "}", "return   result    !  =    null    ?    result    :    Pointcut . TRUE ;", "}", "METHOD_END"], "methodName": ["buildPointcut"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( asyncAnnotationType ,     \"  ' asyncAnnotationType '    must   not   be   null \"  )  ;", "Set < Class <  ?    extends   Annotation >  >    asyncAnnotationTypes    =    new   HashSet <  >  (  )  ;", "asyncAnnotationTypes . add ( asyncAnnotationType )  ;", "this . pointcut    =    buildPointcut ( asyncAnnotationTypes )  ;", "}", "METHOD_END"], "methodName": ["setAsyncAnnotationType"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . advice    =    buildAdvice ( executor ,    this . exceptionHandler )  ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationAdvisor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( asyncAnnotationType ,     \"  ' asyncAnnotationType '    must   not   be   null \"  )  ;", "this . asyncAnnotationType    =    asyncAnnotationType ;", "}", "METHOD_END"], "methodName": ["setAsyncAnnotationType"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . exceptionHandler    =    exceptionHandler ;", "}", "METHOD_END"], "methodName": ["setExceptionHandler"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . executor    =    executor ;", "}", "METHOD_END"], "methodName": ["setExecutor"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "result . get (  )  ;", "}    catch    ( InterruptedException   ex )     {", "fail (  (  \" Should   not   have   failed   with   InterruptedException :     \"     +    ex )  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertEquals (  \" Wrong   exception   cause \"  ,    UnsupportedOperException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "}", "assertFalse (  \" handler   should   never   be   called   with   Future   return   type \"  ,    exceptionHandler . isCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertFutureWithException"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericXmlApplicationContext   context    =    new   GenericXmlApplicationContext (  )  ;", "context . load ( new   ClassPathResource (  \" taskNamespaceTests . xml \"  ,    getClass (  )  )  )  ;", "context . refresh (  )  ;", ". ITestBean   testBean    =    context . getBean (  \" target \"  ,     . ITestBean . class )  ;", "testBean . test (  )  ;", "testBean . await (  3  0  0  0  )  ;", "Thread   asyncThread    =    testBean . getThread (  )  ;", "assertTrue ( asyncThread . getName (  )  . startsWith (  \" testExecutor \"  )  )  ;", "TestableAsyncUncaughtExceptionHandler   exceptionHandler    =    context . getBean (  \" exceptionHandler \"  ,    TestableAsyncUncaughtExceptionHandler . class )  ;", "assertFalse (  \" handler   should   not   have   been   called   yet \"  ,    exceptionHandler . isCalled (  )  )  ;", "testBean . failWithVoid (  )  ;", "exceptionHandler . await (  3  0  0  0  )  ;", "Method   m    =    ReflectionUtils . findMethod (  . TestBean . class ,     \" failWithVoid \"  )  ;", "exceptionHandler . assertCalledWith ( m ,    UnsupportedOperationException . class )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["configuredThroughNamespace"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( AsyncAnnotationBeanPostProcessorTests . TestBean . class ,     \" failWithVoid \"  )  ;", "TestableAsyncUncaughtExceptionHandler   exceptionHandler    =    new   TestableAsyncUncaughtExceptionHandler ( true )  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  ;", "processorDefinition . getPropertyValues (  )  . add (  \" exceptionHandler \"  ,    exceptionHandler )  ;", "processorDefinition . getPropertyValues (  )  . add (  \" executor \"  ,    new   AsyncAnnotationBeanPostProcessorTests . DirectExecutor (  )  )  ;", "ConfigurableApplicationContext   context    =    initContext ( processorDefinition )  ;", "AsyncAnnotationBeanPostProcessorTests . ITestBean   testBean    =    context . getBean (  \" target \"  ,    AsyncAnnotationBeanPostProcessorTests . ITestBean . class )  ;", "assertFalse (  \" Handler   should   not   have   been   called \"  ,    exceptionHandler . isCalled (  )  )  ;", "try    {", "testBean . failWithVoid (  )  ;", "exceptionHandler . assertCalledWith ( m ,    UnsupportedOperationException . class )  ;", "}    catch    ( Exception   e )     {", "fail (  \" No   unexpected   exception   should   have   been   received \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["exceptionHandlerThrowsUnexpectedException"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( AsyncAnnotationBeanPostProcessorTests . TestBean . class ,     \" failWithVoid \"  )  ;", "TestableAsyncUncaughtExceptionHandler   exceptionHandler    =    new   TestableAsyncUncaughtExceptionHandler (  )  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  ;", "processorDefinition . getPropertyValues (  )  . add (  \" exceptionHandler \"  ,    exceptionHandler )  ;", "ConfigurableApplicationContext   context    =    initContext ( processorDefinition )  ;", "AsyncAnnotationBeanPostProcessorTests . ITestBean   testBean    =    context . getBean (  \" target \"  ,    AsyncAnnotationBeanPostProcessorTests . ITestBean . class )  ;", "assertFalse (  \" Handler   should   not   have   been   called \"  ,    exceptionHandler . isCalled (  )  )  ;", "testBean . failWithVoid (  )  ;", "exceptionHandler . await (  3  0  0  0  )  ;", "exceptionHandler . assertCalledWith ( m ,    UnsupportedOperationException . class )  ;", "}", "METHOD_END"], "methodName": ["handleExceptionWithCustomExceptionHandler"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AsyncAnnotationBeanPostProcessorTests . ConfigWithExceptionHandler . class )  ;", "AsyncAnnotationBeanPostProcessorTests . ITestBean   testBean    =    context . getBean (  \" target \"  ,    AsyncAnnotationBeanPostProcessorTests . ITestBean . class )  ;", "TestableAsyncUncaughtExceptionHandler   exceptionHandler    =    context . getBean (  \" exceptionHandler \"  ,    TestableAsyncUncaughtExceptionHandler . class )  ;", "assertFalse (  \" handler   should   not   have   been   called   yet \"  ,    exceptionHandler . isCalled (  )  )  ;", "Future < Object >    result    =    testBean . failWithFuture (  )  ;", "assertFutureWithException ( result ,    exceptionHandler )  ;", "}", "METHOD_END"], "methodName": ["handleExceptionWithFuture"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AsyncAnnotationBeanPostProcessorTests . ConfigWithExceptionHandler . class )  ;", "AsyncAnnotationBeanPostProcessorTests . ITestBean   testBean    =    context . getBean (  \" target \"  ,    AsyncAnnotationBeanPostProcessorTests . ITestBean . class )  ;", "TestableAsyncUncaughtExceptionHandler   exceptionHandler    =    context . getBean (  \" exceptionHandler \"  ,    TestableAsyncUncaughtExceptionHandler . class )  ;", "assertFalse (  \" handler   should   not   have   been   called   yet \"  ,    exceptionHandler . isCalled (  )  )  ;", "Future < Object >    result    =    testBean . failWithListenableFuture (  )  ;", "assertFutureWithException ( result ,    exceptionHandler )  ;", "}", "METHOD_END"], "methodName": ["handleExceptionWithListenableFuture"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . TestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    asyncAnnotationBeanPostProcessorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "return   context ;", "}", "METHOD_END"], "methodName": ["initContext"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    initContext ( new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  )  ;", ". ITestBean   testBean    =    context . getBean (  \" target \"  ,     . ITestBean . class )  ;", "testBean . test (  )  ;", "Thread   mainThread    =    Thread . currentThread (  )  ;", "testBean . await (  3  0  0  0  )  ;", "Thread   asyncThread    =    testBean . getThread (  )  ;", "assertNotSame ( mainThread ,    asyncThread )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["invokedAsynchronously"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    initContext ( new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "assertTrue ( AopUtils . isAopProxy ( target )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["proxyCreated"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "BeanDefinition   executorDefinition    =    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  ;", "executorDefinition . getPropertyValues (  )  . add (  \" threadNamePrefix \"  ,     \" testExecutor \"  )  ;", "context . registerBeanDefinition (  \" myExecutor \"  ,    executorDefinition )  ;", "BeanDefinition   executorDefinition 2     =    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  ;", "executorDefinition 2  . getPropertyValues (  )  . add (  \" threadNamePrefix \"  ,     \" testExecutor 2  \"  )  ;", "context . registerBeanDefinition (  \" taskExecutor \"  ,    executorDefinition 2  )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . TestBean . class )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", ". ITestBean   testBean    =    context . getBean (  \" target \"  ,     . ITestBean . class )  ;", "testBean . test (  )  ;", "testBean . await (  3  0  0  0  )  ;", "Thread   asyncThread    =    testBean . getThread (  )  ;", "assertTrue ( asyncThread . getName (  )  . startsWith (  \" testExecutor 2  \"  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["taskExecutorByBeanName"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "BeanDefinition   executorDefinition    =    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  ;", "executorDefinition . getPropertyValues (  )  . add (  \" threadNamePrefix \"  ,     \" testExecutor \"  )  ;", "context . registerBeanDefinition (  \" myExecutor \"  ,    executorDefinition )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . TestBean . class )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", ". ITestBean   testBean    =    context . getBean (  \" target \"  ,     . ITestBean . class )  ;", "testBean . test (  )  ;", "testBean . await (  3  0  0  0  )  ;", "Thread   asyncThread    =    testBean . getThread (  )  ;", "assertTrue ( asyncThread . getName (  )  . startsWith (  \" testExecutor \"  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["taskExecutorByBeanType"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  ;", "ThreadPoolTaskExecutor   executor    =    new   ThreadPoolTaskExecutor (  )  ;", "executor . setThreadNamePrefix (  \" testExecutor \"  )  ;", "executor . afterPropertiesSet (  )  ;", "processorDefinition . getPropertyValues (  )  . add (  \" executor \"  ,    executor )  ;", "ConfigurableApplicationContext   context    =    initContext ( processorDefinition )  ;", ". ITestBean   testBean    =    context . getBean (  \" target \"  ,     . ITestBean . class )  ;", "testBean . test (  )  ;", "testBean . await (  3  0  0  0  )  ;", "Thread   asyncThread    =    testBean . getThread (  )  ;", "assertTrue ( asyncThread . getName (  )  . startsWith (  \" testExecutor \"  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["threadNamePrefix"], "fileName": "org.springframework.scheduling.annotation.AsyncAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getAsyncExecutor"], "fileName": "org.springframework.scheduling.annotation.AsyncConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getAsyncUncaughtExceptionHandler"], "fileName": "org.springframework.scheduling.annotation.AsyncConfigurer"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncClassBean . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncClassBean   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncClassBean . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "ListenableFuture < String >    listenableFuture    =    asyncTest . returnSomethingListenable (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    listenableFuture . get (  )  )  ;", "CompletableFuture < String >    completableFuture    =    asyncTest . returnSomethingCompletable (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    completableFuture . get (  )  )  ;", "try    {", "asyncTest . returnSomething (  0  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "try    {", "asyncTest . returnSomethingListenable (  0  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "try    {", "asyncTest . returnSomethingCompletable (  0  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["asyncClass"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "AsyncExecutionTests . listenerCalled    =     0  ;", "AsyncExecutionTests . listenerConstructed    =     0  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncClassListener . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "context . close (  )  ;", "Thread . sleep (  1  0  0  0  )  ;", "assertEquals (  2  ,    AsyncExecutionTests . listenerCalled )  ;", "assertEquals (  1  ,    AsyncExecutionTests . listenerConstructed )  ;", "}", "METHOD_END"], "methodName": ["asyncClassListener"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncClassBeanWithInterface . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . RegularInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . RegularInterface . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncClassWithInterface"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncClassBeanWithInterface . class )  )  ;", "context . registerBeanDefinition (  \" asyncProcessor \"  ,    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . RegularInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . RegularInterface . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncClassWithInterfaceAndPostProcessor"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncClassBean . class )  )  ;", "context . registerBeanDefinition (  \" asyncProcessor \"  ,    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncClassBean   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncClassBean . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncClassWithPostProcessor"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncInterfaceBean . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncInterface . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncInterface"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncInterfaceBean . class )  )  ;", "context . registerBeanDefinition (  \" asyncProcessor \"  ,    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncInterface . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncInterfaceWithPostProcessor"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "AsyncExecutionTests . listenerCalled    =     0  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncMethodListener . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "Thread . sleep (  1  0  0  0  )  ;", "assertEquals (  1  ,    AsyncExecutionTests . listenerCalled )  ;", "}", "METHOD_END"], "methodName": ["asyncMethodListener"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncMethodBean . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncMethodBean   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncMethodBean . class )  ;", "asyncTest . doNothing (  5  )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "ListenableFuture < String >    listenableFuture    =    asyncTest . returnSomethingListenable (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    listenableFuture . get (  )  )  ;", "CompletableFuture < String >    completableFuture    =    asyncTest . returnSomethingCompletable (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    completableFuture . get (  )  )  ;", "try    {", "asyncTest . returnSomething (  0  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "try    {", "asyncTest . returnSomething (  (  -  1  )  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IOException )  )  ;", "}", "try    {", "asyncTest . returnSomethingListenable (  0  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "try    {", "asyncTest . returnSomethingListenable (  (  -  1  )  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IOException )  )  ;", "}", "try    {", "asyncTest . returnSomethingCompletable (  0  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["asyncMethods"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncMethodsInterfaceBean . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncMethodsInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncMethodsInterface . class )  ;", "asyncTest . doNothing (  5  )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncMethodsInInterface"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncMethodsInterfaceBean . class )  )  ;", "context . registerBeanDefinition (  \" asyncProcessor \"  ,    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncMethodsInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncMethodsInterface . class )  ;", "asyncTest . doNothing (  5  )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncMethodsInInterfaceWithPostProcessor"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . SimpleAsyncMethodBean . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . SimpleInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . SimpleInterface . class )  ;", "asyncTest . doNothing (  5  )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncMethodsThroughInterface"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . AsyncMethodWithQualifierBean . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . registerBeanDefinition (  \" e 0  \"  ,    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  )  ;", "context . registerBeanDefinition (  \" e 1  \"  ,    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  )  ;", "context . registerBeanDefinition (  \" e 2  \"  ,    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncMethodWithQualifierBean   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncMethodWithQualifierBean . class )  ;", "asyncTest . doNothing (  5  )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "Future < String >    future 2     =    asyncTest . returnSomething 2  (  3  0  )  ;", "assertEquals (  \"  3  0  \"  ,    future 2  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncMethodsWithQualifier"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . SimpleAsyncMethodWithQualifierBean . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . registerBeanDefinition (  \" e 0  \"  ,    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  )  ;", "context . registerBeanDefinition (  \" e 1  \"  ,    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  )  ;", "context . registerBeanDefinition (  \" e 2  \"  ,    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . SimpleInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . SimpleInterface . class )  ;", "asyncTest . doNothing (  5  )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "Future < String >    future 2     =    asyncTest . returnSomething 2  (  3  0  )  ;", "assertEquals (  \"  3  0  \"  ,    future 2  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncMethodsWithQualifierThroughInterface"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "AsyncExecutionTests . listenerCalled    =     0  ;", "AsyncExecutionTests . listenerConstructed    =     0  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "RootBeanDefinition   listenerDef    =    new   RootBeanDefinition ( AsyncExecutionTests . AsyncClassListener . class )  ;", "listenerDef . setScope ( SCOPE _ PROTOTYPE )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    listenerDef )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "context . close (  )  ;", "Thread . sleep (  1  0  0  0  )  ;", "assertEquals (  2  ,    AsyncExecutionTests . listenerCalled )  ;", "assertEquals (  2  ,    AsyncExecutionTests . listenerConstructed )  ;", "}", "METHOD_END"], "methodName": ["asyncPrototypeClassListener"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . DynamicAsyncInterfaceBean . class )  )  ;", "context . registerBeanDefinition (  \" autoProxyCreator \"  ,    new   RootBeanDefinition ( DefaultAdvisorAutoProxyCreator . class )  )  ;", "context . registerBeanDefinition (  \" asyncAdvisor \"  ,    new   RootBeanDefinition ( AsyncAnnotationAdvisor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncInterface . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["dynamicAsyncInterface"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . DynamicAsyncInterfaceBean . class )  )  ;", "context . registerBeanDefinition (  \" asyncProcessor \"  ,    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncInterface . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["dynamicAsyncInterfaceWithPostProcessor"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "AsyncExecutionTests . originalThreadName    =    Thread . currentThread (  )  . getName (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . registerBeanDefinition (  \" asyncTest \"  ,    new   RootBeanDefinition ( AsyncExecutionTests . DynamicAsyncMethodsInterfaceBean . class )  )  ;", "context . registerBeanDefinition (  \" asyncProcessor \"  ,    new   RootBeanDefinition ( AsyncAnnotationBeanPostProcessor . class )  )  ;", "context . refresh (  )  ;", "AsyncExecutionTests . AsyncMethodsInterface   asyncTest    =    context . getBean (  \" asyncTest \"  ,    AsyncExecutionTests . AsyncMethodsInterface . class )  ;", "asyncTest . doSomething (  1  0  )  ;", "Future < String >    future    =    asyncTest . returnSomething (  2  0  )  ;", "assertEquals (  \"  2  0  \"  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["dynamicAsyncMethodsInInterfaceWithPostProcessor"], "fileName": "org.springframework.scheduling.annotation.AsyncExecutionTests"}, {"methodBody": ["METHOD_START", "{", "if    ( original   instanceof   ExecutionException )     {", "Throwable   cause    =    original . getCause (  )  ;", "if    ( cause    !  =    null )     {", "return   cause ;", "}", "}", "return   original ;", "}", "METHOD_END"], "methodName": ["exposedException"], "fileName": "org.springframework.scheduling.annotation.AsyncResult"}, {"methodBody": ["METHOD_START", "{", "return   new   AsyncResult ( null ,    ex )  ;", "}", "METHOD_END"], "methodName": ["forExecutionException"], "fileName": "org.springframework.scheduling.annotation.AsyncResult"}, {"methodBody": ["METHOD_START", "{", "return   new   AsyncResult ( value ,    null )  ;", "}", "METHOD_END"], "methodName": ["forValue"], "fileName": "org.springframework.scheduling.annotation.AsyncResult"}, {"methodBody": ["METHOD_START", "{", "IOException   ex    =    new   IOException (  )  ;", "final   Set < Throwable >    values    =    new   HashSet <  >  (  1  )  ;", "ListenableFuture < String >    future    =    AsyncResult . forExecutionException ( ex )  ;", "future . addCallback ( new   util . concurrent . ListenableFutureCallback < String >  (  )     {", "@ Override", "public   void   onSuccess ( String   result )     {", "fail (  (  \" Success   callback   not   expected :     \"     +    result )  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "values . add ( ex )  ;", "}", "}  )  ;", "assertSame ( ex ,    values . iterator (  )  . next (  )  )  ;", "try    {", "future . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex 2  )     {", "assertSame ( ex ,    ex 2  . getCause (  )  )  ;", "}", "try    {", "future . completable (  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex 2  )     {", "assertSame ( ex ,    ex 2  . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["asyncResultWithCallbackAndException"], "fileName": "org.springframework.scheduling.annotation.AsyncResultTests"}, {"methodBody": ["METHOD_START", "{", "String   value    =     \" val \"  ;", "final   Set < String >    values    =    new   HashSet <  >  (  1  )  ;", "ListenableFuture < String >    future    =    AsyncResult . forValue ( value )  ;", "future . addCallback ( new   util . concurrent . ListenableFutureCallback < String >  (  )     {", "@ Override", "public   void   onSuccess ( String   result )     {", "values . add ( result )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail (  (  \" Failure   callback   not   expected :     \"     +    ex )  )  ;", "}", "}  )  ;", "assertSame ( value ,    values . iterator (  )  . next (  )  )  ;", "assertSame ( value ,    future . get (  )  )  ;", "assertSame ( value ,    future . completable (  )  . get (  )  )  ;", "future . completable (  )  . thenAccept (  (    v )     -  >    assertSame ( value ,    v )  )  ;", "}", "METHOD_END"], "methodName": ["asyncResultWithCallbackAndValue"], "fileName": "org.springframework.scheduling.annotation.AsyncResultTests"}, {"methodBody": ["METHOD_START", "{", "IOException   ex    =    new   IOException (  )  ;", "final   Set < Throwable >    values    =    new   HashSet <  >  (  1  )  ;", "ListenableFuture < String >    future    =     . forExecutionException ( ex )  ;", "future . addCallback (  (    result )     -  >    fail (  (  \" Success   callback   not   expected :     \"     +    result )  )  ,    values :  : add )  ;", "assertSame ( ex ,    values . iterator (  )  . next (  )  )  ;", "try    {", "future . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex 2  )     {", "assertSame ( ex ,    ex 2  . getCause (  )  )  ;", "}", "try    {", "future . completable (  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex 2  )     {", "assertSame ( ex ,    ex 2  . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["asyncResultWithSeparateCallbacksAndException"], "fileName": "org.springframework.scheduling.annotation.AsyncResultTests"}, {"methodBody": ["METHOD_START", "{", "String   value    =     \" val \"  ;", "final   Set < String >    values    =    new   HashSet <  >  (  1  )  ;", "ListenableFuture < String >    future    =     . forValue ( value )  ;", "future . addCallback ( values :  : add ,     (    ex )     -  >    fail (  (  \" Failure   callback   not   expected :     \"     +    ex )  )  )  ;", "assertSame ( value ,    values . iterator (  )  . next (  )  )  ;", "assertSame ( value ,    future . get (  )  )  ;", "assertSame ( value ,    future . completable (  )  . get (  )  )  ;", "future . completable (  )  . thenAccept (  (    v )     -  >    assertSame ( value ,    v )  )  ;", "}", "METHOD_END"], "methodName": ["asyncResultWithSeparateCallbacksAndValue"], "fileName": "org.springframework.scheduling.annotation.AsyncResultTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AspectJAsyncAnnotationConfig . class )  ;", "ctx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["aspectModeAspectJAttemptsToRegisterAsyncAspect"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AsyncConfig . class )  ;", "ctx . refresh (  )  ;", "AsyncAnnotationBeanPostProcessor   bpp    =    ctx . getBean ( AsyncAnnotationBeanPostProcessor . class )  ;", "assertThat ( bpp . getOrder (  )  ,    is ( LOWEST _ PRECEDENCE )  )  ;", "}", "METHOD_END"], "methodName": ["asyncProcessorIsOrderedLowestPrecedenceByDefault"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . CustomAsyncAnnotationConfig . class ,     . CustomAsyncBean . class )  ;", "ctx . refresh (  )  ;", "Object   bean    =    ctx . getBean (  . CustomAsyncBean . class )  ;", "assertTrue ( AopUtils . isAopProxy ( bean )  )  ;", "boolean   isAsyncAdvised    =    false ;", "for    ( Advisor   advisor    :     (  ( Advised )     ( bean )  )  . getAdvisors (  )  )     {", "if    ( advisor   instanceof   AsyncAnnotationAdvisor )     {", "isAsyncAdvised    =    true ;", "break ;", "}", "}", "assertTrue (  \" bean   was   not   async   advised   as   expected \"  ,    isAsyncAdvised )  ;", "}", "METHOD_END"], "methodName": ["customAsyncAnnotationIsPropagated"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . CustomExecutorBean . class )  ;", "ctx . refresh (  )  ;", ". AsyncBean   asyncBean    =    ctx . getBean (  . AsyncBean . class )  ;", "asyncBean . work (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertThat ( asyncBean . getThreadOfExecution (  )  . getName (  )  ,    startsWith (  \" Custom -  \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["customExecutorBean"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . CustomExecutorConfig . class )  ;", "ctx . refresh (  )  ;", ". AsyncBean   asyncBean    =    ctx . getBean (  . AsyncBean . class )  ;", "asyncBean . work (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertThat ( asyncBean . getThreadOfExecution (  )  . getName (  )  ,    startsWith (  \" Custom -  \"  )  )  ;", "TestableAsyncUncaughtExceptionHandler   exceptionHandler    =     (  ( TestableAsyncUncaughtExceptionHandler )     ( ctx . getBean (  \" exceptionHandler \"  )  )  )  ;", "assertFalse (  \" handler   should   not   have   been   called   yet \"  ,    exceptionHandler . isCalled (  )  )  ;", "asyncBean . fail (  )  ;", "Thread . sleep (  5  0  0  )  ;", "Method   method    =    ReflectionUtils . findMethod (  . AsyncBean . class ,     \" fail \"  )  ;", "exceptionHandler . assertCalledWith ( method ,    UnsupportedOperationException . class )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["customExecutorConfig"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . OrderedAsyncConfig . class )  ;", "ctx . refresh (  )  ;", "AsyncAnnotationBeanPostProcessor   bpp    =    ctx . getBean ( AsyncAnnotationBeanPostProcessor . class )  ;", "assertThat ( bpp . getOrder (  )  ,    is ( HIGHEST _ PRECEDENCE )  )  ;", "}", "METHOD_END"], "methodName": ["orderAttributeIsPropagated"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AsyncConfig . class ,     . AsyncBeanWithInterface . class ,     . AsyncBeanUser . class )  ;", "try    {", "ctx . refresh (  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "ex . printStackTrace (  )  ;", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   BeanNotOfRequiredTypeException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["properExceptionForExistingProxyDependencyMismatch"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AsyncConfig . class ,     . AsyncBeanUser . class ,     . AsyncBeanWithInterface . class )  ;", "try    {", "ctx . refresh (  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "ex . printStackTrace (  )  ;", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   BeanNotOfRequiredTypeException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["properExceptionForResolvedProxyDependencyMismatch"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AsyncConfig . class )  ;", "ctx . refresh (  )  ;", ". AsyncBean   asyncBean    =    ctx . getBean (  . AsyncBean . class )  ;", "assertThat ( AopUtils . isAopProxy ( asyncBean )  ,    is ( true )  )  ;", "asyncBean . work (  )  ;", "}", "METHOD_END"], "methodName": ["proxyingOccurs"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AsyncConfigWithMockito . class ,     . AsyncBeanUser . class )  ;", "ctx . refresh (  )  ;", ". AsyncBeanUser   asyncBeanUser    =    ctx . getBean (  . AsyncBeanUser . class )  ;", ". AsyncBean   asyncBean    =    asyncBeanUser . getAsyncBean (  )  ;", "assertThat ( AopUtils . isAopProxy ( asyncBean )  ,    is ( true )  )  ;", "asyncBean . work (  )  ;", "}", "METHOD_END"], "methodName": ["proxyingOccursWithMockitoStub"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableAsyncTests . Spr 1  4  9  4  9 ConfigB . class )  ;", "EnableAsyncTests . AsyncInterface   asyncBean    =    ctx . getBean ( EnableAsyncTests . AsyncInterface . class )  ;", "asyncBean . work (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertThat ( asyncBean . getThreadOfExecution (  )  . getName (  )  ,    startsWith (  \" Custom -  \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr14949FindsOnInterfaceWithCglibProxy"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableAsyncTests . Spr 1  4  9  4  9 ConfigA . class )  ;", "EnableAsyncTests . AsyncInterface   asyncBean    =    ctx . getBean ( EnableAsyncTests . AsyncInterface . class )  ;", "asyncBean . work (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertThat ( asyncBean . getThreadOfExecution (  )  . getName (  )  ,    startsWith (  \" Custom -  \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr14949FindsOnInterfaceWithInterfaceProxy"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . AsyncWithExecutorQualifiedByNameConfig . class )  ;", "ctx . refresh (  )  ;", ". AsyncBeanWithExecutorQualifiedByName   asyncBean    =    ctx . getBean (  . AsyncBeanWithExecutorQualifiedByName . class )  ;", "Future < Thread >    workerThread 0     =    asyncBean . work 0  (  )  ;", "assertThat ( workerThread 0  . get (  )  . getName (  )  ,    not ( anyOf ( startsWith (  \" e 1  -  \"  )  ,    startsWith (  \" otherExecutor -  \"  )  )  )  )  ;", "Future < Thread >    workerThread    =    asyncBean . work (  )  ;", "assertThat ( workerThread . get (  )  . getName (  )  ,    startsWith (  \" e 1  -  \"  )  )  ;", "Future < Thread >    workerThread 2     =    asyncBean . work 2  (  )  ;", "assertThat ( workerThread 2  . get (  )  . getName (  )  ,    startsWith (  \" otherExecutor -  \"  )  )  ;", "Future < Thread >    workerThread 3     =    asyncBean . work 3  (  )  ;", "assertThat ( workerThread 3  . get (  )  . getName (  )  ,    startsWith (  \" otherExecutor -  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withAsyncBeanWithExecutorQualifiedByName"], "fileName": "org.springframework.scheduling.annotation.EnableAsyncTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ctx )     !  =    null )     {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "ctx    =    new   AnnotationConfigApplicationContext ( EnableSchedulingTests . SchedulingEnabled _ withAmbiguousTaskSchedulers _ andSingleTask . class )  ;", "}", "METHOD_END"], "methodName": ["withAmbiguousTaskSchedulers_andSingleTask"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . SchedulingEnabled _ withAmbiguousTaskSchedulers _ andSingleTask _ disambiguatedByScheduledTaskRegistrar . class )  ;", "Thread . sleep (  1  0  0  )  ;", "assertThat ( ctx . getBean (  . ThreadAwareWorker . class )  . executedByThread ,    startsWith (  \" explicitScheduler 2  -  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withAmbiguousTaskSchedulers_andSingleTask_disambiguatedByScheduledTaskRegistrarBean"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . SchedulingEnabled _ withAmbiguousTaskSchedulers _ andSingleTask _ disambiguatedBySchedulerNameAttribute . class )  ;", "Thread . sleep (  1  0  0  )  ;", "assertThat ( ctx . getBean (  . ThreadAwareWorker . class )  . executedByThread ,    startsWith (  \" explicitScheduler 2  -  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withAmbiguousTaskSchedulers_andSingleTask_disambiguatedBySchedulerNameAttribute"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "ctx    =    new   AnnotationConfigApplicationContext ( EnableSchedulingTests . SchedulingEnabled _ withAmbiguousTaskSchedulers _ butNoActualTasks . class )  ;", "}", "METHOD_END"], "methodName": ["withAmbiguousTaskSchedulers_butNoActualTasks"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . ExplicitScheduledTaskRegistrarConfig . class )  ;", "assertEquals (  1  ,    ctx . getBean ( ScheduledTaskHolder . class )  . getScheduledTasks (  )  . size (  )  )  ;", "Thread . sleep (  1  0  0  )  ;", "assertThat ( ctx . getBean ( AtomicInteger . class )  . get (  )  ,    greaterThanOrEqualTo (  1  0  )  )  ;", "assertThat ( ctx . getBean (  . ExplicitScheduledTaskRegistrarConfig . class )  . threadName ,    startsWith (  \" explicitScheduler 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withExplicitScheduledTaskRegistrar"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . ExplicitSchedulerConfig . class )  ;", "assertEquals (  1  ,    ctx . getBean ( ScheduledTaskHolder . class )  . getScheduledTasks (  )  . size (  )  )  ;", "Thread . sleep (  1  0  0  )  ;", "assertThat ( ctx . getBean ( AtomicInteger . class )  . get (  )  ,    greaterThanOrEqualTo (  1  0  )  )  ;", "assertThat ( ctx . getBean (  . ExplicitSchedulerConfig . class )  . threadName ,    startsWith (  \" explicitScheduler -  \"  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getDefaultListableBeanFactory (  )  . getDependentBeans (  \" myTaskScheduler \"  )  )  . contains ( TaskManagementConfigUtils . SCHEDULED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["withExplicitScheduler"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "ctx    =    new   AnnotationConfigApplicationContext ( EnableSchedulingTests . AmbiguousExplicitSchedulerConfig . class )  ;", "}", "METHOD_END"], "methodName": ["withExplicitSchedulerAmbiguity_andSchedulingEnabled"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . FixedRateTaskConfig . class )  ;", "assertEquals (  2  ,    ctx . getBean ( ScheduledTaskHolder . class )  . getScheduledTasks (  )  . size (  )  )  ;", "Thread . sleep (  1  0  0  )  ;", "assertThat ( ctx . getBean ( AtomicInteger . class )  . get (  )  ,    greaterThanOrEqualTo (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["withFixedRateTask"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . FixedRateTaskConfig _ withInitialDelay . class )  ;", "Thread . sleep (  1  9  5  0  )  ;", "AtomicInteger   counter    =    ctx . getBean ( AtomicInteger . class )  ;", "assertThat ( counter . get (  )  ,    both ( greaterThan (  0  )  )  . and ( lessThanOrEqualTo (  1  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withInitiallyDelayedFixedRateTask"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . FixedRateTaskConfigSubclass . class )  ;", "assertEquals (  2  ,    ctx . getBean ( ScheduledTaskHolder . class )  . getScheduledTasks (  )  . size (  )  )  ;", "Thread . sleep (  1  0  0  )  ;", "assertThat ( ctx . getBean ( AtomicInteger . class )  . get (  )  ,    greaterThanOrEqualTo (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["withSubclass"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . SchedulingEnabled _ withTaskAddedVia _ configureTasks . class )  ;", "Thread . sleep (  1  0  0  )  ;", "assertThat ( ctx . getBean (  . ThreadAwareWorker . class )  . executedByThread ,    startsWith (  \" taskScheduler -  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withTaskAddedVia_configureTasks"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ctx    =    new   AnnotationConfigApplicationContext (  . TriggerTaskConfig . class )  ;", "Thread . sleep (  1  0  0  )  ;", "assertThat ( ctx . getBean ( AtomicInteger . class )  . get (  )  ,    greaterThan (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["withTriggerTask"], "fileName": "org.springframework.scheduling.annotation.EnableSchedulingTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . enableAsync ,     \"  @ EnableAsync   annotation   metadata   was   not   injected \"  )  ;", "AsyncAnnotationBeanPostProcessor   bpp    =    new   AsyncAnnotationBeanPostProcessor (  )  ;", "Class <  ?    extends   Annotation >    customAsyncAnnotation    =    this . enableAsync . getClass (  \" annotation \"  )  ;", "if    ( customAsyncAnnotation    !  =     ( AnnotationUtils . getDefaultValue ( EnableAsync . class ,     \" annotation \"  )  )  )     {", "bpp . setAsyncAnnotationType ( customAsyncAnnotation )  ;", "}", "if    (  ( this . executor )     !  =    null )     {", "bpp . setExecutor ( this . executor )  ;", "}", "if    (  ( this . exceptionHandler )     !  =    null )     {", "bpp . setExceptionHandler ( this . exceptionHandler )  ;", "}", "bpp . setProxyTargetClass ( this . enableAsync . getBoolean (  \" proxyTargetClass \"  )  )  ;", "bpp . setOrder ( this . enableAsync .  < Integer > getNumber (  \" order \"  )  )  ;", "return   bpp ;", "}", "METHOD_END"], "methodName": ["asyncAdvisor"], "fileName": "org.springframework.scheduling.annotation.ProxyAsyncConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduler )     !  =    null )     {", "this . registrar . setScheduler ( this . scheduler )  ;", "}", "if    (  ( this . beanFactory )    instanceof   ListableBeanFactory )     {", "Map < String ,    SchedulingConfigurer >    beans    =     (  ( ListableBeanFactory )     ( this . beanFactory )  )  . getBeansOfType ( SchedulingConfigurer . class )  ;", "List < SchedulingConfigurer >    configurers    =    new   ArrayList <  >  ( beans . values (  )  )  ;", "AwareOrderComparator . sort ( configurers )  ;", "for    ( SchedulingConfigurer   configurer    :    configurers )     {", "configurer . configureTasks ( this . registrar )  ;", "}", "}", "if    (  ( this . registrar . hasTasks (  )  )     &  &     (  ( this . registrar . getScheduler (  )  )     =  =    null )  )     {", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" BeanFactory   must   be   set   to   find   scheduler   by   type \"  )  ;", "try    {", "this . registrar . setTaskScheduler ( resolveSchedulerBean ( beanFactory ,    TaskScheduler . class ,    false )  )  ;", "}    catch    ( NoUniqueBeanDefinitionException   ex )     {", "logger . debug (  \" Could   not   find   unique   TaskScheduler   bean \"  ,    ex )  ;", "try    {", "this . registrar . setTaskScheduler ( resolveSchedulerBean ( beanFactory ,    TaskScheduler . class ,    true )  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex 2  )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" More   than   one   TaskScheduler   bean   exists   within   the   context ,    and    \"     +     (  (  \" none   is   named    ' taskScheduler '  .    Mark   one   of   them   as   primary   or   name   it    ' taskScheduler '     \"     +     \"  ( possibly   as   an   alias )  ;    or   implement   the   SchedulingConfigurer   interface   and   call    \"  )     +     \" ScheduledTaskRegistrar # setScheduler   explicitly   within   the   configureTasks (  )    callback :     \"  )  )     +     ( ex . getBeanNamesFound (  )  )  )  )  ;", "}", "}", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "logger . debug (  \" Could   not   find   default   TaskScheduler   bean \"  ,    ex )  ;", "try    {", "this . registrar . setScheduler ( resolveSchedulerBean ( beanFactory ,    ScheduledExecutorService . class ,    false )  )  ;", "}    catch    ( NoUniqueBeanDefinitionException   ex 2  )     {", "logger . debug (  \" Could   not   find   unique   ScheduledExecutorService   bean \"  ,    ex 2  )  ;", "try    {", "this . registrar . setScheduler ( resolveSchedulerBean ( beanFactory ,    ScheduledExecutorService . class ,    true )  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex 3  )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" More   than   one   ScheduledExecutorService   bean   exists   within   the   context ,    and    \"     +     (  (  \" none   is   named    ' taskScheduler '  .    Mark   one   of   them   as   primary   or   name   it    ' taskScheduler '     \"     +     \"  ( possibly   as   an   alias )  ;    or   implement   the   SchedulingConfigurer   interface   and   call    \"  )     +     \" ScheduledTaskRegistrar # setScheduler   explicitly   within   the   configureTasks (  )    callback :     \"  )  )     +     ( ex 2  . getBeanNamesFound (  )  )  )  )  ;", "}", "}", "}    catch    ( NoSuchBeanDefinitionException   ex 2  )     {", "logger . debug (  \" Could   not   find   default   ScheduledExecutorService   bean \"  ,    ex 2  )  ;", "logger . info (  \" No   TaskScheduler / ScheduledExecutorService   bean   found   for   scheduled   processing \"  )  ;", "}", "}", "}", "this . registrar . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["finishRegistration"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( ch    =  =     ' P '  )     |  |     ( ch    =  =     ' p '  )  ;", "}", "METHOD_END"], "methodName": ["isP"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( value . length (  )  )     >     1  )     &  &     (  ( ScheduledAnnotationBeanPostProcessor . isP ( value . charAt (  0  )  )  )     |  |     ( ScheduledAnnotationBeanPostProcessor . isP ( value . charAt (  1  )  )  )  )  )     {", "return   Duration . parse ( value )  . toMillis (  )  ;", "}", "return   Long . parseLong ( value )  ;", "}", "METHOD_END"], "methodName": ["parseDelayAsLong"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "Assert . isTrue (  (  ( method . getParameterCount (  )  )     =  =     0  )  ,     \" Only   no - arg   methods   may   be   annotated   with    @ Scheduled \"  )  ;", "Method   invocableMethod    =    AopUtils . selectInvocableMethod ( method ,    bean . getClass (  )  )  ;", "Runnable   runnable    =    new   ScheduledMethodRunnable ( bean ,    invocableMethod )  ;", "boolean   processedSchedule    =    false ;", "String   errorMessage    =     \" Exactly   one   of   the    ' cron '  ,     ' fixedDelay ( String )  '  ,    or    ' fixedRate ( String )  '    attributes   is   required \"  ;", "Set < ScheduledTask >    tasks    =    new   LinkedHashSet <  >  (  4  )  ;", "long   initialDelay    =    scheduled . initialDelay (  )  ;", "String   initialDelayString    =    scheduled . initialDelayString (  )  ;", "if    ( StringUtils . hasText ( initialDelayString )  )     {", "Assert . isTrue (  ( initialDelay    <     0  )  ,     \" Specify    ' initialDelay '    or    ' initialDelayString '  ,    not   both \"  )  ;", "if    (  ( this . embeddedValueResolver )     !  =    null )     {", "initialDelayString    =    this . embeddedValueResolver . resolveStringValue ( initialDelayString )  ;", "}", "if    ( StringUtils . hasLength ( initialDelayString )  )     {", "try    {", "initialDelay    =     . parseDelayAsLong ( initialDelayString )  ;", "}    catch    ( RuntimeException   ex )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   initialDelayString   value    \\  \"  \"     +    initialDelayString )     +     \"  \\  \"     -    cannot   parse   into   long \"  )  )  ;", "}", "}", "}", "String   cron    =    scheduled . cron (  )  ;", "if    ( StringUtils . hasText ( cron )  )     {", "String   zone    =    scheduled . zone (  )  ;", "if    (  ( this . embeddedValueResolver )     !  =    null )     {", "cron    =    this . embeddedValueResolver . resolveStringValue ( cron )  ;", "zone    =    this . embeddedValueResolver . resolveStringValue ( zone )  ;", "}", "if    ( StringUtils . hasLength ( cron )  )     {", "Assert . isTrue (  ( initialDelay    =  =     (  -  1  )  )  ,     \"  ' initialDelay '    not   supported   for   cron   triggers \"  )  ;", "processedSchedule    =    true ;", "TimeZone   timeZone ;", "if    ( StringUtils . hasText ( zone )  )     {", "timeZone    =    StringUtils . parseTimeZoneString ( zone )  ;", "} else    {", "timeZone    =    TimeZone . getDefault (  )  ;", "}", "tasks . add ( this . registrar . scheduleCronTask ( new   CronTask ( runnable ,    new   CronTrigger ( cron ,    timeZone )  )  )  )  ;", "}", "}", "if    ( initialDelay    <     0  )     {", "initialDelay    =     0  ;", "}", "long   fixedDelay    =    scheduled . fixedDelay (  )  ;", "if    ( fixedDelay    >  =     0  )     {", "Assert . isTrue (  (  ! processedSchedule )  ,    errorMessage )  ;", "processedSchedule    =    true ;", "tasks . add ( this . registrar . scheduleFixedDelayTask ( new   FixedDelayTask ( runnable ,    fixedDelay ,    initialDelay )  )  )  ;", "}", "String   fixedDelayString    =    scheduled . fixedDelayString (  )  ;", "if    ( StringUtils . hasText ( fixedDelayString )  )     {", "if    (  ( this . embeddedValueResolver )     !  =    null )     {", "fixedDelayString    =    this . embeddedValueResolver . resolveStringValue ( fixedDelayString )  ;", "}", "if    ( StringUtils . hasLength ( fixedDelayString )  )     {", "Assert . isTrue (  (  ! processedSchedule )  ,    errorMessage )  ;", "processedSchedule    =    true ;", "try    {", "fixedDelay    =     . parseDelayAsLong ( fixedDelayString )  ;", "}    catch    ( RuntimeException   ex )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   fixedDelayString   value    \\  \"  \"     +    fixedDelayString )     +     \"  \\  \"     -    cannot   parse   into   long \"  )  )  ;", "}", "tasks . add ( this . registrar . scheduleFixedDelayTask ( new   FixedDelayTask ( runnable ,    fixedDelay ,    initialDelay )  )  )  ;", "}", "}", "long   fixedRate    =    scheduled . fixedRate (  )  ;", "if    ( fixedRate    >  =     0  )     {", "Assert . isTrue (  (  ! processedSchedule )  ,    errorMessage )  ;", "processedSchedule    =    true ;", "tasks . add ( this . registrar . scheduleFixedRateTask ( new   FixedRateTask ( runnable ,    fixedRate ,    initialDelay )  )  )  ;", "}", "String   fixedRateString    =    scheduled . fixedRateString (  )  ;", "if    ( StringUtils . hasText ( fixedRateString )  )     {", "if    (  ( this . embeddedValueResolver )     !  =    null )     {", "fixedRateString    =    this . embeddedValueResolver . resolveStringValue ( fixedRateString )  ;", "}", "if    ( StringUtils . hasLength ( fixedRateString )  )     {", "Assert . isTrue (  (  ! processedSchedule )  ,    errorMessage )  ;", "processedSchedule    =    true ;", "try    {", "fixedRate    =     . parseDelayAsLong ( fixedRateString )  ;", "}    catch    ( RuntimeException   ex )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   fixedRateString   value    \\  \"  \"     +    fixedRateString )     +     \"  \\  \"     -    cannot   parse   into   long \"  )  )  ;", "}", "tasks . add ( this . registrar . scheduleFixedRateTask ( new   FixedRateTask ( runnable ,    fixedRate ,    initialDelay )  )  )  ;", "}", "}", "Assert . isTrue ( processedSchedule ,    errorMessage )  ;", "synchronized ( this . scheduledTasks )     {", "Set < ScheduledTask >    registeredTasks    =    this . scheduledTasks . get ( bean )  ;", "if    ( registeredTasks    =  =    null )     {", "registeredTasks    =    new   LinkedHashSet <  >  (  4  )  ;", "this . scheduledTasks . put ( bean ,    registeredTasks )  ;", "}", "registeredTasks . addAll ( tasks )  ;", "}", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   IllegalStateException (  (  (  (  \" Encountered   invalid    @ Scheduled   method    '  \"     +     ( method . getName (  )  )  )     +     \"  '  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processScheduled"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( byName )     {", "T   scheduler    =    beanFactory . getBean (  . DEFAULT _ TASK _ SCHEDULER _ BEAN _ NAME ,    schedulerType )  ;", "if    (  (  ( this . beanName )     !  =    null )     &  &     (  ( this . beanFactory )    instanceof   ConfigurableBeanFactory )  )     {", "(  ( ConfigurableBeanFactory )     ( this . beanFactory )  )  . registerDependentBean (  . DEFAULT _ TASK _ SCHEDULER _ BEAN _ NAME ,    this . beanName )  ;", "}", "return   scheduler ;", "} else", "if    ( beanFactory   instanceof   AutowireCapableBeanFactory )     {", "NamedBeanHolder < T >    holder    =     (  ( AutowireCapableBeanFactory )     ( beanFactory )  )  . resolveNamedBean ( schedulerType )  ;", "if    (  (  ( this . beanName )     !  =    null )     &  &     ( beanFactory   instanceof   ConfigurableBeanFactory )  )     {", "(  ( ConfigurableBeanFactory )     ( beanFactory )  )  . registerDependentBean ( holder . getBeanName (  )  ,    this . beanName )  ;", "}", "return   holder . getBeanInstance (  )  ;", "} else    {", "return   beanFactory . getBean ( schedulerType )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveSchedulerBean"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . scheduler    =    scheduler ;", "}", "METHOD_END"], "methodName": ["setScheduler"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["closeContextAfterTest"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . ComposedAnnotationFixedRateTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < IntervalTask >    fixedRateTasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" fixedRateTasks \"  )  )  )  ;", "assertEquals (  1  ,    fixedRateTasks . size (  )  )  ;", "IntervalTask   task    =    fixedRateTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" checkForUpdates \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  5  0  0  0 L ,    task . getInterval (  )  )  ;", "assertEquals (  1  0  0  0 L ,    task . getInitialDelay (  )  )  ;", "}", "METHOD_END"], "methodName": ["composedAnnotationWithInitialDelayAndFixedRate"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . CronTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < CronTask >    cronTasks    =     (  ( List < CronTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" cronTasks \"  )  )  )  ;", "assertEquals (  1  ,    cronTasks . size (  )  )  ;", "CronTask   task    =    cronTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" cron \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  \"  *  /  7     *     *     *     *     ?  \"  ,    task . getExpression (  )  )  ;", "Thread . sleep (  1  0  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["cronTask"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . CronWithInvalidTimezoneTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Thread . sleep (  1  0  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["cronTaskWithInvalidZone"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   validationDefinition    =    new   RootBeanDefinition ( MethodValidationPostProcessor . class )  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . CronTestBean . class )  ;", "context . registerBeanDefinition (  \" methodValidation \"  ,    validationDefinition )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["cronTaskWithMethodValidation"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . CronWithTimezoneTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < CronTask >    cronTasks    =     (  ( List < CronTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" cronTasks \"  )  )  )  ;", "assertEquals (  1  ,    cronTasks . size (  )  )  ;", "CronTask   task    =    cronTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" cron \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  \"  0     0     0  -  4  ,  6  -  2  3     *     *     ?  \"  ,    task . getExpression (  )  )  ;", "Trigger   trigger    =    task . getTrigger (  )  ;", "assertNotNull ( trigger )  ;", "assertTrue (  ( trigger   instanceof   CronTrigger )  )  ;", "CronTrigger   cronTrigger    =     (  ( CronTrigger )     ( trigger )  )  ;", "Calendar   cal    =    Calendar . getInstance ( TimeZone . getTimeZone (  \" GMT +  1  0  \"  )  )  ;", "cal . clear (  )  ;", "cal . set (  2  0  1  3  ,     3  ,     1  5  ,     4  ,     0  )  ;", "Date   lastScheduledExecutionTime    =    cal . getTime (  )  ;", "Date   lastActualExecutionTime    =    cal . getTime (  )  ;", "cal . add ( Calendar . MINUTE ,     3  0  )  ;", "Date   lastCompletionTime    =    cal . getTime (  )  ;", "TriggerContext   triggerContext    =    new   SimpleTriggerContext ( lastScheduledExecutionTime ,    lastActualExecutionTime ,    lastCompletionTime )  ;", "cal . add ( Calendar . MINUTE ,     3  0  )  ;", "cal . add ( Calendar . HOUR _ OF _ DAY ,     1  )  ;", "Date   nextExecutionTime    =    cronTrigger . nextExecutionTime ( triggerContext )  ;", "assertEquals ( cal . getTime (  )  ,    nextExecutionTime )  ;", "Thread . sleep (  1  0  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["cronTaskWithZone"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . EmptyAnnotationTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["emptyAnnotation"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   businessHoursCronExpression    =     \"  0     0     9  -  1  7     *     *    MON - FRI \"  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . ExpressionWithCronTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "Map < String ,    String >    schedules    =    new   HashMap <  >  (  )  ;", "schedules . put (  \" businessHours \"  ,    businessHoursCronExpression )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" schedules \"  ,    schedules )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < CronTask >    cronTasks    =     (  ( List < CronTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" cronTasks \"  )  )  )  ;", "assertEquals (  1  ,    cronTasks . size (  )  )  ;", "CronTask   task    =    cronTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" x \"  ,    targetMethod . getName (  )  )  ;", "assertEquals ( businessHoursCronExpression ,    task . getExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["expressionWithCron"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . FixedDelayTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < IntervalTask >    fixedDelayTasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" fixedDelayTasks \"  )  )  )  ;", "assertEquals (  1  ,    fixedDelayTasks . size (  )  )  ;", "IntervalTask   task    =    fixedDelayTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" fixedDelay \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  0 L ,    task . getInitialDelay (  )  )  ;", "assertEquals (  5  0  0  0 L ,    task . getInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedDelayTask"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . FixedRateTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < IntervalTask >    fixedRateTasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" fixedRateTasks \"  )  )  )  ;", "assertEquals (  1  ,    fixedRateTasks . size (  )  )  ;", "IntervalTask   task    =    fixedRateTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" fixedRate \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  0 L ,    task . getInitialDelay (  )  )  ;", "assertEquals (  3  0  0  0 L ,    task . getInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedRateTask"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . FixedRateWithInitialDelayTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < IntervalTask >    fixedRateTasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" fixedRateTasks \"  )  )  )  ;", "assertEquals (  1  ,    fixedRateTasks . size (  )  )  ;", "IntervalTask   task    =    fixedRateTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" fixedRate \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  1  0  0  0 L ,    task . getInitialDelay (  )  )  ;", "assertEquals (  3  0  0  0 L ,    task . getInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedRateTaskWithInitialDelay"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . InvalidCronTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["invalidCron"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . MetaAnnotationCronTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < CronTask >    cronTasks    =     (  ( List < CronTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" cronTasks \"  )  )  )  ;", "assertEquals (  1  ,    cronTasks . size (  )  )  ;", "CronTask   task    =    cronTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" generateReport \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  \"  0     0     *     *     *     ?  \"  ,    task . getExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["metaAnnotationWithCronExpression"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . MetaAnnotationFixedRateTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < IntervalTask >    fixedRateTasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" fixedRateTasks \"  )  )  )  ;", "assertEquals (  1  ,    fixedRateTasks . size (  )  )  ;", "IntervalTask   task    =    fixedRateTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" checkForUpdates \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  5  0  0  0 L ,    task . getInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["metaAnnotationWithFixedRate"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . NonEmptyParamListTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["nonEmptyParamList"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . NonVoidReturnTypeTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < CronTask >    cronTasks    =     (  ( List < CronTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" cronTasks \"  )  )  )  ;", "assertEquals (  1  ,    cronTasks . size (  )  )  ;", "CronTask   task    =    cronTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" cron \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  \"  0     0     9  -  1  7     *     *    MON - FRI \"  ,    task . getExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["nonVoidReturnType"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   businessHoursCronExpression    =     \"  0     0     9  -  1  7     *     *    MON - FRI \"  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   placeholderDefinition    =    new   RootBeanDefinition ( PropertyPlaceholderConfigurer . class )  ;", "Properties   properties    =    new   Properties (  )  ;", "properties . setProperty (  \" schedules . businessHours \"  ,    businessHoursCronExpression )  ;", "placeholderDefinition . getPropertyValues (  )  . addPropertyValue (  \" properties \"  ,    properties )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . PropertyPlaceholderMetaAnnotationTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" placeholder \"  ,    placeholderDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < CronTask >    cronTasks    =     (  ( List < CronTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" cronTasks \"  )  )  )  ;", "assertEquals (  1  ,    cronTasks . size (  )  )  ;", "CronTask   task    =    cronTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" y \"  ,    targetMethod . getName (  )  )  ;", "assertEquals ( businessHoursCronExpression ,    task . getExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderForMetaAnnotation"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "String   businessHoursCronExpression    =     \"  0     0     9  -  1  7     *     *    MON - FRI \"  ;", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   placeholderDefinition    =    new   RootBeanDefinition ( PropertyPlaceholderConfigurer . class )  ;", "Properties   properties    =    new   Properties (  )  ;", "properties . setProperty (  \" schedules . businessHours \"  ,    businessHoursCronExpression )  ;", "placeholderDefinition . getPropertyValues (  )  . addPropertyValue (  \" properties \"  ,    properties )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . PropertyPlaceholderWithCronTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" placeholder \"  ,    placeholderDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < CronTask >    cronTasks    =     (  ( List < CronTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" cronTasks \"  )  )  )  ;", "assertEquals (  1  ,    cronTasks . size (  )  )  ;", "CronTask   task    =    cronTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" x \"  ,    targetMethod . getName (  )  )  ;", "assertEquals ( businessHoursCronExpression ,    task . getExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithCron"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   placeholderDefinition    =    new   RootBeanDefinition ( PropertyPlaceholderConfigurer . class )  ;", "Properties   properties    =    new   Properties (  )  ;", "properties . setProperty (  \" fixedDelay \"  ,     ( durationFormat    ?     \" PT 5 S \"     :     \"  5  0  0  0  \"  )  )  ;", "properties . setProperty (  \" initialDelay \"  ,     ( durationFormat    ?     \" PT 1 S \"     :     \"  1  0  0  0  \"  )  )  ;", "placeholderDefinition . getPropertyValues (  )  . addPropertyValue (  \" properties \"  ,    properties )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . PropertyPlaceholderWithFixedDelayTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" placeholder \"  ,    placeholderDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < IntervalTask >    fixedDelayTasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" fixedDelayTasks \"  )  )  )  ;", "assertEquals (  1  ,    fixedDelayTasks . size (  )  )  ;", "IntervalTask   task    =    fixedDelayTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" fixedDelay \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  1  0  0  0 L ,    task . getInitialDelay (  )  )  ;", "assertEquals (  5  0  0  0 L ,    task . getInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithFixedDelay"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "propertyPlaceholderWithFixedDelay ( true )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithFixedDelayInDuration"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "propertyPlaceholderWithFixedDelay ( false )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithFixedDelayInMillis"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   placeholderDefinition    =    new   RootBeanDefinition ( PropertyPlaceholderConfigurer . class )  ;", "Properties   properties    =    new   Properties (  )  ;", "properties . setProperty (  \" fixedRate \"  ,     ( durationFormat    ?     \" PT 3 S \"     :     \"  3  0  0  0  \"  )  )  ;", "properties . setProperty (  \" initialDelay \"  ,     ( durationFormat    ?     \" PT 1 S \"     :     \"  1  0  0  0  \"  )  )  ;", "placeholderDefinition . getPropertyValues (  )  . addPropertyValue (  \" properties \"  ,    properties )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . PropertyPlaceholderWithFixedRateTestBean . class )  ;", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" placeholder \"  ,    placeholderDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < IntervalTask >    fixedRateTasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" fixedRateTasks \"  )  )  )  ;", "assertEquals (  1  ,    fixedRateTasks . size (  )  )  ;", "IntervalTask   task    =    fixedRateTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable    =     (  ( ScheduledMethodRunnable )     ( task . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable . getTarget (  )  ;", "Method   targetMethod    =    runnable . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" fixedRate \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  1  0  0  0 L ,    task . getInitialDelay (  )  )  ;", "assertEquals (  3  0  0  0 L ,    task . getInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithFixedRate"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "propertyPlaceholderWithFixedRate ( true )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithFixedRateInDuration"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "propertyPlaceholderWithFixedRate ( false )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithFixedRateInMillis"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "context . registerBeanDefinition (  \" postProcessor \"  ,    processorDefinition )  ;", "context . registerBeanDefinition (  \" target \"  ,    targetDefinition )  ;", "context . refresh (  )  ;", "Object   postProcessor    =    context . getBean (  \" postProcessor \"  )  ;", "Object   target    =    context . getBean (  \" target \"  )  ;", "ScheduledTaskRegistrar   registrar    =     (  ( ScheduledTaskRegistrar )     ( new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" registrar \"  )  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < IntervalTask >    fixedRateTasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( registrar )  . getPropertyValue (  \" fixedRateTasks \"  )  )  )  ;", "assertEquals (  2  ,    fixedRateTasks . size (  )  )  ;", "IntervalTask   task 1     =    fixedRateTasks . get (  0  )  ;", "ScheduledMethodRunnable   runnable 1     =     (  ( ScheduledMethodRunnable )     ( task 1  . getRunnable (  )  )  )  ;", "Object   targetObject    =    runnable 1  . getTarget (  )  ;", "Method   targetMethod    =    runnable 1  . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" fixedRate \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  0  ,    task 1  . getInitialDelay (  )  )  ;", "assertEquals (  4  0  0  0 L ,    task 1  . getInterval (  )  )  ;", "IntervalTask   task 2     =    fixedRateTasks . get (  1  )  ;", "ScheduledMethodRunnable   runnable 2     =     (  ( ScheduledMethodRunnable )     ( task 2  . getRunnable (  )  )  )  ;", "targetObject    =    runnable 2  . getTarget (  )  ;", "targetMethod    =    runnable 2  . getMethod (  )  ;", "assertEquals ( target ,    targetObject )  ;", "assertEquals (  \" fixedRate \"  ,    targetMethod . getName (  )  )  ;", "assertEquals (  2  0  0  0 L ,    task 2  . getInitialDelay (  )  )  ;", "assertEquals (  4  0  0  0 L ,    task 2  . getInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["severalFixedRates"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . SeveralFixedRatesWithRepeatedScheduledAnnotationTestBean . class )  ;", "targetDefinition . setFactoryMethodName (  \" nestedProxy \"  )  ;", "severalFixedRates ( context ,    processorDefinition ,    targetDefinition )  ;", "}", "METHOD_END"], "methodName": ["severalFixedRatesAgainstNestedCglibProxy"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . FixedRatesSubBean . class )  ;", "severalFixedRates ( context ,    processorDefinition ,    targetDefinition )  ;", "}", "METHOD_END"], "methodName": ["severalFixedRatesOnBaseClass"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . FixedRatesDefaultBean . class )  ;", "severalFixedRates ( context ,    processorDefinition ,    targetDefinition )  ;", "}", "METHOD_END"], "methodName": ["severalFixedRatesOnDefaultMethod"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . SeveralFixedRatesWithRepeatedScheduledAnnotationTestBean . class )  ;", "severalFixedRates ( context ,    processorDefinition ,    targetDefinition )  ;", "}", "METHOD_END"], "methodName": ["severalFixedRatesWithRepeatedScheduledAnnotation"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorDefinition    =    new   RootBeanDefinition ( ScheduledAnnotationBeanPostProcessor . class )  ;", "BeanDefinition   targetDefinition    =    new   RootBeanDefinition (  . SeveralFixedRatesWithSchedulesContainerAnnotationTestBean . class )  ;", "severalFixedRates ( context ,    processorDefinition ,    targetDefinition )  ;", "}", "METHOD_END"], "methodName": ["severalFixedRatesWithSchedulesContainerAnnotation"], "fileName": "org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ScheduledAnnotationBeanPostProcessor (  )  ;", "}", "METHOD_END"], "methodName": ["scheduledAnnotationProcessor"], "fileName": "org.springframework.scheduling.annotation.SchedulingConfiguration"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Handler   not   called \"  ,    descriptor )  ;", "assertEquals (  \" Wrong   exception   type \"  ,    expectedType ,    descriptor . ex . getClass (  )  )  ;", "assertEquals (  \" Wrong   method \"  ,    expectedMethod ,    descriptor . method )  ;", "}", "METHOD_END"], "methodName": ["assertCalledWith"], "fileName": "org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . latch . await ( timeout ,    TimeUnit . MILLISECONDS )  ;", "}    catch    (    e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "METHOD_END"], "methodName": ["await"], "fileName": "org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "return    ( descriptor )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isCalled"], "fileName": "org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( AbstractSchedulingTaskExecutorTests . THREAD _ NAME _ PREFIX ,    task . lastThread . getName (  )  . substring (  0  ,    AbstractSchedulingTaskExecutorTests . THREAD _ NAME _ PREFIX . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertThreadNamePrefix"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "latch . await (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "}    catch    ( InterruptedException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "assertEquals (  \" latch   did   not   count   down ,  \"  ,     0  ,    latch . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["await"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "await ( task . latch )  ;", "}", "METHOD_END"], "methodName": ["await"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestTask   task    =    new   AbstractSchedulingTaskExecutorTests . TestTask (  0  )  ;", "executor . execute ( task )  ;", "}", "METHOD_END"], "methodName": ["executeFailingRunnable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestTask   task    =    new   AbstractSchedulingTaskExecutorTests . TestTask (  1  )  ;", "executor . execute ( task )  ;", "await ( task )  ;", "assertThreadNamePrefix ( task )  ;", "}", "METHOD_END"], "methodName": ["executeRunnable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "executor    =    buildExecutor (  )  ;", "}", "METHOD_END"], "methodName": ["initExecutor"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executor )    instanceof   DisposableBean )     {", "(  ( DisposableBean )     ( executor )  )  . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["shutdownExecutor"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestCallable   task    =    new   AbstractSchedulingTaskExecutorTests . TestCallable (  1  )  ;", "Future < String >    future    =    executor . submit ( task )  ;", "String   result    =    future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "assertEquals ( AbstractSchedulingTaskExecutorTests . THREAD _ NAME _ PREFIX ,    result . substring (  0  ,    AbstractSchedulingTaskExecutorTests . THREAD _ NAME _ PREFIX . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["submitCallable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestCallable   task 1     =    new   AbstractSchedulingTaskExecutorTests . TestCallable (  (  -  1  )  )  ;", "Future <  ?  >    future 1     =    executor . submit ( task 1  )  ;", "AbstractSchedulingTaskExecutorTests . TestCallable   task 2     =    new   AbstractSchedulingTaskExecutorTests . TestCallable (  (  -  1  )  )  ;", "Future <  ?  >    future 2     =    executor . submit ( task 2  )  ;", "shutdownExecutor (  )  ;", "future 1  . get (  1  0  0  ,    TimeUnit . MILLISECONDS )  ;", "future 2  . get (  1  0  0  ,    TimeUnit . MILLISECONDS )  ;", "}", "METHOD_END"], "methodName": ["submitCallableWithGetAfterShutdown"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestCallable   task    =    new   AbstractSchedulingTaskExecutorTests . TestCallable (  0  )  ;", "Future < String >    future    =    executor . submit ( task )  ;", "future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "assertTrue ( future . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["submitFailingCallable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestCallable   task    =    new   AbstractSchedulingTaskExecutorTests . TestCallable (  0  )  ;", "ListenableFuture < String >    future    =    executor . submitListenable ( task )  ;", "future . addCallback (  (    result )     -  >    outcome    =    result ,     (    ex )     -  >    outcome    =    ex )  ;", "Thread . sleep (  1  0  0  )  ;", "assertTrue ( future . isDone (  )  )  ;", "assertSame ( RuntimeException . class ,    outcome . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["submitFailingListenableCallable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestTask   task    =    new   AbstractSchedulingTaskExecutorTests . TestTask (  0  )  ;", "ListenableFuture <  ?  >    future    =    executor . submitListenable ( task )  ;", "future . addCallback (  (    result )     -  >    outcome    =    result ,     (    ex )     -  >    outcome    =    ex )  ;", "Thread . sleep (  1  0  0  0  )  ;", "assertTrue ( future . isDone (  )  )  ;", "assertSame ( RuntimeException . class ,    outcome . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["submitFailingListenableRunnable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestTask   task    =    new   AbstractSchedulingTaskExecutorTests . TestTask (  0  )  ;", "Future <  ?  >    future    =    executor . submit ( task )  ;", "try    {", "future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue ( future . isDone (  )  )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["submitFailingRunnable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestCallable   task    =    new   AbstractSchedulingTaskExecutorTests . TestCallable (  1  )  ;", "ListenableFuture < String >    future    =    executor . submitListenable ( task )  ;", "future . addCallback (  (    result )     -  >    outcome    =    result ,     (    ex )     -  >    outcome    =    ex )  ;", "Thread . sleep (  1  0  0  )  ;", "assertTrue ( future . isDone (  )  )  ;", "assertEquals ( AbstractSchedulingTaskExecutorTests . THREAD _ NAME _ PREFIX ,    outcome . toString (  )  . substring (  0  ,    AbstractSchedulingTaskExecutorTests . THREAD _ NAME _ PREFIX . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["submitListenableCallable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestCallable   task 1     =    new   AbstractSchedulingTaskExecutorTests . TestCallable (  (  -  1  )  )  ;", "ListenableFuture <  ?  >    future 1     =    executor . submitListenable ( task 1  )  ;", "AbstractSchedulingTaskExecutorTests . TestCallable   task 2     =    new   AbstractSchedulingTaskExecutorTests . TestCallable (  (  -  1  )  )  ;", "ListenableFuture <  ?  >    future 2     =    executor . submitListenable ( task 2  )  ;", "shutdownExecutor (  )  ;", "future 1  . get (  1  0  0  ,    TimeUnit . MILLISECONDS )  ;", "future 2  . get (  1  0  0  ,    TimeUnit . MILLISECONDS )  ;", "}", "METHOD_END"], "methodName": ["submitListenableCallableWithGetAfterShutdown"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestTask   task    =    new   AbstractSchedulingTaskExecutorTests . TestTask (  1  )  ;", "ListenableFuture <  ?  >    future    =    executor . submitListenable ( task )  ;", "future . addCallback (  (    result )     -  >    outcome    =    result ,     (    ex )     -  >    outcome    =    ex )  ;", "Thread . sleep (  1  0  0  0  )  ;", "assertTrue ( future . isDone (  )  )  ;", "assertNull ( outcome )  ;", "assertThreadNamePrefix ( task )  ;", "}", "METHOD_END"], "methodName": ["submitListenableRunnable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestTask   task 1     =    new   AbstractSchedulingTaskExecutorTests . TestTask (  (  -  1  )  )  ;", "ListenableFuture <  ?  >    future 1     =    executor . submitListenable ( task 1  )  ;", "AbstractSchedulingTaskExecutorTests . TestTask   task 2     =    new   AbstractSchedulingTaskExecutorTests . TestTask (  (  -  1  )  )  ;", "ListenableFuture <  ?  >    future 2     =    executor . submitListenable ( task 2  )  ;", "shutdownExecutor (  )  ;", "future 1  . get (  )  ;", "future 2  . get (  )  ;", "}", "METHOD_END"], "methodName": ["submitListenableRunnableWithGetAfterShutdown"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestTask   task    =    new   AbstractSchedulingTaskExecutorTests . TestTask (  1  )  ;", "Future <  ?  >    future    =    executor . submit ( task )  ;", "Object   result    =    future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "assertNull ( result )  ;", "assertThreadNamePrefix ( task )  ;", "}", "METHOD_END"], "methodName": ["submitRunnable"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSchedulingTaskExecutorTests . TestTask   task 1     =    new   AbstractSchedulingTaskExecutorTests . TestTask (  (  -  1  )  )  ;", "Future <  ?  >    future 1     =    executor . submit ( task 1  )  ;", "AbstractSchedulingTaskExecutorTests . TestTask   task 2     =    new   AbstractSchedulingTaskExecutorTests . TestTask (  (  -  1  )  )  ;", "Future <  ?  >    future 2     =    executor . submit ( task 2  )  ;", "shutdownExecutor (  )  ;", "future 1  . get (  )  ;", "future 2  . get (  )  ;", "}", "METHOD_END"], "methodName": ["submitRunnableWithGetAfterShutdown"], "fileName": "org.springframework.scheduling.concurrent.AbstractSchedulingTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( ConcurrentTaskExecutor . managedExecutorServiceClass )     !  =    null )     &  &     ( ConcurrentTaskExecutor . managedExecutorServiceClass . isInstance ( concurrentExecutor )  )  )     {", "return   new   ConcurrentTaskExecutor . ManagedTaskExecutorAdapter ( concurrentExecutor )  ;", "}", "return   new   TaskExecutorAdapter ( concurrentExecutor )  ;", "}", "METHOD_END"], "methodName": ["getAdaptedExecutor"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . concurrentExecutor ;", "}", "METHOD_END"], "methodName": ["getConcurrentExecutor"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . concurrentExecutor    =     ( executor    !  =    null )     ?    executor    :    Executors . newSingleThreadExecutor (  )  ;", "this . adaptedExecutor    =     . getAdaptedExecutor ( this . concurrentExecutor )  ;", "}", "METHOD_END"], "methodName": ["setConcurrentExecutor"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . adaptedExecutor . setTaskDecorator ( taskDecorator )  ;", "}", "METHOD_END"], "methodName": ["setTaskDecorator"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "ConcurrentTaskExecutor   executor    =    new   ConcurrentTaskExecutor ( null )  ;", "executor . execute ( new   NoOpRunnable (  )  )  ;", "}", "METHOD_END"], "methodName": ["passingNullExecutorToCtorResultsInDefaultTaskExecutorBeingUsed"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentTaskExecutor   executor    =    new   ConcurrentTaskExecutor (  )  ;", "executor . setConcurrentExecutor ( null )  ;", "executor . execute ( new   NoOpRunnable (  )  )  ;", "}", "METHOD_END"], "methodName": ["passingNullExecutorToSetterResultsInDefaultTaskExecutorBeingUsed"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentTaskExecutor   executor    =    new   ConcurrentTaskExecutor (  )  ;", "executor . execute ( new   NoOpRunnable (  )  )  ;", "}", "METHOD_END"], "methodName": ["zeroArgCtorResultsInDefaultTaskExecutorBeingUsed"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   result    =    TaskUtils . decorateTaskWithErrorHandler ( task ,    this . errorHandler ,    isRepeatingTask )  ;", "if    ( this . enterpriseConcurrentScheduler )     {", "result    =    Executor . ManagedTaskBuilder . buildManagedTask ( result ,    task . toString (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["decorateTask"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "if    ( scheduledExecutor    !  =    null )     {", "this . scheduledExecutor    =    scheduledExecutor ;", "this . enterpriseConcurrentScheduler    =     (  (  . managedScheduledExecutorServiceClass )     !  =    null )     &  &     (  . managedScheduledExecutorServiceClass . isInstance ( scheduledExecutor )  )  ;", "} else    {", "this . scheduledExecutor    =    Executors . newSingleThreadScheduledExecutor (  )  ;", "this . enterpriseConcurrentScheduler    =    false ;", "}", "return   this . scheduledExecutor ;", "}", "METHOD_END"], "methodName": ["initScheduledExecutor"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( errorHandler ,     \" ErrorHandler   must   not   be   null \"  )  ;", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "initScheduledExecutor ( scheduledExecutor )  ;", "}", "METHOD_END"], "methodName": ["setScheduledExecutor"], "fileName": "org.springframework.scheduling.concurrent.ConcurrentTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setJndiEnvironment ( jndiEnvironment )  ;", "}", "METHOD_END"], "methodName": ["setJndiEnvironment"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedAwareThreadFactory"}, {"methodBody": ["METHOD_START", "{", "this . jndiName    =    jndiName ;", "}", "METHOD_END"], "methodName": ["setJndiName"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedAwareThreadFactory"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setJndiTemplate ( jndiTemplate )  ;", "}", "METHOD_END"], "methodName": ["setJndiTemplate"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedAwareThreadFactory"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setResourceRef ( resourceRef )  ;", "}", "METHOD_END"], "methodName": ["setResourceRef"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedAwareThreadFactory"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setJndiEnvironment ( jndiEnvironment )  ;", "}", "METHOD_END"], "methodName": ["setJndiEnvironment"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . jndiName    =    jndiName ;", "}", "METHOD_END"], "methodName": ["setJndiName"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setJndiTemplate ( jndiTemplate )  ;", "}", "METHOD_END"], "methodName": ["setJndiTemplate"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setResourceRef ( resourceRef )  ;", "}", "METHOD_END"], "methodName": ["setResourceRef"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setJndiEnvironment ( jndiEnvironment )  ;", "}", "METHOD_END"], "methodName": ["setJndiEnvironment"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "this . jndiName    =    jndiName ;", "}", "METHOD_END"], "methodName": ["setJndiName"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setJndiTemplate ( jndiTemplate )  ;", "}", "METHOD_END"], "methodName": ["setJndiTemplate"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "this . jndiLocator . setResourceRef ( resourceRef )  ;", "}", "METHOD_END"], "methodName": ["setResourceRef"], "fileName": "org.springframework.scheduling.concurrent.DefaultManagedTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . awaitTerminationSeconds )     >     0  )     {", "try    {", "if    (  !  ( e . awaitTermination ( this . awaitTerminationSeconds ,    TimeUnit . SECONDS )  )  )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Timed   out   while   waiting   for   e \"     +     (  ( this . beanName )     !  =    null    ?     (  \"     '  \"     +     ( this . beanName )  )     +     \"  '  \"     :     \"  \"  )  )     +     \"    to   terminate \"  )  )  ;", "}", "}", "}    catch    ( InterruptedException   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Interrupted   while   waiting   for   e \"     +     (  ( this . beanName )     !  =    null    ?     (  \"     '  \"     +     ( this . beanName )  )     +     \"  '  \"     :     \"  \"  )  )     +     \"    to   terminate \"  )  )  ;", "}", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["awaitTerminationIfNecessary"], "fileName": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( task   instanceof   Future )     {", "(  ( Future <  ?  >  )     ( task )  )  . cancel ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["cancelRemainingTask"], "fileName": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Initializing   Service    \"     +     (  ( this . beanName )     !  =    null    ?     (  \"     '  \"     +     ( this . beanName )  )     +     \"  '  \"     :     \"  \"  )  )  )  ;", "}", "if    (  (  !  ( this . threadNamePrefixSet )  )     &  &     (  ( this . beanName )     !  =    null )  )     {", "setThreadNamePrefix (  (  ( this . beanName )     +     \"  -  \"  )  )  ;", "}", "this . executor    =    initialize ( this . threadFactory ,    this . rejectedExecutionHandler )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "this . awaitTerminationSeconds    =    awaitTerminationSeconds ;", "}", "METHOD_END"], "methodName": ["setAwaitTerminationSeconds"], "fileName": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "this . rejectedExecutionHandler    =     ( rejectedExecutionHandler    !  =    null )     ?    rejectedExecutionHandler    :    new   ThreadPoolExecutor . AbortPolicy (  )  ;", "}", "METHOD_END"], "methodName": ["setRejectedExecutionHandler"], "fileName": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "this . threadFactory    =     ( threadFactory    !  =    null )     ?    threadFactory    :    this ;", "}", "METHOD_END"], "methodName": ["setThreadFactory"], "fileName": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "this . waitForTasksToCompleteOnShutdown    =    waitForJobsToCompleteOnShutdown ;", "}", "METHOD_END"], "methodName": ["setWaitForTasksToCompleteOnShutdown"], "fileName": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Shutting   down   Service \"     +     (  ( this . beanName )     !  =    null    ?     (  \"     '  \"     +     ( this . beanName )  )     +     \"  '  \"     :     \"  \"  )  )  )  ;", "}", "if    (  ( this . executor )     !  =    null )     {", "if    ( this . waitForTasksToCompleteOnShutdown )     {", "this . executor . shutdown (  )  ;", "} else    {", "for    ( Runnable   remainingTask    :    this . executor . shutdownNow (  )  )     {", "cancelRemainingTask ( remainingTask )  ;", "}", "}", "awaitTerminationIfNecessary ( this . executor )  ;", "}", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.springframework.scheduling.concurrent.ExecutorConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "this . asyncMode    =    asyncMode ;", "}", "METHOD_END"], "methodName": ["setAsyncMode"], "fileName": "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . awaitTerminationSeconds    =    awaitTerminationSeconds ;", "}", "METHOD_END"], "methodName": ["setAwaitTerminationSeconds"], "fileName": "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . commonPool    =    commonPool ;", "}", "METHOD_END"], "methodName": ["setCommonPool"], "fileName": "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . parallelism    =    parallelism ;", "}", "METHOD_END"], "methodName": ["setParallelism"], "fileName": "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . threadFactory    =    threadFactory ;", "}", "METHOD_END"], "methodName": ["setThreadFactory"], "fileName": "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . uncaughtExceptionHandler    =    uncaughtExceptionHandler ;", "}", "METHOD_END"], "methodName": ["setUncaughtExceptionHandler"], "fileName": "org.springframework.scheduling.concurrent.ForkJoinPoolFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . currentFuture )     !  =    null )  ,     \" No   scheduled   future \"  )  ;", "return   this . currentFuture ;", "}", "METHOD_END"], "methodName": ["obtainCurrentFuture"], "fileName": "org.springframework.scheduling.concurrent.ReschedulingRunnable"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . triggerContextMonitor )     {", "thisedExecutionTime    =    this . trigger . nextExecutionTime ( this . triggerContext )  ;", "if    (  ( thisedExecutionTime )     =  =    null )     {", "return   null ;", "}", "long   initialDelay    =     ( thisedExecutionTime . getTime (  )  )     -     ( System . currentTimeMillis (  )  )  ;", "this . currentFuture    =    this . executore ( this ,    initialDelay ,    TimeUnit . MILLISECONDS )  ;", "return   this ;", "}", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "org.springframework.scheduling.concurrent.ReschedulingRunnable"}, {"methodBody": ["METHOD_START", "{", "return   new   ScheduledThreadPoolExecutor ( poolSize ,    threadFactory ,    rejectedExecutionHandler )  ;", "}", "METHOD_END"], "methodName": ["createExecutor"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . continueScheduledExecutionAfterException    ?    new   DelegatingErrorHandlingRunnable ( task . getRunnable (  )  ,    TaskUtils . LOG _ AND _ SUPPRESS _ ERROR _ HANDLER )     :    new   DelegatingErrorHandlingRunnable ( task . getRunnable (  )  ,    TaskUtils . LOG _ AND _ PROPAGATE _ ERROR _ HANDLER )  ;", "}", "METHOD_END"], "methodName": ["getRunnableToSchedule"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "for    ( ScheduledExecutorTask   task    :    tasks )     {", "Runnable   runnable    =    getRunnableToSchedule ( task )  ;", "if    ( task . isOneTimeTask (  )  )     {", "executor . schedule ( runnable ,    task . getDelay (  )  ,    task . getTimeUnit (  )  )  ;", "} else    {", "if    ( task . isFixedRate (  )  )     {", "executor . scheduleAtFixedRate ( runnable ,    task . getDelay (  )  ,    task . getPeriod (  )  ,    task . getTimeUnit (  )  )  ;", "} else    {", "executor . scheduleWithFixedDelay ( runnable ,    task . getDelay (  )  ,    task . getPeriod (  )  ,    task . getTimeUnit (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["registerTasks"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . continueScheduledExecutionAfterException    =    continueScheduledExecutionAfterException ;", "}", "METHOD_END"], "methodName": ["setContinueScheduledExecutionAfterException"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . exposeUnconfigurableExecutor    =    exposeUnconfigurableExecutor ;", "}", "METHOD_END"], "methodName": ["setExposeUnconfigurableExecutor"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( poolSize    >     0  )  ,     \"  ' poolSize '    must   be    1    or   higher \"  )  ;", "this . poolSize    =    poolSize ;", "}", "METHOD_END"], "methodName": ["setPoolSize"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . removeOnCancelPolicy    =    removeOnCancelPolicy ;", "}", "METHOD_END"], "methodName": ["setRemoveOnCancelPolicy"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . scheduledExecutorTasks    =    scheduledExecutorTasks ;", "}", "METHOD_END"], "methodName": ["setScheduledExecutorTasks"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "try    {", "Thread . sleep (  ( seconds    *     1  0  0  0  )  )  ;", "}    catch    ( Interruptception   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["pauseToLetTaskStart"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Runnable   runnable    =    mock ( Runnable . class )  ;", "ScheduledExecutorTask   task    =    new   ScheduledExecutorTask ( runnable )  ;", "task . setPeriod (  5  0  0  )  ;", "task . setFixedRate ( true )  ;", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    task    }  )  ;", "factory . afterPropertiesSet (  )  ;", ". pauseToLetTaskStart (  2  )  ;", "factory . destroy (  )  ;", "verify ( runnable ,    atLeast (  2  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["testFixedRepeatedExecutionIsSetUpAndFiresCorrectly"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Runnable   runnable    =    mock ( Runnable . class )  ;", "willThrow ( new   IllegalStateException (  )  )  . given ( runnable )  . run (  )  ;", "ScheduledExecutorTask   task    =    new   ScheduledExecutorTask ( runnable )  ;", "task . setPeriod (  5  0  0  )  ;", "task . setFixedRate ( true )  ;", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    task    }  )  ;", "factory . setContinueScheduledExecutionAfterException ( true )  ;", "factory . afterPropertiesSet (  )  ;", ". pauseToLetTaskStart (  2  )  ;", "factory . destroy (  )  ;", "verify ( runnable ,    atLeast (  2  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["testFixedRepeatedExecutionIsSetUpAndFiresCorrectlyAfterException"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )  ;", "assertEquals ( ScheduledExecutorService . class ,    factory . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testObjectTypeReportsCorrectType"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Runnable   runnable    =    mock ( Runnable . class )  ;", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    new   ScheduledExecutorTask ( runnable )     }  )  ;", "factory . afterPropertiesSet (  )  ;", ". pauseToLetTaskStart (  1  )  ;", "factory . destroy (  )  ;", "verify ( runnable )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["testOneTimeExecutionIsSetUpAndFiresCorrectly"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )     {", "@ Override", "protected   ScheduledExecutorService   createExecutor ( int   poolSize ,    ThreadFactory   threadFactory ,    RejectedExecutionHandler   rejectedExecutionHandler )     {", "assertNotNull (  \" Bah ;    the   setRejectedExecutionHandler (  .  .  )    method   must   use   a   default   RejectedExecutionHandler   if   a   null   arg   is   passed   in .  \"  )  ;", "return   super . createExecutor ( poolSize ,    threadFactory ,    rejectedExecutionHandler )  ;", "}", "}  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    new    . NoOpScheduledExecutorTask (  )     }  )  ;", "factory . setRejectedExecutionHandler ( null )  ;", "factory . afterPropertiesSet (  )  ;", "factory . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["testSettingRejectedExecutionHandlerToNullForcesUseOfDefaultButIsOtherwiseCool"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )     {", "@ Override", "protected   ScheduledExecutorService   createExecutor ( int   poolSize ,    ThreadFactory   threadFactory ,    RejectedExecutionHandler   rejectedExecutionHandler )     {", "assertNotNull (  \" Bah ;    the   setThreadFactory (  .  .  )    method   must   use   a   default   ThreadFactory   if   a   null   arg   is   passed   in .  \"  )  ;", "return   super . createExecutor ( poolSize ,    threadFactory ,    rejectedExecutionHandler )  ;", "}", "}  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    new    . NoOpScheduledExecutorTask (  )     }  )  ;", "factory . setThreadFactory ( null )  ;", "factory . afterPropertiesSet (  )  ;", "factory . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["testSettingThreadFactoryToNullForcesUseOfDefaultButIsOtherwiseCool"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   ScheduledExecutorService   executor    =    mock ( ScheduledExecutorService . class )  ;", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )     {", "@ Override", "protected   ScheduledExecutorService   createExecutor ( int   poolSize ,    ThreadFactory   threadFactory ,    RejectedExecutionHandler   rejectedExecutionHandler )     {", "return   executor ;", "}", "}  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    new    . NoOpScheduledExecutorTask (  )     }  )  ;", "factory . setWaitForTasksToCompleteOnShutdown ( true )  ;", "factory . afterPropertiesSet (  )  ;", "factory . destroy (  )  ;", "verify ( executor )  . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["testShutdownIsPropagatedToTheExecutorOnDestroy"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   ScheduledExecutorService   executor    =    mock ( ScheduledExecutorService . class )  ;", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )     {", "@ Override", "protected   ScheduledExecutorService   createExecutor ( int   poolSize ,    ThreadFactory   threadFactory ,    RejectedExecutionHandler   rejectedExecutionHandler )     {", "return   executor ;", "}", "}  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    new    . NoOpScheduledExecutorTask (  )     }  )  ;", "factory . afterPropertiesSet (  )  ;", "factory . destroy (  )  ;", "verify ( executor )  . shutdownNow (  )  ;", "}", "METHOD_END"], "methodName": ["testShutdownNowIsPropagatedToTheExecutorOnDestroy"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )  ;", "factory . setPoolSize (  (  -  1  )  )  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    new    . NoOpScheduledExecutorTask (  )     }  )  ;", "factory . afterPropertiesSet (  )  ;", "fail (  \" Pool   size   less   than   zero \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testThrowsExceptionIfPoolSizeIsLessThanZero"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   runnable    =    mock ( Runnable . class )  ;", "ScheduledExecutorTask   task    =    new   ScheduledExecutorTask ( runnable )  ;", "task . setPeriod (  5  0  0  )  ;", "task . setDelay (  3  0  0  0  )  ;", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    task    }  )  ;", "factory . afterPropertiesSet (  )  ;", ". pauseToLetTaskStart (  1  )  ;", "factory . destroy (  )  ;", "verify ( runnable ,    never (  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["testWithInitialDelayRepeatedExecutionIsSetUpAndFiresCorrectly"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   runnable    =    mock ( Runnable . class )  ;", "willThrow ( new   IllegalStateException (  )  )  . given ( runnable )  . run (  )  ;", "ScheduledExecutorTask   task    =    new   ScheduledExecutorTask ( runnable )  ;", "task . setPeriod (  5  0  0  )  ;", "task . setDelay (  3  0  0  0  )  ;", "ScheduledExecutorFactoryBean   factory    =    new   ScheduledExecutorFactoryBean (  )  ;", "factory . setScheduledExecutorTasks ( new   ScheduledExecutorTask [  ]  {    task    }  )  ;", "factory . setContinueScheduledExecutionAfterException ( true )  ;", "factory . afterPropertiesSet (  )  ;", ". pauseToLetTaskStart (  1  )  ;", "factory . destroy (  )  ;", "verify ( runnable ,    never (  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["testWithInitialDelayRepeatedExecutionIsSetUpAndFiresCorrectlyAfterException"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   this . delay ;", "}", "METHOD_END"], "methodName": ["getDelay"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "return   this . period ;", "}", "METHOD_END"], "methodName": ["getPeriod"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . runnable )     !  =    null )  ,     \" No   Runnable   set \"  )  ;", "return   this . runnable ;", "}", "METHOD_END"], "methodName": ["getRunnable"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "return   this . timeUnit ;", "}", "METHOD_END"], "methodName": ["getTimeUnit"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "return   this . fixedRate ;", "}", "METHOD_END"], "methodName": ["isFixedRate"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "return    ( this . period )     <  =     0  ;", "}", "METHOD_END"], "methodName": ["isOneTimeTask"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "this . delay    =    delay ;", "}", "METHOD_END"], "methodName": ["setDelay"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "this . fixedRate    =    fixedRate ;", "}", "METHOD_END"], "methodName": ["setFixedRate"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "this . period    =    period ;", "}", "METHOD_END"], "methodName": ["setPeriod"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "this . runnable    =    executorTask ;", "}", "METHOD_END"], "methodName": ["setRunnable"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "this . timeUnit    =     ( timeUnit    !  =    null )     ?    timeUnit    :    TimeUnit . MILLISECONDS ;", "}", "METHOD_END"], "methodName": ["setTimeUnit"], "fileName": "org.springframework.scheduling.concurrent.ScheduledExecutorTask"}, {"methodBody": ["METHOD_START", "{", "return   new   ThreadPoolExecutor ( corePoolSize ,    maxPoolSize ,    keepAliveSeconds ,    TimeUnit . SECONDS ,    queue ,    threadFactory ,    rejectedExecutionHandler )  ;", "}", "METHOD_END"], "methodName": ["createExecutor"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( queueCapacity    >     0  )     {", "return   new   LinkedBlockQueue <  >  ( queueCapacity )  ;", "} else    {", "return   new   SynchronousQueue <  >  (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createQueue"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . allowCoreThreadTimeOut    =    allowCoreThreadTimeOut ;", "}", "METHOD_END"], "methodName": ["setAllowCoreThreadTimeOut"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . corePoolSize    =    corePoolSize ;", "}", "METHOD_END"], "methodName": ["setCorePoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . exposeUnconfigurableExecutor    =    exposeUnconfigurableExecutor ;", "}", "METHOD_END"], "methodName": ["setExposeUnconfigurableExecutor"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . keepAliveSeconds    =    keepAliveSeconds ;", "}", "METHOD_END"], "methodName": ["setKeepAliveSeconds"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . maxPoolSize    =    maxPoolSize ;", "}", "METHOD_END"], "methodName": ["setMaxPoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . queueCapacity    =    queueCapacity ;", "}", "METHOD_END"], "methodName": ["setQueueCapacity"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ThreadPoolExecutorFactoryBeanTests . ExecutorConfig . class )  ;", "ExecutorService   executor    =    context . getBean (  \" executor \"  ,    ExecutorService . class )  ;", "FutureTask < String >    task    =    new   FutureTask <  >  ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "return    \" foo \"  ;", "}", "}  )  ;", "executor . execute ( task )  ;", "assertEquals (  \" foo \"  ,    task . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultExecutor"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "if    ( queueCapacity    >     0  )     {", "return   new   LinkedBlockQueue <  >  ( queueCapacity )  ;", "} else    {", "return   new   SynchronousQueue <  >  (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createQueue"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . threadPoolExecutor )     =  =    null )     {", "return    0  ;", "}", "return   this . threadPoolExecutor . getActiveCount (  )  ;", "}", "METHOD_END"], "methodName": ["getActiveCount"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . poolSizeMonitor )     {", "return   this . coreSize ;", "}", "}", "METHOD_END"], "methodName": ["getCorePoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . poolSizeMonitor )     {", "return   this . keepAliveSeconds ;", "}", "}", "METHOD_END"], "methodName": ["getKeepAliveSeconds"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . poolSizeMonitor )     {", "return   this . maxSize ;", "}", "}", "METHOD_END"], "methodName": ["getMaxPoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . threadPoolExecutor )     =  =    null )     {", "return   this . corePoolSize ;", "}", "return   this . threadPoolExecutor . getPoolSize (  )  ;", "}", "METHOD_END"], "methodName": ["getPoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . threadPoolExecutor )     !  =    null )  ,     \" ThreadPoolTaskExecutor   not   initialized \"  )  ;", "return   this . threadPoolExecutor ;", "}", "METHOD_END"], "methodName": ["getThreadPoolExecutor"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . allowCoreThreadTimeOut    =    allowCoreThreadTimeOut ;", "}", "METHOD_END"], "methodName": ["setAllowCoreThreadTimeOut"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . poolSizeMonitor )     {", "this . corePoolSize    =    corePoolSize ;", "if    (  ( this . tExecutor )     !  =    null )     {", "this . tExecutor . setCorePoolSize ( corePoolSize )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setCorePoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . poolSizeMonitor )     {", "this . keepAliveSeconds    =    keepAliveSeconds ;", "if    (  ( this . tExecutor )     !  =    null )     {", "this . tExecutor . setKeepAliveTime ( keepAliveSeconds ,    TimeUnit . SECONDS )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setKeepAliveSeconds"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . poolSizeMonitor )     {", "this . maxPoolSize    =    maxPoolSize ;", "if    (  ( this . tExecutor )     !  =    null )     {", "this . tExecutor . setMaximumPoolSize ( maxPoolSize )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setMaxPoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . queueCapacity    =    queueCapacity ;", "}", "METHOD_END"], "methodName": ["setQueueCapacity"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . taskDecorator    =    taskDecorator ;", "}", "METHOD_END"], "methodName": ["setTaskDecorator"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "return   new   ScheduledThreadPoolExecutor ( poolSize ,    threadFactory ,    rejectedExecutionHandler )  ;", "}", "METHOD_END"], "methodName": ["createExecutor"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "return   TaskUtils . decorateTaskWithErrorHandler ( task ,    this . errorHandler ,    isRepeatingTask )  ;", "}", "METHOD_END"], "methodName": ["errorHandlingTask"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "Future <  ?  >    scheduledFuture    =    executor . submit ( errorHandlingTask ( listenableFuture ,    false )  )  ;", "this . listenableFutureMap . put ( scheduledFuture ,    listenableFuture )  ;", "listenableFuture . addCallback (  (    result )     -  >    listenableFutureMap . remove ( scheduledFuture )  ,     (    ex )     -  >    listenableFutureMap . remove ( scheduledFuture )  )  ;", "}", "METHOD_END"], "methodName": ["executeAndTrack"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduledExecutor )     =  =    null )     {", "return    0  ;", "}", "return   getScheduledExecutor (  )  . getActiveCount (  )  ;", "}", "METHOD_END"], "methodName": ["getActiveCount"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduledExecutor )     =  =    null )     {", "return   this . poolSize ;", "}", "return   getScheduledExecutor (  )  . getPoolSize (  )  ;", "}", "METHOD_END"], "methodName": ["getPoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . scheduledExecutor )     !  =    null )  ,     \" ThreadPoolTaskScheduler   not   initialized \"  )  ;", "return   this . scheduledExecutor ;", "}", "METHOD_END"], "methodName": ["getScheduledExecutor"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . scheduledExecutor )    instanceof   ScheduledThreadPoolExecutor )  ,     \" No   ScheduledThreadPoolExecutor   available \"  )  ;", "return    (  ( ScheduledThreadPoolExecutor )     ( this . scheduledExecutor )  )  ;", "}", "METHOD_END"], "methodName": ["getScheduledThreadPoolExecutor"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduledExecutor )     =  =    null )     {", "return   this . removeOnCancelPolicy ;", "}", "return   getScheduledExecutor (  )  . getRemoveOnCancelPolicy (  )  ;", "}", "METHOD_END"], "methodName": ["isRemoveOnCancelPolicy"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( poolSize    >     0  )  ,     \"  ' poolSize '    must   be    1    or   higher \"  )  ;", "this . poolSize    =    poolSize ;", "if    (  ( this . scheduledExecutor )    instanceof   ScheduledExecutor )     {", "(  ( ScheduledExecutor )     ( this . scheduledExecutor )  )  . setCorePoolSize ( poolSize )  ;", "}", "}", "METHOD_END"], "methodName": ["setPoolSize"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "this . removeOnCancelPolicy    =    removeOnCancelPolicy ;", "if    (  ( this . scheduledExecutor )    instanceof   ScheduledExecutor )     {", "(  ( ScheduledExecutor )     ( this . scheduledExecutor )  )  . setRemoveOnCancelPolicy ( removeOnCancelPolicy )  ;", "} else", "if    ( removeOnCancelPolicy    &  &     (  ( this . scheduledExecutor )     !  =    null )  )     {", "logger . info (  \" Could   not   apply   remove - on - cancel   policy    -    not   a   Java    7  +    ScheduledExecutor \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRemoveOnCancelPolicy"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( AbstractSchedulingTaskExecutorTests . THREAD _ NAME _ PREFIX ,    task . lastThread . getName (  )  . substring (  0  ,    AbstractSchedulingTaskExecutorTests . THREAD _ NAME _ PREFIX . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertThreadNamePrefix"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "lat . await (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "}    cat    ( InterruptedException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "assertEquals (  \" lat   did   not   count   down ,  \"  ,     0  ,    lat . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["await"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "await ( errorHandler . latch )  ;", "}", "METHOD_END"], "methodName": ["await"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "await ( task . latch )  ;", "}", "METHOD_END"], "methodName": ["await"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskSchedulerTests . TestTask   task    =    new   ThreadPoolTaskSchedulerTests . TestTask (  0  )  ;", "ThreadPoolTaskSchedulerTests . TestErrorHandler   errorHandler    =    new   ThreadPoolTaskSchedulerTests . TestErrorHandler (  1  )  ;", "scheduler . setErrorHandler ( errorHandler )  ;", "scheduler . execute ( task )  ;", "await ( errorHandler )  ;", "assertNotNull ( errorHandler . lastError )  ;", "}", "METHOD_END"], "methodName": ["executeFailingRunnableWithErrorHandler"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "eTriggerTask (  )  ;", "}", "}", "METHOD_END"], "methodName": ["scheduleMultipleTriggerTasks"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskSchedulerTests . TestTask   task    =    new   ThreadPoolTaskSchedulerTests . TestTask (  0  )  ;", "ThreadPoolTaskSchedulerTests . TestErrorHandler   errorHandler    =    new   ThreadPoolTaskSchedulerTests . TestErrorHandler (  1  )  ;", "scheduler . setErrorHandler ( errorHandler )  ;", "Future <  ?  >    future    =    scheduler . schedule ( task ,    new   Date (  )  )  ;", "Object   result    =    future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "assertTrue ( future . isDone (  )  )  ;", "assertNull ( result )  ;", "assertNotNull ( errorHandler . lastError )  ;", "}", "METHOD_END"], "methodName": ["scheduleOneTimeFailingTaskWithErrorHandler"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskSchedulerTests . TestTask   task    =    new   ThreadPoolTaskSchedulerTests . TestTask (  0  )  ;", "Future <  ?  >    future    =    scheduler . schedule ( task ,    new   Date (  )  )  ;", "try    {", "future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "}    catch    ( ExecutionException   ex )     {", "assertTrue ( future . isDone (  )  )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["scheduleOneTimeFailingTaskWithoutErrorHandler"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskSchedulerTests . TestTask   task    =    new   ThreadPoolTaskSchedulerTests . TestTask (  1  )  ;", "Future <  ?  >    future    =    scheduler . schedule ( task ,    new   Date (  )  )  ;", "Object   result    =    future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "assertNull ( result )  ;", "assertTrue ( future . isDone (  )  )  ;", "assertThreadNamePrefix ( task )  ;", "}", "METHOD_END"], "methodName": ["scheduleOneTimeTask"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskSchedulerTests . TestTask   task    =    new   ThreadPoolTaskSchedulerTests . TestTask (  3  )  ;", "Future <  ?  >    future    =    scheduler . schedule ( task ,    new   ThreadPoolTaskSchedulerTests . TestTrigger (  3  )  )  ;", "Object   result    =    future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "assertNull ( result )  ;", "await ( task )  ;", "assertThreadNamePrefix ( task )  ;", "}", "METHOD_END"], "methodName": ["scheduleTriggerTask"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskSchedulerTests . TestCallable   task    =    new   ThreadPoolTaskSchedulerTests . TestCallable (  0  )  ;", "ThreadPoolTaskSchedulerTests . TestErrorHandler   errorHandler    =    new   ThreadPoolTaskSchedulerTests . TestErrorHandler (  1  )  ;", "scheduler . setErrorHandler ( errorHandler )  ;", "Future < String >    future    =    scheduler . submit ( task )  ;", "Object   result    =    future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "assertTrue ( future . isDone (  )  )  ;", "assertNull ( result )  ;", "assertNotNull ( errorHandler . lastError )  ;", "}", "METHOD_END"], "methodName": ["submitFailingCallableWithErrorHandler"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskSchedulerTests . TestTask   task    =    new   ThreadPoolTaskSchedulerTests . TestTask (  0  )  ;", "ThreadPoolTaskSchedulerTests . TestErrorHandler   errorHandler    =    new   ThreadPoolTaskSchedulerTests . TestErrorHandler (  1  )  ;", "scheduler . setErrorHandler ( errorHandler )  ;", "Future <  ?  >    future    =    scheduler . submit ( task )  ;", "Object   result    =    future . get (  1  0  0  0  ,    TimeUnit . MILLISECONDS )  ;", "assertTrue ( future . isDone (  )  )  ;", "assertNull ( result )  ;", "assertNotNull ( errorHandler . lastError )  ;", "}", "METHOD_END"], "methodName": ["submitFailingRunnableWithErrorHandler"], "fileName": "org.springframework.scheduling.concurrent.ThreadPoolTaskSchedulerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( parserContext . getRegistry (  )  . containsBeanDefinition ( TaskManagementConfigUtils . ASYNC _ EXECUTION _ ASPECT _ BEAN _ NAME )  )  )     {", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . genericBeanDefinition (  . ASYNC _ EXECUTION _ ASPECT _ CLASS _ NAME )  ;", "builder . setFactoryMethod (  \" aspectOf \"  )  ;", "String   executor    =    element . getAttribute (  \" executor \"  )  ;", "if    ( StringUtils . hasText ( executor )  )     {", "builder . addPropertyReference (  \" executor \"  ,    executor )  ;", "}", "String   exceptionHandler    =    element . getAttribute (  \" exception - handler \"  )  ;", "if    ( StringUtils . hasText ( exceptionHandler )  )     {", "builder . addPropertyReference (  \" exceptionHandler \"  ,    exceptionHandler )  ;", "}", "parserContext . registerBeanComponent ( new   BeanComponentDefinition ( builder . getBeanDefinition (  )  ,    TaskManagementConfigUtils . ASYNC _ EXECUTION _ ASPECT _ BEAN _ NAME )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerAsyncExecutionAspect"], "fileName": "org.springframework.scheduling.config.AnnotationDrivenBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "builder . setRole ( ROLE _ INFRASTRUCTURE )  ;", "parserContext . getRegistry (  )  . registerBeanDefinition ( beanName ,    builder . getBeanDefinition (  )  )  ;", "BeanDefinitionHolder   holder    =    new   BeanDefinitionHolder ( builder . getBeanDefinition (  )  ,    beanName )  ;", "parserContext . registerComponent ( new   beans . factory . parsing . BeanComponentDefinition ( holder )  )  ;", "}", "METHOD_END"], "methodName": ["registerPostProcessor"], "fileName": "org.springframework.scheduling.config.AnnotationDrivenBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Object   exceptionHandler    =    context . getBean (  \" testExceptionHandler \"  )  ;", "Object   postProcessor    =    context . getBean ( TaskManagementCUtils . ASYNC _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  ;", "assertSame ( exceptionHandler ,    new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" exceptionHandler \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncPostProcessorExceptionHandlerReference"], "fileName": "org.springframework.scheduling.config.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   executor    =    context . getBean (  \" testExecutor \"  )  ;", "Object   postProcessor    =    context . getBean ( TaskManagementCUtils . ASYNC _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  ;", "assertSame ( executor ,    new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" executor \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncPostProcessorExecutorReference"], "fileName": "org.springframework.scheduling.config.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( context . containsBean ( TaskManagementConfigUtils . ASYNC _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["asyncPostProcessorRegistered"], "fileName": "org.springframework.scheduling.config.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( context . containsBean ( TaskManagementConfigUtils . SCHEDULED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["scheduledPostProcessorRegistered"], "fileName": "org.springframework.scheduling.config.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   scheduler    =    context . getBean (  \" testScheduler \"  )  ;", "Object   postProcessor    =    context . getBean ( TaskManagementConfigUtils . SCHEDULED _ ANNOTATION _ PROCESSOR _ BEAN _ NAME )  ;", "assertSame ( scheduler ,    new   DirectFieldAccessor ( postProcessor )  . getPropertyValue (  \" scheduler \"  )  )  ;", "}", "METHOD_END"], "methodName": ["scheduledPostProcessorSchedulerReference"], "fileName": "org.springframework.scheduling.config.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   ClassPathXmlApplicationContext (  \" annotationDrivenContext . xml \"  ,    AnnotationDrivenBeanDefinitionParserTests . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.scheduling.config.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return   this . expression ;", "}", "METHOD_END"], "methodName": ["getExpression"], "fileName": "org.springframework.scheduling.config.CronTask"}, {"methodBody": ["METHOD_START", "{", "String   rejectionPolicy    =    element . getAttribute (  \" rejection - policy \"  )  ;", "if    (  !  ( StringUtils . hasText ( rejectionPolicy )  )  )     {", "return ;", "}", "String   prefix    =     \" \"  ;", "String   policyClassName ;", "if    ( rejectionPolicy . equals (  \" ABORT \"  )  )     {", "policyClassName    =    prefix    +     \" AbortPolicy \"  ;", "} else", "if    ( rejectionPolicy . equals (  \" CALLER _ RUNS \"  )  )     {", "policyClassName    =    prefix    +     \" CallerRunsPolicy \"  ;", "} else", "if    ( rejectionPolicy . equals (  \" DISCARD \"  )  )     {", "policyClassName    =    prefix    +     \" DiscardPolicy \"  ;", "} else", "if    ( rejectionPolicy . equals (  \" DISCARD _ OLDEST \"  )  )     {", "policyClassName    =    prefix    +     \" DiscardOldestPolicy \"  ;", "} else    {", "policyClassName    =    rejectionPolicy ;", "}", "builder . addPropertyValue (  \" rejectedExecutionHandler \"  ,    new   Root ( policyClassName )  )  ;", "}", "METHOD_END"], "methodName": ["configureRejectionPolicy"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskExecutor   executor    =    this . context . getBean (  \" default \"  ,    ThreadPoolTaskExecutor . class )  ;", "assertEquals (  1  ,    getCorePoolSize ( executor )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    getMaxPoolSize ( executor )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    getQueueCapacity ( executor )  )  ;", "assertEquals (  6  0  ,    getKeepAliveSeconds ( executor )  )  ;", "assertEquals ( false ,    getAllowCoreThreadTimeOut ( executor )  )  ;", "FutureTask < String >    task    =    new   FutureTask <  >  ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "return    \" foo \"  ;", "}", "}  )  ;", "executor . execute ( task )  ;", "assertEquals (  \" foo \"  ,    task . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultExecutor"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Boolean )     ( new   DirectFieldAccessor ( executor )  . getPropertyValue (  \" allowCoreThreadTimeOut \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllowCoreThreadTimeOut"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Integer )     ( new   DirectFieldAccessor ( executor )  . getPropertyValue (  \" corePoolSize \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCorePoolSize"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Integer )     ( new   DirectFieldAccessor ( executor )  . getPropertyValue (  \" keepAliveSeconds \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getKeepAliveSeconds"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Integer )     ( new   DirectFieldAccessor ( executor )  . getPropertyValue (  \" maxPoolSize \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMaxPoolSize"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Integer )     ( new   DirectFieldAccessor ( executor )  . getPropertyValue (  \" queueCapacity \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getQueueCapacity"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "this . context . getBean (  \" invalidPoolSize \"  )  ;", "}", "METHOD_END"], "methodName": ["invalidPoolSize"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "this . context . getBean (  \" propertyPlaceholderWithInvalidPoolSize \"  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithInvalidPoolSize"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   executor    =    this . context . getBean (  \" propertyPlaceholderWithRange \"  )  ;", "assertEquals (  5  ,    getCorePoolSize ( executor )  )  ;", "assertEquals (  2  5  ,    getMaxPoolSize ( executor )  )  ;", "assertEquals ( false ,    getAllowCoreThreadTimeOut ( executor )  )  ;", "assertEquals (  1  0  ,    getQueueCapacity ( executor )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithRange"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   executor    =    this . context . getBean (  \" propertyPlaceholderWithRangeAndCoreThreadTimeout \"  )  ;", "assertEquals (  9  9  ,    getCorePoolSize ( executor )  )  ;", "assertEquals (  9  9  ,    getMaxPoolSize ( executor )  )  ;", "assertEquals ( true ,    getAllowCoreThreadTimeOut ( executor )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithRangeAndCoreThreadTimeout"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   executor    =    this . context . getBean (  \" propertyPlaceholderWithSingleSize \"  )  ;", "assertEquals (  1  2  3  ,    getCorePoolSize ( executor )  )  ;", "assertEquals (  1  2  3  ,    getMaxPoolSize ( executor )  )  ;", "assertEquals (  6  0  ,    getKeepAliveSeconds ( executor )  )  ;", "assertEquals ( false ,    getAllowCoreThreadTimeOut ( executor )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    getQueueCapacity ( executor )  )  ;", "}", "METHOD_END"], "methodName": ["propertyPlaceholderWithSingleSize"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   executor    =    this . context . getBean (  \" rangeWithBoundedQueue \"  )  ;", "assertEquals (  7  ,    getCorePoolSize ( executor )  )  ;", "assertEquals (  4  2  ,    getMaxPoolSize ( executor )  )  ;", "assertEquals (  1  1  ,    getQueueCapacity ( executor )  )  ;", "}", "METHOD_END"], "methodName": ["rangeWithBoundedQueue"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   executor    =    this . context . getBean (  \" rangeWithUnboundedQueue \"  )  ;", "assertEquals (  9  ,    getCorePoolSize ( executor )  )  ;", "assertEquals (  9  ,    getMaxPoolSize ( executor )  )  ;", "assertEquals (  3  7  ,    getKeepAliveSeconds ( executor )  )  ;", "assertEquals ( true ,    getAllowCoreThreadTimeOut ( executor )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    getQueueCapacity ( executor )  )  ;", "}", "METHOD_END"], "methodName": ["rangeWithUnboundedQueue"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   ClassPathXmlApplicationContext (  \" executorContext . xml \"  ,    ExecutorBeanDefinitionParserTests . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   executor    =    this . context . getBean (  \" singleSize \"  )  ;", "assertEquals (  4  2  ,    getCorePoolSize ( executor )  )  ;", "assertEquals (  4  2  ,    getMaxPoolSize ( executor )  )  ;", "}", "METHOD_END"], "methodName": ["singleSize"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "CustomizableThreadCreator   executor    =    this . context . getBean (  \" default \"  ,    CustomizableThreadCreator . class )  ;", "assertEquals (  \" default -  \"  ,    executor . getThreadNamePrefix (  )  )  ;", "}", "METHOD_END"], "methodName": ["threadNamePrefix"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . context . isTypeMatch (  \" default \"  ,    Executor . class )  )  ;", "assertTrue ( this . context . isTypeMatch (  \" default \"  ,    TaskExecutor . class )  )  ;", "assertTrue ( this . context . isTypeMatch (  \" default \"  ,    ThreadPoolTaskExecutor . class )  )  ;", "}", "METHOD_END"], "methodName": ["typeCheck"], "fileName": "org.springframework.scheduling.config.ExecutorBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return   this . initialDelay ;", "}", "METHOD_END"], "methodName": ["getInitialDelay"], "fileName": "org.springframework.scheduling.config.IntervalTask"}, {"methodBody": ["METHOD_START", "{", "return   this . interval ;", "}", "METHOD_END"], "methodName": ["getInterval"], "fileName": "org.springframework.scheduling.config.IntervalTask"}, {"methodBody": ["METHOD_START", "{", "LazyScheduledTasksBeanDefinitionParserTests . Task   task    =    new   GenericXmlApplicationContext ( LazyScheduledTasksBeanDefinitionParserTests . class ,     \" lazyScheduledTasksContext . xml \"  )  . getBean ( LazyScheduledTasksBeanDefinitionParserTests . Task . class )  ;", "while    (  !  ( task . executed )  )     {", "try    {", "Thread . sleep (  1  0  )  ;", "}    catch    ( Exception   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["checkTarget"], "fileName": "org.springframework.scheduling.config.LazyScheduledTasksBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "ScheduledFuture <  ?  >    future    =    this . future ;", "if    ( future    !  =    null )     {", "future . cancel ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.springframework.scheduling.config.ScheduledTask"}, {"methodBody": ["METHOD_START", "{", "return   this . task ;", "}", "METHOD_END"], "methodName": ["getTask"], "fileName": "org.springframework.scheduling.config.ScheduledTask"}, {"methodBody": ["METHOD_START", "{", "addCronTask ( new   CronTask ( task ,    expression )  )  ;", "}", "METHOD_END"], "methodName": ["addCronTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cronTasks )     =  =    null )     {", "this . cronTasks    =    new   ArrayList <  >  (  )  ;", "}", "this . cronTasks . add ( task )  ;", "}", "METHOD_END"], "methodName": ["addCronTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "addFixedDelayTask ( new   IntervalTask ( task ,    delay ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["addFixedDelayTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . fixedDelayTasks )     =  =    null )     {", "this . fixedDelayTasks    =    new   ArrayList <  >  (  )  ;", "}", "this . fixedDelayTasks . add ( task )  ;", "}", "METHOD_END"], "methodName": ["addFixedDelayTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "addFixedRateTask ( new   IntervalTask ( task ,    interval ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["addFixedRateTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . fixedRateTasks )     =  =    null )     {", "this . fixedRateTasks    =    new   ArrayList <  >  (  )  ;", "}", "this . fixedRateTasks . add ( task )  ;", "}", "METHOD_END"], "methodName": ["addFixedRateTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    ( task    !  =    null )     {", "this . ss . add ( task )  ;", "}", "}", "METHOD_END"], "methodName": ["addScheduledTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "addTriggerTask ( new   TriggerTask ( task ,    trigger )  )  ;", "}", "METHOD_END"], "methodName": ["addTriggerTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . triggerTasks )     =  =    null )     {", "this . triggerTasks    =    new   ArrayList <  >  (  )  ;", "}", "this . triggerTasks . add ( task )  ;", "}", "METHOD_END"], "methodName": ["addTriggerTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "return    ( this . cronTasks )     !  =    null    ?    Collections . unmodifiableList ( this . cronTasks )     :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getCronTaskList"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "return    ( this . fixedDelayTasks )     !  =    null    ?    Collections . unmodifiableList ( this . fixedDelayTasks )     :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getFixedDelayTaskList"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "return    ( this . fixedRateTasks )     !  =    null    ?    Collections . unmodifiableList ( this . fixedRateTasks )     :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getFixedRateTaskList"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "return   this . taskScheduler ;", "}", "METHOD_END"], "methodName": ["getScheduler"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "return    ( this . triggerTasks )     !  =    null    ?    Collections . unmodifiableList ( this . triggerTasks )     :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getTriggerTaskList"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  !  ( CollectionUtils . isEmpty ( this . triggerTasks )  )  )     |  |     (  !  ( CollectionUtils . isEmpty ( this . cronTasks )  )  )  )     |  |     (  !  ( CollectionUtils . isEmpty ( this . fixedRateTasks )  )  )  )     |  |     (  !  ( CollectionUtils . isEmpty ( this . fixedDelayTasks )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "ScheduledTask   scheduledTask    =    this . unresolvedTasks . remove ( task )  ;", "boolean   newTask    =    false ;", "if    ( scheduledTask    =  =    null )     {", "scheduledTask    =    new   ScheduledTask ( task )  ;", "newTask    =    true ;", "}", "if    (  ( this . taskScheduler )     !  =    null )     {", "scheduledTask . future    =    this . taskScheduler . schedule ( task . getRunnable (  )  ,    task . getTrigger (  )  )  ;", "} else    {", "addCronTask ( task )  ;", "this . unresolvedTasks . put ( task ,    scheduledTask )  ;", "}", "return   newTask    ?    scheduledTask    :    null ;", "}", "METHOD_END"], "methodName": ["scheduleCronTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "ScheduledTask   scheduledTask    =    this . unresolvedTasks . remove ( task )  ;", "boolean   newTask    =    false ;", "if    ( scheduledTask    =  =    null )     {", "scheduledTask    =    new   ScheduledTask ( task )  ;", "newTask    =    true ;", "}", "if    (  ( this . taskScheduler )     !  =    null )     {", "if    (  ( task . getInitialDelay (  )  )     >     0  )     {", "Date   startTime    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +     ( task . getInitialDelay (  )  )  )  )  ;", "scheduledTask . future    =    this . taskScheduler . scheduleWithFixedDelay ( task . getRunnable (  )  ,    startTime ,    task . getInterval (  )  )  ;", "} else    {", "scheduledTask . future    =    this . taskScheduler . scheduleWithFixedDelay ( task . getRunnable (  )  ,    task . getInterval (  )  )  ;", "}", "} else    {", "addFixedDelayTask ( task )  ;", "this . unresolvedTasks . put ( task ,    scheduledTask )  ;", "}", "return   newTask    ?    scheduledTask    :    null ;", "}", "METHOD_END"], "methodName": ["scheduleFixedDelayTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "FixedDelayTask   taskToUse    =     ( task   instanceof   FixedDelayTask )     ?     (  ( FixedDelayTask )     ( task )  )     :    new   FixedDelayTask ( task . getRunnable (  )  ,    task . getInterval (  )  ,    task . getInitialDelay (  )  )  ;", "return   eFixedDelayTask ( taskToUse )  ;", "}", "METHOD_END"], "methodName": ["scheduleFixedDelayTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "ScheduledTask   scheduledTask    =    this . unresolvedTasks . remove ( task )  ;", "boolean   newTask    =    false ;", "if    ( scheduledTask    =  =    null )     {", "scheduledTask    =    new   ScheduledTask ( task )  ;", "newTask    =    true ;", "}", "if    (  ( this . taskScheduler )     !  =    null )     {", "if    (  ( task . getInitialDelay (  )  )     >     0  )     {", "Date   startTime    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +     ( task . getInitialDelay (  )  )  )  )  ;", "scheduledTask . future    =    this . taskScheduler . scheduleAtFixedRate ( task . getRunnable (  )  ,    startTime ,    task . getInterval (  )  )  ;", "} else    {", "scheduledTask . future    =    this . taskScheduler . scheduleAtFixedRate ( task . getRunnable (  )  ,    task . getInterval (  )  )  ;", "}", "} else    {", "addFixedRateTask ( task )  ;", "this . unresolvedTasks . put ( task ,    scheduledTask )  ;", "}", "return   newTask    ?    scheduledTask    :    null ;", "}", "METHOD_END"], "methodName": ["scheduleFixedRateTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "FixedRateTask   taskToUse    =     ( task   instanceof   FixedRateTask )     ?     (  ( FixedRateTask )     ( task )  )     :    new   FixedRateTask ( task . getRunnable (  )  ,    task . getInterval (  )  ,    task . getInitialDelay (  )  )  ;", "return   eFixedRateTask ( taskToUse )  ;", "}", "METHOD_END"], "methodName": ["scheduleFixedRateTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . taskScheduler )     =  =    null )     {", "this . localExecutor    =    Executors . newSingleThreadScheduledExecutor (  )  ;", "this . taskScheduler    =    new   ConcurrentTaskScheduler ( this . localExecutor )  ;", "}", "if    (  ( this . triggerTasks )     !  =    null )     {", "for    ( TriggerTask   task    :    this . triggerTasks )     {", "add ( scheduleTriggerTask ( task )  )  ;", "}", "}", "if    (  ( this . cronTasks )     !  =    null )     {", "for    ( CronTask   task    :    this . cronTasks )     {", "add ( scheduleCronTask ( task )  )  ;", "}", "}", "if    (  ( this . fixedRateTasks )     !  =    null )     {", "for    ( IntervalTask   task    :    this . fixedRateTasks )     {", "add ( scheduleFixedRateTask ( task )  )  ;", "}", "}", "if    (  ( this . fixedDelayTasks )     !  =    null )     {", "for    ( IntervalTask   task    :    this . fixedDelayTasks )     {", "add ( scheduleFixedDelayTask ( task )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["scheduleTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "ScheduledTask   scheduledTask    =    this . unresolvedTasks . remove ( task )  ;", "boolean   newTask    =    false ;", "if    ( scheduledTask    =  =    null )     {", "scheduledTask    =    new   ScheduledTask ( task )  ;", "newTask    =    true ;", "}", "if    (  ( this . taskScheduler )     !  =    null )     {", "scheduledTask . future    =    this . taskScheduler . schedule ( task . getRunnable (  )  ,    task . getTrigger (  )  )  ;", "} else    {", "addTriggerTask ( task )  ;", "this . unresolvedTasks . put ( task ,    scheduledTask )  ;", "}", "return   newTask    ?    scheduledTask    :    null ;", "}", "METHOD_END"], "methodName": ["scheduleTriggerTask"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . cronTasks    =    new   ArrayList <  >  (  )  ;", "cronTasks . forEach ( this :  : addCronTask )  ;", "}", "METHOD_END"], "methodName": ["setCronTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . cronTasks    =    cronTasks ;", "}", "METHOD_END"], "methodName": ["setCronTasksList"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . fixedDelayTasks    =    new   ArrayList <  >  (  )  ;", "fixedDelayTasks . forEach ( this :  : addFixedDelayTask )  ;", "}", "METHOD_END"], "methodName": ["setFixedDelayTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . fixedDelayTasks    =    fixedDelayTasks ;", "}", "METHOD_END"], "methodName": ["setFixedDelayTasksList"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . fixedRateTasks    =    new   ArrayList <  >  (  )  ;", "fixedRateTasks . forEach ( this :  : addFixedRateTask )  ;", "}", "METHOD_END"], "methodName": ["setFixedRateTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . fixedRateTasks    =    fixedRateTasks ;", "}", "METHOD_END"], "methodName": ["setFixedRateTasksList"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    ( scheduler    =  =    null )     {", "this . taskScheduler    =    null ;", "} else", "if    ( scheduler   instanceof   TaskScheduler )     {", "this . taskScheduler    =     (  ( TaskScheduler )     ( scheduler )  )  ;", "} else", "if    ( scheduler   instanceof   ScheduledExecutorService )     {", "this . taskScheduler    =    new   current . ConcurrentTaskScheduler (  (  ( ScheduledExecutorService )     ( scheduler )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unsupported   scheduler   type :     \"     +     ( scheduler . getClass (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setScheduler"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( taskScheduler ,     \" TaskScheduler   must   not   be   null \"  )  ;", "this . taskScheduler    =    taskScheduler ;", "}", "METHOD_END"], "methodName": ["setTaskScheduler"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . triggerTasks    =    new   ArrayList <  >  (  )  ;", "triggerTasks . forEach (  (    task ,    trigger )     -  >    addTriggerTask ( new   TriggerTask ( task ,    trigger )  )  )  ;", "}", "METHOD_END"], "methodName": ["setTriggerTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . triggerTasks    =    triggerTasks ;", "}", "METHOD_END"], "methodName": ["setTriggerTasksList"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrar"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . taskRegistrar . getTriggerTaskList (  )  . isEmpty (  )  )  ;", "assertTrue ( this . taskRegistrar . getCronTaskList (  )  . isEmpty (  )  )  ;", "assertTrue ( this . taskRegistrar . getFixedRateTaskList (  )  . isEmpty (  )  )  ;", "assertTrue ( this . taskRegistrar . getFixedDelayTaskList (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyTaskLists"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "CronTask   mockCronTask    =    mock ( CronTask . class )  ;", "List < CronTask >    cronTaskList    =    Collections . singletonList ( mockCronTask )  ;", "this . t . setCronTasksList ( cronTaskList )  ;", "List < CronTask >    retrievedList    =    this . t . getCronTaskList (  )  ;", "assertEquals (  1  ,    retrievedList . size (  )  )  ;", "assertEquals ( mockCronTask ,    retrievedList . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getCronTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "IntervalTask   mockFixedDelayTask    =    mock ( IntervalTask . class )  ;", "List < IntervalTask >    fixedDelayTaskList    =    Collections . singletonList ( mockFixedDelayTask )  ;", "this . t . setFixedDelayTasksList ( fixedDelayTaskList )  ;", "List < IntervalTask >    retrievedList    =    this . t . getFixedDelayTaskList (  )  ;", "assertEquals (  1  ,    retrievedList . size (  )  )  ;", "assertEquals ( mockFixedDelayTask ,    retrievedList . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getFixedDelayTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "IntervalTask   mockFixedRateTask    =    mock ( IntervalTask . class )  ;", "List < IntervalTask >    fixedRateTaskList    =    Collections . singletonList ( mockFixedRateTask )  ;", "this . t . setFixedRateTasksList ( fixedRateTaskList )  ;", "List < IntervalTask >    retrievedList    =    this . t . getFixedRateTaskList (  )  ;", "assertEquals (  1  ,    retrievedList . size (  )  )  ;", "assertEquals ( mockFixedRateTask ,    retrievedList . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getFixedRateTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "TriggerTask   mockTriggerTask    =    mock ( TriggerTask . class )  ;", "List < TriggerTask >    triggerTaskList    =    Collections . singletonList ( mockTriggerTask )  ;", "this . t . setTriggerTasksList ( triggerTaskList )  ;", "List < TriggerTask >    retrievedList    =    this . t . getTriggerTaskList (  )  ;", "assertEquals (  1  ,    retrievedList . size (  )  )  ;", "assertEquals ( mockTriggerTask ,    retrievedList . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getTriggerTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTaskRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "builder . getRawBeanDefinition (  )  . setSource ( parserContext . extractSource ( taskElement )  )  ;", "String   generatedName    =    parserContext . getReaderContext (  )  . generateBeanName ( builder . getRawBeanDefinition (  )  )  ;", "parserContext . registerBeanComponent ( new   beans . factory . parsing . BeanComponentDefinition ( builder . getBeanDefinition (  )  ,    generatedName )  )  ;", "return   new   RuntimeBeanReference ( generatedName )  ;", "}", "METHOD_END"], "methodName": ["beanReference"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . genericBeanDefinition (  \" CronTask \"  )  ;", "builder . addConstructorArgReference ( runnableBeanName )  ;", "builder . addConstructorArgValue ( cronExpression )  ;", "return   beanReference ( taskElement ,    parserContext ,    builder )  ;", "}", "METHOD_END"], "methodName": ["cronTaskReference"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . genericBeanDefinition (  \" IntervalTask \"  )  ;", "builder . addConstructorArgReference ( runnableBeanName )  ;", "builder . addConstructorArgValue ( interval )  ;", "builder . addConstructorArgValue (  ( StringUtils . hasLength ( initialDelay )     ?    initialDelay    :    ScheduledTasksBeanDefinitionParser . ZERO _ INITIAL _ DELAY )  )  ;", "return   beanReference ( taskElement ,    parserContext ,    builder )  ;", "}", "METHOD_END"], "methodName": ["intervalTaskReference"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return    (  ( node . getNodeType (  )  )     =  =     ( Node . ELEMENT _ NODE )  )     &  &     ( ScheduledTasksBeanDefinitionParser . ELEMENT _ SCHEDULED . equals ( parserContext . getDelegate (  )  . getLocalName ( node )  )  )  ;", "}", "METHOD_END"], "methodName": ["isScheduledElement"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . genericBeanDefinition (  \" ScheduledMethodRunnable \"  )  ;", "builder . addConstructorArgReference ( ref )  ;", "builder . addConstructorArgValue ( method )  ;", "return   beanReference ( taskElement ,    parserContext ,    builder )  ;", "}", "METHOD_END"], "methodName": ["runnableReference"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . genericBeanDefinition (  \" TriggerTask \"  )  ;", "builder . addConstructorArgReference ( runnableBeanName )  ;", "builder . addConstructorArgReference ( triggerBeanName )  ;", "return   beanReference ( taskElement ,    parserContext ,    builder )  ;", "}", "METHOD_END"], "methodName": ["triggerTaskReference"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Object   schedulerBean    =    this . context . getBean (  \" testScheduler \"  )  ;", "Object   schedulerRef    =    new   DirectFieldAccessor ( this . registrar )  . getPropertyValue (  \" taskScheduler \"  )  ;", "assertEquals ( schedulerBean ,    schedulerRef )  ;", "}", "METHOD_END"], "methodName": ["checkScheduler"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "List < IntervalTask >    tasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( this . registrar )  . getPropertyValue (  \" fixedRateTasks \"  )  )  )  ;", "Runnable   runnable    =    tasks . get (  0  )  . getRunnable (  )  ;", "assertEquals ( MethodRunnable . class ,    runnable . getClass (  )  )  ;", "Object   targetObject    =     (  ( MethodRunnable )     ( runnable )  )  . getTarget (  )  ;", "Method   targetMethod    =     (  ( MethodRunnable )     ( runnable )  )  . getMethod (  )  ;", "assertEquals ( this . testBean ,    targetObject )  ;", "assertEquals (  \" test \"  ,    targetMethod . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkTarget"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "List < CronTask >    tasks    =     (  ( List < CronTask >  )     ( new   DirectFieldAccessor ( this . registrar )  . getPropertyValue (  \" cronTasks \"  )  )  )  ;", "assertEquals (  1  ,    tasks . size (  )  )  ;", "assertEquals (  \"  *  /  4     *     9  -  1  7     *     *    MON - FRI \"  ,    tasks . get (  0  )  . getExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["cronTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "List < IntervalTask >    tasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( this . registrar )  . getPropertyValue (  \" fixedDelayTasks \"  )  )  )  ;", "assertEquals (  2  ,    tasks . size (  )  )  ;", "assertEquals (  3  0  0  0 L ,    tasks . get (  0  )  . getInterval (  )  )  ;", "assertEquals (  3  5  0  0 L ,    tasks . get (  1  )  . getInterval (  )  )  ;", "assertEquals (  2  5  0  ,    tasks . get (  1  )  . getInitialDelay (  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedDelayTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "List < IntervalTask >    tasks    =     (  ( List < IntervalTask >  )     ( new   DirectFieldAccessor ( this . registrar )  . getPropertyValue (  \" fixedRateTasks \"  )  )  )  ;", "assertEquals (  3  ,    tasks . size (  )  )  ;", "assertEquals (  1  0  0  0 L ,    tasks . get (  0  )  . getInterval (  )  )  ;", "assertEquals (  2  0  0  0 L ,    tasks . get (  1  )  . getInterval (  )  )  ;", "assertEquals (  4  0  0  0 L ,    tasks . get (  2  )  . getInterval (  )  )  ;", "assertEquals (  5  0  0  ,    tasks . get (  2  )  . getInitialDelay (  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedRateTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   ClassPathXmlApplicationContext (  \" scheduledTasksContext . xml \"  ,    ScheduledTasksBeanDefinitionParserTests . class )  ;", "this . registrar    =    this . context . getBeansOfType ( ScheduledTaskRegistrar . class )  . values (  )  . iterator (  )  . next (  )  ;", "this . testBean    =    this . context . getBean (  \" testBean \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "List < TriggerTask >    tasks    =     (  ( List < TriggerTask >  )     ( new   DirectFieldAccessor ( this . registrar )  . getPropertyValue (  \" triggerTasks \"  )  )  )  ;", "assertEquals (  1  ,    tasks . size (  )  )  ;", "assertThat ( tasks . get (  0  )  . getTrigger (  )  ,    instanceOf (  . TestTrigger . class )  )  ;", "}", "METHOD_END"], "methodName": ["triggerTasks"], "fileName": "org.springframework.scheduling.config.ScheduledTasksBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskScheduler   scheduler    =     (  ( ThreadPoolTaskScheduler )     ( this . context . getBean (  \" customScheduler \"  )  )  )  ;", "Integer   size    =     (  ( Integer )     ( new   DirectFieldAccessor ( scheduler )  . getPropertyValue (  \" poolSize \"  )  )  )  ;", "assertEquals ( new   Integer (  4  2  )  ,    size )  ;", "}", "METHOD_END"], "methodName": ["customScheduler"], "fileName": "org.springframework.scheduling.config.SchedulerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskScheduler   scheduler    =     (  ( ThreadPoolTaskScheduler )     ( this . context . getBean (  \" defaultScheduler \"  )  )  )  ;", "Integer   size    =     (  ( Integer )     ( new   DirectFieldAccessor ( scheduler )  . getPropertyValue (  \" poolSize \"  )  )  )  ;", "assertEquals ( new   Integer (  1  )  ,    size )  ;", "}", "METHOD_END"], "methodName": ["defaultScheduler"], "fileName": "org.springframework.scheduling.config.SchedulerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   ClassPathXmlApplicationContext (  \" schedulerContext . xml \"  ,    SchedulerBeanDefinitionParserTests . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.scheduling.config.SchedulerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskScheduler   scheduler    =     (  ( ThreadPoolTaskScheduler )     ( this . context . getBean (  \" customScheduler \"  )  )  )  ;", "assertEquals (  \" customScheduler -  \"  ,    scheduler . getThreadNamePrefix (  )  )  ;", "}", "METHOD_END"], "methodName": ["threadNamePrefix"], "fileName": "org.springframework.scheduling.config.SchedulerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return   this . runnable ;", "}", "METHOD_END"], "methodName": ["getRunnable"], "fileName": "org.springframework.scheduling.config.Task"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( this . poolSize )  )     {", "try    {", "int   corePoolSize ;", "int   maxPoolSize ;", "int   separatorIndex    =    this . poolSize . indexOf (  '  -  '  )  ;", "if    ( separatorIndex    !  =     (  -  1  )  )     {", "corePoolSize    =    Integer . valueOf ( this . poolSize . substring (  0  ,    separatorIndex )  )  ;", "maxPoolSize    =    Integer . valueOf ( this . poolSize . substring (  ( separatorIndex    +     1  )  ,    this . poolSize . length (  )  )  )  ;", "if    ( corePoolSize    >    maxPoolSize )     {", "throw   new   IllegalArgumentException (  \" Lower   bound   of   pool - size   range   must   not   exceed   the   upper   bound \"  )  ;", "}", "if    (  ( this . queueCapacity )     =  =    null )     {", "if    ( corePoolSize    =  =     0  )     {", "e . setAllowCoreThreadTimeOut ( true )  ;", "corePoolSize    =    maxPoolSize ;", "} else    {", "throw   new   IllegalArgumentException (  \" A   non - zero   lower   bound   for   the   size   range   requires   a   queue - capacity   value \"  )  ;", "}", "}", "} else    {", "Integer   value    =    Integer . valueOf ( this . poolSize )  ;", "corePoolSize    =    value ;", "maxPoolSize    =    value ;", "}", "e . setCorePoolSize ( corePoolSize )  ;", "e . setMaxPoolSize ( maxPoolSize )  ;", "}    catch    ( NumberFormatException   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Invalid   pool - size   value    [  \"     +     ( this . poolSize )  )     +     \"  ]  :    only   single    \"  )     +     \" maximum   integer    ( e . g .     \\  \"  5  \\  \"  )    and   minimum - maximum   range    ( e . g .     \\  \"  3  -  5  \\  \"  )    are   supported \"  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["determinePoolSizeRange"], "fileName": "org.springframework.scheduling.config.TaskExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . keepAliveSeconds    =    keepAliveSeconds ;", "}", "METHOD_END"], "methodName": ["setKeepAliveSeconds"], "fileName": "org.springframework.scheduling.config.TaskExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . poolSize    =    poolSize ;", "}", "METHOD_END"], "methodName": ["setPoolSize"], "fileName": "org.springframework.scheduling.config.TaskExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . queueCapacity    =    queueCapacity ;", "}", "METHOD_END"], "methodName": ["setQueueCapacity"], "fileName": "org.springframework.scheduling.config.TaskExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . rejectedExecutionHandler    =    rejectedExecutionHandler ;", "}", "METHOD_END"], "methodName": ["setRejectedExecutionHandler"], "fileName": "org.springframework.scheduling.config.TaskExecutorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . trigger ;", "}", "METHOD_END"], "methodName": ["getTrigger"], "fileName": "org.springframework.scheduling.config.TriggerTask"}, {"methodBody": ["METHOD_START", "{", "return    ( fields    !  =    null )     &  &     (  ( fields . length )     =  =     6  )  ;", "}", "METHOD_END"], "methodName": ["areValidCronFields"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    resets    =    new   ArrayList <  >  (  )  ;", "int   second    =    calendar . get ( Calendar . SECOND )  ;", "List < Integer >    emptyList    =    Collections . emptyList (  )  ;", "int   updateSecond    =    findNext ( this . seconds ,    second ,    calendar ,    Calendar . SECOND ,    Calendar . MINUTE ,    emptyList )  ;", "if    ( second    =  =    updateSecond )     {", "resets . add ( Calendar . SECOND )  ;", "}", "int   minute    =    calendar . get ( Calendar . MINUTE )  ;", "int   updateMinute    =    findNext ( this . minutes ,    minute ,    calendar ,    Calendar . MINUTE ,    Calendar . HOUR _ OF _ DAY ,    resets )  ;", "if    ( minute    =  =    updateMinute )     {", "resets . add ( Calendar . MINUTE )  ;", "} else    {", "doNext ( calendar ,    dot )  ;", "}", "int   hour    =    calendar . get ( Calendar . HOUR _ OF _ DAY )  ;", "int   updateHour    =    findNext ( this . hours ,    hour ,    calendar ,    Calendar . HOUR _ OF _ DAY ,    Calendar . DAY _ OF _ WEEK ,    resets )  ;", "if    ( hour    =  =    updateHour )     {", "resets . add ( Calendar . HOUR _ OF _ DAY )  ;", "} else    {", "doNext ( calendar ,    dot )  ;", "}", "int   dayOfWeek    =    calendar . get ( Calendar . DAY _ OF _ WEEK )  ;", "int   dayOfMonth    =    calendar . get ( Calendar . DAY _ OF _ MONTH )  ;", "int   updateDayOfMonth    =    findNextDay ( calendar ,    this . daysOfMonth ,    dayOfMonth ,    daysOfWeek ,    dayOfWeek ,    resets )  ;", "if    ( dayOfMonth    =  =    updateDayOfMonth )     {", "resets . add ( Calendar . DAY _ OF _ MONTH )  ;", "} else    {", "doNext ( calendar ,    dot )  ;", "}", "int   month    =    calendar . get ( Calendar . MONTH )  ;", "int   updateMonth    =    findNext ( this . months ,    month ,    calendar ,    Calendar . MONTH ,    Calendar . YEAR ,    resets )  ;", "if    ( month    !  =    updateMonth )     {", "if    (  (  ( calendar . get ( Calendar . YEAR )  )     -    dot )     >     4  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   c   expression    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"    led   to   runaway   search   for   next   trigger \"  )  )  ;", "}", "doNext ( calendar ,    dot )  ;", "}", "}", "METHOD_END"], "methodName": ["doNext"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "setNumberHits ( this . seconds ,    fields [  0  ]  ,     0  ,     6  0  )  ;", "setNumberHits ( this . minutes ,    fields [  1  ]  ,     0  ,     6  0  )  ;", "setNumberHits ( this . hours ,    fields [  2  ]  ,     0  ,     2  4  )  ;", "setDaysOfMonth ( this . daysOfMonth ,    fields [  3  ]  )  ;", "setMonths ( this . months ,    fields [  4  ]  )  ;", "setDays ( this . daysOfWeek ,    replaceOrdinals ( fields [  5  ]  ,     \" SUN , MON , TUE , WED , THU , FRI , SAT \"  )  ,     8  )  ;", "if    ( this . daysOfWeek . get (  7  )  )     {", "this . daysOfWeeet (  0  )  ;", "this . daysOfWeek . clear (  7  )  ;", "}", "}", "METHOD_END"], "methodName": ["doParse"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "int   nextValue    =    bits . nextSetBit ( value )  ;", "if    ( nextValue    =  =     (  -  1  )  )     {", "calendar . add ( nextField ,     1  )  ;", "reset ( calendar ,    Collections . sletonList ( field )  )  ;", "nextValue    =    bits . nextSetBit (  0  )  ;", "}", "if    ( nextValue    !  =    value )     {", "calendar . set ( field ,    nextValue )  ;", "reset ( calendar ,    lowerOrders )  ;", "}", "return   nextValue ;", "}", "METHOD_END"], "methodName": ["findNext"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "int   max    =     3  6  6  ;", "while    (  (  (  !  ( daysOfMonth . get ( dayOfMonth )  )  )     |  |     (  !  ( daysOfWeek . get (  ( dayOfWeek    -     1  )  )  )  )  )     &  &     (  ( count +  +  )     <    max )  )     {", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "dayOfMonth    =    calendar . get ( Calendar . DAY _ OF _ MONTH )  ;", "dayOfWeek    =    calendar . get ( Calendar . DAY _ OF _ WEEK )  ;", "reset ( calendar ,    resets )  ;", "}", "if    ( count    >  =    max )     {", "throw   new   IllegalArgumentException (  (  (  \" Overflow   in   day   for   expression    \\  \"  \"     +     ( this . expression )  )     +     \"  \\  \"  \"  )  )  ;", "}", "return   dayOfMonth ;", "}", "METHOD_END"], "methodName": ["findNextDay"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . expression ;", "}", "METHOD_END"], "methodName": ["getExpression"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  2  ]  ;", "if    ( field . contains (  \"  *  \"  )  )     {", "result [  0  ]     =    min ;", "result [  1  ]     =    max    -     1  ;", "return   result ;", "}", "if    (  !  ( field . contains (  \"  -  \"  )  )  )     {", "result [  0  ]     =    result [  1  ]     =    Integer . valueOf ( field )  ;", "} else    {", "St [  ]    split    =    StUtils . delimitedListToStArray ( field ,     \"  -  \"  )  ;", "if    (  ( split . length )     >     2  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Range   has   more   than   two   fields :     '  \"     +    field )     +     \"  \\  '    in   expression    \\  \"  \"  )     +     ( this . expression )  )     +     \"  \\  \"  \"  )  )  ;", "}", "result [  0  ]     =    Integer . valueOf ( split [  0  ]  )  ;", "result [  1  ]     =    Integer . valueOf ( split [  1  ]  )  ;", "}", "if    (  (  ( result [  0  ]  )     >  =    max )     |  |     (  ( result [  1  ]  )     >  =    max )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Range   exceeds   maximum    (  \"     +    max )     +     \"  )  :     '  \"  )     +    field )     +     \"  \\  '    in   expression    \\  \"  \"  )     +     ( this . expression )  )     +     \"  \\  \"  \"  )  )  ;", "}", "if    (  (  ( result [  0  ]  )     <    min )     |  |     (  ( result [  1  ]  )     <    min )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Range   less   than   minimum    (  \"     +    min )     +     \"  )  :     '  \"  )     +    field )     +     \"  \\  '    in   expression    \\  \"  \"  )     +     ( this . expression )  )     +     \"  \\  \"  \"  )  )  ;", "}", "if    (  ( result [  0  ]  )     >     ( result [  1  ]  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Invalid   inverted   range :     '  \"     +    field )     +     \"  \\  '    in   expression    \\  \"  \"  )     +     ( this . expression )  )     +     \"  \\  \"  \"  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getRange"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( expression    =  =    null )     {", "return   false ;", "}", "String [  ]    fields    =    StringUtils . tokenizeToStringArray ( expression ,     \"     \"  )  ;", "if    (  !  (  . areValidCronFields ( fields )  )  )     {", "return   false ;", "}", "try    {", "new    ( expression ,    fields )  ;", "return   true ;", "}    catch    ( IllegalArgumentException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isValidExpression"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "Calendar   calendar    =    new   GregorianCalendar (  )  ;", "calendar . setTimeZone ( this . timeZone )  ;", "calendar . setTime ( date )  ;", "calendar . set ( Calendar . MILLISECOND ,     0  )  ;", "long   originalTimestamp    =    calendar . getTimeInMillis (  )  ;", "doNext ( calendar ,    calendar . get ( Calendar . YEAR )  )  ;", "if    (  ( calendar . getTimeInMillis (  )  )     =  =    originalTimestamp )     {", "calendar . add ( Calendar . SECOND ,     1  )  ;", "doNext ( calendar ,    calendar . get ( Calendar . YEAR )  )  ;", "}", "return   calendar . getTime (  )  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "String [  ]    fields    =    StringUtils . tokenizeToStringArray ( expression ,     \"     \"  )  ;", "if    (  !  (  . areValidCronFields ( fields )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cron   expression   must   consist   of    6    fields    ( found    % d   in    \\  \"  % s \\  \"  )  \"  ,    fields . length ,    expression )  )  ;", "}", "doParse ( fields )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "String [  ]    list    =    StringUtils . commaDelimitedListToStringArray ( commaSeparatedList )  ;", "for    ( int   i    =     0  ;    i    <     ( list . length )  ;    i +  +  )     {", "String   item    =    list [ i ]  . toUpperCase (  )  ;", "value    =    StringUtils . replace ( value . toUpperCase (  )  ,    item ,     (  \"  \"     +    i )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["replaceOrdinals"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "for    ( int   field    :    fields )     {", "calendar . set ( field ,     ( field    =  =     ( Calendar . DAY _ OF _ MONTH )     ?     1     :     0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( field . contains (  \"  ?  \"  )  )     {", "field    =     \"  *  \"  ;", "}", "setNumberHits ( bits ,    field ,     0  ,    max )  ;", "}", "METHOD_END"], "methodName": ["setDays"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "int   max    =     3  1  ;", "setDays ( bits ,    field ,     ( max    +     1  )  )  ;", "bits . clear (  0  )  ;", "}", "METHOD_END"], "methodName": ["setDaysOfMonth"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "int   max    =     1  2  ;", "value    =    replaceOrdinals ( value ,     \" FOO , JAN , FEB , MAR , APR , MAY , JUN , JUL , AUG , SEP , OCT , NOV , DEC \"  )  ;", "BitSet   months    =    new   BitSet (  1  3  )  ;", "setNumberHits ( months ,    value ,     1  ,     ( max    +     1  )  )  ;", "for    ( int   i    =     1  ;    i    <  =    max ;    i +  +  )     {", "if    ( months . get ( i )  )     {", "bits . set (  ( i    -     1  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setMonths"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "String [  ]    fields    =    StringUtils . delimitedListToStringArray ( value ,     \"  ,  \"  )  ;", "for    ( String   field    :    fields )     {", "if    (  !  ( field . contains (  \"  /  \"  )  )  )     {", "int [  ]    range    =    getRange ( field ,    min ,    max )  ;", "bits . set ( range [  0  ]  ,     (  ( range [  1  ]  )     +     1  )  )  ;", "} else    {", "String [  ]    split    =    StringUtils . delimitedListToStringArray ( field ,     \"  /  \"  )  ;", "if    (  ( split . length )     >     2  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Incrementer   has   more   than   two   fields :     '  \"     +    field )     +     \"  \\  '    in   expression    \\  \"  \"  )     +     ( this . expression )  )     +     \"  \\  \"  \"  )  )  ;", "}", "int [  ]    range    =    getRange ( split [  0  ]  ,    min ,    max )  ;", "if    (  !  ( split [  0  ]  . contains (  \"  -  \"  )  )  )     {", "range [  1  ]     =    max    -     1  ;", "}", "int   delta    =    Integer . parseInt ( split [  1  ]  )  ;", "if    ( delta    <  =     0  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Incrementer   delta   must   be    1    or   higher :     '  \"     +    field )     +     \"  \\  '    in   expression    \\  \"  \"  )     +     ( this . expression )  )     +     \"  \\  \"  \"  )  )  ;", "}", "for    ( int   i    =    range [  0  ]  ;    i    <  =     ( range [  1  ]  )  ;    i    +  =    delta )     {", "bits . set ( i )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setNumberHits"], "fileName": "org.springframework.scheduling.support.CronSequenceGenerator"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   Date (  2  0  1  2  ,     6  ,     2  ,     1  ,     0  )  ,    new   CronSequenceGenerator (  \"  0     *  /  2     1  -  4     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["at0Minutes"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   Date (  2  0  1  2  ,     6  ,     2  ,     1  ,     0  )  ,    new   CronSequenceGenerator (  \"  *  /  1  5     *     1  -  4     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     5  3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["at0Seconds"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   Date (  2  0  1  2  ,     6  ,     2  ,     1  ,     0  )  ,    new   CronSequenceGenerator (  \"  *  /  1  5     *     1  -  4     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     5  3  ,     5  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["at50Seconds"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( CronSequenceGenerator . isValidExpression (  \"  0     *  /  2     1  -  4     *     *     *     *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidExpressionWithLength"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( CronSequenceGenerator . isValidExpression (  \"  0     *  /  2     1  -  4     *    INVALID    *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidExpressionWithMonths"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( CronSequenceGenerator . isValidExpression (  \"  1  0  0     *  /  2     1  -  4     *     *     *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidExpressionWithSeconds"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( CronSequenceGenerator . isValidExpression ( null )  )  ;", "}", "METHOD_END"], "methodName": ["nullExpression"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( CronSequenceGenerator . isValidExpression (  \"  0     *  /  2     1  -  4     *     *     *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["validExpression"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "new   CronSequenceGenerator (  \"  *  /  0     *     *     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["with0Increment"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "new   CronSequenceGenerator (  \"  *     *     6  -  5     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["withInvertedHourRange"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "new   CronSequenceGenerator (  \"  *     6  -  5     *     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["withInvertedMinuteRange"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "new   CronSequenceGenerator (  \"  *  /  -  1     *     *     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["withNegativeIncrement"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "new   CronSequenceGenerator (  \"  *     *     6  -  6     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["withSameHourRange"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "new   CronSequenceGenerator (  \"  *     6  -  6     *     *     *     *  \"  )  . next ( new   Date (  2  0  1  2  ,     6  ,     1  ,     9  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["withSameMinuteRange"], "fileName": "org.springframework.scheduling.support.CronSequenceGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . sequenceGenerator . getExpression (  )  ;", "}", "METHOD_END"], "methodName": ["getExpression"], "fileName": "org.springframework.scheduling.support.CronTrigger"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    calendar . getTime (  )  ;", "roundup ( calendar )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["assertMatchesNextSecond"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "List < Object [  ]  >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new   Object [  ]  {    new   Date (  )  ,    TimeZone . getTimeZone (  \" PST \"  )     }  )  ;", "list . add ( new   Object [  ]  {    new   Date (  )  ,    TimeZone . getTimeZone (  \" CET \"  )     }  )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["getParameters"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "SimpleTriggerContext   context    =    new   SimpleTriggerContext (  )  ;", "context . update ( null ,    null ,    lastCompletionTime )  ;", "return   context ;", "}", "METHOD_END"], "methodName": ["getTriggerContext"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "calendar . add ( Calendar . SECOND ,     1  )  ;", "calendaret ( Calendar . MILLISECOND ,     0  )  ;", "}", "METHOD_END"], "methodName": ["roundup"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "calendar . setTimeZone ( timeZone )  ;", "calendar . setTime ( date )  ;", "roundup ( calendar )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     7  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  1  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . set ( Calendar . MONTH ,     8  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testDailyTriggerInLongMonth"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     8  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . MONTH ,     9  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     2  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testDailyTriggerInShortMonth"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     9  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  1  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . set ( Calendar . MONTH ,     1  0  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testDailyTriggerOnDaylightSavingBoundary"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  *     *     *     4  5     *     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testDayInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  *     *     *     *     *     0  -  6  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  *     *     *     *     *    TUE , WED , THU , FRI , SAT , SUN , MON \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testDayNames"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  0     0     0     3  2     1  2     ?  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testDayOfMonthInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  *     *     *     2     *     *  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  *     *     *     2     *     ?  \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testDayOfWeekIndifferent"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  *     *     *     2  8  -  4  5     *     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testDayRangeInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     1  0     2     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  1  )  ;", "calendar . set ( Calendar . MONTH ,    Calendar . MARCH )  ;", "calendar . set ( Calendar . YEAR ,     2  0  1  3  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     1  )  ;", "calendar . set ( Calendar . SECOND ,     5  4  )  ;", "Date   date    =    calendar . getTime (  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "if    ( timeZone . equals ( TimeZone . getTimeZone (  \" CET \"  )  )  )     {", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "}", "calendar . add ( Calendar . HOUR _ OF _ DAY ,     1  )  ;", "calendar . set ( Calendar . MINUTE ,     1  0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDaylightSavingMissingHour"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  *     *     4  ,  8  ,  1  2  ,  1  6  ,  2  0     *     *     *  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  *     *     4  /  4     *     *     *  \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testHourIncrementer"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  *     *     2  7     *     *     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testHourInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  *     *     2  3  -  2  8     *     *     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testHourRangeInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "assertEquals (  2  ,    calendar . get ( Calendar . DAY _ OF _ MONTH )  )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "assertEquals (  3  ,    calendar . get ( Calendar . DAY _ OF _ MONTH )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementDayOfMonth"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  *     *     *     1  0     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  1  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . MONTH ,     1  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  0  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementDayOfMonthAndRollover"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  *     *     *     1  0     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     9  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementDayOfMonthByOne"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  *     *     *     *     *     2  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ WEEK ,     4  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     6  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "assertEquals ( Calendar . TUESDAY ,    calendar . get ( Calendar . DAY _ OF _ WEEK )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementDayOfWeekAndRollover"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  *     *     *     *     *     2  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ WEEK ,     2  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . DAY _ OF _ WEEK ,     1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "assertEquals ( Calendar . TUESDAY ,    calendar . get ( Calendar . DAY _ OF _ WEEK )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementDayOfWeekByOne"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     9  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  0  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     1  1  )  ;", "calendar . set ( Calendar . MINUTE ,     1  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     1  2  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     1  3  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementHour"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     9  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  0  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     2  3  )  ;", "calendar . set ( Calendar . MINUTE ,     1  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  1  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementHourAndRollover"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     *     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MINUTE ,     1  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . MINUTE ,     1  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "date    =    trigger . nextExecutionTime ( context 1  )  ;", "assertEquals ( calendar . getTime (  )  ,    date )  ;", "calendar . add ( Calendar . MINUTE ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "date    =    trigger . nextExecutionTime ( context 2  )  ;", "assertEquals ( calendar . getTime (  )  ,    date )  ;", "}", "METHOD_END"], "methodName": ["testIncrementMinute"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     1  0     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MINUTE ,     1  1  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . MINUTE ,     5  9  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementMinuteAndRollover"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     1  1     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MINUTE ,     1  0  )  ;", "TriggerContext   context    =     . getTriggerContext ( calendar . getTime (  )  )  ;", "calendar . add ( Calendar . MINUTE ,     1  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementMinuteByOne"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     1     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     9  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "calendar . set ( Calendar . MONTH ,     1  0  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . set ( Calendar . MONTH ,     1  1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementMonth"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     1     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     1  1  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  1  )  ;", "calendar . set ( Calendar . YEAR ,     2  0  1  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "calendar . set ( Calendar . MONTH ,     0  )  ;", "calendar . set ( Calendar . YEAR ,     2  0  1  1  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . set ( Calendar . MONTH ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementMonthAndRollover"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  1  0     *     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . SECOND ,     1  1  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . SECOND ,     5  9  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementSecondAndRollover"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  1  1     *     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . SECOND ,     1  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . SECOND ,     1  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementSecondByOne"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  1  1     *     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . SECOND ,     1  1  )  ;", "SimpleTriggerContext   context    =    new   SimpleTriggerContext (  )  ;", "context . update ( calendar . getTime (  )  ,    new   Date (  (  ( calendar . getTimeInMillis (  )  )     -     1  0  0  )  )  ,    new   Date (  (  ( calendar . getTimeInMillis (  )  )     -     9  0  )  )  )  ;", "calendar . add ( Calendar . MINUTE ,     1  )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testIncrementSecondWithPreviousExecutionTooEarly"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     2  9     2     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . YEAR ,     2  0  0  7  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  0  )  ;", "calendar . set ( Calendar . MONTH ,     1  )  ;", "Date   date    =    calendar . getTime (  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "calendar . set ( Calendar . YEAR ,     2  0  0  8  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     2  9  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . add ( Calendar . YEAR ,     4  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testLeapYearSpecificDate"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  *     *     *     *     *     *  \"  ,    timeZone )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchAll"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  *     *     *     *     *     *  \"  ,    timeZone )  ;", "GregorianCalendar   calendar    =    new   GregorianCalendar (  )  ;", "calendar . set ( Calendar . SECOND ,     5  8  )  ;", "assertMatchesNextSecond ( trigger ,    calendar )  ;", "}", "METHOD_END"], "methodName": ["testMatchLastSecond"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  1  0     *     *     *     *     *  \"  ,    timeZone )  ;", "GregorianCalendar   calendar    =    new   GregorianCalendar (  )  ;", "calendar . set ( Calendar . SECOND ,     9  )  ;", "assertMatchesNextSecond ( trigger ,    calendar )  ;", "}", "METHOD_END"], "methodName": ["testMatchSpecificSecond"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  *     7  7     *     *     *     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testMinuteInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  *     4  4  -  7  7     *     *     *     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testMinuteRangeInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  0     0     0     2  5     1  3     ?  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testMonthInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  0     0     0     2  5     0     ?  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testMonthInvalidTooSmall"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  *     *     *     *     1  -  1  2     *  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  *     *     *     *    FEB , JAN , MAR , APR , MAY , JUN , JUL , AUG , SEP , OCT , NOV , DEC    *  \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testMonthNames"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  *     *     *     *     2     *  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  *     *     *     *    Feb    *  \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testMonthNamesMixedCase"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  *     *     *     *     1  1  -  1  3     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testMonthRangeInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     3  0     2  3     3  0     1  /  3     ?  \"  ,    timeZone )  ;", "calendar . set (  2  0  1  0  ,     1  1  ,     3  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     2  3  )  ;", "calendar . set ( Calendar . MINUTE ,     3  0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "calendar . add ( Calendar . MONTH ,     1  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . add ( Calendar . MONTH ,     3  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "calendar . add ( Calendar . MONTH ,     3  )  ;", "TriggerContext   context 3     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMonthSequence"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     3  1     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     9  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testMonthlyTriggerInLongMonth"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     1     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MONTH ,     9  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     3  0  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . MONTH ,     1  0  )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context    =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,    trigger . nextExecutionTime ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testMonthlyTriggerInShortMonth"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     0     3  1     6     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     1  0  )  ;", "calendar . set ( Calendar . MONTH ,     2  )  ;", "Date   date    =    calendar . getTime (  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "trigger . nextExecutionTime ( context 1  )  ;", "}", "METHOD_END"], "methodName": ["testNonExistentSpecificDate"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  5  7  ,  5  9     *     *     *     *     *  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  5  7  /  2     *     *     *     *     *  \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testSecondIncrementer"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  1  ,  3  ,  5     *     *     *     *     *  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  1  -  6  /  2     *     *     *     *     *  \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testSecondIncrementerWithRange"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  7  7     *     *     *     *     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testSecondInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  1  0  -  1  5     *     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . SECOND ,     9  )  ;", "assertMatchesNextSecond ( trigger ,    calendar )  ;", "calendar . set ( Calendar . SECOND ,     1  4  )  ;", "assertMatchesNextSecond ( trigger ,    calendar )  ;", "}", "METHOD_END"], "methodName": ["testSecondRange"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "new   CronTrigger (  \"  4  4  -  7  7     *     *     *     *     *  \"  ,    timeZone )  ;", "}", "METHOD_END"], "methodName": ["testSecondRangeInvalid"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  *     *     *     3     1  1     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     2  )  ;", "calendar . set ( Calendar . MONTH ,     9  )  ;", "Date   date    =    calendar . getTime (  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MONTH ,     1  0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . add ( Calendar . SECOND ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecificDate"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  5  5     *     *     3     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . DAY _ OF _ MONTH ,     2  )  ;", "calendar . set ( Calendar . SECOND ,     5  4  )  ;", "Date   date    =    calendar . getTime (  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     0  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     5  5  )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . add ( Calendar . MINUTE ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecificDayOfMonthSecond"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  5  5     *     1  0     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     9  )  ;", "calendar . set ( Calendar . SECOND ,     5  4  )  ;", "Date   date    =    calendar . getTime (  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "calendar . add ( Calendar . HOUR _ OF _ DAY ,     1  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     5  5  )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . add ( Calendar . MINUTE ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecificHourSecond"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  *     5     1  0     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MINUTE ,     4  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     9  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . add ( Calendar . MINUTE ,     1  )  ;", "calendar . add ( Calendar . HOUR _ OF _ DAY ,     1  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . add ( Calendar . SECOND ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecificMinuteHour"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  5  5     5     *     *     *     *  \"  ,    timeZone )  ;", "calendar . set ( Calendar . MINUTE ,     4  )  ;", "calendar . set ( Calendar . SECOND ,     5  4  )  ;", "Date   date    =    calendar . getTime (  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "calendar . add ( Calendar . MINUTE ,     1  )  ;", "calendar . set ( Calendar . SECOND ,     5  5  )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . add ( Calendar . HOUR ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecificMinuteSecond"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  *     *     *     *     *     0  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  *     *     *     *     *    SUN \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testSundayIsZero"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  *     *     *     *     *     0  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  *     *     *     *     *     7  \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testSundaySynonym"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger    =    new   CronTrigger (  \"  0     0     7     ?     *    MON - FRI \"  ,    timeZone )  ;", "calendar . set (  2  0  0  9  ,     8  ,     2  6  )  ;", "Date   date    =    calendar . getTime (  )  ;", "calendar . set ( Calendar . HOUR _ OF _ DAY ,     7  )  ;", "calendar . set ( Calendar . MINUTE ,     0  )  ;", "calendar . set ( Calendar . SECOND ,     0  )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     2  )  ;", "TriggerContext   context 1     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 1  )  )  )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "TriggerContext   context 2     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 2  )  )  )  ;", "calendar . add ( Calendar . DAY _ OF _ MONTH ,     1  )  ;", "TriggerContext   context 3     =     . getTriggerContext ( date )  ;", "assertEquals ( calendar . getTime (  )  ,     ( date    =    trigger . nextExecutionTime ( context 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWeekDaySequence"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "CronTrigger   trigger 1     =    new   CronTrigger (  \"  *        *        *     *        1     *  \"  ,    timeZone )  ;", "CronTrigger   trigger 2     =    new   CronTrigger (  \"  *     *     *     *     1     *  \"  ,    timeZone )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "}", "METHOD_END"], "methodName": ["testWhitespace"], "fileName": "org.springframework.scheduling.support.CronTriggerTests"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" Invocation   of   method    '  \"     +     ( getTargetMethod (  )  )  )     +     \"  '    on   target   class    [  \"  )     +     ( getTargetClass (  )  )  )     +     \"  ]    failed \"  ;", "}", "METHOD_END"], "methodName": ["getInvocationFailureMessage"], "fileName": "org.springframework.scheduling.support.MethodInvokingRunnable"}, {"methodBody": ["METHOD_START", "{", "return   this . initialDelay ;", "}", "METHOD_END"], "methodName": ["getInitialDelay"], "fileName": "org.springframework.scheduling.support.PeriodicTrigger"}, {"methodBody": ["METHOD_START", "{", "return   this . period ;", "}", "METHOD_END"], "methodName": ["getPeriod"], "fileName": "org.springframework.scheduling.support.PeriodicTrigger"}, {"methodBody": ["METHOD_START", "{", "return   this . timeUnit ;", "}", "METHOD_END"], "methodName": ["getTimeUnit"], "fileName": "org.springframework.scheduling.support.PeriodicTrigger"}, {"methodBody": ["METHOD_START", "{", "return   this . fixedRate ;", "}", "METHOD_END"], "methodName": ["isFixedRate"], "fileName": "org.springframework.scheduling.support.PeriodicTrigger"}, {"methodBody": ["METHOD_START", "{", "this . fixedRate    =    fixedRate ;", "}", "METHOD_END"], "methodName": ["setFixedRate"], "fileName": "org.springframework.scheduling.support.PeriodicTrigger"}, {"methodBody": ["METHOD_START", "{", "this . initialDelay    =    this . timeUnit . toMillis ( initialDelay )  ;", "}", "METHOD_END"], "methodName": ["setInitialDelay"], "fileName": "org.springframework.scheduling.support.PeriodicTrigger"}, {"methodBody": ["METHOD_START", "{", "if    ( o    =  =    null )     {", "return   null ;", "}", "if    ( o   instanceof   Date )     {", "return    (  ( Date )     ( o )  )  ;", "}", "if    ( o   instanceof   Number )     {", "return   new   Date (  (  ( System . currentTimeMillis (  )  )     +     ( NumberUtils . convertNumberToTargetClass (  (  ( Number )     ( o )  )  ,    Loclass )  )  )  )  ;", "}", "throw   new   IllegalArgumentException (  (  \" expected   Date   or   Number ,    but   actual   type   was :     \"     +     ( o . getClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["asDate"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "long   diff    =     ( greater . getTime (  )  )     -     ( lesser . getTime (  )  )  ;", "long   variance    =    Math . abs (  ( expected    -    diff )  )  ;", "assertTrue (  (  (  (  \" expected   approximate   difference   of    \"     +    expected )     +     \"  ,    but   actual   difference   was    \"  )     +    diff )  ,     ( variance    <     1  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertApproximateDifference"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "long   diff    =    Math . abs (  (  ( d 1  . getTime (  )  )     -     ( d 2  . getTime (  )  )  )  )  ;", "assertTrue (  (  \" difference   exceeds   threshold :     \"     +    diff )  ,     ( diff    <     1  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNegligibleDifference"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   PeriodicTriggerTests . TestTriggerContext ( PeriodicTriggerTests . asDate ( scheduled )  ,    PeriodicTriggerTests . asDate ( actual )  ,    PeriodicTriggerTests . asDate ( completion )  )  ;", "}", "METHOD_END"], "methodName": ["context"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "PeriodicTrigger   trigger 1     =    new   PeriodicTrigger (  3  0  0  0  )  ;", "PeriodicTrigger   trigger 2     =    new   PeriodicTrigger (  3  0  0  0  )  ;", "assertFalse ( trigger 1  . equals ( new   String (  \" not   a   trigger \"  )  )  )  ;", "assertFalse ( trigger 1  . equals ( null )  )  ;", "assertEquals ( trigger 1  ,    trigger 1  )  ;", "assertEquals ( trigger 2  ,    trigger 2  )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "trigger 2  . setInitialDelay (  1  2  3  4  )  ;", "assertFalse ( trigger 1  . equals ( trigger 2  )  )  ;", "assertFalse ( trigger 2  . equals ( trigger 1  )  )  ;", "trigger 1  . setInitialDelay (  1  2  3  4  )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "trigger 2  . setFixedRate ( true )  ;", "assertFalse ( trigger 1  . equals ( trigger 2  )  )  ;", "assertFalse ( trigger 2  . equals ( trigger 1  )  )  ;", "trigger 1  . setFixedRate ( true )  ;", "assertEquals ( trigger 1  ,    trigger 2  )  ;", "PeriodicTrigger   trigger 3     =    new   PeriodicTrigger (  3  ,    TimeUnit . SECONDS )  ;", "trigger 3  . setInitialDelay (  7  )  ;", "trigger 3  . setFixedRate ( true )  ;", "assertFalse ( trigger 1  . equals ( trigger 3  )  )  ;", "assertFalse ( trigger 3  . equals ( trigger 1  )  )  ;", "trigger 1  . setInitialDelay (  7  0  0  0  )  ;", "assertEquals ( trigger 1  ,    trigger 3  )  ;", "}", "METHOD_END"], "methodName": ["equalsVerification"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger (  5  0  0  0  )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( null ,    null ,    null )  )  ;", ". assertNegligibleDifference ( now ,    next )  ;", "}", "METHOD_END"], "methodName": ["fixedDelayFirstExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  0  0  0  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( now ,     5  0  0  ,     3  0  0  0  )  )  ;", ". assertApproximateDifference ( now ,    next ,     ( period    +     3  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedDelaySubsequentExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  0  0  0  ;", "long   initialDelay    =     3  0  0  0  0  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period )  ;", "trigger . setInitialDelay ( initialDelay )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( null ,    null ,    null )  )  ;", ". assertApproximateDifference ( now ,    next ,    initialDelay )  ;", "}", "METHOD_END"], "methodName": ["fixedDelayWithInitialDelayFirstExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  0  0  0  ;", "long   initialDelay    =     3  0  0  0  0  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period )  ;", "trigger . setInitialDelay ( initialDelay )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( now ,     5  0  0  ,     3  0  0  0  )  )  ;", ". assertApproximateDifference ( now ,    next ,     ( period    +     3  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedDelayWithInitialDelaySubsequentExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  ;", "long   initialDelay    =     3  0  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period ,    TimeUnit . SECONDS )  ;", "trigger . setInitialDelay ( initialDelay )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( null ,    null ,    null )  )  ;", ". assertApproximateDifference ( now ,    next ,     ( initialDelay    *     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedDelayWithTimeUnitAndInitialDelayFirstExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger (  5  ,    TimeUnit . SECONDS )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( null ,    null ,    null )  )  ;", ". assertNegligibleDifference ( now ,    next )  ;", "}", "METHOD_END"], "methodName": ["fixedDelayWithTimeUnitFirstExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period ,    TimeUnit . SECONDS )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( now ,     5  0  0  ,     3  0  0  0  )  )  ;", ". assertApproximateDifference ( now ,    next ,     (  ( period    *     1  0  0  0  )     +     3  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedDelayWithTimeUnitSubsequentExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger (  5  0  0  0  )  ;", "trigger . setFixedRate ( true )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( null ,    null ,    null )  )  ;", ". assertNegligibleDifference ( now ,    next )  ;", "}", "METHOD_END"], "methodName": ["fixedRateFirstExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  0  0  0  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period )  ;", "trigger . setFixedRate ( true )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( now ,     5  0  0  ,     3  0  0  0  )  )  ;", ". assertApproximateDifference ( now ,    next ,    period )  ;", "}", "METHOD_END"], "methodName": ["fixedRateSubsequentExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  0  0  0  ;", "long   initialDelay    =     3  0  0  0  0  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period )  ;", "trigger . setFixedRate ( true )  ;", "trigger . setInitialDelay ( initialDelay )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( null ,    null ,    null )  )  ;", ". assertApproximateDifference ( now ,    next ,    initialDelay )  ;", "}", "METHOD_END"], "methodName": ["fixedRateWithInitialDelayFirstExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  0  0  0  ;", "long   initialDelay    =     3  0  0  0  0  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period )  ;", "trigger . setFixedRate ( true )  ;", "trigger . setInitialDelay ( initialDelay )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( now ,     5  0  0  ,     3  0  0  0  )  )  ;", ". assertApproximateDifference ( now ,    next ,    period )  ;", "}", "METHOD_END"], "methodName": ["fixedRateWithInitialDelaySubsequentExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  ;", "long   initialDelay    =     3  0  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period ,    TimeUnit . MINUTES )  ;", "trigger . setFixedRate ( true )  ;", "trigger . setInitialDelay ( initialDelay )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( null ,    null ,    null )  )  ;", ". assertApproximateDifference ( now ,    next ,     (  ( initialDelay    *     6  0  )     *     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedRateWithTimeUnitAndInitialDelayFirstExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger (  5  ,    TimeUnit . SECONDS )  ;", "trigger . setFixedRate ( true )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( null ,    null ,    null )  )  ;", ". assertNegligibleDifference ( now ,    next )  ;", "}", "METHOD_END"], "methodName": ["fixedRateWithTimeUnitFirstExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "Date   now    =    new   Date (  )  ;", "long   period    =     5  ;", "PeriodicTrigger   trigger    =    new   PeriodicTrigger ( period ,    TimeUnit . HOURS )  ;", "trigger . setFixedRate ( true )  ;", "Date   next    =    trigger . nextExecutionTime (  . context ( now ,     5  0  0  ,     3  0  0  0  )  )  ;", ". assertApproximateDifference ( now ,    next ,     (  (  ( period    *     6  0  )     *     6  0  )     *     1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedRateWithTimeUnitSubsequentExecution"], "fileName": "org.springframework.scheduling.support.PeriodicTriggerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.scheduling.support.ScheduledMethodRunnable"}, {"methodBody": ["METHOD_START", "{", "return   this . target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.springframework.scheduling.support.ScheduledMethodRunnable"}, {"methodBody": ["METHOD_START", "{", "this . lastScheduledExecutionTime    =    lastScheduledExecutionTime ;", "this . lastActualExecutionTime    =    lastActualExecutionTime ;", "this . lastCompletionTime    =    lastCompletionTime ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.scheduling.support.SimpleTriggerContext"}, {"methodBody": ["METHOD_START", "{", "if    ( task   instanceof   DelegatingErrorHandlingRunnable )     {", "return    (  ( DelegatingErrorHandlingRunnable )     ( task )  )  ;", "}", "ErrorHandler   eh    =     ( errorHandler    !  =    null )     ?    errorHandler    :     . getDefaultErrorHandler ( isRepeatingTask )  ;", "return   new   DelegatingErrorHandlingRunnable ( task ,    eh )  ;", "}", "METHOD_END"], "methodName": ["decorateTaskWithErrorHandler"], "fileName": "org.springframework.scheduling.support.TaskUtils"}, {"methodBody": ["METHOD_START", "{", "return   isRepeatingTask    ?    TaskUtils . LOG _ AND _ SUPPRESS _ ERROR _ HANDLER    :    TaskUtils . LOG _ AND _ PROPAGATE _ ERROR _ HANDLER ;", "}", "METHOD_END"], "methodName": ["getDefaultErrorHandler"], "fileName": "org.springframework.scheduling.support.TaskUtils"}, {"methodBody": ["METHOD_START", "{", "String   message    =     (  ( String )     ( pjp . proceed (  )  )  )  ;", "return   new   StringBuffer ( message )  . reverse (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["scramble"], "fileName": "org.springframework.scripting.MessengerScrambler"}, {"methodBody": ["METHOD_START", "{", "return   this . scriptSource ;", "}", "METHOD_END"], "methodName": ["getScriptSource"], "fileName": "org.springframework.scripting.ScriptCompilationException"}, {"methodBody": ["METHOD_START", "{", "ScriptEvaluator   evaluator    =    new   BshScriptEvaluator (  )  ;", "Object   result    =    evaluator . evaluate ( new   ResourceScriptSource ( new   ClassPathResource (  \" simple . bsh \"  ,    getClass (  )  )  )  )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testBshScriptFromFile"], "fileName": "org.springframework.scripting.bsh.BshScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "ScriptEvaluator   evaluator    =    new   BshScriptEvaluator (  )  ;", "Object   result    =    evaluator . evaluate ( new   StaticScriptSource (  \" return    3     *     2  ;  \"  )  )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testBshScriptFromString"], "fileName": "org.springframework.scripting.bsh.BshScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "ScriptEvaluator   evaluator    =    new   BshScriptEvaluator (  )  ;", "Map < String ,    Object >    arguments    =    new   HashMap <  >  (  )  ;", "arguments . put (  \" a \"  ,     3  )  ;", "arguments . put (  \" b \"  ,     2  )  ;", "Object   result    =    evaluator . evaluate ( new   StaticScriptSource (  \" return   a    *    b ;  \"  )  ,    arguments )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptWithArguments"], "fileName": "org.springframework.scripting.bsh.BshScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bsh - with - xsd . xml \"  ,    getClass (  )  )  ;", "Messenger   eventListener    =     (  ( Messenger )     ( ctx . getBean (  \" eventListener \"  )  )  )  ;", "ctx . publishEvent ( new    . MyEvent ( ctx )  )  ;", "assertEquals (  \" count =  2  \"  ,    eventListener . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["applicationEventListener"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  \"  \"  ,    Messenger . class )  ;", "fail (  \" Must   have   thrown   exception   by   this   point .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["ctorWithEmptyScriptSourceLocator"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    ( null ,    Messenger . class )  ;", "fail (  \" Must   have   thrown   exception   by   this   point .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["ctorWithNullScriptSourceLocator"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  \"  \\ n          \"  ,    Messenger . class )  ;", "fail (  \" Must   have   thrown   exception   by   this   point .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["ctorWithWhitespacedScriptSourceLocator"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bsh - with - xsd . xml \"  ,    getClass (  )  )  ;", "Calculator   calculator    =     (  ( Calculator )     ( ctx . getBean (  \" calculator \"  )  )  )  ;", "assertNotNull ( calculator )  ;", "assertFalse (  ( calculator   instanceof   Refreshable )  )  ;", "}", "METHOD_END"], "methodName": ["inlineScriptFromTag"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bshRefreshableContext . xml \"  ,    getClass (  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "ConfigurableMessenger   messenger 2     =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "assertTrue (  \" Should   be   a   proxy   for   refreshable   s \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertTrue (  \" Should   be   an   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "messenger . setMessage (  \" Bye   World !  \"  )  ;", "messenger 2  . setMessage (  \" Byebye   World !  \"  )  ;", "assertEquals (  \" Bye   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "Refreshable   refreshable    =     (  ( Refreshable )     ( messenger )  )  ;", "refreshable . refresh (  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "assertEquals (  \" Incorrect   refresh   count \"  ,     2  ,    refreshable . getRefreshCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["nonStaticPrototypeScript"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bshRefreshableContext . xml \"  ,    getClass (  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "assertTrue (  \" Should   be   a   proxy   for   refreshable   s \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertTrue (  \" Should   be   an   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "Refreshable   refreshable    =     (  ( Refreshable )     ( messenger )  )  ;", "refreshable . refresh (  )  ;", "assertEquals (  \" Message   is   incorrect   after   refresh \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Incorrect   refresh   count \"  ,     2  ,    refreshable . getRefreshCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["nonStaticScript"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bsh - with - xsd . xml \"  ,    getClass (  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "ConfigurableMessenger   messenger 2     =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "assertNotSame ( messenger ,    messenger 2  )  ;", "assertSame ( messenger . getClass (  )  ,    messenger 2  . getClass (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "messenger . setMessage (  \" Bye   World !  \"  )  ;", "messenger 2  . setMessage (  \" Byebye   World !  \"  )  ;", "assertEquals (  \" Bye   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["prototypeScriptFromTag"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bsh - with - xsd . xml \"  ,    getClass (  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" refreshableMessenger \"  )  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertTrue (  \" Messenger   should   be   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "}", "METHOD_END"], "methodName": ["refreshableFromTag"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bsh - with - xsd . xml \"  ,    getClass (  )  )  ;", "Bean   testBean    =     (  ( Bean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "Collection < String >    beanNames    =    Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  ;", "assertTrue ( beanNames . contains (  \" messenger \"  )  )  ;", "assertTrue ( beanNames . contains (  \" messengerImpl \"  )  )  ;", "assertTrue ( beanNames . contains (  \" messengerInstance \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertFalse (  ( messenger   instanceof   Refreshable )  )  ;", "Messenger   messengerImpl    =     (  ( Messenger )     ( ctx . getBean (  \" messengerImpl \"  )  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messengerImpl . getMessage (  )  )  ;", "Messenger   messengerInstance    =     (  ( Messenger )     ( ctx . getBean (  \" messengerInstance \"  )  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messengerInstance . getMessage (  )  )  ;", "BeanAwareMessenger   messengerByType    =     (  ( BeanAwareMessenger )     ( ctx . getBean (  \" messengerByType \"  )  )  )  ;", "assertEquals ( testBean ,    messengerByType . getBean (  )  )  ;", "BeanAwareMessenger   messengerByName    =     (  ( BeanAwareMessenger )     ( ctx . getBean (  \" messengerByName \"  )  )  )  ;", "assertEquals ( testBean ,    messengerByName . getBean (  )  )  ;", "Collection < Messenger >    beans    =    ctx . getBeansOfType ( Messenger . class )  . values (  )  ;", "assertTrue ( beans . contains ( messenger )  )  ;", "assertTrue ( beans . contains ( messengerImpl )  )  ;", "assertTrue ( beans . contains ( messengerInstance )  )  ;", "assertTrue ( beans . contains ( messengerByType )  )  ;", "assertTrue ( beans . contains ( messengerByName )  )  ;", "ctx . close (  )  ;", "assertNull ( messenger . getMessage (  )  )  ;", "assertNull ( messengerImpl . getMessage (  )  )  ;", "assertNull ( messengerInstance . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["resourceScriptFromTag"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  \" org /  / scripting / bsh / bshBrokenContext . xml \"  )  ;", "fail (  \" Must   throw   exception   for   broken   script   file \"  )  ;", "}    catch    ( NestedRuntimeException   ex )     {", "assertTrue ( ex . contains ( ScriptCompilationException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["scriptCompilationException"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   script    =    mock ( ScriptSource . class )  ;", "final   String   badScript    =     \" String   getMessage (  )     {    throw   new   IllegalArgumentException (  )  ;     }  \"  ;", "given ( script . getScriptAsString (  )  )  . willReturn ( badScript )  ;", "given ( script . isModified (  )  )  . willReturn ( true )  ;", "factory    =    new    (  (  ( ScriptFactoryPostProcessor . INLINE _ SCRIPT _ PREFIX )     +    badScript )  ,    Messenger . class )  ;", "try    {", "Messenger   messenger    =     (  ( Messenger )     ( factory . getScriptedObject ( script ,    Messenger . class )  )  )  ;", "messenger . getMessage (  )  ;", "fail (  \" Must   have   thrown   a   BshScriptUtils . BshExecutionException .  \"  )  ;", "}    catch    ( BshScriptUtils . BshExecutionException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["scriptThatCompilesButIsJustPlainBad"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bshContext . xml \"  ,    getClass (  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "ConfigurableMessenger   messenger 2     =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" ed   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "assertNotSame ( messenger ,    messenger 2  )  ;", "assertSame ( messenger . getClass (  )  ,    messenger 2  . getClass (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "messenger . setMessage (  \" Bye   World !  \"  )  ;", "messenger 2  . setMessage (  \" Byebye   World !  \"  )  ;", "assertEquals (  \" Bye   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["staticPrototypeScript"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bshContext . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Calculator . class )  )  . contains (  \" calculator \"  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messenger \"  )  )  ;", "Calculator   calc    =     (  ( Calculator )     ( ctx . getBean (  \" calculator \"  )  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "assertFalse (  \" ed   object   should   not   be   instance   of   Refreshable \"  ,     ( calc   instanceof   Refreshable )  )  ;", "assertFalse (  \" ed   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "assertEquals ( calc ,    calc )  ;", "assertEquals ( messenger ,    messenger )  ;", "assertTrue (  (  !  ( messenger . equals ( calc )  )  )  )  ;", "assertTrue (  (  ( messenger . hashCode (  )  )     !  =     ( calc . hashCode (  )  )  )  )  ;", "assertTrue (  (  !  ( messenger . toString (  )  . equals ( calc . toString (  )  )  )  )  )  ;", "assertEquals (  5  ,    calc . add (  2  ,     3  )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Calculator . class )  . values (  )  . contains ( calc )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["staticScript"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bshContext . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerImpl \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messengerImpl \"  )  )  )  ;", "St   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "ctx . close (  )  ;", "assertNull ( messenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["staticScriptImplementingInterface"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bshContext . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerWithConfig \"  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerWithConfig \"  )  )  )  ;", "messenger . setMessage ( null )  ;", "assertNull ( messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["staticScriptWithNullReturnValue"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bshContext . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerWithConfigExtra \"  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerWithConfigExtra \"  )  )  )  ;", "messenger . setMessage ( null )  ;", "assertNull ( messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "ctx . close (  )  ;", "assertNull ( messenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["staticScriptWithTwoInterfacesSpecified"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" bshContext . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerInstance \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messengerInstance \"  )  )  )  ;", "St   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "ctx . close (  )  ;", "assertNull ( messenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["staticWithScriptReturningInstance"], "fileName": "org.springframework.scripting.bsh.BshScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   BshScriptUtils . createBshObject ( scriptSource ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["createBshObject"], "fileName": "org.springframework.scripting.bsh.BshScriptUtils"}, {"methodBody": ["METHOD_START", "{", "return   BshScriptUtils . createBshObject ( scriptSource ,    scriptInterfaces ,    ClassUtils . getDefaultClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBshObject"], "fileName": "org.springframework.scripting.bsh.BshScriptUtils"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    BshScriptUtils . evaluateBshScript ( scriptSource ,    scriptInterfaces ,    classLoader )  ;", "if    ( result   instanceof   Class )     {", "Class <  ?  >    clazz    =     (  ( Class <  ?  >  )     ( result )  )  ;", "try    {", "return   ReflectionUtils . accessibleConstructor ( clazz )  . newInstance (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  \" Could   not   instantiate   script   class :     \"     +     ( clazz . getName (  )  )  )  ,    ex )  ;", "}", "} else    {", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["createBshObject"], "fileName": "org.springframework.scripting.bsh.BshScriptUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( scriptSource ,     \" Script   source   must   not   be   empty \"  )  ;", "Interpreter   interpreter    =    new   Interpreter (  )  ;", "if    ( classLoader    !  =    null )     {", "interpreter . setClassLoader ( classLoader )  ;", "}", "Object   result    =    interpreter . eval ( scriptSource )  ;", "if    ( result   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( result )  )  ;", "} else", "if    ( result    !  =    null )     {", "return   result . getClass (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["determineBshObjectType"], "fileName": "org.springframework.scripting.bsh.BshScriptUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( scriptSource ,     \" Script   source   must   not   be   empty \"  )  ;", "Interpreter   interpreter    =    new   Interpreter (  )  ;", "interpreter . setClassLoader ( classLoader )  ;", "Object   result    =    interpreter . eval ( scriptSource )  ;", "if    ( result    !  =    null )     {", "return   result ;", "} else    {", "if    ( ObjectUtils . isEmpty ( scriptInterfaces )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Given   script   requires   a   script   proxy :     \"     +     \" At   least   one   script   interface   is   required .  \\ nScript :     \"  )     +    scriptSource )  )  ;", "}", "XThis   xt    =     (  ( XThis )     ( interpreter . eval (  \" return   this \"  )  )  )  ;", "return   Proxy . newProxyInstance ( classLoader ,    scriptInterfaces ,    new    . BshObjectInvocationHandler ( xt )  )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluateBshScript"], "fileName": "org.springframework.scripting.bsh.BshScriptUtils"}, {"methodBody": ["METHOD_START", "{", "registerBeanDefinitionParser ( key ,    new   ScriptBeanDefinitionParser ( scriptFactoryClassName )  )  ;", "}", "METHOD_END"], "methodName": ["registerScriptBeanDefinitionParser"], "fileName": "org.springframework.scripting.config.LangNamespaceHandler"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition ;", "if    ( registry . containsBeanDefinition (  . SCRIPT _ FACTORY _ POST _ PROCESSOR _ BEAN _ NAME )  )     {", "beanDefinition    =    registry . getBeanDefinition (  . SCRIPT _ FACTORY _ POST _ PROCESSOR _ BEAN _ NAME )  ;", "} else    {", "beanDefinition    =    new   RootBeanDefinition ( ScriptFactoryPostProcessor . class )  ;", "registry . registerBeanDefinition (  . SCRIPT _ FACTORY _ POST _ PROCESSOR _ BEAN _ NAME ,    beanDefinition )  ;", "}", "return   beanDefinition ;", "}", "METHOD_END"], "methodName": ["registerScriptFactoryPostProcessorIfNecessary"], "fileName": "org.springframework.scripting.config.LangNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "boolean   hasScriptSource    =    element . hasAttribute ( ScriptBeanDefinitionParser . SCRIPT _ SOURCE _ ATTRIBUTE )  ;", "List < Element >    elements    =    DomUtils . getChildElementsByTagName ( element ,    ScriptBeanDefinitionParser . INLINE _ SCRIPT _ ELEMENT )  ;", "if    ( hasScriptSource    &  &     (  !  ( elements . isEmpty (  )  )  )  )     {", "readerContext . error (  \" Only   one   of    ' script - source '    and    ' inline - script '    should   be   specified .  \"  ,    element )  ;", "return   null ;", "} else", "if    ( hasScriptSource )     {", "return   element . getAttribute ( ScriptBeanDefinitionParser . SCRIPT _ SOURCE _ ATTRIBUTE )  ;", "} else", "if    (  !  ( elements . isEmpty (  )  )  )     {", "Element   inlineElement    =    elements . get (  0  )  ;", "return    \" inline :  \"     +     ( DomUtils . getTextValue ( inlineElement )  )  ;", "} else    {", "readerContext . error (  \" Must   specify   either    ' script - source '    or    ' inline - script '  .  \"  ,    element )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["resolveScriptSource"], "fileName": "org.springframework.scripting.config.ScriptBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext ( ScriptingDefaultsTests . CONFIG )  ;", "ITestBean   testBean    =     (  ( ITestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", "ITestBean   otherBean    =     (  ( ITestBean )     ( context . getBean (  \" otherBean \"  )  )  )  ;", "assertEquals ( otherBean ,    testBean . getOtherBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultAutowire"], "fileName": "org.springframework.scripting.config.ScriptingDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext ( ScriptingDefaultsTests . CONFIG )  ;", "ITestBean   testBean    =     (  ( ITestBean )     ( context . getBean (  \" nonRefreshableTestBean \"  )  )  )  ;", "assertFalse ( testBean . isDestroyed (  )  )  ;", "context . close (  )  ;", "assertTrue ( testBean . isDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultDestroyMethod"], "fileName": "org.springframework.scripting.config.ScriptingDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext ( ScriptingDefaultsTests . CONFIG )  ;", "ITestBean   testBean    =     (  ( ITestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", "assertTrue ( testBean . isInitialized (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultInitMethod"], "fileName": "org.springframework.scripting.config.ScriptingDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext ( ScriptingDefaultsTests . PROXY _ CONFIG )  ;", "Object   testBean    =    context . getBean (  \" testBean \"  )  ;", "assertTrue ( AopUtils . isCglibProxy ( testBean )  )  ;", "}", "METHOD_END"], "methodName": ["defaultProxyTargetClass"], "fileName": "org.springframework.scripting.config.ScriptingDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext ( ScriptingDefaultsTests . CONFIG )  ;", "Advised   advised    =     (  ( Advised )     ( context . getBean (  \" testBean \"  )  )  )  ;", "AbstractRefreshableTargetSource   targetSource    =     (  ( AbstractRefreshableTargetSource )     ( advised . getTargetSource (  )  )  )  ;", "Field   field    =    AbstractRefreshableTargetSource . class . getDeclaredField (  \" refreshCheckDelay \"  )  ;", "field . setAccessible ( true )  ;", "long   delay    =     (  ( Long )     ( field . get ( targetSource )  )  )  . longValue (  )  ;", "assertEquals (  5  0  0  0 L ,    delay )  ;", "}", "METHOD_END"], "methodName": ["defaultRefreshCheckDelay"], "fileName": "org.springframework.scripting.config.ScriptingDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext ( ScriptingDefaultsTests . CONFIG )  ;", "ITestBean   testBean    =     (  ( ITestBean )     ( context . getBean (  \"  / url \"  )  )  )  ;", "assertTrue ( testBean . isInitialized (  )  )  ;", "}", "METHOD_END"], "methodName": ["nameAsAlias"], "fileName": "org.springframework.scripting.config.ScriptingDefaultsTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( context )     !  =    null )     {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.scripting.groovy.GroovyAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   GenericXmlApplicationContext ( getClass (  )  ,     (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - groovy - dynamic - context . xml \"  )  )  ;", "TestService   bean    =    context . getBean (  \" groovyBean \"  ,    TestService . class )  ;", "LogUserAdvice   logAdvice    =    context . getBean ( LogUserAdvice . class )  ;", "assertEquals (  0  ,    logAdvice . getCountThrows (  )  )  ;", "try    {", "bean . sayHello (  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertEquals (  \" GroovyServiceImpl \"  ,    ex . getMessage (  )  )  ;", "}", "assertEquals (  0  ,    logAdvice . getCountThrows (  )  )  ;", "assertEquals (  0  ,    logAdvice . getCountBefore (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGroovyBeanDynamic"], "fileName": "org.springframework.scripting.groovy.GroovyAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   GenericXmlApplicationContext ( getClass (  )  ,     (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - groovy - interface - context . xml \"  )  )  ;", "TestService   bean    =    context . getBean (  \" groovyBean \"  ,    TestService . class )  ;", "LogUserAdvice   logAdvice    =    context . getBean ( LogUserAdvice . class )  ;", "assertEquals (  0  ,    logAdvice . getCountThrows (  )  )  ;", "try    {", "bean . sayHello (  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertEquals (  \" GroovyServiceImpl \"  ,    ex . getMessage (  )  )  ;", "}", "assertEquals (  1  ,    logAdvice . getCountThrows (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGroovyBeanInterface"], "fileName": "org.springframework.scripting.groovy.GroovyAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   GenericXmlApplicationContext ( getClass (  )  ,     (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - groovy - proxy - target - class - context . xml \"  )  )  ;", "TestService   bean    =    context . getBean (  \" groovyBean \"  ,    TestService . class )  ;", "LogUserAdvice   logAdvice    =    context . getBean ( LogUserAdvice . class )  ;", "assertEquals (  0  ,    logAdvice . getCountThrows (  )  )  ;", "try    {", "bean . sayHello (  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( TestException   ex )     {", "assertEquals (  \" GroovyServiceImpl \"  ,    ex . getMessage (  )  )  ;", "}", "assertEquals (  1  ,    logAdvice . getCountBefore (  )  )  ;", "assertEquals (  1  ,    logAdvice . getCountThrows (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGroovyBeanProxyTargetClass"], "fileName": "org.springframework.scripting.groovy.GroovyAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   GenericXmlApplicationContext ( getClass (  )  ,     (  ( getClass (  )  . getSimpleName (  )  )     +     \"  - java - context . xml \"  )  )  ;", "TestService   bean    =    context . getBean (  \" javaBean \"  ,    TestService . class )  ;", "LogUserAdvice   logAdvice    =    context . getBean ( LogUserAdvice . class )  ;", "assertEquals (  0  ,    logAdvice . getCountThrows (  )  )  ;", "try    {", "bean . sayHello (  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertEquals (  \" TestServiceImpl \"  ,    ex . getMessage (  )  )  ;", "}", "assertEquals (  1  ,    logAdvice . getCountThrows (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJavaBean"], "fileName": "org.springframework.scripting.groovy.GroovyAspectIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "TestService   target    =     (  ( TestService )     ( scriptFactory . getScriptedObject ( new   ResourceScriptSource ( new   ClassPathResource (  \" GroovyServiceImpl . grv \"  ,    getClass (  )  )  )  )  )  )  ;", "AspectJExpressionPointcut   pointcut    =    new   AspectJExpressionPointcut (  )  ;", "pointcut . setExpression ( String . format (  \"  @ within (  % s . Log )  \"  ,    ClassUtils . getPackageName ( getClass (  )  )  )  )  ;", "testAdvice ( new   aop . support . DefaultPointcutAdvisor ( pointcut ,    logAdvice )  ,    logAdvice ,    target ,     \" GroovyServiceImpl \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["manualGroovyBeanWithDynamicPointcut"], "fileName": "org.springframework.scripting.groovy.GroovyAspectTests"}, {"methodBody": ["METHOD_START", "{", "TestService   target    =     (  ( TestService )     ( scriptFactory . getScriptedObject ( new   ResourceScriptSource ( new   ClassPathResource (  \" GroovyServiceImpl . grv \"  ,    getClass (  )  )  )  )  )  )  ;", "AspectJExpressionPointcut   pointcut    =    new   AspectJExpressionPointcut (  )  ;", "pointcut . setExpression ( String . format (  \"  @ within (  % s . Log )  \"  ,    ClassUtils . getPackageName ( getClass (  )  )  )  )  ;", "testAdvice ( new   aop . support . DefaultPointcutAdvisor ( pointcut ,    logAdvice )  ,    logAdvice ,    target ,     \" GroovyServiceImpl \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["manualGroovyBeanWithDynamicPointcutProxyTargetClass"], "fileName": "org.springframework.scripting.groovy.GroovyAspectTests"}, {"methodBody": ["METHOD_START", "{", "TestService   target    =     (  ( TestService )     ( scriptFactory . getScriptedObject ( new   ResourceScriptSource ( new   ClassPathResource (  \" GroovyServiceImpl . grv \"  ,    getClass (  )  )  )  )  )  )  ;", "AspectJExpressionPointcut   pointcut    =    new   AspectJExpressionPointcut (  )  ;", "pointcut . setExpression ( String . format (  \" execution (  *     % s . TestService +  .  *  (  .  .  )  )  \"  ,    ClassUtils . getPackageName ( getClass (  )  )  )  )  ;", "testAdvice ( new   aop . support . DefaultPointcutAdvisor ( pointcut ,    logAdvice )  ,    logAdvice ,    target ,     \" GroovyServiceImpl \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["manualGroovyBeanWithStaticPointcut"], "fileName": "org.springframework.scripting.groovy.GroovyAspectTests"}, {"methodBody": ["METHOD_START", "{", "TestService   target    =     (  ( TestService )     ( scriptFactory . getScriptedObject ( new   ResourceScriptSource ( new   ClassPathResource (  \" GroovyServiceImpl . grv \"  ,    getClass (  )  )  )  )  )  )  ;", "testAdvice ( new   DefaultPointcutAdvisor ( logAdvice )  ,    logAdvice ,    target ,     \" GroovyServiceImpl \"  )  ;", "}", "METHOD_END"], "methodName": ["manualGroovyBeanWithUnconditionalPointcut"], "fileName": "org.springframework.scripting.groovy.GroovyAspectTests"}, {"methodBody": ["METHOD_START", "{", "testAdvice ( advisor ,    logAdvice ,    target ,    message ,    false )  ;", "}", "METHOD_END"], "methodName": ["testAdvice"], "fileName": "org.springframework.scripting.groovy.GroovyAspectTests"}, {"methodBody": ["METHOD_START", "{", "logAdvice . reset (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( target )  ;", "factory . setProxyTargetClass ( proxyTargetClass )  ;", "factory . addAdvisor ( advisor )  ;", "Service   bean    =     (  ( Service )     ( factory . getProxy (  )  )  )  ;", "assertEquals (  0  ,    logAdvice . getCountThrows (  )  )  ;", "try    {", "bean . sayHello (  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( Exception   ex )     {", "assertEquals ( message ,    ex . getMessage (  )  )  ;", "}", "assertEquals (  1  ,    logAdvice . getCountThrows (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAdvice"], "fileName": "org.springframework.scripting.groovy.GroovyAspectTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "er   gcl    =    new   er (  )  ;", "Class <  ?  >    class 1     =    gcl . parseClass (  \" class   TestBean    {    def   myMethod (  )     {     \\  \" foo \\  \"     }     }  \"  )  ;", "Class <  ?  >    class 2     =    gcl . parseClass (  \" class   TestBean    {    def   myMethod (  )     {     \\  \" bar \\  \"     }     }  \"  )  ;", "context . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( class 1  )  )  ;", "Object   testBean 1     =    context . getBean (  \" testBean \"  )  ;", "Method   method 1     =    class 1  . getDeclaredMethod (  \" myMethod \"  ,    new   Class <  ?  >  [  0  ]  )  ;", "Object   result 1     =    ReflectionUtils . invokeMethod ( method 1  ,    testBean 1  )  ;", "assertEquals (  \" foo \"  ,    result 1  )  ;", "context . removeBeanDefinition (  \" testBean \"  )  ;", "context . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( class 2  )  )  ;", "Object   testBean 2     =    context . getBean (  \" testBean \"  )  ;", "Method   method 2     =    class 2  . getDeclaredMethod (  \" myMethod \"  ,    new   Class <  ?  >  [  0  ]  )  ;", "Object   result 2     =    ReflectionUtils . invokeMethod ( method 2  ,    testBean 2  )  ;", "assertEquals (  \" bar \"  ,    result 2  )  ;", "}", "METHOD_END"], "methodName": ["classLoading"], "fileName": "org.springframework.scripting.groovy.GroovyClassLoadingTests"}, {"methodBody": ["METHOD_START", "{", "return   this . compilerConfiguration ;", "}", "METHOD_END"], "methodName": ["getCompilerConfiguration"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluator"}, {"methodBody": ["METHOD_START", "{", "this . compilerConfiguration . addCompilationCustomizers ( compilationCustomizers )  ;", "}", "METHOD_END"], "methodName": ["setCompilationCustomizers"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluator"}, {"methodBody": ["METHOD_START", "{", "this . compilerConfiguration    =     ( compilerConfiguration    !  =    null )     ?    compilerConfiguration    :    new   CompilerConfiguration (  )  ;", "}", "METHOD_END"], "methodName": ["setCompilerConfiguration"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluator"}, {"methodBody": ["METHOD_START", "{", "ScriptEvaluator   evaluator    =    new   GroovyScriptEvaluator (  )  ;", "Object   result    =    evaluator . evaluate ( new   ResourceScriptSource ( new   ClassPathResource (  \" simple . groovy \"  ,    getClass (  )  )  )  )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptFromFile"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "ScriptEvaluator   evaluator    =    new   StandardScriptEvaluator (  )  ;", "Object   result    =    evaluator . evaluate ( new   ResourceScriptSource ( new   ClassPathResource (  \" simple . groovy \"  ,    getClass (  )  )  )  )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptFromFileUsingJsr223"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "ScriptEvaluator   evaluator    =    new   GroovyScriptEvaluator (  )  ;", "Object   result    =    evaluator . evaluate ( new   StaticScriptSource (  \" return    3     *     2  \"  )  )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptFromString"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "StandardScriptEvaluator   evaluator    =    new   StandardScriptEvaluator (  )  ;", "evaluator . setLanguage (  \" Groovy \"  )  ;", "Object   result    =    evaluator . evaluate ( new   StaticScriptSource (  \" return    3     *     2  \"  )  )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptFromStringUsingJsr223"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "ScriptEvaluator   evaluator    =    new   GroovyScriptEvaluator (  )  ;", "Map < String ,    Object >    arguments    =    new   HashMap <  >  (  )  ;", "arguments . put (  \" a \"  ,     3  )  ;", "arguments . put (  \" b \"  ,     2  )  ;", "Object   result    =    evaluator . evaluate ( new   StaticScriptSource (  \" return   a    *    b \"  )  ,    arguments )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptWithArguments"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "StandardScriptEvaluator   evaluator    =    new   StandardScriptEvaluator (  )  ;", "evaluator . setLanguage (  \" Groovy \"  )  ;", "Map < String ,    Object >    arguments    =    new   HashMap <  >  (  )  ;", "arguments . put (  \" a \"  ,     3  )  ;", "arguments . put (  \" b \"  ,     2  )  ;", "Object   result    =    evaluator . evaluate ( new   StaticScriptSource (  \" return   a    *    b \"  )  ,    arguments )  ;", "assertEquals (  6  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptWithArgumentsUsingJsr223"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "GroovyScriptEvaluator   evaluator    =    new   GroovyScriptEvaluator (  )  ;", "MyBytecodeProcessor   processor    =    new   MyBytecodeProcessor (  )  ;", "evaluator . getCompilerConfiguration (  )  . setBytecodePostprocessor ( processor )  ;", "Object   result    =    evaluator . evaluate ( new   StaticScriptSource (  \" return    3     *     2  \"  )  )  ;", "assertEquals (  6  ,    result )  ;", "assertTrue ( processor . processed . contains (  \" Script 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptWithCompilerConfiguration"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "GroovyScriptEvaluator   evaluator    =    new   GroovyScriptEvaluator (  )  ;", "ImportCustomizer   importCustomizer    =    new   ImportCustomizer (  )  ;", "importCustomizer . addStarImports (  \" util \"  )  ;", "evaluator . setCompilationCustomizers ( importCustomizer )  ;", "Object   result    =    evaluator . evaluate ( new   StaticScriptSource (  \" return   ResourceUtils . CLASSPATH _ URL _ PREFIX \"  )  )  ;", "assertEquals (  \" classpath :  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testGroovyScriptWithImportCustomizer"], "fileName": "org.springframework.scripting.groovy.GroovyScriptEvaluatorTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this . compilerConfiguration )     !  =    null    ?    new   GroovyClassLoader ( classLoader ,    this . compilerConfiguration )     :    new   GroovyClassLoader ( classLoader )  ;", "}", "METHOD_END"], "methodName": ["buildGroovyClassLoader"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "GroovyObject   goo    =     (  ( GroovyObject )     ( ReflectionUtils . accessibleConstructor ( scriptClass )  . newInstance (  )  )  )  ;", "if    (  ( thisObjectCustomizer )     !  =    null )     {", "thisObjectCustomizer . customize ( goo )  ;", "}", "if    ( goo   instanceof   Script )     {", "return    (  ( Script )     ( goo )  )  . run (  )  ;", "} else    {", "return   goo ;", "}", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   ScriptCompilationException (  (  \" No   default   constructor   on   Groovy   script   class :     \"     +     ( scriptClass . getName (  )  )  )  ,    ex )  ;", "}    catch    ( InstantiationException   ex )     {", "throw   new   ScriptCompilationException ( scriptSource ,     (  \" Unable   to   instantiate   Groovy   script   class :     \"     +     ( scriptClass . getName (  )  )  )  ,    ex )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   ScriptCompilationException ( scriptSource ,     (  \" Could   not   access   Groovy   script   constructor :     \"     +     ( scriptClass . getName (  )  )  )  ,    ex )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   ScriptCompilationException (  (  \" Failed   to   invoke   Groovy   script   constructor :     \"     +     ( scriptClass . getName (  )  )  )  ,    ex . getTargetException (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["executeScript"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . scriptClassMonitor )     {", "if    (  ( this . groovyClassLoader )     =  =    null )     {", "this . groovyClassLoader    =    buildGroovyClassLoader ( ClassUtils . getDefaultClassLoader (  )  )  ;", "}", "return   this . groovyClassLoader ;", "}", "}", "METHOD_END"], "methodName": ["getGroovyClassLoader"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactory"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd . xml \"  ,    getClass (  )  )  ;", "Map <  ?  ,    Messenger >    beans    =    ctx . getBeansOfType ( Messenger . class )  ;", "assertEquals (  4  ,    beans . size (  )  )  ;", "assertTrue ( ctx . getBean ( MyBytecodeProcessor . class )  . processed . contains (  \" Messenger 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnonymousScriptDetected"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - multiple - properties . xml \"  ,    getClass (  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( ctx . getBean (  \" testBean \"  )  )  )  ;", "ContextScriptBean   bean    =     (  ( ContextScriptBean )     ( ctx . getBean (  \" bean \"  )  )  )  ;", "assertEquals (  \" The   first   property   ain ' t   bein '    injected .  \"  ,     \" Sophie   Marceau \"  ,    bean . getName (  )  )  ;", "assertEquals (  \" The   second   property   ain ' t   bein '    injected .  \"  ,     3  1  ,    bean . getAge (  )  )  ;", "assertEquals ( tb ,    bean . getTestBean (  )  )  ;", "assertEquals ( ctx ,    bean . getApplicationContext (  )  )  ;", "ContextScriptBean   bean 2     =     (  ( ContextScriptBean )     ( ctx . getBean (  \" bean 2  \"  )  )  )  ;", "assertEquals ( tb ,    bean 2  . getTestBean (  )  )  ;", "assertEquals ( ctx ,    bean 2  . getApplicationContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanPassInMoreThanOneProperty"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  \"  \"  )  ;", "fail (  \" Must   have   thrown   exception   by   this   point .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testCtorWithEmptyScriptSourceLocator"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    ( null )  ;", "fail (  \" Must   have   thrown   exception   by   this   point .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testCtorWithNullScriptSourceLocator"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  \"  \\ n          \"  )  ;", "fail (  \" Must   have   thrown   exception   by   this   point .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testCtorWithWhitespacedScriptSourceLocator"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" groovyContext . xml \"  ,    getClass (  )  )  ;", "Object   factory    =    context . getBean (  \"  & factory \"  )  ;", "assertTrue (  ( factory   instanceof   Bean )  )  ;", "Object   result    =    context . getBean (  \" factory \"  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBean"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "GroovyScriptFactory   factory    =    new   GroovyScriptFactory (  \" a   script   source   locator    ( doesn ' t   matter   here )  \"  )  ;", "try    {", "factory . getScriptedObject ( null )  ;", "fail (  \" Must   have   thrown   a   NullPointerException   as   per   contract    (  ' null '    ScriptSource   supplied \"  )  ;", "}    catch    ( NullPointerException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testGetScriptedObjectDoesChokeOnNullScriptSourceBeingPassedIn"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   script    =    mock ( ScriptSource . class )  ;", "given ( script . getScriptAsString (  )  )  . willReturn (  \" class   Bar    {  }  \"  )  ;", "given ( script . suggestedClassName (  )  )  . willReturn (  \" someName \"  )  ;", "factory    =    new    (  \" a   script   source   locator    ( doesn ' t   matter   here )  \"  )  ;", "Object   scriptedObject    =    factory . getScriptedObject ( script )  ;", "assertNotNull ( scriptedObject )  ;", "}", "METHOD_END"], "methodName": ["testGetScriptedObjectDoesNotChokeOnNullInterfacesBeingPassedIn"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd - jsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" inlineMessenger \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" inlineMessenger \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testInlineJsr223FromTag"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd - jsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" inlineMessengerWithInterface \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" inlineMessengerWithInterface \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testInlineJsr223FromTagWithInterface"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd . xml \"  ,    getClass (  )  )  ;", "BeanDefinition   bd    =    ctx . getBean (  )  . getBeanDefinition (  \" calculator \"  )  ;", "assertTrue ( ObjectUtils . containsElement ( bd . getDependsOn (  )  ,     \" messenger \"  )  )  ;", "Calculator   calculator    =     (  ( Calculator )     ( ctx . getBean (  \" calculator \"  )  )  )  ;", "assertNotNull ( calculator )  ;", "assertFalse (  ( calculator   instanceof   Refreshable )  )  ;", "}", "METHOD_END"], "methodName": ["testInlineScriptFromTag"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd - jsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messenger \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( messenger )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJsr223FromTag"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd - jsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerWithInterface \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messengerWithInterface \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testJsr223FromTagWithInterface"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext ( xmlFile )  ;", "Calculator   calc    =     (  ( Calculator )     ( ctx . getBean (  \" delegaCalculator \"  )  )  )  ;", "calc . add (  1  ,     2  )  ;", "fail (  \" expected   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" Gotcha \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMetaClass"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "testMetaClass (  \" org / springframework / scripting / groovy / calculators . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMetaClassWithBeans"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "testMetaClass (  \" org / springframework / scripting / groovy / calculators - with - xsd . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testMetaClassWithXsd"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyRefreshableContext . xml \"  ,    getClass (  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "ConfigurableMessenger   messenger 2     =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "assertTrue (  \" Should   be   a   proxy   for   refreshable   scripts \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertTrue (  \" Should   be   an   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "messenger . setMessage (  \" Bye   World !  \"  )  ;", "messenger 2  . setMessage (  \" Byebye   World !  \"  )  ;", "assertEquals (  \" Bye   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "Refreshable   refreshable    =     (  ( Refreshable )     ( messenger )  )  ;", "refreshable . refresh (  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "assertEquals (  \" Incorrect   refresh   count \"  ,     2  ,    refreshable . getRefreshCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonStaticPrototypeScript"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyRefreshableContext . xml \"  ,    getClass (  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "assertTrue (  \" Should   be   a   proxy   for   refreshable   scripts \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertTrue (  \" Should   be   an   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "Refreshable   refreshable    =     (  ( Refreshable )     ( messenger )  )  ;", "refreshable . refresh (  )  ;", "assertEquals (  \" Message   is   incorrect   after   refresh .  \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Incorrect   refresh   count \"  ,     2  ,    refreshable . getRefreshCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonStaticScript"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd . xml \"  ,    getClass (  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "ConfigurableMessenger   messenger 2     =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "assertNotSame ( messenger ,    messenger 2  )  ;", "assertSame ( messenger . getClass (  )  ,    messenger 2  . getClass (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "messenger . setMessage (  \" Bye   World !  \"  )  ;", "messenger 2  . setMessage (  \" Byebye   World !  \"  )  ;", "assertEquals (  \" Bye   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeScriptFromTag"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  \"  - with - xsd - proxy - target - class . xml \"  ,    getClass (  )  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" Cannot   use   proxyTargetClass = true \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testProxyTargetClassNotAllowedIfNotGroovy"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" groovyContext . xml \"  ,    getClass (  )  )  ;", "Object   factory    =    context . getBean (  \"  & refreshable \"  )  ;", "assertTrue (  ( factory   instanceof   Bean )  )  ;", "Object   result    =    context . getBean (  \" refreshable \"  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testRefreshableFactoryBean"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" refreshableMessenger \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" refreshableMessenger \"  )  )  )  ;", "CallCounter   countingAspect    =     (  ( CallCounter )     ( ctx . getBean (  \" getMessageAspect \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( messenger )  )  ;", "assertTrue (  ( messenger   instanceof   Refreshable )  )  ;", "assertEquals (  0  ,    countingAspect . getCalls (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  1  ,    countingAspect . getCalls (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshableFromTag"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd - proxy - target - class . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" refreshableMessenger \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" refreshableMessenger \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( messenger )  )  ;", "assertTrue (  ( messenger   instanceof   Refreshable )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( ConcreteMessenger . class )  . values (  )  . contains ( messenger )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( messenger . getClass (  )  ,    Component . class )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshableFromTagProxyTargetClass"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd - jsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" refreshableMessenger \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" refreshableMessenger \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( messenger )  )  ;", "assertTrue (  ( messenger   instanceof   Refreshable )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshableJsr223FromTag"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovy - with - xsd . xml \"  ,    getClass (  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "CallCounter   countingAspect    =     (  ( CallCounter )     ( ctx . getBean (  \" getMessageAspect \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  ( messenger   instanceof   Refreshable )  )  ;", "assertEquals (  0  ,    countingAspect . getCalls (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  1  ,    countingAspect . getCalls (  )  )  ;", "ctx . close (  )  ;", "assertEquals (  (  -  2  0  0  )  ,    countingAspect . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceScriptFromTag"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  \" org /  / scripting / groovy / groovyBrokenContext . xml \"  )  ;", "fail (  \" Should   throw   exception   for   broken   script   file \"  )  ;", "}    catch    ( NestedRuntimeException   ex )     {", "assertTrue (  (  \" Wrong   root   cause :     \"     +    ex )  ,    ex . contains ( ScriptCompilationException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testScriptCompilationException"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   script    =    mock ( ScriptSource . class )  ;", "String   badScript    =     \" class   Foo    {    public   Foo ( String   foo )     {  }  }  \"  ;", "given ( script . getScriptAsString (  )  )  . willReturn ( badScript )  ;", "given ( script . suggestedClassName (  )  )  . willReturn (  \" someName \"  )  ;", "factory    =    new    (  (  ( ScriptFactoryPostProcessor . INLINE _ SCRIPT _ PREFIX )     +    badScript )  )  ;", "try    {", "factory . getScriptedObject ( script )  ;", "fail (  \" Must   have   thrown   a   ScriptCompilationException    ( no   public   no - arg   ctor   in   scripted   class )  .  \"  )  ;", "}    catch    ( ScriptCompilationException   expected )     {", "assertTrue ( expected . contains ( NoSuchMethodException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testScriptedClassThatDoesNotHaveANoArgCtor"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   script    =    mock ( ScriptSource . class )  ;", "String   badScript    =     \" class   Foo    {    protected   Foo (  )     {  }     \\ n   String   toString (  )     {     \\  ' X \\  '     }  }  \"  ;", "given ( script . getScriptAsString (  )  )  . willReturn ( badScript )  ;", "given ( script . suggestedClassName (  )  )  . willReturn (  \" someName \"  )  ;", "factory    =    new    (  (  ( ScriptFactoryPostProcessor . INLINE _ SCRIPT _ PREFIX )     +    badScript )  )  ;", "assertEquals (  \" X \"  ,    factory . getScriptedObject ( script )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScriptedClassThatHasNoPublicNoArgCtor"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyContext . xml \"  ,    getClass (  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "ConfigurableMessenger   messenger 2     =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "assertNotSame ( messenger ,    messenger 2  )  ;", "assertSame ( messenger . getClass (  )  ,    messenger 2  . getClass (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "messenger . setMessage (  \" Bye   World !  \"  )  ;", "messenger 2  . setMessage (  \" Byebye   World !  \"  )  ;", "assertEquals (  \" Bye   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticPrototypeScript"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyContextWithJsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "ConfigurableMessenger   messenger    =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "ConfigurableMessenger   messenger 2     =     (  ( ConfigurableMessenger )     ( ctx . getBean (  \" messengerPrototype \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "assertNotSame ( messenger ,    messenger 2  )  ;", "assertSame ( messenger . getClass (  )  ,    messenger 2  . getClass (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "messenger . setMessage (  \" Bye   World !  \"  )  ;", "messenger 2  . setMessage (  \" Byebye   World !  \"  )  ;", "assertEquals (  \" Bye   World !  \"  ,    messenger . getMessage (  )  )  ;", "assertEquals (  \" Byebye   World !  \"  ,    messenger 2  . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticPrototypeScriptUsingJsr223"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyContext . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Calculator . class )  )  . contains (  \" calculator \"  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messenger \"  )  )  ;", "Calculator   calc    =     (  ( Calculator )     ( ctx . getBean (  \" calculator \"  )  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( calc )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( calc   instanceof   Refreshable )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "assertEquals ( calc ,    calc )  ;", "assertEquals ( messenger ,    messenger )  ;", "assertTrue (  (  !  ( messenger . equals ( calc )  )  )  )  ;", "assertTrue (  (  ( messenger . hashCode (  )  )     !  =     ( calc . hashCode (  )  )  )  )  ;", "assertTrue (  (  !  ( messenger . toString (  )  . equals ( calc . toString (  )  )  )  )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Calculator . class )  . values (  )  . contains ( calc )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticScript"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyContextWithJsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Calculator . class )  )  . contains (  \" calculator \"  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messenger \"  )  )  ;", "Calculator   calc    =     (  ( Calculator )     ( ctx . getBean (  \" calculator \"  )  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( calc )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( calc   instanceof   Refreshable )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "assertEquals ( calc ,    calc )  ;", "assertEquals ( messenger ,    messenger )  ;", "assertTrue (  (  !  ( messenger . equals ( calc )  )  )  )  ;", "assertTrue (  (  ( messenger . hashCode (  )  )     !  =     ( calc . hashCode (  )  )  )  )  ;", "assertTrue (  (  !  ( messenger . toString (  )  . equals ( calc . toString (  )  )  )  )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Calculator . class )  . values (  )  . contains ( calc )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticScriptUsingJsr223"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyContext . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerInstanceInline \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messengerInstanceInline \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticScriptWithInlineDefinedInstance"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyContextWithJsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerInstanceInline \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messengerInstanceInline \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticScriptWithInlineDefinedInstanceUsingJsr223"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyContext . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerInstance \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messengerInstance \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticScriptWithInstance"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" groovyContextWithJsr 2  2  3  . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNamesForType ( Messenger . class )  )  . contains (  \" messengerInstance \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messengerInstance \"  )  )  )  ;", "assertFalse (  \" Shouldn ' t   get   proxy   when   refresh   is   disabled \"  ,    AopUtils . isAopProxy ( messenger )  )  ;", "assertFalse (  \" Scripted   object   should   not   be   instance   of   Refreshable \"  ,     ( messenger   instanceof   Refreshable )  )  ;", "String   desiredMessage    =     \" Hello   World !  \"  ;", "assertEquals (  \" Message   is   incorrect \"  ,    desiredMessage ,    messenger . getMessage (  )  )  ;", "assertTrue ( ctx . getBeansOfType ( Messenger . class )  . values (  )  . contains ( messenger )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticScriptWithInstanceUsingJsr223"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   ClassPathXmlApplicationContext (  \" lwspBadContext . xml \"  ,    getClass (  )  )  ;", "fail (  \" Must   have   thrown   a   BeanCreationException    (  ' inline :  '    prefix   was   preceded   by   whitespace \"  )  ;", "}    catch    ( BeanCreationException   expected )     {", "assertTrue ( expected . contains ( FileNotFoundException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithInlineScriptWithLeadingWhitespace"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" twoClassesCorrectOneFirst . xml \"  ,    getClass (  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messenger \"  )  )  )  ;", "assertNotNull ( messenger )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "Object   goo    =     (  ( Object )     ( messenger )  )  ;", "assertNotNull ( goo )  ;", "}", "METHOD_END"], "methodName": ["testWithTwoClassesDefinedInTheOneGroovyFile_CorrectClassFirst"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" twoClassesWrongOneFirst . xml \"  ,    getClass (  )  )  ;", "ctx . getBean (  \" messenger \"  ,    Messenger . class )  ;", "fail (  \" Must   have   failed :    two   classes   defined   in      source ,    non - Messenger   class   defined   first .  \"  )  ;", "}    catch    ( Exception   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testWithTwoClassesDefinedInTheOneGroovyFile_WrongClassFirst"], "fileName": "org.springframework.scripting.groovy.GroovyScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "( countThrows )  +  +  ;", "throw   e ;", "}", "METHOD_END"], "methodName": ["afterThrowing"], "fileName": "org.springframework.scripting.groovy.LogUserAdvice"}, {"methodBody": ["METHOD_START", "{", "return   countBefore ;", "}", "METHOD_END"], "methodName": ["getCountBefore"], "fileName": "org.springframework.scripting.groovy.LogUserAdvice"}, {"methodBody": ["METHOD_START", "{", "return   countThrows ;", "}", "METHOD_END"], "methodName": ["getCountThrows"], "fileName": "org.springframework.scripting.groovy.LogUserAdvice"}, {"methodBody": ["METHOD_START", "{", "countThrows    =     0  ;", "countBefore    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.scripting.groovy.LogUserAdvice"}, {"methodBody": ["METHOD_START", "{", "new   RefreshableScriptTargetSource ( mock ( BeanFactory . class )  ,     \" a . bean \"  ,    null ,    null ,    false )  ;", "}", "METHOD_END"], "methodName": ["createWithNullScriptSource"], "fileName": "org.springframework.scripting.support.RefreshableScriptTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "return   this . resource . getResource (  )  ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.scripting.support.ResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   get (  )  . lastModified (  )  ;", "}    catch    ( IOException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  ( get (  )  )     +     \"    could   not   be   resolved   in   the   file   system    -     \"  )     +     \" current   timestamp   not   available   for   script   modification   check \"  )  ,    ex )  ;", "}", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["retrieveLastModifiedTime"], "fileName": "org.springframework.scripting.support.ResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "this . resource    =    new   EncodedResource ( this . resource . getResource (  )  ,    encoding )  ;", "}", "METHOD_END"], "methodName": ["setEncoding"], "fileName": "org.springframework.scripting.support.ResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    mock ( Resource . class )  ;", "scriptSource    =    new    ( resource )  ;", "assertTrue ( scriptSource . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["beginsInModifiedState"], "fileName": "org.springframework.scripting.support.ResourceScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    mock ( Resource . class )  ;", "given ( resource . lastModified (  )  )  . willThrow ( new   IOException (  )  )  ;", "scriptSource    =    new    ( resource )  ;", "long   lastModified    =    scriptSource . retrieveLastModifiedTime (  )  ;", "assertEquals (  0  ,    lastModified )  ;", "}", "METHOD_END"], "methodName": ["doesNotPropagateFatalExceptionOnResourceThatCannotBeResolvedToAFile"], "fileName": "org.springframework.scripting.support.ResourceScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ByteArrayResource ( new   byte [  0  ]  )  ;", "scriptSource    =    new    ( resource )  ;", "assertTrue (  \"    must   start   off   in   the    ' isModified '    state    ( it   obviously   isn ' t )  .  \"  ,    scriptSource . isModified (  )  )  ;", "scriptSource . getScriptAsString (  )  ;", "assertFalse (  \"    must   not   report   back   as   being   modified   if   the   underlying   File   resource   is   not   reporting   a   changed   lastModified   time .  \"  ,    scriptSource . isModified (  )  )  ;", "assertFalse (  \"    must   not   report   back   as   being   modified   if   the   underlying   File   resource   is   not   reporting   a   changed   lastModified   time .  \"  ,    scriptSource . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["lastModifiedWorksWithResourceThatDoesNotSupportFileBasedAccessAtAll"], "fileName": "org.springframework.scripting.support.ResourceScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    mock ( Resource . class )  ;", "given ( resource . lastModified (  )  )  . willReturn (  1  0  0 L ,     1  0  0 L ,     2  0  0 L )  ;", "given ( resource . getInputStream (  )  )  . willReturn ( StreamUtils . emptyInput (  )  )  ;", "scriptSource    =    new    ( resource )  ;", "assertTrue (  \"    must   start   off   in   the    ' isModified '    state    ( it   obviously   isn ' t )  .  \"  ,    scriptSource . isModified (  )  )  ;", "scriptSource . getScriptAsString (  )  ;", "assertFalse (  \"    must   not   report   back   as   being   modified   if   the   underlying   File   resource   is   not   reporting   a   changed   lastModified   time .  \"  ,    scriptSource . isModified (  )  )  ;", "assertTrue (  \"    must   report   back   as   being   modified   if   the   underlying   File   resource   is   reporting   a   changed   lastModified   time .  \"  ,    scriptSource . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["lastModifiedWorksWithResourceThatDoesNotSupportFileBasedReading"], "fileName": "org.springframework.scripting.support.ResourceScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "if    ( scriptSourceLocator . startsWith ( ScriptFactoryPostProcessor . INLINE _ SCRIPT _ PREFIX )  )     {", "return   new   StaticScriptSource ( scriptSourceLocator . substring ( ScriptFactoryPostProcessor . INLINE _ SCRIPT _ PREFIX . length (  )  )  ,    beanName )  ;", "} else    {", "return   new   ResourceScriptSource ( resourceLoader . getResource ( scriptSourceLocator )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convertToScriptSource"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . createCompositeInterface ( interfaces ,    this . beanClassLoader )  ;", "}", "METHOD_END"], "methodName": ["createCompositeInterface"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "InterfaceMaker   maker    =    new   InterfaceMaker (  )  ;", "PropertyValue [  ]    pvs    =    bd . gepertyValues (  )  . gepertyValues (  )  ;", "for    ( PropertyValue   pv    :    pvs )     {", "String   propertyName    =    pv . getName (  )  ;", "Class <  ?  >    propertyType    =    BeanUtils . findPropertyType ( propertyName ,    interfaces )  ;", "String   setterName    =     \" set \"     +     ( StringUtils . capitalize ( propertyName )  )  ;", "Signature   signature    =    new   Signature ( setterName ,    Type . VOID _ TYPE ,    new   Type [  ]  {    Type . getType ( propertyType )     }  )  ;", "maker . add ( signature ,    new   Type [  0  ]  )  ;", "}", "if    ( bd   instanceof   AbstractBeanDefinition )     {", "AbstractBeanDefinition   abd    =     (  ( AbstractBeanDefinition )     ( bd )  )  ;", "if    (  ( abd . getInitMethodName (  )  )     !  =    null )     {", "Signature   signature    =    new   Signature ( abd . getInitMethodName (  )  ,    Type . VOID _ TYPE ,    new   Type [  0  ]  )  ;", "maker . add ( signature ,    new   Type [  0  ]  )  ;", "}", "if    ( StringUtils . hasText ( abd . getDestroyMethodName (  )  )  )     {", "Signature   signature    =    new   Signature ( abd . getDestroyMethodName (  )  ,    Type . VOID _ TYPE ,    new   Type [  0  ]  )  ;", "maker . add ( signature ,    new   Type [  0  ]  )  ;", "}", "}", "return   maker . create (  )  ;", "}", "METHOD_END"], "methodName": ["createConfigInterface"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTargetSource ( ts )  ;", "ClassLoader   classLoader    =    this . beanClassLoader ;", "if    ( interfaces    !  =    null )     {", "proxyFactory . setInterfaces ( interfaces )  ;", "} else    {", "Class <  ?  >    targetClass    =    ts . getTargetClass (  )  ;", "if    ( targetClass    !  =    null )     {", "proxyFactory . setInterfaces ( ClassUtils . getAllInterfacesForClass ( targetClass ,    this . beanClassLoader )  )  ;", "}", "}", "if    ( proxyTargetClass )     {", "classLoader    =    null ;", "proxyFactory . setProxyTargetClass ( true )  ;", "}", "DelegatingIntroductionInterceptor   introduction    =    new   DelegatingIntroductionInterceptor ( ts )  ;", "introduction . suppressInterface ( TargetSource . class )  ;", "proxyFactory . addAdvice ( introduction )  ;", "return   proxyFactory . getProxy ( classLoader )  ;", "}", "METHOD_END"], "methodName": ["createRefreshableProxy"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "GenericBeanDefinition   scriptBd    =    new   GenericBeanDefinition (  )  ;", "scriptBd . setBeanClassName ( bd . getBeanClassName (  )  )  ;", "scriptBd . getConstructorArgumentValues (  )  . addArgumentValues ( bd . getConstructorArgumentValues (  )  )  ;", "return   scriptBd ;", "}", "METHOD_END"], "methodName": ["createScriptFactoryBeanDefinition"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "GenericBeanDefinition   objectBd    =    new   GenericBeanDefinition ( bd )  ;", "objectBd . setFactoryBeanName ( sBeanName )  ;", "objectBd . setFactoryMethodName (  \" getScriptedObject \"  )  ;", "objectBd . getConstructorArgumentValues (  )  . clear (  )  ;", "objectBd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    scriptSource )  ;", "objectBd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    interfaces )  ;", "return   objectBd ;", "}", "METHOD_END"], "methodName": ["createScriptedObjectBeanDefinition"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . scriptSourceCache )     {", "ScriptSource   scriptSource    =    this . scriptSourceCache . get ( beanName )  ;", "if    ( scriptSource    =  =    null )     {", "scriptSource    =    convertToScriptSource ( beanName ,    scriptSourceLocator ,    this . resourceLoader )  ;", "this . scriptSourceCache . put ( beanName ,    scriptSource )  ;", "}", "return   scriptSource ;", "}", "}", "METHOD_END"], "methodName": ["getScriptSource"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . scriptBeanFactory )     {", "if    (  !  ( this . scriptBeanFactory . containsBeanDefinition ( scriptedObjectBeanName )  )  )     {", "this . scriptBeanFactory . registerBeanDefinition ( scriptFactoryBeanName ,    createBeanDefinition ( bd )  )  ;", "scriptFactory    =    this . scriptBeanFactory . getBean ( scriptFactoryBeanName ,     . class )  ;", "ScriptSource   scriptSource    =    getScriptSource ( scriptFactoryBeanName ,    scriptFactory . getScriptSourceLocator (  )  )  ;", "Class <  ?  >  [  ]    interfaces    =    scriptFactory . getScriptInterfaces (  )  ;", "Class <  ?  >  [  ]    scriptedInterfaces    =    interfaces ;", "if    (  ( scriptFactory . requiresConfigInterface (  )  )     &  &     (  !  ( bd . getPropertyValues (  )  . isEmpty (  )  )  )  )     {", "Class <  ?  >    configInterface    =    createConfigInterface ( bd ,    interfaces )  ;", "scriptedInterfaces    =    ObjectUtils . addObjectToArray ( interfaces ,    configInterface )  ;", "}", "BeanDefinition   objectBd    =    createScriptedObjectBeanDefinition ( bd ,    scriptFactoryBeanName ,    scriptSource ,    scriptedInterfaces )  ;", "long   refreshCheckDelay    =    resolveRefreshCheckDelay ( bd )  ;", "if    ( refreshCheckDelay    >  =     0  )     {", "objectBd . setScope ( SCOPE _ PROTOTYPE )  ;", "}", "this . scriptBeanFactory . registerBeanDefinition ( scriptedObjectBeanName ,    objectBd )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["prepareScriptBeans"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "boolean   proxyTargetClass    =    this . defaultProxyTargetClass ;", "Object   attributeValue    =    beanDefinition . getAttribute (  . PROXY _ TARGET _ CLASS _ ATTRIBUTE )  ;", "if    ( attributeValue   instanceof   Boolean )     {", "proxyTargetClass    =     (  ( Boolean )     ( attributeValue )  )  ;", "} else", "if    ( attributeValue   instanceof   String )     {", "proxyTargetClass    =    Boolean . valueOf (  (  ( String )     ( attributeValue )  )  )  ;", "} else", "if    ( attributeValue    !  =    null )     {", "throw   new   BeanDefinitionStoreException (  (  (  (  (  \" Invalid   proxy   target   class   attribute    [  \"     +     (  . PROXY _ TARGET _ CLASS _ ATTRIBUTE )  )     +     \"  ]    with   value    '  \"  )     +    attributeValue )     +     \"  '  :    needs   to   be   of   type   Boolean   or   String \"  )  )  ;", "}", "return   proxyTargetClass ;", "}", "METHOD_END"], "methodName": ["resolveProxyTargetClass"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "long   refreshCheckDelay    =    this . defaultRefreshCheckDelay ;", "Object   attributeValue    =    beanDefinition . getAttribute (  . REFRESH _ CHECK _ DELAY _ ATTRIBUTE )  ;", "if    ( attributeValue   instanceof   Number )     {", "refreshCheckDelay    =     (  ( Number )     ( attributeValue )  )  . longValue (  )  ;", "} else", "if    ( attributeValue   instanceof   String )     {", "refreshCheckDelay    =    Long . parseLong (  (  ( String )     ( attributeValue )  )  )  ;", "} else", "if    ( attributeValue    !  =    null )     {", "throw   new   BeanDefinitionStoreException (  (  (  (  (  \" Invalid   refresh   check   delay   attribute    [  \"     +     (  . REFRESH _ CHECK _ DELAY _ ATTRIBUTE )  )     +     \"  ]    with   value    '  \"  )     +    attributeValue )     +     \"  '  :    needs   to   be   of   type   Number   or   String \"  )  )  ;", "}", "return   refreshCheckDelay ;", "}", "METHOD_END"], "methodName": ["resolveRefreshCheckDelay"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . defaultProxyTargetClass    =    defaultProxyTargetClass ;", "}", "METHOD_END"], "methodName": ["setDefaultProxyTargetClass"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . defaultRefreshCheckDelay    =    defaultRefreshCheckDelay ;", "}", "METHOD_END"], "methodName": ["setDefaultRefreshCheckDelay"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessor"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( ScriptFactoryPostProcessor . class )  ;", "if    ( isRefreshable )     {", "builder . addPropertyValue (  \" defaultRefreshCheckDelay \"  ,    new   Long (  1  )  )  ;", "}", "return   builder . getBeanDefinition (  )  ;", "}", "METHOD_END"], "methodName": ["createScriptFactoryPostProcessor"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( GroovyScriptFactory . class )  ;", "builder . addConstructorArgValue (  (  \" inline : package   scripting ;  \\ n \"     +     (  (  (  (  (  (  (  (  \" class   GroovyMessenger   implements   Messenger    {  \\ n \"     +     \"       private   String   message    =     \\  \" Bingo \\  \"  \\ n \"  )     +     \"       public   String   getMessage (  )     {  \\ n \"  )     +     \"             return   this . message \\ n \"  )     +     \"        }  \\ n \"  )     +     \"       public   void   setMessage ( String   message )     {  \\ n \"  )     +     \"             this . message    =    message \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  )  )  ;", "builder . addPropertyValue (  \" message \"  ,     . MESSAGE _ TEXT )  ;", "return   builder . getBeanDefinition (  )  ;", "}", "METHOD_END"], "methodName": ["createScriptedGroovyBean"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ScriptFactoryPostProcessor   processor    =     (  ( ScriptFactoryPostProcessor )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . PROCESSOR _ BEAN _ NAME )  )  )  ;", "BeanDefinition   bd    =    processor . scriptBeanFactory . getBeanDefinition (  \" scriptedObject . messenger \"  )  ;", "return    (  ( StaticScriptSource )     ( bd . getConstructorArgumentValues (  )  . getIndexedArgumentValue (  0  ,    StaticScriptSource . class )  . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScriptSource"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Thread . sleep (  ( secondsToPause    *     1  0  0  0  )  )  ;", "}    catch    ( InterruptedExceon   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["pauseToLetRefreshDelayKickIn"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorBeanDefinition    =    ScriptFactoryPostProcessorTests . createScriptFactoryPostProcessor ( false )  ;", "BeanDefinition   scriptedBeanDefinition    =    ScriptFactoryPostProcessorTests . createScriptedGroovyBean (  )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . registerBeanDefinition ( ScriptFactoryPostProcessorTests . PROCESSOR _ BEAN _ NAME ,    processorBeanDefinition )  ;", "ctx . registerBeanDefinition ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME ,    scriptedBeanDefinition )  ;", "ctx . refresh (  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  )  )  ;", "assertEquals ( ScriptFactoryPostProcessorTests . MESSAGE _ TEXT ,    messenger . getMessage (  )  )  ;", "ScriptFactoryPostProcessorTests . pauseToLetRefreshDelayKickIn ( ScriptFactoryPostProcessorTests . DEFAULT _ SECONDS _ TO _ PAUSE )  ;", "StaticScriptSource   source    =    ScriptFactoryPostProcessorTests . getScriptSource ( ctx )  ;", "source . setScript ( ScriptFactoryPostProcessorTests . CHANGED _ SCRIPT )  ;", "Messenger   refreshedMessenger    =     (  ( Messenger )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  )  )  ;", "assertEquals (  \" Script   seems   to   have   been   refreshed    ( must   not   be   as   no   refreshCheckDelay   set   on   ScriptFactoryPostProcessor )  \"  ,    ScriptFactoryPostProcessorTests . MESSAGE _ TEXT ,    refreshedMessenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testChangeScriptWithNoRefreshableBeanFunctionality"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorBeanDefinition    =    ScriptFactoryPostProcessorTests . createScriptFactoryPostProcessor ( true )  ;", "BeanDefinition   scriptedBeanDefinition    =    ScriptFactoryPostProcessorTests . createScriptedGroovyBean (  )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . registerBeanDefinition ( ScriptFactoryPostProcessorTests . PROCESSOR _ BEAN _ NAME ,    processorBeanDefinition )  ;", "ctx . registerBeanDefinition ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME ,    scriptedBeanDefinition )  ;", "ctx . refresh (  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  )  )  ;", "assertEquals ( ScriptFactoryPostProcessorTests . MESSAGE _ TEXT ,    messenger . getMessage (  )  )  ;", "ScriptFactoryPostProcessorTests . pauseToLetRefreshDelayKickIn ( ScriptFactoryPostProcessorTests . DEFAULT _ SECONDS _ TO _ PAUSE )  ;", "StaticScriptSource   source    =    ScriptFactoryPostProcessorTests . getScriptSource ( ctx )  ;", "source . setScript ( ScriptFactoryPostProcessorTests . CHANGED _ SCRIPT )  ;", "Messenger   refreshedMessenger    =     (  ( Messenger )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  )  )  ;", "assertEquals ( ScriptFactoryPostProcessorTests . EXPECTED _ CHANGED _ MESSAGE _ TEXT ,    refreshedMessenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testChangeScriptWithRefreshableBeanFunctionality"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( new   ScriptFactoryPostProcessor (  )  . postProcessBeforeInstantiation ( getClass (  )  ,     \" a . bean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoesNothingWhenPostProcessingNonScriptFactoryTypeBeforeInstantiation"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorBeanDefinition    =    ScriptFactoryPostProcessorTests . createScriptFactoryPostProcessor ( true )  ;", "BeanDefinition   scriptedBeanDefinition    =    ScriptFactoryPostProcessorTests . createScriptedGroovyBean (  )  ;", "BeanDefinitionBuilder   collaboratorBuilder    =    BeanDefinitionBuilder . rootBeanDefinition ( ScriptFactoryPostProcessorTests . DefaultMessengerService . class )  ;", "collaboratorBuilder . addPropertyReference ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME ,    ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . registerBeanDefinition ( ScriptFactoryPostProcessorTests . PROCESSOR _ BEAN _ NAME ,    processorBeanDefinition )  ;", "ctx . registerBeanDefinition ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME ,    scriptedBeanDefinition )  ;", "final   String   collaboratorBeanName    =     \" collaborator \"  ;", "ctx . registerBeanDefinition ( collaboratorBeanName ,    collaboratorBuilder . getBeanDefinition (  )  )  ;", "ctx . refresh (  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  )  )  ;", "assertEquals ( ScriptFactoryPostProcessorTests . MESSAGE _ TEXT ,    messenger . getMessage (  )  )  ;", "ScriptFactoryPostProcessorTests . pauseToLetRefreshDelayKickIn ( ScriptFactoryPostProcessorTests . DEFAULT _ SECONDS _ TO _ PAUSE )  ;", "StaticScriptSource   source    =    ScriptFactoryPostProcessorTests . getScriptSource ( ctx )  ;", "source . setScript (  \" I   keep   hoping   you   are   the   same   as   me ,    and   I ' ll   send   you   letters   and   come   to   your   house   for   tea \"  )  ;", "Messenger   refreshedMessenger    =     (  ( Messenger )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  )  )  ;", "try    {", "refreshedMessenger . getMessage (  )  ;", "fail (  \" Must   have   thrown   an   Exception    ( invalid   script )  \"  )  ;", "}    catch    ( FatalBeanException   expected )     {", "assertTrue ( expected . contains ( ScriptCompilationException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testForRefreshedScriptHavingErrorPickedUpOnFirstCall"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . registerBeanDefinition (  \" messenger \"  ,    BeanDefinitionBuilder . rootBeanDefinition ( StubMessenger . class )  . getBeanDefinition (  )  )  ;", "BeanDefinitionBuilder   scriptedBeanBuilder    =    BeanDefinitionBuilder . rootBeanDefinition ( GroovyScriptFactory . class )  ;", "scriptedBeanBuilder . setScope ( SCOPE _ PROTOTYPE )  ;", "scriptedBeanBuilder . addConstructorArgValue (  . DELEGATING _ SCRIPT )  ;", "scriptedBeanBuilder . addPropertyReference (  \" messenger \"  ,     \" messenger \"  )  ;", "final   String   BEAN _ WITH _ DEPENDENCY _ NAME    =     \" needsMessenger \"  ;", "ctx . registerBeanDefinition ( BEAN _ WITH _ DEPENDENCY _ NAME ,    scriptedBeanBuilder . getBeanDefinition (  )  )  ;", "ctx . registerBeanDefinition (  \" scriptProcessor \"  ,     . createScriptFactoryPostProcessor ( true )  )  ;", "ctx . refresh (  )  ;", "Messenger   messenger 1     =     (  ( Messenger )     ( ctx . getBean ( BEAN _ WITH _ DEPENDENCY _ NAME )  )  )  ;", "Messenger   messenger 2     =     (  ( Messenger )     ( ctx . getBean ( BEAN _ WITH _ DEPENDENCY _ NAME )  )  )  ;", "assertNotSame ( messenger 1  ,    messenger 2  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeScriptedBean"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   businessContext    =    new   GenericApplicationContext (  )  ;", "businessContext . registerBeanDefinition (  \" messenger \"  ,    BeanDefinitionBuilder . rootBeanDefinition ( StubMessenger . class )  . getBeanDefinition (  )  )  ;", "businessContext . refresh (  )  ;", "BeanDefinitionBuilder   scriptedBeanBuilder    =    BeanDefinitionBuilder . rootBeanDefinition ( GroovyScriptFactory . class )  ;", "scriptedBeanBuilder . addConstructorArgValue (  . DELEGATING _ SCRIPT )  ;", "scriptedBeanBuilder . addPropertyReference (  \" messenger \"  ,     \" messenger \"  )  ;", "GenericApplicationContext   presentationCtx    =    new   GenericApplicationContext ( businessContext )  ;", "presentationCtx . registerBeanDefinition (  \" needsMessenger \"  ,    scriptedBeanBuilder . getBeanDefinition (  )  )  ;", "presentationCtx . registerBeanDefinition (  \" scriptProcessor \"  ,     . createScriptFactoryPostProcessor ( true )  )  ;", "presentationCtx . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["testReferencesAcrossAContainerHierarchy"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   processorBeanDefinition    =    ScriptFactoryPostProcessorTests . createScriptFactoryPostProcessor ( true )  ;", "BeanDefinition   scriptedBeanDefinition    =    ScriptFactoryPostProcessorTests . createScriptedGroovyBean (  )  ;", "BeanDefinitionBuilder   collaboratorBuilder    =    BeanDefinitionBuilder . rootBeanDefinition ( ScriptFactoryPostProcessorTests . DefaultMessengerService . class )  ;", "collaboratorBuilder . addPropertyReference ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME ,    ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  ;", "GenericApplicationContext   ctx    =    new   GenericApplicationContext (  )  ;", "ctx . registerBeanDefinition ( ScriptFactoryPostProcessorTests . PROCESSOR _ BEAN _ NAME ,    processorBeanDefinition )  ;", "ctx . registerBeanDefinition ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME ,    scriptedBeanDefinition )  ;", "final   String   collaboratorBeanName    =     \" collaborator \"  ;", "ctx . registerBeanDefinition ( collaboratorBeanName ,    collaboratorBuilder . getBeanDefinition (  )  )  ;", "ctx . refresh (  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  )  )  ;", "assertEquals ( ScriptFactoryPostProcessorTests . MESSAGE _ TEXT ,    messenger . getMessage (  )  )  ;", "ScriptFactoryPostProcessorTests . pauseToLetRefreshDelayKickIn ( ScriptFactoryPostProcessorTests . DEFAULT _ SECONDS _ TO _ PAUSE )  ;", "StaticScriptSource   source    =    ScriptFactoryPostProcessorTests . getScriptSource ( ctx )  ;", "source . setScript ( ScriptFactoryPostProcessorTests . CHANGED _ SCRIPT )  ;", "Messenger   refreshedMessenger    =     (  ( Messenger )     ( ctx . getBean ( ScriptFactoryPostProcessorTests . MESSENGER _ BEAN _ NAME )  )  )  ;", "assertEquals ( ScriptFactoryPostProcessorTests . EXPECTED _ CHANGED _ MESSAGE _ TEXT ,    refreshedMessenger . getMessage (  )  )  ;", "ScriptFactoryPostProcessorTests . DefaultMessengerService   collaborator    =     (  ( ScriptFactoryPostProcessorTests . DefaultMessengerService )     ( ctx . getBean ( collaboratorBeanName )  )  )  ;", "assertEquals ( ScriptFactoryPostProcessorTests . EXPECTED _ CHANGED _ MESSAGE _ TEXT ,    collaborator . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshedScriptReferencePropagatesToCollaborators"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  \" org / springframework / scripting / support / groovyReferences . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["testScriptHavingAReferenceToAnotherBean"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  )  . setBeanFactory ( mock ( BeanFactory . class )  )  ;", "fail (  \" Must   have   thrown   exception   by   this   point .  \"  )  ;", "}    catch    ( IllegalStateException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testThrowsExceptionIfGivenNonAbstractBeanFactoryImplementation"], "fileName": "org.springframework.scripting.support.ScriptFactoryPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . scriptException ;", "}", "METHOD_END"], "methodName": ["getScriptException"], "fileName": "org.springframework.scripting.support.StandardScriptEvalException"}, {"methodBody": ["METHOD_START", "{", "ScriptEngineManager   scriptEngineManager    =    this . scriptEngineManager ;", "if    ( scriptEngineManager    =  =    null )     {", "scriptEngineManager    =    new   ScriptEngineManager (  )  ;", "this . scriptEngineManager    =    scriptEngineManager ;", "}", "if    ( StringUtils . hasText ( this . engineName )  )     {", "return   StandardScriptUtils . retrieveEngineByName ( scriptEngineManager ,    this . engineName )  ;", "} else", "if    ( script   instanceof   ResourceScriptSource )     {", "core . io . Resource   resource    =     (  ( ResourceScriptSource )     ( script )  )  . getResource (  )  ;", "String   extension    =    StringUtils . getFilenameExtension ( resource . getFilename (  )  )  ;", "if    ( extension    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   script   language   defined ,    and   no   file   extension   defined   for   resource :     \"     +    resource )  )  ;", "}", "ScriptEngine   engine    =    scriptEngineManager . getEngineByExtension ( extension )  ;", "if    ( engine    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   matching   engine   found   for   file   extension    '  \"     +    extension )     +     \"  '  \"  )  )  ;", "}", "return   engine ;", "} else    {", "throw   new   IllegalStateException (  (  \" No   script   language   defined ,    and   no   resource   associated   with   script :     \"     +    script )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getScriptEngine"], "fileName": "org.springframework.scripting.support.StandardScriptEvaluator"}, {"methodBody": ["METHOD_START", "{", "this . engineName    =    engineName ;", "}", "METHOD_END"], "methodName": ["setEngineName"], "fileName": "org.springframework.scripting.support.StandardScriptEvaluator"}, {"methodBody": ["METHOD_START", "{", "Bindings   bindings    =    StandardScriptUtils . getBindings ( globalBindings )  ;", "this . globalBindings    =    bindings ;", "ScriptEngineManager   scriptEngineManager    =    this . scriptEngineManager ;", "if    ( scriptEngineManager    !  =    null )     {", "scriptEngineManager . setBindings ( bindings )  ;", "}", "}", "METHOD_END"], "methodName": ["setGlobalBindings"], "fileName": "org.springframework.scripting.support.StandardScriptEvaluator"}, {"methodBody": ["METHOD_START", "{", "this . engineName    =    language ;", "}", "METHOD_END"], "methodName": ["setLanguage"], "fileName": "org.springframework.scripting.support.StandardScriptEvaluator"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    adaptedIfc ;", "if    (  ( actualInterfaces . length )     =  =     1  )     {", "adaptedIfc    =    actualInterfaces [  0  ]  ;", "} else    {", "adaptedIfc    =    ClassUtils . createCompositeInterface ( actualInterfaces ,    this . beanClassLoader )  ;", "}", "if    ( adaptedIfc    !  =    null )     {", "ScriptEngineEngine    =    thisEngine ;", "if    (  ! Engine   instanceof   Invocable )  )     {", "throw   new   ScriptCompilationExceptionSource ,     (  \" ScriptEngine   must   implement   Invocable   in   order   to   adapt   it   to   an   interface :     \"     + Engine )  )  ;", "}", "Invocable   invocable    =     (  ( Invocable )    Engine )  )  ;", "if       !  =    null )     {", "=    invocable . getInterface ,    adaptedIfc )  ;", "}", "if       =  =    null )     {", "=    invocable . getInterface ( adaptedIfc )  ;", "if       =  =    null )     {", "throw   new   ScriptCompilationExceptionSource ,     (  (  \" Could   not   adapt   to   interface    [  \"     +     ( adaptedIfc . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "return ;", "}", "METHOD_END"], "methodName": ["adaptToInterfaces"], "fileName": "org.springframework.scripting.support.StandardScriptFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "ScriptEngineEngine    =    thisEngine ;", "if   Engine    =  =    null )     {", "Engine    =    retrieveScriptEngineSource )  ;", "if   Engine    =  =    null )     {", "throw   new   IllegalStateException (  (  \" Could   not   determine   engine   for    \"     + Source )  )  ;", "}", "thisEngine    = Engine ;", "}", "returnEngine . evalSource . getScriptAsString (  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   ScriptCompilationExceptionSource ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluateScript"], "fileName": "org.springframework.scripting.support.StandardScriptFactory"}, {"methodBody": ["METHOD_START", "{", "ScriptEngineManager   scriptEngineManager    =    new   ScriptEngineManager ( this . beanClassLoader )  ;", "if    (  ( this . scriptEngineName )     !  =    null )     {", "return   Utils . retrieveEngineByName ( scriptEngineManager ,    this . scriptEngineName )  ;", "}", "if    ( scriptSource   instanceof   ResourceScriptSource )     {", "String   filename    =     (  ( ResourceScriptSource )     ( scriptSource )  )  . getResource (  )  . getFilename (  )  ;", "if    ( filename    !  =    null )     {", "String   extension    =    StringUtils . getFilenameExtension ( filename )  ;", "if    ( extension    !  =    null )     {", "ScriptEngine   engine    =    scriptEngineManager . getEngineByExtension ( extension )  ;", "if    ( engine    !  =    null )     {", "return   engine ;", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["retrieveScriptEngine"], "fileName": "org.springframework.scripting.support.StandardScriptFactory"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" jsr 2  2  3  - with - xsd . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNsForType ( Messenger . class )  )  . contains (  \" inlineMessengerWithInterface \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" inlineMessengerWithInterface \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( messenger )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInlineJsr223FromTagWithInterface"], "fileName": "org.springframework.scripting.support.StandardScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" jsr 2  2  3  - with - xsd . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNsForType ( Messenger . class )  )  . contains (  \" messengerWithInterface \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" messengerWithInterface \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( messenger )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJsr223FromTagWithInterface"], "fileName": "org.springframework.scripting.support.StandardScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   ctx    =    new   ClassPathXmlApplicationContext (  \" jsr 2  2  3  - with - xsd . xml \"  ,    getClass (  )  )  ;", "assertTrue ( Arrays . asList ( ctx . getBeanNsForType ( Messenger . class )  )  . contains (  \" refreshableMessengerWithInterface \"  )  )  ;", "Messenger   messenger    =     (  ( Messenger )     ( ctx . getBean (  \" refreshableMessengerWithInterface \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( messenger )  )  ;", "assertTrue (  ( messenger   instanceof   Refreshable )  )  ;", "assertEquals (  \" Hello   World !  \"  ,    messenger . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshableJsr223FromTagWithInterface"], "fileName": "org.springframework.scripting.support.StandardScriptFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   bindings   instanceof   Bindings    ?     (  ( Bindings )     ( bindings )  )     :    new   SimpleBindings ( bindings )  ;", "}", "METHOD_END"], "methodName": ["getBindings"], "fileName": "org.springframework.scripting.support.StandardScriptUtils"}, {"methodBody": ["METHOD_START", "{", "ScriptEngine   engine    =    scriptEngineManager . getEngineByName ( engineName )  ;", "if    ( engine    =  =    null )     {", "Set < String >    engineNames    =    new   LinkedHashSet <  >  (  )  ;", "for    ( ScriptEngineFactory   engineFactory    :    scriptEngineManager . getEngineFactories (  )  )     {", "List < String >    factoryNames    =    engineFactory . getNames (  )  ;", "if    ( factoryNames . contains ( engineName )  )     {", "try    {", "engine    =    engineFactory . getScriptEngine (  )  ;", "engine . setBindings ( scriptEngineManager . getBindings (  )  ,    ScriptContext . GLOBAL _ SCOPE )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  (  \" Script   engine   with   name    '  \"     +    engineName )     +     \"  '    failed   to   initialize \"  )  ,    ex )  ;", "}", "}", "engineNames . addAll ( factoryNames )  ;", "}", "throw   new   IllegalArgumentException (  (  (  (  \" Script   engine   with   name    '  \"     +    engineName )     +     \"  '    not   found ;    registered   engine   names :     \"  )     +    engineNames )  )  ;", "}", "return   engine ;", "}", "METHOD_END"], "methodName": ["retrieveEngineByName"], "fileName": "org.springframework.scripting.support.StandardScriptUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ,     \" Script   must   not   be   empty \"  )  ;", "this . modified    =     !  . equals ( this )  )  ;", "this    =  ;", "}", "METHOD_END"], "methodName": ["setScript"], "fileName": "org.springframework.scripting.support.StaticScriptSource"}, {"methodBody": ["METHOD_START", "{", "new   StaticScriptSource (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["createWithEmptyScript"], "fileName": "org.springframework.scripting.support.StaticScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "new   StaticScriptSource ( null )  ;", "}", "METHOD_END"], "methodName": ["createWithNullScript"], "fileName": "org.springframework.scripting.support.StaticScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "new   StaticScriptSource (  \"           \\ n \\ n \\ t       \\ t \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["createWithWhitespaceOnlyScript"], "fileName": "org.springframework.scripting.support.StaticScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "source . getScriptAsString (  )  ;", "assertFalse (  \" Script   must   be   flagged   as    ' not   modified '    after   script   is   read .  \"  ,    source . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["gettingScriptTogglesIsModified"], "fileName": "org.springframework.scripting.support.StaticScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "boolean   isModifiedState    =    source . isModified (  )  ;", "source . toString (  )  ;", "assertEquals (  \" Script ' s    ' modified '    flag   must   not   change   after      is   read   via   toString (  )  .  \"  ,    isModifiedState ,    source . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["gettingScriptViaToStringDoesNotToggleIsModified"], "fileName": "org.springframework.scripting.support.StaticScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Script   must   be   flagged   as    ' modified '    when   first   created .  \"  ,    source . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["isModifiedIsTrueByDefault"], "fileName": "org.springframework.scripting.support.StaticScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "source . setScript ( StaticScriptSourceTests . SCRIPT _ TEXT )  ;", "assertFalse (  \" Script   must   not   be   flagged   as    ' modified '    when   same   script   is   passed   in .  \"  ,    source . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["isModifiedNotToggledWhenSameScriptIsSet"], "fileName": "org.springframework.scripting.support.StaticScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "source . setScript (  \" use   warnings ;  \"  )  ;", "assertTrue (  \" Script   must   be   flagged   as    ' modified '    when   different   script   is   passed   in .  \"  ,    source . isModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["isModifiedToggledWhenDifferentScriptIsSet"], "fileName": "org.springframework.scripting.support.StaticScriptSourceTests"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator < Runnable >    it    =    this . callbacks . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Runnable   runnable    =    it . next (  )  ;", "runnable . run (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.tests.context.SimpleMapScope"}, {"methodBody": ["METHOD_START", "{", "return   this . map ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "org.springframework.tests.context.SimpleMapScope"}, {"methodBody": ["METHOD_START", "{", "( this . counter )  +  +  ;", "}", "METHOD_END"], "methodName": ["doSomething"], "fileName": "org.springframework.tests.context.TestMethodInvokingTask"}, {"methodBody": ["METHOD_START", "{", "( this . counter )  +  +  ;", "synchronized ( this . lock )     {", "try    {", "this . lock . wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["doWait"], "fileName": "org.springframework.tests.context.TestMethodInvokingTask"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lock )     {", "this . lock . notify (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.springframework.tests.context.TestMethodInvokingTask"}, {"methodBody": ["METHOD_START", "{", "this . jndiObjects . put ( name ,    object )  ;", "}", "METHOD_END"], "methodName": ["addObject"], "fileName": "org.springframework.tests.mock.jndi.ExpectedLookupTemplate"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" Activating   simple   JNDI   environment \"  )  ;", "synchronized (  . initializationLock )     {", "if    (  !  (  . initialized )  )     {", "if    ( NamingManager . hasInitialContextFactoryBuilder (  )  )     {", "throw   new   IllegalStateException (  (  \" Cannot   activate    :    there   is   already   a   JNDI   provider   registered .     \"     +     (  \" Note   that   JNDI   is   a   JVM - wide   service ,    shared   at   the   JVM   system   class   loader   level ,     \"     +     \" with   no   reset   option .    As   a   consequence ,    a   JNDI   provider   must   only   be   registered   once   per   JVM .  \"  )  )  )  ;", "}", "NamingManager . setInitialContextFactoryBuilder ( this )  ;", ". initialized    =    true ;", "}", "}", ". activated    =    this ;", "}", "METHOD_END"], "methodName": ["activate"], "fileName": "org.springframework.tests.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  (  \" Static   JNDI   bind :     [  \"     +    name )     +     \"  ]     =     [  \"  )     +    obj )     +     \"  ]  \"  )  )  ;", "}", "this . boundObjects . put ( name ,    obj )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.springframework.tests.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . boundObjects . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.tests.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" Deactivating   simple   JNDI   environment \"  )  ;", ". activated    =    null ;", "}", "METHOD_END"], "methodName": ["deactivate"], "fileName": "org.springframework.tests.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( SimpleNamingContextBuilder . activated )     !  =    null )     {", "SimpleNamingContextBuilder . activated . clear (  )  ;", "} else    {", "SimpleNamingContextBuilder   builder    =    new   SimpleNamingContextBuilder (  )  ;", "builder . activate (  )  ;", "}", "return   SimpleNamingContextBuilder . activated ;", "}", "METHOD_END"], "methodName": ["emptyActivatedContextBuilder"], "fileName": "org.springframework.tests.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   SimpleNamingContextBuilder . activated ;", "}", "METHOD_END"], "methodName": ["getCurrentContextBuilder"], "fileName": "org.springframework.tests.mock.jndi.SimpleNamingContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   object ;", "}", "METHOD_END"], "methodName": ["getObject"], "fileName": "org.springframework.tests.sample.beans.BeanWithObjectProperty"}, {"methodBody": ["METHOD_START", "{", "this . object    =    object ;", "}", "METHOD_END"], "methodName": ["setObject"], "fileName": "org.springframework.tests.sample.beans.BeanWithObjectProperty"}, {"methodBody": ["METHOD_START", "{", "return   co ;", "}", "METHOD_END"], "methodName": ["getCompany"], "fileName": "org.springframework.tests.sample.beans.Employee"}, {"methodBody": ["METHOD_START", "{", "this . co    =    co ;", "}", "METHOD_END"], "methodName": ["setCompany"], "fileName": "org.springframework.tests.sample.beans.Employee"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["nullInstance"], "fileName": "org.springframework.tests.sample.beans.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.tests.sample.beans.FieldAccessBean"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.tests.sample.beans.FieldAccessBean"}, {"methodBody": ["METHOD_START", "{", "return   spouse ;", "}", "METHOD_END"], "methodName": ["getSpouse"], "fileName": "org.springframework.tests.sample.beans.FieldAccessBean"}, {"methodBody": ["METHOD_START", "{", "return   contextResource ;", "}", "METHOD_END"], "methodName": ["getContextResource"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "return   inputStream ;", "}", "METHOD_END"], "methodName": ["getInputStream"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "return   resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "return   resourceArray ;", "}", "METHOD_END"], "methodName": ["getResourceArray"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "return   resourceArrayMap ;", "}", "METHOD_END"], "methodName": ["getResourceArrayMap"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "return   resourceMap ;", "}", "METHOD_END"], "methodName": ["getResourceMap"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "this . contextResource    =    contextResource ;", "}", "METHOD_END"], "methodName": ["setContextResource"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "this . inputStream    =    inputStream ;", "}", "METHOD_END"], "methodName": ["setInputStream"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "this . resource    =    resource ;", "}", "METHOD_END"], "methodName": ["setResource"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "this . resourceArray    =    resourceArray ;", "}", "METHOD_END"], "methodName": ["setResourceArray"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "this . resourceArrayMap    =    resourceArrayMap ;", "}", "METHOD_END"], "methodName": ["setResourceArrayMap"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "this . resourceMap    =    resourceMap ;", "}", "METHOD_END"], "methodName": ["setResourceMap"], "fileName": "org.springframework.tests.sample.beans.ResourceTestBean"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeValues    !  =    null )     {", "for    ( Object   attributeValue    :    attributeValues )     {", "addAttribute ( attributeValue )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addAllAttributes"], "fileName": "org.springframework.ui.ConcurrentModel"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    !  =    null )     {", "putAll ( attributes )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addAllAttributes"], "fileName": "org.springframework.ui.ConcurrentModel"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeValue ,     \" Model   object   must   not   be   null \"  )  ;", "if    (  ( attributeValue   instanceof   Collection )     &  &     (  (  ( Collection <  ?  >  )     ( attributeValue )  )  . isEmpty (  )  )  )     {", "return   this ;", "}", "return   addAttribute ( Conventions . getVariableName ( attributeValue )  ,    attributeValue )  ;", "}", "METHOD_END"], "methodName": ["addAttribute"], "fileName": "org.springframework.ui.ConcurrentModel"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeName ,     \" Model   attribute   name   must   not   be   null \"  )  ;", "Assert . notNull ( attributeValue ,     \"    does   not   support   null   attribute   value \"  )  ;", "put ( attributeName ,    attributeValue )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAttribute"], "fileName": "org.springframework.ui.ConcurrentModel"}, {"methodBody": ["METHOD_START", "{", "return   containsKey ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["containsAttribute"], "fileName": "org.springframework.ui.ConcurrentModel"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    !  =    null )     {", "attributes . forEach (  (    key ,    value )     -  >     {", "if    (  !  ( containsKey ( key )  )  )     {", "put ( key ,    value )  ;", "}", "}  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["mergeAttributes"], "fileName": "org.springframework.ui.ConcurrentModel"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeValues    !  =    null )     {", "for    ( Object   attributeValue    :    attributeValues )     {", "addAttribute ( attributeValue )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addAllAttributes"], "fileName": "org.springframework.ui.ModelMap"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    !  =    null )     {", "putAll ( attributes )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addAllAttributes"], "fileName": "org.springframework.ui.ModelMap"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeValue ,     \" Model   object   must   not   be   null \"  )  ;", "if    (  ( attributeValue   instanceof   Collection )     &  &     (  (  ( Collection <  ?  >  )     ( attributeValue )  )  . isEmpty (  )  )  )     {", "return   this ;", "}", "return   addAttribute ( Conventions . getVariableName ( attributeValue )  ,    attributeValue )  ;", "}", "METHOD_END"], "methodName": ["addAttribute"], "fileName": "org.springframework.ui.ModelMap"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeName ,     \" Model   attribute   name   must   not   be   null \"  )  ;", "put ( attributeName ,    attributeValue )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAttribute"], "fileName": "org.springframework.ui.ModelMap"}, {"methodBody": ["METHOD_START", "{", "return   containsKey ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["containsAttribute"], "fileName": "org.springframework.ui.ModelMap"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    !  =    null )     {", "attributes . forEach (  (    key ,    value )     -  >     {", "if    (  !  ( containsKey ( key )  )  )     {", "put ( key ,    value )  ;", "}", "}  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["mergeAttributes"], "fileName": "org.springframework.ui.ModelMap"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  )  ;", "model . addAllAttributes (  (  ( Collection < Object >  )     ( null )  )  )  ;", "assertEquals (  0  ,    model . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddAllObjectsWithNullCollection"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  )  ;", "model . addAllAttributes (  (  ( Map < String ,     ?  >  )     ( null )  )  )  ;", "assertEquals (  0  ,    model . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddAllObjectsWithNullMap"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  )  ;", "ArrayList < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \" bing \"  )  ;", "list . add ( null )  ;", "model . addAllAttributes ( list )  ;", "}", "METHOD_END"], "methodName": ["testAddAllObjectsWithSparseArrayList"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "List < TestBean >    beans    =    new   ArrayList <  >  (  )  ;", "beans . add ( new   TestBean (  \" one \"  )  )  ;", "beans . add ( new   TestBean (  \" two \"  )  )  ;", "beans . add ( new   TestBean (  \" three \"  )  )  ;", "model    =    new    (  )  ;", "model . addAllAttributes ( beans )  ;", "assertEquals (  1  ,    model . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddListOfTheSameObjects"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" one \"  ,     \" one - value \"  )  ;", "map . put (  \" two \"  ,     \" two - value \"  )  ;", "model    =    new    (  )  ;", "model . addAttribute ( map )  ;", "assertEquals (  1  ,    model . size (  )  )  ;", "String   key    =    StringUtils . uncapitalize ( ClassUtils . getShortName ( map . getClass (  )  )  )  ;", "assertTrue ( model . containsKey ( key )  )  ;", "}", "METHOD_END"], "methodName": ["testAddMap"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  \" foo \"  ,    null )  ;", "assertTrue ( model . containsKey (  \" foo \"  )  )  ;", "assertNull ( model . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddNullObjectViaCtorWithExplicitKey"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  )  ;", "model . addAttribute (  \" foo \"  ,    null )  ;", "assertTrue ( model . containsKey (  \" foo \"  )  )  ;", "assertNull ( model . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddNullObjectWithExplicitKey"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  )  ;", "model . addAttribute (  \" foo \"  )  ;", "model . addAttribute (  \" bar \"  )  ;", "assertEquals (  1  ,    model . size (  )  )  ;", "String   bar    =     (  ( String )     ( model . get (  \" string \"  )  )  )  ;", "assertEquals (  \" bar \"  ,    bar )  ;", "}", "METHOD_END"], "methodName": ["testAddObjectNoKeyOfSameTypeOverrides"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap ( new   int [  ]  {        }  )  ;", "assertEquals (  1  ,    model . size (  )  )  ;", "int [  ]    ints    =     (  ( int [  ]  )     ( model . get (  \" intList \"  )  )  )  ;", "assertNotNull ( ints )  ;", "assertEquals (  0  ,    ints . length )  ;", "}", "METHOD_END"], "methodName": ["testAddObjectWithEmptyArray"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  )  ;", "model . addAttribute ( null )  ;", "}", "METHOD_END"], "methodName": ["testAddObjectWithNull"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   map    =    new   ModelMap (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory (  )  ;", ". SomeInnerClass   val    =    new    . SomeInnerClass (  )  ;", "factory . setTarget ( val )  ;", "factory . setProxyTargetClass ( true )  ;", "map . addAttribute ( factory . getProxy (  )  )  ;", "assertTrue ( map . containsKey (  \" someInnerClass \"  )  )  ;", "assertEquals ( val ,    map . get (  \" someInnerClass \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAopCglibProxy"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   map    =    new   ModelMap (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory (  )  ;", "Map <  ?  ,     ?  >    target    =    new   HashMap <  >  (  )  ;", "factory . setTarget ( target )  ;", "factory . addInterface ( Map . class )  ;", "Object   proxy    =    factory . getProxy (  )  ;", "map . addAttribute ( proxy )  ;", "assertSame ( proxy ,    map . get (  \" map \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAopJdkProxy"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   map    =    new   ModelMap (  )  ;", "Map <  ?  ,     ?  >    target    =    new   HashMap <  >  (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( target )  ;", "Object   proxy    =    factory . getProxy (  )  ;", "map . addAttribute ( proxy )  ;", "assertSame ( proxy ,    map . get (  \" map \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAopJdkProxyWithDetectedInterfaces"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   map    =    new   ModelMap (  )  ;", "Map <  ?  ,     ?  >    target    =    new   HashMap <  >  (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory (  )  ;", "factory . setTarget ( target )  ;", "factory . addInterface ( Serializable . class )  ;", "factory . addInterface ( Cloneable . class )  ;", "factory . addInterface ( Comparable . class )  ;", "factory . addInterface ( Map . class )  ;", "Object   proxy    =    factory . getProxy (  )  ;", "map . addAttribute ( proxy )  ;", "assertSame ( proxy ,    map . get (  \" map \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAopJdkProxyWithMultipleInterfaces"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   map    =    new   ModelMap (  )  ;", ". SomeInnerClass   inner    =    new    . SomeInnerClass (  )  ;", "map . addAttribute ( inner )  ;", "assertSame ( inner ,    map . get (  \" someInnerClass \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testInnerClass"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   map    =    new   ModelMap (  )  ;", ". UKInnerClass   inner    =    new    . UKInnerClass (  )  ;", "map . addAttribute ( inner )  ;", "assertSame ( inner ,    map . get (  \" UKInnerClass \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testInnerClassWithTwoUpperCaseLetters"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    TestBean >    beans    =    new   HashMap <  >  (  )  ;", "beans . put (  \" one \"  ,    new   TestBean (  \" one \"  )  )  ;", "beans . put (  \" two \"  ,    new   TestBean (  \" two \"  )  )  ;", "beans . put (  \" three \"  ,    new   TestBean (  \" three \"  )  )  ;", "model    =    new    (  )  ;", "model . put (  \" one \"  ,    new   TestBean (  \" oneOld \"  )  )  ;", "model . mergeAttributes ( beans )  ;", "assertEquals (  3  ,    model . size (  )  )  ;", "assertEquals (  \" oneOld \"  ,     (  ( TestBean )     ( model . get (  \" one \"  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergeMapWithOverriding"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  \" foo \"  ,     \" bing \"  )  ;", "assertEquals (  1  ,    model . size (  )  )  ;", "String   bing    =     (  ( String )     ( model . get (  \" foo \"  )  )  )  ;", "assertNotNull ( bing )  ;", "assertEquals (  \" bing \"  ,    bing )  ;", "}", "METHOD_END"], "methodName": ["testNamedObjectCtor"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    new   ModelMap (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoArgCtorYieldsEmptyModel"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap ( new   String [  ]  {     \" foo \"  ,     \" boing \"     }  )  ;", "assertEquals (  1  ,    model . size (  )  )  ;", "String [  ]    strings    =     (  ( String [  ]  )     ( model . get (  \" stringList \"  )  )  )  ;", "assertNotNull ( strings )  ;", "assertEquals (  2  ,    strings . length )  ;", "assertEquals (  \" foo \"  ,    strings [  0  ]  )  ;", "assertEquals (  \" boing \"  ,    strings [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testOneArgCtorWithCollection"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap ( new   HashSet <  >  (  )  )  ;", "assertEquals (  0  ,    model . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOneArgCtorWithEmptyCollection"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "new   ModelMap ( null )  ;", "}", "METHOD_END"], "methodName": ["testOneArgCtorWithNull"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  \" bing \"  )  ;", "assertEquals (  1  ,    model . size (  )  )  ;", "String   string    =     (  ( String )     ( model . get (  \" string \"  )  )  )  ;", "assertNotNull ( string )  ;", "assertEquals (  \" bing \"  ,    string )  ;", "}", "METHOD_END"], "methodName": ["testOneArgCtorWithScalar"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   map    =    new   ModelMap (  )  ;", "Object   proxy    =    Proxy . newProxyInstance ( getClass (  )  . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    Map . class    }  ,    new   InvocationHandler (  )     {", "@ Override", "public   Object   invoke ( Object   proxy ,    Method   method ,    Object [  ]    args )     {", "return    \" proxy \"  ;", "}", "}  )  ;", "map . addAttribute ( proxy )  ;", "assertSame ( proxy ,    map . get (  \" map \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRawJdkProxy"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ModelMap   model    =    new   ModelMap (  \" foo \"  ,     \" bing \"  )  ;", "assertEquals (  1  ,    model . size (  )  )  ;", "String   bing    =     (  ( String )     ( model . get (  \" foo \"  )  )  )  ;", "assertNotNull ( bing )  ;", "assertEquals (  \" bing \"  ,    bing )  ;", "}", "METHOD_END"], "methodName": ["testUnnamedCtorScalar"], "fileName": "org.springframework.ui.ModelMapTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleMessageSource   messageSource    =    new   ResourceBundleMessageSource (  )  ;", "messageSource . setBasename ( basename )  ;", "if    (  ( this . defaultEncoding )     !  =    null )     {", "messageSource . setDefaultEncoding ( this . defaultEncoding )  ;", "}", "if    (  ( this . fallbackToSystemLocale )     !  =    null )     {", "messageSource . setFallbackToSystemLocale ( this . fallbackToSystemLocale )  ;", "}", "if    (  ( this . beanClassLoader )     !  =    null )     {", "messageSource . setBeanClassLoader ( this . beanClassLoader )  ;", "}", "return   messageSource ;", "}", "METHOD_END"], "methodName": ["createMessageSource"], "fileName": "org.springframework.ui.context.support.ResourceBundleThemeSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( theme . getMessageSource (  )  )    instanceof   HierarchicalMessageSource )     {", "HierarchicalMessageSource   messageSource    =     (  ( HierarchicalMessageSource )     ( theme . getMessageSource (  )  )  )  ;", "if    (  (  ( getParent (  )  )     !  =    null )     &  &     (  ( messageSource . getParentMessageSource (  )  )     =  =    null )  )     {", "Theme   parentTheme    =    getParent (  )  . getTheme ( theme . getName (  )  )  ;", "if    ( parentTheme    !  =    null )     {", "messageSource . setParentMessageSource ( parentTheme . getMessageSource (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["initParent"], "fileName": "org.springframework.ui.context.support.ResourceBundleThemeSource"}, {"methodBody": ["METHOD_START", "{", "this . basenamePrefix    =     ( basenamePrefix    !  =    null )     ?    basenamePrefix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setBasenamePrefix"], "fileName": "org.springframework.ui.context.support.ResourceBundleThemeSource"}, {"methodBody": ["METHOD_START", "{", "this . defaultEncoding    =    defaultEncoding ;", "}", "METHOD_END"], "methodName": ["setDefaultEncoding"], "fileName": "org.springframework.ui.context.support.ResourceBundleThemeSource"}, {"methodBody": ["METHOD_START", "{", "this . fallbackToSystemLocale    =    fallbackToSystemLocale ;", "}", "METHOD_END"], "methodName": ["setFallbackToSystemLocale"], "fileName": "org.springframework.ui.context.support.ResourceBundleThemeSource"}, {"methodBody": ["METHOD_START", "{", "if    ( context . containsLocalBean ( UiApplicationContextUtils . THEME _ SOURCE _ BEAN _ NAME )  )     {", "ThemeSource   themeSource    =    context . getBean ( UiApplicationContextUtils . THEME _ SOURCE _ BEAN _ NAME ,    ThemeSource . class )  ;", "if    (  (  ( context . getParent (  )  )    instanceof   ThemeSource )     &  &     ( themeSource   instanceof   HierarchicalThemeSource )  )     {", "HierarchicalThemeSource   hts    =     (  ( HierarchicalThemeSource )     ( themeSource )  )  ;", "if    (  ( hts . getParentThemeSource (  )  )     =  =    null )     {", "hts . setParentThemeSource (  (  ( ThemeSource )     ( context . getParent (  )  )  )  )  ;", "}", "}", "if    ( UiApplicationContextUtils . logger . isDebugEnabled (  )  )     {", "UiApplicationContextUtils . logger . debug (  (  (  \" Using   ThemeSource    [  \"     +    themeSource )     +     \"  ]  \"  )  )  ;", "}", "return   themeSource ;", "} else    {", "HierarchicalThemeSource   themeSource    =    null ;", "if    (  ( context . getParent (  )  )    instanceof   ThemeSource )     {", "themeSource    =    new   DelegatingThemeSource (  )  ;", "themeSource . setParentThemeSource (  (  ( ThemeSource )     ( context . getParent (  )  )  )  )  ;", "} else    {", "themeSource    =    new   ResourceBundleThemeSource (  )  ;", "}", "if    ( UiApplicationContextUtils . logger . isDebugEnabled (  )  )     {", "UiApplicationContextUtils . logger . debug (  (  (  (  (  \" Unable   to   locate   ThemeSource   with   name    '  \"     +     ( UiApplicationContextUtils . THEME _ SOURCE _ BEAN _ NAME )  )     +     \"  '  :    using   default    [  \"  )     +    themeSource )     +     \"  ]  \"  )  )  ;", "}", "return   themeSource ;", "}", "}", "METHOD_END"], "methodName": ["initThemeSource"], "fileName": "org.springframework.ui.context.support.UiApplicationContextUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( MBeanServer   server    :    MBeanServerFactory . findMBeanServer ( null )  )     {", "MBeanServerFactory . releaseMBeanServer ( server )  ;", "}", "Field   field    =    ManagementFactory . class . getDeclaredField (  \" platformMBeanServer \"  )  ;", "field . setAccessible ( true )  ;", "field . set ( null ,    null )  ;", "}", "METHOD_END"], "methodName": ["resetMBeanServers"], "fileName": "org.springframework.util.MBeanTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["formatFieldValue"], "fileName": "org.springframework.validation.AbstractBindingResult"}, {"methodBody": ["METHOD_START", "{", "return   this . messageCodesResolver ;", "}", "METHOD_END"], "methodName": ["getMessageCodesResolver"], "fileName": "org.springframework.validation.AbstractBindingResult"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageCodesResolver ,     \" MessageCodesResolver   must   not   be   null \"  )  ;", "this . messageCodesResolver    =    messageCodesResolver ;", "}", "METHOD_END"], "methodName": ["setMessageCodesResolver"], "fileName": "org.springframework.validation.AbstractBindingResult"}, {"methodBody": ["METHOD_START", "{", "return   field ;", "}", "METHOD_END"], "methodName": ["canonicalFieldName"], "fileName": "org.springframework.validation.AbstractErrors"}, {"methodBody": ["METHOD_START", "{", "if    ( nestedPath    =  =    null )     {", "nestedPath    =     \"  \"  ;", "}", "nestedPath    =    canonicalFieldName ( nestedPath )  ;", "if    (  (  ( nestedPath . length (  )  )     >     0  )     &  &     (  !  ( nestedPath . endsWith (  . NESTED _ PATH _ SEPARATOR )  )  )  )     {", "nestedPath    +  =     . NESTED _ PATH _ SEPARATOR ;", "}", "this . nestedPath    =    nestedPath ;", "}", "METHOD_END"], "methodName": ["doSetNestedPath"], "fileName": "org.springframework.validation.AbstractErrors"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasLength ( field )  )     {", "return    ( getNestedPath (  )  )     +     ( canonicalFieldName ( field )  )  ;", "} else    {", "String   path    =    getNestedPath (  )  ;", "return   path . endsWith (  . NESTED _ PATH _ SEPARATOR )     ?    path . substring (  0  ,     (  ( path . length (  )  )     -     (  . NESTED _ PATH _ SEPARATOR . length (  )  )  )  )     :    path ;", "}", "}", "METHOD_END"], "methodName": ["fixedField"], "fileName": "org.springframework.validation.AbstractErrors"}, {"methodBody": ["METHOD_START", "{", "if    ( field . equals ( fieldError . getField (  )  )  )     {", "return   true ;", "}", "int   endIndex    =     ( field . length (  )  )     -     1  ;", "return    (  ( endIndex    >  =     0  )     &  &     (  ( field . charAt ( endIndex )  )     =  =     '  *  '  )  )     &  &     (  ( endIndex    =  =     0  )     |  |     ( field . regionMatches (  0  ,    fieldError . getField (  )  ,     0  ,    endIndex )  )  )  ;", "}", "METHOD_END"], "methodName": ["isMatchingFieldError"], "fileName": "org.springframework.validation.AbstractErrors"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetType    =    getPropertyAccessor (  )  . getPropertyType ( fixedField )  ;", "PropertyEditor   editor    =    getPropertyAccessor (  )  . findCustomEditor ( targetType ,    fixedField )  ;", "if    ( editor    =  =    null )     {", "editor    =    BeanUtils . findEditorByConvention ( targetType )  ;", "}", "return   editor ;", "}", "METHOD_END"], "methodName": ["getCustomEditor"], "fileName": "org.springframework.validation.AbstractPropertyBindingResult"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( conversionService ,     \" ConversionService   must   not   be   null \"  )  ;", "this . conversionService    =    conversionService ;", "if    (  ( getTarget (  )  )     !  =    null )     {", "geAccessor (  )  . setConversionService ( conversionService )  ;", "}", "}", "METHOD_END"], "methodName": ["initConversion"], "fileName": "org.springframework.validation.AbstractPropertyBindingResult"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . target )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" Cannot   access   properties   on   null   bean   instance    '  \"     +     ( getObjectName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "return   PropertyAccessorFactory . forAccess ( this . target )  ;", "}", "METHOD_END"], "methodName": ["createBeanWrapper"], "fileName": "org.springframework.validation.BeanPropertyBindingResult"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingResult ;", "}", "METHOD_END"], "methodName": ["getBindingResult"], "fileName": "org.springframework.validation.BindException"}, {"methodBody": ["METHOD_START", "{", "return   new   String [  0  ]  ;", "}", "METHOD_END"], "methodName": ["getSuppressedFields"], "fileName": "org.springframework.validation.BindingResult"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( model ,     \" Model   map   must   not   be   null \"  )  ;", "Assert . notNull ( name ,     \" Name   must   not   be   null \"  )  ;", "Object   attr    =    model . get (  (  (  . MODEL _ KEY _ PREFIX )     +    name )  )  ;", "if    (  ( attr    !  =    null )     &  &     (  !  ( attr   instanceof    )  )  )     {", "throw   new   IllegalStateException (  (  \"    attribute   is   not   of   type    :     \"     +    attr )  )  ;", "}", "return    (  (  )     ( attr )  )  ;", "}", "METHOD_END"], "methodName": ["getBindingResult"], "fileName": "org.springframework.validation.BindingResultUtils"}, {"methodBody": ["METHOD_START", "{", "BindingResult   bindingResult    =    BindingResultUtils . getBindingResult ( model ,    name )  ;", "if    ( bindingResult    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   BindingResult   attribute   found   for   name    '  \"     +    name )     +     \"  '  -    have   you   exposed   the   correct   model ?  \"  )  )  ;", "}", "return   bindingResult ;", "}", "METHOD_END"], "methodName": ["getRequiredBindingResult"], "fileName": "org.springframework.validation.BindingResultUtils"}, {"methodBody": ["METHOD_START", "{", "FormatterPropertyEditorAdapter   adapter    =    new   FormatterPropertyEditorAdapter ( formatter )  ;", "getPropertyEditorRegistry (  )  . registerCustomEditor ( adapter . getFieldType (  )  ,    adapter )  ;", "}", "METHOD_END"], "methodName": ["addCustomFormatter"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "FormatterPropertyEditorAdapter   adapter    =    new   FormatterPropertyEditorAdapter ( formatter )  ;", "if    ( ObjectUtils . isEmpty ( fieldTypes )  )     {", "getPropertyEditorRegistry (  )  . registerCustomEditor ( adapter . getFieldType (  )  ,    adapter )  ;", "} else    {", "for    ( Class <  ?  >    fieldType    :    fieldTypes )     {", "getPropertyEditorRegistry (  )  . registerCustomEditor ( fieldType ,    adapter )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addCustomFormatter"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "FormatterPropertyEditorAdapter   adapter    =    new   FormatterPropertyEditorAdapter ( formatter )  ;", "Class <  ?  >    fieldType    =    adapter . getFieldType (  )  ;", "if    ( ObjectUtils . isEmpty ( fields )  )     {", "getPropertyEditorRegistry (  )  . registerCustomEditor ( fieldType ,    adapter )  ;", "} else    {", "for    ( St   field    :    fields )     {", "getPropertyEditorRegistry (  )  . registerCustomEditor ( fieldType ,    field ,    adapter )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addCustomFormatter"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "assertValidatorsors )  ;", "thisors . addAll ( Arrays . asListors )  )  ;", "}", "METHOD_END"], "methodName": ["addValidators"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "try    {", "getPropertyAccessor (  )  . setPropertyValues ( mpvs ,    isIgnoreUnknownFields (  )  ,    isIgnoreInFields (  )  )  ;", "}    catch    ( PropertyBatchUpdateException   ex )     {", "for    ( PropertyAccessException   pae    :    ex . getPropertyAccessExceptions (  )  )     {", "getBindingErrorProcessor (  )  . processPropertyAccessException ( pae ,    getInternalBindingResult (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyPropertyValues"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "Object   target    =    getTarget (  )  ;", "for    ( Validator   or    :    ors )     {", "if    (  ( or    !  =    null )     &  &     (  ( target    !  =    null )     &  &     (  !  ( or . supports ( target . getClass (  )  )  )  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  \" Invalid   target   for   Validator    [  \"     +    or )     +     \"  ]  :     \"  )     +    target )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertValidators"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   mpvs    =     ( pvs   instanceof   MutablePropertyValues )     ?     (  ( MutablePropertyValues )     ( pvs )  )     :    new   MutablePropertyValues ( pvs )  ;", "do ( mpvs )  ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "PropertyValue [  ]    pvs    =    mpvs . getPropertyValues (  )  ;", "for    ( PropertyValue   pv    :    pvs )     {", "String   field    =    PropertyAccessorUtils . canonicalPropertyName ( pv . getName (  )  )  ;", "if    (  !  ( isAllowed ( field )  )  )     {", "mpvs . removePropertyValue ( pv )  ;", "getBindingResult (  )  . recordSuppressedField ( field )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Field    [  \"     +    field )     +     \"  ]    has   been   removed   from   PropertyValues    \"  )     +     \" and   will   not   be   bound ,    because   it   has   not   been   found   in   the   list   of   allowed   fields \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkAllowedFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "String [  ]    requiredFields    =    getRequiredFields (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( requiredFields )  )  )     {", "Map < String ,    PropertyValue >    propertyValues    =    new   HashMap <  >  (  )  ;", "PropertyValue [  ]    pvs    =    mpvs . getPropertyValues (  )  ;", "for    ( PropertyValue   pv    :    pvs )     {", "String   canonicalName    =    PropertyAccessorUtils . canonicalPropertyName ( pv . getName (  )  )  ;", "propertyValues . put ( canonicalName ,    pv )  ;", "}", "for    ( String   field    :    requiredFields )     {", "PropertyValue   pv    =    propertyValues . get ( field )  ;", "boolean   empty    =     ( pv    =  =    null )     |  |     (  ( pv . getValue (  )  )     =  =    null )  ;", "if    (  ! empty )     {", "if    (  ( pv . getValue (  )  )    instanceof   String )     {", "empty    =     !  ( StringUtils . hasText (  (  ( String )     ( pv . getValue (  )  )  )  )  )  ;", "} else", "if    (  ( pv . getValue (  )  )    instanceof   String [  ]  )     {", "String [  ]    values    =     (  ( String [  ]  )     ( pv . getValue (  )  )  )  ;", "empty    =     (  ( values . length )     =  =     0  )     |  |     (  !  ( StringUtils . hasText ( values [  0  ]  )  )  )  ;", "}", "}", "if    ( empty )     {", "getBindingErrorProcessor (  )  . processMissingFieldError ( field ,    getInternalBindingResult (  )  )  ;", "if    ( pv    !  =    null )     {", "mpvs . removePropertyValue ( pv )  ;", "propertyValues . remove ( field )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkRequiredFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "if    ( getBindingResult (  )  . hasErrors (  )  )     {", "throw   new   BindException ( getBindingResult (  )  )  ;", "}", "return   getBindingResult (  )  . getModel (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( getTarget (  )  ,    getObjectName (  )  ,    isAutoGrowNestedPaths (  )  ,    getAutoGrowCollectionLimit (  )  )  ;", "if    (  ( this . conversionService )     !  =    null )     {", "result . initConversion ( this . conversionService )  ;", "}", "if    (  ( this . messageCodesResolver )     !  =    null )     {", "result . setMessageCodesResolver ( this . messageCodesResolver )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["createBeanPropertyBindingResult"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "DirectFieldBindingResult   result    =    new   DirectFieldBindingResult ( getTarget (  )  ,    getObjectName (  )  ,    isAutoGrowNestedPaths (  )  )  ;", "if    (  ( this . conversionService )     !  =    null )     {", "result . initConversion ( this . conversionService )  ;", "}", "if    (  ( this . messageCodesResolver )     !  =    null )     {", "result . setMessageCodesResolver ( this . messageCodesResolver )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["createDirectFieldBindingResult"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "checkAllowedFields ( mpvs )  ;", "checkRequiredFields ( mpvs )  ;", "applyProptyValues ( mpvs )  ;", "}", "METHOD_END"], "methodName": ["doBind"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . allowedFields ;", "}", "METHOD_END"], "methodName": ["getAllowedFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . autoGrowCollectionLimit ;", "}", "METHOD_END"], "methodName": ["getAutoGrowCollectionLimit"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingErrorProcessor ;", "}", "METHOD_END"], "methodName": ["getBindingErrorProcessor"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   getInternalBindingResult (  )  ;", "}", "METHOD_END"], "methodName": ["getBindingResult"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . conversionService ;", "}", "METHOD_END"], "methodName": ["getConversionService"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . disallowedFields ;", "}", "METHOD_END"], "methodName": ["getDisallowedFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . bindingResult )     =  =    null )     {", "initBeanPropertyAccess (  )  ;", "}", "return   this . bindingResult ;", "}", "METHOD_END"], "methodName": ["getInternalBindingResult"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . objectName ;", "}", "METHOD_END"], "methodName": ["getObjectName"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   getInternalBindingResult (  )  . getPropertyAccessor (  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyAccessor"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getTarget (  )  )     !  =    null )     {", "return   getInternalingResult (  )  . getPropertyAccessor (  )  ;", "} else    {", "return   getSimpleTypeConverter (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPropertyEditorRegistry"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . requiredFields ;", "}", "METHOD_END"], "methodName": ["getRequiredFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . typeConverter )     =  =    null )     {", "this . typeConverter    =    new   SimpleTypeConverter (  )  ;", "if    (  ( this . conversService )     !  =    null )     {", "this . typeConverter . setConversService ( this . conversService )  ;", "}", "}", "return   this . typeConverter ;", "}", "METHOD_END"], "methodName": ["getSimpleTypeConverter"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getTarget (  )  )     !  =    null )     {", "return   getInternalingResult (  )  . getPropertyAccessor (  )  ;", "} else    {", "return   getSimpleTypeConverter (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getTypeConverter"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . validators . isEmpty (  )  )     ?    this . validators . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getValidator"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . validators )  ;", "}", "METHOD_END"], "methodName": ["getValidators"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . bindingResult )     =  =    null )  ,     \" DataBinder   is   already   initialized    -    call   initBeanPropertyAccess   before   other   configuration   methods \"  )  ;", "this . bindingResult    =    createBeanPropertyBindingResult (  )  ;", "}", "METHOD_END"], "methodName": ["initBeanPropertyAccess"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . bindingResult )     =  =    null )  ,     \" DataBinder   is   already   initialized    -    call   initDirectFieldAccess   before   other   configuration   methods \"  )  ;", "this . bindingResult    =    createDirectFieldBindingResult (  )  ;", "}", "METHOD_END"], "methodName": ["initDirectFieldAccess"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "String [  ]    allowed    =    getAllowedFields (  )  ;", "String [  ]    disallowed    =    getDisallowedFields (  )  ;", "return    (  ( ObjectUtils . isEmpty ( allowed )  )     |  |     ( PatternMatchUtils . simpleMatch ( allowed ,    field )  )  )     &  &     (  ( ObjectUtils . isEmpty ( disallowed )  )     |  |     (  !  ( PatternMatchUtils . simpleMatch ( disallowed ,    field )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAllowed"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . autoGrowNestedPaths ;", "}", "METHOD_END"], "methodName": ["isAutoGrowNestedPaths"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . ignoreInvalidFields ;", "}", "METHOD_END"], "methodName": ["isIgnoreInvalidFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "return   this . ignoreUnknownFields ;", "}", "METHOD_END"], "methodName": ["isIgnoreUnknownFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "assertValidatorsors )  ;", "thisors . clear (  )  ;", "thisors . addAll ( Arrays . asListors )  )  ;", "}", "METHOD_END"], "methodName": ["replaceValidators"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "this . allowedFields    =    PropertyAccessorUtils . canonicalPropertyNames ( allowedFields )  ;", "}", "METHOD_END"], "methodName": ["setAllowedFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . bindingResult )     =  =    null )  ,     \" DataBinder   is   already   initialized    -    call   setAutoGrowCollectionLimit   before   other   configuration   methods \"  )  ;", "this . autoGrowCollectionLimit    =    autoGrowCollectionLimit ;", "}", "METHOD_END"], "methodName": ["setAutoGrowCollectionLimit"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . bindingResult )     =  =    null )  ,     \" DataBinder   is   already   initialized    -    call   setAutoGrowNestedPaths   before   other   configuration   methods \"  )  ;", "this . autoGrowNestedPaths    =    autoGrowNestedPaths ;", "}", "METHOD_END"], "methodName": ["setAutoGrowNestedPaths"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bindingErrorProcessor ,     \" BindingErrorProcessor   must   not   be   null \"  )  ;", "this . bindingErrorProcessor    =    bindingErrorProcessor ;", "}", "METHOD_END"], "methodName": ["setBindingErrorProcessor"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . conversionService )     =  =    null )  ,     \" DataBinder   is   already   initialized   with   ConversionService \"  )  ;", "this . conversionService    =    conversionService ;", "if    (  (  ( this . bindingResult )     !  =    null )     &  &     ( conversionService    !  =    null )  )     {", "this . bindingResult . initConversion ( conversionService )  ;", "}", "}", "METHOD_END"], "methodName": ["setConversionService"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "this . disallowedFields    =    PropertyAccessorUtils . canonicalPropertyNames ( disallowedFields )  ;", "}", "METHOD_END"], "methodName": ["setDisallowedFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "this . ignoreInvalidFields    =    ignoreInvalidFields ;", "}", "METHOD_END"], "methodName": ["setIgnoreInvalidFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "this . ignoreUnknownFields    =    ignoreUnknownFields ;", "}", "METHOD_END"], "methodName": ["setIgnoreUnknownFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . messageCodesResolver )     =  =    null )  ,     \" DataBinder   is   already   initialized   with   MessageCodesResolver \"  )  ;", "this . messageCodesResolver    =    messageCodesResolver ;", "if    (  (  ( this . bindingResult )     !  =    null )     &  &     ( messageCodesResolver    !  =    null )  )     {", "this . bindingResult . setMessageCodesResolver ( messageCodesResolver )  ;", "}", "}", "METHOD_END"], "methodName": ["setMessageCodesResolver"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "this . requiredFields    =    PropertyAccessorUtils . canonicalPropertyNames ( requiredFields )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \"    requires   binding   of   required   fields    [  \"     +     ( StringUtils . arrayToCommaDelimitedString ( requiredFields )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRequiredFields"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "assertValidatorsor )  ;", "thisors . clear (  )  ;", "if   or    !  =    null )     {", "thisors . addor )  ;", "}", "}", "METHOD_END"], "methodName": ["setValidator"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "for    ( Validator   validator    :    this . validators )     {", "validator . validate ( getTarget (  )  ,    getBindingResult (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "for    ( Validator   validator    :    getValidators (  )  )     {", "if    (  (  !  ( ObjectUtils . isEmpty ( Hints )  )  )     &  &     ( validator   instanceof   SmartValidator )  )     {", "(  ( SmartValidator )     ( validator )  )  . validate ( getTarget (  )  ,    getBindingResult (  )  ,    Hints )  ;", "} else", "if    ( validator    !  =    null )     {", "validator . validate ( getTarget (  )  ,    getBindingResult (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.springframework.validation.DataBinder"}, {"methodBody": ["METHOD_START", "{", "FieldAccessBean   rod    =    new   FieldAccessBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( rod ,     \" person \"  )  ;", "assertTrue ( binder . isIgnoreUnknownFields (  )  )  ;", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,     \" Rod \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,    new   Integer (  3  2  )  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" nonExisting \"  ,     \" someValue \"  )  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "assertTrue (  \" changed   age   correctly \"  ,     (  ( rod . getAge (  )  )     =  =     3  2  )  )  ;", "Map <  ?  ,     ?  >    m    =    binder . getBindingResult (  )  . getModel (  )  ;", "assertTrue (  \" There   is   one   element   in   map \"  ,     (  ( m . size (  )  )     =  =     2  )  )  ;", "FieldAccessBean   tb    =     (  ( FieldAccessBean )     ( m . get (  \" person \"  )  )  )  ;", "assertTrue (  \" Same   object \"  ,    tb . equals ( rod )  )  ;", "}", "METHOD_END"], "methodName": ["bindingNoErrors"], "fileName": "org.springframework.validation.DataBinderFieldAccessTests"}, {"methodBody": ["METHOD_START", "{", "FieldAccessBean   rod    =    new   FieldAccessBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( rod ,     \" person \"  )  ;", "binder . initDirectFieldAccess (  )  ;", "binder . setIgnoreUnknownFields ( false )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,     \" Rod \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,    new   Integer (  3  2  )  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" nonExisting \"  ,     \" someValue \"  )  )  ;", "try    {", "binder . bind ( pvs )  ;", "fail (  \" Should   have   thrown   NotWritablePropertyException \"  )  ;", "}    catch    ( NotWritablePropertyException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["bindingNoErrorsNotIgnoreUnknown"], "fileName": "org.springframework.validation.DataBinderFieldAccessTests"}, {"methodBody": ["METHOD_START", "{", "FieldAccessBean   rod    =    new   FieldAccessBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( rod ,     \" person \"  )  ;", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,     \" Rod \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,     \"  3  2 x \"  )  )  ;", "binder . bind ( pvs )  ;", "try    {", "binder . close (  )  ;", "fail (  \" Should   have   thrown   BindException \"  )  ;", "}    catch    ( BindException   ex )     {", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "Map <  ?  ,     ?  >    map    =    binder . getBindingResult (  )  . getModel (  )  ;", "FieldAccessBean   tb    =     (  ( FieldAccessBean )     ( map . get (  \" person \"  )  )  )  ;", "assertTrue (  \" Same   object \"  ,    tb . equals ( rod )  )  ;", "BindingResult   br    =     (  ( BindingResult )     ( map . get (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +     \" person \"  )  )  )  )  ;", "assertTrue (  \" Added   itself   to   map \"  ,     ( br    =  =     ( binder . getBindingResult (  )  )  )  )  ;", "assertTrue ( br . hasErrors (  )  )  ;", "assertTrue (  \" Correct   number   of   errors \"  ,     (  ( br . getErrorCount (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Has   age   errors \"  ,    br . hasFieldErrors (  \" age \"  )  )  ;", "assertTrue (  \" Correct   number   of   age   errors \"  ,     (  ( br . getFieldErrorCount (  \" age \"  )  )     =  =     1  )  )  ;", "assertEquals (  \"  3  2 x \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" age \"  )  )  ;", "assertEquals (  \"  3  2 x \"  ,    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["bindingWithErrors"], "fileName": "org.springframework.validation.DataBinderFieldAccessTests"}, {"methodBody": ["METHOD_START", "{", "FieldAccessBean   rod    =    new   FieldAccessBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( rod ,     \" person \"  )  ;", "binder . initDirectFieldAccess (  )  ;", "binder . registerCustomEditor ( TestBean . class ,     \" spouse \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean ( text ,     0  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,     \" Rod \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,     \"  3  2 x \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" spouse \"  ,     \" Kerry \"  )  )  ;", "binder . bind ( pvs )  ;", "try    {", "binder . close (  )  ;", "fail (  \" Should   have   thrown   BindException \"  )  ;", "}    catch    ( BindException   ex )     {", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "Map <  ?  ,     ?  >    model    =    binder . getBindingResult (  )  . getModel (  )  ;", "FieldAccessBean   tb    =     (  ( FieldAccessBean )     ( model . get (  \" person \"  )  )  )  ;", "assertTrue (  \" Same   object \"  ,    tb . equals ( rod )  )  ;", "BindingResult   br    =     (  ( BindingResult )     ( model . get (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +     \" person \"  )  )  )  )  ;", "assertTrue (  \" Added   itself   to   map \"  ,     ( br    =  =     ( binder . getBindingResult (  )  )  )  )  ;", "assertTrue ( br . hasErrors (  )  )  ;", "assertTrue (  \" Correct   number   of   errors \"  ,     (  ( br . getErrorCount (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Has   age   errors \"  ,    br . hasFieldErrors (  \" age \"  )  )  ;", "assertTrue (  \" Correct   number   of   age   errors \"  ,     (  ( br . getFieldErrorCount (  \" age \"  )  )     =  =     1  )  )  ;", "assertEquals (  \"  3  2 x \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" age \"  )  )  ;", "assertEquals (  \"  3  2 x \"  ,    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "assertTrue (  \" Does   not   have   spouse   errors \"  ,     (  !  ( br . hasFieldErrors (  \" spouse \"  )  )  )  )  ;", "assertEquals (  \" Kerry \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" spouse \"  )  )  ;", "assertNotNull ( tb . getSpouse (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["bindingWithErrorsAndCustomEditors"], "fileName": "org.springframework.validation.DataBinderFieldAccessTests"}, {"methodBody": ["METHOD_START", "{", "FieldAccessBean   rod    =    new   FieldAccessBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( rod ,     \" person \"  )  ;", "assertTrue ( binder . isIgnoreUnknownFields (  )  )  ;", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" spouse . name \"  ,     \" Kerry \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" spouse . jedi \"  ,     \" on \"  )  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertEquals (  \" Kerry \"  ,    rod . getSpouse (  )  . getName (  )  )  ;", "assertTrue ( rod . getSpouse (  )  . isJedi (  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedBindingWithDefaultConversionNoErrors"], "fileName": "org.springframework.validation.DataBinderFieldAccessTests"}, {"methodBody": ["METHOD_START", "{", "FieldAccessBean   rod    =    new   FieldAccessBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( rod ,     \" person \"  )  ;", "binder . setAutoGrowNestedPaths ( false )  ;", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" spouse . name \"  ,     \" Kerry \"  )  )  ;", "thrown . expect ( NullValueInNestedPathException . class )  ;", "binder . bind ( pvs )  ;", "}", "METHOD_END"], "methodName": ["nestedBindingWithDisabledAutoGrow"], "fileName": "org.springframework.validation.DataBinderFieldAccessTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "binder . bind ( pvs )  ;", "Errors   errors    =    binder . getBindingResult (  )  ;", "BeanPropertyBindingResult   errors 2     =    new   BeanPropertyBindingResult ( rod ,     \" person \"  )  ;", "errors . rejectValue (  \" name \"  ,     \" badName \"  )  ;", "errors . addAllErrors ( errors 2  )  ;", "FieldError   ageError    =    errors . getFieldError (  \" age \"  )  ;", "assertEquals (  \" typeMismatch \"  ,    ageError . getCode (  )  )  ;", "FieldError   nameError    =    errors . getFieldError (  \" name \"  )  ;", "assertEquals (  \" badName \"  ,    nameError . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddAllErrors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "binder . setAutoGrowCollectionLimit (  1  0  )  ;", "MutablePropertyValues   mpvs    =    new   MutablePropertyValues (  )  ;", "mpvs . add (  \" friends [  1  6  ]  \"  ,     \"  \"  )  ;", "try    {", "binder . bind ( mpvs )  ;", "fail (  \" Should   have   thrown   InvalidPropertyException \"  )  ;", "}    catch    ( InvalidPropertyException   ex )     {", "assertTrue (  (  ( ex . getRootCause (  )  )    instanceof   IndexOutOfBoundsException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutoGrowBeyondCustomLimit"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "MutablePropertyValues   mpvs    =    new   MutablePropertyValues (  )  ;", "mpvs . add (  \" friends [  2  5  6  ]  \"  ,     \"  \"  )  ;", "try    {", "binder . bind ( mpvs )  ;", "fail (  \" Should   have   thrown   InvalidPropertyException \"  )  ;", "}    catch    ( InvalidPropertyException   ex )     {", "assertTrue (  (  ( ex . getRootCause (  )  )    instanceof   IndexOutOfBoundsException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutoGrowBeyondDefaultLimit"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "binder . setAutoGrowCollectionLimit (  1  0  )  ;", "MutablePropertyValues   mpvs    =    new   MutablePropertyValues (  )  ;", "mpvs . add (  \" friends [  4  ]  \"  ,     \"  \"  )  ;", "binder . bind ( mpvs )  ;", "assertEquals (  5  ,    testBean . getFriends (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutoGrowWithinCustomLimit"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "MutablePropertyValues   mpvs    =    new   MutablePropertyValues (  )  ;", "mpvs . add (  \" friends [  4  ]  \"  ,     \"  \"  )  ;", "binder . bind ( mpvs )  ;", "assertEquals (  5  ,    testBean . getFriends (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutoGrowWithinDefaultLimit"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "SerializablePerson   tb    =    new   SerializablePerson (  )  ;", "tb . setName (  \" myName \"  )  ;", "tb . setAge (  9  9  )  ;", "BindException   ex    =    new   BindException ( tb ,     \" tb \"  )  ;", "ex . reject (  \" in \"  ,     \" someMessage \"  )  ;", "ex . rejectValue (  \" age \"  ,     \" inField \"  ,     \" someMessage \"  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( baos )  ;", "oos . writeObject ( ex )  ;", "ByteArrayInputStream   bais    =    new   ByteArrayInputStream ( baos . toByteArray (  )  )  ;", "ObjectInputStream   ois    =    new   ObjectInputStream ( bais )  ;", "BindException   ex 2     =     (  ( BindException )     ( ois . readObject (  )  )  )  ;", "assertTrue ( ex 2  . hasGlobalErrors (  )  )  ;", "assertEquals (  \" in \"  ,    ex 2  . getGlobalError (  )  . getCode (  )  )  ;", "assertTrue ( ex 2  . hasFieldErrors (  \" age \"  )  )  ;", "assertEquals (  \" inField \"  ,    ex 2  . getFieldError (  \" age \"  )  . getCode (  )  )  ;", "assertEquals ( new   Integer (  9  9  )  ,    ex 2  . getFieldValue (  \" age \"  )  )  ;", "ex 2  . rejectValue (  \" name \"  ,     \" inField \"  ,     \" someMessage \"  )  ;", "assertTrue ( ex 2  . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" inField \"  ,    ex 2  . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" myName \"  ,    ex 2  . getFieldValue (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindExceptionSerializable"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String [  ]  . class ,     \" stringArray \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( StringUtils . delimitedListToStringArray ( text ,     \"  -  \"  )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" stringArray \"  ,     \" a 1  - b 2  \"  )  ;", "binder . bind ( pvs )  ;", "assertTrue (  (  !  ( binder . getBindingResult (  )  . hasErrors (  )  )  )  )  ;", "assertEquals (  2  ,    tb . getStringArray (  )  . length )  ;", "assertEquals (  \" a 1  \"  ,    tb . getStringArray (  )  [  0  ]  )  ;", "assertEquals (  \" b 2  \"  ,    tb . getStringArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBindToStringArrayWithArrayEditor"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" stringArray \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" X \"     +    text )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" stringArray \"  ,    new   String [  ]  {     \" a 1  \"  ,     \" b 2  \"     }  )  ;", "binder . bind ( pvs )  ;", "assertTrue (  (  !  ( binder . getBindingResult (  )  . hasErrors (  )  )  )  )  ;", "assertEquals (  2  ,    tb . getStringArray (  )  . length )  ;", "assertEquals (  \" Xa 1  \"  ,    tb . getStringArray (  )  [  0  ]  )  ;", "assertEquals (  \" Xb 2  \"  ,    tb . getStringArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBindToStringArrayWithComponentEditor"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "binder . addCustomFormatter ( new   NumberStyleFormatter (  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1 x 2  \"  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "binder . bind ( pvs )  ;", "assertEquals ( new   Float (  0  .  0  )  ,    tb . getMyFloat (  )  )  ;", "assertEquals (  \"  1 x 2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" myFloat \"  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" myFloat \"  )  )  ;", "assertEquals (  \" typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" myFloat \"  )  . getCode (  )  )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingErrorWithCustomFormatter"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "FormattingConversionService   conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . addFormatterForFieldType ( Float . class ,    new   NumberStyleFormatter (  )  )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1 x 2  \"  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "binder . bind ( pvs )  ;", "assertEquals ( new   Float (  0  .  0  )  ,    tb . getMyFloat (  )  )  ;", "assertEquals (  \"  1 x 2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" myFloat \"  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" myFloat \"  )  )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingErrorWithFormatter"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "binder . initDirectFieldAccess (  )  ;", "FormattingConversionService   conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . addFormatterForFieldType ( Float . class ,    new   NumberStyleFormatter (  )  )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1 x 2  \"  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "binder . bind ( pvs )  ;", "assertEquals ( new   Float (  0  .  0  )  ,    tb . getMyFloat (  )  )  ;", "assertEquals (  \"  1 x 2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" myFloat \"  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" myFloat \"  )  )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingErrorWithFormatterAgainstFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "DataBinderTests . BeanWithIntegerList   tb    =    new   DataBinderTests . BeanWithIntegerList (  )  ;", "DataBinder   binder    =    new   DataBinder ( tb )  ;", "FormattingConversionService   conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . addFormatterForFieldType ( Float . class ,    new   NumberStyleFormatter (  )  )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" integerList [  0  ]  \"  ,     \"  1 x 2  \"  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "binder . bind ( pvs )  ;", "assertTrue ( tb . getIntegerList (  )  . isEmpty (  )  )  ;", "assertEquals (  \"  1 x 2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" integerList [  0  ]  \"  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" integerList [  0  ]  \"  )  )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingErrorWithFormatterAgainstList"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "binder . addCustomFormatter ( new   Formatter < String >  (  )     {", "@ Override", "public   String   parse ( String   text ,    Locale   locale )    throws   ParseException    {", "throw   new   ParseException ( text ,     0  )  ;", "}", "@ Override", "public   String   print ( String   object ,    Locale   locale )     {", "return   object ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" test \"  )  ;", "binder . bind ( pvs )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" test \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" name \"  )  )  ;", "assertEquals (  \" typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingErrorWithParseExceptionFromCustomFormatter"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "FormattingConversionService   conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . addFormatter ( new   Formatter < String >  (  )     {", "@ Override", "public   String   parse ( String   text ,    Locale   locale )    throws   ParseException    {", "throw   new   ParseException ( text ,     0  )  ;", "}", "@ Override", "public   String   print ( String   object ,    Locale   locale )     {", "return   object ;", "}", "}  )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" test \"  )  ;", "binder . bind ( pvs )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" test \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingErrorWithParseExceptionFromFormatter"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "binder . addCustomFormatter ( new   Formatter < String >  (  )     {", "@ Override", "public   String   parse ( String   text ,    Locale   locale )    throws   ParseException    {", "throw   new   RuntimeException ( text )  ;", "}", "@ Override", "public   String   print ( String   object ,    Locale   locale )     {", "return   object ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" test \"  )  ;", "binder . bind ( pvs )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" test \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" name \"  )  )  ;", "assertEquals (  \" typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingErrorWithRuntimeExceptionFromCustomFormatter"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "FormattingConversionService   conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . addFormatter ( new   Formatter < String >  (  )     {", "@ Override", "public   String   parse ( String   text ,    Locale   locale )    throws   ParseException    {", "throw   new   RuntimeException ( text )  ;", "}", "@ Override", "public   String   print ( String   object ,    Locale   locale )     {", "return   object ;", "}", "}  )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" test \"  )  ;", "binder . bind ( pvs )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" test \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingErrorWithRuntimeExceptionFromFormatter"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( rod ,     \" person \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "binder . bind ( pvs )  ;", "Errors   errors    =    binder . getBindingResult (  )  ;", "FieldError   ageError    =    errors . getFieldError (  \" age \"  )  ;", "assertEquals (  \" typeMismatch \"  ,    ageError . getCode (  )  )  ;", "ResourceBundleMessageSource   messageSource    =    new   ResourceBundleMessageSource (  )  ;", "messageSource . setBasename (  \" messages 1  \"  )  ;", "String   msg    =    messageSource . getMessage ( ageError ,    Locale . getDefault (  )  )  ;", "assertEquals (  \" Field   age   did   not   have   correct   type \"  ,    msg )  ;", "messageSource    =    new   ResourceBundleMessageSource (  )  ;", "messageSource . setBasename (  \" messages 2  \"  )  ;", "msg    =    messageSource . getMessage ( ageError ,    Locale . getDefault (  )  )  ;", "assertEquals (  \" Field   Age   did   not   have   correct   type \"  ,    msg )  ;", "messageSource    =    new   ResourceBundleMessageSource (  )  ;", "messageSource . setBasename (  \" messages 3  \"  )  ;", "msg    =    messageSource . getMessage ( ageError ,    Locale . getDefault (  )  )  ;", "assertEquals (  \" Field   Person   Age   did   not   have   correct   type \"  ,    msg )  ;", "}", "METHOD_END"], "methodName": ["testBindingErrors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "assertTrue ( binder . isIgnoreUnknownFields (  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  0  3  2  \"  )  ;", "pvs . add (  \" nonExisting \"  ,     \" someValue \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "assertTrue (  \" changed   age   correctly \"  ,     (  ( rod . getAge (  )  )     =  =     3  2  )  )  ;", "Map <  ?  ,     ?  >    map    =    binder . getBindingResult (  )  . getModel (  )  ;", "assertTrue (  \" There   is   one   element   in   map \"  ,     (  ( map . size (  )  )     =  =     2  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( map . get (  \" person \"  )  )  )  ;", "assertTrue (  \" Same   object \"  ,    tb . equals ( rod )  )  ;", "BindingResult   other    =    new   BeanPropertyBindingResult ( rod ,     \" person \"  )  ;", "assertEquals ( other ,    binder . getBindingResult (  )  )  ;", "assertEquals ( binder . getBindingResult (  )  ,    other )  ;", "BindException   ex    =    new   BindException ( other )  ;", "assertEquals ( ex ,    other )  ;", "assertEquals ( other ,    ex )  ;", "assertEquals ( ex ,    binder . getBindingResult (  )  )  ;", "assertEquals ( binder . getBindingResult (  )  ,    ex )  ;", "other . reject (  \" xxx \"  )  ;", "assertTrue (  (  !  ( other . equals ( binder . getBindingResult (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingNoErrors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "binder . setIgnoreUnknownFields ( false )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     3  2  )  ;", "pvs . add (  \" nonExisting \"  ,     \" someValue \"  )  ;", "try    {", "binder . bind ( pvs )  ;", "fail (  \" Should   have   thrown   NotWritablePropertyException \"  )  ;", "}    catch    ( NotWritablePropertyException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testBindingNoErrorsNotIgnoreUnknown"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "binder . setIgnoreInvalidFields ( true )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" spouse . age \"  ,     3  2  )  ;", "binder . bind ( pvs )  ;", "}", "METHOD_END"], "methodName": ["testBindingNoErrorsWithIgnoreInvalid"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" spouse . age \"  ,     3  2  )  ;", "try    {", "binder . bind ( pvs )  ;", "fail (  \" Should   have   thrown   NullValueInNestedPathException \"  )  ;", "}    catch    ( NullValueInNestedPathException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testBindingNoErrorsWithInvalidField"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( Set . class ,    new   CustomCollectionEditor ( TreeSet . class ,    true )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" set \"  ,    null )  ;", "binder . bind ( pvs )  ;", "assertTrue (  (  ( tb . getSet (  )  )    instanceof   TreeSet )  )  ;", "assertTrue ( tb . getSet (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingNullToEmptyCollection"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( Set . class ,    new   CustomCollectionEditor ( TreeSet . class )     {", "@ Override", "protected   Object   convertElement ( Object   element )     {", "return   new   Integer ( element . toString (  )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" set \"  ,    new   String [  ]  {     \"  1  0  \"  ,     \"  2  0  \"  ,     \"  3  0  \"     }  )  ;", "binder . bind ( pvs )  ;", "assertEquals ( tb . getSet (  )  ,    binder . getBindingResult (  )  . getFieldValue (  \" set \"  )  )  ;", "assertTrue (  (  ( tb . getSet (  )  )    instanceof   TreeSet )  )  ;", "assertEquals (  3  ,    tb . getSet (  )  . size (  )  )  ;", "assertTrue ( tb . getSet (  )  . contains ( new   Integer (  1  0  )  )  )  ;", "assertTrue ( tb . getSet (  )  . contains ( new   Integer (  2  0  )  )  )  ;", "assertTrue ( tb . getSet (  )  . contains ( new   Integer (  3  0  )  )  )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" set \"  ,    null )  ;", "binder . bind ( pvs )  ;", "assertNull ( tb . getSet (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingStringArrayToIntegerSet"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" array . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" array \"     +    text )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  \"  ,     \" a \"  )  ;", "binder . bind ( pvs )  ;", "Errors   errors    =    binder . getBindingResult (  )  ;", "errors . rejectValue (  \" array [  0  ]  . name \"  ,     \" NOT _ ROD \"  ,     \" are   you   sure   you ' re   not   Rod ?  \"  )  ;", "errors . rejectValue (  \" map [ key 1  ]  . name \"  ,     \" NOT _ ROD \"  ,     \" are   you   sure   you ' re   not   Rod ?  \"  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" array [  0  ]  . name \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ ROD . tb . array [  0  ]  . name \"  ,    errors . getFieldError (  \" array [  0  ]  . name \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ ROD . tb . array . name \"  ,    errors . getFieldError (  \" array [  0  ]  . name \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ ROD . array [  0  ]  . name \"  ,    errors . getFieldError (  \" array [  0  ]  . name \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ ROD . array . name \"  ,    errors . getFieldError (  \" array [  0  ]  . name \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ ROD . name \"  ,    errors . getFieldError (  \" array [  0  ]  . name \"  )  . getCodes (  )  [  4  ]  )  ;", "assertEquals (  \" NOT _ ROD . String \"  ,    errors . getFieldError (  \" array [  0  ]  . name \"  )  . getCodes (  )  [  5  ]  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" array [  0  ]  . name \"  )  . getCodes (  )  [  6  ]  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" map [ key 1  ]  . name \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" map [  ' key 1  '  ]  . name \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" map [  \\  \" key 1  \\  \"  ]  . name \"  )  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" map [ key 1  ]  . name \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ ROD . tb . map [ key 1  ]  . name \"  ,    errors . getFieldError (  \" map [ key 1  ]  . name \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ ROD . tb . map . name \"  ,    errors . getFieldError (  \" map [ key 1  ]  . name \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ ROD . map [ key 1  ]  . name \"  ,    errors . getFieldError (  \" map [ key 1  ]  . name \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ ROD . map . name \"  ,    errors . getFieldError (  \" map [ key 1  ]  . name \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ ROD . name \"  ,    errors . getFieldError (  \" map [ key 1  ]  . name \"  )  . getCodes (  )  [  4  ]  )  ;", "assertEquals (  \" NOT _ ROD . String \"  ,    errors . getFieldError (  \" map [ key 1  ]  . name \"  )  . getCodes (  )  [  5  ]  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" map [ key 1  ]  . name \"  )  . getCodes (  )  [  6  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBindingToIndexedField"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "tb . getArray (  )  [  0  ]  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb . getArray (  )  [  1  ]  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" array . nestedIndexedBean . list . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list \"     +    text )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,     \" a \"  )  ;", "binder . bind ( pvs )  ;", "Errors   errors    =    binder . getBindingResult (  )  ;", "errors . rejectValue (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,     \" NOT _ ROD \"  ,     \" are   you   sure   you ' re   not   Rod ?  \"  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ ROD . tb . array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ ROD . tb . array [  0  ]  . nestedIndexedBean . list . name \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ ROD . tb . array . nestedIndexedBean . list . name \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ ROD . array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ ROD . array [  0  ]  . nestedIndexedBean . list . name \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  4  ]  )  ;", "assertEquals (  \" NOT _ ROD . array . nestedIndexedBean . list . name \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  5  ]  )  ;", "assertEquals (  \" NOT _ ROD . name \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  6  ]  )  ;", "assertEquals (  \" NOT _ ROD . String \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  7  ]  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  . getCodes (  )  [  8  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBindingToNestedIndexedField"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod )  ;", "binder . setAllowedFields (  \" name \"  ,     \" myparam \"  )  ;", "binder . setDisallowedFields (  \" age \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "assertTrue (  \" did   not   change   age \"  ,     (  ( rod . getAge (  )  )     =  =     0  )  )  ;", "String [  ]    disallowedFields    =    binder . getBindingResult (  )  . getSuppressedFields (  )  ;", "assertEquals (  1  ,    disallowedFields . length )  ;", "assertEquals (  \" age \"  ,    disallowedFields [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithAllowedAndDisallowedFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod )  ;", "binder . setAllowedFields (  \" someMap [ key 1  ]  \"  ,     \" someMap [ key 2  ]  \"  )  ;", "binder . setDisallowedFields (  \" someMap [  ' key 3  '  ]  \"  ,     \" someMap [ key 4  ]  \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" someMap [ key 1  ]  \"  ,     \" value 1  \"  )  ;", "pvs . add (  \" someMap [  ' key 2  '  ]  \"  ,     \" value 2  \"  )  ;", "pvs . add (  \" someMap [ key 3  ]  \"  ,     \" value 3  \"  )  ;", "pvs . add (  \" someMap [  ' key 4  '  ]  \"  ,     \" value 4  \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertEquals (  \" value 1  \"  ,    rod . getSomeMap (  )  . get (  \" key 1  \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    rod . getSomeMap (  )  . get (  \" key 2  \"  )  )  ;", "assertNull ( rod . getSomeMap (  )  . get (  \" key 3  \"  )  )  ;", "assertNull ( rod . getSomeMap (  )  . get (  \" key 4  \"  )  )  ;", "String [  ]    disallowedFields    =    binder . getBindingResult (  )  . getSuppressedFields (  )  ;", "assertEquals (  2  ,    disallowedFields . length )  ;", "assertTrue ( ObjectUtils . containsElement ( disallowedFields ,     \" someMap [ key 3  ]  \"  )  )  ;", "assertTrue ( ObjectUtils . containsElement ( disallowedFields ,     \" someMap [ key 4  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithAllowedAndDisallowedMapFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod )  ;", "binder . setAllowedFields (  \" name \"  ,     \" myparam \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "assertTrue (  \" did   not   change   age \"  ,     (  ( rod . getAge (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithAllowedFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "binder . setAllowedFields (  \" nam *  \"  ,     \"  * ouchy \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" touchy \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertTrue (  \" changed   name   correctly \"  ,     \" Rod \"  . equals ( rod . getName (  )  )  )  ;", "assertTrue (  \" changed   touchy   correctly \"  ,     \" Rod \"  . equals ( rod . getTouchy (  )  )  )  ;", "assertTrue (  \" did   not   change   age \"  ,     (  ( rod . getAge (  )  )     =  =     0  )  )  ;", "String [  ]    disallowedFields    =    binder . getBindingResult (  )  . getSuppressedFields (  )  ;", "assertEquals (  1  ,    disallowedFields . length )  ;", "assertEquals (  \" age \"  ,    disallowedFields [  0  ]  )  ;", "Map <  ?  ,     ?  >    m    =    binder . getBindingResult (  )  . getModel (  )  ;", "assertTrue (  \" There   is   one   element   in   map \"  ,     (  ( m . size (  )  )     =  =     2  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( m . get (  \" person \"  )  )  )  ;", "assertTrue (  \" Same   object \"  ,    tb . equals ( rod )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithAllowedFieldsUsingAsterisks"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "BeanWithObjectProperty   tb    =    new   BeanWithObjectProperty (  )  ;", "binder    =    new    ( tb )  ;", "binder . registerCustomEditor ( Integer . class ,     \" object \"  ,    new   CustomNumberEditor ( Integer . class ,    true )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" object \"  ,     \"  1  \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals ( new   Integer (  1  )  ,    tb . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithCustomEditorOnObjectField"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "binder . addCustomFormatter ( new   NumberStyleFormatter (  )  ,    Float . class )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1  ,  2  \"  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "binder . bind ( pvs )  ;", "assertEquals ( new   Float (  1  .  2  )  ,    tb . getMyFloat (  )  )  ;", "assertEquals (  \"  1  ,  2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" myFloat \"  )  )  ;", "PropertyEditor   editor    =    binder . getBindingResult (  )  . findEditor (  \" myFloat \"  ,    Float . class )  ;", "assertNotNull ( editor )  ;", "editor . setValue ( new   Float (  1  .  4  )  )  ;", "assertEquals (  \"  1  ,  4  \"  ,    editor . getAsText (  )  )  ;", "editor    =    binder . getBindingResult (  )  . findEditor (  \" myFloat \"  ,    null )  ;", "assertNotNull ( editor )  ;", "editor . setAsText (  \"  1  ,  6  \"  )  ;", "assertTrue (  (  (  (  ( Number )     ( editor . getValue (  )  )  )  . floatValue (  )  )     =  =     1  .  6 F )  )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingWithCustomFormatter"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "assertTrue ( binder . isIgnoreUnknownFields (  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" jedi \"  ,     \" on \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertEquals (  \" Rod \"  ,    rod . getName (  )  )  ;", "assertTrue ( rod . isJedi (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithDefaultConversionNoErrors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod )  ;", "binder . setDisallowedFields (  \" age \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "assertTrue (  \" did   not   change   age \"  ,     (  ( rod . getAge (  )  )     =  =     0  )  )  ;", "String [  ]    disallowedFields    =    binder . getBindingResult (  )  . getSuppressedFields (  )  ;", "assertEquals (  1  ,    disallowedFields . length )  ;", "assertEquals (  \" age \"  ,    disallowedFields [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithDisallowedFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "pvs . add (  \" touchy \"  ,     \" m . y \"  )  ;", "binder . bind ( pvs )  ;", "try    {", "binder . close (  )  ;", "fail (  \" Should   have   thrown   BindException \"  )  ;", "}    catch    ( BindException   ex )     {", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "Map <  ?  ,     ?  >    map    =    binder . getBindingResult (  )  . getModel (  )  ;", "TestBean   tb    =     (  ( TestBean )     ( map . get (  \" person \"  )  )  )  ;", "assertTrue (  \" Same   object \"  ,    tb . equals ( rod )  )  ;", "BindingResult   br    =     (  ( BindingResult )     ( map . get (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +     \" person \"  )  )  )  )  ;", "assertSame ( br ,    BindingResultUtils . getBindingResult ( map ,     \" person \"  )  )  ;", "assertSame ( br ,    BindingResultUtils . getRequiredBindingResult ( map ,     \" person \"  )  )  ;", "assertNull ( BindingResultUtils . getBindingResult ( map ,     \" someOtherName \"  )  )  ;", "try    {", "BindingResultUtils . getRequiredBindingResult ( map ,     \" someOtherName \"  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   expected )     {", "}", "assertTrue (  \" Added   itself   to   map \"  ,     ( br    =  =     ( binder . getBindingResult (  )  )  )  )  ;", "assertTrue ( br . hasErrors (  )  )  ;", "assertTrue (  \" Correct   number   of   errors \"  ,     (  ( br . getErrorCount (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Has   age   errors \"  ,    br . hasFieldErrors (  \" age \"  )  )  ;", "assertTrue (  \" Correct   number   of   age   errors \"  ,     (  ( br . getFieldErrorCount (  \" age \"  )  )     =  =     1  )  )  ;", "assertEquals (  \"  3  2 x \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" age \"  )  )  ;", "FieldError   ageError    =    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  ;", "assertNotNull ( ageError )  ;", "assertEquals (  \" typeMismatch \"  ,    ageError . getCode (  )  )  ;", "assertEquals (  \"  3  2 x \"  ,    ageError . getRejectedValue (  )  )  ;", "assertTrue ( ageError . contains ( TypeMismatchException . class )  )  ;", "assertTrue ( ageError . contains ( NumberFormatException . class )  )  ;", "assertTrue ( ageError . unwrap ( NumberFormatException . class )  . getMessage (  )  . contains (  \"  3  2 x \"  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "assertTrue (  \" Has   touchy   errors \"  ,    br . hasFieldErrors (  \" touchy \"  )  )  ;", "assertTrue (  \" Correct   number   of   touchy   errors \"  ,     (  ( br . getFieldErrorCount (  \" touchy \"  )  )     =  =     1  )  )  ;", "assertEquals (  \" m . y \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" touchy \"  )  )  ;", "FieldError   touchyError    =    binder . getBindingResult (  )  . getFieldError (  \" touchy \"  )  ;", "assertNotNull ( touchyError )  ;", "assertEquals (  \" methodInvocation \"  ,    touchyError . getCode (  )  )  ;", "assertEquals (  \" m . y \"  ,    touchyError . getRejectedValue (  )  )  ;", "assertTrue ( touchyError . contains ( MethodInvocationException . class )  )  ;", "assertTrue ( touchyError . unwrap ( MethodInvocationException . class )  . getCause (  )  . getMessage (  )  . contains (  \" a    .  \"  )  )  ;", "assertNull ( tb . getTouchy (  )  )  ;", "rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "pvs . add (  \" touchy \"  ,     \" m . y \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals ( binder . getBindingResult (  )  ,    ex . getBindingResult (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingWithErrors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" touchy \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" prefix _  \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return   getValue (  )  . toString (  )  . substring (  7  )  ;", "}", "}  )  ;", "binder . registerCustomEditor ( TestBean . class ,     \" spouse \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean ( text ,     0  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "pvs . add (  \" touchy \"  ,     \" m . y \"  )  ;", "pvs . add (  \" spouse \"  ,     \" Kerry \"  )  ;", "binder . bind ( pvs )  ;", "try    {", "binder . close (  )  ;", "fail (  \" Should   have   thrown   BindException \"  )  ;", "}    catch    ( BindException   ex )     {", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "Map <  ?  ,     ?  >    model    =    binder . getBindingResult (  )  . getModel (  )  ;", "TestBean   tb    =     (  ( TestBean )     ( model . get (  \" person \"  )  )  )  ;", "assertTrue (  \" Same   object \"  ,    tb . equals ( rod )  )  ;", "BindingResult   br    =     (  ( BindingResult )     ( model . get (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +     \" person \"  )  )  )  )  ;", "assertTrue (  \" Added   itself   to   map \"  ,     ( br    =  =     ( binder . getBindingResult (  )  )  )  )  ;", "assertTrue ( br . hasErrors (  )  )  ;", "assertTrue (  \" Correct   number   of   errors \"  ,     (  ( br . getErrorCount (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Has   age   errors \"  ,    br . hasFieldErrors (  \" age \"  )  )  ;", "assertTrue (  \" Correct   number   of   age   errors \"  ,     (  ( br . getFieldErrorCount (  \" age \"  )  )     =  =     1  )  )  ;", "assertEquals (  \"  3  2 x \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" age \"  )  )  ;", "FieldError   ageError    =    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  ;", "assertNotNull ( ageError )  ;", "assertEquals (  \" typeMismatch \"  ,    ageError . getCode (  )  )  ;", "assertEquals (  \"  3  2 x \"  ,    ageError . getRejectedValue (  )  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "assertTrue (  \" Has   touchy   errors \"  ,    br . hasFieldErrors (  \" touchy \"  )  )  ;", "assertTrue (  \" Correct   number   of   touchy   errors \"  ,     (  ( br . getFieldErrorCount (  \" touchy \"  )  )     =  =     1  )  )  ;", "assertEquals (  \" m . y \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" touchy \"  )  )  ;", "FieldError   touchyError    =    binder . getBindingResult (  )  . getFieldError (  \" touchy \"  )  ;", "assertNotNull ( touchyError )  ;", "assertEquals (  \" methodInvocation \"  ,    touchyError . getCode (  )  )  ;", "assertEquals (  \" m . y \"  ,    touchyError . getRejectedValue (  )  )  ;", "assertNull ( tb . getTouchy (  )  )  ;", "assertTrue (  \" Does   not   have   spouse   errors \"  ,     (  !  ( br . hasFieldErrors (  \" spouse \"  )  )  )  )  ;", "assertEquals (  \" Kerry \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" spouse \"  )  )  ;", "assertNotNull ( tb . getSpouse (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingWithErrorsAndCustomEditors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "FormattingConversionService   conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . addFormatterForFieldType ( Float . class ,    new   NumberStyleFormatter (  )  )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1  ,  2  \"  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "binder . bind ( pvs )  ;", "assertEquals ( new   Float (  1  .  2  )  ,    tb . getMyFloat (  )  )  ;", "assertEquals (  \"  1  ,  2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" myFloat \"  )  )  ;", "PropertyEditor   editor    =    binder . getBindingResult (  )  . findEditor (  \" myFloat \"  ,    Float . class )  ;", "assertNotNull ( editor )  ;", "editor . setValue ( new   Float (  1  .  4  )  )  ;", "assertEquals (  \"  1  ,  4  \"  ,    editor . getAsText (  )  )  ;", "editor    =    binder . getBindingResult (  )  . findEditor (  \" myFloat \"  ,    null )  ;", "assertNotNull ( editor )  ;", "editor . setAsText (  \"  1  ,  6  \"  )  ;", "assertEquals ( new   Float (  1  .  6  )  ,    editor . getValue (  )  )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingWithFormatter"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb )  ;", "FormattingConversionService   conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . addFormatterForFieldType ( Float . class ,    new   NumberStyleFormatter (  )  )  ;", "binder . setConversionService ( conversionService )  ;", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1  ,  2  \"  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "binder . bind ( pvs )  ;", "assertEquals ( new   Float (  1  .  2  )  ,    tb . getMyFloat (  )  )  ;", "assertEquals (  \"  1  ,  2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" myFloat \"  )  )  ;", "PropertyEditor   editor    =    binder . getBindingResult (  )  . findEditor (  \" myFloat \"  ,    Float . class )  ;", "assertNotNull ( editor )  ;", "editor . setValue ( new   Float (  1  .  4  )  )  ;", "assertEquals (  \"  1  ,  4  \"  ,    editor . getAsText (  )  )  ;", "editor    =    binder . getBindingResult (  )  . findEditor (  \" myFloat \"  ,    null )  ;", "assertNotNull ( editor )  ;", "editor . setAsText (  \"  1  ,  6  \"  )  ;", "assertEquals ( new   Float (  1  .  6  )  ,    editor . getValue (  )  )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingWithFormatterAgainstFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "DataBinderTests . BeanWithIntegerList   tb    =    new   DataBinderTests . BeanWithIntegerList (  )  ;", "DataBinder   binder    =    new   DataBinder ( tb )  ;", "FormattingConversionService   conversionService    =    new   FormattingConversionService (  )  ;", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "conversionService . addFormatterForFieldType ( Float . class ,    new   NumberStyleFormatter (  )  )  ;", "binder . setConversionService ( conversionService )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" integerList [  0  ]  \"  ,     \"  1  \"  )  ;", "LocaleContextHolder . setLocale ( Locale . GERMAN )  ;", "try    {", "binder . bind ( pvs )  ;", "assertEquals ( new   Integer (  1  )  ,    tb . getIntegerList (  )  . get (  0  )  )  ;", "assertEquals (  \"  1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" integerList [  0  ]  \"  )  )  ;", "}    finally    {", "LocaleContextHolder . resetLocaleContext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingWithFormatterAgainstList"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" person \"  )  ;", "binder . registerCustomEditor ( ITestBean . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" spouse \"  ,     \" someValue \"  )  ;", "pvs . add (  \" spouse . name \"  ,     \" test \"  )  ;", "binder . bind ( pvs )  ;", "assertNotNull ( tb . getSpouse (  )  )  ;", "assertEquals (  \" test \"  ,    tb . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithNestedObjectCreation"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod )  ;", "binder . setAllowedFields (  \" name \"  ,     \" age \"  )  ;", "binder . setDisallowedFields (  \" age \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "pvs . add (  \" age \"  ,     \"  3  2 x \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertTrue (  \" changed   name   correctly \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "assertTrue (  \" did   not   change   age \"  ,     (  ( rod . getAge (  )  )     =  =     0  )  )  ;", "String [  ]    disallowedFields    =    binder . getBindingResult (  )  . getSuppressedFields (  )  ;", "assertEquals (  1  ,    disallowedFields . length )  ;", "assertEquals (  \" age \"  ,    disallowedFields [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithOverlappingAllowedAndDisallowedFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setSpouse ( new   TestBean (  )  )  ;", "binder    =    new    ( tb ,     \" person \"  )  ;", "binder . setRequiredFields (  \" touchy \"  ,     \" name \"  ,     \" age \"  ,     \" date \"  ,     \" spouse . name \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" touchy \"  ,     \"  \"  )  ;", "pvs . add (  \" name \"  ,    null )  ;", "pvs . add (  \" age \"  ,    null )  ;", "pvs . add (  \" spouse . name \"  ,     \"                 \"  )  ;", "binder . bind ( pvs )  ;", "BindingResult   br    =    binder . getBindingResult (  )  ;", "assertEquals (  \" Wrong   number   of   errors \"  ,     5  ,    br . getErrorCount (  )  )  ;", "assertEquals (  \" required \"  ,    br . getFieldError (  \" touchy \"  )  . getCode (  )  )  ;", "assertEquals (  \"  \"  ,    br . getFieldValue (  \" touchy \"  )  )  ;", "assertEquals (  \" required \"  ,    br . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \"  \"  ,    br . getFieldValue (  \" name \"  )  )  ;", "assertEquals (  \" required \"  ,    br . getFieldError (  \" age \"  )  . getCode (  )  )  ;", "assertEquals (  \"  \"  ,    br . getFieldValue (  \" age \"  )  )  ;", "assertEquals (  \" required \"  ,    br . getFieldError (  \" date \"  )  . getCode (  )  )  ;", "assertEquals (  \"  \"  ,    br . getFieldValue (  \" date \"  )  )  ;", "assertEquals (  \" required \"  ,    br . getFieldError (  \" spouse . name \"  )  . getCode (  )  )  ;", "assertEquals (  \"  \"  ,    br . getFieldValue (  \" spouse . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithRequiredFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setSpouse ( new   TestBean (  )  )  ;", "binder    =    new    ( tb ,     \" person \"  )  ;", "binder . setRequiredFields (  \" someMap [ key 1  ]  \"  ,     \" someMap [ key 2  ]  \"  ,     \" someMap [  ' key 3  '  ]  \"  ,     \" someMap [ key 4  ]  \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" someMap [ key 1  ]  \"  ,     \" value 1  \"  )  ;", "pvs . add (  \" someMap [  ' key 2  '  ]  \"  ,     \" value 2  \"  )  ;", "pvs . add (  \" someMap [ key 3  ]  \"  ,     \" value 3  \"  )  ;", "binder . bind ( pvs )  ;", "BindingResult   br    =    binder . getBindingResult (  )  ;", "assertEquals (  \" Wrong   number   of   errors \"  ,     1  ,    br . getErrorCount (  )  )  ;", "assertEquals (  \" required \"  ,    br . getFieldError (  \" someMap [ key 4  ]  \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithRequiredMapFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "TestBean   tb 1     =    new   TestBean (  \" tb 1  \"  ,     9  9  )  ;", "TestBean   tb 2     =    new   TestBean (  \" tb 2  \"  ,     9  9  )  ;", "pvs . add (  \" list [  0  ]  \"  ,    tb 1  )  ;", "pvs . add (  \" list [  1  ]  \"  ,    tb 2  )  ;", "binder . bind ( pvs )  ;", "assertEquals ( tb 1  . getName (  )  ,    binder . getBindingResult (  )  . getFieldValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals ( tb 2  . getName (  )  ,    binder . getBindingResult (  )  . getFieldValue (  \" list [  1  ]  . name \"  )  )  ;", "tb . getList (  )  . set (  0  ,    tb 2  )  ;", "tb . getList (  )  . set (  1  ,    tb 1  )  ;", "assertEquals ( tb 2  . getName (  )  ,    binder . getBindingResult (  )  . getFieldValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals ( tb 1  . getName (  )  ,    binder . getBindingResult (  )  . getFieldValue (  \" list [  1  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithResortedList"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean (  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" class . classLoader . URLs [  0  ]  \"  ,     \" http :  /  / myserver \"  )  ;", "binder . setIgnoreUnknownFields ( false )  ;", "try    {", "binder . bind ( pvs )  ;", "fail (  \" Should   have   thrown   NotWritablePropertyException \"  )  ;", "}    catch    ( NotWritablePropertyException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" classLoader \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBindingWithSystemFieldError"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage (  \"    is   already   initialized   with   MessageCodesResolver \"  )  ;", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "binder . setMessageCodesResolver ( new   DefaultMessageCodesResolver (  )  )  ;", "binder . setMessageCodesResolver ( new   DefaultMessageCodesResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCallSetMessageCodesResolverTwice"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "DataBinder   dataBinder    =    new   DataBinder ( null )  ;", "DefaultFormattingConversionService   conversionService    =    new   DefaultFormattingConversionService (  )  ;", "dataBinder . setConversionService ( conversionService )  ;", "dataBinder . registerCustomEditor ( String . class ,    new   StringTrimmerEditor ( true )  )  ;", ". NameBean   bean    =    new    . NameBean (  \" Fred \"  )  ;", "assertEquals (  \" ConversionService   should   have   invoked   toString (  )  \"  ,     \" Fred \"  ,    dataBinder . convertIfNecessary ( bean ,    String . class )  )  ;", "conversionService . addConverter ( new    . NameBeanConverter (  )  )  ;", "assertEquals (  \" Type   converter   should   have   been   used \"  ,     \"  [ Fred ]  \"  ,    dataBinder . convertIfNecessary ( bean ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testConversionWithInappropriateStringEditor"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,    null ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" prefix \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( String )     ( getValue (  )  )  )  . substring (  6  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" value \"  )  ;", "pvs . add (  \" touchy \"  ,     \" value \"  )  ;", "binder . bind ( pvs )  ;", "binder . getBindingResult (  )  . rejectValue (  \" name \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "binder . getBindingResult (  )  . rejectValue (  \" touchy \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" name \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    binder . getBindingResult (  )  . getFieldError (  \" name \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" touchy \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    binder . getBindingResult (  )  . getFieldError (  \" touchy \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorForAllStringProperties"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( int . class ,     \" age \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   Integer (  9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    \" argh \"  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \"  \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" argh \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" age \"  )  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorForPrimitiveProperty"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setSpouse ( new   TestBean (  )  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" prefix \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( String )     ( getValue (  )  )  )  . substring (  6  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" value \"  )  ;", "pvs . add (  \" touchy \"  ,     \" value \"  )  ;", "pvs . add (  \" spouse . name \"  ,     \" sue \"  )  ;", "binder . bind ( pvs )  ;", "binder . getBindingResult (  )  . rejectValue (  \" name \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "binder . getBindingResult (  )  . rejectValue (  \" touchy \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "binder . getBindingResult (  )  . rejectValue (  \" spouse . name \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "assertEquals (  \"  \"  ,    binder . getBindingResult (  )  . getNestedPath (  )  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" name \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    binder . getBindingResult (  )  . getFieldError (  \" name \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" touchy \"  )  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldError (  \" touchy \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" value \"  ,    tb . getTouchy (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" spouse .  *  \"  )  )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getFieldErrorCount (  \" spouse .  *  \"  )  )  ;", "assertEquals (  \" spouse . name \"  ,    binder . getBindingResult (  )  . getFieldError (  \" spouse .  *  \"  )  . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorForSingleProperty"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,    null ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "if    (  (  ( getValue (  )  )     =  =    null )     |  |     (  !  ( text . equalsIgnoreCase ( getValue (  )  . toString (  )  )  )  )  )     {", "setValue ( text )  ;", "}", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" value \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" value \"  ,    tb . getName (  )  )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" vaLue \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" value \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorWithOldValueAccess"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( TestBean . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "DerivedTestBean   tb    =    new   DerivedTestBean (  )  ;", "tb . setName (  (  \" array \"     +    text )  )  ;", "setValue ( tb )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  \"  ,     \" a \"  )  ;", "binder . bind ( pvs )  ;", "Errors   errors    =    binder . getBindingResult (  )  ;", "errors . rejectValue (  \" array [  0  ]  \"  ,     \" NOT _ ROD \"  ,     \" are   you   sure   you ' re   not   Rod ?  \"  )  ;", "assertEquals (  \" arraya \"  ,    errors . getFieldValue (  \" array [  0  ]  \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" array [  0  ]  \"  )  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ ROD . tb . array [  0  ]  \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ ROD . tb . array \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ ROD . array [  0  ]  \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ ROD . array \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ ROD . tests . sample . beans . DerivedTestBean \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  4  ]  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  5  ]  )  ;", "assertEquals (  \" arraya \"  ,    errors . getFieldValue (  \" array [  0  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorWithSubclass"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . addCustomFormatter ( new   Formatter < String >  (  )     {", "@ Override", "public   String   parse ( String   text ,    Locale   locale )    throws   ParseException    {", "return    \" prefix \"     +    text ;", "}", "@ Override", "public   String   print ( String   object ,    Locale   locale )     {", "return   object . substring (  6  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" value \"  )  ;", "pvs . add (  \" touchy \"  ,     \" value \"  )  ;", "binder . bind ( pvs )  ;", "binder . getBindingResult (  )  . rejectValue (  \" name \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "binder . getBindingResult (  )  . rejectValue (  \" touchy \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" name \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    binder . getBindingResult (  )  . getFieldError (  \" name \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" touchy \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    binder . getBindingResult (  )  . getFieldError (  \" touchy \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomFormatterForAllStringProperties"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . addCustomFormatter ( new   Formatter < Integer >  (  )     {", "@ Override", "public   Integer   parse ( String   text ,    Locale   locale )    throws   ParseException    {", "return    9  9  ;", "}", "@ Override", "public   String   print ( Integer   object ,    Locale   locale )     {", "return    \" argh \"  ;", "}", "}  ,     \" age \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \" x \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" argh \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" age \"  )  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomFormatterForPrimitiveProperty"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setSpouse ( new   TestBean (  )  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . addCustomFormatter ( new   Formatter < String >  (  )     {", "@ Override", "public   String   parse ( String   text ,    Locale   locale )    throws   ParseException    {", "return    \" prefix \"     +    text ;", "}", "@ Override", "public   String   print ( String   object ,    Locale   locale )     {", "return   object . substring (  6  )  ;", "}", "}  ,     \" name \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" value \"  )  ;", "pvs . add (  \" touchy \"  ,     \" value \"  )  ;", "pvs . add (  \" spouse . name \"  ,     \" sue \"  )  ;", "binder . bind ( pvs )  ;", "binder . getBindingResult (  )  . rejectValue (  \" name \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "binder . getBindingResult (  )  . rejectValue (  \" touchy \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "binder . getBindingResult (  )  . rejectValue (  \" spouse . name \"  ,     \" someCode \"  ,     \" someMessage \"  )  ;", "assertEquals (  \"  \"  ,    binder . getBindingResult (  )  . getNestedPath (  )  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" name \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    binder . getBindingResult (  )  . getFieldError (  \" name \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" touchy \"  )  )  ;", "assertEquals (  \" value \"  ,    binder . getBindingResult (  )  . getFieldError (  \" touchy \"  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" value \"  ,    tb . getTouchy (  )  )  ;", "assertTrue ( binder . getBindingResult (  )  . hasFieldErrors (  \" spouse .  *  \"  )  )  ;", "assertEquals (  1  ,    binder . getBindingResult (  )  . getFieldErrorCount (  \" spouse .  *  \"  )  )  ;", "assertEquals (  \" spouse . name \"  ,    binder . getBindingResult (  )  . getFieldError (  \" spouse .  *  \"  )  . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomFormatterForSingleProperty"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( TestBean . class ,     \" map \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "DerivedTestBean   tb    =    new   DerivedTestBean (  )  ;", "tb . setName (  (  \" array \"     +    text )  )  ;", "setValue ( tb )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "Errors   errors    =    binder . getBindingResult (  )  ;", "errors . rejectValue (  \" map [ key 0  ]  \"  ,     \" NOT _ NULL \"  ,     \" should   not   be   null \"  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" map [ key 0  ]  \"  )  )  ;", "assertEquals (  \" NOT _ NULL \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ NULL . tb . map [ key 0  ]  \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ NULL . tb . map \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ NULL . map [ key 0  ]  \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ NULL . map \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ NULL . tests . sample . beans . TestBean \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  4  ]  )  ;", "assertEquals (  \" NOT _ NULL \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  5  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDirectBindingToEmptyIndexedFieldWithRegisteredGenericEditor"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( TestBean . class ,     \" map [ key 0  ]  \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "DerivedTestBean   tb    =    new   DerivedTestBean (  )  ;", "tb . setName (  (  \" array \"     +    text )  )  ;", "setValue ( tb )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "Errors   errors    =    binder . getBindingResult (  )  ;", "errors . rejectValue (  \" map [ key 0  ]  \"  ,     \" NOT _ NULL \"  ,     \" should   not   be   null \"  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" map [ key 0  ]  \"  )  )  ;", "assertEquals (  \" NOT _ NULL \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ NULL . tb . map [ key 0  ]  \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ NULL . tb . map \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ NULL . map [ key 0  ]  \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ NULL . map \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ NULL . tests . sample . beans . TestBean \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  4  ]  )  ;", "assertEquals (  \" NOT _ NULL \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  5  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDirectBindingToEmptyIndexedFieldWithRegisteredSpecificEditor"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "DataBinder   binder    =    new   DataBinder ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( TestBean . class ,     \" array \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "DerivedTestBean   tb    =    new   DerivedTestBean (  )  ;", "tb . setName (  (  \" array \"     +    text )  )  ;", "setValue ( tb )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  \"  ,     \" a \"  )  ;", "binder . bind ( pvs )  ;", "Errors   errors    =    binder . getBindingResult (  )  ;", "errors . rejectValue (  \" array [  0  ]  \"  ,     \" NOT _ ROD \"  ,     \" are   you   sure   you ' re   not   Rod ?  \"  )  ;", "errors . rejectValue (  \" map [ key 1  ]  \"  ,     \" NOT _ ROD \"  ,     \" are   you   sure   you ' re   not   Rod ?  \"  )  ;", "errors . rejectValue (  \" map [ key 0  ]  \"  ,     \" NOT _ NULL \"  ,     \" should   not   be   null \"  )  ;", "assertEquals (  \" arraya \"  ,    errors . getFieldValue (  \" array [  0  ]  \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" array [  0  ]  \"  )  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ ROD . tb . array [  0  ]  \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ ROD . tb . array \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ ROD . array [  0  ]  \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ ROD . array \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ ROD . tests . sample . beans . DerivedTestBean \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  4  ]  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" array [  0  ]  \"  )  . getCodes (  )  [  5  ]  )  ;", "assertEquals (  \" arraya \"  ,    errors . getFieldValue (  \" array [  0  ]  \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" map [ key 1  ]  \"  )  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" map [ key 1  ]  \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ ROD . tb . map [ key 1  ]  \"  ,    errors . getFieldError (  \" map [ key 1  ]  \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ ROD . tb . map \"  ,    errors . getFieldError (  \" map [ key 1  ]  \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ ROD . map [ key 1  ]  \"  ,    errors . getFieldError (  \" map [ key 1  ]  \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ ROD . map \"  ,    errors . getFieldError (  \" map [ key 1  ]  \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ ROD . tests . sample . beans . TestBean \"  ,    errors . getFieldError (  \" map [ key 1  ]  \"  )  . getCodes (  )  [  4  ]  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" map [ key 1  ]  \"  )  . getCodes (  )  [  5  ]  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" map [ key 0  ]  \"  )  )  ;", "assertEquals (  \" NOT _ NULL \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ NULL . tb . map [ key 0  ]  \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ NULL . tb . map \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ NULL . map [ key 0  ]  \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ NULL . map \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" NOT _ NULL \"  ,    errors . getFieldError (  \" map [ key 0  ]  \"  )  . getCodes (  )  [  4  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDirectBindingToIndexedField"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "tb . getArray (  )  [  0  ]  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb . getArray (  )  [  1  ]  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" array . nestedIndexedBean . list . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( String )     ( getValue (  )  )  )  . substring (  4  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,     \" test 1  \"  )  ;", "pvs . add (  \" array [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  ,     \" test 2  \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" listtest 1  \"  ,     (  ( TestBean )     ( tb . getArray (  )  [  0  ]  . getNestedIndexedBean (  )  . getList (  )  . get (  0  )  )  )  . getName (  )  )  ;", "assertEquals (  \" listtest 2  \"  ,     (  ( TestBean )     ( tb . getArray (  )  [  1  ]  . getNestedIndexedBean (  )  . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" test 1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" test 2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" array [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testEditorForNestedIndexedField"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "assertNull ( binder . getBindingResult (  )  . getGlobalError (  )  )  ;", "assertNull ( binder . getBindingResult (  )  . getFieldError (  )  )  ;", "assertNull ( binder . getBindingResult (  )  . getFieldError (  \"  \"  )  )  ;", "MutablePropertyValues   mpv    =    new   MutablePropertyValues (  )  ;", "mpv . add (  \" age \"  ,     \" invalid \"  )  ;", "binder . bind ( mpv )  ;", "assertNull ( binder . getBindingResult (  )  . getGlobalError (  )  )  ;", "assertNull ( binder . getBindingResult (  )  . getFieldError (  \"  \"  )  )  ;", "assertNull ( binder . getBindingResult (  )  . getFieldError (  \" b *  \"  )  )  ;", "assertEquals (  \" age \"  ,    binder . getBindingResult (  )  . getFieldError (  )  . getField (  )  )  ;", "assertEquals (  \" age \"  ,    binder . getBindingResult (  )  . getFieldError (  \"  *  \"  )  . getField (  )  )  ;", "assertEquals (  \" age \"  ,    binder . getBindingResult (  )  . getFieldError (  \" a *  \"  )  . getField (  )  )  ;", "assertEquals (  \" age \"  ,    binder . getBindingResult (  )  . getFieldError (  \" ag *  \"  )  . getField (  )  )  ;", "assertEquals (  \" age \"  ,    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldErrorAccessVariations"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "tb . getArray (  )  [  0  ]  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb . getArray (  )  [  1  ]  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" array . nestedIndexedBean . list [  0  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( String )     ( getValue (  )  )  )  . substring (  4  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,     \" test 1  \"  )  ;", "pvs . add (  \" array [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  ,     \" test 2  \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" listtest 1  \"  ,     (  ( TestBean )     ( tb . getArray (  )  [  0  ]  . getNestedIndexedBean (  )  . getList (  )  . get (  0  )  )  )  . getName (  )  )  ;", "assertEquals (  \" test 2  \"  ,     (  ( TestBean )     ( tb . getArray (  )  [  1  ]  . getNestedIndexedBean (  )  . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" test 1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" test 2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" array [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testInnerSpecificEditorForNestedIndexedField"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "DataBinderTests . Book   book    =    new   DataBinderTests . Book (  )  ;", "DataBinder   binder    =    new   DataBinder ( book )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" title \"  ,     \" my   book \"  )  ;", "pvs . add (  \" ISBN \"  ,     \"  1  2  3  4  \"  )  ;", "pvs . add (  \" NInStock \"  ,     \"  5  \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" my   book \"  ,    book . getTitle (  )  )  ;", "assertEquals (  \"  1  2  3  4  \"  ,    book . getISBN (  )  )  ;", "assertEquals (  5  ,    book . getNInStock (  )  )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" Title \"  ,     \" my   other   book \"  )  ;", "pvs . add (  \" iSBN \"  ,     \"  6  7  8  9  \"  )  ;", "pvs . add (  \" nInStock \"  ,     \"  0  \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" my   other   book \"  ,    book . getTitle (  )  )  ;", "assertEquals (  \"  6  7  8  9  \"  ,    book . getISBN (  )  )  ;", "assertEquals (  0  ,    book . getNInStock (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJavaBeanPropertyConventions"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =    new   TestBean ( new   TestBean (  )  )  ;", "binder    =    new    ( rod ,     \" person \"  )  ;", "assertTrue ( binder . isIgnoreUnknownFields (  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" spouse . name \"  ,     \" Kerry \"  )  ;", "pvs . add (  \" spouse . jedi \"  ,     \" on \"  )  ;", "binder . bind ( pvs )  ;", "binder . close (  )  ;", "assertEquals (  \" Kerry \"  ,    rod . getSpouse (  )  . getName (  )  )  ;", "assertTrue (  (  ( TestBean )     ( rod . getSpouse (  )  )  )  . isJedi (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedBindingWithDefaultConversionNoErrors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "DataBinderTests . Form   form    =    new   DataBinderTests . Form (  )  ;", "DataBinder   binder    =    new   DataBinder ( form ,     \" form \"  )  ;", "MutablePropertyValues   mpv    =    new   MutablePropertyValues (  )  ;", "mpv . add (  \" f [ list ]  [  0  ]  \"  ,     \" firstValue \"  )  ;", "mpv . add (  \" f [ list ]  [  1  ]  \"  ,     \" secondValue \"  )  ;", "binder . bind ( mpv )  ;", "assertFalse ( binder . getBindingResult (  )  . hasErrors (  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < Object >    list    =     (  ( List < Object >  )     ( form . getF (  )  . get (  \" list \"  )  )  )  ;", "assertEquals (  \" firstValue \"  ,    list . get (  0  )  )  ;", "assertEquals (  \" secondValue \"  ,    list . get (  1  )  )  ;", "assertEquals (  2  ,    list . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedGrowingList"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \" XXX \"  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "Validator   spouseValidator    =    new    . SpouseValidator (  )  ;", "spouseValidator . validate ( tb ,    errors )  ;", "assertTrue ( errors . hasGlobalErrors (  )  )  ;", "assertEquals (  1  ,    errors . getGlobalErrorCount (  )  )  ;", "assertEquals (  \" SPOUSE _ NOT _ AVAILABLE \"  ,    errors . getGlobalError (  )  . getCode (  )  )  ;", "assertEquals (  \" tb \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getObjectName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedValidatorWithoutNestedPath"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "DataBinderTests . OptionalHolder   bean    =    new   DataBinderTests . OptionalHolder (  )  ;", "DataBinder   binder    =    new   DataBinder ( bean )  ;", "binder . setConversionService ( new   DefaultConversionService (  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" id \"  ,     \"  1  \"  )  ;", "pvs . add (  \" name \"  ,    null )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \"  1  \"  ,    bean . getId (  )  )  ;", "assertFalse ( bean . getName (  )  . isPresent (  )  )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" id \"  ,     \"  2  \"  )  ;", "pvs . add (  \" name \"  ,     \" myName \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \"  2  \"  ,    bean . getId (  )  )  ;", "assertEquals (  \" myName \"  ,    bean . getName (  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalProperty"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \" myName \"  )  ;", "tb . setAge (  9  9  )  ;", "BeanPropertyBindingResult   ex    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "ex . reject (  \" in \"  )  ;", "ex . rejectValue (  \" age \"  ,     \" inField \"  )  ;", "StaticMessageSource   ms    =    new   StaticMessageSource (  )  ;", "ms . addMessage (  \" in \"  ,    Locale . US ,     \" general   error \"  )  ;", "ms . addMessage (  \" inField \"  ,    Locale . US ,     \" in   field \"  )  ;", "assertEquals (  \" general   error \"  ,    ms . getMessage ( ex . getGlobalError (  )  ,    Locale . US )  )  ;", "assertEquals (  \" in   field \"  ,    ms . getMessage ( ex . getFieldError (  \" age \"  )  ,    Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectWithoutDefaultMessage"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "DataBinderTests . BeanWithIntegerList   tb    =    new   DataBinderTests . BeanWithIntegerList (  )  ;", "DataBinder   binder    =    new   DataBinder ( tb )  ;", "binder . setAutoGrowCollectionLimit (  2  5  7  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" integerList [  2  5  6  ]  \"  ,     \"  1  \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  2  5  7  ,    tb . getIntegerList (  )  . size (  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    tb . getIntegerList (  )  . get (  2  5  6  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    binder . getBindingResult (  )  . getFieldValue (  \" integerList [  2  5  6  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAutoGrowCollectionLimit"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "expectedException . expect ( IllegalStateException . class )  ;", "expectedException . expectMessage (  \" DataBinder   is   already   initialized    -    call   setAutoGrowCollectionLimit   before   other   configuration   methods \"  )  ;", "DataBinder   binder    =    new   DataBinder ( new    . BeanWithIntegerList (  )  )  ;", "binder . registerCustomEditor ( String . class ,    new   StringTrimmerEditor ( true )  )  ;", "binder . setAutoGrowCollectionLimit (  2  5  7  )  ;", "}", "METHOD_END"], "methodName": ["testSetAutoGrowCollectionLimitAfterInitialization"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "binder . initBeanPropertyAccess (  )  ;", "DefaultMessageCodesResolver   messageCodesResolver    =    new   DefaultMessageCodesResolver (  )  ;", "messageCodesResolver . setPrefix (  \" errors .  \"  )  ;", "binder . setMessageCodesResolver ( messageCodesResolver )  ;", "MutablePropertyValues   mpv    =    new   MutablePropertyValues (  )  ;", "mpv . add (  \" age \"  ,     \" invalid \"  )  ;", "binder . bind ( mpv )  ;", "assertEquals (  \" errors . typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetCustomMessageCodesResolverAfterInitializeBindingResult"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "DefaultMessageCodesResolver   messageCodesResolver    =    new   DefaultMessageCodesResolver (  )  ;", "messageCodesResolver . setPrefix (  \" errors .  \"  )  ;", "binder . setMessageCodesResolver ( messageCodesResolver )  ;", "binder . setAutoGrowCollectionLimit (  5  1  2  )  ;", "binder . initBeanPropertyAccess (  )  ;", "MutablePropertyValues   mpv    =    new   MutablePropertyValues (  )  ;", "mpv . add (  \" age \"  ,     \" invalid \"  )  ;", "binder . bind ( mpv )  ;", "assertEquals (  \" errors . typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  . getCode (  )  )  ;", "assertEquals (  5  1  2  ,    BeanWrapper . class . cast ( binder . getInternalBindingResult (  )  . getPropertyAccessor (  )  )  . getAutoGrowCollectionLimit (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetCustomMessageCodesResolverBeforeInitializeBindingResultForBeanPropertyAccess"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "DefaultMessageCodesResolver   messageCodesResolver    =    new   DefaultMessageCodesResolver (  )  ;", "messageCodesResolver . setPrefix (  \" errors .  \"  )  ;", "binder . setMessageCodesResolver ( messageCodesResolver )  ;", "binder . initDirectFieldAccess (  )  ;", "MutablePropertyValues   mpv    =    new   MutablePropertyValues (  )  ;", "mpv . add (  \" age \"  ,     \" invalid \"  )  ;", "binder . bind ( mpv )  ;", "assertEquals (  \" errors . typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetCustomMessageCodesResolverBeforeInitializeBindingResultForDirectFieldAccess"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "binder . initBeanPropertyAccess (  )  ;", "binder . setMessageCodesResolver ( null )  ;", "MutablePropertyValues   mpv    =    new   MutablePropertyValues (  )  ;", "mpv . add (  \" age \"  ,     \" invalid \"  )  ;", "binder . bind ( mpv )  ;", "assertEquals (  \" typeMismatch \"  ,    binder . getBindingResult (  )  . getFieldError (  \" age \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetMessageCodesResolverIsNullAfterInitializeBindingResult"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "tb . getArray (  )  [  0  ]  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb . getArray (  )  [  1  ]  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "binder    =    new    ( tb ,     \" tb \"  )  ;", "binder . registerCustomEditor ( String . class ,     \" array [  0  ]  . nestedIndexedBean . list . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( String )     ( getValue (  )  )  )  . substring (  4  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,     \" test 1  \"  )  ;", "pvs . add (  \" array [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  ,     \" test 2  \"  )  ;", "binder . bind ( pvs )  ;", "assertEquals (  \" listtest 1  \"  ,     (  ( TestBean )     ( tb . getArray (  )  [  0  ]  . getNestedIndexedBean (  )  . getList (  )  . get (  0  )  )  )  . getName (  )  )  ;", "assertEquals (  \" test 2  \"  ,     (  ( TestBean )     ( tb . getArray (  )  [  1  ]  . getNestedIndexedBean (  )  . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" test 1  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" array [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" test 2  \"  ,    binder . getBindingResult (  )  . getFieldValue (  \" array [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecificEditorForNestedIndexedField"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean    =    new   TestBean (  )  ;", "binder    =    new    ( testBean ,     \" testBean \"  )  ;", "binder . setAllowedFields (  \" name \"  ,     \" age \"  )  ;", "String   name    =     \" Rob   Harrop \"  ;", "String   beanName    =     \" foobar \"  ;", "MutablePropertyValues   mpvs    =    new   MutablePropertyValues (  )  ;", "mpvs . add (  \" name \"  ,    name )  ;", "mpvs . add (  \" beanName \"  ,    beanName )  ;", "binder . bind ( mpvs )  ;", "assertEquals ( name ,    testBean . getName (  )  )  ;", "String [  ]    disallowedFields    =    binder . getBindingResult (  )  . getSuppressedFields (  )  ;", "assertEquals (  1  ,    disallowedFields . length )  ;", "assertEquals (  \" beanName \"  ,    disallowedFields [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testTrackDisallowedFields"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setAge (  3  3  )  ;", "tb . setName (  \" Rod \"  )  ;", "try    {", "tb . setTouchy (  \" Rod \"  )  ;", "}    catch    ( Exception   e )     {", "fail (  \" Should   not   throw   any   Exception \"  )  ;", "}", "TestBean   tb 2     =    new   TestBean (  )  ;", "tb 2  . setAge (  3  4  )  ;", "tb . setSpouse ( tb 2  )  ;", "DataBinder   db    =    new   DataBinder ( tb ,     \" tb \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" spouse . age \"  ,     \" argh \"  )  ;", "db . bind ( pvs )  ;", "Errors   errors    =    db . getBindingResult (  )  ;", "Validator   testValidator    =    new    . TestBeanValidator (  )  ;", "testValidator . validate ( tb ,    errors )  ;", "errors . setNestedPath (  \" spouse \"  )  ;", "assertEquals (  \" spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "assertEquals (  \" argh \"  ,    errors . getFieldValue (  \" age \"  )  )  ;", "Validator   spouseValidator    =    new    . SpouseValidator (  )  ;", "spouseValidator . validate ( tb . getSpouse (  )  ,    errors )  ;", "errors . setNestedPath (  \"  \"  )  ;", "assertEquals (  \"  \"  ,    errors . getNestedPath (  )  )  ;", "errors . pushNestedPath (  \" spouse \"  )  ;", "assertEquals (  \" spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "errors . pushNestedPath (  \" spouse \"  )  ;", "assertEquals (  \" spouse . spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "errors . popNestedPath (  )  ;", "assertEquals (  \" spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "errors . popNestedPath (  )  ;", "assertEquals (  \"  \"  ,    errors . getNestedPath (  )  )  ;", "try    {", "errors . popNestedPath (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "errors . pushNestedPath (  \" spouse \"  )  ;", "assertEquals (  \" spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "errors . setNestedPath (  \"  \"  )  ;", "assertEquals (  \"  \"  ,    errors . getNestedPath (  )  )  ;", "try    {", "errors . popNestedPath (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "errors . pushNestedPath (  \" spouse \"  )  ;", "assertEquals (  \" spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "assertEquals (  1  ,    errors . getErrorCount (  )  )  ;", "assertTrue (  (  !  ( errors . hasGlobalErrors (  )  )  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" age \"  )  )  ;", "assertTrue (  (  !  ( errors . hasFieldErrors (  \" name \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidatorNoErrors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setSpouse ( new   TestBean (  )  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "Validator   testValidator    =    new    . TestBeanValidator (  )  ;", "testValidator . validate ( tb ,    errors )  ;", "errors . setNestedPath (  \" spouse .  \"  )  ;", "assertEquals (  \" spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "Validator   spouseValidator    =    new    . SpouseValidator (  )  ;", "spouseValidator . validate ( tb . getSpouse (  )  ,    errors )  ;", "errors . setNestedPath (  \"  \"  )  ;", "assertTrue ( errors . hasErrors (  )  )  ;", "assertEquals (  6  ,    errors . getErrorCount (  )  )  ;", "assertEquals (  2  ,    errors . getGlobalErrorCount (  )  )  ;", "assertEquals (  \" NAME _ TOUCHY _ MISMATCH \"  ,    errors . getGlobalError (  )  . getCode (  )  )  ;", "assertEquals (  \" NAME _ TOUCHY _ MISMATCH \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getCode (  )  )  ;", "assertEquals (  \" NAME _ TOUCHY _ MISMATCH . tb \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NAME _ TOUCHY _ MISMATCH \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" tb \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getObjectName (  )  )  ;", "assertEquals (  \" GENERAL _ ERROR \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getCode (  )  )  ;", "assertEquals (  \" GENERAL _ ERROR . tb \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" GENERAL _ ERROR \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" msg \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getDefaultMessage (  )  )  ;", "assertEquals (  \" arg \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getArguments (  )  [  0  ]  )  ;", "assertTrue ( errors . hasFieldErrors (  )  )  ;", "assertEquals (  4  ,    errors . getFieldErrorCount (  )  )  ;", "assertEquals (  \" TOO _ YOUNG \"  ,    errors . getFieldError (  )  . getCode (  )  )  ;", "assertEquals (  \" TOO _ YOUNG \"  ,    errors . getFieldErrors (  )  . get (  0  )  . getCode (  )  )  ;", "assertEquals (  \" age \"  ,    errors . getFieldErrors (  )  . get (  0  )  . getField (  )  )  ;", "assertEquals (  \" AGE _ NOT _ ODD \"  ,    errors . getFieldErrors (  )  . get (  1  )  . getCode (  )  )  ;", "assertEquals (  \" age \"  ,    errors . getFieldErrors (  )  . get (  1  )  . getField (  )  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldErrors (  )  . get (  2  )  . getCode (  )  )  ;", "assertEquals (  \" name \"  ,    errors . getFieldErrors (  )  . get (  2  )  . getField (  )  )  ;", "assertEquals (  \" TOO _ YOUNG \"  ,    errors . getFieldErrors (  )  . get (  3  )  . getCode (  )  )  ;", "assertEquals (  \" spouse . age \"  ,    errors . getFieldErrors (  )  . get (  3  )  . getField (  )  )  ;", "assertTrue ( errors . hasFieldErrors (  \" age \"  )  )  ;", "assertEquals (  2  ,    errors . getFieldErrorCount (  \" age \"  )  )  ;", "assertEquals (  \" TOO _ YOUNG \"  ,    errors . getFieldError (  \" age \"  )  . getCode (  )  )  ;", "assertEquals (  \" TOO _ YOUNG \"  ,    errors . getFieldErrors (  \" age \"  )  . get (  0  )  . getCode (  )  )  ;", "assertEquals (  \" tb \"  ,    errors . getFieldErrors (  \" age \"  )  . get (  0  )  . getObjectName (  )  )  ;", "assertEquals (  \" age \"  ,    errors . getFieldErrors (  \" age \"  )  . get (  0  )  . getField (  )  )  ;", "assertEquals ( new   Integer (  0  )  ,    errors . getFieldErrors (  \" age \"  )  . get (  0  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" AGE _ NOT _ ODD \"  ,    errors . getFieldErrors (  \" age \"  )  . get (  1  )  . getCode (  )  )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" name \"  )  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" NOT _ ROD . tb . name \"  ,    errors . getFieldError (  \" name \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" NOT _ ROD . name \"  ,    errors . getFieldError (  \" name \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" NOT _ ROD . String \"  ,    errors . getFieldError (  \" name \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" NOT _ ROD \"  ,    errors . getFieldError (  \" name \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" name \"  ,    errors . getFieldErrors (  \" name \"  )  . get (  0  )  . getField (  )  )  ;", "assertEquals ( null ,    errors . getFieldErrors (  \" name \"  )  . get (  0  )  . getRejectedValue (  )  )  ;", "assertTrue ( errors . hasFieldErrors (  \" spouse . age \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" spouse . age \"  )  )  ;", "assertEquals (  \" TOO _ YOUNG \"  ,    errors . getFieldError (  \" spouse . age \"  )  . getCode (  )  )  ;", "assertEquals (  \" tb \"  ,    errors . getFieldErrors (  \" spouse . age \"  )  . get (  0  )  . getObjectName (  )  )  ;", "assertEquals ( new   Integer (  0  )  ,    errors . getFieldErrors (  \" spouse . age \"  )  . get (  0  )  . getRejectedValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidatorWithErrors"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setSpouse ( new   TestBean (  )  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "DefaultMessageCodesResolver   codesResolver    =    new   DefaultMessageCodesResolver (  )  ;", "codesResolver . setPrefix (  \" validation .  \"  )  ;", "errors . setMessageCodesResolver ( codesResolver )  ;", "Validator   testValidator    =    new    . TestBeanValidator (  )  ;", "testValidator . validate ( tb ,    errors )  ;", "errors . setNestedPath (  \" spouse .  \"  )  ;", "assertEquals (  \" spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "Validator   spouseValidator    =    new    . SpouseValidator (  )  ;", "spouseValidator . validate ( tb . getSpouse (  )  ,    errors )  ;", "errors . setNestedPath (  \"  \"  )  ;", "assertTrue ( errors . hasErrors (  )  )  ;", "assertEquals (  6  ,    errors . getErrorCount (  )  )  ;", "assertEquals (  2  ,    errors . getGlobalErrorCount (  )  )  ;", "assertEquals (  \" validation . NAME _ TOUCHY _ MISMATCH \"  ,    errors . getGlobalError (  )  . getCode (  )  )  ;", "assertEquals (  \" validation . NAME _ TOUCHY _ MISMATCH \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getCode (  )  )  ;", "assertEquals (  \" validation . NAME _ TOUCHY _ MISMATCH . tb \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" validation . NAME _ TOUCHY _ MISMATCH \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" tb \"  ,    errors . getGlobalErrors (  )  . get (  0  )  . getObjectName (  )  )  ;", "assertEquals (  \" validation . GENERAL _ ERROR \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getCode (  )  )  ;", "assertEquals (  \" validation . GENERAL _ ERROR . tb \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" validation . GENERAL _ ERROR \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" msg \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getDefaultMessage (  )  )  ;", "assertEquals (  \" arg \"  ,    errors . getGlobalErrors (  )  . get (  1  )  . getArguments (  )  [  0  ]  )  ;", "assertTrue ( errors . hasFieldErrors (  )  )  ;", "assertEquals (  4  ,    errors . getFieldErrorCount (  )  )  ;", "assertEquals (  \" validation . TOO _ YOUNG \"  ,    errors . getFieldError (  )  . getCode (  )  )  ;", "assertEquals (  \" validation . TOO _ YOUNG \"  ,    errors . getFieldErrors (  )  . get (  0  )  . getCode (  )  )  ;", "assertEquals (  \" age \"  ,    errors . getFieldErrors (  )  . get (  0  )  . getField (  )  )  ;", "assertEquals (  \" validation . AGE _ NOT _ ODD \"  ,    errors . getFieldErrors (  )  . get (  1  )  . getCode (  )  )  ;", "assertEquals (  \" age \"  ,    errors . getFieldErrors (  )  . get (  1  )  . getField (  )  )  ;", "assertEquals (  \" validation . NOT _ ROD \"  ,    errors . getFieldErrors (  )  . get (  2  )  . getCode (  )  )  ;", "assertEquals (  \" name \"  ,    errors . getFieldErrors (  )  . get (  2  )  . getField (  )  )  ;", "assertEquals (  \" validation . TOO _ YOUNG \"  ,    errors . getFieldErrors (  )  . get (  3  )  . getCode (  )  )  ;", "assertEquals (  \" spouse . age \"  ,    errors . getFieldErrors (  )  . get (  3  )  . getField (  )  )  ;", "assertTrue ( errors . hasFieldErrors (  \" age \"  )  )  ;", "assertEquals (  2  ,    errors . getFieldErrorCount (  \" age \"  )  )  ;", "assertEquals (  \" validation . TOO _ YOUNG \"  ,    errors . getFieldError (  \" age \"  )  . getCode (  )  )  ;", "assertEquals (  \" validation . TOO _ YOUNG \"  ,    errors . getFieldErrors (  \" age \"  )  . get (  0  )  . getCode (  )  )  ;", "assertEquals (  \" tb \"  ,    errors . getFieldErrors (  \" age \"  )  . get (  0  )  . getObjectName (  )  )  ;", "assertEquals (  \" age \"  ,    errors . getFieldErrors (  \" age \"  )  . get (  0  )  . getField (  )  )  ;", "assertEquals ( new   Integer (  0  )  ,    errors . getFieldErrors (  \" age \"  )  . get (  0  )  . getRejectedValue (  )  )  ;", "assertEquals (  \" validation . AGE _ NOT _ ODD \"  ,    errors . getFieldErrors (  \" age \"  )  . get (  1  )  . getCode (  )  )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" name \"  )  )  ;", "assertEquals (  \" validation . NOT _ ROD \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" validation . NOT _ ROD . tb . name \"  ,    errors . getFieldError (  \" name \"  )  . getCodes (  )  [  0  ]  )  ;", "assertEquals (  \" validation . NOT _ ROD . name \"  ,    errors . getFieldError (  \" name \"  )  . getCodes (  )  [  1  ]  )  ;", "assertEquals (  \" validation . NOT _ ROD . String \"  ,    errors . getFieldError (  \" name \"  )  . getCodes (  )  [  2  ]  )  ;", "assertEquals (  \" validation . NOT _ ROD \"  ,    errors . getFieldError (  \" name \"  )  . getCodes (  )  [  3  ]  )  ;", "assertEquals (  \" name \"  ,    errors . getFieldErrors (  \" name \"  )  . get (  0  )  . getField (  )  )  ;", "assertEquals ( null ,    errors . getFieldErrors (  \" name \"  )  . get (  0  )  . getRejectedValue (  )  )  ;", "assertTrue ( errors . hasFieldErrors (  \" spouse . age \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" spouse . age \"  )  )  ;", "assertEquals (  \" validation . TOO _ YOUNG \"  ,    errors . getFieldError (  \" spouse . age \"  )  . getCode (  )  )  ;", "assertEquals (  \" tb \"  ,    errors . getFieldErrors (  \" spouse . age \"  )  . get (  0  )  . getObjectName (  )  )  ;", "assertEquals ( new   Integer (  0  )  ,    errors . getFieldErrors (  \" spouse . age \"  )  . get (  0  )  . getRejectedValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidatorWithErrorsAndCodesPrefix"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "Validator   testValidator    =    new    . TestBeanValidator (  )  ;", "testValidator . validate ( tb ,    errors )  ;", "errors . setNestedPath (  \" spouse .  \"  )  ;", "assertEquals (  \" spouse .  \"  ,    errors . getNestedPath (  )  )  ;", "Validator   spouseValidator    =    new    . SpouseValidator (  )  ;", "spouseValidator . validate ( tb . getSpouse (  )  ,    errors )  ;", "errors . setNestedPath (  \"  \"  )  ;", "assertTrue ( errors . hasFieldErrors (  \" spouse \"  )  )  ;", "assertEquals (  1  ,    errors . getFieldErrorCount (  \" spouse \"  )  )  ;", "assertEquals (  \" SPOUSE _ NOT _ AVAILABLE \"  ,    errors . getFieldError (  \" spouse \"  )  . getCode (  )  )  ;", "assertEquals (  \" tb \"  ,    errors . getFieldErrors (  \" spouse \"  )  . get (  0  )  . getObjectName (  )  )  ;", "assertEquals ( null ,    errors . getFieldErrors (  \" spouse \"  )  . get (  0  )  . getRejectedValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidatorWithNestedObjectNull"], "fileName": "org.springframework.validation.DataBinderTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    codes    =    new   String [  ]  {     ( objectName    +     ( Errors . NESTED _ PATH _ SEPARATOR )  )     +    field ,    field    }  ;", "return   new   Object [  ]  {    new   MessageSourceResolvable ( codes ,    field )     }  ;", "}", "METHOD_END"], "methodName": ["getArgumentsForBindError"], "fileName": "org.springframework.validation.DefaultBindingErrorProcessor"}, {"methodBody": ["METHOD_START", "{", "codeList . add ( postProcessMessageCode ( this . formatter . format ( errorCode ,    objectName ,    field )  )  )  ;", "}", "METHOD_END"], "methodName": ["addCode"], "fileName": "org.springframework.validation.DefaultMessageCodesResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( String   field    :    fields )     {", "addCode ( codeList ,    errorCode ,    objectName ,    field )  ;", "}", "}", "METHOD_END"], "methodName": ["addCodes"], "fileName": "org.springframework.validation.DefaultMessageCodesResolver"}, {"methodBody": ["METHOD_START", "{", "fieldList . add ( field )  ;", "St   plainField    =    field ;", "int   keyIndex    =    plainField . lastIndexOf (  '  [  '  )  ;", "while    ( keyIndex    !  =     (  -  1  )  )     {", "int   endKeyIndex    =    plainField . indexOf (  '  ]  '  ,    keyIndex )  ;", "if    ( endKeyIndex    !  =     (  -  1  )  )     {", "plainField    =     ( plainField . subst (  0  ,    keyIndex )  )     +     ( plainField . subst (  ( endKeyIndex    +     1  )  )  )  ;", "fieldList . add ( plainField )  ;", "keyIndex    =    plainField . lastIndexOf (  '  [  '  )  ;", "} else    {", "keyIndex    =     -  1  ;", "}", "}", "}", "METHOD_END"], "methodName": ["buildFieldList"], "fileName": "org.springframework.validation.DefaultMessageCodesResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . prefix ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "org.springframework.validation.DefaultMessageCodesResolver"}, {"methodBody": ["METHOD_START", "{", "return    ( getPrefix (  )  )     +    code ;", "}", "METHOD_END"], "methodName": ["postProcessMessageCode"], "fileName": "org.springframework.validation.DefaultMessageCodesResolver"}, {"methodBody": ["METHOD_START", "{", "this . formatter    =     ( formatter    !  =    null )     ?    formatter    :    DefaultMessageCodesResolver . DEFAULT _ FORMATTER ;", "}", "METHOD_END"], "methodName": ["setMessageCodeFormatter"], "fileName": "org.springframework.validation.DefaultMessageCodesResolver"}, {"methodBody": ["METHOD_START", "{", "this . prefix    =     ( prefix    !  =    null )     ?    prefix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setPrefix"], "fileName": "org.springframework.validation.DefaultMessageCodesResolver"}, {"methodBody": ["METHOD_START", "{", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  ,     \" field \"  ,    TestBean . class )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" errorCode . objectName . field \"  ,     \" errorCode . field \"  ,     \" errorCode . tests . sample . beans . TestBean \"  ,     \" errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldResolveFieldMessageCode"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . setPrefix (  \" prefix .  \"  )  ;", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  ,     \" field \"  ,    TestBean . class )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" prefix . errorCode . objectName . field \"  ,     \" prefix . errorCode . field \"  ,     \" prefix . errorCode . tests . sample . beans . TestBean \"  ,     \" prefix . errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldResolveFieldMessageCodeWithPrefix"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  ,     \" a . b [  3  ]  . c [  5  ]  . d \"  ,    TestBean . class )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" errorCode . objectName . a . b [  3  ]  . c [  5  ]  . d \"  ,     \" errorCode . objectName . a . b [  3  ]  . c . d \"  ,     \" errorCode . objectName . a . b . c . d \"  ,     \" errorCode . a . b [  3  ]  . c [  5  ]  . d \"  ,     \" errorCode . a . b [  3  ]  . c . d \"  ,     \" errorCode . a . b . c . d \"  ,     \" errorCode . d \"  ,     \" errorCode . tests . sample . beans . TestBean \"  ,     \" errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldResolveIndexedFieldMessageCode"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" errorCode . objectName \"  ,     \" errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldResolveMessageCode"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . setPrefix (  \" prefix .  \"  )  ;", "String [  ]    codes    =    resolver . resolve (  \" errorCode \"  ,     \" objectName \"  )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" prefix . errorCode . objectName \"  ,     \" prefix . errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldResolveMessageCodeWithPrefix"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . setMessageCodeFormatter ( new   MessageCodeFormatter (  )     {", "@ Override", "public   String   format ( String   errorCode ,    String   objectName ,    String   field )     {", "return    . Format . toDelimitedString (  (  \" CUSTOM -  \"     +    errorCode )  ,    objectName ,    field )  ;", "}", "}  )  ;", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" CUSTOM - errorCode . objectName \"  ,     \" CUSTOM - errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportCustomFormat"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . setMessageCodeFormatter ( DefaultMessageCodesResolver . Format . POSTFIX _ ERROR _ CODE )  ;", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  ,     \" field \"  ,    TestBean . class )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" objectName . field . errorCode \"  ,     \" field . errorCode \"  ,     \" errorCode \"  ,     \" errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportFieldPostfixFormat"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  ,     \" field [  \"  ,    TestBean . class )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" errorCode . objectName . field [  \"  ,     \" errorCode . field [  \"  ,     \" errorCode . tests . sample . beans . TestBean \"  ,     \" errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportMalformedIndexField"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  ,     \" field \"  ,    null )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" errorCode . objectName . field \"  ,     \" errorCode . field \"  ,     \" errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportNullFieldType"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . setPrefix ( null )  ;", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  ,     \" field \"  ,    TestBean . class )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" errorCode . objectName . field \"  ,     \" errorCode . field \"  ,     \" errorCode . tests . sample . beans . TestBean \"  ,     \" errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportNullPrefix"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . setMessageCodeFormatter ( DefaultMessageCodesResolver . Format . POSTFIX _ ERROR _ CODE )  ;", "String [  ]    codes    =    resolver . resolveMessageCodes (  \" errorCode \"  ,     \" objectName \"  )  ;", "assertThat ( codes ,    is ( equalTo ( new   String [  ]  {     \" objectName . errorCode \"  ,     \" errorCode \"     }  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportPostfixFormat"], "fileName": "org.springframework.validation.DefaultMessageCodesResolverTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . target )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" Cannot   access   fields   on   null   target   instance    '  \"     +     ( getObjectName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "return   PropertyAccessorFactory . forAccess ( this . target )  ;", "}", "METHOD_END"], "methodName": ["createDirectFieldAccessor"], "fileName": "org.springframework.validation.DirectFieldBindingResult"}, {"methodBody": ["METHOD_START", "{", "return   this . field ;", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "org.springframework.validation.FieldError"}, {"methodBody": ["METHOD_START", "{", "return   this . rejectedValue ;", "}", "METHOD_END"], "methodName": ["getRejectedValue"], "fileName": "org.springframework.validation.FieldError"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingFailure ;", "}", "METHOD_END"], "methodName": ["isBindingFailure"], "fileName": "org.springframework.validation.FieldError"}, {"methodBody": ["METHOD_START", "{", "return   this . target ;", "}", "METHOD_END"], "methodName": ["getTargetMap"], "fileName": "org.springframework.validation.MapBindingResult"}, {"methodBody": ["METHOD_START", "{", "return    ( sourceType . isInstance ( this . source )  )     |  |     (  (  ( this . source )    instanceof   Throwable )     &  &     ( sourceType . isInstance (  (  ( Throwable )     ( this . source )  )  . getCause (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.springframework.validation.ObjectError"}, {"methodBody": ["METHOD_START", "{", "return   this . objectName ;", "}", "METHOD_END"], "methodName": ["getObjectName"], "fileName": "org.springframework.validation.ObjectError"}, {"methodBody": ["METHOD_START", "{", "if    ( sourceType . isInstance ( this . source )  )     {", "return   sourceType . cast ( this . source )  ;", "} else", "if    (  ( this . source )    instanceof   Throwable )     {", "Throwable   cause    =     (  ( Throwable )     ( this . source )  )  . getCause (  )  ;", "if    ( sourceType . isInstance ( cause )  )     {", "return   sourceType . cast ( cause )  ;", "}", "}", "throw   new   IllegalArgumentException (  (  \" No   source   o   of   the   given   type   available :     \"     +    sourceType )  )  ;", "}", "METHOD_END"], "methodName": ["unwrap"], "fileName": "org.springframework.validation.ObjectError"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . source )     !  =    null )     {", "throw   new   IllegalStateExcep (  (  \" Already   wrapping    \"     +     ( this . source )  )  )  ;", "}", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.springframework.validation.ObjectError"}, {"methodBody": ["METHOD_START", "{", "ValidationUtils . invokeValidator ( validator ,    obj ,    errors ,     (  ( Object [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeValidator"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( validator ,     \" Validator   must   not   be   null \"  )  ;", "Assert . notNull ( errors ,     \" Errors   object   must   not   be   null \"  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Invoking   validator    [  \"     +    validator )     +     \"  ]  \"  )  )  ;", "}", "if    (  ( obj    !  =    null )     &  &     (  !  ( validator . supports ( obj . getClass (  )  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Validator    [  \"     +     ( validator . getClass (  )  )  )     +     \"  ]    does   not   support    [  \"  )     +     ( obj . getClass (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "if    (  (  !  ( ObjectUtils . isEmpty ( validationHints )  )  )     &  &     ( validator   instanceof   SmartValidator )  )     {", "(  ( SmartValidator )     ( validator )  )  . validate ( obj ,    errors ,    validationHints )  ;", "} else    {", "validator . validate ( obj ,    errors )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", "if    ( errors . hasErrors (  )  )     {", ". logger . debug (  (  (  \" Validator   found    \"     +     ( errors . getErrorCount (  )  )  )     +     \"    errors \"  )  )  ;", "} else    {", ". logger . debug (  \" Validator   found   no   errors \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokeValidator"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "ValidationUtils . rejectIfEmpty ( errors ,    field ,    errorCode ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["rejectIfEmpty"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "ValidationUtils . rejectIfEmpty ( errors ,    field ,    errorCode ,    errorArgs ,    null )  ;", "}", "METHOD_END"], "methodName": ["rejectIfEmpty"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( errors ,     \" Errors   object   must   not   be   null \"  )  ;", "Object   value    =    errors . getFieldValue ( field )  ;", "if    (  ( value    =  =    null )     |  |     (  !  ( String . hasLength ( value . toString (  )  )  )  )  )     {", "errors . rejectValue ( field ,    errorCode ,    errorArgs ,    defaultMessage )  ;", "}", "}", "METHOD_END"], "methodName": ["rejectIfEmpty"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "ValidationUtils . rejectIfEmpty ( errors ,    field ,    errorCode ,    null ,    defaultMessage )  ;", "}", "METHOD_END"], "methodName": ["rejectIfEmpty"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "ValidationUtils . rejectIfEmptyOrWhitespace ( errors ,    field ,    errorCode ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["rejectIfEmptyOrWhitespace"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "ValidationUtils . rejectIfEmptyOrWhitespace ( errors ,    field ,    errorCode ,    errorArgs ,    null )  ;", "}", "METHOD_END"], "methodName": ["rejectIfEmptyOrWhitespace"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( errors ,     \" Errors   object   must   not   be   null \"  )  ;", "Object   value    =    errors . getFieldValue ( field )  ;", "if    (  ( value    =  =    null )     |  |     (  !  ( String . hasText ( value . toString (  )  )  )  )  )     {", "errors . rejectValue ( field ,    errorCode ,    errorArgs ,    defaultMessage )  ;", "}", "}", "METHOD_END"], "methodName": ["rejectIfEmptyOrWhitespace"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "ValidationUtils . rejectIfEmptyOrWhitespace ( errors ,    field ,    errorCode ,    null ,    defaultMessage )  ;", "}", "METHOD_END"], "methodName": ["rejectIfEmptyOrWhitespace"], "fileName": "org.springframework.validation.ValidationUtils"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "ValidationUtils . invokeValidator ( new    . EmptyValidator (  )  ,    tb ,    errors )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInvokeValidatorSunnyDay"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "ValidationUtils . invokeValidator ( new    . EmptyValidator (  )  ,    tb ,    null )  ;", "}", "METHOD_END"], "methodName": ["testInvokeValidatorWithNullErrors"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", ". invokeValidator ( null ,    tb ,    errors )  ;", "}", "METHOD_END"], "methodName": ["testInvokeValidatorWithNullValidator"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  \"  \"  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "Validator   testValidator    =    new    . EmptyValidator (  )  ;", "testValidator . validate ( tb ,    errors )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidationUtilsEmpty"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Validator   testValidator    =    new    . EmptyOrWhitespaceValidator (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "testValidator . validate ( tb ,    errors )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY _ OR _ WHITESPACE \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "tb . setName (  \"  \"  )  ;", "errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "testValidator . validate ( tb ,    errors )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY _ OR _ WHITESPACE \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "tb . setName (  \"     \"  )  ;", "errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "testValidator . validate ( tb ,    errors )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY _ OR _ WHITESPACE \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "tb . setName (  \" Roddy \"  )  ;", "errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "testValidator . validate ( tb ,    errors )  ;", "assertFalse ( errors . hasFieldErrors (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidationUtilsEmptyOrWhitespace"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \"     \"  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", ". rejectIfEmptyOrWhitespace ( errors ,     \" name \"  ,     \" EMPTY _ OR _ WHITESPACE \"  ,    new   Object [  ]  {     \" arg \"     }  )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY _ OR _ WHITESPACE \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" arg \"  ,    errors . getFieldError (  \" name \"  )  . getArguments (  )  [  0  ]  )  ;", "errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", ". rejectIfEmptyOrWhitespace ( errors ,     \" name \"  ,     \" EMPTY _ OR _ WHITESPACE \"  ,    new   Object [  ]  {     \" arg \"     }  ,     \" msg \"  )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY _ OR _ WHITESPACE \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" arg \"  ,    errors . getFieldError (  \" name \"  )  . getArguments (  )  [  0  ]  )  ;", "assertEquals (  \" msg \"  ,    errors . getFieldError (  \" name \"  )  . getDefaultMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidationUtilsEmptyOrWhitespaceVariants"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", ". rejectIfEmpty ( errors ,     \" name \"  ,     \" EMPTY _ OR _ WHITESPACE \"  ,    new   Object [  ]  {     \" arg \"     }  )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY _ OR _ WHITESPACE \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" arg \"  ,    errors . getFieldError (  \" name \"  )  . getArguments (  )  [  0  ]  )  ;", "errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", ". rejectIfEmpty ( errors ,     \" name \"  ,     \" EMPTY _ OR _ WHITESPACE \"  ,    new   Object [  ]  {     \" arg \"     }  ,     \" msg \"  )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY _ OR _ WHITESPACE \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "assertEquals (  \" arg \"  ,    errors . getFieldError (  \" name \"  )  . getArguments (  )  [  0  ]  )  ;", "assertEquals (  \" msg \"  ,    errors . getFieldError (  \" name \"  )  . getDefaultMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidationUtilsEmptyVariants"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "Validator   testValidator    =    new    . EmptyValidator (  )  ;", "testValidator . validate ( tb ,    errors )  ;", "assertTrue ( errors . hasFieldErrors (  \" name \"  )  )  ;", "assertEquals (  \" EMPTY \"  ,    errors . getFieldError (  \" name \"  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidationUtilsNull"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  \"  \"  )  ;", "Validator   testValidator    =    new    . EmptyValidator (  )  ;", "tb . setName (  \"     \"  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "testValidator . validate ( tb ,    errors )  ;", "assertFalse ( errors . hasFieldErrors (  \" name \"  )  )  ;", "tb . setName (  \" Roddy \"  )  ;", "errors    =    new   BeanPropertyBindingResult ( tb ,     \" tb \"  )  ;", "testValidator . validate ( tb ,    errors )  ;", "assertFalse ( errors . hasFieldErrors (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidationUtilsSunnyDay"], "fileName": "org.springframework.validation.ValidationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . validator )     !  =    null )  ,     \" No   Validator   set \"  )  ;", "Set < ConstraintViolation < Object >  >    result    =    this . validator . validate ( bean )  ;", "if    (  !  ( result . isEmpty (  )  )  )     {", "StringBuilder   sb    =    new   StringBuilder (  \" Bean   state   is   invalid :     \"  )  ;", "for    ( Iterator < ConstraintViolation < Object >  >    it    =    result . iterator (  )  ;    it . hasNext (  )  ;  )     {", "ConstraintViolation < Object >    violation    =    it . next (  )  ;", "sb . append ( violation . getPropertyPath (  )  )  . append (  \"     -     \"  )  . append ( violation . getMessage (  )  )  ;", "if    ( it . hasNext (  )  )     {", "sb . append (  \"  ;     \"  )  ;", "}", "}", "throw   new   BeanInitializationException ( sb . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doValidate"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . afterInitialization    =    afterInitialization ;", "}", "METHOD_END"], "methodName": ["setAfterInitialization"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . validator    =    validator ;", "}", "METHOD_END"], "methodName": ["setValidator"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . validator    =    validatorFactory . getValidator (  )  ;", "}", "METHOD_END"], "methodName": ["setValidatorFactory"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  )  ;", "ac . registerBeanDefinition (  \" capp \"  ,    new   RootBeanDefinition ( CommonAnnotationBeanPostProcessor . class )  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    new   RootBeanDefinition (  . NotNullConstrainedBean . class )  )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getRootCause (  )  . getMessage (  )  . contains (  \" testBean \"  )  )  ;", "assertTrue ( ex . getRootCause (  )  . getMessage (  )  . contains (  \" invalid \"  )  )  ;", "}", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNotNullConstraint"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "RootBeanDefinition   bvpp    =    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  ;", "bvpp . getPropertyValues (  )  . add (  \" afterInitialization \"  ,    true )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    bvpp )  ;", "ac . registerBeanDefinition (  \" capp \"  ,    new   RootBeanDefinition ( CommonAnnotationBeanPostProcessor . class )  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    new   RootBeanDefinition (  . AfterInitConstraintBean . class )  )  ;", "ac . refresh (  )  ;", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNotNullConstraintAfterInitialization"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  )  ;", "ac . registerBeanDefinition (  \" capp \"  ,    new   RootBeanDefinition ( CommonAnnotationBeanPostProcessor . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . NotNullConstrainedBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" testBean \"  ,    new   TestBean (  )  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    bd )  ;", "ac . refresh (  )  ;", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNotNullConstraintSatisfied"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . NotNullConstrainedBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" testBean \"  ,    new   TestBean (  )  )  ;", "bd . getPropertyValues (  )  . add (  \" stringValue \"  ,     \" s \"  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    bd )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getRootCause (  )  . getMessage (  )  . contains (  \" stringValue \"  )  )  ;", "assertTrue ( ex . getRootCause (  )  . getMessage (  )  . contains (  \" invalid \"  )  )  ;", "}", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSizeConstraint"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . NotNullConstrainedBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" testBean \"  ,    new   TestBean (  )  )  ;", "bd . getPropertyValues (  )  . add (  \" stringValue \"  ,     \" ss \"  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    bd )  ;", "ac . refresh (  )  ;", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSizeConstraintSatisfied"], "fileName": "org.springframework.validation.beanvalidation.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . messageInterpolator    =    messageInterpolator ;", "}", "METHOD_END"], "methodName": ["setMessageInterpolator"], "fileName": "org.springframework.validation.beanvalidation.CustomValidatorBean"}, {"methodBody": ["METHOD_START", "{", "this . traversableResolver    =    traversableResolver ;", "}", "METHOD_END"], "methodName": ["setTraversableResolver"], "fileName": "org.springframework.validation.beanvalidation.CustomValidatorBean"}, {"methodBody": ["METHOD_START", "{", "this . validatorFactory    =    validatorFactory ;", "}", "METHOD_END"], "methodName": ["setValidatorFactory"], "fileName": "org.springframework.validation.beanvalidation.CustomValidatorBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . validatorFactory )     !  =    null )     {", "this . validatorFactory . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "final   ParameterNameProvider   defaultProvider    =    configuration . getDefaultParameterNameProvider (  )  ;", "configuration . parameterNameProvider ( new   ParameterNameProvider (  )     {", "@ Override", "public   List < String >    getParameterNames ( Constructor <  ?  >    constructor )     {", "String [  ]    paramNames    =    discoverer . getParameterNames ( constructor )  ;", "return   paramNames    !  =    null    ?    Arrays . asList ( paramNames )     :    defaultProvider . getParameterNames ( constructor )  ;", "}", "@ Override", "public   List < String >    getParameterNames ( Method   method )     {", "String [  ]    paramNames    =    discoverer . getParameterNames ( method )  ;", "return   paramNames    !  =    null    ?    Arrays . asList ( paramNames )     :    defaultProvider . getParameterNames ( method )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureParameterNameProvider"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . validationPropertyMap ;", "}", "METHOD_END"], "methodName": ["getValidationPropertyMap"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . constraintValidatorFactory    =    constraintValidatorFactory ;", "}", "METHOD_END"], "methodName": ["setConstraintValidatorFactory"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . mappingLocations    =    mappingLocations ;", "}", "METHOD_END"], "methodName": ["setMappingLocations"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . messageInterpolator    =    messageInterpolator ;", "}", "METHOD_END"], "methodName": ["setMessageInterpolator"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameDiscoverer    =    parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["setParameterNameDiscoverer"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . providerClass    =    providerClass ;", "}", "METHOD_END"], "methodName": ["setProviderClass"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . traversableResolver    =    traversableResolver ;", "}", "METHOD_END"], "methodName": ["setTraversableResolver"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . messageInterpolator    =    LocalValidatorFactoryBean . HibernateValidatorDelegate . buildMessageInterpolator ( messageSource )  ;", "}", "METHOD_END"], "methodName": ["setValidationMessageSource"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "CollectionUtils . mergePropertiesIntoMap ( jpaProperties ,    this . validationPropertyMap )  ;", "}", "METHOD_END"], "methodName": ["setValidationProperties"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if   Properties    !  =    null )     {", "thisPropertyMap . putAllProperties )  ;", "}", "}", "METHOD_END"], "methodName": ["setValidationPropertyMap"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . validationProviderResolver    =    validationProviderResolver ;", "}", "METHOD_END"], "methodName": ["setValidationProviderResolver"], "fileName": "org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Validated   validatedAnn    =    AnnotationUtils . findAnnotation ( invocation . getMethod (  )  ,    Validated . class )  ;", "if    ( validatedAnn    =  =    null )     {", "validatedAnn    =    AnnotationUtils . findAnnotation ( invocation . getThis (  )  . getClass (  )  ,    Validated . class )  ;", "}", "return   validatedAnn    !  =    null    ?    validatedAnn . value (  )     :    new   Class <  ?  >  [  0  ]  ;", "}", "METHOD_END"], "methodName": ["determineValidationGroups"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   validator    !  =    null    ?    new   MethodValidationInterceptor ( validator )     :    new   MethodValidationInterceptor (  )  ;", "}", "METHOD_END"], "methodName": ["createMethodValidationAdvice"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNulledAnnotationType ,     \" edAnnotationType '    must   not   be   null \"  )  ;", "thisedAnnotationType    = edAnnotationType ;", "}", "METHOD_END"], "methodName": ["setValidatedAnnotationType"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if   or   instanceof   LocalValidatorFactoryBean )     {", "thisor    =     (  ( LocalValidatorFactoryBean )    or )  )  . getValidator (  )  ;", "} else", "if   or   instanceof   SpringValidatorAdapter )     {", "thisor    = or . unwrap ( Validator . class )  ;", "} else    {", "thisor    = or ;", "}", "}", "METHOD_END"], "methodName": ["setValidator"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . validator    =    validatorFactory . getValidator (  )  ;", "}", "METHOD_END"], "methodName": ["setValidatorFactory"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( proxy . myValidMethod (  \" value \"  ,     5  )  )  ;", "try    {", "assertNotNull ( proxy . myValidMethod (  \" value \"  ,     1  5  )  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "try    {", "assertNotNull ( proxy . myValidMethod ( null ,     5  )  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "try    {", "assertNotNull ( proxy . myValidMethod (  \" value \"  ,     0  )  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "proxy . myValidAsyncMethod (  \" value \"  ,     5  )  ;", "try    {", "proxy . myValidAsyncMethod (  \" value \"  ,     1  5  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "try    {", "proxy . myValidAsyncMethod ( null ,     5  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "assertEquals (  \" myValue \"  ,    proxy . myGenericMethod (  \" myValue \"  )  )  ;", "try    {", "proxy . myGenericMethod ( null )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "}", "METHOD_END"], "methodName": ["doTestProxyValidation"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( MethodValidationTests . LazyMethodValidationConfig . class ,    CustomValidatorBean . class ,    MethodValidationTests . MyValidBean . class )  ;", "ctx . getBean ( MethodValidationTests . MyValidInterface . class )  . myValidMethod (  \" value \"  ,     5  )  ;", "}", "METHOD_END"], "methodName": ["testLazyValidatorForMethodValidation"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationTests"}, {"methodBody": ["METHOD_START", "{", "MethodValidationTests . MyValidBean   bean    =    new   MethodValidationTests . MyValidBean (  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory ( bean )  ;", "proxyFactory . addAdvice ( new   MethodValidationInterceptor (  )  )  ;", "proxyFactory . addAdvisor ( new   AsyncAnnotationAdvisor (  )  )  ;", "doTestProxyValidation (  (  ( MethodValidationTests . MyValidInterface )     ( proxyFactory . getProxy (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodValidationInterceptor"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerSingleton (  \" mvpp \"  ,    MethodValidationPostProcessor . class )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" beforeExistingAdvisors \"  ,    false )  ;", "ac . registerSingleton (  \" aapp \"  ,    AsyncAnnotationBeanPostProcessor . class ,    pvs )  ;", "ac . registerSingleton (  \" bean \"  ,     . MyValidBean . class )  ;", "ac . refresh (  )  ;", "doTestProxyValidation ( ac . getBean (  \" bean \"  ,     . MyValidInterface . class )  )  ;", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testMethodValidationPostProcessor"], "fileName": "org.springframework.validation.beanvalidation.MethodValidationTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . destroyBean ( instance )  ;", "}", "METHOD_END"], "methodName": ["releaseInstance"], "fileName": "org.springframework.validation.beanvalidation.SpringConstraintValidatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   descriptor . getAnnotation (  )  . annotationType (  )  . getSimpleName (  )  ;", "}", "METHOD_END"], "methodName": ["determineErrorCode"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapter"}, {"methodBody": ["METHOD_START", "{", "Path   path    =    violation . getPropertyPath (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "boolean   first    =    true ;", "for    ( Path . Node   node    :    path )     {", "if    ( node . isInIterable (  )  )     {", "sb . append (  '  [  '  )  ;", "Object   index    =    node . getIndex (  )  ;", "if    ( index    =  =    null )     {", "index    =    node . getKey (  )  ;", "}", "if    ( index    !  =    null )     {", "sb . append ( index )  ;", "}", "sb . append (  '  ]  '  )  ;", "}", "String   name    =    node . getName (  )  ;", "if    (  (  ( name    !  =    null )     &  &     (  ( node . getKind (  )  )     =  =     ( ElementKind . PROPERTY )  )  )     &  &     (  !  ( name . startsWith (  \"  <  \"  )  )  )  )     {", "if    (  ! first )     {", "sb . append (  '  .  '  )  ;", "}", "first    =    false ;", "sb . append ( name )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["determineField"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapter"}, {"methodBody": ["METHOD_START", "{", "List < Object >    arguments    =    new   ArrayList <  >  (  )  ;", "arguments . add ( getResolvableField ( objectName ,    field )  )  ;", "Map < String ,    Object >    attributesToExpose    =    new   TreeMap <  >  (  )  ;", "descriptor . getAttributes (  )  . forEach (  (    attributeName ,    attributeValue )     -  >     {", "if    (  !  (  . internalAnnotationAttributes . contains ( attributeName )  )  )     {", "if    ( attributeValue   instanceof   String )     {", "attributeValue    =    new   ResolvableAttribute ( attributeValue . toString (  )  )  ;", "}", "attributesToExpose . put ( attributeName ,    attributeValue )  ;", "}", "}  )  ;", "arguments . addAll ( attributesToExpose . values (  )  )  ;", "return   arguments . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["getArgumentsForConstraint"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapter"}, {"methodBody": ["METHOD_START", "{", "Object   invalidValue    =    violation . getInvalidValue (  )  ;", "if    (  (  (  !  (  \"  \"  . equals ( field )  )  )     &  &     (  !  ( field . contains (  \"  [  ]  \"  )  )  )  )     &  &     (  (  ( invalidValue    =  =     ( violation . getLeafBean (  )  )  )     |  |     ( field . contains (  \"  [  \"  )  )  )     |  |     ( field . contains (  \"  .  \"  )  )  )  )     {", "invalidValue    =    bindingResult . getRawFieldValue ( field )  ;", "}", "return   invalidValue ;", "}", "METHOD_END"], "methodName": ["getRejectedValue"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapter"}, {"methodBody": ["METHOD_START", "{", "String [  ]    codes    =    new   String [  ]  {     ( objectName    +     ( Errors . NESTED _ PATH _ SEPARATOR )  )     +    field ,    field    }  ;", "return   new   DefaultMessageSourceResolvable ( codes ,    field )  ;", "}", "METHOD_END"], "methodName": ["getResolvableField"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapter"}, {"methodBody": ["METHOD_START", "{", "for    ( ConstraintViolation < Object >    violation    :    violations )     {", "String   field    =    determineField ( violation )  ;", "FieldError   fieldError    =    errors . getFieldError ( field )  ;", "if    (  ( fieldError    =  =    null )     |  |     (  !  ( fieldError . isBindingFailure (  )  )  )  )     {", "try    {", "ConstraintDescriptor <  ?  >    cd    =    violation . getConstraintDescriptor (  )  ;", "String   errorCode    =    determineErrorCode ( cd )  ;", "Object [  ]    errorArgs    =    getArgumentsForConstraint ( errors . getObjectName (  )  ,    field ,    cd )  ;", "if    ( errors   instanceof   BindingResult )     {", "BindingResult   bindingResult    =     (  ( BindingResult )     ( errors )  )  ;", "String   nestedField    =     ( bindingResult . getNestedPath (  )  )     +    field ;", "if    (  \"  \"  . equals ( nestedField )  )     {", "String [  ]    errorCodes    =    bindingResult . resolveMessageCodes ( errorCode )  ;", "ObjectError   error    =    new   ObjectError ( errors . getObjectName (  )  ,    errorCodes ,    errorArgs ,    violation . getMessage (  )  )  ;", "error . wrap ( violation )  ;", "bindingResult . addError ( error )  ;", "} else    {", "Object   rejectedValue    =    getRejectedValue ( field ,    violation ,    bindingResult )  ;", "String [  ]    errorCodes    =    bindingResult . resolveMessageCodes ( errorCode ,    field )  ;", "FieldError   error    =    new   FieldError ( errors . getObjectName (  )  ,    nestedField ,    rejectedValue ,    false ,    errorCodes ,    errorArgs ,    violation . getMessage (  )  )  ;", "error . wrap ( violation )  ;", "bindingResult . addError ( error )  ;", "}", "} else    {", "errors . rejectValue ( field ,    errorCode ,    errorArgs ,    violation . getMessage (  )  )  ;", "}", "}    catch    ( NotReadablePropertyException   ex )     {", "throw   new   IllegalStateException (  (  (  (  \" JSR -  3  0  3    ed   property    '  \"     +    field )     +     \"  '    does   not   have   a   corresponding   accessor   for   Spring   data   binding    -     \"  )     +     \" check   your   DataBinder ' s   configuration    ( bean   property   versus   direct   field   access )  \"  )  ,    ex )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processConstraintViolations"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapter"}, {"methodBody": ["METHOD_START", "{", "this . targetValidator    =    targetValidator ;", "}", "METHOD_END"], "methodName": ["setTargetValidator"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapter"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . Child   child 1     =    new   SpringValidatorAdapterTests . Child (  )  ;", "child 1  . setName (  \" Child 1  \"  )  ;", "child 1  . setAge ( null )  ;", "child 1  . setParent ( parent )  ;", "SpringValidatorAdapterTests . Child   child 2     =    new   SpringValidatorAdapterTests . Child (  )  ;", "child 2  . setName ( null )  ;", "child 2  . setAge (  1  7  )  ;", "child 2  . setParent ( parent )  ;", "return   Arrays . asList ( child 1  ,    child 2  )  ;", "}", "METHOD_END"], "methodName": ["createChildren"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "messageSource . addMessage (  \" Size \"  ,    Locale . ENGLISH ,     \" Size   of    {  0  }    is   must   be   between    {  2  }    and    {  1  }  \"  )  ;", "messageSource . addMessage (  \" S \"  ,    Locale . ENGLISH ,     \"  {  2  }    must   be   s   value   with    {  1  }  \"  )  ;", "messageSource . addMessage (  \" password \"  ,    Locale . ENGLISH ,     \" Password \"  )  ;", "messageSource . addMessage (  \" confirmPassword \"  ,    Locale . ENGLISH ,     \" Password ( Confirm )  \"  )  ;", "}", "METHOD_END"], "methodName": ["setupSpringValidatorAdapter"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "messageSource . setAlwaysUseMessageFormat ( true )  ;", ". TestBean   testBean    =    new    . TestBean (  )  ;", "testBean . setEmail (  \" test @ example . com \"  )  ;", "testBean . setConfirmEmail (  \" TEST @ EXAMPLE . IO \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( testBean ,     \" testBean \"  )  ;", "validatorAdapter . validate ( testBean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" email \"  )  ,    is (  1  )  )  ;", "assertThat ( errors . getFieldValue (  \" email \"  )  ,    is (  \" test @ example . com \"  )  )  ;", "assertThat ( errors . getFieldErrorCount (  \" confirmEmail \"  )  ,    is (  1  )  )  ;", "FieldError   error 1     =    errors . getFieldError (  \" email \"  )  ;", "FieldError   error 2     =    errors . getFieldError (  \" confirmEmail \"  )  ;", "assertNotNull ( error 1  )  ;", "assertNotNull ( error 2  )  ;", "assertThat ( messageSource . getMessage ( error 1  ,    Locale . ENGLISH )  ,    is (  \" email   must   be   same   value   with   confirmEmail \"  )  )  ;", "assertThat ( messageSource . getMessage ( error 2  ,    Locale . ENGLISH )  ,    is (  \" Email   required \"  )  )  ;", "assertTrue ( error 1  . contains ( ConstraintViolation . class )  )  ;", "assertThat ( error 1  . unwrap ( ConstraintViolation . class )  . getPropertyPath (  )  . toString (  )  ,    is (  \" email \"  )  )  ;", "assertTrue ( error 2  . contains ( ConstraintViolation . class )  )  ;", "assertThat ( error 2  . unwrap ( ConstraintViolation . class )  . getPropertyPath (  )  . toString (  )  ,    is (  \" confirmEmail \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyMessageSourceResolvableToStringArgumentValueWithAlwaysUseMessageFormat"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . TestBean   testBean    =    new   SpringValidatorAdapterTests . TestBean (  )  ;", "testBean . setPassword (  \" password \"  )  ;", "testBean . setConfirmPassword (  \" PASSWORD \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( testBean ,     \" testBean \"  )  ;", "validatorAdapter . validate ( testBean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" password \"  )  ,    is (  1  )  )  ;", "assertThat ( errors . getFieldValue (  \" password \"  )  ,    is (  \" password \"  )  )  ;", "FieldError   error    =    errors . getFieldError (  \" password \"  )  ;", "assertNotNull ( error )  ;", "assertThat ( messageSource . getMessage ( error ,    Locale . ENGLISH )  ,    is (  \" Password   must   be   same   value   with   Password ( Confirm )  \"  )  )  ;", "assertTrue ( error . contains ( ConstraintViolation . class )  )  ;", "assertThat ( error . unwrap ( ConstraintViolation . class )  . getPropertyPath (  )  . toString (  )  ,    is (  \" password \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyMessageSourceResolvableToStringArgumentValueWithResolvedLogicalFieldName"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . TestBean   testBean    =    new   SpringValidatorAdapterTests . TestBean (  )  ;", "testBean . setEmail (  \" test @ example . com \"  )  ;", "testBean . setConfirmEmail (  \" TEST @ EXAMPLE . IO \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( testBean ,     \" testBean \"  )  ;", "validatorAdapter . validate ( testBean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" email \"  )  ,    is (  1  )  )  ;", "assertThat ( errors . getFieldValue (  \" email \"  )  ,    is (  \" test @ example . com \"  )  )  ;", "assertThat ( errors . getFieldErrorCount (  \" confirmEmail \"  )  ,    is (  1  )  )  ;", "FieldError   error 1     =    errors . getFieldError (  \" email \"  )  ;", "FieldError   error 2     =    errors . getFieldError (  \" confirmEmail \"  )  ;", "assertNotNull ( error 1  )  ;", "assertNotNull ( error 2  )  ;", "assertThat ( messageSource . getMessage ( error 1  ,    Locale . ENGLISH )  ,    is (  \" email   must   be   same   value   with   confirmEmail \"  )  )  ;", "assertThat ( messageSource . getMessage ( error 2  ,    Locale . ENGLISH )  ,    is (  \" Email   required \"  )  )  ;", "assertTrue ( error 1  . contains ( ConstraintViolation . class )  )  ;", "assertThat ( error 1  . unwrap ( ConstraintViolation . class )  . getPropertyPath (  )  . toString (  )  ,    is (  \" email \"  )  )  ;", "assertTrue ( error 2  . contains ( ConstraintViolation . class )  )  ;", "assertThat ( error 2  . unwrap ( ConstraintViolation . class )  . getPropertyPath (  )  . toString (  )  ,    is (  \" confirmEmail \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyMessageSourceResolvableToStringArgumentValueWithUnresolvedLogicalFieldName"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . TestBean   testBean    =    new   SpringValidatorAdapterTests . TestBean (  )  ;", "testBean . setPassword (  \" pass \"  )  ;", "testBean . setConfirmPassword (  \" pass \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( testBean ,     \" testBean \"  )  ;", "validatorAdapter . validate ( testBean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" password \"  )  ,    is (  1  )  )  ;", "assertThat ( errors . getFieldValue (  \" password \"  )  ,    is (  \" pass \"  )  )  ;", "FieldError   error    =    errors . getFieldError (  \" password \"  )  ;", "assertNotNull ( error )  ;", "assertThat ( messageSource . getMessage ( error ,    Locale . ENGLISH )  ,    is (  \" Size   of   Password   is   must   be   between    8    and    1  2  8  \"  )  )  ;", "assertTrue ( error . contains ( ConstraintViolation . class )  )  ;", "assertThat ( error . unwrap ( ConstraintViolation . class )  . getPropertyPath (  )  . toString (  )  ,    is (  \" password \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoStringArgumentValue"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Validator   nativeValidator    =    validatorAdapter . unwrap ( Validator . class )  ;", "assertSame ( this . nativeValidator ,    nativeValidator )  ;", "}", "METHOD_END"], "methodName": ["testUnwrap"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . Parent   parent    =    new   SpringValidatorAdapterTests . Parent (  )  ;", "parent . setName (  \" Parent   whit   list \"  )  ;", "parent . getChildList (  )  . addAll ( createChildren ( parent )  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( parent ,     \" parent \"  )  ;", "validatorAdapter . validate ( parent ,    errors )  ;", "assertTrue (  (  ( errors . getErrorCount (  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithList"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . Parent   parent    =    new   SpringValidatorAdapterTests . Parent (  )  ;", "parent . setName (  \" Parent   whith   set \"  )  ;", "parent . getChildSet (  )  . addAll ( createChildren ( parent )  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( parent ,     \" parent \"  )  ;", "validatorAdapter . validate ( parent ,    errors )  ;", "assertTrue (  (  ( errors . getErrorCount (  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithSet"], "fileName": "org.springframework.validation.beanvalidation.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". MainBean   mainBean    =    new    . MainBean (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( mainBean ,     \" mainBean \"  )  ;", "validator . validate ( mainBean ,    errors )  ;", "Object   rejected    =    errors . getFieldValue (  \" inner . value \"  )  ;", "assertNull ( rejected )  ;", "}", "METHOD_END"], "methodName": ["testInnerBeanValidation"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ListContainer   listContainer    =    new    . ListContainer (  )  ;", "listContainer . addString (  \" A \"  )  ;", "listContainer . addString (  \" X \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( listContainer ,     \" listContainer \"  )  ;", "errors . initConversion ( new   DefaultConversionService (  )  )  ;", "validator . validate ( listContainer ,    errors )  ;", "FieldError   fieldError    =    errors . getFieldError (  \" list [  1  ]  \"  )  ;", "assertEquals (  \" X \"  ,    errors . getFieldValue (  \" list [  1  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testListValidation"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "Set < ConstraintViolation <  . ValidPerson >  >    result    =    validator . validate ( person )  ;", "assertEquals (  2  ,    result . size (  )  )  ;", "for    ( ConstraintViolation <  . ValidPerson >    cv    :    result )     {", "String   path    =    cv . getPropertyPath (  )  . toString (  )  ;", "if    (  (  \" name \"  . equals ( path )  )     |  |     (  \" address . street \"  . equals ( path )  )  )     {", "assertTrue (  (  ( cv . getConstraintDescriptor (  )  . getAnnotation (  )  )    instanceof   NotNull )  )  ;", "} else    {", "fail (  (  (  \" Invalid   constraint   violation   with   path    '  \"     +    path )     +     \"  '  \"  )  )  ;", "}", "}", "Validator   nativeValidator    =    validator . unwrap ( Validator . class )  ;", "assertTrue ( nativeValidator . getClass (  )  . getName (  )  . startsWith (  \" hibernate \"  )  )  ;", "assertTrue (  (  ( validator . unwrap ( ValidatorFactory . class )  )    instanceof   HibernateValidatorFactory )  )  ;", "assertTrue (  (  ( validator . unwrap ( HibernateValidatorFactory . class )  )    instanceof   HibernateValidatorFactory )  )  ;", "validator . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleValidation"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . setName (  \" Juergen \"  )  ;", "person . getAddress (  )  . setStreet (  \" Juergen ' s   Street \"  )  ;", "Set < ConstraintViolation <  . ValidPerson >  >    result    =    validator . validate ( person )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "Iterator < ConstraintViolation <  . ValidPerson >  >    iterator    =    result . iterator (  )  ;", "ConstraintViolation <  ?  >    cv    =    iterator . next (  )  ;", "assertEquals (  \"  \"  ,    cv . getPropertyPath (  )  . toString (  )  )  ;", "assertTrue (  (  ( cv . getConstraintDescriptor (  )  . getAnnotation (  )  )    instanceof    . NameAddressValid )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleValidationWithClassLevel"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . setProviderClass ( HibernateValidator . class )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "Set < ConstraintViolation <  . ValidPerson >  >    result    =    validator . validate ( person )  ;", "assertEquals (  2  ,    result . size (  )  )  ;", "for    ( ConstraintViolation <  . ValidPerson >    cv    :    result )     {", "String   path    =    cv . getPropertyPath (  )  . toString (  )  ;", "if    (  (  \" name \"  . equals ( path )  )     |  |     (  \" address . street \"  . equals ( path )  )  )     {", "assertTrue (  (  ( cv . getConstraintDescriptor (  )  . getAnnotation (  )  )    instanceof   NotNull )  )  ;", "} else    {", "fail (  (  (  \" Invalid   constraint   violation   with   path    '  \"     +    path )     +     \"  '  \"  )  )  ;", "}", "}", "Validator   nativeValidator    =    validator . unwrap ( Validator . class )  ;", "assertTrue ( nativeValidator . getClass (  )  . getName (  )  . startsWith (  \" hibernate \"  )  )  ;", "assertTrue (  (  ( validator . unwrap ( ValidatorFactory . class )  )    instanceof   HibernateValidatorFactory )  )  ;", "assertTrue (  (  ( validator . unwrap ( HibernateValidatorFactory . class )  )    instanceof   HibernateValidatorFactory )  )  ;", "validator . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleValidationWithCustomProvider"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  2  ,    result . getErrorCount (  )  )  ;", "FieldError   fieldError    =    result . getFieldError (  \" name \"  )  ;", "assertEquals (  \" name \"  ,    fieldError . getField (  )  )  ;", "List < String >    errorCodes    =    Arrays . asList ( fieldError . getCodes (  )  )  ;", "assertEquals (  4  ,    errorCodes . size (  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . person . name \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . name \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . String \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull \"  )  )  ;", "fieldError    =    result . getFieldError (  \" address . street \"  )  ;", "assertEquals (  \" address . street \"  ,    fieldError . getField (  )  )  ;", "errorCodes    =    Arrays . asList ( fieldError . getCodes (  )  )  ;", "assertEquals (  5  ,    errorCodes . size (  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . person . address . street \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . address . street \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . street \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . String \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidation"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . setName (  \" Phil \"  )  ;", "person . getAddress (  )  . setStreet (  \" Phil ' s   Street \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    errors )  ;", "assertEquals (  1  ,    errors . getErrorCount (  )  )  ;", "assertThat (  \" Field / Value   type   mismatch \"  ,    errors . getFieldError (  \" address \"  )  . getRejectedValue (  )  ,    instanceOf (  . ValidAddress . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationFieldType"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( LocalValidatorFactoryBean . class )  ;", "LocalValidatorFactoryBean   validator    =    ctx . getBean ( LocalValidatorFactoryBean . class )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . expectsAutowiredValidator    =    true ;", "person . setName (  \" Juergen \"  )  ;", "person . getAddress (  )  . setStreet (  \" Juergen ' s   Street \"  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  1  ,    result . getErrorCount (  )  )  ;", "ObjectError   globalError    =    result . getGlobalError (  )  ;", "List < String >    errorCodes    =    Arrays . asList ( globalError . getCodes (  )  )  ;", "assertEquals (  2  ,    errorCodes . size (  )  )  ;", "assertTrue ( errorCodes . contains (  \" NameAddressValid . person \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NameAddressValid \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationWithAutowiredValidator"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . setName (  \" Juergen \"  )  ;", "person . getAddress (  )  . setStreet (  \" Juergen ' s   Street \"  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  1  ,    result . getErrorCount (  )  )  ;", "ObjectError   globalError    =    result . getGlobalError (  )  ;", "List < String >    errorCodes    =    Arrays . asList ( globalError . getCodes (  )  )  ;", "assertEquals (  2  ,    errorCodes . size (  )  )  ;", "assertTrue ( errorCodes . contains (  \" NameAddressValid . person \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NameAddressValid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationWithClassLevel"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . getAddressList (  )  . add ( new    . ValidAddress (  )  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  3  ,    result . getErrorCount (  )  )  ;", "FieldError   fieldError    =    result . getFieldError (  \" name \"  )  ;", "assertEquals (  \" name \"  ,    fieldError . getField (  )  )  ;", "fieldError    =    result . getFieldError (  \" address . street \"  )  ;", "assertEquals (  \" address . street \"  ,    fieldError . getField (  )  )  ;", "fieldError    =    result . getFieldError (  \" addressList [  0  ]  . street \"  )  ;", "assertEquals (  \" addressList [  0  ]  . street \"  ,    fieldError . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationWithErrorInListElement"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . getAddressSet (  )  . add ( new    . ValidAddress (  )  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  3  ,    result . getErrorCount (  )  )  ;", "FieldError   fieldError    =    result . getFieldError (  \" name \"  )  ;", "assertEquals (  \" name \"  ,    fieldError . getField (  )  )  ;", "fieldError    =    result . getFieldError (  \" address . street \"  )  ;", "assertEquals (  \" address . street \"  ,    fieldError . getField (  )  )  ;", "fieldError    =    result . getFieldError (  \" addressSet [  ]  . street \"  )  ;", "assertEquals (  \" addressSet [  ]  . street \"  ,    fieldError . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationWithErrorInSetElement"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". MainBeanWithOptional   mainBean    =    new    . MainBeanWithOptional (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( mainBean ,     \" mainBean \"  )  ;", "validator . validate ( mainBean ,    errors )  ;", "Object   rejected    =    errors . getFieldValue (  \" inner . value \"  )  ;", "assertNull ( rejected )  ;", "}", "METHOD_END"], "methodName": ["testValidationWithOptionalField"], "fileName": "org.springframework.validation.beanvalidation.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( key . startsWith ( BindingResult . MODEL _ KEY _ PREFIX )  )  )     {", "String   resultKey    =     ( BindingResult . MODEL _ KEY _ PREFIX )     +    key ;", "BindingResult   result    =     (  ( BindingResult )     ( get ( resultKey )  )  )  ;", "if    (  ( result    !  =    null )     &  &     (  ( result . getTarget (  )  )     !  =    value )  )     {", "remove ( resultKey )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeBindingResultIfNecessary"], "fileName": "org.springframework.validation.support.BindingAwareConcurrentModel"}, {"methodBody": ["METHOD_START", "{", "if    ( key   instanceof   String )     {", "String   attributeName    =     (  ( String )     ( key )  )  ;", "if    (  !  ( attributeName . startsWith ( Result . MODEL _ KEY _ PREFIX )  )  )     {", "String   bindingResultKey    =     ( Result . MODEL _ KEY _ PREFIX )     +    attributeName ;", "Result   bindingResult    =     (  ( Result )     ( get ( bindingResultKey )  )  )  ;", "if    (  ( bindingResult    !  =    null )     &  &     (  ( bindingResult . getTarget (  )  )     !  =    value )  )     {", "remove ( bindingResultKey )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["removeBindingResultIfNecessary"], "fileName": "org.springframework.validation.support.BindingAwareModelMap"}, {"methodBody": ["METHOD_START", "{", "+  +  ( count )  ;", "}", "METHOD_END"], "methodName": ["countSetter"], "fileName": "test.aspect.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "return    ( count )  +  +  ;", "}", "METHOD_END"], "methodName": ["returnCountAsAge"], "fileName": "test.aspect.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "test.aspect.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "return    ( invocations )  +  +  ;", "}", "METHOD_END"], "methodName": ["changeAge"], "fileName": "test.aspect.PerThisAspect"}, {"methodBody": ["METHOD_START", "{", "return   this . invocations ;", "}", "METHOD_END"], "methodName": ["getInvocations"], "fileName": "test.aspect.PerThisAspect"}, {"methodBody": ["METHOD_START", "{", "+  +  ( totalCalls )  ;", "}", "METHOD_END"], "methodName": ["countSet"], "fileName": "test.aspect.TwoAdviceAspect"}, {"methodBody": ["METHOD_START", "{", "return   totalCalls ;", "}", "METHOD_END"], "methodName": ["returnCallCount"], "fileName": "test.aspect.TwoAdviceAspect"}]