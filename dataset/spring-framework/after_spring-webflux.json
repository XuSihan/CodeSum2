[{"methodBody": ["METHOD_START", "{", "WebExchangeDataBinder   dataBinder    =    new   WebExchangeDataBinder ( target ,    name )  ;", "if    (  ( this . initializer )     !  =    null )     {", "this . initializer . initBinder ( dataBinder )  ;", "}", "return   initDataBinder ( dataBinder ,    exchange )  ;", "}", "METHOD_END"], "methodName": ["createDataBinder"], "fileName": "org.springframework.web.reactive.BindingContext"}, {"methodBody": ["METHOD_START", "{", "return   createDataBinder ( exchange ,    null ,    name )  ;", "}", "METHOD_END"], "methodName": ["createDataBinder"], "fileName": "org.springframework.web.reactive.BindingContext"}, {"methodBody": ["METHOD_START", "{", "return   this . model ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.springframework.web.reactive.BindingContext"}, {"methodBody": ["METHOD_START", "{", "return   binder ;", "}", "METHOD_END"], "methodName": ["initDataBinder"], "fileName": "org.springframework.web.reactive.BindingContext"}, {"methodBody": ["METHOD_START", "{", "return   this . handlerMappings ;", "}", "METHOD_END"], "methodName": ["getHandlerMappings"], "fileName": "org.springframework.web.reactive.DispatcherHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . resultHandlers )     !  =    null )     {", "for    ( HandlerResultHandler   resultHandler    :    this . resultHandlers )     {", "if    ( resultHandler . supports ( handlerResult )  )     {", "return   resultHandler ;", "}", "}", "}", "throw   new   IllegalStateException (  (  \" No   HandlerResultHandler   for    \"     +     ( handlerResult . getReturnValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getResultHandler"], "fileName": "org.springframework.web.reactive.DispatcherHandler"}, {"methodBody": ["METHOD_START", "{", "return   getResultHandler ( result )  . handleResult ( exchange ,    result )  . onErrorResume (  (    ex )     -  >    result . applyExceptionHandler ( ex )  . flatMap (  (    exceptionResult )     -  >    getResultHandler ( exceptionResult )  . handleResult ( exchange ,    exceptionResult )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleResult"], "fileName": "org.springframework.web.reactive.DispatcherHandler"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    HandlerMapping >    mappingBeans    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( context ,    HandlerMapping . class ,    true ,    false )  ;", "ArrayList < HandlerMapping >    mappings    =    new   ArrayList <  >  ( mappingBeans . values (  )  )  ;", "AnnotationAwareOrderComparator . sort ( mappings )  ;", "this . handlerMappings    =    Collections . unmodifiableList ( mappings )  ;", "Map < String ,    HandlerAdapter >    adapterBeans    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( context ,    HandlerAdapter . class ,    true ,    false )  ;", "this . handlerAdapters    =    new   ArrayList <  >  ( adapterBeans . values (  )  )  ;", "AnnotationAwareOrderComparator . sort ( this . handlerAdapters )  ;", "Map < String ,    HandlerResultHandler >    beans    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( context ,    HandlerResultHandler . class ,    true ,    false )  ;", "this . resultHandlers    =    new   ArrayList <  >  ( beans . values (  )  )  ;", "AnnotationAwareOrderComparator . sort ( this . resultHandlers )  ;", "}", "METHOD_END"], "methodName": ["initStrategies"], "fileName": "org.springframework.web.reactive.DispatcherHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . handlerAdapters )     !  =    null )     {", "for    ( Adapter   handlerAdapter    :    this . handlerAdapters )     {", "if    ( handlerAdapter . supports ( handler )  )     {", "return   handlerAdapter . handle ( exchange ,    handler )  ;", "}", "}", "}", "return   Mono . error ( new   IllegalStateException (  (  \" No   Adapter :     \"     +    handler )  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeHandler"], "fileName": "org.springframework.web.reactive.DispatcherHandler"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / error - signal \"  )  )  ;", "Mono < Void >    publisher    =    this . dispatcherHandler . handle ( exchange )  ;", "StepVerifier . create ( publisher )  . consumeErrorWith (  (    error )     -  >    assertSame (  . EXCEPTION ,    error )  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["controllerReturnsMonoError"], "fileName": "org.springframework.web.reactive.DispatcherHandlerErrorTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / raise - exception \"  )  )  ;", "Mono < Void >    publisher    =    this . dispatcherHandler . handle ( exchange )  ;", "StepVerifier . create ( publisher )  . consumeErrorWith (  (    error )     -  >    assertSame (  . EXCEPTION ,    error )  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["controllerThrowsException"], "fileName": "org.springframework.web.reactive.DispatcherHandlerErrorTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / does - not - exist \"  )  )  ;", "Mono < Void >    publisher    =    this . d . handle ( exchange )  ;", "StepVerifier . create ( publisher )  . consumeErrorWith (  (    error )     -  >     {", "assertThat ( error ,    instanceOf (  . class )  )  ;", "assertThat ( error . getMessage (  )  ,    is (  \" Response   status    4  0  4    with   reason    \\  \" No   matching   handler \\  \"  \"  )  )  ;", "}  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["noHandler"], "fileName": "org.springframework.web.reactive.DispatcherHandlerErrorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . post (  \"  / request - body \"  )  . body ( Mono . error ( DispatcherHandlerErrorTests . EXCEPTION )  )  )  ;", "Mono < Void >    publisher    =    this . dispatcherHandler . handle ( exchange )  ;", "StepVerifier . create ( publisher )  . consumeErrorWith (  (    error )     -  >    assertSame ( DispatcherHandlerErrorTests . EXCEPTION ,    error )  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["requestBodyError"], "fileName": "org.springframework.web.reactive.DispatcherHandlerErrorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . post (  \"  / request - body \"  )  . accept ( MediaType . APPLICATION _ JSON )  . body (  \" body \"  )  )  ;", "Mono < Void >    publisher    =    this . d . handle ( exchange )  ;", "StepVerifier . create ( publisher )  . consumeErrorWith (  (    error )     -  >    assertThat ( error ,    instanceOf (  . class )  )  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["responseBodyMessageConversionError"], "fileName": "org.springframework.web.reactive.DispatcherHandlerErrorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . TestConfig . class )  ;", "ctx . refresh (  )  ;", "this . dispatcherHandler    =    new   DispatcherHandler ( ctx )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.DispatcherHandlerErrorTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / unknown - return - type \"  )  )  ;", "Mono < Void >    publisher    =    this . d . handle ( exchange )  ;", "StepVerifier . create ( publisher )  . consumeErrorWith (  (    error )     -  >     {", "assertThat ( error ,    instanceOf (  . class )  )  ;", "assertThat ( error . getMessage (  )  ,    startsWith (  \" No   HandlerResultHandler \"  )  )  ;", "}  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["unknownReturnType"], "fileName": "org.springframework.web.reactive.DispatcherHandlerErrorTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / unknown - argument - type \"  )  )  ;", "List < WebExceptionHandler >    handlers    =    Collections . singletonList ( new    . ServerError 5  0  0 ExceptionHandler (  )  )  ;", "WebHandler   webHandler    =    new   ExceptionHandlingWebHandler ( this . dispatcherHandler ,    handlers )  ;", "webHandler . handle ( exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( INTERNAL _ SERVER _ ERROR ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["webExceptionHandler"], "fileName": "org.springframework.web.reactive.DispatcherHandlerErrorTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMapping   hm 1     =    mock ( HandlerMapping . class ,    withSettings (  )  . extraInterfaces ( Ordered . class )  )  ;", "HandlerMapping   hm 2     =    mock ( HandlerMapping . class ,    withSettings (  )  . extraInterfaces ( Ordered . class )  )  ;", "when (  (  ( Ordered )     ( hm 1  )  )  . getOrder (  )  )  . thenReturn (  1  )  ;", "when (  (  ( Ordered )     ( hm 2  )  )  . getOrder (  )  )  . thenReturn (  2  )  ;", "when ( hm 1  . getHandler ( any (  )  )  )  . thenReturn ( Mono . just (  (  ( Supplier < String >  )     (  (  )     -  >     \"  1  \"  )  )  )  )  ;", "when ( hm 2  . getHandler ( any (  )  )  )  . thenReturn ( Mono . just (  (  ( Supplier < String >  )     (  (  )     -  >     \"  2  \"  )  )  )  )  ;", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . registerBean (  \" b 2  \"  ,    HandlerMapping . class ,     (  )     -  >    hm 2  )  ;", "context . registerBean (  \" b 1  \"  ,    HandlerMapping . class ,     (  )     -  >    hm 1  )  ;", "context . registerBean ( HandlerAdapter . class ,     . SupplierHandlerAdapter :  : new )  ;", "context . registerBean ( HandlerResultHandler . class ,     . StringHandlerResultHandler :  : new )  ;", "context . refresh (  )  ;", "DispatcherHandler   dispatcherHandler    =    new   DispatcherHandler ( context )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "dispatcherHandler . handle ( exchange )  . block ( Duration . ofSeconds (  0  )  )  ;", "assertEquals (  \"  1  \"  ,    exchange . getResponse (  )  . getBodyAsString (  )  . block ( Duration . ofSeconds (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handlerMappingOrder"], "fileName": "org.springframework.web.reactive.DispatcherHandlerTests"}, {"methodBody": ["METHOD_START", "{", "super . setup (  )  ;", "thisClient    =    WebClient . create (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.FlushingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    this . webClient . get (  )  . uri (  \"  / write - and - never - complete \"  )  . retrieve (  )  . bodyToFlux ( String . class )  . next (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    s )     -  >    s . startsWith (  \"  0  1  2  3  4  5  6  7  8  9  \"  )  )  . expectComplete (  )  . verify ( Du . ofSeconds (  1  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["writeAndAutoFlushBeforeComplete"], "fileName": "org.springframework.web.reactive.FlushingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    this . webClient . get (  )  . uri (  \"  / write - and - complete \"  )  . retrieve (  )  . bodyToFlux ( String . class )  . reduce (  (    s 1  ,    s 2  )     -  >    s 1     +    s 2  )  ;", "try    {", "StepVerifier . create ( result )  . consumeNextWith (  (    value )     -  >    assertTrue (  (  ( value . length (  )  )     =  =     (  2  0  0  0  0     *     (  \"  0  1  2  3  4  5  6  7  8  9  \"  . length (  )  )  )  )  )  )  . expectComplete (  )  . verify ( Du . ofSeconds (  1  0 L )  )  ;", "}    catch    ( AssertionError   err )     {", "String   os    =    System . getProperty (  \" os . name \"  )  . toLowerCase (  )  ;", "if    (  ( os . contains (  \" windows \"  )  )     &  &     ( err . getMessage (  )  . startsWith (  \" VerifySubscriber   timed   out \"  )  )  )     {", "err . printStackTrace (  )  ;", "return ;", "}", "throw   err ;", "}", "}", "METHOD_END"], "methodName": ["writeAndAutoFlushOnComplete"], "fileName": "org.springframework.web.reactive.FlushingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    this . webClient . get (  )  . uri (  \"  / write - and - flush \"  )  . retrieve (  )  . bodyToFlux ( String . class )  . takeUntil (  (    s )     -  >    s . endsWith (  \" data 1  \"  )  )  . reduce (  (    s 1  ,    s 2  )     -  >    s 1     +    s 2  )  ;", "StepVerifier . create ( result )  . expectNext (  \" data 0 data 1  \"  )  . expectComplete (  )  . verify ( Du . ofSeconds (  1  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["writeAndFlushWith"], "fileName": "org.springframework.web.reactive.FlushingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this . exceptionHandler )     !  =    null    ?    this . exceptionHandler . apply ( failure )     :    Mono . error ( failure )  ;", "}", "METHOD_END"], "methodName": ["applyExceptionHandler"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingContext ;", "}", "METHOD_END"], "methodName": ["getBindingContext"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "return   this . handler ;", "}", "METHOD_END"], "methodName": ["getHandler"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingContext . getModel (  )  ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "return   this . returnType ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "return    (  ( MethodParameter )     ( this . returnType . getSource (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getReturnTypeSource"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "return   this . returnValue ;", "}", "METHOD_END"], "methodName": ["getReturnValue"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "return    ( this . exceptionHandler )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasExceptionHandler"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "this . exceptionHandler    =    function ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExceptionHandler"], "fileName": "org.springframework.web.reactive.HandlerResult"}, {"methodBody": ["METHOD_START", "{", "return   this . contentTypes ;", "}", "METHOD_END"], "methodName": ["getContentTypes"], "fileName": "org.springframework.web.reactive.accept.FixedContentTypeResolver"}, {"methodBody": ["METHOD_START", "{", "String   header    =     \" text / plain ;    q =  0  .  5  ,    text / html ,    text / x - dvi ;    q =  0  .  8  ,    text / x - c \"  ;", "List < MediaType >    mediaTypes    =    this . resolver . resolveMediaTypes ( MockServerWebExchange . from ( mock . http . server . reactive . test . MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" accept \"  ,    header )  )  )  ;", "assertEquals (  4  ,    mediaTypes . size (  )  )  ;", "assertEquals (  \" text / html \"  ,    mediaTypes . get (  0  )  . toString (  )  )  ;", "assertEquals (  \" text / x - c \"  ,    mediaTypes . get (  1  )  . toString (  )  )  ;", "assertEquals (  \" text / x - dvi ; q =  0  .  8  \"  ,    mediaTypes . get (  2  )  . toString (  )  )  ;", "assertEquals (  \" text / plain ; q =  0  .  5  \"  ,    mediaTypes . get (  3  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypes"], "fileName": "org.springframework.web.reactive.accept.HeaderContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   header    =     \" textplain ;    q =  0  .  5  \"  ;", "this . resolver . resolveMediaTypes ( MockServerWebExchange . from ( mock . http . server . reactive . test . MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" accept \"  ,    header )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMediaTypesParseError"], "fileName": "org.springframework.web.reactive.accept.HeaderContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   key . toLowerCase ( Locale . ENGLISH )  ;", "}", "METHOD_END"], "methodName": ["formatKey"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterName ;", "}", "METHOD_END"], "methodName": ["getParameterName"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( parameterName ,     \"  ' parameterName '    is   required \"  )  ;", "this . parameterName    =    parameterName ;", "}", "METHOD_END"], "methodName": ["setParameterName"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolver"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( MockServerHttpRequest . get (  (  \"  / path ? format =  \"     +    format )  )  )  ;", "}", "METHOD_END"], "methodName": ["createExchange"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "ParameterContentTypeResolver   resolver    =    new   ParameterContentTypeResolver ( Collections . emptyMap (  )  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( RequestedContentTypeResolver . MEDIA _ TYPE _ ALL _ LIST ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["noKey"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "ParameterContentTypeResolver   resolver    =    new   ParameterContentTypeResolver ( Collections . emptyMap (  )  )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( createExchange (  \" blah \"  )  )  ;", "assertEquals (  0  ,    mediaTypes . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["noMatchForKey"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    createExchange (  \" html \"  )  ;", "Map < String ,    MediaType >    mapping    =    Collections . emptyMap (  )  ;", "RequestedContentTypeResolver   resolver    =    new    ( mapping )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( Collections . singletonList ( new   MediaType (  \" text \"  ,     \" html \"  )  )  ,    mediaTypes )  ;", "mapping    =    Collections . singletonMap (  \" HTML \"  ,    APPLICATION _ XHTML _ XML )  ;", "resolver    =    new    ( mapping )  ;", "mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( Collections . singletonList ( new   MediaType (  \" application \"  ,     \" xhtml + xml \"  )  )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolveKeyFromRegistrations"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    createExchange (  \" JSoN \"  )  ;", "Map < String ,    MediaType >    mapping    =    Collections . singletonMap (  \" json \"  ,    APPLICATION _ JSON )  ;", "resolver    =    new    ( mapping )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( Collections . singletonList ( APPLICATION _ JSON )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolveKeyIsCaseInsensitive"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    createExchange (  \" xls \"  )  ;", "RequestedContentTypeResolver   resolver    =    new    ( Collections . emptyMap (  )  )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( Collections . singletonList ( new   MediaType (  \" application \"  ,     \" vnd . ms - excel \"  )  )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolveKeyThroughMediaTypeFactory"], "fileName": "org.springframework.web.reactive.accept.ParameterContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < RequestedContentTypeResolver >    resolvers    =     ( this . candidates . isEmpty (  )  )     ?    Collections . singletonList ( new   HeaderContentTypeResolver (  )  )     :    this . candidates . stream (  )  . map ( Supplier :  : get )  . collect ( Collectors . toList (  )  )  ;", "return    (    exchange )     -  >     {", "for    ( RequestedContentTypeResolver   resolver    :    resolvers )     {", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "if    ( mediaTypes . equals ( RequestedContentTypeResolver . MEDIA _ TYPE _ ALL _ LIST )  )     {", "continue ;", "}", "return   mediaTypes ;", "}", "return   RequestedContentTypeResolver . MEDIA _ TYPE _ ALL _ LIST ;", "}  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilder"}, {"methodBody": ["METHOD_START", "{", "this . candidates . add (  (  )     -  >    new   FixedContentTypeResolver ( Arrays . asList ( mediaTypes )  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedResolver"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilder"}, {"methodBody": ["METHOD_START", "{", "this . candidates . add ( HeaderContentTypeResolver :  : new )  ;", "}", "METHOD_END"], "methodName": ["headerResolver"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilder"}, {"methodBody": ["METHOD_START", "{", "RequestedContentTypeResolverBuilder . ParameterResolverConfigurer   parameterBuilder    =    new   RequestedContentTypeResolverBuilder . ParameterResolverConfigurer (  )  ;", "this . candidates . add ( parameterBuilder :  : createResolver )  ;", "return   parameterBuilder ;", "}", "METHOD_END"], "methodName": ["parameterResolver"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilder"}, {"methodBody": ["METHOD_START", "{", "this . candidates . add (  (  )     -  >    resolver )  ;", "}", "METHOD_END"], "methodName": ["resolver"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilder"}, {"methodBody": ["METHOD_START", "{", "RequestedContentTypeResolver   resolver    =    new   RequestedContentTypeResolverBuilder (  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / flower \"  )  . accept ( IMAGE _ GIF )  )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( Collections . singletonList ( IMAGE _ GIF )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["defaultSettings"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "RequestedContentTypeResolverBuilder   builder    =    new   RequestedContentTypeResolverBuilder (  )  ;", "builder . fixedResolver ( APPLICATION _ JSON )  ;", "RequestedContentTypeResolver   resolver    =    builder . build (  )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . accept ( ALL )  )  )  ;", "assertEquals ( Collections . singletonList ( APPLICATION _ JSON )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["fixedResolver"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "RequestedContentTypeResolverBuilder   builder    =    new   RequestedContentTypeResolverBuilder (  )  ;", "builder . parameterResolver (  )  . mediaType (  \" json \"  ,    APPLICATION _ JSON )  ;", "RequestedContentTypeResolver   resolver    =    builder . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / flower ? format = json \"  )  )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( Collections . singletonList ( APPLICATION _ JSON )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["parameterResolver"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "RequestedContentTypeResolverBuilder   builder    =    new   RequestedContentTypeResolverBuilder (  )  ;", "builder . parameterResolver (  )  . mediaType (  \" json \"  ,    APPLICATION _ JSON )  . parameterName (  \" s \"  )  ;", "RequestedContentTypeResolver   resolver    =    builder . build (  )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / flower ? s = json \"  )  )  )  ;", "assertEquals ( Collections . singletonList ( APPLICATION _ JSON )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["parameterResolverWithCustomParamName"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "RequestedContentTypeResolverBuilder   builder    =    new   RequestedContentTypeResolverBuilder (  )  ;", "builder . resolver ( new   FixedContentTypeResolver ( MediaType . APPLICATION _ JSON )  )  ;", "RequestedContentTypeResolver   resolver    =    builder . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "List < MediaType >    mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( Collections . singletonList ( APPLICATION _ JSON )  ,    mediaTypes )  ;", "exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . accept ( ALL )  )  ;", "mediaTypes    =    resolver . resolveMediaTypes ( exchange )  ;", "assertEquals ( Collections . singletonList ( APPLICATION _ JSON )  ,    mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["resolver"], "fileName": "org.springframework.web.reactive.accept.RequestedContentTypeResolverBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . config . setAllowCredentials ( allowCredentials )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["allowCredentials"], "fileName": "org.springframework.web.reactive.config.CorsRegistration"}, {"methodBody": ["METHOD_START", "{", "this . config . setAllowedHeaders ( new   ArrayList ( Arrays . asList ( headers )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["allowedHeaders"], "fileName": "org.springframework.web.reactive.config.CorsRegistration"}, {"methodBody": ["METHOD_START", "{", "this . config . setAllowedMethods ( new   ArrayList ( Arrays . asList ( methods )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["allowedMethods"], "fileName": "org.springframework.web.reactive.config.CorsRegistration"}, {"methodBody": ["METHOD_START", "{", "this . config . setAllowedOrigins ( new   ArrayList ( Arrays . asList ( origins )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["allowedOrigins"], "fileName": "org.springframework.web.reactive.config.CorsRegistration"}, {"methodBody": ["METHOD_START", "{", "this . config . setExposedHeaders ( new   ArrayList ( Arrays . asList ( headers )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exposedHeaders"], "fileName": "org.springframework.web.reactive.config.CorsRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . config ;", "}", "METHOD_END"], "methodName": ["getCorsConfiguration"], "fileName": "org.springframework.web.reactive.config.CorsRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . pathPattern ;", "}", "METHOD_END"], "methodName": ["getPathPattern"], "fileName": "org.springframework.web.reactive.config.CorsRegistration"}, {"methodBody": ["METHOD_START", "{", "this . config . setMaxAge ( maxAge )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxAge"], "fileName": "org.springframework.web.reactive.config.CorsRegistration"}, {"methodBody": ["METHOD_START", "{", "CorsRegistration   registration    =    new   CorsRegistration ( pathPattern )  ;", "this . registrations . add ( registration )  ;", "return   registration ;", "}", "METHOD_END"], "methodName": ["addMapping"], "fileName": "org.springframework.web.reactive.config.CorsRegistry"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    CorsConfiguration >    configs    =    new   LinkedHashMap <  >  ( this . registrations . size (  )  )  ;", "for    ( ation   registration    :    this . registrations )     {", "configs . put ( registration . getPathPattern (  )  ,    registration . getCorsConfiguration (  )  )  ;", "}", "return   configs ;", "}", "METHOD_END"], "methodName": ["getCorsConfigurations"], "fileName": "org.springframework.web.reactive.config.CorsRegistry"}, {"methodBody": ["METHOD_START", "{", "this . registry . addMapping (  \"  / foo \"  )  . allowedOrigins (  \" http :  /  / domain 2  . com \"  ,     \" http :  /  / domain 2  . com \"  )  . allowedMethods (  \" DELETE \"  )  . allowCredentials ( false )  . allowedHeaders (  \" header 1  \"  ,     \" header 2  \"  )  . exposedHeaders (  \" header 3  \"  ,     \" header 4  \"  )  . maxAge (  3  6  0  0  )  ;", "Map < String ,    CorsConfiguration >    configs    =    this . registry . getCorsConfigurations (  )  ;", "assertEquals (  1  ,    configs . size (  )  )  ;", "CorsConfiguration   config    =    configs . get (  \"  / foo \"  )  ;", "assertEquals ( Arrays . asList (  \" http :  /  / domain 2  . com \"  ,     \" http :  /  / domain 2  . com \"  )  ,    config . getAllowedOrigins (  )  )  ;", "assertEquals ( Arrays . asList (  \" DELETE \"  )  ,    config . getAllowedMethods (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 1  \"  ,     \" header 2  \"  )  ,    config . getAllowedHeaders (  )  )  ;", "assertEquals ( Arrays . asList (  \" header 3  \"  ,     \" header 4  \"  )  ,    config . getExposedHeaders (  )  )  ;", "assertEquals ( false ,    config . getAllowCredentials (  )  )  ;", "assertEquals ( Long . valueOf (  3  6  0  0  )  ,    config . getMaxAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["customizedMapping"], "fileName": "org.springframework.web.reactive.config.CorsRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registry . addMapping (  \"  / foo \"  )  ;", "this . registry . addMapping (  \"  / bar \"  )  ;", "assertEquals (  2  ,    this . registry . getCorsConfigurations (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleMappings"], "fileName": "org.springframework.web.reactive.config.CorsRegistryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . registry . getCorsConfigurations (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["noMapping"], "fileName": "org.springframework.web.reactive.config.CorsRegistryTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( configurers )  )  )     {", "this . configurers . adders ( configurers )  ;", "}", "}", "METHOD_END"], "methodName": ["setConfigurers"], "fileName": "org.springframework.web.reactive.config.DelegatingWebFluxConfiguration"}, {"methodBody": ["METHOD_START", "{", "delegatingConfig . setConfigurers ( Collections . singletonList ( webFluxConfigurer )  )  ;", "ConfigurableWebBindingInitializer   initializer    =     (  ( ConfigurableWebBindingInitializer )     ( this . delegatingConfig . requestMappingHandlerAdapter (  )  . getWebBindingInitializer (  )  )  )  ;", "verify ( webFluxConfigurer )  . configureHttpMessageCodecs ( codecsConfigurer . capture (  )  )  ;", "verify ( webFluxConfigurer )  . getValidator (  )  ;", "verify ( webFluxConfigurer )  . getMessageCodesResolver (  )  ;", "verify ( webFluxConfigurer )  . addFormatters ( formatterRegistry . capture (  )  )  ;", "verify ( webFluxConfigurer )  . configureArgumentResolvers ( any (  )  )  ;", "assertNotNull ( initializer )  ;", "assertTrue (  (  ( initializer . getValidator (  )  )    instanceof   LocalValidatorFactoryBean )  )  ;", "assertSame ( formatterRegistry . getValue (  )  ,    initializer . getConversionService (  )  )  ;", "assertEquals (  1  2  ,    codecsConfigurer . getValue (  )  . getReaders (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestMappingHandlerAdapter"], "fileName": "org.springframework.web.reactive.config.DelegatingWebFluxConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "delegatingConfig . setConfigurers ( Collections . singletonList ( webFluxConfigurer )  )  ;", "delegatingConfig . requestMappingHandlerMapping (  )  ;", "verify ( webFluxConfigurer )  . configureContentTypeResolver ( any ( RequestedContentTypeResolverBuilder . class )  )  ;", "verify ( webFluxConfigurer )  . addCorsMappings ( any ( CorsRegistry . class )  )  ;", "verify ( webFluxConfigurer )  . configurePathMatching ( any ( PathMatchConfigurer . class )  )  ;", "}", "METHOD_END"], "methodName": ["requestMappingHandlerMapping"], "fileName": "org.springframework.web.reactive.config.DelegatingWebFluxConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "delegatingConfig . setConfigurers ( Collections . singletonList ( webFluxConfigurer )  )  ;", "doAnswer (  (    invocation )     -  >     {", "ResourceHandlerRegistry   registry    =    invocation . getArgument (  0  )  ;", "registry . addResourceHandler (  \"  / static /  *  *  \"  )  . addResourceLocations (  \" classpath :  / static \"  )  ;", "return   null ;", "}  )  . when ( webFluxConfigurer )  . addResourceHandlers ( any ( ResourceHandlerRegistry . class )  )  ;", "delegatingConfig . resourceHandlerMapping (  )  ;", "verify ( webFluxConfigurer )  . addResourceHandlers ( any ( ResourceHandlerRegistry . class )  )  ;", "verify ( webFluxConfigurer )  . configurePathMatching ( any ( PathMatchConfigurer . class )  )  ;", "}", "METHOD_END"], "methodName": ["resourceHandlerMapping"], "fileName": "org.springframework.web.reactive.config.DelegatingWebFluxConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "delegatingConfig . setConfigurers ( Collections . singletonList ( webFluxConfigurer )  )  ;", "delegatingConfig . responseBodyResultHandler (  )  ;", "verify ( webFluxConfigurer )  . configureHttpMessageCodecs ( codecsConfigurer . capture (  )  )  ;", "verify ( webFluxConfigurer )  . configureContentTypeResolver ( any ( RequestedContentTypeResolverBuilder . class )  )  ;", "}", "METHOD_END"], "methodName": ["responseBodyResultHandler"], "fileName": "org.springframework.web.reactive.config.DelegatingWebFluxConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "delegatingConfig    =    new    (  )  ;", "delegatingConfig . setApplicationContext ( new   StaticApplicationContext (  )  )  ;", "given ( webFluxConfigurer . getValidator (  )  )  . willReturn ( null )  ;", "given ( webFluxConfigurer . getMessageCodesResolver (  )  )  . willReturn ( null )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.config.DelegatingWebFluxConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "delegatingConfig . setConfigurers ( Collections . singletonList ( webFluxConfigurer )  )  ;", "delegatingConfig . viewResolutionResultHandler (  )  ;", "verify ( webFluxConfigurer )  . configureViewResolvers ( any ( ViewResolverRegistry . class )  )  ;", "}", "METHOD_END"], "methodName": ["viewResolutionResultHandler"], "fileName": "org.springframework.web.reactive.config.DelegatingWebFluxConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . caseSensitiveMatch ;", "}", "METHOD_END"], "methodName": ["isUseCaseSensitiveMatch"], "fileName": "org.springframework.web.reactive.config.PathMatchConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   this . trailingSlashMatch ;", "}", "METHOD_END"], "methodName": ["isUseTrailingSlashMatch"], "fileName": "org.springframework.web.reactive.config.PathMatchConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . caseSensitiveMatch    =    caseSensitiveMatch ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUseCaseSensitiveMatch"], "fileName": "org.springframework.web.reactive.config.PathMatchConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . trailingSlashMatch    =    trailingSlashMatch ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUseTrailingSlashMatch"], "fileName": "org.springframework.web.reactive.config.PathMatchConfigurer"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resolver ,     \" The   provided   ResourceResolver   should   not   be   null \"  )  ;", "this . resolvers . add ( resolver )  ;", "if    ( resolver   instanceof   VersionResourceResolver )     {", "this . hasVersionResolver    =    true ;", "} else", "if    ( resolver   instanceof   resource . PathResourceResolver )     {", "this . hasPathResolver    =    true ;", "} else", "if    ( resolver   instanceof   resource . WebJarsResourceResolver )     {", "this . hasWebjarsResolver    =    true ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addResolver"], "fileName": "org.springframework.web.reactive.config.ResourceChainRegistration"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( transformer ,     \" The   provided   ResourceTransformer   should   not   be   null \"  )  ;", "this . transformers . add ( transformer )  ;", "if    ( transformer   instanceof   CssLinkResourceTransformer )     {", "this . hasCssLinkTransformer    =    true ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addTransformer"], "fileName": "org.springframework.web.reactive.config.ResourceChainRegistration"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . hasPathResolver )  )     {", "List < ResourceResolver >    result    =    new   ArrayList <  >  ( this . resolvers )  ;", "if    (  (  . isWebJarsAssetLocatorPresent )     &  &     (  !  ( this . hasWebjarsResolver )  )  )     {", "result . add ( new   WebJarsResourceResolver (  )  )  ;", "}", "result . add ( new   PathResourceResolver (  )  )  ;", "return   result ;", "}", "return   this . resolvers ;", "}", "METHOD_END"], "methodName": ["getResourceResolvers"], "fileName": "org.springframework.web.reactive.config.ResourceChainRegistration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . hasVersionResolver )     &  &     (  !  ( this . hasCssLinkTransformer )  )  )     {", "List < Transformer >    result    =    new   ArrayList <  >  ( this . transformers )  ;", "boolean   hasTransformers    =     !  ( this . transformers . isEmpty (  )  )  ;", "boolean   hasCaching    =    hasTransformers    &  &     (  ( this . transformers . get (  0  )  )    instanceof   CachingTransformer )  ;", "result . add (  ( hasCaching    ?     1     :     0  )  ,    new   CssLinkTransformer (  )  )  ;", "return   result ;", "}", "return   this . transformers ;", "}", "METHOD_END"], "methodName": ["getResourceTransformers"], "fileName": "org.springframework.web.reactive.config.ResourceChainRegistration"}, {"methodBody": ["METHOD_START", "{", "for    ( String   location    :    resourceLocations )     {", "this . locations . add ( this . resourceLoader . get ( location )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addResourceLocations"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . pathPatterns ;", "}", "METHOD_END"], "methodName": ["getPathPatterns"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "ResourceWebHandler   handler    =    new   ResourceWebHandler (  )  ;", "if    (  ( this . resourceChain )     !  =    null )     {", "handler . setResourceResolvers ( this . resourceChain . getResourceResolvers (  )  )  ;", "handler . setResourceTransformers ( this . resourceChain . getResourceTransformers (  )  )  ;", "}", "handler . setLocations ( this . locations )  ;", "if    (  ( this . cacheControl )     !  =    null )     {", "handler . setCacheControl ( this . cacheControl )  ;", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["getRequestHandler"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "this . resourceChainRegistration    =    new   ResourceChainRegistration ( cacheResources )  ;", "return   this . resourceChainRegistration ;", "}", "METHOD_END"], "methodName": ["resourceChain"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "this . resourceChainRegistration    =    new   ResourceChainRegistration ( cacheResources ,    cache )  ;", "return   this . resourceChainRegistration ;", "}", "METHOD_END"], "methodName": ["resourceChain"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "this . cacheControl    =    cacheControl ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCacheControl"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "ResourceHandlerRegistration   registration    =    new   ResourceHandlerRegistration ( this . resourceLoader ,    patterns )  ;", "this . registrations . add ( registration )  ;", "return   registration ;", "}", "METHOD_END"], "methodName": ["addResourceHandler"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( this . registrations . isEmpty (  )  )     {", "return   null ;", "}", "Map < String ,    WebHandler >    urlMap    =    new   LinkedHashMap <  >  (  )  ;", "for    ( ation   registration    :    this . registrations )     {", "for    ( String   pathPattern    :    registration . getPathPatterns (  )  )     {", "ResourceWebHandler   handler    =    registration . getRequestHandler (  )  ;", "try    {", "handler . afterPropertiesSet (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanInitializationException (  \" Failed   to   init   ResourceHttpRequestHandler \"  ,    ex )  ;", "}", "urlMap . put ( pathPattern ,    handler )  ;", "}", "}", "SimpleUrlHandlerMapping   handlerMapping    =    new   SimpleUrlHandlerMapping (  )  ;", "handlerMapping . setOrder ( this . order )  ;", "handlerMapping . setUrlMap ( urlMap )  ;", "return   handlerMapping ;", "}", "METHOD_END"], "methodName": ["getHandlerMapping"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "for    ( ResourceHandlerRegistration   registration    :    this . registrations )     {", "if    ( Arrays . asList ( registration . getPathPatterns (  )  )  . contains ( pathPattern )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasMappingForPattern"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "assertThat ( getHandler (  \"  / resources /  *  *  \"  )  . getCacheControl (  )  ,    Matchers . nullValue (  )  )  ;", "this . registration . setCacheControl ( CacheControl . noCache (  )  . cachePrivate (  )  )  ;", "assertThat ( getHandler (  \"  / resources /  *  *  \"  )  . getCacheControl (  )  . getHeaderValue (  )  ,    Matchers . equalTo ( CacheControl . noCache (  )  . cachePrivate (  )  . getHeaderValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheControl"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SimpleUrlHandlerMapping   mapping    =     (  ( SimpleUrlHandlerMapping )     ( this . registry . getHandlerMapping (  )  )  )  ;", "return    (  ( WebHandler )     ( mapping . getUrlMap (  )  . get ( pathPattern )  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandler"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . registry . hasMappingForPattern (  \"  / resources /  *  *  \"  )  )  ;", "assertFalse ( this . registry . hasMappingForPattern (  \"  / whatever \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hasMappingForPattern"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "exchange . getAttributes (  )  . put ( HandlerMapping . PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE ,    PathContainer . parsePath (  \"  / testStylesheet . css \"  )  )  ;", "WebHandler   handler    =    getHandler (  \"  / resources /  *  *  \"  )  ;", "handler . handle ( exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "StepVerifier . create ( exchange . getResponse (  )  . getBody (  )  )  . consumeNextWith (  (    buf )     -  >    assertEquals (  \" test   stylesheet   content \"  ,    DataBufferTestUtils . dumpString ( buf ,    StandardCharsets . UTF _  8  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["mapPathToLocation"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registry    =    new   ResourceHandlerRegistry ( new   GenericApplicationContext (  )  )  ;", "assertNull ( this . registry . getHandlerMapping (  )  )  ;", "}", "METHOD_END"], "methodName": ["noResourceHandlers"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  ( Integer . MAX _ VALUE )     -     1  )  ,    this . registry . getHandlerMapping (  )  . getOrder (  )  )  ;", "this . registry . setOrder (  0  )  ;", "assertEquals (  0  ,    this . registry . getHandlerMapping (  )  . getOrder (  )  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "ResourceResolver   mockResolver    =    Mockito . mock ( ResourceResolver . class )  ;", "ResourceTransformer   mockTransformer    =    Mockito . mock ( ResourceTransformer . class )  ;", "this . registration . resourceChain ( true )  . addResolver ( mockResolver )  . addTransformer ( mockTransformer )  ;", "ResourceWebHandler   handler    =    getHandler (  \"  / resources /  *  *  \"  )  ;", "List < ResourceResolver >    resolvers    =    handler . getResourceResolvers (  )  ;", "assertThat ( resolvers . toString (  )  ,    resolvers ,    Matchers . hasSize (  4  )  )  ;", "assertThat ( resolvers . get (  0  )  ,    Matchers . instanceOf ( CachingResourceResolver . class )  )  ;", "CachingResourceResolver   cachingResolver    =     (  ( CachingResourceResolver )     ( resolvers . get (  0  )  )  )  ;", "assertThat ( cachingResolver . getCache (  )  ,    Matchers . instanceOf ( ConcurrentMapCache . class )  )  ;", "assertThat ( resolvers . get (  1  )  ,    Matchers . equalTo ( mockResolver )  )  ;", "assertThat ( resolvers . get (  2  )  ,    Matchers . instanceOf ( WebJarsResourceResolver . class )  )  ;", "assertThat ( resolvers . get (  3  )  ,    Matchers . instanceOf ( PathResourceResolver . class )  )  ;", "List < ResourceTransformer >    transformers    =    handler . getResourceTransformers (  )  ;", "assertThat ( transformers ,    Matchers . hasSize (  2  )  )  ;", "assertThat ( transformers . get (  0  )  ,    Matchers . instanceOf ( CachingResourceTransformer . class )  )  ;", "assertThat ( transformers . get (  1  )  ,    Matchers . equalTo ( mockTransformer )  )  ;", "}", "METHOD_END"], "methodName": ["resourceChain"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "CachingResourceResolver   cachingResolver    =    Mockito . mock ( CachingResourceResolver . class )  ;", "VersionResourceResolver   versionResolver    =    Mockito . mock ( VersionResourceResolver . class )  ;", "WebJarsResourceResolver   webjarsResolver    =    Mockito . mock ( WebJarsResourceResolver . class )  ;", "PathResourceResolver   pathResourceResolver    =    new   PathResourceResolver (  )  ;", "CachingResourceTransformer   cachingTransformer    =    Mockito . mock ( CachingResourceTransformer . class )  ;", "AppCacheManifestTransformer   appCacheTransformer    =    Mockito . mock ( AppCacheManifestTransformer . class )  ;", "CssLinkResourceTransformer   cssLinkTransformer    =    new   CssLinkResourceTransformer (  )  ;", "this . registration . setCacheControl ( CacheControl . maxAge (  3  6  0  0  ,    TimeUnit . MILLISECONDS )  )  . resourceChain ( false )  . addResolver ( cachingResolver )  . addResolver ( versionResolver )  . addResolver ( webjarsResolver )  . addResolver ( pathResourceResolver )  . addTransformer ( cachingTransformer )  . addTransformer ( appCacheTransformer )  . addTransformer ( cssLinkTransformer )  ;", "ResourceWebHandler   handler    =    getHandler (  \"  / resources /  *  *  \"  )  ;", "List < ResourceResolver >    resolvers    =    handler . getResourceResolvers (  )  ;", "assertThat ( resolvers . toString (  )  ,    resolvers ,    Matchers . hasSize (  4  )  )  ;", "assertThat ( resolvers . get (  0  )  ,    Matchers . sameInstance ( cachingResolver )  )  ;", "assertThat ( resolvers . get (  1  )  ,    Matchers . sameInstance ( versionResolver )  )  ;", "assertThat ( resolvers . get (  2  )  ,    Matchers . sameInstance ( webjarsResolver )  )  ;", "assertThat ( resolvers . get (  3  )  ,    Matchers . sameInstance ( pathResourceResolver )  )  ;", "List < ResourceTransformer >    transformers    =    handler . getResourceTransformers (  )  ;", "assertThat ( transformers ,    Matchers . hasSize (  3  )  )  ;", "assertThat ( transformers . get (  0  )  ,    Matchers . sameInstance ( cachingTransformer )  )  ;", "assertThat ( transformers . get (  1  )  ,    Matchers . sameInstance ( appCacheTransformer )  )  ;", "assertThat ( transformers . get (  2  )  ,    Matchers . sameInstance ( cssLinkTransformer )  )  ;", "}", "METHOD_END"], "methodName": ["resourceChainWithOverrides"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  . addFixedVersionStrategy (  \" fixed \"  ,     \"  /  *  *  /  *  . js \"  )  . addContentVersionStrategy (  \"  /  *  *  \"  )  ;", "this . registration . resourceChain ( true )  . addResolver ( versionResolver )  . addTransformer ( new   AppCacheManifestTransformer (  )  )  ;", "ResourceWebHandler   handler    =    getHandler (  \"  / resources /  *  *  \"  )  ;", "List < ResourceResolver >    resolvers    =    handler . getResourceResolvers (  )  ;", "assertThat ( resolvers . toString (  )  ,    resolvers ,    Matchers . hasSize (  4  )  )  ;", "assertThat ( resolvers . get (  0  )  ,    Matchers . instanceOf ( CachingResourceResolver . class )  )  ;", "assertThat ( resolvers . get (  1  )  ,    Matchers . sameInstance ( versionResolver )  )  ;", "assertThat ( resolvers . get (  2  )  ,    Matchers . instanceOf ( WebJarsResourceResolver . class )  )  ;", "assertThat ( resolvers . get (  3  )  ,    Matchers . instanceOf ( PathResourceResolver . class )  )  ;", "List < ResourceTransformer >    transformers    =    handler . getResourceTransformers (  )  ;", "assertThat ( transformers ,    Matchers . hasSize (  3  )  )  ;", "assertThat ( transformers . get (  0  )  ,    Matchers . instanceOf ( CachingResourceTransformer . class )  )  ;", "assertThat ( transformers . get (  1  )  ,    Matchers . instanceOf ( CssLinkResourceTransformer . class )  )  ;", "assertThat ( transformers . get (  2  )  ,    Matchers . instanceOf ( AppCacheManifestTransformer . class )  )  ;", "}", "METHOD_END"], "methodName": ["resourceChainWithVersionResolver"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registration . resourceChain ( false )  ;", "WebHandler   handler    =    getHandler (  \"  / resources /  *  *  \"  )  ;", "List < Resolver >    resolvers    =    handler . getResolvers (  )  ;", "assertThat ( resolvers ,    Matchers . hasSize (  2  )  )  ;", "assertThat ( resolvers . get (  0  )  ,    Matchers . instanceOf ( WebJarsResolver . class )  )  ;", "assertThat ( resolvers . get (  1  )  ,    Matchers . instanceOf ( PathResolver . class )  )  ;", "List < Transformer >    transformers    =    handler . getTransformers (  )  ;", "assertThat ( transformers ,    Matchers . hasSize (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["resourceChainWithoutCaching"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registry    =    new   ResourceHandlerRegistry ( new   GenericApplicationContext (  )  )  ;", "this . registration    =    this . registry . addResourceHandler (  \"  / resources /  *  *  \"  )  ;", "this . registration . addResourceLocations (  \" classpath : org / springframework / web / reactive / config /  \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.config.ResourceHandlerRegistryTests"}, {"methodBody": ["METHOD_START", "{", "return   this . viewResolver ;", "}", "METHOD_END"], "methodName": ["getViewResolver"], "fileName": "org.springframework.web.reactive.config.UrlBasedViewResolverRegistration"}, {"methodBody": ["METHOD_START", "{", "this . viewResolver . setPrefix ( prefix )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["prefix"], "fileName": "org.springframework.web.reactive.config.UrlBasedViewResolverRegistration"}, {"methodBody": ["METHOD_START", "{", "this . viewResolver . setSuffix ( suffix )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["suffix"], "fileName": "org.springframework.web.reactive.config.UrlBasedViewResolverRegistration"}, {"methodBody": ["METHOD_START", "{", "this . viewResolver . setViewClass ( viewClass )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["viewClass"], "fileName": "org.springframework.web.reactive.config.UrlBasedViewResolverRegistration"}, {"methodBody": ["METHOD_START", "{", "this . viewResolver . setViewNames ( viewNames )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["viewNames"], "fileName": "org.springframework.web.reactive.config.UrlBasedViewResolverRegistration"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . applicationContext )     =  =    null )     |  |     (  !  ( ObjectUtils . isEmpty ( BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( this . applicationContext ,    beanType ,    false ,    false )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkBeanOfType"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "this . defaultViews . addAll ( Arrays . asList ( defaultViews )  )  ;", "}", "METHOD_END"], "methodName": ["defaultViews"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( checkBeanOfType ( FreeMarkerConfigurer . class )  )  )     {", "throw   new   BeanInitializationException (  (  \" In   addition   to   a   FreeMarker   view   resolver    \"     +     (  (  \" there   must   also   be   a   single   FreeMarkerConfig   bean   in   this   web   application   context    \"     +     \"  ( or   its   parent )  :    FreeMarkerConfigurer   is   the   usual   implementation .     \"  )     +     \" This   bean   may   be   given   any   name .  \"  )  )  )  ;", "}", ". FreeMarkerRegistration   registration    =    new    . FreeMarkerRegistration (  )  ;", "UrlBasedViewResolver   resolver    =    registration . getViewResolver (  )  ;", "if    (  ( this . applicationContext )     !  =    null )     {", "resolver . setApplicationContext ( this . applicationContext )  ;", "}", "this . viewResolvers . add ( resolver )  ;", "return   registration ;", "}", "METHOD_END"], "methodName": ["freeMarker"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultViews ;", "}", "METHOD_END"], "methodName": ["getDefaultViews"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "return    ( this . order )     !  =    null    ?    this . order    :    Ordered . LOWEST _ PRECEDENCE ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . viewResolvers ;", "}", "METHOD_END"], "methodName": ["getViewResolvers"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . viewResolvers . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasRegistrations"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( checkBeanOfType ( ScriptTemplateConfigurer . class )  )  )     {", "throw   new   BeanInitializationException (  (  \" In   addition   to   a   script   template   view   resolver    \"     +     (  (  \" there   must   also   be   a   single   ScriptTemplateConfig   bean   in   this   web   application   context    \"     +     \"  ( or   its   parent )  :    ScriptTemplateConfigurer   is   the   usual   implementation .     \"  )     +     \" This   bean   may   be   given   any   name .  \"  )  )  )  ;", "}", ". ScriptRegistration   registration    =    new    . ScriptRegistration (  )  ;", "UrlBasedViewResolver   resolver    =    registration . getViewResolver (  )  ;", "if    (  ( this . applicationContext )     !  =    null )     {", "resolver . setApplicationContext ( this . applicationContext )  ;", "}", "this . viewResolvers . add ( resolver )  ;", "return   registration ;", "}", "METHOD_END"], "methodName": ["scriptTemplate"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "this . viewResolvers . add ( viewResolver )  ;", "}", "METHOD_END"], "methodName": ["viewResolver"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistry"}, {"methodBody": ["METHOD_START", "{", "UrlBasedViewResolver   viewResolver    =    new   UrlBasedViewResolver (  )  ;", "this . registry . viewResolver ( viewResolver )  ;", "assertSame ( viewResolver ,    this . registry . getViewResolvers (  )  . get (  0  )  )  ;", "assertEquals (  1  ,    this . registry . getViewResolvers (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["customViewResolver"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistryTests"}, {"methodBody": ["METHOD_START", "{", "View   view    =    new   HttpMessageWriterView ( new   Jackson 2 JsonEncoder (  )  )  ;", "this . r . defaultViews ( view )  ;", "assertEquals (  1  ,    this . r . getDefaultViews (  )  . size (  )  )  ;", "assertSame ( view ,    this . r . getDefaultViews (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultViews"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistryTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . registry . hasRegistrations (  )  )  ;", "this . registry . freeMarker (  )  ;", "assertTrue ( this . registry . hasRegistrations (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasRegistrations"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistryTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( this . registry . getViewResolvers (  )  )  ;", "assertEquals (  0  ,    this . registry . getViewResolvers (  )  . size (  )  )  ;", "assertFalse ( this . registry . hasRegistrations (  )  )  ;", "}", "METHOD_END"], "methodName": ["noResolvers"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistryTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( LOWEST _ PRECEDENCE ,    this . registry . getOrder (  )  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registry . scriptTemplate (  )  . prefix (  \"  /  \"  )  . suffix (  \"  . html \"  )  ;", "List <  >    viewResolvers    =    this . registry . gets (  )  ;", "assertEquals (  1  ,    viewResolvers . size (  )  )  ;", "assertEquals ( ScriptTemplate . class ,    viewResolvers . get (  0  )  . getClass (  )  )  ;", "DirectFieldAccessor   accessor    =    new   DirectFieldAccessor ( viewResolvers . get (  0  )  )  ;", "assertEquals (  \"  /  \"  ,    accessor . getPropertyValue (  \" prefix \"  )  )  ;", "assertEquals (  \"  . html \"  ,    accessor . getPropertyValue (  \" suffix \"  )  )  ;", "}", "METHOD_END"], "methodName": ["scriptTemplate"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistryTests"}, {"methodBody": ["METHOD_START", "{", "StaticWebApplicationContext   context    =    new   StaticWebApplicationContext (  )  ;", "context . registerSingleton (  \" freeMarkerConfigurer \"  ,    FreeMarkerConfigurer . class )  ;", "context . registerSingleton (  \" scriptTemplateConfigurer \"  ,    ScriptTemplateConfigurer . class )  ;", "this . registry    =    new    ( context )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.config.ViewResolverRegistryTests"}, {"methodBody": ["METHOD_START", "{", "return   new   AcceptHeaderLocaleContextResolver (  )  ;", "}", "METHOD_END"], "methodName": ["createLocaleContextResolver"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestMappingHandlerAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["createRequestMappingHandlerAdapter"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestMappingHandlerMapping (  )  ;", "}", "METHOD_END"], "methodName": ["createRequestMappingHandlerMapping"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   RouterFunctionMapping (  )  ;", "}", "METHOD_END"], "methodName": ["createRouterFunctionMapping"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( webFluxConversionService (  )  )  ;", "initializer . setValidator ( webFluxValidator (  )  )  ;", "MessageCodesResolver   messageCodesResolver    =    getMessageCodesResolver (  )  ;", "if    ( messageCodesResolver    !  =    null )     {", "initializer . setMessageCodesResolver ( messageCodesResolver )  ;", "}", "return   initializer ;", "}", "METHOD_END"], "methodName": ["getConfigurableWebBindingInitializer"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . corsConfigurations )     =  =    null )     {", "CorsRegistry   registry    =    new   CorsRegistry (  )  ;", "addCorsMappings ( registry )  ;", "this . corsConfigurations    =    registry . getCorsConfigurations (  )  ;", "}", "return   this . corsConfigurations ;", "}", "METHOD_END"], "methodName": ["getCorsConfigurations"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getMessageCodesResolver"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . pathMatchConfigurer )     =  =    null )     {", "this . pathMatchConfigurer    =    new   PathMatchConfigurer (  )  ;", "configurePathMatching ( this . pathMatchConfigurer )  ;", "}", "return   this . pathMatchConfigurer ;", "}", "METHOD_END"], "methodName": ["getPathMatchConfigurer"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getValidator"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . viewResolverRegistry )     =  =    null )     {", "this . viewResolverRegistry    =    new   ViewResolverRegistry ( this . applicationContext )  ;", "ceViewResolvers ( this . viewResolverRegistry )  ;", "}", "return   this . viewResolverRegistry ;", "}", "METHOD_END"], "methodName": ["getViewResolverRegistry"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerFunctionAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["handlerFunctionAdapter"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   createLocaleContextResolver (  )  ;", "}", "METHOD_END"], "methodName": ["localeContextResolver"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "RequestMappingHandlerAdapter   adapter    =    createRequestMappingHandlerAdapter (  )  ;", "adapter . setMessageReaders ( serverCodecConfigurer (  )  . getReaders (  )  )  ;", "adapter . setWebBindingInitializer ( getbleWebBindingInitializer (  )  )  ;", "adapter . setReactiveAdapterRegistry ( webFluxAdapterRegistry (  )  )  ;", "ArgumentResolverConfigurer   configurer    =    new   ArgumentResolverConfigurer (  )  ;", "configureArgumentResolvers ( configurer )  ;", "adapter . setArgumentResolverConfigurer ( configurer )  ;", "return   adapter ;", "}", "METHOD_END"], "methodName": ["requestMappingHandlerAdapter"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "RequestMappingHandlerMapping   mapping    =    createRequestMappingHandlerMapping (  )  ;", "mapping . setOrder (  0  )  ;", "mapping . setContentTypeResolver ( webFluxContentTypeResolver (  )  )  ;", "mapping . setCorss ( getCorss (  )  )  ;", "PathMatchConfigurer   configurer    =    getPathMatchConfigurer (  )  ;", "Boolean   useTrailingSlashMatch    =    configurer . isUseTrailingSlashMatch (  )  ;", "Boolean   useCaseSensitiveMatch    =    configurer . isUseCaseSensitiveMatch (  )  ;", "if    ( useTrailingSlashMatch    !  =    null )     {", "mapping . setUseTrailingSlashMatch ( useTrailingSlashMatch )  ;", "}", "if    ( useCaseSensitiveMatch    !  =    null )     {", "mapping . setUseCaseSensitiveMatch ( useCaseSensitiveMatch )  ;", "}", "return   mapping ;", "}", "METHOD_END"], "methodName": ["requestMappingHandlerMapping"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "ResourceLoader   resourceLoader    =    this . applicationContext ;", "if    ( resourceLoader    =  =    null )     {", "resourceLoader    =    new   DefaultResourceLoader (  )  ;", "}", "ResourceHandlerRegistry   registry    =    new   ResourceHandlerRegistry ( resourceLoader )  ;", "addResourceHandlers ( registry )  ;", "AbstractHandlerMapping   handlerMapping    =    registry . getHandlerMapping (  )  ;", "if    ( handlerMapping    !  =    null )     {", "PathMatchConfigurer   configurer    =    getPathMatchConfigurer (  )  ;", "Boolean   useTrailingSlashMatch    =    configurer . isUseTrailingSlashMatch (  )  ;", "Boolean   useCaseSensitiveMatch    =    configurer . isUseCaseSensitiveMatch (  )  ;", "if    ( useTrailingSlashMatch    !  =    null )     {", "handlerMapping . setUseTrailingSlashMatch ( useTrailingSlashMatch )  ;", "}", "if    ( useCaseSensitiveMatch    !  =    null )     {", "handlerMapping . setUseCaseSensitiveMatch ( useCaseSensitiveMatch )  ;", "}", "} else    {", "handlerMapping    =    new    . EmptyHandlerMapping (  )  ;", "}", "return   handlerMapping ;", "}", "METHOD_END"], "methodName": ["resourceHandlerMapping"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   ResponseBodyResultHandler ( serverCodecConfigurer (  )  . getWriters (  )  ,    webFluxContentTypeResolver (  )  ,    webFluxAdapterRegistry (  )  )  ;", "}", "METHOD_END"], "methodName": ["responseBodyResultHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   ResponseEntityResultHandler ( serverCodecConfigurer (  )  . getWriters (  )  ,    webFluxContentTypeResolver (  )  ,    webFluxAdapterRegistry (  )  )  ;", "}", "METHOD_END"], "methodName": ["responseEntityResultHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   WebFluxResponseStatusExceptionHandler (  )  ;", "}", "METHOD_END"], "methodName": ["responseStatusExceptionHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "RouterFunctionMapping   mapping    =    createRouterFunctionMapping (  )  ;", "mapping . setOrder (  (  -  1  )  )  ;", "mapping . setMessageReaders ( serverCodecConfigurer (  )  . getReaders (  )  )  ;", "mapping . setCorss ( getCorss (  )  )  ;", "return   mapping ;", "}", "METHOD_END"], "methodName": ["routerFunctionMapping"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "ServerCodecConfigurer   serverCodecConfigurer    =    ServerCodecConfigurer . create (  )  ;", "configureHttpMessageCodecs ( serverCodecConfigurer )  ;", "return   serverCodecConfigurer ;", "}", "METHOD_END"], "methodName": ["serverCodecConfigurer"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "List < ViewResolver >    resolvers    =    getViewResolverRegistry (  )  . getViewResolvers (  )  ;", "ServerResponseResultHandler   handler    =    new   ServerResponseResultHandler (  )  ;", "handler . setMessageWriters ( serverCodecer (  )  . getWriters (  )  )  ;", "handler . setViewResolvers ( resolvers )  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["serverResponseResultHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleHandlerAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["simpleHandlerAdapter"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "ViewResolverRegistry   registry    =    getViewResolverRegistry (  )  ;", "List < ViewResolver >    resolvers    =    registry . getViewResolvers (  )  ;", "ViewResolutionResultHandler   handler    =    new   ViewResolutionResultHandler ( resolvers ,    wtentTypeResolver (  )  ,    webFluxAdapterRegistry (  )  )  ;", "handler . setDefaultViews ( registry . getDefaultViews (  )  )  ;", "handler . setOrder ( registry . getOrder (  )  )  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["viewResolutionResultHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactiveAdapterRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["webFluxAdapterRegistry"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "RequestedContentTypeResolverBuilder   builder    =    new   RequestedContentTypeResolverBuilder (  )  ;", "ceContentTypeResolver ( builder )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["webFluxContentTypeResolver"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "FormattingConversionService   service    =    new   DefaultFormattingConversionService (  )  ;", "addFormatters ( service )  ;", "return   service ;", "}", "METHOD_END"], "methodName": ["webFluxConversionService"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "Validator   validator    =    getValidator (  )  ;", "if    ( validator    =  =    null )     {", "if    ( ClassUtils . isPresent (  \" Validator \"  ,    getClass (  )  . getClassLoader (  )  )  )     {", "Class <  ?  >    clazz ;", "try    {", "String   name    =     \" OptionalValidatorFactoryBean \"  ;", "clazz    =    ClassUtils . forName ( name ,    getClass (  )  . getClassLoader (  )  )  ;", "}    catch    ( ClassNotFoundException    |    LinkageError   ex )     {", "throw   new   BeanInitializationException (  \" Failed   to   resolve   default   validator   class \"  ,    ex )  ;", "}", "validator    =     (  ( Validator )     ( BeanUtils . instantiateClass ( clazz )  )  )  ;", "} else    {", "validator    =    new    . NoOpValidator (  )  ;", "}", "}", "return   validator ;", "}", "METHOD_END"], "methodName": ["webFluxValidator"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   DispatcherHandler (  )  ;", "}", "METHOD_END"], "methodName": ["webHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( readers . stream (  )  . anyMatch (  (    c )     -  >     ( mediaType    =  =    null )     |  |     ( c . canRead ( type ,    mediaType )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertHasMessageReader"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( writers . stream (  )  . anyMatch (  (    c )     -  >     ( mediaType    =  =    null )     |  |     ( c . canWrite ( type ,    mediaType )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertHasMessageWriter"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( WebFluxConfigurationSupportTests . CustomMessageConverterConfig . class )  ;", "String   name    =     \" requestMappingHandlerAdapter \"  ;", "RequestMappingHandlerAdapter   adapter    =    context . getBean ( name ,    RequestMappingHandlerAdapter . class )  ;", "assertNotNull ( adapter )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    adapter . getMessageReaders (  )  ;", "assertEquals (  2  ,    messageReaders . size (  )  )  ;", "assertHasMessageReader ( messageReaders ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ PLAIN )  ;", "assertHasMessageReader ( messageReaders ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    MediaType . APPLICATION _ XML )  ;", "}", "METHOD_END"], "methodName": ["customMessageConverterConfig"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( WebFluxConfigurationSupportTests . CustomPatchMatchConfig . class )  ;", "final   Field   field    =    ReflectionUtils . findField ( PathPatternParser . class ,     \" matchOptionalTrailingSeparator \"  )  ;", "ReflectionUtils . makeAccessible ( field )  ;", "String   name    =     \" requestMappingHandlerMapping \"  ;", "RequestMappingHandlerMapping   mapping    =    context . getBean ( name ,    RequestMappingHandlerMapping . class )  ;", "assertNotNull ( mapping )  ;", "PathPatternParser   patternParser    =    mapping . getPathPatternParser (  )  ;", "assertNotNull ( patternParser )  ;", "boolean   matchOptionalTrailingSlash    =     (  ( boolean )     ( ReflectionUtils . getField ( field ,    patternParser )  )  )  ;", "assertFalse ( matchOptionalTrailingSlash )  ;", "}", "METHOD_END"], "methodName": ["customPathMatchConfig"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register ( cClasses )  ;", "context . refresh (  )  ;", "return   context ;", "}", "METHOD_END"], "methodName": ["loadConfig"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( WebFluxConfigurationSupportTests . WebFluxConfig . class )  ;", "String   name    =     \" requestMappingHandlerAdapter \"  ;", "RequestMappingHandlerAdapter   adapter    =    context . getBean ( name ,    RequestMappingHandlerAdapter . class )  ;", "assertNotNull ( adapter )  ;", "List < HttpMessageReader <  ?  >  >    readers    =    adapter . getMessageReaders (  )  ;", "assertEquals (  1  2  ,    readers . size (  )  )  ;", "ResolvableType   multiValueMapType    =    ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    String . class ,    String . class )  ;", "assertHasMessageReader ( readers ,    ResolvableType . forClass ( byte [  ]  . class )  ,    MediaType . APPLICATION _ OCTET _ STREAM )  ;", "assertHasMessageReader ( readers ,    ResolvableType . forClass ( ByteBuffer . class )  ,    MediaType . APPLICATION _ OCTET _ STREAM )  ;", "assertHasMessageReader ( readers ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ PLAIN )  ;", "assertHasMessageReader ( readers ,    ResolvableType . forClass ( Resource . class )  ,    MediaType . IMAGE _ PNG )  ;", "assertHasMessageReader ( readers ,    multiValueMapType ,    MediaType . APPLICATION _ FORM _ URLENCODED )  ;", "assertHasMessageReader ( readers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    MediaType . APPLICATION _ XML )  ;", "assertHasMessageReader ( readers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    MediaType . APPLICATION _ JSON )  ;", "assertHasMessageReader ( readers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    new   MediaType (  \" application \"  ,     \" x - jackson - smile \"  )  )  ;", "assertHasMessageReader ( readers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    null )  ;", "WebBindingInitializer   bindingInitializer    =    adapter . getWebBindingInitializer (  )  ;", "assertNotNull ( bindingInitializer )  ;", "WebExchangeDataBinder   binder    =    new   WebExchangeDataBinder ( new   Object (  )  )  ;", "bindingInitializer . initBinder ( binder )  ;", "name    =     \" webFluxConversionService \"  ;", "ConversionService   service    =    context . getBean ( name ,    ConversionService . class )  ;", "assertSame ( service ,    binder . getConversionService (  )  )  ;", "name    =     \" webFluxValidator \"  ;", "Validator   validator    =    context . getBean ( name ,    Validator . class )  ;", "assertSame ( validator ,    binder . getValidator (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestMappingHandlerAdapter"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( WebFluxConfigurationSupportTests . WebFluxConfig . class )  ;", "final   Field   field    =    ReflectionUtils . findField ( PathPatternParser . class ,     \" matchOptionalTrailingSeparator \"  )  ;", "ReflectionUtils . makeAccessible ( field )  ;", "String   name    =     \" requestMappingHandlerMapping \"  ;", "RequestMappingHandlerMapping   mapping    =    context . getBean ( name ,    RequestMappingHandlerMapping . class )  ;", "assertNotNull ( mapping )  ;", "assertEquals (  0  ,    mapping . getOrder (  )  )  ;", "PathPatternParser   patternParser    =    mapping . getPathPatternParser (  )  ;", "assertNotNull ( patternParser )  ;", "boolean   matchOptionalTrailingSlash    =     (  ( boolean )     ( ReflectionUtils . getField ( field ,    patternParser )  )  )  ;", "assertTrue ( matchOptionalTrailingSlash )  ;", "name    =     \" webFluxContentTypeResolver \"  ;", "RequestedContentTypeResolver   resolver    =    context . getBean ( name ,    RequestedContentTypeResolver . class )  ;", "assertSame ( resolver ,    mapping . getContentTypeResolver (  )  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  . accept ( APPLICATION _ JSON )  )  ;", "assertEquals ( Collections . singletonList ( APPLICATION _ JSON )  ,    resolver . resolveMediaTypes ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["requestMappingHandlerMapping"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( WebFluxConfigurationSupportTests . CustomResourceHandlingConfig . class )  ;", "String   name    =     \" resourceHandlerMapping \"  ;", "AbstractUrlHandlerMapping   handlerMapping    =    context . getBean ( name ,    AbstractUrlHandlerMapping . class )  ;", "assertNotNull ( handlerMapping )  ;", "assertEquals (  (  ( Ordered . LOWEST _ PRECEDENCE )     -     1  )  ,    handlerMapping . getOrder (  )  )  ;", "SimpleUrlHandlerMapping   urlHandlerMapping    =     (  ( SimpleUrlHandlerMapping )     ( handlerMapping )  )  ;", "WebHandler   webHandler    =     (  ( WebHandler )     ( urlHandlerMapping . getUrlMap (  )  . get (  \"  / images /  *  *  \"  )  )  )  ;", "assertNotNull ( webHandler )  ;", "}", "METHOD_END"], "methodName": ["resourceHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( WebFluxConfigurationSupportTests . WebFluxConfig . class )  ;", "String   name    =     \" responseBodyResultHandler \"  ;", "ResponseBodyResultHandler   handler    =    context . getBean ( name ,    ResponseBodyResultHandler . class )  ;", "assertNotNull ( handler )  ;", "assertEquals (  1  0  0  ,    handler . getOrder (  )  )  ;", "List < HttpMessageWriter <  ?  >  >    writers    =    handler . getMessageWriters (  )  ;", "assertEquals (  1  0  ,    writers . size (  )  )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( byte [  ]  . class )  ,    MediaType . APPLICATION _ OCTET _ STREAM )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( ByteBuffer . class )  ,    MediaType . APPLICATION _ OCTET _ STREAM )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ PLAIN )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( Resource . class )  ,    MediaType . IMAGE _ PNG )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    MediaType . APPLICATION _ XML )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    MediaType . APPLICATION _ JSON )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    new   MediaType (  \" application \"  ,     \" x - jackson - smile \"  )  )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    null )  ;", "name    =     \" webFluxContentTypeResolver \"  ;", "RequestedContentTypeResolver   resolver    =    context . getBean ( name ,    RequestedContentTypeResolver . class )  ;", "assertSame ( resolver ,    handler . getContentTypeResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["responseBodyResultHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( WebFluxConfigurationSupportTests . WebFluxConfig . class )  ;", "String   name    =     \" responseEntityResultHandler \"  ;", "ResponseEntityResultHandler   handler    =    context . getBean ( name ,    ResponseEntityResultHandler . class )  ;", "assertNotNull ( handler )  ;", "assertEquals (  0  ,    handler . getOrder (  )  )  ;", "List < HttpMessageWriter <  ?  >  >    writers    =    handler . getMessageWriters (  )  ;", "assertEquals (  1  0  ,    writers . size (  )  )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( byte [  ]  . class )  ,    MediaType . APPLICATION _ OCTET _ STREAM )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( ByteBuffer . class )  ,    MediaType . APPLICATION _ OCTET _ STREAM )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( String . class )  ,    MediaType . TEXT _ PLAIN )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( Resource . class )  ,    MediaType . IMAGE _ PNG )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    MediaType . APPLICATION _ XML )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    MediaType . APPLICATION _ JSON )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    new   MediaType (  \" application \"  ,     \" x - jackson - smile \"  )  )  ;", "assertHasMessageWriter ( writers ,    ResolvableType . forClass ( WebFluxConfigurationSupportTests . TestBean . class )  ,    MediaType . parseMediaType (  \" text / event - stream \"  )  )  ;", "name    =     \" webFluxContentTypeResolver \"  ;", "RequestedContentTypeResolver   resolver    =    context . getBean ( name ,    RequestedContentTypeResolver . class )  ;", "assertSame ( resolver ,    handler . getContentTypeResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["responseEntityResultHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( WebFluxConfigurationSupportTests . CustomViewResolverConfig . class )  ;", "String   name    =     \" viewResolutionResultHandler \"  ;", "ViewResolutionResultHandler   handler    =    context . getBean ( name ,    ViewResolutionResultHandler . class )  ;", "assertNotNull ( handler )  ;", "assertEquals ( LOWEST _ PRECEDENCE ,    handler . getOrder (  )  )  ;", "List < ViewResolver >    resolvers    =    handler . getViewResolvers (  )  ;", "assertEquals (  1  ,    resolvers . size (  )  )  ;", "assertEquals ( FreeMarkerViewResolver . class ,    resolvers . get (  0  )  . getClass (  )  )  ;", "List < View >    views    =    handler . getDefaultViews (  )  ;", "assertEquals (  1  ,    views . size (  )  )  ;", "MimeType   type    =    MimeTypeUtils . parseMimeType (  \" application / json ; charset = UTF -  8  \"  )  ;", "assertEquals ( type ,    views . get (  0  )  . getSupportedMediaTypes (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["viewResolutionResultHandler"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getMessageCodesResolver"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getValidator"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( configurers )  )  )     {", "this . delegates . addAll ( configurers )  ;", "}", "}", "METHOD_END"], "methodName": ["addWebFluxConfigurers"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurerComposite"}, {"methodBody": ["METHOD_START", "{", "List < T >    result    =    this . delegates . stream (  )  . map ( factory )  . filter ( Objects :  : nonNull )  . collect ( Collectors . toList (  )  )  ;", "if    ( result . isEmpty (  )  )     {", "return   null ;", "} else", "if    (  ( result . size (  )  )     =  =     1  )     {", "return   result . get (  0  )  ;", "} else    {", "throw   new   IllegalStateException (  (  (  \" More   than   one      implements    \"     +     ( beanType . getSimpleName (  )  )  )     +     \"    factory   method .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createSingleBean"], "fileName": "org.springframework.web.reactive.config.WebFluxConfigurerComposite"}, {"methodBody": ["METHOD_START", "{", "return    (  ( HttpMessageReader < T >  )     ( messageReader )  )  ;", "}", "METHOD_END"], "methodName": ["cast"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "MediaType   result    =    message . getHeaders (  )  . getContentType (  )  ;", "return   result    !  =    null    ?    result    :    MediaType . APPLICATION _ OCTET _ STREAM ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return   context . messageReaders (  )  . stream (  )  . filter (  (    messageReader )     -  >    messageReader . canRead ( elementType ,    mediaType )  )  . findFirst (  )  . map ( T :  : cast )  . orElseThrow (  (  )     -  >    new   IllegalStateException (  (  (  (  (  \" Could   not   find   HttpMessageReader   that   supports    \\  \"  \"     +    mediaType )     +     \"  \\  \"    and    \\  \"  \"  )     +    elementType )     +     \"  \\  \"  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["messageReader"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return   message . getBody (  )  . doOnNext (  (    buffer )     -  >     {", "throw   ex ;", "}  )  . map (  (    o )     -  >     (  ( T )     ( o )  )  )  ;", "}", "METHOD_END"], "methodName": ["permitEmptyOrFail"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "if    ( BodyExtractors . VOID _ TYPE . equals ( elementType )  )     {", "return   empty . get (  )  ;", "}", "MediaType   contentType    =    BodyExtractors . contentType ( inputMessage )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    context . messageReaders (  )  ;", "return   messageReaders . stream (  )  . filter (  (    r )     -  >    r . canRead ( elementType ,    contentType )  )  . findFirst (  )  . map ( T :  : cast )  . map ( readerFunction )  . orElseGet (  (  )     -  >     {", "List < MediaType >    supportedMediaTypes    =    messageReaders . stream (  )  . flatMap (  (    reader )     -  >    reader . getReadableMediaTypes (  )  . stream (  )  )  . collect ( Collectors . toList (  )  )  ;", "UnsupportedMediaTypeException   error    =    new   UnsupportedMediaTypeException ( contentType ,    supportedMediaTypes )  ;", "return   unsupportedError . apply ( error )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["readWithMessageReaders"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return    (    inputMessage ,    context )     -  >    inputMessage . getBody (  )  ;", "}", "METHOD_END"], "methodName": ["toDataBuffers"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return   BodyExtractors . toFlux ( ResolvableType . forClass ( elementClass )  )  ;", "}", "METHOD_END"], "methodName": ["toFlux"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return   BodyExtractors . toFlux ( ResolvableType . forType ( typeReference . getType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toFlux"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return    (    inputMessage ,    context )     -  >    readWithMessageReaders ( inputMessage ,    context ,    elementType ,     ( HttpMessageReader < T >    reader )     -  >     {", "Opal < ServerHttpResponse >    serverResponse    =    context . serverResponse (  )  ;", "if    (  ( serverResponse . isPresent (  )  )     &  &     ( inputMessage   instanceof   ServerHttpRequest )  )     {", "return   reader . read ( elementType ,    elementType ,     (  ( ServerHttpRequest )     ( inputMessage )  )  ,    serverResponse . get (  )  ,    context . hints (  )  )  ;", "} else    {", "return   reader . read ( elementType ,    inputMessage ,    context . hints (  )  )  ;", "}", "}  ,     (    ex )     -  >     ( inputMessage . getHeaders (  )  . getContentType (  )  )     =  =    null    ?    permitEmptyOrFail ( inputMessage ,    ex )     :    Flux . error ( ex )  ,    Flux :  : empty )  ;", "}", "METHOD_END"], "methodName": ["toFlux"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return    (    request ,    context )     -  >     {", "ResolvableType   type    =     . FORM _ MAP _ TYPE ;", "HttpMessageReader < MultiValueMap < String ,    String >  >    reader    =    messageReader ( type ,    MediaType . APPLICATION _ FORM _ URLENCODED ,    context )  ;", "return   context . serverResponse (  )  . map (  (    response )     -  >    reader . readMono ( type ,    type ,    request ,    response ,    context . hints (  )  )  )  . orElseGet (  (  )     -  >    reader . readMono ( type ,    request ,    context . hints (  )  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["toFormData"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return   BodyExtractors . toMono ( ResolvableType . forClass ( elementClass )  )  ;", "}", "METHOD_END"], "methodName": ["toMono"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return   BodyExtractors . toMono ( ResolvableType . forType ( typeReference . getType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toMono"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return    (    inputMessage ,    context )     -  >    readWithMessageReaders ( inputMessage ,    context ,    elementType ,     ( HttpMessageReader < T >    reader )     -  >     {", "Opal < ServerHttpResponse >    serverResponse    =    context . serverResponse (  )  ;", "if    (  ( serverResponse . isPresent (  )  )     &  &     ( inputMessage   instanceof   ServerHttpRequest )  )     {", "return   reader . readMono ( elementType ,    elementType ,     (  ( ServerHttpRequest )     ( inputMessage )  )  ,    serverResponse . get (  )  ,    context . hints (  )  )  ;", "} else    {", "return   reader . readMono ( elementType ,    inputMessage ,    context . hints (  )  )  ;", "}", "}  ,     (    ex )     -  >     ( inputMessage . getHeaders (  )  . getContentType (  )  )     =  =    null    ?    Mono . from ( permitEmptyOrFail ( inputMessage ,    ex )  )     :    Mono . error ( ex )  ,    Mono :  : empty )  ;", "}", "METHOD_END"], "methodName": ["toMono"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return    (    serverRequest ,    context )     -  >     {", "ResolvableType   type    =     . MULTIPART _ MAP _ TYPE ;", "HttpMessageReader < MultiValueMap < String ,    Part >  >    reader    =    messageReader ( type ,    MediaType . MULTIPART _ FORM _ DATA ,    context )  ;", "return   context . serverResponse (  )  . map (  (    response )     -  >    reader . readMono ( type ,    type ,    serverRequest ,    response ,    context . hints (  )  )  )  . orElseGet (  (  )     -  >    reader . readMono ( type ,    serverRequest ,    context . hints (  )  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["toMultipartData"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "return    (    serverRequest ,    context )     -  >     {", "ResolvableType   type    =     . PART _ TYPE ;", "HttpMessageReader < Part >    reader    =    messageReader ( type ,    MediaType . MULTIPART _ FORM _ DATA ,    context )  ;", "return   context . serverResponse (  )  . map (  (    response )     -  >    reader . read ( type ,    type ,    serverRequest ,    response ,    context . hints (  )  )  )  . orElseGet (  (  )     -  >    reader . read ( type ,    serverRequest ,    context . hints (  )  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["toParts"], "fileName": "org.springframework.web.reactive.function.BodyExtractors"}, {"methodBody": ["METHOD_START", "{", "final   List < HttpMessageReader <  ?  >  >    messageReaders    =    new   ArrayList <  >  (  )  ;", "messageReaders . add ( new   http . codec . DecoderHttpMessageReader ( new   ByteBufferDecoder (  )  )  )  ;", "messageReaders . add ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "messageReaders . add ( new   http . codec . DecoderHttpMessageReader ( new   Jaxb 2 XmlDecoder (  )  )  )  ;", "messageReaders . add ( new   http . codec . DecoderHttpMessageReader ( new   Jackson 2 JsonDecoder (  )  )  )  ;", "messageReaders . add ( new   FormHttpMessageReader (  )  )  ;", "SynchronossPartHttpMessageReader   partReader    =    new   SynchronossPartHttpMessageReader (  )  ;", "messageReaders . add ( partReader )  ;", "messageReaders . add ( new   http . codec . multipart . MultipartHttpMessageReader ( partReader )  )  ;", "messageReaders . add ( new   FormHttpMessageReader (  )  )  ;", "this . context    =    new   BodyExtractor . Context (  )     {", "@ Override", "public   List < HttpMessageReader <  ?  >  >    messageReaders (  )     {", "return   messageReaders ;", "}", "@ Override", "public   Optional < ServerHttpResponse >    serverResponse (  )     {", "return   Optional . empty (  )  ;", "}", "@ Override", "public   Map < String ,    Object >    hints (  )     {", "return   hints ;", "}", "}  ;", "this . hints    =    new   HashMap < String ,    Object >  (  )  ;", "}", "METHOD_END"], "methodName": ["createContext"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Flux < DataBuffer >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toDataBuffers (  )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body ( body )  ;", "Flux < DataBuffer >    result    =    extractor . extract ( request ,    this . context )  ;", "StepVerifier . create ( result )  . expectNext ( dataBuffer )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toDataBuffers"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Flux < String >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toFlux ( String . class )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body ( body )  ;", "Flux < String >    result    =    extractor . extract ( request ,    this . context )  ;", "StepVerifier . create ( result )  . expectNext (  \" foo \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toFlux"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Flux < String >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toFlux ( String . class )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( MediaType . APPLICATION _ JSON )  . body ( body )  ;", "BodyExtractor . Context   emptyContext    =    new   BodyExtractor . Context (  )     {", "@ Override", "public   List < HttpMessageReader <  ?  >  >    messageReaders (  )     {", "return   Collections . emptyList (  )  ;", "}", "@ Override", "public   Optional < ServerHttpResponse >    serverResponse (  )     {", "return   Optional . empty (  )  ;", "}", "@ Override", "public   Map < String ,    Object >    hints (  )     {", "return   Collections . emptyMap (  )  ;", "}", "}  ;", "Flux < String >    result    =    extractor . extract ( request ,    emptyContext )  ;", "StepVerifier . create ( result )  . expectError ( UnsupportedMediaTypeException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toFluxUnacceptable"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Flux < BodyExtractorsTests . User >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toFlux ( BodyExtractorsTests . User . class )  ;", "this . hints . put ( JSON _ VIEW _ HINT ,    BodyExtractorsTests . SafeToDeserialize . class )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "String   text    =     \"  [  {  \\  \" username \\  \"  :  \\  \" foo \\  \"  ,  \\  \" password \\  \"  :  \\  \" bar \\  \"  }  ,  {  \\  \" username \\  \"  :  \\  \" bar \\  \"  ,  \\  \" password \\  \"  :  \\  \" baz \\  \"  }  ]  \"  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap ( text . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( MediaType . APPLICATION _ JSON )  . body ( body )  ;", "Flux < BodyExtractorsTests . User >    result    =    extractor . extract ( request ,    this . context )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    user )     -  >     {", "assertEquals (  \" foo \"  ,    user . getUsername (  )  )  ;", "assertNull ( user . getPassword (  )  )  ;", "}  )  . consumeNextWith (  (    user )     -  >     {", "assertEquals (  \" bar \"  ,    user . getUsername (  )  )  ;", "assertNull ( user . getPassword (  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toFluxWithHints"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Mono < MultiValueMap < String ,    String >  >  ,    ServerHttpRequest >    extractor    =    BodyExtractors . toFormData (  )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "String   text    =     \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap ( text . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( MediaType . APPLICATION _ FORM _ URLENCODED )  . body ( body )  ;", "Mono < MultiValueMap < String ,    String >  >    result    =    extractor . extract ( request ,    this . context )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    form )     -  >     {", "assertEquals (  \" Invalid   result \"  ,     3  ,    form . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    1  \"  ,    form . getFirst (  \" name    1  \"  )  )  ;", "List < String >    values    =    form . get (  \" name    2  \"  )  ;", "assertEquals (  \" Invalid   result \"  ,     2  ,    values . size (  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    2  +  1  \"  ,    values . get (  0  )  )  ;", "assertEquals (  \" Invalid   result \"  ,     \" value    2  +  2  \"  ,    values . get (  1  )  )  ;", "assertNull (  \" Invalid   result \"  ,    form . getFirst (  \" name    3  \"  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toFormData"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Mono < String >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toMono ( String . class )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body ( body )  ;", "Mono < String >    result    =    extractor . extract ( request ,    this . context )  ;", "StepVerifier . create ( result )  . expectNext (  \" foo \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toMono"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Mono < Map < String ,    String >  >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toMono ( new   ParameterizedTypeReference < Map < String ,    String >  >  (  )     {  }  )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \"  {  \\  \" username \\  \"  :  \\  \" foo \\  \"  ,  \\  \" password \\  \"  :  \\  \" bar \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( MediaType . APPLICATION _ JSON )  . body ( body )  ;", "Mono < Map < String ,    String >  >    result    =    extractor . extract ( request ,    this . context )  ;", "Map < String ,    String >    expected    =    new   LinkedHashMap <  >  (  )  ;", "expected . put (  \" username \"  ,     \" foo \"  )  ;", "expected . put (  \" password \"  ,     \" bar \"  )  ;", "StepVerifier . create ( result )  . expectNext ( expected )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toMonoParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Mono < Map < String ,    String >  >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toMono ( new   ParameterizedTypeReference < Map < String ,    String >  >  (  )     {  }  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . body ( Flux . empty (  )  )  ;", "Mono < Map < String ,    String >  >    result    =    extractor . extract ( request ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toMonoWithEmptyBodyAndNoContentType"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Mono < BodyExtractorsTests . User >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toMono ( BodyExtractorsTests . User . class )  ;", "this . hints . put ( JSON _ VIEW _ HINT ,    BodyExtractorsTests . SafeToDeserialize . class )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \"  {  \\  \" username \\  \"  :  \\  \" foo \\  \"  ,  \\  \" password \\  \"  :  \\  \" bar \\  \"  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( MediaType . APPLICATION _ JSON )  . body ( body )  ;", "Mono < BodyExtractorsTests . User >    result    =    extractor . extract ( request ,    this . context )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    user )     -  >     {", "assertEquals (  \" foo \"  ,    user . getUsername (  )  )  ;", "assertNull ( user . getPassword (  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toMonoWithHints"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "BodyExtractor < Flux < Part >  ,    ServerHttpRequest >    extractor    =    BodyExtractors . toParts (  )  ;", "String   bodyContents    =     \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  9  0  5  1  9  1  4  0  4  1  5  4  4  8  4  3  3  6  5  9  7  2  7  5  4  2  6  6  \\ r \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" Content - Disposition :    form - data ;    name =  \\  \" text \\  \"  \\ r \\ n \"     +     \"  \\ r \\ n \"  )     +     \" text   default \\ r \\ n \"  )     +     \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  9  0  5  1  9  1  4  0  4  1  5  4  4  8  4  3  3  6  5  9  7  2  7  5  4  2  6  6  \\ r \\ n \"  )     +     \" Content - Disposition :    form - data ;    name =  \\  \" file 1  \\  \"  ;    filename =  \\  \" a . txt \\  \"  \\ r \\ n \"  )     +     \" Content - Type :    text / plain \\ r \\ n \"  )     +     \"  \\ r \\ n \"  )     +     \" Content   of   a . txt .  \\ r \\ n \"  )     +     \"  \\ r \\ n \"  )     +     \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  9  0  5  1  9  1  4  0  4  1  5  4  4  8  4  3  3  6  5  9  7  2  7  5  4  2  6  6  \\ r \\ n \"  )     +     \" Content - Disposition :    form - data ;    name =  \\  \" file 2  \\  \"  ;    filename =  \\  \" a . html \\  \"  \\ r \\ n \"  )     +     \" Content - Type :    text / html \\ r \\ n \"  )     +     \"  \\ r \\ n \"  )     +     \"  <  ! DOCTYPE   html >  < title > Content   of   a . html .  <  / title >  \\ r \\ n \"  )     +     \"  \\ r \\ n \"  )     +     \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  9  0  5  1  9  1  4  0  4  1  5  4  4  8  4  3  3  6  5  9  7  2  7  5  4  2  6  6  -  -  \\ r \\ n \"  )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap ( bodyContents . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  /  \"  )  . header (  \" Content - Type \"  ,     \" multipart / form - data ;    boundary =  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  9  0  5  1  9  1  4  0  4  1  5  4  4  8  4  3  3  6  5  9  7  2  7  5  4  2  6  6  \"  )  . body ( body )  ;", "Flux < Part >    result    =    extractor . extract ( request ,    this . context )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    part )     -  >     {", "assertEquals (  \" text \"  ,    part . name (  )  )  ;", "assertTrue (  ( part   instanceof   FormFieldPart )  )  ;", "FormFieldPart   formFieldPart    =     (  ( FormFieldPart )     ( part )  )  ;", "assertEquals (  \" text   default \"  ,    formFieldPart . value (  )  )  ;", "}  )  . consumeNextWith (  (    part )     -  >     {", "assertEquals (  \" file 1  \"  ,    part . name (  )  )  ;", "assertTrue (  ( part   instanceof   FilePart )  )  ;", "FilePart   filePart    =     (  ( FilePart )     ( part )  )  ;", "assertEquals (  \" a . txt \"  ,    filePart . filename (  )  )  ;", "assertEquals ( MediaType . TEXT _ PLAIN ,    filePart . headers (  )  . getContentType (  )  )  ;", "}  )  . consumeNextWith (  (    part )     -  >     {", "assertEquals (  \" file 2  \"  ,    part . name (  )  )  ;", "assertTrue (  ( part   instanceof   FilePart )  )  ;", "FilePart   filePart    =     (  ( FilePart )     ( part )  )  ;", "assertEquals (  \" a . html \"  ,    filePart . filename (  )  )  ;", "assertEquals ( MediaType . TEXT _ HTML ,    filePart . headers (  )  . getContentType (  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["toParts"], "fileName": "org.springframework.web.reactive.function.BodyExtractorsTests"}, {"methodBody": ["METHOD_START", "{", "return    (    outputMessage ,    context )     -  >     {", "MediaType   contentType    =    outputMessage . getHeaders (  )  . getContentType (  )  ;", "List < HttpMessageWriter <  ?  >  >    messageWriters    =    context . messageWriters (  )  ;", "return   messageWriters . stream (  )  . filter (  (    messageWriter )     -  >    messageWriter . canWrite ( bodyType ,    contentType )  )  . findFirst (  )  . map (  :  : cast )  . map (  (    messageWriter )     -  >     {", "Optional < ServerHttpRequest >    serverRequest    =    context . serverRequest (  )  ;", "if    (  ( serverRequest . isPresent (  )  )     &  &     ( outputMessage   instanceof   ServerHttpResponse )  )     {", "return   messageWriter . write ( body ,    bodyType ,    bodyType ,    contentType ,    serverRequest . get (  )  ,     (  ( ServerHttpResponse )     ( outputMessage )  )  ,    context . hints (  )  )  ;", "} else    {", "return   messageWriter . write ( body ,    bodyType ,    contentType ,    outputMessage ,    context . hints (  )  )  ;", "}", "}  )  . orElseGet (  (  )     -  >     {", "List < MediaType >    supportedMediaTypes    =    messageWriters . stream (  )  . flatMap (  (    reader )     -  >    reader . getWritableMediaTypes (  )  . stream (  )  )  . collect ( Collectors . toList (  )  )  ;", "UnsupportedMediaTypeException   error    =    new   UnsupportedMediaTypeException ( contentType ,    supportedMediaTypes )  ;", "return   Mono . error ( error )  ;", "}  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["bodyInserterFor"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return    (  ( HttpMessageWriter < T >  )     ( messageWriter )  )  ;", "}", "METHOD_END"], "methodName": ["cast"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return    (  ( BodyInserter < T ,    ReactiveHttpOutputMessage >  )     ( BodyInserters . EMPTY )  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return   context . messageWriters (  )  . stream (  )  . filter (  (    messageWriter )     -  >    messageWriter . canWrite ( type ,    mediaType )  )  . findFirst (  )  . map ( T :  : cast )  . orElseThrow (  (  )     -  >    new   IllegalStateException (  (  \" Could   not   find   HttpMessageWriter   that   supports    \"     +    mediaType )  )  )  ;", "}", "METHOD_END"], "methodName": ["findMessageWriter"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( publisher ,     \"  ' publisher '    must   not   be   null \"  )  ;", "return    (    outputMessage ,    context )     -  >    outputMessage . writeWith ( publisher )  ;", "}", "METHOD_END"], "methodName": ["fromDataBuffers"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \"  ' key '    must   not   be   null \"  )  ;", "Assert . notNull ( value ,     \"  ' value '    must   not   be   null \"  )  ;", "return   new    . DefaultFormInserter (  )  . with ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["fromFormData"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return   new   BodyInserters . DefaultFormInserter (  )  . with ( formData )  ;", "}", "METHOD_END"], "methodName": ["fromFormData"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \"  ' key '    must   not   be   null \"  )  ;", "Assert . notNull ( publisher ,     \"  ' publisher '    must   not   be   null \"  )  ;", "Assert . notNull ( elementClass ,     \"  ' elementClass '    must   not   be   null \"  )  ;", "return   new    . DefaultMultipartInserter (  )  . withPublisher ( name ,    publisher ,    elementClass )  ;", "}", "METHOD_END"], "methodName": ["fromMultipartAsyncData"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \"  ' key '    must   not   be   null \"  )  ;", "Assert . notNull ( publisher ,     \"  ' publisher '    must   not   be   null \"  )  ;", "Assert . notNull ( typeReference ,     \"  ' typeReference '    must   not   be   null \"  )  ;", "return   new    . DefaultMultipartInserter (  )  . withPublisher ( name ,    publisher ,    typeReference )  ;", "}", "METHOD_END"], "methodName": ["fromMultipartAsyncData"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \"  ' key '    must   not   be   null \"  )  ;", "Assert . notNull ( value ,     \"  ' value '    must   not   be   null \"  )  ;", "return   new    . DefaultMultipartInserter (  )  . with ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["fromMultipartData"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( multipartData ,     \"  ' multipartData '    must   not   be   null \"  )  ;", "return   new    . DefaultMultipartInserter (  )  . withInternal ( multipartData )  ;", "}", "METHOD_END"], "methodName": ["fromMultipartData"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return   BodyInserters . bodyInserterFor ( Mono . just ( body )  ,    ResolvableType . forInstance ( body )  )  ;", "}", "METHOD_END"], "methodName": ["fromObject"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return   BodyInserters . bodyInserterFor ( publisher ,    ResolvableType . forClass ( elementClass )  )  ;", "}", "METHOD_END"], "methodName": ["fromPublisher"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return   BodyInserters . bodyInserterFor ( publisher ,    ResolvableType . forType ( typeReference . getType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["fromPublisher"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return    (    outputMessage ,    context )     -  >     {", "Mono < T >    inputStream    =    reactor . core . publisher . Mono . just ( resource )  ;", "HttpMessageWriter < Resource >    messageWriter    =    resourceHttpMessageWriter ( context )  ;", "Optional < ServerHttpRequest >    serverRequest    =    context . serverRequest (  )  ;", "if    (  ( serverRequest . isPresent (  )  )     &  &     ( outputMessage   instanceof   ServerHttpResponse )  )     {", "return   messageWriter . write ( inputStream ,     . RESOURCE _ TYPE ,     . RESOURCE _ TYPE ,    null ,    serverRequest . get (  )  ,     (  ( ServerHttpResponse )     ( outputMessage )  )  ,    context . hints (  )  )  ;", "} else    {", "return   messageWriter . write ( inputStream ,     . RESOURCE _ TYPE ,    null ,    outputMessage ,    context . hints (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["fromResource"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return    (    serverResponse ,    context )     -  >     {", "HttpMessageWriter < ServerSentEvent < T >  >    messageWriter    =    findMessageWriter ( context ,     . SERVER _ SIDE _ EVENT _ TYPE ,    MediaType . TEXT _ EVENT _ STREAM )  ;", "return   context . serverRequest (  )  . map (  (    serverRequest )     -  >    messageWriter . write ( eventsPublisher ,     . SERVER _ SIDE _ EVENT _ TYPE ,     . SERVER _ SIDE _ EVENT _ TYPE ,    MediaType . TEXT _ EVENT _ STREAM ,    serverRequest ,    serverResponse ,    context . hints (  )  )  )  . orElseGet (  (  )     -  >    messageWriter . write ( eventsPublisher ,     . SERVER _ SIDE _ EVENT _ TYPE ,    MediaType . TEXT _ EVENT _ STREAM ,    serverResponse ,    context . hints (  )  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["fromServerSentEvents"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "return   context . messageWriters (  )  . stream (  )  . filter (  (    messageWriter )     -  >    messageWriter . canWrite ( BodyInserters . RESOURCE _ TYPE ,    null )  )  . findFirst (  )  . map ( Resource :  : cast )  . orElseThrow (  (  )     -  >    new   IllegalStateException (  \" Could   not   find   HttpMessageWriter   that   supports   Resource   objects \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resourceHttpMessageWriter"], "fileName": "org.springframework.web.reactive.function.BodyInserters"}, {"methodBody": ["METHOD_START", "{", "final   List < HttpMessageWriter <  ?  >  >    messageWriters    =    new   ArrayList <  >  (  )  ;", "messageWriters . add ( new   http . codec . EncoderHttpMessageWriter ( new   ByteBufferEncoder (  )  )  )  ;", "messageWriters . add ( new   http . codec . EncoderHttpMessageWriter ( CharSequenceEncoder . textPlainOnly (  )  )  )  ;", "messageWriters . add ( new   ResourceHttpMessageWriter (  )  )  ;", "messageWriters . add ( new   http . codec . EncoderHttpMessageWriter ( new   Jaxb 2 XmlEncoder (  )  )  )  ;", "Jackson 2 JsonEncoder   jsonEncoder    =    new   Jackson 2 JsonEncoder (  )  ;", "messageWriters . add ( new   http . codec . EncoderHttpMessageWriter ( jsonEncoder )  )  ;", "messageWriters . add ( new   http . codec . ServerSentEventHttpMessageWriter ( jsonEncoder )  )  ;", "messageWriters . add ( new   FormHttpMessageWriter (  )  )  ;", "messageWriters . add ( new   http . codec . EncoderHttpMessageWriter ( CharSequenceEncoder . allMimeTypes (  )  )  )  ;", "messageWriters . add ( new   http . codec . multipart . MultipartHttpMessageWriter ( messageWriters )  )  ;", "this . context    =    new   BodyInserter . Context (  )     {", "@ Override", "public   List < HttpMessageWriter <  ?  >  >    messageWriters (  )     {", "return   messageWriters ;", "}", "@ Override", "public   Optional < ServerHttpRequest >    serverRequest (  )     {", "return   Optional . empty (  )  ;", "}", "@ Override", "public   Map < String ,    Object >    hints (  )     {", "return   hints ;", "}", "}  ;", "this . hints    =    new   HashMap <  >  (  )  ;", "}", "METHOD_END"], "methodName": ["createContext"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    body    =    new   LinkedMultiValueMap (  )  ;", "body . set (  \" name    1  \"  ,     \" value    1  \"  )  ;", "body . add (  \" name    2  \"  ,     \" value    2  +  1  \"  )  ;", "body . add (  \" name    2  \"  ,     \" value    2  +  2  \"  )  ;", "body . add (  \" name    3  \"  ,    null )  ;", "BodyInserter < MultiValueMap < String ,    String >  ,    ClientHttpRequest >    inserter    =    BodyInserters . fromFormData ( body )  ;", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  ;", "Mono < Void >    result    =    inserter . insert ( request ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "StepVerifier . create ( request . getBody (  )  )  . consumeNextWith (  (    dataBuffer )     -  >     {", "byte [  ]    resultBytes    =    new   byte [ dataBuffer . readableByteCount (  )  ]  ;", "dataBuffer . read ( resultBytes )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "assertArrayEquals (  \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  . getBytes ( StandardCharsets . UTF _  8  )  ,    resultBytes )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["fromFormDataMap"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "BodyInserter < MultiValueMap < String ,    String >  ,    ClientHttpRequest >    inserter    =    BodyInserters . fromFormData (  \" name    1  \"  ,     \" value    1  \"  )  . with (  \" name    2  \"  ,     \" value    2  +  1  \"  )  . with (  \" name    2  \"  ,     \" value    2  +  2  \"  )  . with (  \" name    3  \"  ,    null )  ;", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  ;", "Mono < Void >    result    =    inserter . insert ( request ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "StepVerifier . create ( request . getBody (  )  )  . consumeNextWith (  (    dataBuffer )     -  >     {", "byte [  ]    resultBytes    =    new   byte [ dataBuffer . readableByteCount (  )  ]  ;", "dataBuffer . read ( resultBytes )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "assertArrayEquals (  \" name +  1  = value +  1  & name +  2  = value +  2  %  2 B 1  & name +  2  = value +  2  %  2 B 2  & name +  3  \"  . getBytes ( StandardCharsets . UTF _  8  )  ,    resultBytes )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["fromFormDataWith"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    map    =    new   LinkedMultiValueMap (  )  ;", "map . set (  \" name    3  \"  ,     \" value    3  \"  )  ;", "BodyInserters . FormInserter < Object >    inserter    =    BodyInserters . fromMultipartData (  \" name    1  \"  ,     \" value    1  \"  )  . withPublisher (  \" name    2  \"  ,    Flux . just (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ,    String . class )  . with ( map )  ;", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  ;", "Mono < Void >    result    =    inserter . insert ( request ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["fromMultipartData"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    map    =    new   LinkedMultiValueMap (  )  ;", "map . put (  \" name \"  ,    Arrays . asList (  \" value 1  \"  ,     \" value 2  \"  )  )  ;", "BodyInserters . FormInserter < Object >    inserter    =    BodyInserters . fromMultipartData ( map )  ;", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  ;", "Mono < Void >    result    =    inserter . insert ( request ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "StepVerifier . create ( DataBufferUtils . join ( request . getBody (  )  )  )  . consumeNextWith (  (    dataBuffer )     -  >     {", "byte [  ]    resultBytes    =    new   byte [ dataBuffer . readableByteCount (  )  ]  ;", "dataBuffer . read ( resultBytes )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "String   content    =    new   String ( resultBytes ,    StandardCharsets . UTF _  8  )  ;", "assertThat ( content ,    containsString (  (  \" Content - Disposition :    form - data ;    name =  \\  \" name \\  \"  \\ r \\ n \"     +     (  (  \" Content - Type :    text / plain ; charset = UTF -  8  \\ r \\ n \"     +     \"  \\ r \\ n \"  )     +     \" value 1  \"  )  )  )  )  ;", "assertThat ( content ,    containsString (  (  \" Content - Disposition :    form - data ;    name =  \\  \" name \\  \"  \\ r \\ n \"     +     (  (  \" Content - Type :    text / plain ; charset = UTF -  8  \\ r \\ n \"     +     \"  \\ r \\ n \"  )     +     \" value 2  \"  )  )  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["fromMultipartDataWithMultipleValues"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "BodyInserter < Flux < DataBuffer >  ,    ReactiveHttpOutputMessage >    inserter    =     . fromDataBuffers ( body )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Mono < Void >    result    =    inserter . insert ( response ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectNext ( dataBuffer )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ofDataBuffers"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "BodyInsertersTests . User   body    =    new   BodyInsertersTests . User (  \" foo \"  ,     \" bar \"  )  ;", "BodyInserter < BodyInsertersTests . User ,    ReactiveHttpOutputMessage >    inserter    =    BodyInserters . fromObject ( body )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Mono < Void >    result    =    inserter . insert ( response ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "StepVerifier . create ( response . getBodyAsString (  )  )  . expectNext (  \"  {  \\  \" username \\  \"  :  \\  \" foo \\  \"  ,  \\  \" password \\  \"  :  \\  \" bar \\  \"  }  \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ofObject"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "BodyInsertersTests . User   body    =    new   BodyInsertersTests . User (  \" foo \"  ,     \" bar \"  )  ;", "BodyInserter < BodyInsertersTests . User ,    ReactiveHttpOutputMessage >    inserter    =    BodyInserters . fromObject ( body )  ;", "this . hints . put ( JSON _ VIEW _ HINT ,    BodyInsertersTests . SafeToSerialize . class )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Mono < Void >    result    =    inserter . insert ( response ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "StepVerifier . create ( response . getBodyAsString (  )  )  . expectNext (  \"  {  \\  \" username \\  \"  :  \\  \" foo \\  \"  }  \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ofObjectWithHints"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    body    =    Flux . just (  \" foo \"  )  ;", "BodyInserter < Flux < String >  ,    ReactiveHttpOutputMessage >    inserter    =     . fromPublisher ( body ,    String . class )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Mono < Void >    result    =    inserter . insert ( response ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "ByteBuffer   byteBuffer    =    ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "DataBuffer   buffer    =    new   DefaultDataBufferFactory (  )  . wrap ( byteBuffer )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectNext ( buffer )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ofPublisher"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "Resource   body    =    new   ClassPathResource (  \" response . txt \"  ,    getClass (  )  )  ;", "BodyInserter < Resource ,    ReactiveHttpOutputMessage >    inserter    =     . fromResource ( body )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Mono < Void >    result    =    inserter . insert ( response ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "byte [  ]    expectedBytes    =    Files . readAllBytes ( body . getFile (  )  . toPath (  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . consumeNextWith (  (    dataBuffer )     -  >     {", "byte [  ]    resultBytes    =    new   byte [ dataBuffer . readableByteCount (  )  ]  ;", "dataBuffer . read ( resultBytes )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "assertArrayEquals ( expectedBytes ,    resultBytes )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ofResource"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "final   int   rangeStart    =     1  0  ;", "Resource   body    =    new   ClassPathResource (  \" response . txt \"  ,    getClass (  )  )  ;", "BodyInserter < Resource ,    ReactiveHttpOutputMessage >    inserter    =     . fromResource ( body )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / foo \"  )  . range ( HttpRange . createByteRange ( rangeStart )  )  . build (  )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Mono < Void >    result    =    inserter . insert ( response ,    new   BodyInserter . Context (  )     {", "@ Override", "public   List < HttpMessageWriter <  ?  >  >    messageWriters (  )     {", "return   Collections . singletonList ( new   ResourceHttpMessageWriter (  )  )  ;", "}", "@ Override", "public   Optional < ServerHttpRequest >    serverRequest (  )     {", "return   Optional . of ( request )  ;", "}", "@ Override", "public   Map < String ,    Object >    hints (  )     {", "return   hints ;", "}", "}  )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "byte [  ]    allBytes    =    Files . readAllBytes ( body . getFile (  )  . toPath (  )  )  ;", "byte [  ]    expectedBytes    =    new   byte [  ( allBytes . length )     -    rangeStart ]  ;", "System . arraycopy ( allBytes ,    rangeStart ,    expectedBytes ,     0  ,    expectedBytes . length )  ;", "StepVerifier . create ( response . getBody (  )  )  . consumeNextWith (  (    dataBuffer )     -  >     {", "byte [  ]    resultBytes    =    new   byte [ dataBuffer . readableByteCount (  )  ]  ;", "dataBuffer . read ( resultBytes )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "assertArrayEquals ( expectedBytes ,    resultBytes )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ofResourceRange"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "ServerSentEvent < String >    event    =    ServerSentEvent . builder (  \" foo \"  )  . build (  )  ;", "Flux < ServerSentEvent < String >  >    body    =    Flux . just ( event )  ;", "BodyInserter < Flux < ServerSentEvent < String >  >  ,    ServerHttpResponse >    inserter    =     . fromServerSentEvents ( body )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Mono < Void >    result    =    inserter . insert ( response ,    this . context )  ;", "StepVerifier . create ( result )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ofServerSentEventFlux"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "BodyInserter < String ,    ReactiveHttpOutputMessage >    inserter    =     . fromObject ( body )  ;", "MockServerHttpResponse   response    =    new   MockServerHttpResponse (  )  ;", "Mono < Void >    result    =    inserter . insert ( response ,    this . context )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "DataBuffer   buffer    =    new   DefaultDataBufferFactory (  )  . wrap ( body . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectNext ( buffer )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ofString"], "fileName": "org.springframework.web.reactive.function.BodyInsertersTests"}, {"methodBody": ["METHOD_START", "{", "MultipartBodyBuilder   builder    =    new   MultipartBodyBuilder (  )  ;", "builder . part (  \" fooPart \"  ,    new   ClassPathResource (  \" org /  / http / codec / multipart / foo . txt \"  )  )  ;", "builder . part (  \" barPart \"  ,     \" bar \"  )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["generateBody"], "fileName": "org.springframework.web.reactive.function.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ClientResponse >    result    =    webClient . post (  )  . uri (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / multipartData \"  )  )  . syncBody ( generateBody (  )  )  . exchange (  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    response )     -  >    assertEquals ( HttpStatus . OK ,    response . statusCode (  )  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["multipartData"], "fileName": "org.springframework.web.reactive.function.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ClientResponse >    result    =    webClient . post (  )  . uri (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / parts \"  )  )  . syncBody ( generateBody (  )  )  . exchange (  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    response )     -  >    assertEquals ( HttpStatus . OK ,    response . statusCode (  )  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["parts"], "fileName": "org.springframework.web.reactive.function.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . contentType ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.web.reactive.function.UnsupportedMediaTypeException"}, {"methodBody": ["METHOD_START", "{", "return   this . supportedMediaTypes ;", "}", "METHOD_END"], "methodName": ["getSupportedMediaTypes"], "fileName": "org.springframework.web.reactive.function.UnsupportedMediaTypeException"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    attributes (  )  ;", "if    ( attributes . containsKey ( name )  )     {", "return   Optional . of ( attributes . get ( name )  )  ;", "} else    {", "return   Optional . empty (  )  ;", "}", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.web.reactive.function.client.ClientRequest"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultClientRequestBuilder ( method ,    url )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.client.ClientRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \"  ' other '    must   not   be   null \"  )  ;", "return   new   DefaultBuilder ( other )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.web.reactive.function.client.ClientRequest"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultClientRequestBuilder ( method ,    url )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.reactive.function.client.ClientRequest"}, {"methodBody": ["METHOD_START", "{", "return   ClientResponse . create ( statusCode ,    ExchangeStrategies . withDefaults (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.client.ClientResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( statusCode ,     \"  ' statusCode '    must   not   be   null \"  )  ;", "Assert . notNull ( messageReaders ,     \"  ' messageReaders '    must   not   be   null \"  )  ;", "return    . create ( statusCode ,    new   ExchangeStrategies (  )     {", "@ Override", "public   List < HttpMessageReader <  ?  >  >    messageReaders (  )     {", "return   messageReaders ;", "}", "@ Override", "public   List < HttpMessageWriter <  ?  >  >    messageWriters (  )     {", "return   Collections . emptyList (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.client.ClientResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( statusCode ,     \"  ' statusCode '    must   not   be   null \"  )  ;", "Assert . notNull ( strategies ,     \"  ' strategies '    must   not   be   null \"  )  ;", "return   new   DefaultBuilder ( strategies )  . statusCode ( statusCode )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.client.ClientResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \"  ' other '    must   not   be   null \"  )  ;", "return   new   DefaultBuilder ( other )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.web.reactive.function.client.ClientResponse"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Publisher < String >    publisher    =    Mono . just ( body )  ;", "ClientRequest   result    =    ClientRequest . create ( HttpMethod . POST ,    create (  \" http :  /  / example . com \"  )  )  . body ( publisher ,    String . class )  . build (  )  ;", "List < HttpMessageWriter <  ?  >  >    messageWriters    =    new   ArrayList <  >  (  )  ;", "messageWriters . add ( new   http . codec . EncoderHttpMessageWriter ( CharSequenceEncoder . allMimeTypes (  )  )  )  ;", "ExchangeStrategies   strategies    =    mock ( ExchangeStrategies . class )  ;", "when ( strategies . messageWriters (  )  )  . thenReturn ( messageWriters )  ;", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,     \"  /  \"  )  ;", "result . writeTo ( request ,    strategies )  . block (  )  ;", "assertNotNull ( request . getBody (  )  )  ;", "StepVerifier . create ( request . getBody (  )  )  . expectNextCount (  1  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["bodyClass"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "BodyInserter < String ,    ClientHttpRequest >    inserter    =     (    response ,    strategies )     -  >     {", "byte [  ]    bodyBytes    =    body . getBytes ( StandardCharsets . UTF _  8  )  ;", "DataBuffer   buffer    =    new   DefaultDataBufferFactory (  )  . wrap ( bodyBytes )  ;", "return   response . writeWith ( Mono . just ( buffer )  )  ;", "}  ;", "ClientRequest   result    =    ClientRequest . create ( HttpMethod . POST ,    create (  \" http :  /  / example . com \"  )  )  . body ( inserter )  . build (  )  ;", "List < HttpMessageWriter <  ?  >  >    messageWriters    =    new   ArrayList <  >  (  )  ;", "messageWriters . add ( new   http . codec . EncoderHttpMessageWriter ( CharSequenceEncoder . allMimeTypes (  )  )  )  ;", "ExchangeStrategies   strategies    =    mock ( ExchangeStrategies . class )  ;", "when ( strategies . messageWriters (  )  )  . thenReturn ( messageWriters )  ;", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,     \"  /  \"  )  ;", "result . writeTo ( request ,    strategies )  . block (  )  ;", "assertNotNull ( request . getBody (  )  )  ;", "StepVerifier . create ( request . getBody (  )  )  . expectNextCount (  1  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["bodyInserter"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Publisher < String >    publisher    =    Mono . just ( body )  ;", "ParameterizedTypeReference < String >    typeReference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "ClientRequest   result    =    ClientRequest . create ( HttpMethod . POST ,    create (  \" http :  /  / example . com \"  )  )  . body ( publisher ,    typeReference )  . build (  )  ;", "List < HttpMessageWriter <  ?  >  >    messageWriters    =    new   ArrayList <  >  (  )  ;", "messageWriters . add ( new   http . codec . EncoderHttpMessageWriter ( CharSequenceEncoder . allMimeTypes (  )  )  )  ;", "ExchangeStrategies   strategies    =    mock ( ExchangeStrategies . class )  ;", "when ( strategies . messageWriters (  )  )  . thenReturn ( messageWriters )  ;", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,     \"  /  \"  )  ;", "result . writeTo ( request ,    strategies )  . block (  )  ;", "assertNotNull ( request . getBody (  )  )  ;", "StepVerifier . create ( request . getBody (  )  )  . expectNextCount (  1  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["bodyParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   result    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . header (  \" MyKey \"  ,     \" MyValue \"  )  . cookie (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "MockClientHttpRequest   request    =    new   MockClientHttpRequest ( HttpMethod . GET ,     \"  /  \"  )  ;", "ExchangeStrategies   strategies    =    mock ( ExchangeStrategies . class )  ;", "result . writeTo ( request ,    strategies )  . block (  )  ;", "assertEquals (  \" MyValue \"  ,    request . getHeaders (  )  . getFirst (  \" MyKey \"  )  )  ;", "assertEquals (  \" bar \"  ,    request . getCookies (  )  . getFirst (  \" foo \"  )  . getValue (  )  )  ;", "StepVerifier . create ( request . getBody (  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   result    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . cookie (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "assertEquals (  \" bar \"  ,    result . cookies (  )  . getFirst (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cookie"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   other    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . header (  \" foo \"  ,     \" bar \"  )  . cookie (  \" baz \"  ,     \" qux \"  )  . build (  )  ;", "ClientRequest   result    =    ClientRequest . from ( other )  . headers (  (    httpHeaders )     -  >    httpHeaders . set (  \" foo \"  ,     \" baar \"  )  )  . cookies (  (    cookies )     -  >    cookies . set (  \" baz \"  ,     \" quux \"  )  )  . build (  )  ;", "assertEquals ( new   URI (  \" http :  /  / example . com \"  )  ,    result . url (  )  )  ;", "assertEquals ( HttpMethod . GET ,    result . method (  )  )  ;", "assertEquals (  1  ,    result . headers (  )  . size (  )  )  ;", "assertEquals (  \" baar \"  ,    result . headers (  )  . getFirst (  \" foo \"  )  )  ;", "assertEquals (  1  ,    result . cookies (  )  . size (  )  )  ;", "assertEquals (  \" quux \"  ,    result . cookies (  )  . getFirst (  \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  \" http :  /  / example . com \"  )  ;", ". Builder   builder    =     . create ( HttpMethod . DELETE ,    url )  ;", "assertEquals ( HttpMethod . DELETE ,    builder . build (  )  . method (  )  )  ;", "builder . method ( HttpMethod . OPTIONS )  ;", "assertEquals ( HttpMethod . OPTIONS ,    builder . build (  )  . method (  )  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   url 1     =    new   URI (  \" http :  /  / example . com / foo \"  )  ;", "URI   url 2     =    new   URI (  \" http :  /  / example . com / bar \"  )  ;", ". Builder   builder    =     . create ( HttpMethod . DELETE ,    url 1  )  ;", "assertEquals ( url 1  ,    builder . build (  )  . url (  )  )  ;", "builder . url ( url 2  )  ;", "assertEquals ( url 2  ,    builder . build (  )  . url (  )  )  ;", "}", "METHOD_END"], "methodName": ["url"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientRequestBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Mono < T >  )     ( this . response . getBody (  )  . map (  (    buffer )     -  >     {", "DataBufferUtils . release ( buffer )  ;", "throw   new   ReadCancellationException (  )  ;", "}  )  . onErrorResume (  . ReadCancellationException . class ,     (    ex )     -  >    Mono . empty (  )  )  . then (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["consumeAndCancel"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponse"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    headers (  )  . asHttpHeaders (  )  ;", "HttpStatus   statusCode    =    statusCode (  )  ;", "return   bodyMono . map (  (    body )     -  >    new   Entity <  >  ( body ,    headers ,    statusCode )  )  . switchIfEmpty ( Mono . defer (  (  )     -  >    Mono . just ( new   Entity <  >  ( headers ,    statusCode )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityInternal"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponse"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    headers (  )  . asHttpHeaders (  )  ;", "HttpStatus   statusCode    =    statusCode (  )  ;", "return   bodyFlux . collectList (  )  . map (  (    body )     -  >    new   Entity <  >  ( body ,    headers ,    statusCode )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityListInternal"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponse"}, {"methodBody": ["METHOD_START", "{", "this . body . subscribe ( DataBufferUtils . releaseConsumer (  )  )  ;", "}", "METHOD_END"], "methodName": ["releaseBody"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . dataBufferFactory    =    new   DefaultDataBufferFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createBufferFactory"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    otherBody    =    Flux . just (  \" foo \"  ,     \" bar \"  )  . map (  (    s )     -  >    s . getBytes ( StandardCharsets . UTF _  8  )  )  . map ( dataBufferFactory :  : wrap )  ;", "other    =     . create ( BAD _ REQUEST ,    ExchangeStrategies . withDefaults (  )  )  . header (  \" foo \"  ,     \" bar \"  )  . cookie (  \" baz \"  ,     \" qux \"  )  . body ( otherBody )  . build (  )  ;", "Flux < DataBuffer >    body    =    Flux . just (  \" baz \"  )  . map (  (    s )     -  >    s . getBytes ( StandardCharsets . UTF _  8  )  )  . map ( dataBufferFactory :  : wrap )  ;", "result    =     . from ( other )  . headers (  (    httpHeaders )     -  >    httpHeaders . set (  \" foo \"  ,     \" baar \"  )  )  . cookies (  (    cookies )     -  >    cookies . set (  \" baz \"  ,    ResponseCookie . from (  \" baz \"  ,     \" quux \"  )  . build (  )  )  )  . body ( body )  . build (  )  ;", "assertEquals ( BAD _ REQUEST ,    result . statusCode (  )  )  ;", "assertEquals (  1  ,    result . headers (  )  . asHttpHeaders (  )  . size (  )  )  ;", "assertEquals (  \" baar \"  ,    result . headers (  )  . asHttpHeaders (  )  . getFirst (  \" foo \"  )  )  ;", "assertEquals (  1  ,    result . cookies (  )  . size (  )  )  ;", "assertEquals (  \" quux \"  ,    result . cookies (  )  . getFirst (  \" baz \"  )  . getValue (  )  )  ;", "StepVerifier . create ( result . bodyToFlux ( String . class )  )  . expectNext (  \" baz \"  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    body    =    Flux . just (  \" baz \"  )  . map (  (    s )     -  >    s . getBytes ( StandardCharsets . UTF _  8  )  )  . map ( dataBufferFactory :  : wrap )  ;", "response    =     . create ( BAD _ GATEWAY ,    ExchangeStrategies . withDefaults (  )  )  . header (  \" foo \"  ,     \" bar \"  )  . cookie (  \" baz \"  ,     \" qux \"  )  . body ( body )  . build (  )  ;", "assertEquals ( BAD _ GATEWAY ,    response . statusCode (  )  )  ;", "HttpHeaders   responseHeaders    =    response . headers (  )  . asHttpHeaders (  )  ;", "assertEquals (  \" bar \"  ,    responseHeaders . getFirst (  \" foo \"  )  )  ;", "assertNotNull (  \" qux \"  ,    response . cookies (  )  . getFirst (  \" baz \"  )  )  ;", "assertEquals (  \" qux \"  ,    response . cookies (  )  . getFirst (  \" baz \"  )  . getValue (  )  )  ;", "StepVerifier . create ( response . bodyToFlux ( String . class )  )  . expectNext (  \" baz \"  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "Mono < String >    resultMono    =    defaultClientResponse . body ( BodyExtractors . toMono ( String . class )  )  ;", "assertEquals (  \" foo \"  ,    resultMono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["body"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "Flux < String >    resultFlux    =    defaultClientResponse . bodyToFlux ( String . class )  ;", "Mono < List < String >  >    result    =    resultFlux . collectList (  )  ;", "assertEquals ( Collections . singletonList (  \" foo \"  )  ,    result . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToFlux"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "Flux < String >    resultFlux    =    defaultClientResponse . bodyToFlux ( new   core . ParameterizedTypeReference < String >  (  )     {  }  )  ;", "Mono < List < String >  >    result    =    resultFlux . collectList (  )  ;", "assertEquals ( Collections . singletonList (  \" foo \"  )  ,    result . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToFluxTypeReference"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "Mono < String >    resultMono    =    defaultClientResponse . bodyToMono ( String . class )  ;", "assertEquals (  \" foo \"  ,    resultMono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToMono"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "Mono < String >    resultMono    =    defaultClientResponse . bodyToMono ( new   core . ParameterizedTypeReference < String >  (  )     {  }  )  ;", "assertEquals (  \" foo \"  ,    resultMono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToMonoTypeReference"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "ResponseCookie   cookie    =    ResponseCookie . from (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "MultiValueMap < String ,    ResponseCookie >    cookies    =    new   util . LinkedMultiValueMap (  )  ;", "cookies . add (  \" foo \"  ,    cookie )  ;", "when ( mockResponse . getCookies (  )  )  . thenReturn ( cookies )  ;", "assertSame ( cookies ,    defaultClientResponse . cookies (  )  )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "mockResponse    =    mock ( ClientHttpResponse . class )  ;", "mockExchangeStrategies    =    mock ( ExchangeStrategies . class )  ;", "defaultClientResponse    =    new    ( mockResponse ,    mockExchangeStrategies )  ;", "}", "METHOD_END"], "methodName": ["createMocks"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "long   contentLength    =     4  2 L ;", "httpHeaders . setContentLength ( contentLength )  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "httpHeaders . setContentType ( contentType )  ;", "InetSocketAddress   host    =    InetSocketAddress . createUnresolved (  \" localhost \"  ,     8  0  )  ;", "httpHeaders . setHost ( host )  ;", "List < HttpRange >    range    =    Collections . singletonList ( HttpRange . createByteRange (  0  ,     4  2  )  )  ;", "httpHeaders . setRange ( range )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "ClientResponse . Headers   headers    =    d . headers (  )  ;", "assertEquals ( OptionalLong . of ( contentLength )  ,    headers . contentLength (  )  )  ;", "assertEquals ( Optional . of ( contentType )  ,    headers . contentType (  )  )  ;", "assertEquals ( httpHeaders ,    headers . asHttpHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   status    =    HttpStatus . CONTINUE ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( status )  ;", "assertEquals ( status ,    d . statusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["statusCode"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "ResponseEntity < String >    result    =    defaultClientResponse . toEntity ( String . class )  . block (  )  ;", "assertEquals (  \" foo \"  ,    result . getBody (  )  )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["toEntity"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "ResponseEntity < List < String >  >    result    =    defaultClientResponse . toEntityList ( String . class )  . block (  )  ;", "assertEquals ( Collections . singletonList (  \" foo \"  )  ,    result . getBody (  )  )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityList"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "ResponseEntity < List < String >  >    result    =    defaultClientResponse . toEntityList ( new   core . ParameterizedTypeReference < String >  (  )     {  }  )  . block (  )  ;", "assertEquals ( Collections . singletonList (  \" foo \"  )  ,    result . getBody (  )  )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityListTypeReference"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "ResponseEntity < String >    result    =    defaultClientResponse . toEntity ( new   core . ParameterizedTypeReference < String >  (  )     {  }  )  . block (  )  ;", "assertEquals (  \" foo \"  ,    result . getBody (  )  )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    result . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityTypeReference"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "TestPublisher < DataBuffer >    body    =    TestPublisher . create (  )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body . flux (  )  )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "StepVerifier . create ( defaultClientResponse . bodyToMono ( Void . class )  )  . then (  (  )     -  >     {", "body . assertWasSubscribed (  )  ;", "body . complete (  )  ;", "}  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["toMonoVoid"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "TestPublisher < DataBuffer >    body    =    TestPublisher . create (  )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "when ( mockResponse . getHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "when ( mockResponse . getStatusCode (  )  )  . thenReturn ( OK )  ;", "when ( mockResponse . getBody (  )  )  . thenReturn ( body . flux (  )  )  ;", "List < HttpMessageReader <  ?  >  >    messageReaders    =    Collections . singletonList ( new   http . codec . DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "when ( mockExchangeStrategies . messageReaders (  )  )  . thenReturn ( messageReaders )  ;", "StepVerifier . create ( defaultClientResponse . bodyToMono ( Void . class )  )  . then (  (  )     -  >     {", "body . assertWasSubscribed (  )  ;", "body . emit ( dataBuffer )  ;", "}  )  . verifyComplete (  )  ;", "body . assertCancelled (  )  ;", "}", "METHOD_END"], "methodName": ["toMonoVoidNonEmptyBody"], "fileName": "org.springframework.web.reactive.function.client.DefaultClientResponseTests"}, {"methodBody": ["METHOD_START", "{", "this . codecConfigurer . registerDefaults ( true )  ;", "}", "METHOD_END"], "methodName": ["defaultConfiguration"], "fileName": "org.springframework.web.reactive.function.client.DefaultExchangeStrategiesBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultWebClient . DefaultRequestBodyUriSpec ( httpMethod )  ;", "}", "METHOD_END"], "methodName": ["methodInternal"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClient"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . defaultCookies )     =  =    null )     {", "this . defaultCookies    =    new   util . LinkedMultiValueMap (  4  )  ;", "}", "return   this . defaultCookies ;", "}", "METHOD_END"], "methodName": ["initCookies"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . exchangeFunction )     !  =    null )     {", "return   this . exchangeFunction ;", "} else", "if    (  ( this . connector )     !  =    null )     {", "return   ExchangeFunctions . create ( this . connector ,    this . exchangeStrategies )  ;", "} else    {", "return   ExchangeFunctions . create ( new   http . client . reactive . ReactorClientHttpConnector (  )  ,    this . exchangeStrategies )  ;", "}", "}", "METHOD_END"], "methodName": ["initExchangeFunction"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . filters )     =  =    null )     {", "this . filters    =    new   ArrayList <  >  (  )  ;", "}", "return   this . filters ;", "}", "METHOD_END"], "methodName": ["initFilters"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . defaultHeaders )     =  =    null )     {", "this . defaultHeaders    =    new   HttpHeaders (  )  ;", "}", "return   this . defaultHeaders ;", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . uriBuilderFactory )     !  =    null )     {", "return   this . uriBuilderFactory ;", "}", "DefaultUriBuilderFactory   factory    =     (  ( this . baseUrl )     !  =    null )     ?    new   DefaultUriBuilderFactory ( this . baseUrl )     :    new   DefaultUriBuilderFactory (  )  ;", "factory . setDefaultUriVariables ( this . defaultUriVariables )  ;", "return   factory ;", "}", "METHOD_END"], "methodName": ["initUriBuilderFactory"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( original    !  =    null )     {", "HttpHeaders   copy    =    new   HttpHeaders (  )  ;", "copy . putAll ( original )  ;", "return   HttpHeadersdOnlyHttpHeaders ( copy )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["unmodifiableCopy"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( original    !  =    null )     {", "return   CollectionUtils . unmodifiableMultiValueMap ( new   util . LinkedMultiValueMap ( original )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["unmodifiableCopy"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientBuilder"}, {"methodBody": ["METHOD_START", "{", "WebClient   client    =    builder (  )  . apply (  (    builder )     -  >    builder . defaultHeader (  \" Accept \"  ,     \" application / json \"  )  . defaultCookie (  \" id \"  ,     \"  1  2  3  \"  )  )  . build (  )  ;", "client . get (  )  . uri (  \"  / path \"  )  . exchange (  )  ;", "ClientRequest   request    =    verifyExchange (  )  ;", "assertEquals (  \" application / json \"  ,    request . headers (  )  . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    request . cookies (  )  . getFirst (  \" id \"  )  )  ;", "verifyNoMoreInteractions ( this . exchangeFunction )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "ExchangeFilterFunction   filter    =     (    request ,    next )     -  >     {", "assertEquals (  \" bar \"  ,    request . attributes (  )  . get (  \" foo \"  )  )  ;", "return   next . exchange ( request )  ;", "}  ;", "client    =    builder (  )  . filter ( filter )  . build (  )  ;", "client . get (  )  . uri (  \"  / path \"  )  . attribute (  \" foo \"  ,     \" bar \"  )  . exchange (  )  ;", "}", "METHOD_END"], "methodName": ["attributes"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "WebClient   client    =    builder (  )  . build (  )  ;", "client . get (  )  . uri (  \"  / path \"  )  . exchange (  )  ;", "ClientRequest   request    =    verifyExchange (  )  ;", "assertEquals (  \"  / base / path \"  ,    request . url (  )  . toString (  )  )  ;", "assertEquals ( new   HttpHeaders (  )  ,    request . headers (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    request . cookies (  )  )  ;", "}", "METHOD_END"], "methodName": ["basic"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Void >    mono    =    Mono . empty (  )  ;", "client    =    builder (  )  . build (  )  ;", "client . post (  )  . uri (  \" http :  /  / example . com \"  )  . syncBody ( mono )  ;", "}", "METHOD_END"], "methodName": ["bodyObjectPublisher"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "return   WebClient . builder (  )  . baseUrl (  \"  / base \"  )  . exchangeFunction ( this . exchangeFunction )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "WebClient   client    =    builder (  )  . defaultHeader (  \" Accept \"  ,     \" application / json \"  )  . defaultCookie (  \" id \"  ,     \"  1  2  3  \"  )  . build (  )  ;", "client . get (  )  . uri (  \"  / path \"  )  . exchange (  )  ;", "ClientRequest   request    =    verifyExchange (  )  ;", "assertEquals (  \" application / json \"  ,    request . headers (  )  . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    request . cookies (  )  . getFirst (  \" id \"  )  )  ;", "verifyNoMoreInteractions ( this . exchangeFunction )  ;", "}", "METHOD_END"], "methodName": ["defaultHeaderAndCookie"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "WebClient   client    =    builder (  )  . defaultHeader (  \" Accept \"  ,     \" application / json \"  )  . defaultCookie (  \" id \"  ,     \"  1  2  3  \"  )  . build (  )  ;", "client . get (  )  . uri (  \"  / path \"  )  . header (  \" Accept \"  ,     \" application / xml \"  )  . cookie (  \" id \"  ,     \"  4  5  6  \"  )  . exchange (  )  ;", "ClientRequest   request    =    verifyExchange (  )  ;", "assertEquals (  \" application / xml \"  ,    request . headers (  )  . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \"  4  5  6  \"  ,    request . cookies (  )  . getFirst (  \" id \"  )  )  ;", "verifyNoMoreInteractions ( this . exchangeFunction )  ;", "}", "METHOD_END"], "methodName": ["defaultHeaderAndCookieOverrides"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "WebClient . Builder   builder    =    WebClient . builder (  )  ;", "builder . filter (  (    request ,    next )     -  >    next . exchange ( request )  )  ;", "builder . defaultHeader (  \" foo \"  ,     \" bar \"  )  ;", "builder . defaultCookie (  \" foo \"  ,     \" bar \"  )  ;", "WebClient   client 1     =    builder . build (  )  ;", "builder . filter (  (    request ,    next )     -  >    next . exchange ( request )  )  ;", "builder . defaultHeader (  \" baz \"  ,     \" qux \"  )  ;", "builder . defaultCookie (  \" baz \"  ,     \" qux \"  )  ;", "WebClient   client 2     =    builder . build (  )  ;", "WebClient . Builder   mutatedBuilder    =    client 1  . mutate (  )  ;", "mutatedBuilder . filter (  (    request ,    next )     -  >    next . exchange ( request )  )  ;", "mutatedBuilder . defaultHeader (  \" baz \"  ,     \" qux \"  )  ;", "mutatedBuilder . defaultCookie (  \" baz \"  ,     \" qux \"  )  ;", "WebClient   clientFromMutatedBuilder    =    mutatedBuilder . build (  )  ;", "client 1  . mutate (  )  . filters (  (    filters )     -  >    assertEquals (  1  ,    filters . size (  )  )  )  ;", "client 1  . mutate (  )  . defaultHeaders (  (    headers )     -  >    assertEquals (  1  ,    headers . size (  )  )  )  ;", "client 1  . mutate (  )  . defaultCookies (  (    cookies )     -  >    assertEquals (  1  ,    cookies . size (  )  )  )  ;", "client 2  . mutate (  )  . filters (  (    filters )     -  >    assertEquals (  2  ,    filters . size (  )  )  )  ;", "client 2  . mutate (  )  . defaultHeaders (  (    headers )     -  >    assertEquals (  2  ,    headers . size (  )  )  )  ;", "client 2  . mutate (  )  . defaultCookies (  (    cookies )     -  >    assertEquals (  2  ,    cookies . size (  )  )  )  ;", "clientFromMutatedBuilder . mutate (  )  . filters (  (    filters )     -  >    assertEquals (  2  ,    filters . size (  )  )  )  ;", "clientFromMutatedBuilder . mutate (  )  . defaultHeaders (  (    headers )     -  >    assertEquals (  2  ,    headers . size (  )  )  )  ;", "clientFromMutatedBuilder . mutate (  )  . defaultCookies (  (    cookies )     -  >    assertEquals (  2  ,    cookies . size (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mutateDoesCopy"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "WebClient   client    =    builder (  )  . build (  )  ;", "client . get (  )  . uri (  \"  / path \"  )  . accept ( APPLICATION _ JSON )  . cookies (  (    cookies )     -  >    cookies . add (  \" id \"  ,     \"  1  2  3  \"  )  )  . exchange (  )  ;", "ClientRequest   request    =    verifyExchange (  )  ;", "assertEquals (  \" application / json \"  ,    request . headers (  )  . getFirst (  \" Accept \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    request . cookies (  )  . getFirst (  \" id \"  )  )  ;", "verifyNoMoreInteractions ( this . exchangeFunction )  ;", "}", "METHOD_END"], "methodName": ["requestHeaderAndCookie"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "this . exchangeFunction    =    mock ( ExchangeFass )  ;", "when ( this . exchangeFunction . exchange ( captor . capture (  )  )  )  . thenReturn ( Mono . empty (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( builder (  )  . build (  )  . get (  )  . uri (  \"  / path \"  )  . exchange (  )  )  . expectErrorMessage (  \" The   underlying   HTTP   client   completed   without   emitting   a   response .  \"  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["switchToErrorOnEmptyClientResponseMono"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "WebClient   client    =    builder (  )  . build (  )  ;", "client . get (  )  . uri (  (    builder )     -  >    builder . path (  \"  / path \"  )  . queryParam (  \" q \"  ,     \"  1  2  \"  )  . build (  )  )  . exchange (  )  ;", "ClientRequest   request    =    verifyExchange (  )  ;", "assertEquals (  \"  / base / path ? q =  1  2  \"  ,    request . url (  )  . toString (  )  )  ;", "verifyNoMoreInteractions ( this . exchangeFunction )  ;", "}", "METHOD_END"], "methodName": ["uriBuilder"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "WebClient   client    =    builder (  )  . build (  )  ;", "client . get (  )  . uri (  (    builder )     -  >    builder . replacePath (  \"  / path \"  )  . build (  )  )  . exchange (  )  ;", "ClientRequest   request    =    verifyExchange (  )  ;", "assertEquals (  \"  / path \"  ,    request . url (  )  . toString (  )  )  ;", "verifyNoMoreInteractions ( this . exchangeFunction )  ;", "}", "METHOD_END"], "methodName": ["uriBuilderWithPathOverride"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   request    =    this . captor . getValue (  )  ;", "Mockito . verify ( this . exchangeF )  . exchange ( request )  ;", "verifyNoMoreInteractions ( this . exchangeF )  ;", "return   request ;", "}", "METHOD_END"], "methodName": ["verifyExchange"], "fileName": "org.springframework.web.reactive.function.client.DefaultWebClientTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( after ,     \"  ' after '    must   not   be   null \"  )  ;", "return    (    request ,    next )     -  >     {", "unction   nextExchange    =     (    exchangeRequest )     -  >    after . filter ( exchangeRequest ,    next )  ;", "return   filter ( request ,    nextExchange )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["andThen"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunction"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( exchange ,     \"  ' exchange '    must   not   be   null \"  )  ;", "return    (    request )     -  >    this . filter ( request ,    exchange )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunction"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( requestProcessor ,     \"  ' requestProcessor '    must   not   be   null \"  )  ;", "return    (    request ,    next )     -  >    requestProcessor . apply ( request )  . flatMap ( next :  : e )  ;", "}", "METHOD_END"], "methodName": ["ofRequestProcessor"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunction"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( responseProcessor ,     \"  ' responseProcessor '    must   not   be   null \"  )  ;", "return    (    request ,    next )     -  >    next . e ( request )  . flatMap ( responseProcessor )  ;", "}", "METHOD_END"], "methodName": ["ofResponseProcessor"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunction"}, {"methodBody": ["METHOD_START", "{", "String   credentialsString    =     (  ( credentials . username )     +     \"  :  \"  )     +     ( credentials . password )  ;", "byte [  ]    credentialBytes    =    credentialsString . getBytes ( StandardCharsets . ISO _  8  8  5  9  _  1  )  ;", "byte [  ]    encodedBytes    =    Base 6  4  . getEncoder (  )  . encode ( credentialBytes )  ;", "String   encodedCredentials    =    new   String ( encodedBytes ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  ;", "return    \" Basic    \"     +    encodedCredentials ;", "}", "METHOD_END"], "methodName": ["authorization"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctions"}, {"methodBody": ["METHOD_START", "{", "return   ExchangeFilterFunctions . basicAuthenticationInternal (  (    request )     -  >    request . attribute ( ExchangeFilterFunctions . BASIC _ AUTHENTICATION _ CREDENTIALS _ ATTRIBUTE )  . map (  (    o )     -  >     (  ( ExchangeFilterFunctions . Credentials )     ( o )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["basicAuthentication"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( username ,     \"  ' username '    must   not   be   null \"  )  ;", "Assert . notNull ( password ,     \"  ' password '    must   not   be   null \"  )  ;", ". checkIllegalCharacters ( username ,    password )  ;", "return    . basicAuthenticationInternal (  (    r )     -  >    Optional . of ( new    . Credentials ( username ,    password )  )  )  ;", "}", "METHOD_END"], "methodName": ["basicAuthentication"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctions"}, {"methodBody": ["METHOD_START", "{", "return   ExchangeFilterFunction . ofRequestProcessor (  (    clientRequest )     -  >    credentialsFunction . apply ( clientRequest )  . map (  (    credentials )     -  >     {", "ClientRequest   authorizedRequest    =    ClientRequest . from ( clientRequest )  . headers (  (    headers )     -  >    headers . set ( AUTHORIZATION ,     . authorization ( credentials )  )  )  . build (  )  ;", "return   Mono . just ( authorizedRequest )  ;", "}  )  . orElse ( Mono . just ( clientRequest )  )  )  ;", "}", "METHOD_END"], "methodName": ["basicAuthenticationInternal"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctions"}, {"methodBody": ["METHOD_START", "{", "CharsetEncoder   encoder    =    StandardCharsets . ISO _  8  8  5  9  _  1  . newEncoder (  )  ;", "if    (  (  !  ( encoder . canEncode ( username )  )  )     |  |     (  !  ( encoder . canEncode ( password )  )  )  )     {", "throw   new   IllegalArgumentExcep (  \" Username   or   password   contains   characters   that   cannot   be   encoded   to   ISO -  8  8  5  9  -  1  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkIllegalCharacters"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( statusPredicate ,     \"  ' statusPredicate '    must   not   be   null \"  )  ;", "Assert . notNull ( exceptionFunction ,     \"  ' exceptionFunction '    must   not   be   null \"  )  ;", "return    . ofResponseProcessor (  (    clientResponse )     -  >     {", "if    ( statusPredicate . test ( clientResponse . statusCode (  )  )  )     {", "return   Mono . error ( exceptionFunction . apply ( clientResponse )  )  ;", "} else    {", "return   Mono . just ( clientResponse )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["statusError"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctions"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   request    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . build (  )  ;", "ClientResponse   response    =    mock ( ClientResponse . class )  ;", "ExchangeFunction   exchange    =     (    r )     -  >    Mono . just ( response )  ;", "boolean [  ]    filtersInvoked    =    new   boolean [  2  ]  ;", "filter 1     =     (    r ,    n )     -  >     {", "assertFalse ( filtersInvoked [  0  ]  )  ;", "assertFalse ( filtersInvoked [  1  ]  )  ;", "filtersInvoked [  0  ]     =    true ;", "assertFalse ( filtersInvoked [  1  ]  )  ;", "return   n . exchange ( r )  ;", "}  ;", "filter 2     =     (    r ,    n )     -  >     {", "assertTrue ( filtersInvoked [  0  ]  )  ;", "assertFalse ( filtersInvoked [  1  ]  )  ;", "filtersInvoked [  1  ]     =    true ;", "return   n . exchange ( r )  ;", "}  ;", "filter    =    filter 1  . andThen ( filter 2  )  ;", "ClientResponse   result    =    filter . filter ( request ,    exchange )  . block (  )  ;", "assertEquals ( response ,    result )  ;", "assertTrue ( filtersInvoked [  0  ]  )  ;", "assertTrue ( filtersInvoked [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["andThen"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   request    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . build (  )  ;", "ClientResponse   response    =    mock ( ClientResponse . class )  ;", "ExchangeFunction   exchange    =     (    r )     -  >    Mono . just ( response )  ;", "boolean [  ]    filterInvoked    =    new   boolean [  1  ]  ;", "filter    =     (    r ,    n )     -  >     {", "assertFalse ( filterInvoked [  0  ]  )  ;", "filterInvoked [  0  ]     =    true ;", "return   n . exchange ( r )  ;", "}  ;", "ExchangeFunction   filteredExchange    =    filter . apply ( exchange )  ;", "ClientResponse   result    =    filteredExchange . exchange ( request )  . block (  )  ;", "assertEquals ( response ,    result )  ;", "assertTrue ( filterInvoked [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   request    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . build (  )  ;", "ClientResponse   response    =    mock ( ClientResponse . class )  ;", "ExchangeFunction   exchange    =     (    r )     -  >     {", "assertFalse ( r . headers (  )  . containsKey ( AUTHORIZATION )  )  ;", "return   Mono . just ( response )  ;", "}  ;", "ExchangeFilterFunction   auth    =     . basicAuthentication (  )  ;", "assertFalse ( request . headers (  )  . containsKey ( AUTHORIZATION )  )  ;", "ClientResponse   result    =    auth . filter ( request ,    exchange )  . block (  )  ;", "assertEquals ( response ,    result )  ;", "}", "METHOD_END"], "methodName": ["basicAuthenticationAbsentAttributes"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   request    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . attributes ( ExchangeFilterFunctions . Credentials . basicAuthenticationCredentials (  \" foo \"  ,     \" bar \"  )  )  . build (  )  ;", "ClientResponse   response    =    mock ( ClientResponse . class )  ;", "ExchangeFunction   exchange    =     (    r )     -  >     {", "assertTrue ( r . headers (  )  . containsKey ( AUTHORIZATION )  )  ;", "assertTrue ( r . headers (  )  . getFirst ( AUTHORIZATION )  . startsWith (  \" Basic    \"  )  )  ;", "return   Mono . just ( response )  ;", "}  ;", "ExchangeFilterFunction   auth    =    ExchangeFilterFunctions . basicAuthentication (  )  ;", "assertFalse ( request . headers (  )  . containsKey ( AUTHORIZATION )  )  ;", "ClientResponse   result    =    auth . filter ( request ,    exchange )  . block (  )  ;", "assertEquals ( response ,    result )  ;", "}", "METHOD_END"], "methodName": ["basicAuthenticationAttributes"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "ExchangeFilterFunctions . basicAuthentication (  \" foo \"  ,     \"  \\ ud 8  3 d \\ udca 9  \"  )  ;", "}", "METHOD_END"], "methodName": ["basicAuthenticationInvalidCharacters"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   request    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . build (  )  ;", "ClientResponse   response    =    mock ( ClientResponse . class )  ;", "ExchangeFunction   exchange    =     (    r )     -  >     {", "assertTrue ( r . headers (  )  . containsKey ( AUTHORIZATION )  )  ;", "assertTrue ( r . headers (  )  . getFirst ( AUTHORIZATION )  . startsWith (  \" Basic    \"  )  )  ;", "return   Mono . just ( response )  ;", "}  ;", "ExchangeFilterFunction   auth    =     . basicAuthentication (  \" foo \"  ,     \" bar \"  )  ;", "assertFalse ( request . headers (  )  . containsKey ( AUTHORIZATION )  )  ;", "ClientResponse   result    =    auth . filter ( request ,    exchange )  . block (  )  ;", "assertEquals ( response ,    result )  ;", "}", "METHOD_END"], "methodName": ["basicAuthenticationUsernamePassword"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   request    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . build (  )  ;", "ClientResponse   response    =    mock ( ClientResponse . class )  ;", "when ( response . statusCode (  )  )  . thenReturn ( NOT _ FOUND )  ;", "ExchangeFunction   exchange    =     (    r )     -  >    Mono . just ( response )  ;", "ExchangeFilterFunction   errorHandler    =    ExchangeFilterFunctions . statusError ( HttpStatus :  : is 4 xxClientError ,     (    r )     -  >    new   MyException (  )  )  ;", "Mono < ClientResponse >    result    =    errorHandler . filter ( request ,    exchange )  ;", "StepVerifier . create ( result )  . expectError (  . MyException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["statusHandlerMatch"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "ClientRequest   request    =    ClientRequest . create ( HttpMethod . GET ,    URI . create (  \" http :  /  / example . com \"  )  )  . build (  )  ;", "ClientResponse   response    =    mock ( ClientResponse . class )  ;", "when ( response . statusCode (  )  )  . thenReturn ( NOT _ FOUND )  ;", "ExchangeFunction   exchange    =     (    r )     -  >    Mono . just ( response )  ;", "ExchangeFilterFunction   errorHandler    =     . statusError ( HttpStatus :  : is 5 xxServerError ,     (    r )     -  >    new   MyException (  )  )  ;", "Mono < ClientResponse >    result    =    errorHandler . filter ( request ,    exchange )  ;", "StepVerifier . create ( result )  . expectNext ( response )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["statusHandlerNoMatch"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFilterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( filter ,     \"  ' filter '    must   not   be   null \"  )  ;", "return   filter . apply ( this )  ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFunction"}, {"methodBody": ["METHOD_START", "{", "return   ExchangeFunctions . create ( connector ,    ExchangeStrategies . withDefaults (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( connector ,     \"  ' connector '    must   not   be   null \"  )  ;", "Assert . notNull ( strategies ,     \"  ' strategies '    must   not   be   null \"  )  ;", "return   new    . DefaultExchangeFunction ( connector ,    strategies )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.client.ExchangeFunctions"}, {"methodBody": ["METHOD_START", "{", "DefaultExchangeStrategiesBuilder   builder    =    new   DefaultExchangeStrategiesBuilder (  )  ;", "builder . defaultConfiguration (  )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.web.reactive.function.client.ExchangeStrategies"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultExchangeStrategiesBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.web.reactive.function.client.ExchangeStrategies"}, {"methodBody": ["METHOD_START", "{", "return   ExchangeStrategies . builder (  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["withDefaults"], "fileName": "org.springframework.web.reactive.function.client.ExchangeStrategies"}, {"methodBody": ["METHOD_START", "{", "ExchangeStrategies   strategies    =    ExchangeStrategies . empty (  )  . build (  )  ;", "assertTrue ( strategies . messageReaders (  )  . isEmpty (  )  )  ;", "assertTrue ( strategies . messageWriters (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.web.reactive.function.client.ExchangeStrategiesTests"}, {"methodBody": ["METHOD_START", "{", "ExchangeStrategies   strategies    =    ExchangeStrategies . withDefaults (  )  ;", "assertFalse ( strategies . messageReaders (  )  . isEmpty (  )  )  ;", "assertFalse ( strategies . messageWriters (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaults"], "fileName": "org.springframework.web.reactive.function.client.ExchangeStrategiesTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultWebClientBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.web.reactive.function.client.WebClient"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultWebClientBuilder (  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.client.WebClient"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultWebClientBuilder (  )  . baseUrl ( baseUrl )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.client.WebClient"}, {"methodBody": ["METHOD_START", "{", "consumer . accept ( this . server . takeRequest (  )  )  ;", "}", "METHOD_END"], "methodName": ["expectRequest"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( count ,    this . server . getRequestCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["expectRequestCount"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "CRC 3  2    crc    =    new   CRC 3  2  (  )  ;", "crc . update ( bytes ,     0  ,    bytes . length )  ;", "return   crc . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["hash"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "MockResponse   response    =    new   MockResponse (  )  ;", "consumer . accept ( response )  ;", "this . server . enqueue ( response )  ;", "}", "METHOD_END"], "methodName": ["prepareResponse"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . server    =    new   MockWebServer (  )  ;", "this . webClient    =     . create ( this . server . url (  \"  /  \"  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setResponseCode (  5  0  0  )  . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" Internal   Server   error \"  )  )  ;", "Mono < String >    result    =    this . webClient . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . retrieve (  )  . onStatus ( HttpStatus :  : is 5 xxServerError ,     (    response )     -  >    Mono . just ( new   MyException (  \"  5  0  0    error !  \"  )  )  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . expectError (  . MyException . class )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting ? name = Spring \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldApplyCustomStatusHandler"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setResponseCode (  5  0  0  )  . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" Internal   Server   error \"  )  )  ;", "Mono < String >    result    =    this . webClient . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . retrieve (  )  . onStatus ( HttpStatus :  : is 5 xxServerError ,     (    response )     -  >    Mono . just ( new   MyException (  \"  5  0  0    error !  \"  )  )  )  . bodyToMono ( new   ParameterizedTypeReference < String >  (  )     {  }  )  ;", "StepVerifier . create ( result )  . expectError (  . MyException . class )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting ? name = Spring \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldApplyCustomStatusHandlerParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ExchangeFilterFunction   filter    =    ExchangeFilterFunction . ofResponseProcessor (  (    clientResponse )     -  >     {", "List < String >    headerValues    =    clientResponse . headers (  )  . header (  \" Foo \"  )  ;", "return   headerValues . isEmpty (  )     ?    Mono . error ( new    . MyException (  \" Response   does   not   contain   Foo   header \"  )  )     :    Mono . just ( clientResponse )  ;", "}  )  ;", "WebClient   filteredClient    =    this . webClient . mutate (  )  . filter ( filter )  . build (  )  ;", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" Hello   Spring !  \"  )  )  ;", "Mono < String >    result    =    filteredClient . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . expectError (  . MyException . class )  . verify ( Duration . ofSeconds (  3  )  )  ;", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setHeader (  \" Foo \"  ,     \" Bar \"  )  . setBody (  \" Hello   Spring !  \"  )  )  ;", "result    =    filteredClient . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . expectNext (  \" Hello   Spring !  \"  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  2  )  ;", "}", "METHOD_END"], "methodName": ["shouldApplyErrorHandlingFilter"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" Hello   Spring !  \"  )  )  ;", "filteredClient    =    this . webClient . mutate (  )  . filter (  (    request ,    next )     -  >     {", "ClientRequest   filteredRequest    =    ClientRequest . from ( request )  . header (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "return   next . exchange ( filteredRequest )  ;", "}  )  . build (  )  ;", "Mono < String >    result    =    filteredClient . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . expectNext (  \" Hello   Spring !  \"  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >    assertEquals (  \" bar \"  ,    request . getHeader (  \" foo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldApplyExchangeFilter"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   uri    =     \"  / api / v 4  / groups /  1  \"  ;", "Mono < ClientResponse >    responseMono    =     . builder (  )  . build (  )  . get (  )  . uri ( uri )  . exchange (  )  ;", "StepVerifier . create ( responseMono )  . expectErrorMessage (  (  \" URI   is   not   absolute :     \"     +    uri )  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldFailWithRelativeUrls"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setResponseCode (  4  0  4  )  . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" Not   Found \"  )  )  ;", "Mono < String >    result    =    this . webClient . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . expectError ( Exception . class )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting ? name = Spring \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetErrorSignalOn404"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setResponseCode (  4  0  4  )  . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  )  ;", "Mono < String >    result    =    this . webClient . get (  )  . uri (  \"  / greeting \"  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . expectError ( Exception . class )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetErrorSignalOnEmptyErrorResponse"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   errorMessage    =     \" Internal   Server   error \"  ;", "prepareResponse (  (    response )     -  >    response . setResponseCode (  5  0  0  )  . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody ( errorMessage )  )  ;", "Mono < String >    result    =    this . webClient . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . expectErrorSatisfies (  (    throwable )     -  >     {", "assertTrue (  ( throwable   instanceof   ResponseException )  )  ;", "ResponseException   ex    =     (  ( ResponseException )     ( throwable )  )  ;", "assertEquals ( HttpStatus . INTERNAL _ SERVER _ ERROR ,    ex . getStatusCode (  )  )  ;", "assertEquals ( MediaType . TEXT _ PLAIN ,    ex . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals ( errorMessage ,    ex . getResponseBodyAsString (  )  )  ;", "}  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting ? name = Spring \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetInternalServerErrorSignal"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setResponseCode (  4  0  4  )  . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" Not   Found \"  )  )  ;", "Mono < ClientResponse >    result    =    this . w . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . exchange (  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    response )     -  >    assertEquals ( HttpStatus . NOT _ FOUND ,    response . statusCode (  )  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting ? name = Spring \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceive404Response"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Length \"  ,     \"  0  \"  )  . setBody (  \"  \"  )  )  ;", "Mono < ResponseEntity < Void >  >    result    =    this . w . get (  )  . uri (  \"  / noContent \"  )  . exchange (  )  . flatMap (  (    response )     -  >    response . toEntity (  . class )  )  ;", "StepVerifier . create ( result )  . assertNext (  (    r )     -  >     {", "assertTrue ( r . getStatusCode (  )  . is 2 xxSuccessful (  )  )  ;", "}  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveEmptyResponse"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" application / json \"  )  . setBody (  \"  [  {  \\  \" bar \\  \"  :  \\  \" bar 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" foo 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" bar 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" foo 2  \\  \"  }  ]  \"  )  )  ;", "Flux < Pojo >    result    =    this . w . get (  )  . uri (  \"  / pojos \"  )  . accept ( APPLICATION _ JSON )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . bodyToFlux (  . class )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    p )     -  >    assertThat ( p . getBar (  )  ,    Matchers . is (  \" bar 1  \"  )  )  )  . consumeNextWith (  (    p )     -  >    assertThat ( p . getBar (  )  ,    Matchers . is (  \" bar 2  \"  )  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / pojos \"  ,    request . getPath (  )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( ACCEPT )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveJsonAsFluxPojo"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  {  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  ,  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  }  \"  ;", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" application / json \"  )  . setBody ( content )  )  ;", "Flux < String >    result    =    this . w . get (  )  . uri (  \"  / json \"  )  . accept ( APPLICATION _ JSON )  . retrieve (  )  . bodyToFlux ( String . class )  ;", "StepVerifier . create ( result )  . expectNext ( content )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / json \"  ,    request . getPath (  )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( ACCEPT )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveJsonAsFluxString"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" application / json \"  )  . setBody (  \"  {  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  ,  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  }  \"  )  )  ;", "Mono < Pojo >    result    =    this . w . get (  )  . uri (  \"  / pojo \"  )  . accept ( APPLICATION _ JSON )  . exchange (  )  . flatMap (  (    response )     -  >    response . bodyToMono (  . class )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    p )     -  >    assertEquals (  \" barbar \"  ,    p . getBar (  )  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / pojo \"  ,    request . getPath (  )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( ACCEPT )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveJsonAsPojo"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" bar 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" foo 1  \\  \"  }  ,     {  \\  \" bar \\  \"  :  \\  \" bar 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" foo 2  \\  \"  }  ]  \"  ;", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" application / json \"  )  . setBody ( content )  )  ;", "Mono < ResponseEntity < List < Pojo >  >  >    result    =    this . w . get (  )  . uri (  \"  / json \"  )  . accept ( APPLICATION _ JSON )  . exchange (  )  . flatMap (  (    response )     -  >    response . toEntityList (  . class )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    entity )     -  >     {", "assertEquals ( HttpStatus . OK ,    entity . getStatusCode (  )  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  5  8  ,    entity . getHeaders (  )  . getContentLength (  )  )  ;", "Pojo   pojo 1     =    new   Pojo (  \" foo 1  \"  ,     \" bar 1  \"  )  ;", "Pojo   pojo 2     =    new   Pojo (  \" foo 2  \"  ,     \" bar 2  \"  )  ;", "assertEquals ( Arrays . asList ( pojo 1  ,    pojo 2  )  ,    entity . getBody (  )  )  ;", "}  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / json \"  ,    request . getPath (  )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( ACCEPT )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveJsonAsResponseEntityList"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  {  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  ,  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  }  \"  ;", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" application / json \"  )  . setBody ( content )  )  ;", "Mono < ResponseEntity < String >  >    result    =    this . w . get (  )  . uri (  \"  / json \"  )  . accept ( APPLICATION _ JSON )  . exchange (  )  . flatMap (  (    response )     -  >    response . toEntity (  . class )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    entity )     -  >     {", "assertEquals ( HttpStatus . OK ,    entity . getStatusCode (  )  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON ,    entity . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  3  1  ,    entity . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals ( content ,    entity . getBody (  )  )  ;", "}  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / json \"  ,    request . getPath (  )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( ACCEPT )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveJsonAsResponseEntityString"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  {  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  ,  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  }  \"  ;", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" application / json \"  )  . setBody ( content )  )  ;", "Mono < String >    result    =    this . w . get (  )  . uri (  \"  / json \"  )  . accept ( APPLICATION _ JSON )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . expectNext ( content )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / json \"  ,    request . getPath (  )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( ACCEPT )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveJsonAsString"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \"  {  \\  \" containerValue \\  \"  :  {  \\  \" fooValue \\  \"  :  \\  \" bar \\  \"  }  }  \"  ;", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" application / json \"  )  . setBody ( content )  )  ;", "Mono <  . ValueContainer <  . Foo >  >    result    =    this . webClient . get (  )  . uri (  \"  / json \"  )  . accept ( APPLICATION _ JSON )  . retrieve (  )  . bodyToMono ( new   ParameterizedTypeReference <  . ValueContainer <  . Foo >  >  (  )     {  }  )  ;", "StepVerifier . create ( result )  . assertNext (  (    valueContainer )     -  >     {", "Foo   foo    =    valueContainer . getContainerValue (  )  ;", "assertNotNull ( foo )  ;", "assertEquals (  \" bar \"  ,    foo . getFooValue (  )  )  ;", "}  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / json \"  ,    request . getPath (  )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( ACCEPT )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveJsonAsTypeReferenceString"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setResponseCode (  4  0  4  )  . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" Not   Found \"  )  )  ;", "Mono < ResponseEntity < String >  >    result    =    this . w . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . exchange (  )  . flatMap (  (    response )     -  >    response . toEntity (  . class )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    response )     -  >    assertEquals ( HttpStatus . NOT _ FOUND ,    response . getStatusCode (  )  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting ? name = Spring \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveNotFoundEntity"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setBody (  \" Hello   Spring !  \"  )  )  ;", "Mono < String >    result    =    this . w . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . header (  \" X - Test - Header \"  ,     \" testvalue \"  )  . exchange (  )  . flatMap (  (    response )     -  >    response . bodyToMono (  . class )  )  ;", "StepVerifier . create ( result )  . expectNext (  \" Hello   Spring !  \"  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \" testvalue \"  ,    request . getHeader (  \" X - Test - Header \"  )  )  ;", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting ? name = Spring \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceivePlainText"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" Hello   Spring !  \"  )  )  ;", "Mono < HttpHeaders >    result    =    this . w . get (  )  . uri (  \"  / greeting ? name = Spring \"  )  . exchange (  )  . map (  (    response )     -  >    response . headers (  )  . asHttpHeaders (  )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    httpHeaders )     -  >     {", "assertEquals ( MediaType . TEXT _ PLAIN ,    httpHeaders . getContentType (  )  )  ;", "assertEquals (  1  3 L ,    httpHeaders . getContentLength (  )  )  ;", "}  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  *  /  *  \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \"  / greeting ? name = Spring \"  ,    request . getPath (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldReceiveResponseHeaders"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" text / plain \"  )  . setBody (  \" test \"  )  )  ;", "Mono < String >    result    =    this . w . get (  )  . uri (  \"  / test \"  )  . cookie (  \" testkey \"  ,     \" testvalue \"  )  . exchange (  )  . flatMap (  (    response )     -  >    response . bodyToMono (  . class )  )  ;", "StepVerifier . create ( result )  . expectNext (  \" test \"  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / test \"  ,    request . getPath (  )  )  ;", "assertEquals (  \" testkey = testvalue \"  ,    request . getHeader ( COOKIE )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldSendCookies"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >     {", "}  )  ;", "Resource   resource    =    new   ClassPathResource (  \" largeTextFile . txt \"  ,    getClass (  )  )  ;", "byte [  ]    expected    =    Files . readAllBytes ( resource . getFile (  )  . toPath (  )  )  ;", "Flux < DataBuffer >    body    =    DataBufferUtils . read ( resource ,    new   DefaultDataBufferFactory (  )  ,     4  0  9  6  )  ;", "this . webClient . post (  )  . uri (  \"  /  \"  )  . body ( body ,    DataBuffer . class )  . retrieve (  )  . bodyToMono ( Void . class )  . block ( Duration . ofSeconds (  5  )  )  ;", "expectRequest (  (    request )     -  >     {", "ByteArrayOutputStream   actual    =    new   ByteArrayOutputStream (  )  ;", "try    {", "request . getBody (  )  . copyTo ( actual )  ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "assertEquals ( expected . length ,    actual . size (  )  )  ;", "assertEquals (  . hash ( expected )  ,     . hash ( actual . toByteArray (  )  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldSendLargeTextFile"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "prepareResponse (  (    response )     -  >    response . setHeader (  \" Content - Type \"  ,     \" application / json \"  )  . setBody (  \"  {  \\  \" bar \\  \"  :  \\  \" BARBAR \\  \"  ,  \\  \" foo \\  \"  :  \\  \" FOOFOO \\  \"  }  \"  )  )  ;", "Mono < Pojo >    result    =    this . w . post (  )  . uri (  \"  / pojo / capitalize \"  )  . accept ( APPLICATION _ JSON )  . contentType ( APPLICATION _ JSON )  . syncBody ( new   Pojo (  \" foofoo \"  ,     \" barbar \"  )  )  . exchange (  )  . flatMap (  (    response )     -  >    response . bodyToMono (  . class )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    p )     -  >    assertEquals (  \" BARBAR \"  ,    p . getBar (  )  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  3  )  )  ;", "expectRequestCount (  1  )  ;", "expectRequest (  (    request )     -  >     {", "assertEquals (  \"  / pojo / capitalize \"  ,    request . getPath (  )  )  ;", "assertEquals (  \"  {  \\  \" foo \\  \"  :  \\  \" foofoo \\  \"  ,  \\  \" bar \\  \"  :  \\  \" barbar \\  \"  }  \"  ,    request . getBody (  )  . readUtf 8  (  )  )  ;", "assertEquals (  \" chunked \"  ,    request . getHeader ( TRANSFER _ ENCODING )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( ACCEPT )  )  ;", "assertEquals (  \" application / json \"  ,    request . getHeader ( CONTENT _ TYPE )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["shouldSendPojoAsJson"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . server . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.springframework.web.reactive.function.client.WebClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.web.reactive.function.client.WebClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   this . statusCode ;", "}", "METHOD_END"], "methodName": ["getRawStatusCode"], "fileName": "org.springframework.web.reactive.function.client.WebClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   this . responseBody ;", "}", "METHOD_END"], "methodName": ["getResponseBodyAsByteArray"], "fileName": "org.springframework.web.reactive.function.client.WebClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   new   String ( this . responseBody ,    this . responseCharset )  ;", "}", "METHOD_END"], "methodName": ["getResponseBodyAsString"], "fileName": "org.springframework.web.reactive.function.client.WebClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   HttpStatus . valueOf ( this . statusCode )  ;", "}", "METHOD_END"], "methodName": ["getStatusCode"], "fileName": "org.springframework.web.reactive.function.client.WebClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   this . statusText ;", "}", "METHOD_END"], "methodName": ["getStatusText"], "fileName": "org.springframework.web.reactive.function.client.WebClientResponseException"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["response"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapper"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    Mono . just (  \" foo \"  )  ;", "BodyExtractor < Mono < String >  ,    ReactiveHttpInputMessage >    extractor    =    BodyExtractors . toMono ( String . class )  ;", "when ( mock . body ( extractor )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . body ( extractor )  )  ;", "}", "METHOD_END"], "methodName": ["bodyExtractor"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    result    =    Flux . just (  \" foo \"  )  ;", "when ( mock . bodyToFlux ( String . class )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . bodyToFlux ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToFluxClass"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    result    =    Flux . just (  \" foo \"  )  ;", "ParameterizedTypeReference < String >    reference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "when ( mock . bodyToFlux ( reference )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . bodyToFlux ( reference )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToFluxParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    Mono . just (  \" foo \"  )  ;", "when ( mock . bodyToMono ( String . class )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . bodyToMono ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToMonoClass"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    Mono . just (  \" foo \"  )  ;", "ParameterizedTypeReference < String >    reference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "when ( mock . bodyToMono ( reference )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . bodyToMono ( reference )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToMonoParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    ResponseCookie >    cookies    =    mock ( MultiValueMap . class )  ;", "when ( mockResponse . cookies (  )  )  . thenReturn ( cookies )  ;", "assertSame ( cookies ,    wrapper . cookies (  )  )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "this . mockResponse    =    mock ( ClientResponse . class )  ;", "this . wrapper    =    new    ( mockResponse )  ;", "}", "METHOD_END"], "methodName": ["createWrapper"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "ClientResponse . Headers   headers    =    mock ( ClientResponse . Headers . class )  ;", "when ( mockResponse . headers (  )  )  . thenReturn ( headers )  ;", "assertSame ( headers ,    wrapper . headers (  )  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( mockResponse ,    wrapper . response (  )  )  ;", "}", "METHOD_END"], "methodName": ["response"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   status    =    HttpStatus . BAD _ REQUEST ;", "when ( mock . statusCode (  )  )  . thenReturn ( status )  ;", "assertSame ( status ,    wrapper . statusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["statusCode"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ResponseEntity < String >  >    result    =    Mono . just ( new   ResponseEntity (  \" foo \"  ,    HttpStatus . OK )  )  ;", "when ( mockResponse . toEntity ( String . class )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . toEntity ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityClass"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ResponseEntity < List < String >  >  >    result    =    Mono . just ( new   ResponseEntity ( Collections . singletonList (  \" foo \"  )  ,    HttpStatus . OK )  )  ;", "when ( mockResponse . toEntityList ( String . class )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . toEntityList ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityListClass"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ResponseEntity < List < String >  >  >    result    =    Mono . just ( new   ResponseEntity ( Collections . singletonList (  \" foo \"  )  ,    HttpStatus . OK )  )  ;", "ParameterizedTypeReference < String >    reference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "when ( mockResponse . toEntityList ( reference )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . toEntityList ( reference )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityListParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ResponseEntity < String >  >    result    =    Mono . just ( new   ResponseEntity (  \" foo \"  ,    HttpStatus . OK )  )  ;", "ParameterizedTypeReference < String >    reference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "when ( mockResponse . toEntity ( reference )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . toEntity ( reference )  )  ;", "}", "METHOD_END"], "methodName": ["toEntityParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.client.support.ClientResponseWrapperTests"}, {"methodBody": ["METHOD_START", "{", "return   HandlerStrategies . withDefaults (  )  ;", "}", "METHOD_END"], "methodName": ["handlerStrategies"], "fileName": "org.springframework.web.reactive.function.server.AbstractRouterFunctionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . allow ( GET )  . build (  )  ;", "Set < HttpMethod >    expected    =    EnumSet . of ( GET )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    expected . equals ( response . headers (  )  . getAllow (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["allow"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Publisher < String >    publisher    =    Mono . just ( body )  ;", "Mono < EntityResponse < Publisher < String >  >  >    result    =    EntityResponse . fromPublisher ( publisher ,    String . class )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  )  ;", "ServerResponse . Context   context    =    new   ServerResponse . Context (  )     {", "@ Override", "public   List < HttpMessageWriter <  ?  >  >    messageWriters (  )     {", "return   Collections . singletonList ( new   http . codec . EncoderHttpMessageWriter ( CharSequenceEncoder . allMimeTypes (  )  )  )  ;", "}", "@ Override", "public   List < ViewResolver >    viewResolvers (  )     {", "return   Collections . emptyList (  )  ;", "}", "}  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    response )     -  >     {", "StepVerifier . create ( response . entity (  )  )  . expectNext ( body )  . expectComplete (  )  . verify (  )  ;", "response . writeTo ( exchange ,    context )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "assertNotNull ( exchange . getResponse (  )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyInserter"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . cacheControl ( CacheControl . noCache (  )  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     \" no - cache \"  . equals ( response . headers (  )  . getCacheControl (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["cacheControlTag"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . contentLength (  4  2  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    Long . valueOf (  4  2  )  . equals ( response . headers (  )  . getContentLength (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . contentType ( APPLICATION _ JSON )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    MediaType . APPLICATION _ JSON . equals ( response . headers (  )  . getContentType (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    ResponseCookie >    newCookies    =    new   LinkedMultiValueMap (  )  ;", "newCookies . add (  \" name \"  ,    ResponseCookie . from (  \" name \"  ,     \" value \"  )  . build (  )  )  ;", "Mono < EntityResponse < String >  >    result    =    EntityResponse . fromObject (  \" foo \"  )  . cookies (  (    cookies )     -  >    cookies . addAll ( newCookies )  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    newCookies . equals ( response . cookies (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . eTag (  \" foo \"  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     \"  \\  \" foo \\  \"  \"  . equals ( response . headers (  )  . getETag (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["etag"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "< String >    response    =     . fromObject ( body )  . build (  )  . block (  )  ;", "assertSame ( body ,    response . entity (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromObject"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    body    =    Flux . just (  \" foo \"  ,     \" bar \"  )  ;", "ParameterizedTypeReference < String >    typeReference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "< Flux < String >  >    response    =     . fromPublisher ( body ,    typeReference )  . build (  )  . block (  )  ;", "assertSame ( body ,    response . entity (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromPublisher"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    body    =    Flux . just (  \" foo \"  ,     \" bar \"  )  ;", "< Flux < String >  >    response    =     . fromPublisher ( body ,    String . class )  . build (  )  . block (  )  ;", "assertSame ( body ,    response . entity (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromPublisherClass"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . headers ( headers )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    headers . equals ( response . headers (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ZonedDateTime   now    =    ZonedDateTime . now (  )  ;", "String   body    =     \" foo \"  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . lastModified ( now )  . build (  )  ;", "Long   expected    =     ( now . toInstant (  )  . toEpochMilli (  )  )     /     1  0  0  0  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    expected . equals (  (  ( response . headers (  )  . getLastModified (  )  )     /     1  0  0  0  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" foo \\  \"  \"  ;", "EntityResponse < String >    responseMono    =    EntityResponse . fromObject (  \" bar \"  )  . eTag ( etag )  . build (  )  . block (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . header ( IF _ NONE _ MATCH ,    etag )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "responseMono . writeTo ( exchange ,    DefaultServer . EMPTY _ CONTEXT )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals ( NOT _ MODIFIED ,    response . getStatusCode (  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectError ( IllegalStateException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notModifiedEtag"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ZonedDateTime   now    =    ZonedDateTime . now (  )  ;", "ZonedDateTime   oneMinuteBeforeNow    =    now . minus (  1  ,    ChronoUnit . MINUTES )  ;", "EntityResponse < String >    responseMono    =    EntityResponse . fromObject (  \" bar \"  )  . lastModified ( oneMinuteBeforeNow )  . build (  )  . block (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . header ( IF _ MODIFIED _ SINCE ,    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME . format ( now )  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "responseMono . writeTo ( exchange ,    DefaultServer . EMPTY _ CONTEXT )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals ( NOT _ MODIFIED ,    response . getStatusCode (  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectError ( IllegalStateException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notModifiedLastModified"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . status ( CREATED )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    HttpStatus . CREATED . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" foo \"  ;", "Mono <  < String >  >    result    =     . fromObject ( body )  . varyBy (  \" foo \"  )  . build (  )  ;", "List < String >    expected    =    Collections . singletonList (  \" foo \"  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    expected . equals ( response . headers (  )  . getVary (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["varyBy"], "fileName": "org.springframework.web.reactive.function.server.DefaultEntityResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "this . codecConfigurer . registerDefaults ( true )  ;", "this . exceptionHandlers . add ( new   WebFluxResponseStatusExceptionHandler (  )  )  ;", "this . localeContextResolver    =    new   AcceptHeaderLocaleContextResolver (  )  ;", "}", "METHOD_END"], "methodName": ["defaultConfiguration"], "fileName": "org.springframework.web.reactive.function.server.DefaultHandlerStrategiesBuilder"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    ResponseCookie >    newCookies    =    new   LinkedMultiValueMap (  )  ;", "newCookies . add (  \" name \"  ,    ResponseCookie . from (  \" name \"  ,     \" value \"  )  . build (  )  )  ;", "Mono < RenderingResponse >    result    =    RenderingResponse . create (  \" foo \"  )  . cookies (  (    cookies )     -  >    cookies . addAll ( newCookies )  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    newCookies . equals ( response . cookies (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "Mono <  >    result    =     . create ( name )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    name . equals ( response . name (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "Mono < RenderingResponse >    result    =    RenderingResponse . create (  \" view \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  )  ;", ". TestView   view    =    new    . TestView (  )  ;", "ViewResolver   viewResolver    =    mock ( ViewResolver . class )  ;", "when ( viewResolver . resolveViewName ( any (  )  ,    any (  )  )  )  . thenReturn ( Mono . just ( view )  )  ;", "List < ViewResolver >    viewResolvers    =    new   ArrayList <  >  (  )  ;", "viewResolvers . add ( viewResolver )  ;", "ServerResponse . Context   context    =    mock ( ServerResponse . Context . class )  ;", "when ( context . viewResolvers (  )  )  . thenReturn ( viewResolvers )  ;", "StepVerifier . create ( result . flatMap (  (    response )     -  >    response . writeTo ( exchange ,    context )  )  )  . verifyComplete (  )  ;", "assertEquals ( ViewResolverSupport . DEFAULT _ CONTENT _ TYPE ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultContentType"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "Mono <  >    result    =     . create (  \" foo \"  )  . headers ( headers )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    headers . equals ( response . headers (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "Mono < RenderingResponse >    result    =    RenderingResponse . create (  \" foo \"  )  . modelAttribute (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     \" bar \"  . equals ( response . model (  )  . get (  \" foo \"  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["modelAttribute"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "Mono < RenderingResponse >    result    =    RenderingResponse . create (  \" foo \"  )  . modelAttribute (  \" bar \"  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     \" bar \"  . equals ( response . model (  )  . get (  \" string \"  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeConventions"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    model    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "Mono <  >    result    =     . create (  \" foo \"  )  . modelAttributes ( model )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     \" bar \"  . equals ( response . model (  )  . get (  \" foo \"  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributes"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    model    =    Collections . singleton (  \" bar \"  )  ;", "Mono <  >    result    =     . create (  \" foo \"  )  . modelAttributes ( model )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     \" bar \"  . equals ( response . model (  )  . get (  \" string \"  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributesConventions"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" foo \\  \"  \"  ;", "responseMono    =     . create (  \" bar \"  )  . header ( ETAG ,    etag )  . build (  )  . block (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . header ( IF _ NONE _ MATCH ,    etag )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "responseMono . writeTo ( exchange ,    DefaultServerResponseBuilderTests . EMPTY _ CONTEXT )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals ( NOT _ MODIFIED ,    response . getStatusCode (  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectError ( IllegalStateException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notModifiedEtag"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "ZonedDateTime   now    =    ZonedDateTime . now (  )  ;", "ZonedDateTime   oneMinuteBeforeNow    =    now . minus (  1  ,    ChronoUnit . MINUTES )  ;", "responseMono    =     . create (  \" bar \"  )  . header ( LAST _ MODIFIED ,    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME . format ( oneMinuteBeforeNow )  )  . build (  )  . block (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . header ( IF _ MODIFIED _ SINCE ,    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME . format ( now )  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "responseMono . writeTo ( exchange ,    DefaultServerResponseBuilderTests . EMPTY _ CONTEXT )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals ( NOT _ MODIFIED ,    response . getStatusCode (  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectError ( IllegalStateException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notModifiedLastModified"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "Mono <  >    result    =     . create (  \" view \"  )  . modelAttributes ( model )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  )  ;", "ViewResolver   viewResolver    =    mock ( ViewResolver . class )  ;", "View   view    =    mock ( View . class )  ;", "when ( viewResolver . resolveViewName (  \" view \"  ,    Locale . ENGLISH )  )  . thenReturn ( Mono . just ( view )  )  ;", "when ( view . render ( model ,    null ,    exchange )  )  . thenReturn ( Mono . empty (  )  )  ;", "List < ViewResolver >    viewResolvers    =    new   ArrayList <  >  (  )  ;", "viewResolvers . add ( viewResolver )  ;", "HandlerStrategies   mockConfig    =    mock ( HandlerStrategies . class )  ;", "when ( mockConfig . viewResolvers (  )  )  . thenReturn ( viewResolvers )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     (  \" view \"  . equals ( response . name (  )  )  )     &  &     ( model . equals ( response . model (  )  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.springframework.web.reactive.function.server.DefaultRenderingResponseTests"}, {"methodBody": ["METHOD_START", "{", "return   this . exchange ;", "}", "METHOD_END"], "methodName": ["exchange"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequest"}, {"methodBody": ["METHOD_START", "{", "return   this . exchange . getRequest (  )  ;", "}", "METHOD_END"], "methodName": ["request"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequest"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( new   ArrayList <  >  ( list )  )  ;", "}", "METHOD_END"], "methodName": ["unmodifiableCopy"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequest"}, {"methodBody": ["METHOD_START", "{", "DefaultServerRequest   request    =    new   DefaultServerRequest ( MockServerWebExchange . from ( MockServerHttpRequest . method ( GET ,     \" http :  /  / example . com ? foo \"  )  )  ,    this . messageReaders )  ;", "assertEquals ( Optional . empty (  )  ,    request . queryParam (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["absentQueryParam"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . method ( GET ,     \" http :  /  / example . com \"  )  )  ;", "exchange . getAttributes (  )  . put (  \" foo \"  ,     \" bar \"  )  ;", "request    =    new    ( exchange ,    messageReaders )  ;", "assertEquals ( Optional . of (  \" bar \"  )  ,    request . attribute (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "MockServerHttpRequest   mockRequest    =    MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com ? foo = bar \"  )  . headers ( httpHeaders )  . body ( body )  ;", "request    =    new    ( MockServerWebExchange . from ( mockRequest )  ,    messageReaders )  ;", "Mono < String >    resultMono    =    request . body ( BodyExtractors . toMono ( String . class )  )  ;", "assertEquals (  \" foo \"  ,    resultMono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["body"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "MockServerHttpRequest   mockRequest    =    MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com ? foo = bar \"  )  . headers ( httpHeaders )  . body ( body )  ;", "request    =    new    ( MockServerWebExchange . from ( mockRequest )  ,    messageReaders )  ;", "Flux < String >    resultFlux    =    request . bodyToFlux ( String . class )  ;", "assertEquals ( Collections . singletonList (  \" foo \"  )  ,    resultFlux . collectList (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToFlux"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "MockServerHttpRequest   mockRequest    =    MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com ? foo = bar \"  )  . headers ( httpHeaders )  . body ( body )  ;", "request    =    new    ( MockServerWebExchange . from ( mockRequest )  ,    messageReaders )  ;", "ParameterizedTypeReference < String >    typeReference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "Flux < String >    resultFlux    =    request . bodyToFlux ( typeReference )  ;", "assertEquals ( Collections . singletonList (  \" foo \"  )  ,    resultFlux . collectList (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToFluxParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "MockServerHttpRequest   mockRequest    =    MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com ? foo = bar \"  )  . headers ( httpHeaders )  . body ( body )  ;", "request    =    new    ( MockServerWebExchange . from ( mockRequest )  ,    messageReaders )  ;", "Mono < String >    resultMono    =    request . bodyToMono ( String . class )  ;", "assertEquals (  \" foo \"  ,    resultMono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToMono"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "MockServerHttpRequest   mockRequest    =    MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com ? foo = bar \"  )  . headers ( httpHeaders )  . body ( body )  ;", "request    =    new    ( MockServerWebExchange . from ( mockRequest )  ,    messageReaders )  ;", "ParameterizedTypeReference < String >    typeReference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "Mono < String >    resultMono    =    request . bodyToMono ( typeReference )  ;", "assertEquals (  \" foo \"  ,    resultMono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToMonoParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( TEXT _ PLAIN )  ;", "MockServerHttpRequest   mockRequest    =    MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com ? foo = bar \"  )  . headers ( httpHeaders )  . body ( body )  ;", "request    =    new    ( MockServerWebExchange . from ( mockRequest )  ,    Collections . emptyList (  )  )  ;", "Flux < String >    resultFlux    =    request . bodyToFlux ( String . class )  ;", "StepVerifier . create ( resultFlux )  . expectError ( UnsupportedMediaTypeStatusException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["bodyUnacceptable"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "HttpCookie   cookie    =    new   HttpCookie (  \" foo \"  ,     \" bar \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( mock . http . server . reactive . test . MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com \"  )  . cookie ( cookie )  )  ;", "DefaultServerRequest   request    =    new   DefaultServerRequest ( exchange ,    messageReaders )  ;", "MultiValueMap < String ,    HttpCookie >    expected    =    new   util . LinkedMultiValueMap (  )  ;", "expected . add (  \" foo \"  ,    cookie )  ;", "assertEquals ( expected ,    request . cookies (  )  )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultServerRequest   request    =    new   DefaultServerRequest ( MockServerWebExchange . from ( MockServerHttpRequest . method ( GET ,     \" http :  /  / example . com ? foo \"  )  )  ,    this . messageReaders )  ;", "assertEquals ( Optional . of (  \"  \"  )  ,    request . queryParam (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyQueryParam"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap (  \" foo = bar & baz = qux \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . setContentType ( APPLICATION _ FORM _ URLENCODED )  ;", "MockServerHttpRequest   mockRequest    =    MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com \"  )  . headers ( httpHeaders )  . body ( body )  ;", "request    =    new    ( MockServerWebExchange . from ( mockRequest )  ,    Collections . emptyList (  )  )  ;", "Mono < MultiValueMap < String ,    String >  >    resultData    =    request . formData (  )  ;", "StepVerifier . create ( resultData )  . consumeNextWith (  (    formData )     -  >     {", "assertEquals (  2  ,    formData . size (  )  )  ;", "assertEquals (  \" bar \"  ,    formData . getFirst (  \" foo \"  )  )  ;", "assertEquals (  \" qux \"  ,    formData . getFirst (  \" baz \"  )  )  ;", "}  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["formData"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "List < MediaType >    accept    =    Collections . singletonList ( APPLICATION _ JSON )  ;", "httpHeaders . setAccept ( accept )  ;", "List < Charset >    acceptCharset    =    Collections . singletonList ( StandardCharsets . UTF _  8  )  ;", "httpHeaders . setAcceptCharset ( acceptCharset )  ;", "long   contentLength    =     4  2 L ;", "httpHeaders . setContentLength ( contentLength )  ;", "MediaType   contentType    =    MediaType . TEXT _ PLAIN ;", "httpHeaders . setContentType ( contentType )  ;", "InetSocketAddress   host    =    InetSocketAddress . createUnresolved (  \" localhost \"  ,     8  0  )  ;", "httpHeaders . setHost ( host )  ;", "List < HttpRange >    range    =    Collections . singletonList ( HttpRange . createByteRange (  0  ,     4  2  )  )  ;", "httpHeaders . setRange ( range )  ;", "DefaultServerRequest   request    =    new   DefaultServerRequest ( MockServerWebExchange . from ( mock . http . server . reactive . test . MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com ? foo = bar \"  )  . headers ( httpHeaders )  )  ,    this . messageReaders )  ;", "ServerRequest . Headers   headers    =    request . headers (  )  ;", "assertEquals ( accept ,    headers . accept (  )  )  ;", "assertEquals ( acceptCharset ,    headers . acceptCharset (  )  )  ;", "assertEquals ( OptionalLong . of ( contentLength )  ,    headers . contentLength (  )  )  ;", "assertEquals ( Optional . of ( contentType )  ,    headers . contentType (  )  )  ;", "assertEquals ( httpHeaders ,    headers . asHttpHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "HttpMethod   method    =    HttpMethod . HEAD ;", "request    =    new    ( MockServerWebExchange . from ( MockServerHttpRequest . method ( method ,     \" http :  /  / example . com \"  )  )  ,    this . messageReaders )  ;", "assertEquals ( method ,    request . method (  )  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "String   data    =     \"  -  -  1  2  3  4  5  \\ r \\ n \"     +     (  (  (  (  (  (  (  \" Content - Disposition :    form - data ;    name =  \\  \" foo \\  \"  \\ r \\ n \"     +     \"  \\ r \\ n \"  )     +     \" bar \\ r \\ n \"  )     +     \"  -  -  1  2  3  4  5  \\ r \\ n \"  )     +     \" Content - Disposition :    form - data ;    name =  \\  \" baz \\  \"  \\ r \\ n \"  )     +     \"  \\ r \\ n \"  )     +     \" qux \\ r \\ n \"  )     +     \"  -  -  1  2  3  4  5  -  -  \\ r \\ n \"  )  ;", "DefaultDataBufferFactory   factory    =    new   DefaultDataBufferFactory (  )  ;", "DefaultDataBuffer   dataBuffer    =    factory . wrap ( ByteBuffer . wrap ( data . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "Flux < DataBuffer >    body    =    Flux . just ( dataBuffer )  ;", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "httpHeaders . set ( CONTENT _ TYPE ,     \" multipart / form - data ;    boundary =  1  2  3  4  5  \"  )  ;", "MockServerHttpRequest   mockRequest    =    MockServerHttpRequest . method ( HttpMethod . GET ,     \" http :  /  / example . com \"  )  . headers ( httpHeaders )  . body ( body )  ;", "request    =    new    ( MockServerWebExchange . from ( mockRequest )  ,    Collections . emptyList (  )  )  ;", "Mono < MultiValueMap < String ,    Part >  >    resultData    =    request . multipartData (  )  ;", "StepVerifier . create ( resultData )  . consumeNextWith (  (    formData )     -  >     {", "assertEquals (  2  ,    formData . size (  )  )  ;", "Part   part    =    formData . getFirst (  \" foo \"  )  ;", "assertTrue (  ( part   instanceof   FormFieldPart )  )  ;", "FormFieldPart   formFieldPart    =     (  ( FormFieldPart )     ( part )  )  ;", "assertEquals (  \" bar \"  ,    formFieldPart . value (  )  )  ;", "part    =    formData . getFirst (  \" baz \"  )  ;", "assertTrue (  ( part   instanceof   FormFieldPart )  )  ;", "formFieldPart    =     (  ( FormFieldPart )     ( part )  )  ;", "assertEquals (  \" qux \"  ,    formFieldPart . value (  )  )  ;", "}  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["multipartData"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  )  ;", "Map < String ,    String >    pathVariables    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "exchange . getAttributes (  )  . put ( RouterFunctions . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ,    pathVariables )  ;", "request    =    new    ( exchange ,    messageReaders )  ;", "assertEquals (  \" bar \"  ,    request . pathVariable (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["pathVariable"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  )  ;", "Map < String ,    String >    pathVariables    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "exchange . getAttributes (  )  . put ( RouterFunctions . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ,    pathVariables )  ;", "request    =    new    ( exchange ,    messageReaders )  ;", "request . pathVariable (  \" baz \"  )  ;", "}", "METHOD_END"], "methodName": ["pathVariableNotFound"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  )  ;", "Map < String ,    String >    pathVariables    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "exchange . getAttributes (  )  . put ( RouterFunctions . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ,    pathVariables )  ;", "request    =    new    ( exchange ,    messageReaders )  ;", "assertEquals ( pathVariables ,    request . pathVariables (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathVariables"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultServerRequest   request    =    new   DefaultServerRequest ( MockServerWebExchange . from ( MockServerHttpRequest . method ( GET ,     \" http :  /  / example . com ? foo = bar \"  )  )  ,    this . messageReaders )  ;", "assertEquals ( Optional . of (  \" bar \"  )  ,    request . queryParam (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParams"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    URI . create (  \" https :  /  / example . com \"  )  ;", "request    =    new    ( MockServerWebExchange . from ( MockServerHttpRequest . method ( GET ,    uri )  )  ,    this . messageReaders )  ;", "assertEquals ( uri ,    request . uri (  )  )  ;", "}", "METHOD_END"], "methodName": ["uri"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" http \"  ,     \" localhost \"  ,     \"  / path \"  ,     \" a =  1  \"  ,    null )  ;", "request    =    new    ( MockServerWebExchange . from ( MockServerHttpRequest . method ( GET ,    uri )  )  ,    this . messageReaders )  ;", "URI   result    =    request . uriBuilder (  )  . build (  )  ;", "assertEquals (  \" http \"  ,    result . getScheme (  )  )  ;", "assertEquals (  \" localhost \"  ,    result . getHost (  )  )  ;", "assertEquals (  (  -  1  )  ,    result . getPort (  )  )  ;", "assertEquals (  \"  / path \"  ,    result . getPath (  )  )  ;", "assertEquals (  \" a =  1  \"  ,    result . getQuery (  )  )  ;", "}", "METHOD_END"], "methodName": ["uriBuilder"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerRequestTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . accepted (  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    HttpStatus . ACCEPTED . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["accepted"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . allow ( GET )  . build (  )  ;", "Set < HttpMethod >    expected    =    EnumSet . of ( GET )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    expected . equals ( response . headers (  )  . getAllow (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["allow"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . badRequest (  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    HttpStatus . BAD _ REQUEST . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["badRequest"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Void >    mono    =    Mono . empty (  )  ;", ". ok (  )  . syncBody ( mono )  ;", "}", "METHOD_END"], "methodName": ["bodyObjectPublisher"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ResponseCookie   cookie    =    ResponseCookie . from (  \" name \"  ,     \" value \"  )  . build (  )  ;", "Mono < ServerResponse >    result    =    ServerResponse . status ( CREATED )  . header (  \" MyKey \"  ,     \" MyValue \"  )  . cookie ( cookie )  . build (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "result . flatMap (  (    res )     -  >    res . writeTo ( exchange ,     . EMPTY _ CONTEXT )  )  . block (  )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals ( CREATED ,    response . getStatusCode (  )  )  ;", "assertEquals (  \" MyValue \"  ,    response . getHeaders (  )  . getFirst (  \" MyKey \"  )  )  ;", "assertEquals (  \" value \"  ,    response . getCookies (  )  . getFirst (  \" name \"  )  . getValue (  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Void >    mono    =    Mono . empty (  )  ;", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . build ( mono )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "result . flatMap (  (    res )     -  >    res . writeTo ( exchange ,     . EMPTY _ CONTEXT )  )  . block (  )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["buildVoidPublisher"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . cacheControl ( CacheControl . noCache (  )  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     \" no - cache \"  . equals ( response . headers (  )  . getCacheControl (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["cacheControlTag"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . contentLength (  4  2  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    Long . valueOf (  4  2  )  . equals ( response . headers (  )  . getContentLength (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . contentType ( APPLICATION _ JSON )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    MediaType . APPLICATION _ JSON . equals ( response . headers (  )  . getContentType (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    ResponseCookie >    newCookies    =    new   LinkedMultiValueMap (  )  ;", "newCookies . add (  \" name \"  ,    ResponseCookie . from (  \" name \"  ,     \" value \"  )  . build (  )  )  ;", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . cookies (  (    cookies )     -  >    cookies . addAll ( newCookies )  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    newCookies . equals ( response . cookies (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    URI . create (  \" http :  /  / example . com \"  )  ;", "Mono <  >    result    =     . created ( location )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     ( HttpStatus . CREATED . equals ( response . statusCode (  )  )  )     &  &     ( location . equals ( response . headers (  )  . getLocation (  )  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["created"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . eTag (  \" foo \"  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     \"  \\  \" foo \\  \"  \"  . equals ( response . headers (  )  . getETag (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["eTag"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ServerResponse   other    =    ServerResponse . ok (  )  . header (  \" foo \"  ,     \" bar \"  )  . build (  )  . block (  )  ;", "Mono < ServerResponse >    result    =    ServerResponse . from ( other )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     ( HttpStatus . OK . equals ( response . statusCode (  )  )  )     &  &     (  \" bar \"  . equals ( response . headers (  )  . getFirst (  \" foo \"  )  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   newHeaders    =    new   HttpHeaders (  )  ;", "newHeaders . set (  \" foo \"  ,     \" bar \"  )  ;", "Mono <  >    result    =     . ok (  )  . headers (  (    headers )     -  >    headers . addAll ( newHeaders )  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    newHeaders . equals ( response . headers (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ZonedDateTime   now    =    ZonedDateTime . now (  )  ;", "Mono <  >    result    =     . ok (  )  . lastModified ( now )  . build (  )  ;", "Long   expected    =     ( now . toInstant (  )  . toEpochMilli (  )  )     /     1  0  0  0  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    expected . equals (  (  ( response . headers (  )  . getLastModified (  )  )     /     1  0  0  0  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . noContent (  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    HttpStatus . NO _ CONTENT . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["noContent"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . notFound (  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    HttpStatus . NOT _ FOUND . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" foo \\  \"  \"  ;", "ServerResponse   responseMono    =    ServerResponse . ok (  )  . eTag ( etag )  . syncBody (  \" bar \"  )  . block (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . header ( IF _ NONE _ MATCH ,    etag )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "responseMono . writeTo ( exchange ,     . EMPTY _ CONTEXT )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals ( NOT _ MODIFIED ,    response . getStatusCode (  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectError ( IllegalStateException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notModifiedEtag"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ZonedDateTime   now    =    ZonedDateTime . now (  )  ;", "ZonedDateTime   oneMinuteBeforeNow    =    now . minus (  1  ,    ChronoUnit . MINUTES )  ;", "ServerResponse   responseMono    =    ServerResponse . ok (  )  . lastModified ( oneMinuteBeforeNow )  . syncBody (  \" bar \"  )  . block (  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \" http :  /  / example . com \"  )  . header ( IF _ MODIFIED _ SINCE ,    DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME . format ( now )  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "responseMono . writeTo ( exchange ,     . EMPTY _ CONTEXT )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals ( NOT _ MODIFIED ,    response . getStatusCode (  )  )  ;", "StepVerifier . create ( response . getBody (  )  )  . expectError ( IllegalStateException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notModifiedLastModified"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    HttpStatus . OK . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ok"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    URI . create (  \" http :  /  / example . com \"  )  ;", "Mono <  >    result    =     . permanentRedirect ( location )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     ( HttpStatus . PERMANENT _ REDIRECT . equals ( response . statusCode (  )  )  )     &  &     ( location . equals ( response . headers (  )  . getLocation (  )  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["permanentRedirect"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    URI . create (  \" http :  /  / example . com \"  )  ;", "Mono <  >    result    =     . seeOther ( location )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     ( HttpStatus . SEE _ OTHER . equals ( response . statusCode (  )  )  )     &  &     ( location . equals ( response . headers (  )  . getLocation (  )  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["seeOther"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . status ( CREATED )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    HttpStatus . CREATED . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "HttpStatus   statusCode    =    HttpStatus . ACCEPTED ;", "Mono <  >    result    =     . status ( statusCode )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    statusCode . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["statusCode"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    URI . create (  \" http :  /  / example . com \"  )  ;", "Mono <  >    result    =     . temporaryRedirect ( location )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >     ( HttpStatus . TEMPORARY _ REDIRECT . equals ( response . statusCode (  )  )  )     &  &     ( location . equals ( response . headers (  )  . getLocation (  )  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["temporaryRedirect"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . unprocessableEntity (  )  . build (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    HttpStatus . UNPROCESSABLE _ ENTITY . equals ( response . statusCode (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["unprocessableEntity"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ServerResponse >    result    =    ServerResponse . ok (  )  . varyBy (  \" foo \"  )  . build (  )  ;", "List < String >    expected    =    Collections . singletonList (  \" foo \"  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    response )     -  >    expected . equals ( response . headers (  )  . getVary (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["varyBy"], "fileName": "org.springframework.web.reactive.function.server.DefaultServerResponseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < DispatcherHandlerIntegrationTests . Person >    result    =    this . restTemplate . getForEntity (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / controller \"  )  ,    DispatcherHandlerIntegrationTests . Person . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals (  \" John \"  ,    result . getBody (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["controller"], "fileName": "org.springframework.web.reactive.function.server.DispatcherHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < List < DispatcherHandlerIntegrationTests . Person >  >    reference    =    new   ParameterizedTypeReference < List < DispatcherHandlerIntegrationTests . Person >  >  (  )     {  }  ;", "ResponseEntity < List < DispatcherHandlerIntegrationTests . Person >  >    result    =    this . restTemplate . exchange (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / flux \"  )  ,    GET ,    null ,    reference )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "List < DispatcherHandlerIntegrationTests . Person >    body    =    result . getBody (  )  ;", "assertEquals (  2  ,    body . size (  )  )  ;", "assertEquals (  \" John \"  ,    body . get (  0  )  . getName (  )  )  ;", "assertEquals (  \" Jane \"  ,    body . get (  1  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["flux"], "fileName": "org.springframework.web.reactive.function.server.DispatcherHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < DispatcherHandlerIntegrationTests . Person >    result    =    this . restTemplate . getForEntity (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / mono \"  )  ,    DispatcherHandlerIntegrationTests . Person . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals (  \" John \"  ,    result . getBody (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["mono"], "fileName": "org.springframework.web.reactive.function.server.DispatcherHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultEntityResponseBuilder ( t ,    BodyInserters . fromObject ( t )  )  ;", "}", "METHOD_END"], "methodName": ["fromObject"], "fileName": "org.springframework.web.reactive.function.server.EntityResponse"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultEntityResponseBuilder ( publisher ,    BodyInserters . fromPublisher ( publisher ,    elementClass )  )  ;", "}", "METHOD_END"], "methodName": ["fromPublisher"], "fileName": "org.springframework.web.reactive.function.server.EntityResponse"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultEntityResponseBuilder ( publisher ,    BodyInserters . fromPublisher ( publisher ,    typeReference )  )  ;", "}", "METHOD_END"], "methodName": ["fromPublisher"], "fileName": "org.springframework.web.reactive.function.server.EntityResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( after ,     \"  ' after '    must   not   be   null \"  )  ;", "return    (    request ,    next )     -  >     {", "Handl < T >    nextHandler    =     (    handlerRequest )     -  >    after . filter ( handlerRequest ,    next )  ;", "return   filter ( request ,    nextHandler )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["andThen"], "fileName": "org.springframework.web.reactive.function.server.HandlerFilterFunction"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( handler ,     \"  ' handler '    must   not   be   null \"  )  ;", "return    (    request )     -  >    this . filter ( request ,    handler )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.springframework.web.reactive.function.server.HandlerFilterFunction"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( requestProcessor ,     \"  ' requestProcessor '    must   not   be   null \"  )  ;", "return    (    request ,    next )     -  >    requestProcessor . apply ( request )  . flatMap ( next :  : h )  ;", "}", "METHOD_END"], "methodName": ["ofRequestProcessor"], "fileName": "org.springframework.web.reactive.function.server.HandlerFilterFunction"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( responseProcessor ,     \"  ' responseProcessor '    must   not   be   null \"  )  ;", "return    (    request ,    next )     -  >    next . h ( request )  . flatMap ( responseProcessor )  ;", "}", "METHOD_END"], "methodName": ["ofResponseProcessor"], "fileName": "org.springframework.web.reactive.function.server.HandlerFilterFunction"}, {"methodBody": ["METHOD_START", "{", "DefaultHandlerStrategiesBuilder   builder    =    new   DefaultHandlerStrategiesBuilder (  )  ;", "builder . defaultConfiguration (  )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.web.reactive.function.server.HandlerStrategies"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultHandlerStrategiesBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.web.reactive.function.server.HandlerStrategies"}, {"methodBody": ["METHOD_START", "{", "return   HandlerStrategies . builder (  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["withDefaults"], "fileName": "org.springframework.web.reactive.function.server.HandlerStrategies"}, {"methodBody": ["METHOD_START", "{", "HandlerStrategies   strategies    =    HandlerStrategies . empty (  )  . build (  )  ;", "assertTrue ( strategies . messageReaders (  )  . isEmpty (  )  )  ;", "assertTrue ( strategies . messageWriters (  )  . isEmpty (  )  )  ;", "assertTrue ( strategies . viewResolvers (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.web.reactive.function.server.HandlerStrategiesTests"}, {"methodBody": ["METHOD_START", "{", "HandlerStrategies   strategies    =    HandlerStrategies . withDefaults (  )  ;", "assertFalse ( strategies . messageReaders (  )  . isEmpty (  )  )  ;", "assertFalse ( strategies . messageWriters (  )  . isEmpty (  )  )  ;", "assertTrue ( strategies . viewResolvers (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaults"], "fileName": "org.springframework.web.reactive.function.server.HandlerStrategiesTests"}, {"methodBody": ["METHOD_START", "{", "List < MediaType >    accept    =    Collections . singletonList ( APPLICATION _ JSON )  ;", "when ( mock . accept (  )  )  . thenReturn ( accept )  ;", "assertSame ( accept ,    wrapper . accept (  )  )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "List < Charset >    acceptCharset    =    Collections . singletonList ( StandardCharsets . UTF _  8  )  ;", "when ( mock . acceptCharset (  )  )  . thenReturn ( acceptCharset )  ;", "assertSame ( acceptCharset ,    wrapper . acceptCharset (  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptCharset"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "when ( mockHeaders . asHttpHeaders (  )  )  . thenReturn ( httpHeaders )  ;", "assertSame ( httpHeaders ,    wrapper . asHttpHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["asHttpHeaders"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "OptionalLong   contentLength    =    OptionalLong . of (  4  2 L )  ;", "when ( mock . contentLength (  )  )  . thenReturn ( contentLength )  ;", "assertSame ( contentLength ,    wrapper . contentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Optional < MediaType >    contentType    =    Optional . of ( APPLICATION _ JSON )  ;", "when ( mock . contentType (  )  )  . thenReturn ( contentType )  ;", "assertSame ( contentType ,    wrapper . contentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "mockHeaders    =    mock ( ServerRequest . Headers . class )  ;", "wrapper    =    new   ServerRequestWrapp ( mockHeaders )  ;", "}", "METHOD_END"], "methodName": ["createWrapper"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "List < String >    value    =    Collections . singletonList (  \" bar \"  )  ;", "when ( mock . header ( name )  )  . thenReturn ( value )  ;", "assertSame ( value ,    wrapper . header ( name )  )  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "InetSocketAddress   host    =    InetSocketAddress . createUnresolved (  \" example . com \"  ,     4  2  )  ;", "when ( mock . host (  )  )  . thenReturn ( host )  ;", "assertSame ( host ,    wrapper . host (  )  )  ;", "}", "METHOD_END"], "methodName": ["host"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpRange >    range    =    Collections . singletonList ( HttpRange . createByteRange (  4  2  )  )  ;", "when ( mock . range (  )  )  . thenReturn ( range )  ;", "assertSame ( range ,    wrapper . range (  )  )  ;", "}", "METHOD_END"], "methodName": ["range"], "fileName": "org.springframework.web.reactive.function.server.HeadersWrapperTests"}, {"methodBody": ["METHOD_START", "{", "OkHttpClient   client    =    new   OkHttpClient (  )  ;", "Request   request    =    new   Request . Builder (  )  . m (  \" BAZ \"  ,    null )  . url (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  /  \"  )  )  . build (  )  ;", "try    ( Response   response    =    client . newCall ( request )  . execute (  )  )     {", "assertEquals (  \" BAR \"  ,    response . body (  )  . string (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidHttpMethod"], "fileName": "org.springframework.web.reactive.function.server.InvalidHttpMethodIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ClientResponse >    result    =    webClient . get (  )  . uri (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  /  \"  )  )  . exchange (  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    response )     -  >     {", "assertEquals ( HttpStatus . OK ,    response . statusCode (  )  )  ;", "assertEquals (  . GERMANY ,    response . headers (  )  . asHttpHeaders (  )  . getContentLanguage (  )  )  ;", "}  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["fixedLocale"], "fileName": "org.springframework.web.reactive.function.server.LocaleContextResolverIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   RenderingResponse . create (  \" foo \"  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.springframework.web.reactive.function.server.LocaleContextResolverIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MockServerRequest . BuilderImpl (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.springframework.web.reactive.function.server.MockServerRequest"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    result    =    restTemplate . getForEntity (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / foo / bar \"  )  ,    String . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals (  \" bar \"  ,    result . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["bar"], "fileName": "org.springframework.web.reactive.function.server.NestedRouteIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    result    =    restTemplate . getForEntity (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / foo / baz \"  )  ,    String . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals (  \" baz \"  ,    result . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["baz"], "fileName": "org.springframework.web.reactive.function.server.NestedRouteIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    result    =    restTemplate . getForEntity (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  /  1  /  2  /  3  \"  )  ,    String . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals (  \"  1  -  2  -  3  \"  ,    result . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["variables"], "fileName": "org.springframework.web.reactive.function.server.NestedRouteIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( path . contains (  \" WEB - INF \"  )  )     |  |     ( path . contains (  \" META - INF \"  )  )  )     {", "return   true ;", "}", "if    ( path . contains (  \"  :  /  \"  )  )     {", "String   relativePath    =     (  ( path . charAt (  0  )  )     =  =     '  /  '  )     ?    path . substring (  1  )     :    path ;", "if    (  ( Utils . isUrl ( relativePath )  )     |  |     ( relativePath . startsWith (  \" url :  \"  )  )  )     {", "return   true ;", "}", "}", "if    ( path . contains (  \"  \"  )  )     {", "path    =    StringUtils . cleanPath ( path )  ;", "if    ( path . contains (  \"  .  .  /  \"  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isInvalidPath"], "fileName": "org.springframework.web.reactive.function.server.PathResourceLookupFunction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resource . getClass (  )  )     !  =     ( this . location . getClass (  )  )  )     {", "return   false ;", "}", "String   resourcePath ;", "String   locationPath ;", "if    ( resource   instanceof   UrlResource )     {", "resourcePath    =    resource . getURL (  )  . toExternalForm (  )  ;", "locationPath    =    StringUtils . cleanPath ( this . location . getURL (  )  . toString (  )  )  ;", "} else", "if    ( resource   instanceof   core . io . ClassPathResource )     {", "resourcePath    =     (  ( core . io . ClassPathResource )     ( resource )  )  . getPath (  )  ;", "locationPath    =    StringUtils . cleanPath (  (  ( core . io . ClassPathResource )     ( this . location )  )  . getPath (  )  )  ;", "} else    {", "resourcePath    =    resource . getURL (  )  . getPath (  )  ;", "locationPath    =    StringUtils . cleanPath ( this . location . getURL (  )  . getPath (  )  )  ;", "}", "if    ( locationPath . equals ( resourcePath )  )     {", "return   true ;", "}", "locationPath    =     (  ( locationPath . endsWith (  \"  /  \"  )  )     |  |     ( locationPath . isEmpty (  )  )  )     ?    locationPath    :    locationPath    +     \"  /  \"  ;", "if    (  !  ( resourcePath . startsWith ( locationPath )  )  )     {", "return   false ;", "}", "if    (  ( resourcePath . contains (  \"  %  \"  )  )     &  &     ( StringUtils . uriDecode ( resourcePath ,    StandardCharsets . UTF _  8  )  . contains (  \"  .  .  /  \"  )  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isResourceUnderLocation"], "fileName": "org.springframework.web.reactive.function.server.PathResourceLookupFunction"}, {"methodBody": ["METHOD_START", "{", "boolean   slash    =    false ;", "for    ( int   i    =     0  ;    i    <     ( path . length (  )  )  ;    i +  +  )     {", "if    (  ( path . charAt ( i )  )     =  =     '  /  '  )     {", "slash    =    true ;", "} else", "if    (  (  ( path . charAt ( i )  )     >     '     '  )     &  &     (  ( path . charAt ( i )  )     !  =     1  2  7  )  )     {", "if    (  ( i    =  =     0  )     |  |     (  ( i    =  =     1  )     &  &    slash )  )     {", "return   path ;", "}", "path    =     ( slash )     ?     \"  /  \"     +     ( path . subst ( i )  )     :    path . subst ( i )  ;", "return   path ;", "}", "}", "return   slash    ?     \"  /  \"     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["processPath"], "fileName": "org.springframework.web.reactive.function.server.PathResourceLookupFunction"}, {"methodBody": ["METHOD_START", "{", "ClassPathResource   location    =    new   ClassPathResource (  \" org / springframework / web / reactive / function / server /  \"  )  ;", "function    =    new    (  \"  / resources /  *  *  \"  ,    location )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . uri ( new   URI (  \" http :  /  / localhost / resources / response . txt \"  )  )  . build (  )  ;", "Mono < Resource >    result    =    function . apply ( request )  ;", "File   expected    =    new   ClassPathResource (  \" response . txt \"  ,    getClass (  )  )  . getFile (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    resource )     -  >     {", "try    {", "return   expected . equals ( resource . getFile (  )  )  ;", "}    catch    (    ex )     {", "return   false ;", "}", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "org.springframework.web.reactive.function.server.PathResourceLookupFunctionTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathResource   location    =    new   ClassPathResource (  \" org / springframework / web / reactive / function / server /  \"  )  ;", "function    =    new    (  \"  / resources /  *  *  \"  ,    location )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . uri ( new   URI (  \" http :  /  / localhost / resources / foo \"  )  )  . build (  )  ;", "Mono < Resource >    result    =    function . apply ( request )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.reactive.function.server.PathResourceLookupFunctionTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathResource   location    =    new   ClassPathResource (  \" org / springframework / web / reactive / function / server /  \"  )  ;", "function    =    new    (  \"  / resources /  *  *  \"  ,    location )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . uri ( new   URI (  \" http :  /  / localhost / resources / child / response . txt \"  )  )  . build (  )  ;", "Mono < Resource >    result    =    function . apply ( request )  ;", "String   path    =     \" org / springframework / web / reactive / function / server / child / response . txt \"  ;", "File   expected    =    new   ClassPathResource ( path )  . getFile (  )  ;", "StepVerifier . create ( result )  . expectNextMatches (  (    resource )     -  >     {", "try    {", "return   expected . equals ( resource . getFile (  )  )  ;", "}    catch    (    ex )     {", "return   false ;", "}", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["subPath"], "fileName": "org.springframework.web.reactive.function.server.PathResourceLookupFunctionTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < List < PublisherHandlerFunctionIntegrationTests . Person >  >    reference    =    new   ParameterizedTypeReference < List < PublisherHandlerFunctionIntegrationTests . Person >  >  (  )     {  }  ;", "ResponseEntity < List < PublisherHandlerFunctionIntegrationTests . Person >  >    result    =    restTemplate . exchange (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / flux \"  )  ,    GET ,    null ,    reference )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "List < PublisherHandlerFunctionIntegrationTests . Person >    body    =    result . getBody (  )  ;", "assertEquals (  2  ,    body . size (  )  )  ;", "assertEquals (  \" John \"  ,    body . get (  0  )  . getName (  )  )  ;", "assertEquals (  \" Jane \"  ,    body . get (  1  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["flux"], "fileName": "org.springframework.web.reactive.function.server.PublisherHandlerFunctionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < PublisherHandlerFunctionIntegrationTests . Person >    result    =    restTemplate . getForEntity (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / mono \"  )  ,    PublisherHandlerFunctionIntegrationTests . Person . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals (  \" John \"  ,    result . getBody (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["mono"], "fileName": "org.springframework.web.reactive.function.server.PublisherHandlerFunctionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    URI . create (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / mono \"  )  )  ;", ". Person   person    =    new    . Person (  \" Jack \"  )  ;", "RequestEntity <  . Person >    requestEntity    =    RequestEntity . post ( uri )  . body ( person )  ;", "ResponseEntity <  . Person >    result    =    restTemplate . exchange ( requestEntity ,     . Person . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "assertEquals (  \" Jack \"  ,    result . getBody (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["postMono"], "fileName": "org.springframework.web.reactive.function.server.PublisherHandlerFunctionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \"  ' name '    must   not   be   null \"  )  ;", "return   new   DefaultBuilder ( name )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.server.RenderingResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \" Other   RenderingResponse   must   not   be   null \"  )  ;", "return   new   DefaultRenderingResponseBuilder ( other )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.web.reactive.function.server.RenderingResponse"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    result    =    restTemplate . getForEntity (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / filter \"  )  ,    String . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "Map < String ,    String >    body    =    parseBody ( result . getBody (  )  )  ;", "assertEquals (  3  ,    body . size (  )  )  ;", "assertEquals (  \" foo \"  ,    body . get (  \" name \"  )  )  ;", "assertEquals (  \" baz \"  ,    body . get (  \" bar \"  )  )  ;", "assertEquals (  \" quux \"  ,    body . get (  \" qux \"  )  )  ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.springframework.web.reactive.function.server.RenderingResponseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    result    =    restTemplate . getForEntity (  (  (  \" http :  /  / localhost :  \"     +     ( port )  )     +     \"  / normal \"  )  ,    String . class )  ;", "assertEquals ( OK ,    result . getStatusCode (  )  )  ;", "Map < String ,    String >    body    =    parseBody ( result . getBody (  )  )  ;", "assertEquals (  2  ,    body . size (  )  )  ;", "assertEquals (  \" foo \"  ,    body . get (  \" name \"  )  )  ;", "assertEquals (  \" baz \"  ,    body . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "org.springframework.web.reactive.function.server.RenderingResponseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    lines    =    body . split (  \"  \\  \\ n \"  )  ;", "Map < String ,    String >    result    =    new   LinkedHashMap <  >  ( lines . length )  ;", "for    ( String   line    :    lines )     {", "int   idx    =    line . indexOf (  '  =  '  )  ;", "String   key    =    line . substring (  0  ,    idx )  ;", "String   value    =    line . substring (  ( idx    +     1  )  )  ;", "result . put ( key ,    value )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseBody"], "fileName": "org.springframework.web.reactive.function.server.RenderingResponseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \"  ' other '    must   not   be   null \"  )  ;", "return   new   s . And ( this ,    other )  ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicate"}, {"methodBody": ["METHOD_START", "{", "return    (    t )     -  >     !  ( test ( t )  )  ;", "}", "METHOD_END"], "methodName": ["negate"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicate"}, {"methodBody": ["METHOD_START", "{", "return   test ( request )     ?    Optional . of ( request )     :    Optional . empty (  )  ;", "}", "METHOD_END"], "methodName": ["nest"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \"  ' other '    must   not   be   null \"  )  ;", "return   new   s . Or ( this ,    other )  ;", "}", "METHOD_END"], "methodName": ["or"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicate"}, {"methodBody": ["METHOD_START", "{", "RequestPredicate   predicate 1     =     (    request )     -  >    true ;", "RequestPredicate   predicate 2     =     (    request )     -  >    true ;", "RequestPredicate   predicate 3     =     (    request )     -  >    false ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "assertTrue ( predicate 1  . and ( predicate 2  )  . test ( request )  )  ;", "assertTrue ( predicate 2  . and ( predicate 1  )  . test ( request )  )  ;", "assertFalse ( predicate 1  . and ( predicate 3  )  . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicateTests"}, {"methodBody": ["METHOD_START", "{", "RequestPredicate   predicate    =     (    request )     -  >    false ;", "RequestPredicate   negated    =    predicate . negate (  )  ;", "MockServerRequest   mockRequest    =    MockServerRequest . builder (  )  . build (  )  ;", "assertTrue ( negated . test ( mockRequest )  )  ;", "predicate    =     (    request )     -  >    true ;", "negated    =    predicate . negate (  )  ;", "assertFalse ( negated . test ( mockRequest )  )  ;", "}", "METHOD_END"], "methodName": ["negate"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicateTests"}, {"methodBody": ["METHOD_START", "{", "RequestPredicate   predicate 1     =     (    request )     -  >    true ;", "RequestPredicate   predicate 2     =     (    request )     -  >    false ;", "RequestPredicate   predicate 3     =     (    request )     -  >    false ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "assertTrue ( predicate 1  . or ( predicate 2  )  . test ( request )  )  ;", "assertTrue ( predicate 2  . or ( predicate 1  )  . test ( request )  )  ;", "assertFalse ( predicate 2  . or ( predicate 3  )  . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["or"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicateTests"}, {"methodBody": ["METHOD_START", "{", "return   RequestPredicates . method ( DELETE )  . and ( RequestPredicates . path ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["DELETE"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return   RequestPredicates . method ( GET )  . and ( RequestPredicates . path ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["GET"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return   RequestPredicates . method ( HEAD )  . and ( RequestPredicates . path ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["HEAD"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return   RequestPredicates . method ( OPTIONS )  . and ( RequestPredicates . path ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["OPTIONS"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return   RequestPredicates . method ( PATCH )  . and ( RequestPredicates . path ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["PATCH"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return   RequestPredicates . method ( POST )  . and ( RequestPredicates . path ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["POST"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return   RequestPredicates . method ( PUT )  . and ( RequestPredicates . path ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["PUT"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( mediaTypes ,     \"  ' mediaTypes '    must   not   be   empty \"  )  ;", "Set < MediaType >    mediaTypeSet    =    new   HashSet ( Arrays . asList ( mediaTypes )  )  ;", "return    . headers ( new   Predicate < ServerRequest . Headers >  (  )     {", "@ Override", "public   boolean   test ( ServerRequest . Headers   headers )     {", "List < MediaType >    acceptedMediaTypes    =    headers . accept (  )  ;", "if    ( acceptedMediaTypes . isEmpty (  )  )     {", "acceptedMediaTypes    =    Collections . singletonList ( ALL )  ;", "} else    {", "MediaType . sortBySpecificityAndQuality ( acceptedMediaTypes )  ;", "}", "boolean   match    =    acceptedMediaTypes . stream (  )  . anyMatch (  (    acceptedMediaType )     -  >    mediaTypeSet . stream (  )  . anyMatch ( acceptedMediaType :  : isCompatibleWith )  )  ;", ". traceMatch (  \" Accept \"  ,    mediaTypeSet ,    acceptedMediaTypes ,    match )  ;", "return   match ;", "}", "@ Override", "public   String   toString (  )     {", "return   String . format (  \" Accept :     % s \"  ,    mediaTypeSet )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >    true ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( mediaTypes ,     \"  ' mediaTypes '    must   not   be   empty \"  )  ;", "Set < MediaType >    mediaTypeSet    =    new   HashSet ( Arrays . asList ( mediaTypes )  )  ;", "return    . headers ( new   Predicate < ServerRequest . Headers >  (  )     {", "@ Override", "public   boolean   test ( ServerRequest . Headers   headers )     {", "MediaType   contentType    =    headers . contentType (  )  . orElse ( APPLICATION _ OCTET _ STREAM )  ;", "boolean   match    =    mediaTypeSet . stream (  )  . anyMatch (  (    mediaType )     -  >    mediaType . includes ( contentType )  )  ;", ". traceMatch (  \" Content - Type \"  ,    mediaTypeSet ,    contentType ,    match )  ;", "return   match ;", "}", "@ Override", "public   String   toString (  )     {", "return   String . format (  \" Content - Type :     % s \"  ,    mediaTypeSet )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestPredicates . HeadersPredicate ( headersPredicate )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestPredicates . HttpMethodPredicate ( httpMethod )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pattern ,     \"  ' pattern '    must   not   be   null \"  )  ;", "return    . pathPredicates (  . DEFAULT _ PATTERN _ PARSER )  . apply ( pattern )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( extension ,     \"  ' extension '    must   not   be   null \"  )  ;", "return    . pathExtension (  (    pathExtension )     -  >     {", "boolean   match    =    extension . equalsIgnoreCase ( pathExtension )  ;", ". traceMatch (  \" Extension \"  ,    extension ,    pathExtension ,    match )  ;", "return   match ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["pathExtension"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( extensionPredicate ,     \"  ' extensionPredicate '    must   not   be   null \"  )  ;", "return    (    request )     -  >     {", "String   pathExtension    =    UriUtils . extractFileExtension ( request . path (  )  )  ;", "return   extensionPredicate . test ( pathExtension )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["pathExtension"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( patternParser ,     \"  ' patternParser '    must   not   be   null \"  )  ;", "return    (    pattern )     -  >    new    . PathPatternPredicate ( patternParser . parse ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["pathPredicates"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "return    (    request )     -  >     {", "Optional < String >    s    =    request . queryParam ( name )  ;", "return   s . filter ( p )  . isPresent (  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["queryParam"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "if    ( RequestPredicates . logger . isTraceEnabled (  )  )     {", "String   message    =    String . format (  \"  % s    \\  \"  % s \\  \"     % s   against   value    \\  \"  % s \\  \"  \"  ,    prefix ,    desired ,     ( match    ?     \" matches \"     :     \" does   not   match \"  )  ,    actual )  ;", "RequestPredicates . logger . trace ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["traceMatch"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicates"}, {"methodBody": ["METHOD_START", "{", "MediaType   json    =    MediaType . APPLICATION _ JSON ;", "RequestPredicate   predicate    =     . accept ( json )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . header (  \" Accept \"  ,    json . toString (  )  )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "request    =    MockServerRequest . builder (  )  . header (  \" Accept \"  ,    TEXT _ XML _ VALUE )  . build (  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "RequestPredicate   predicate    =    RequestPredicates . all (  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "MediaType   json    =    MediaType . APPLICATION _ JSON ;", "RequestPredicate   predicate    =     . contentType ( json )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . header (  \" Content - Type \"  ,    json . toString (  )  )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "request    =    MockServerRequest . builder (  )  . build (  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["contentType"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" MyHeader \"  ;", "String   value    =     \" MyValue \"  ;", "RequestPredicate   predicate    =     . headers (  (    headers )     -  >    headers . header ( name )  . equals ( Collections . singletonList ( value )  )  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . header ( name ,    value )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "request    =    MockServerRequest . builder (  )  . build (  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "HttpMethod   httpMethod    =    HttpMethod . GET ;", "RequestPredicate   predicate    =     . method ( httpMethod )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . method ( httpMethod )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "request    =    MockServerRequest . builder (  )  . method ( POST )  . build (  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    URI . create (  \" http :  /  / localhost / path \"  )  ;", "RequestPredicate   predicate    =     . GET (  \"  / p *  \"  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . method ( HttpMethod . GET )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "predicate    =     . HEAD (  \"  / p *  \"  )  ;", "request    =    MockServerRequest . builder (  )  . method ( HttpMethod . HEAD )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "predicate    =     . POST (  \"  / p *  \"  )  ;", "request    =    MockServerRequest . builder (  )  . method ( HttpMethod . POST )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "predicate    =     . PUT (  \"  / p *  \"  )  ;", "request    =    MockServerRequest . builder (  )  . method ( HttpMethod . PUT )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "predicate    =     . PATCH (  \"  / p *  \"  )  ;", "request    =    MockServerRequest . builder (  )  . method ( HttpMethod . PATCH )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "predicate    =     . DELETE (  \"  / p *  \"  )  ;", "request    =    MockServerRequest . builder (  )  . method ( HttpMethod . DELETE )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "predicate    =     . OPTIONS (  \"  / p *  \"  )  ;", "request    =    MockServerRequest . builder (  )  . method ( HttpMethod . OPTIONS )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["methods"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    URI . create (  \" http :  /  / localhost / path \"  )  ;", "RequestPredicate   predicate    =     . path (  \"  / p *  \"  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "request    =    MockServerRequest . builder (  )  . build (  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    URI . create (  \" http :  /  / localhost / foo %  2  0 bar \"  )  ;", "RequestPredicate   predicate    =     . path (  \"  / foo   bar \"  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "request    =    MockServerRequest . builder (  )  . build (  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["pathEncoded"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "RequestPredicate   predicate    =    RequestPredicates . pathExtension (  \" txt \"  )  ;", "URI   uri    =    URI . create (  \" http :  /  / localhost / file . txt \"  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "uri    =    URI . create (  \" http :  /  / localhost / FILE . TXT \"  )  ;", "request    =    MockServerRequest . builder (  )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "predicate    =    RequestPredicates . pathExtension (  \" bar \"  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "uri    =    URI . create (  \" http :  /  / localhost / file . foo \"  )  ;", "request    =    MockServerRequest . builder (  )  . uri ( uri )  . build (  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["pathExtension"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "PathPatternParser   parser    =    new   PathPatternParser (  )  ;", "parser . setCaseSensitive ( false )  ;", "Function < String ,    RequestPredicate >    pathPredicates    =     . pathPredicates ( parser )  ;", "URI   uri    =    URI . create (  \" http :  /  / localhost / path \"  )  ;", "RequestPredicate   predicate    =    pathPredicates . apply (  \"  / P *  \"  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . uri ( uri )  . build (  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["pathPredicates"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "MockServerRequest   request    =    MockServerRequest . builder (  )  . queryParam (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "RequestPredicate   predicate    =     . queryParam (  \" foo \"  ,     (    s )     -  >    s . equals (  \" bar \"  )  )  ;", "assertTrue ( predicate . test ( request )  )  ;", "predicate    =     . queryParam (  \" foo \"  ,     (    s )     -  >    s . equals (  \" baz \"  )  )  ;", "assertFalse ( predicate . test ( request )  )  ;", "}", "METHOD_END"], "methodName": ["queryParam"], "fileName": "org.springframework.web.reactive.function.server.RequestPredicatesTests"}, {"methodBody": ["METHOD_START", "{", "HandlerStrategies   strategies    =    HandlerStrategies . withDefaults (  )  ;", "context    =    new   ServerResponse . Context (  )     {", "@ Override", "public   List < HttpMessageWriter <  ?  >  >    messageWriters (  )     {", "return   strategies . messageWriters (  )  ;", "}", "@ Override", "public   List < ViewResolver >    viewResolvers (  )     {", "return   strategies . viewResolvers (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createContext"], "fileName": "org.springframework.web.reactive.function.server.ResourceHandlerFunctionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  )  ;", "MockServerHttpResponse   mockResponse    =    exchange . getResponse (  )  ;", "ServerRequest   request    =    new   DefaultServerRequest ( exchange ,    HandlerStrategies . withDefaults (  )  . messageReaders (  )  )  ;", "Mono < ServerResponse >    responseMono    =    this . h . handle ( request )  ;", "Mono < Void >    result    =    responseMono . flatMap (  (    response )     -  >     {", "assertEquals ( HttpStatus . OK ,    response . statusCode (  )  )  ;", "assertTrue (  ( response   instanceof   EntityResponse )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "EntityResponse < Resource >    entityResponse    =     (  ( EntityResponse < Resource >  )     ( response )  )  ;", "assertEquals ( this . resource ,    entityResponse . entity (  )  )  ;", "return   response . writeTo ( exchange ,    context )  ;", "}  )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "byte [  ]    expectedBytes    =    Files . readAllBytes ( this . resource . getFile (  )  . toPath (  )  )  ;", "StepVerifier . create ( mockResponse . getBody (  )  )  . consumeNextWith (  (    dataBuffer )     -  >     {", "byte [  ]    resultBytes    =    new   byte [ dataBuffer . readableByteCount (  )  ]  ;", "dataBuffer . read ( resultBytes )  ;", "assertArrayEquals ( expectedBytes ,    resultBytes )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "assertEquals ( TEXT _ PLAIN ,    mockResponse . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals ( this . resource . contentLength (  )  ,    mockResponse . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.web.reactive.function.server.ResourceHandlerFunctionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . head (  \" http :  /  / localhost \"  )  )  ;", "MockServerHttpResponse   mockResponse    =    exchange . getResponse (  )  ;", "ServerRequest   request    =    new   DefaultServerRequest ( exchange ,    HandlerStrategies . withDefaults (  )  . messageReaders (  )  )  ;", "Mono < ServerResponse >    responseMono    =    this . h . handle ( request )  ;", "Mono < Void >    result    =    responseMono . flatMap (  (    response )     -  >     {", "assertEquals ( HttpStatus . OK ,    response . statusCode (  )  )  ;", "assertTrue (  ( response   instanceof   EntityResponse )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "EntityResponse < Resource >    entityResponse    =     (  ( EntityResponse < Resource >  )     ( response )  )  ;", "assertEquals ( this . resource . getFilename (  )  ,    entityResponse . entity (  )  . getFilename (  )  )  ;", "return   response . writeTo ( exchange ,    context )  ;", "}  )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "StepVerifier . create ( mockResponse . getBody (  )  )  . expectComplete (  )  . verify (  )  ;", "assertEquals ( TEXT _ PLAIN ,    mockResponse . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals ( this . resource . contentLength (  )  ,    mockResponse . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["head"], "fileName": "org.springframework.web.reactive.function.server.ResourceHandlerFunctionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . options (  \" http :  /  / localhost \"  )  )  ;", "MockServerHttpResponse   mockResponse    =    exchange . getResponse (  )  ;", "ServerRequest   request    =    new   DefaultServerRequest ( exchange ,    HandlerStrategies . withDefaults (  )  . messageReaders (  )  )  ;", "Mono < ServerResponse >    responseMono    =    this . h . handle ( request )  ;", "Mono < Void >    result    =    responseMono . flatMap (  (    response )     -  >     {", "assertEquals ( HttpStatus . OK ,    response . statusCode (  )  )  ;", "assertEquals ( EnumSet . of ( HttpMethod . GET ,    HttpMethod . HEAD ,    HttpMethod . OPTIONS )  ,    response . headers (  )  . getAllow (  )  )  ;", "return   response . writeTo ( exchange ,    context )  ;", "}  )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "assertEquals ( OK ,    mockResponse . getStatusCode (  )  )  ;", "assertEquals ( EnumSet . of ( GET ,    HEAD ,    OPTIONS )  ,    mockResponse . getHeaders (  )  . getAllow (  )  )  ;", "StepVerifier . create ( mockResponse . getBody (  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["options"], "fileName": "org.springframework.web.reactive.function.server.ResourceHandlerFunctionTests"}, {"methodBody": ["METHOD_START", "{", "visitor . unknown ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.web.reactive.function.server.RouterFunction"}, {"methodBody": ["METHOD_START", "{", "return   new   RouterFunctions . SameComposedRouterFunction <  >  ( this ,    other )  ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "org.springframework.web.reactive.function.server.RouterFunction"}, {"methodBody": ["METHOD_START", "{", "return   and ( RouterFunctions . nest ( predicate ,    routerFunction )  )  ;", "}", "METHOD_END"], "methodName": ["andNest"], "fileName": "org.springframework.web.reactive.function.server.RouterFunction"}, {"methodBody": ["METHOD_START", "{", "return   new   RouterFunctions . DifferentComposedRouterFunction ( this ,    other )  ;", "}", "METHOD_END"], "methodName": ["andOther"], "fileName": "org.springframework.web.reactive.function.server.RouterFunction"}, {"methodBody": ["METHOD_START", "{", "return   and ( RouterFunctions . route ( predicate ,    handlerFunction )  )  ;", "}", "METHOD_END"], "methodName": ["andRoute"], "fileName": "org.springframework.web.reactive.function.server.RouterFunction"}, {"methodBody": ["METHOD_START", "{", "return   new   RouterFunctions . FilteredRouterFunction <  >  ( this ,    filterFunction )  ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.springframework.web.reactive.function.server.RouterFunction"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . ok (  )  . build (  )  ;", "< ServerResponse >    routerFunction 1     =     (    request )     -  >    Mono . empty (  )  ;", "< ServerResponse >    routerFunction 2     =     (    request )     -  >    Mono . just ( handlerFunction )  ;", "< ServerResponse >    result    =    routerFunction 1  . and ( routerFunction 2  )  ;", "assertNotNull ( result )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "Mono < HandlerFunction < ServerResponse >  >    resultHandlerFunction    =    result . route ( request )  ;", "StepVerifier . create ( resultHandlerFunction )  . expectNext ( handlerFunction )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . ok (  )  . body ( BodyInserters . fromObject (  \"  4  2  \"  )  )  ;", "<  ?  >    routerFunction 1     =     (    request )     -  >    Mono . empty (  )  ;", "< ServerResponse >    routerFunction 2     =     (    request )     -  >    Mono . just ( handlerFunction )  ;", "<  ?  >    result    =    routerFunction 1  . andOther ( routerFunction 2  )  ;", "assertNotNull ( result )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "Mono <  ?    extends   HandlerFunction <  ?  >  >    resultHandlerFunction    =    result . route ( request )  ;", "StepVerifier . create ( resultHandlerFunction )  . expectNextMatches (  (    o )     -  >    o . equals ( handlerFunction )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["andOther"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionTests"}, {"methodBody": ["METHOD_START", "{", "RouterFunction < ServerResponse >    routerFunction 1     =     (    request )     -  >    Mono . empty (  )  ;", "RequestPredicate   requestPredicate    =     (    request )     -  >    true ;", "RouterFunction < ServerResponse >    result    =    routerFunction 1  . andRoute ( requestPredicate ,    this :  : handlerMethod )  ;", "assertNotNull ( result )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "Mono <  ?    extends   HandlerFunction <  ?  >  >    resultHandlerFunction    =    result . route ( request )  ;", "StepVerifier . create ( resultHandlerFunction )  . expectNextCount (  1  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["andRoute"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    stringMono    =    Mono . just (  \"  4  2  \"  )  ;", "HandlerFunction < EntityResponse < Mono < String >  >  >    handlerFunction    =     (    request )     -  >    EntityResponse . fromPublisher ( stringMono ,    String . class )  . build (  )  ;", "< EntityResponse < Mono < String >  >  >    routerFunction    =     (    request )     -  >    Mono . just ( handlerFunction )  ;", "HandlerFilterFunction < EntityResponse < Mono < String >  >  ,    EntityResponse < Mono < Integer >  >  >    filterFunction    =     (    request ,    next )     -  >    next . handle ( request )  . flatMap (  (    response )     -  >     {", "Mono < Integer >    intMono    =    response . entity (  )  . map ( Integer :  : parseInt )  ;", "return   EntityResponse . fromPublisher ( intMono ,     . class )  . build (  )  ;", "}  )  ;", "< EntityResponse < Mono < Integer >  >  >    result    =    routerFunction . filter ( filterFunction )  ;", "assertNotNull ( result )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "Mono < EntityResponse < Mono < Integer >  >  >    responseMono    =    result . route ( request )  . flatMap (  (    hf )     -  >    hf . handle ( request )  )  ;", "StepVerifier . create ( responseMono )  . consumeNextWith (  (    serverResponse )     -  >     {", "StepVerifier . create ( serverResponse . entity (  )  )  . expectNext (  4  2  )  . expectComplete (  )  . verify (  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionTests"}, {"methodBody": ["METHOD_START", "{", "return   ServerResponse . ok (  )  . body ( BodyInserters . fromObject (  \"  4  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handlerMethod"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    exchange . getAttributes (  )  ;", "attributes . put (  . REQUEST _ ATTRIBUTE ,    request )  ;", "}", "METHOD_END"], "methodName": ["addAttributes"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "return    (  ( HandlerFunction < T >  )     ( handlerFunction )  )  ;", "}", "METHOD_END"], "methodName": ["cast"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( predicate ,     \"  ' predicate '    must   not   be   null \"  )  ;", "Assert . notNull ( routerFunction ,     \"  ' routerFunction '    must   not   be   null \"  )  ;", "return   new    . DefaultNestedRouterFunction <  >  ( predicate ,    routerFunction )  ;", "}", "METHOD_END"], "methodName": ["nest"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "return    (  ( HandlerFunction < T >  )     ( RouterFunctions . NOT _ FOUND _ HANDLER )  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( pattern ,     \"  ' pattern '    must   not   be   empty \"  )  ;", "Assert . notNull ( location ,     \"  ' location '    must   not   be   null \"  )  ;", "return    . resources ( new   PathResourceLookupFunction ( pattern ,    location )  )  ;", "}", "METHOD_END"], "methodName": ["resources"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lookupFunction ,     \"  ' lookupFunction '    must   not   be   null \"  )  ;", "return   new    . ResourcesRouterFunction ( lookupFunction )  ;", "}", "METHOD_END"], "methodName": ["resources"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( predicate ,     \"  ' predicate '    must   not   be   null \"  )  ;", "Assert . notNull ( handlerFunction ,     \"  ' handlerFunction '    must   not   be   null \"  )  ;", "return   new    . DefaultRouterFunction <  >  ( predicate ,    handlerFunction )  ;", "}", "METHOD_END"], "methodName": ["route"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "return   RouterFunctions . toHttpHandler ( routerFunction ,    HandlerStrategies . withDefaults (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandler"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( routerFunction ,     \" RouterFunction   must   not   be   null \"  )  ;", "Assert . notNull ( strategies ,     \" HandlerStrategies   must   not   be   null \"  )  ;", "WebHandler   webHandler    =     . toWebHandler ( routerFunction ,    strategies )  ;", "return   WebHttpHandlerBuilder . webHandler ( webHandler )  . filters (  (    filters )     -  >    filters . addAll ( strategies . webFilters (  )  )  )  . exceptionHandlers (  (    handlers )     -  >    handlers . addAll ( strategies . exceptionHandlers (  )  )  )  . localeContextResolver ( strategies . localeContextResolver (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandler"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "return   RouterFunctions . toWebHandler ( routerFunction ,    HandlerStrategies . withDefaults (  )  )  ;", "}", "METHOD_END"], "methodName": ["toWebHandler"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( routerFunction ,     \" RouterFunction   must   not   be   null \"  )  ;", "Assert . notNull ( strategies ,     \" HandlerStrategies   must   not   be   null \"  )  ;", "return    (    exchange )     -  >     {", "ServerRequest   request    =    new   DefaultServerRequest ( exchange ,    strategies . messageReaders (  )  )  ;", "addAttributes ( exchange ,    request )  ;", "return   routerFunction . route ( request )  . defaultIfEmpty ( notFound (  )  )  . flatMap (  (    handlerFunction )     -  >    wrapException (  (  )     -  >    handlerFunction . handle ( request )  )  )  . flatMap (  (    response )     -  >    wrapException (  (  )     -  >    response . writeTo ( exchange ,    new   HandlerStrategiesResponseContext ( strategies )  )  )  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["toWebHandler"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   suppliget (  )  ;", "}    catch    ( Throwable   t )     {", "return   Mono . or ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["wrapException"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctions"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . ok (  )  . build (  )  ;", "RouterFunction < ServerResponse >    routerFunction    =     (    request )     -  >    Mono . just ( handlerFunction )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "RequestPredicate   requestPredicate    =    mock ( RequestPredicate . class )  ;", "when ( requestPredicate . nest ( request )  )  . thenReturn ( Optional . of ( request )  )  ;", "RouterFunction < ServerResponse >    result    =     . nest ( requestPredicate ,    routerFunction )  ;", "assertNotNull ( result )  ;", "Mono < HandlerFunction < ServerResponse >  >    resultHandlerFunction    =    result . route ( request )  ;", "StepVerifier . create ( resultHandlerFunction )  . expectNext ( handlerFunction )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["nestMatch"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . ok (  )  . build (  )  ;", "RouterFunction < ServerResponse >    routerFunction    =     (    request )     -  >    Mono . just ( handlerFunction )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "RequestPredicate   requestPredicate    =    mock ( RequestPredicate . class )  ;", "when ( requestPredicate . nest ( request )  )  . thenReturn ( Optional . empty (  )  )  ;", "RouterFunction < ServerResponse >    result    =     . nest ( requestPredicate ,    routerFunction )  ;", "assertNotNull ( result )  ;", "Mono < HandlerFunction < ServerResponse >  >    resultHandlerFunction    =    result . route ( request )  ;", "StepVerifier . create ( resultHandlerFunction )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["nestNoMatch"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . ok (  )  . build (  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "RequestPredicate   requestPredicate    =    mock ( RequestPredicate . class )  ;", "when ( requestPredicate . test ( request )  )  . thenReturn ( true )  ;", "RouterFunction < ServerResponse >    result    =     . route ( requestPredicate ,    handlerFunction )  ;", "assertNotNull ( result )  ;", "Mono < HandlerFunction < ServerResponse >  >    resultHandlerFunction    =    result . route ( request )  ;", "StepVerifier . create ( resultHandlerFunction )  . expectNext ( handlerFunction )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["routeMatch"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . ok (  )  . build (  )  ;", "MockServerRequest   request    =    MockServerRequest . builder (  )  . build (  )  ;", "RequestPredicate   requestPredicate    =    mock ( RequestPredicate . class )  ;", "when ( requestPredicate . test ( request )  )  . thenReturn ( false )  ;", "RouterFunction < ServerResponse >    result    =     . route ( requestPredicate ,    handlerFunction )  ;", "assertNotNull ( result )  ;", "Mono < HandlerFunction < ServerResponse >  >    resultHandlerFunction    =    result . route ( request )  ;", "StepVerifier . create ( resultHandlerFunction )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["routeNoMatch"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    Mono . error ( new   ResponseStatusException ( HttpStatus . NOT _ FOUND ,     \" Not   found \"  )  )  ;", "RouterFunction < ServerResponse >    routerFunction    =    RouterFunctions . route ( RequestPredicates . all (  )  ,    handlerFunction )  ;", "HttpHandler   result    =    RouterFunctions . toHttpHandler ( routerFunction )  ;", "assertNotNull ( result )  ;", "MockServerHttpRequest   httpRequest    =    MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  . build (  )  ;", "MockServerHttpResponse   httpResponse    =    new   MockServerHttpResponse (  )  ;", "result . handle ( httpRequest ,    httpResponse )  . block (  )  ;", "assertEquals ( NOT _ FOUND ,    httpResponse . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandlerHandlerResponseStatusException"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    Mono .  < ServerResponse > just ( new   ServerResponse (  )     {", "@ Override", "public   HttpStatus   statusCode (  )     {", "return   HttpStatus . OK ;", "}", "@ Override", "public   HttpHeaders   headers (  )     {", "return   new   HttpHeaders (  )  ;", "}", "@ Override", "public   MultiValueMap < String ,    ResponseCookie >    cookies (  )     {", "return   new   LinkedMultiValueMap (  )  ;", "}", "@ Override", "public   Mono < Void >    writeTo ( ServerWebExchange   exchange ,    ServerResponse . Context   context )     {", "return   Mono . error ( new   server . ResponseStatusException ( HttpStatus . NOT _ FOUND ,     \" Not   found \"  )  )  ;", "}", "}  )  ;", "RouterFunction < ServerResponse >    routerFunction    =    RouterFunctions . route ( RequestPredicates . all (  )  ,    handlerFunction )  ;", "HttpHandler   result    =    RouterFunctions . toHttpHandler ( routerFunction )  ;", "assertNotNull ( result )  ;", "MockServerHttpRequest   httpRequest    =    MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  . build (  )  ;", "MockServerHttpResponse   httpResponse    =    new   MockServerHttpResponse (  )  ;", "result . handle ( httpRequest ,    httpResponse )  . block (  )  ;", "assertEquals ( NOT _ FOUND ,    httpResponse . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandlerHandlerReturnResponseStatusExceptionInResponseWriteTo"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    Mono . error ( new   IllegalStateException (  )  )  ;", "RouterFunction < ServerResponse >    routerFunction    =     . route ( RequestPredicates . all (  )  ,    handlerFunction )  ;", "HttpHandler   result    =     . toHttpHandler ( routerFunction )  ;", "assertNotNull ( result )  ;", "MockServerHttpRequest   httpRequest    =    MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  . build (  )  ;", "MockServerHttpResponse   httpResponse    =    new   MockServerHttpResponse (  )  ;", "result . handle ( httpRequest ,    httpResponse )  . block (  )  ;", "assertEquals ( INTERNAL _ SERVER _ ERROR ,    httpResponse . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandlerHandlerReturnsException"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    Mono .  < ServerResponse > just ( new   ServerResponse (  )     {", "@ Override", "public   HttpStatus   statusCode (  )     {", "return   HttpStatus . OK ;", "}", "@ Override", "public   HttpHeaders   headers (  )     {", "return   new   HttpHeaders (  )  ;", "}", "@ Override", "public   MultiValueMap < String ,    ResponseCookie >    cookies (  )     {", "return   new   LinkedMultiValueMap (  )  ;", "}", "@ Override", "public   Mono < Void >    writeTo ( ServerWebExchange   exchange ,    ServerResponse . Context   context )     {", "throw   new   server . ResponseStatusException ( HttpStatus . NOT _ FOUND ,     \" Not   found \"  )  ;", "}", "}  )  ;", "RouterFunction < ServerResponse >    routerFunction    =    RouterFunctions . route ( RequestPredicates . all (  )  ,    handlerFunction )  ;", "HttpHandler   result    =    RouterFunctions . toHttpHandler ( routerFunction )  ;", "assertNotNull ( result )  ;", "MockServerHttpRequest   httpRequest    =    MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  . build (  )  ;", "MockServerHttpResponse   httpResponse    =    new   MockServerHttpResponse (  )  ;", "result . handle ( httpRequest ,    httpResponse )  . block (  )  ;", "assertEquals ( NOT _ FOUND ,    httpResponse . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandlerHandlerThrowResponseStatusExceptionInResponseWriteTo"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >     {", "throw   new   IllegalStateException (  )  ;", "}  ;", "RouterFunction < ServerResponse >    routerFunction    =     . route ( RequestPredicates . all (  )  ,    handlerFunction )  ;", "HttpHandler   result    =     . toHttpHandler ( routerFunction )  ;", "assertNotNull ( result )  ;", "MockServerHttpRequest   httpRequest    =    MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  . build (  )  ;", "MockServerHttpResponse   httpResponse    =    new   MockServerHttpResponse (  )  ;", "result . handle ( httpRequest ,    httpResponse )  . block (  )  ;", "assertEquals ( INTERNAL _ SERVER _ ERROR ,    httpResponse . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandlerHandlerThrowsException"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . accepted (  )  . build (  )  ;", "RouterFunction < ServerResponse >    routerFunction    =     . route ( RequestPredicates . all (  )  ,    handlerFunction )  ;", "HttpHandler   result    =     . toHttpHandler ( routerFunction )  ;", "assertNotNull ( result )  ;", "MockServerHttpRequest   httpRequest    =    MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  . build (  )  ;", "MockServerHttpResponse   httpResponse    =    new   MockServerHttpResponse (  )  ;", "result . handle ( httpRequest ,    httpResponse )  . block (  )  ;", "assertEquals ( ACCEPTED ,    httpResponse . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandlerNormal"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "AtomicBoolean   filterInvoked    =    new   AtomicBoolean (  )  ;", "WebFilter   webFilter    =    new   WebFilter (  )     {", "@ Override", "public   Mono < Void >    filter ( ServerWebExchange   exchange ,    WebFilterChain   chain )     {", "filterInvoked . set ( true )  ;", "return   chain . filter ( exchange )  ;", "}", "}  ;", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . accepted (  )  . build (  )  ;", "RouterFunction < ServerResponse >    routerFunction    =     . route ( RequestPredicates . all (  )  ,    handlerFunction )  ;", "HandlerStrategies   handlerStrategies    =    HandlerStrategies . builder (  )  . webFilter ( webFilter )  . build (  )  ;", "HttpHandler   result    =     . toHttpHandler ( routerFunction ,    handlerStrategies )  ;", "assertNotNull ( result )  ;", "MockServerHttpRequest   httpRequest    =    MockServerHttpRequest . get (  \" http :  /  / localhost \"  )  . build (  )  ;", "MockServerHttpResponse   httpResponse    =    new   MockServerHttpResponse (  )  ;", "result . handle ( httpRequest ,    httpResponse )  . block (  )  ;", "assertEquals ( ACCEPTED ,    httpResponse . getStatusCode (  )  )  ;", "assertTrue ( filterInvoked . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHttpHandlerWebFilter"], "fileName": "org.springframework.web.reactive.function.server.RouterFunctionsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    attributes (  )  ;", "if    ( attributes . containsKey ( name )  )     {", "return   Optional . of ( attributes . get ( name )  )  ;", "} else    {", "return   Optional . empty (  )  ;", "}", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.web.reactive.function.server.ServerRequest"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServerRequest ( exchange ,    messageReaders )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.reactive.function.server.ServerRequest"}, {"methodBody": ["METHOD_START", "{", "return   HttpMethod . resolve ( methodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.reactive.function.server.ServerRequest"}, {"methodBody": ["METHOD_START", "{", "return   uri (  )  . getRawPath (  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.springframework.web.reactive.function.server.ServerRequest"}, {"methodBody": ["METHOD_START", "{", "return   PathContainer . parsePath ( path (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathContainer"], "fileName": "org.springframework.web.reactive.function.server.ServerRequest"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    pathVariables    =    pathVariables (  )  ;", "if    ( pathVariables . containsKey ( name )  )     {", "return   pathVariables (  )  . get ( name )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" No   path   variable   with   name    \\  \"  \"     +    name )     +     \"  \\  \"    available \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pathVariable"], "fileName": "org.springframework.web.reactive.function.server.ServerRequest"}, {"methodBody": ["METHOD_START", "{", "List < String >    queryParamValues    =    queryParams (  )  . get ( name )  ;", "if    ( ColleUtils . isEmpty ( queryParamValues )  )     {", "return   Optional . empty (  )  ;", "} else    {", "String   value    =    queryParamValues . get (  0  )  ;", "if    ( value    =  =    null )     {", "value    =     \"  \"  ;", "}", "return   Optional . of ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["queryParam"], "fileName": "org.springframework.web.reactive.function.server.ServerRequest"}, {"methodBody": ["METHOD_START", "{", "return   ServerResponse . status ( ACCEPTED )  ;", "}", "METHOD_END"], "methodName": ["accepted"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "return   ServerResponse . status ( BAD _ REQUEST )  ;", "}", "METHOD_END"], "methodName": ["badRequest"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "ServerResponse . BodyBuilder   builder    =    ServerResponse . status ( CREATED )  ;", "return   builder . location ( location )  ;", "}", "METHOD_END"], "methodName": ["created"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \" Other   ServerResponse   must   not   be   null \"  )  ;", "return   new   DefaultServerResponseBuilder ( other )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "return   ServerResponse . status ( NO _ CONTENT )  ;", "}", "METHOD_END"], "methodName": ["noContent"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "return   ServerResponse . status ( NOT _ FOUND )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "return   ServerResponse . status ( OK )  ;", "}", "METHOD_END"], "methodName": ["ok"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "ServerResponse . BodyBuilder   builder    =    ServerResponse . status ( PERMANENT _ REDIRECT )  ;", "return   builder . location ( location )  ;", "}", "METHOD_END"], "methodName": ["permanentRedirect"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "ServerResponse . BodyBuilder   builder    =    ServerResponse . status ( SEE _ OTHER )  ;", "return   builder . location ( location )  ;", "}", "METHOD_END"], "methodName": ["seeOther"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServerResponseBuilder ( status )  ;", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( status ,     \" HttpStatus   must   not   be   null \"  )  ;", "return   new   DefaultBuilder ( status )  ;", "}", "METHOD_END"], "methodName": ["status"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "ServerResponse . BodyBuilder   builder    =    ServerResponse . status ( TEMPORARY _ REDIRECT )  ;", "return   builder . location ( location )  ;", "}", "METHOD_END"], "methodName": ["temporaryRedirect"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "return   ServerResponse . status ( UNPROCESSABLE _ ENTITY )  ;", "}", "METHOD_END"], "methodName": ["unprocessableEntity"], "fileName": "org.springframework.web.reactive.function.server.ServerResponse"}, {"methodBody": ["METHOD_START", "{", "super . setup (  )  ;", "thisClient    =    WebClient . create (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.function.server.SseHandlerFunctionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < ServerSentEvent < String >  >    result    =    this . webClient . get (  )  . uri (  \"  / event \"  )  . accept ( TEXT _ EVENT _ STREAM )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . body ( toFlux ( new   ParameterizedTypeReference < ServerSentEvent < String >  >  (  )     {  }  )  )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \"  0  \"  ,    event . id (  )  )  ;", "assertEquals (  \" foo \"  ,    event . data (  )  )  ;", "assertEquals (  \" bar \"  ,    event . comment (  )  )  ;", "assertNull ( event . event (  )  )  ;", "assertNull ( event . retry (  )  )  ;", "}  )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \"  1  \"  ,    event . id (  )  )  ;", "assertEquals (  \" foo \"  ,    event . data (  )  )  ;", "assertEquals (  \" bar \"  ,    event . comment (  )  )  ;", "assertNull ( event . event (  )  )  ;", "assertNull ( event . retry (  )  )  ;", "}  )  . expectComplete (  )  . verify ( Du . ofSeconds (  5 L )  )  ;", "}", "METHOD_END"], "methodName": ["sseAsEvent"], "fileName": "org.springframework.web.reactive.function.server.SseHandlerFunctionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < SseHandlerFunctionIntegrationTests . Person >    result    =    this . webClient . get (  )  . uri (  \"  / person \"  )  . accept ( TEXT _ EVENT _ STREAM )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . body ( toFlux (  . class )  )  )  ;", "StepVerifier . create ( result )  . expectNext ( new   SseHandlerFunctionIntegrationTests . Person (  \" foo    0  \"  )  )  . expectNext ( new   SseHandlerFunctionIntegrationTests . Person (  \" foo    1  \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5 L )  )  ;", "}", "METHOD_END"], "methodName": ["sseAsPerson"], "fileName": "org.springframework.web.reactive.function.server.SseHandlerFunctionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    result    =    this . webClient . get (  )  . uri (  \"  / string \"  )  . accept ( TEXT _ EVENT _ STREAM )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . body ( toFlux (  . class )  )  )  ;", "StepVerifier . create ( result )  . expectNext (  \" foo    0  \"  )  . expectNext (  \" foo    1  \"  )  . expectComplete (  )  . verify ( Du . ofSeconds (  5 L )  )  ;", "}", "METHOD_END"], "methodName": ["sseAsString"], "fileName": "org.springframework.web.reactive.function.server.SseHandlerFunctionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( this . indent )  ;    i +  +  )     {", "this . buildappend (  '     '  )  ;", "}", "}", "METHOD_END"], "methodName": ["indent"], "fileName": "org.springframework.web.reactive.function.server.ToStringVisitor"}, {"methodBody": ["METHOD_START", "{", "return   this . routerFunction ;", "}", "METHOD_END"], "methodName": ["getRouterFunction"], "fileName": "org.springframework.web.reactive.function.server.support.RouterFunctionMapping"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Looking   for   router   functions   in   application   context :     \"     +     ( getApplicationContext (  )  )  )  )  ;", "}", "List <  <  ?  >  >    routerFunctions    =    routerFunctions (  )  ;", "if    (  (  !  ( CollectionUtils . isEmpty ( routerFunctions )  )  )     &  &     ( logger . isInfoEnabled (  )  )  )     {", "routerFunctions . forEach (  (    routerFunction )     -  >    logger . info (  (  \" Mapped    \"     +    routerFunction )  )  )  ;", "}", "this . routerFunction    =    routerFunctions . stream (  )  . reduce (  :  : andOther )  . orElse ( null )  ;", "}", "METHOD_END"], "methodName": ["initRouterFunctions"], "fileName": "org.springframework.web.reactive.function.server.support.RouterFunctionMapping"}, {"methodBody": ["METHOD_START", "{", "RouterFunctionMapping . SortedRouterFunctionsContainer   container    =    new   RouterFunctionMapping . SortedRouterFunctionsContainer (  )  ;", "obtainApplicationContext (  )  . getAutowireCapableBeanFactory (  )  . autowireBean ( container )  ;", "return   CollectionUtils . isEmpty ( container . routerFunctions )     ?    Collections . emptyList (  )     :    container . routerFunctions ;", "}", "METHOD_END"], "methodName": ["routerFunctions"], "fileName": "org.springframework.web.reactive.function.server.support.RouterFunctionMapping"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageReaders ,     \"  ' messageReaders '    must   not   be   null \"  )  ;", "this . messageReaders    =    messageReaders ;", "}", "METHOD_END"], "methodName": ["setMessageReaders"], "fileName": "org.springframework.web.reactive.function.server.support.RouterFunctionMapping"}, {"methodBody": ["METHOD_START", "{", "RouterFunction < ServerResponse >    routerFunction    =     (    request )     -  >    Mono . empty (  )  ;", "mapping    =    new    ( routerFunction )  ;", "mapping . setMessageReaders ( this . codecConfigurer . getReaders (  )  )  ;", "Mono < Object >    result    =    mapping . getHandler ( this . exchange )  ;", "StepVerifier . create ( result )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["noMatch"], "fileName": "org.springframework.web.reactive.function.server.support.RouterFunctionMappingTests"}, {"methodBody": ["METHOD_START", "{", "HandlerFunction < ServerResponse >    handlerFunction    =     (    request )     -  >    ServerResponse . ok (  )  . build (  )  ;", "RouterFunction < ServerResponse >    routerFunction    =     (    request )     -  >    Mono . just ( handlerFunction )  ;", "mapping    =    new    ( routerFunction )  ;", "mapping . setMessageReaders ( this . codecConfigurer . getReaders (  )  )  ;", "Mono < Object >    result    =    mapping . getHandler ( this . exchange )  ;", "StepVerifier . create ( result )  . expectNext ( handlerFunction )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["normal"], "fileName": "org.springframework.web.reactive.function.server.support.RouterFunctionMappingTests"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["request"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapper"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value    =     \" bar \"  ;", "when ( mock . attribute ( name )  )  . thenReturn ( Optional . of ( value )  )  ;", "assertEquals ( Optional . of ( value )  ,    wrapper . attribute ( name )  )  ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    Mono . just (  \" foo \"  )  ;", "BodyExtractor < Mono < String >  ,    RHttpInputMessage >    extractor    =    BodyExtractors . toMono ( String . class )  ;", "when ( mockRequest . body ( extractor )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . body ( extractor )  )  ;", "}", "METHOD_END"], "methodName": ["bodyExtractor"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    result    =    Flux . just (  \" foo \"  )  ;", "when ( mock . bodyToFlux ( String . class )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . bodyToFlux ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToFluxClass"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    result    =    Flux . just (  \" foo \"  )  ;", "ParameterizedTypeReference < String >    reference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "when ( mock . bodyToFlux ( reference )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . bodyToFlux ( reference )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToFluxParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    Mono . just (  \" foo \"  )  ;", "when ( mock . bodyToMono ( String . class )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . bodyToMono ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToMonoClass"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    Mono . just (  \" foo \"  )  ;", "ParameterizedTypeReference < String >    reference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "when ( mock . bodyToMono ( reference )  )  . thenReturn ( result )  ;", "assertSame ( result ,    wrapper . bodyToMono ( reference )  )  ;", "}", "METHOD_END"], "methodName": ["bodyToMonoParameterizedTypeReference"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    HttpCookie >    cookies    =    mock ( MultiValueMap . class )  ;", "when ( mock . cookies (  )  )  . thenReturn ( cookies )  ;", "assertSame ( cookies ,    wrapper . cookies (  )  )  ;", "}", "METHOD_END"], "methodName": ["cookies"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "mockRequest    =    mock ( ServerRequest . class )  ;", "wrapper    =    new    ( mockRequest )  ;", "}", "METHOD_END"], "methodName": ["createWrapper"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "ServerRequest . Headers   headers    =    mock ( ServerRequest . Headers . class )  ;", "when ( mockRequest . headers (  )  )  . thenReturn ( headers )  ;", "assertSame ( headers ,    wrapper . headers (  )  )  ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "HttpMethod   method    =    HttpMethod . POST ;", "when ( mock . method (  )  )  . thenReturn ( method )  ;", "assertSame ( method ,    wrapper . method (  )  )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "String   path    =     \"  / foo / bar \"  ;", "when ( mock . path (  )  )  . thenReturn ( path )  ;", "assertSame ( path ,    wrapper . path (  )  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value    =     \" bar \"  ;", "when ( mock . pathVariable ( name )  )  . thenReturn ( value )  ;", "assertEquals ( value ,    wrapper . pathVariable ( name )  )  ;", "}", "METHOD_END"], "methodName": ["pathVariable"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    pathVariables    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "when ( mock . pathVariables (  )  )  . thenReturn ( pathVariables )  ;", "assertSame ( pathVariables ,    wrapper . pathVariables (  )  )  ;", "}", "METHOD_END"], "methodName": ["pathVariables"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value    =     \" bar \"  ;", "when ( mock . queryParam ( name )  )  . thenReturn ( Optional . of ( value )  )  ;", "assertEquals ( Optional . of ( value )  ,    wrapper . queryParam ( name )  )  ;", "}", "METHOD_END"], "methodName": ["queryParam"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    value    =    new   LinkedMultiValueMap (  )  ;", "value . add (  \" foo \"  ,     \" bar \"  )  ;", "when ( mockRequest . queryParams (  )  )  . thenReturn ( value )  ;", "assertSame ( value ,    wrapper . queryParams (  )  )  ;", "}", "METHOD_END"], "methodName": ["queryParams"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( mockRequest ,    wrapper . request (  )  )  ;", "}", "METHOD_END"], "methodName": ["request"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    URI . create (  \" https :  /  / example . com \"  )  ;", "when ( mock . uri (  )  )  . thenReturn ( uri )  ;", "assertSame ( uri ,    wrapper . uri (  )  )  ;", "}", "METHOD_END"], "methodName": ["uri"], "fileName": "org.springframework.web.reactive.function.server.support.ServerRequestWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageWriters ,     \"  ' messageWriters '    must   not   be   null \"  )  ;", "this . messageWriters    =    configurer ;", "}", "METHOD_END"], "methodName": ["setMessageWriters"], "fileName": "org.springframework.web.reactive.function.server.support.ServerResponseResultHandler"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.web.reactive.function.server.support.ServerResponseResultHandler"}, {"methodBody": ["METHOD_START", "{", "this . viewResolvers    =    viewResolvers ;", "}", "METHOD_END"], "methodName": ["setViewResolvers"], "fileName": "org.springframework.web.reactive.function.server.support.ServerResponseResultHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( handler   instanceof   CorsConfigurationSource )     {", "return    (  ( CorsConfigurationSource )     ( handler )  )  . getCorsConfiguration ( exchange )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCorsConfiguration"], "fileName": "org.springframework.web.reactive.handler.AbstractHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "return   this . corsProcessor ;", "}", "METHOD_END"], "methodName": ["getCorsProcessor"], "fileName": "org.springframework.web.reactive.handler.AbstractHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "return   this . patternParser ;", "}", "METHOD_END"], "methodName": ["getPathPatternParser"], "fileName": "org.springframework.web.reactive.handler.AbstractHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "this . globalCorsConfigSource . setCorsConfigurations ( corsConfigurations )  ;", "}", "METHOD_END"], "methodName": ["setCorsConfigurations"], "fileName": "org.springframework.web.reactive.handler.AbstractHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( corsProcessor ,     \" CorsProcessor   must   not   be   null \"  )  ;", "this . corsProcessor    =    corsProcessor ;", "}", "METHOD_END"], "methodName": ["setCorsProcessor"], "fileName": "org.springframework.web.reactive.handler.AbstractHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.web.reactive.handler.AbstractHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "this . patternParser . setCaseSensitive ( caseSensitiveMatch )  ;", "}", "METHOD_END"], "methodName": ["setUseCaseSensitiveMatch"], "fileName": "org.springframework.web.reactive.handler.AbstractHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "this . patternParser . setMatchOptionalTrailingSeparator ( trailingSlashMatch )  ;", "}", "METHOD_END"], "methodName": ["setUseTrailingSlashMatch"], "fileName": "org.springframework.web.reactive.handler.AbstractHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "return    \" handler    \"     +     ( handler   instanceof   String    ?     (  \"  '  \"     +    handler )     +     \"  '  \"     :     (  \" of   type    [  \"     +     ( handler . getClass (  )  )  )     +     \"  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerDescription"], "fileName": "org.springframework.web.reactive.handler.AbstractUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . handlerMap )  ;", "}", "METHOD_END"], "methodName": ["getHandlerMap"], "fileName": "org.springframework.web.reactive.handler.AbstractUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "if    ( handler   instanceof   String )     {", "String   handlerName    =     (  ( String )     ( handler )  )  ;", "handler    =    obtainApplicationContext (  )  . getBean ( handlerName )  ;", "}", "validateHandler ( handler ,    exchange )  ;", "exchange . getAttributes (  )  . put (  . BEST _ MATCHING _ HANDLER _ ATTRIBUTE ,    handler )  ;", "exchange . getAttributes (  )  . put (  . BEST _ MATCHING _ PATTERN _ ATTRIBUTE ,    bestMatch )  ;", "exchange . getAttributes (  )  . put (  . PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE ,    pathWithinMapping )  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["handleMatch"], "fileName": "org.springframework.web.reactive.handler.AbstractUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "return   this . handlerMap . entrySet (  )  . stream (  )  . filter (  (    entry )     -  >    entry . getKey (  )  . matches ( lookupPath )  )  . sorted (  (    entry 1  ,    entry 2  )     -  >    PathPattern . SPECIFICITY _ COMPARATOR . compare ( entry 1  . getKey (  )  ,    entry 2  . getKey (  )  )  )  . findFirst (  )  . map (  (    entry )     -  >     {", "PathPattern   pattern    =    entry . getKey (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Matching   pattern   for   request    [  \"     +    lookupPath )     +     \"  ]    is    \"  )     +    pattern )  )  ;", "}", "PathContainer   pathWithinMapping    =    pattern . extractPathWithinPattern ( lookupPath )  ;", "return   handleMatch ( entry . getValue (  )  ,    pattern ,    pathWithinMapping ,    exchange )  ;", "}  )  . orElse ( null )  ;", "}", "METHOD_END"], "methodName": ["lookupHandler"], "fileName": "org.springframework.web.reactive.handler.AbstractUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "if    (  ( StringUtils . hasLength ( pattern )  )     &  &     (  !  ( pattern . startsWith (  \"  /  \"  )  )  )  )     {", "return    \"  /  \"     +    pattern ;", "} else    {", "return   pattern ;", "}", "}", "METHOD_END"], "methodName": ["prependLeadingSlash"], "fileName": "org.springframework.web.reactive.handler.AbstractUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( urlPath ,     \" URL   path   must   not   be   null \"  )  ;", "Assert . notNull ( handler ,     \" Handler   object   must   not   be   null \"  )  ;", "Object   resolvedHandler    =    handler ;", "urlPath    =     . prependLeadingSlash ( urlPath )  ;", "PathPattern   pattern    =    getPathPatternParser (  )  . parse ( urlPath )  ;", "if    ( this . handlerMap . containsKey ( pattern )  )     {", "Object   existingHandler    =    this . handlerMap . get ( pattern )  ;", "if    (  ( existingHandler    !  =    null )     &  &     ( existingHandler    !  =    resolvedHandler )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  (  \" Cannot   map    \"     +     ( getHandlerDescription ( handler )  )  )     +     \"    to    [  \"  )     +    urlPath )     +     \"  ]  :     \"  )     +     \" there   is   already    \"  )     +     ( getHandlerDescription ( existingHandler )  )  )     +     \"    mapped .  \"  )  )  ;", "}", "}", "if    (  (  !  ( this . lazyInitHandlers )  )     &  &     ( handler   instanceof   String )  )     {", "String   handlerName    =     (  ( String )     ( handler )  )  ;", "if    ( obtainApplicationContext (  )  . isSingleton ( handlerName )  )     {", "resolvedHandler    =    obtainApplicationContext (  )  . getBean ( handlerName )  ;", "}", "}", "this . handlerMap . put ( pattern ,    resolvedHandler )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  \" Mapped   URL   path    [  \"     +    urlPath )     +     \"  ]    onto    \"  )     +     ( getHandlerDescription ( handler )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerHandler"], "fileName": "org.springframework.web.reactive.handler.AbstractUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( urlPaths ,     \" URL   path   array   must   not   be   null \"  )  ;", "for    ( String   urlPath    :    urlPaths )     {", "register ( urlPath ,    beanName )  ;", "}", "}", "METHOD_END"], "methodName": ["registerHandler"], "fileName": "org.springframework.web.reactive.handler.AbstractUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "this . lazyInitHandlers    =    lazyInitHandlers ;", "}", "METHOD_END"], "methodName": ["setLazyInitHandlers"], "fileName": "org.springframework.web.reactive.handler.AbstractUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "String   origin    =     \" http :  /  / domain 2  . com \"  ;", "ServerWebExchange   exchange    =    createExchange ( GET ,     \"  / cors . html \"  ,    origin )  ;", "Object   actual    =    this . h . getHandler ( exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertSame ( this . corsController ,    actual )  ;", "assertEquals (  \"  *  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithCorsAwareHandler"], "fileName": "org.springframework.web.reactive.handler.CorsUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   mappedConfig    =    new   CorsConfiguration (  )  ;", "mappedConfig . addAllowedOrigin (  \"  *  \"  )  ;", "this . h . setCorsConfigurations ( Collections . singletonMap (  \"  / welcome . html \"  ,    mappedConfig )  )  ;", "String   origin    =     \" http :  /  / domain 2  . com \"  ;", "ServerWebExchange   exchange    =    createExchange ( GET ,     \"  / welcome . html \"  ,    origin )  ;", "Object   actual    =    this . h . getHandler ( exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertSame ( this . welcomeController ,    actual )  ;", "assertEquals (  \"  *  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithGlobalCorsConfig"], "fileName": "org.springframework.web.reactive.handler.CorsUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   origin    =     \" http :  /  / domain 2  . com \"  ;", "ServerWebExchange   exchange    =    createExchange ( GET ,     \"  / welcome . html \"  ,    origin )  ;", "Object   actual    =    this . h . getHandler ( exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertSame ( this . welcomeController ,    actual )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithoutCorsConfigurationProvider"], "fileName": "org.springframework.web.reactive.handler.CorsUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( MockServerHttpRequest . method ( method ,     (  \" http :  /  / localhost \"     +    path )  )  . header (  \" Origin \"  ,    origin )  . header ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createExchange"], "fileName": "org.springframework.web.reactive.handler.CorsUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "CorsConfiguration   mappedConfig    =    new   CorsConfiguration (  )  ;", "mappedConfig . addAllowedOrigin (  \"  *  \"  )  ;", "this . h . setCorsConfigurations ( Collections . singletonMap (  \"  / welcome . html \"  ,    mappedConfig )  )  ;", "String   origin    =     \" http :  /  / domain 2  . com \"  ;", "ServerWebExchange   exchange    =    createExchange ( OPTIONS ,     \"  / welcome . html \"  ,    origin )  ;", "Object   actual    =    this . h . getHandler ( exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertNotSame ( this . welcomeController ,    actual )  ;", "assertEquals (  \"  *  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["preFlightRequestWithGlobalCorsConfig"], "fileName": "org.springframework.web.reactive.handler.CorsUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   origin    =     \" http :  /  / domain 2  . com \"  ;", "ServerWebExchange   exchange    =    createExchange ( OPTIONS ,     \"  / cors . html \"  ,    origin )  ;", "Object   actual    =    this . h . getHandler ( exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertNotSame ( this . corsController ,    actual )  ;", "assertEquals (  \"  *  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["preFlightWithCorsAwareHandler"], "fileName": "org.springframework.web.reactive.handler.CorsUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   origin    =     \" http :  /  / domain 2  . com \"  ;", "ServerWebExchange   exchange    =    createExchange ( OPTIONS ,     \"  / welcome . html \"  ,    origin )  ;", "Object   actual    =    this . h . getHandler ( exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertNotSame ( this . welcomeController ,    actual )  ;", "assertNull ( exchange . getResponse (  )  . getHeaders (  )  . getFirst ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithoutCorsConfigurationProvider"], "fileName": "org.springframework.web.reactive.handler.CorsUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "this . handlerMapping    =    new   AbstractUrlHandlerMapping (  )     {  }  ;", "this . handlerMapping . registerHandler (  \"  / welcome . html \"  ,    this . welcomeController )  ;", "this . handlerMapping . registerHandler (  \"  / cors . html \"  ,    this . corsController )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.handler.CorsUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "return   this . urlMap ;", "}", "METHOD_END"], "methodName": ["getUrlMap"], "fileName": "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "if    ( urlMap . isEmpty (  )  )     {", "logger . warn (  \" Neither    ' urlMap '    nor    ' mappings '    set   on    \"  )  ;", "} else    {", "for    ( Map . Entry < String ,    Object >    entry    :    urlMap . entrySet (  )  )     {", "String   url    =    entry . getKey (  )  ;", "Object   handler    =    entry . getValue (  )  ;", "if    (  !  ( url . startsWith (  \"  /  \"  )  )  )     {", "url    =     \"  /  \"     +    url ;", "}", "if    ( handler   instanceof   String )     {", "handler    =     (  ( String )     ( handler )  )  . trim (  )  ;", "}", "registerHandler ( url ,    handler )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerHandlers"], "fileName": "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "CollectionUtils . mergePropertiesIntoMap ( mappings ,    this . urlMap )  ;", "}", "METHOD_END"], "methodName": ["setMappings"], "fileName": "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "this . urlMap . putAll ( urlMap )  ;", "}", "METHOD_END"], "methodName": ["setUrlMap"], "fileName": "org.springframework.web.reactive.handler.SimpleUrlHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   wac    =    new   AnnotationConfigApplicationContext (  )  ;", "wac . register (  . WebConfig . class )  ;", "wac . refresh (  )  ;", "HandlerMapping   handlerMapping    =     (  ( HandlerMapping )     ( wac . getBean (  \" handlerMapping \"  )  )  )  ;", "Object   mainController    =    wac . getBean (  \" mainController \"  )  ;", "Object   otherController    =    wac . getBean (  \" otherController \"  )  ;", "testUrl (  \"  / welcome . html \"  ,    mainController ,    handlerMapping ,     \"  \"  )  ;", "testUrl (  \"  / welcome . x \"  ,    otherController ,    handlerMapping ,     \" welcome . x \"  )  ;", "testUrl (  \"  / welcome /  \"  ,    otherController ,    handlerMapping ,     \" welcome \"  )  ;", "testUrl (  \"  / show . html \"  ,    mainController ,    handlerMapping ,     \"  \"  )  ;", "testUrl (  \"  / bookseats . html \"  ,    mainController ,    handlerMapping ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["handlerMappingJavaConfig"], "fileName": "org.springframework.web.reactive.handler.SimpleUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   wac    =    new   ClassPathXmlApplicationContext (  \" map . xml \"  ,    getClass (  )  )  ;", "wac . refresh (  )  ;", "handlerMapping    =    wac . getBean (  \" mapping \"  ,     . class )  ;", "Object   mainController    =    wac . getBean (  \" mainController \"  )  ;", "testUrl (  \"  / pathmatchingTest . html \"  ,    mainController ,    handlerMapping ,     \" pathmatchingTest . html \"  )  ;", "testUrl (  \" welcome . html \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / pathmatchingAA . html \"  ,    mainController ,    handlerMapping ,     \" pathmatchingAA . html \"  )  ;", "testUrl (  \"  / pathmatchingA . html \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / administrator / pathmatching . html \"  ,    mainController ,    handlerMapping ,     \"  \"  )  ;", "testUrl (  \"  / administrator / test / pathmatching . html \"  ,    mainController ,    handlerMapping ,     \" test / pathmatching . html \"  )  ;", "testUrl (  \"  / administratort / pathmatching . html \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / administrator / another / bla . xml \"  ,    mainController ,    handlerMapping ,     \"  \"  )  ;", "testUrl (  \"  / administrator / another / bla . gif \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / administrator / test / testlastbit \"  ,    mainController ,    handlerMapping ,     \" test / testlastbit \"  )  ;", "testUrl (  \"  / administrator / test / testla \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / administrator / testing / longer / bla \"  ,    mainController ,    handlerMapping ,     \" bla \"  )  ;", "testUrl (  \"  / administrator / testing / longer 2  / notmatching / notmatching \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / shortpattern / testing / toolong \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / XXpathXXmatching . html \"  ,    mainController ,    handlerMapping ,     \" XXpathXXmatching . html \"  )  ;", "testUrl (  \"  / pathXXmatching . html \"  ,    mainController ,    handlerMapping ,     \" pathXXmatching . html \"  )  ;", "testUrl (  \"  / XpathXXmatching . html \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / XXpathmatching . html \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / show 1  2  . html \"  ,    mainController ,    handlerMapping ,     \" show 1  2  . html \"  )  ;", "testUrl (  \"  / show 1  2  3  . html \"  ,    mainController ,    handlerMapping ,     \"  \"  )  ;", "testUrl (  \"  / show 1  . html \"  ,    mainController ,    handlerMapping ,     \" show 1  . html \"  )  ;", "testUrl (  \"  / reallyGood - test - is - this . jpeg \"  ,    mainController ,    handlerMapping ,     \" reallyGood - test - is - this . jpeg \"  )  ;", "testUrl (  \"  / reallyGood - tst - is - this . jpeg \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / testing / test . jpeg \"  ,    mainController ,    handlerMapping ,     \" testing / test . jpeg \"  )  ;", "testUrl (  \"  / testing / test . jpg \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \"  / anotherTest \"  ,    mainController ,    handlerMapping ,     \" anotherTest \"  )  ;", "testUrl (  \"  / stillAnotherTest \"  ,    null ,    handlerMapping ,    null )  ;", "testUrl (  \" outofpattern * ye \"  ,    null ,    handlerMapping ,    null )  ;", "}", "METHOD_END"], "methodName": ["handlerMappingXmlConfig"], "fileName": "org.springframework.web.reactive.handler.SimpleUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . method ( GET ,    URI . create ( url )  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "Object   actual    =    handlerMapping . getHandler ( exchange )  . block (  )  ;", "if    ( bean    !  =    null )     {", "assertNotNull ( actual )  ;", "assertSame ( bean ,    actual )  ;", "PathContainer   path    =    exchange . getAttribute (  . PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE )  ;", "assertNotNull ( path )  ;", "assertEquals ( pathWithinMapping ,    path . value (  )  )  ;", "} else    {", "assertNull ( actual )  ;", "}", "}", "METHOD_END"], "methodName": ["testUrl"], "fileName": "org.springframework.web.reactive.handler.SimpleUrlHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   ex    =    new   WebFluxResponseStatusExceptionHandlerTests . CustomException (  )  ;", "this . handler . handle ( this . exchange ,    ex )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( I _ AM _ A _ TEAPOT ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleAnnotatedException"], "fileName": "org.springframework.web.reactive.handler.WebFluxResponseStatusExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   ex    =    new   Exception ( new   WebFluxResponseStatusExceptionHandlerTests . CustomException (  )  )  ;", "this . handler . handle ( this . exchange ,    ex )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( I _ AM _ A _ TEAPOT ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleNestedAnnotatedException"], "fileName": "org.springframework.web.reactive.handler.WebFluxResponseStatusExceptionHandlerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( info . isLink (  )  )  )     {", "return   Mono . just ( info . getLine (  )  )  ;", "}", "String   link    =    toAbsolutePath ( info . getLine (  )  ,    exchange )  ;", "return   resolveUrlPath ( link ,    exchange ,    resource ,    chain )  . doOnNext (  (    path )     -  >     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  (  \" Link   modified :     \"     +    path )     +     \"     ( original :     \"  )     +     ( info . getLine (  )  )  )     +     \"  )  \"  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["processLine"], "fileName": "org.springframework.web.reactive.resource.AppCacheManifestTransformer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( content . startsWith ( AppCacheManifestTransformer . MANIFEST _ HEADER )  )  )     {", "if    ( AppCacheManifestTransformer . logger . isTraceEnabled (  )  )     {", "AppCacheManifestTransformer . logger . trace (  (  \" Manifest   should   start   with    ' CACHE   MANIFEST '  ,    skip :     \"     +    resource )  )  ;", "}", "return   Mono . just ( resource )  ;", "}", "if    ( AppCacheManifestTransformer . logger . isTraceEnabled (  )  )     {", "AppCacheManifestTransformer . logger . trace (  (  \" Transforming   resource :     \"     +    resource )  )  ;", "}", "return   Flux . generate ( new   AppCacheManifestTransformer . LineInfoGenerator ( content )  )  . concatMap (  (    info )     -  >    processLine ( info ,    exchange ,    resource ,    chain )  )  . reduce ( new   ByteArrayOutputStream (  )  ,     (    out ,    line )     -  >     {", "writeToByteArrayOutputStream ( out ,     ( line    +     \"  \\ n \"  )  )  ;", "return   out ;", "}  )  . map (  (    out )     -  >     {", "String   hash    =    DigestUtils . md 5 DigestAsHex ( out . toByteArray (  )  )  ;", "writeToByteArrayOutputStream ( out ,     (  (  \"  \\ n \"     +     \"  #    Hash :     \"  )     +    hash )  )  ;", "if    ( AppCacheManifestTransformer . logger . isTraceEnabled (  )  )     {", "AppCacheManifestTransformer . logger . trace (  (  (  (  (  \" AppCache   file :     [  \"     +     ( resource . getFilename (  )  )  )     +     \"  ]    hash :     [  \"  )     +    hash )     +     \"  ]  \"  )  )  ;", "}", "return   new   TransformedResource ( resource ,    out . toByteArray (  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.springframework.web.reactive.resource.AppCacheManifestTransformer"}, {"methodBody": ["METHOD_START", "{", "try    {", "byte [  ]    bytes    =    toWrite . getBytes (  . DEFAULT _ CHARSET )  ;", "out . write ( bytes )  ;", "}    catch    ( IOException   ex )     {", "throw   Exceptions . propagate ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeToByteArrayOutputStream"], "fileName": "org.springframework.web.reactive.resource.AppCacheManifestTransformer"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / static / foobar . file \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "this . chain    =    mock ( ResourceChain . class )  ;", "Resource   resource    =    mock ( Resource . class )  ;", "given ( resource . getFilename (  )  )  . willReturn (  \" foobar . file \"  )  ;", "given ( this . chain . transform ( exchange ,    resource )  )  . willReturn ( Mono . just ( resource )  )  ;", "Resource   result    =    this . transformer . transform ( exchange ,    resource ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals ( resource ,    result )  ;", "}", "METHOD_END"], "methodName": ["noTransformIfExtensionNoMatch"], "fileName": "org.springframework.web.reactive.resource.AppCacheManifestTransformerTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathResource   allowedLocation    =    new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  ;", "ResourceWebHandler   resourceHandler    =    new   ResourceWebHandler (  )  ;", "ResourceUrlProvider   resourceUrlProvider    =    new   ResourceUrlProvider (  )  ;", "resourceUrlProvider . registerHandlers ( Collections . singletonMap (  \"  / static /  *  *  \"  ,    resourceHandler )  )  ;", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  ;", "versionResolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    new   ContentVersionStrategy (  )  )  )  ;", "PathResourceResolver   pathResolver    =    new   PathResourceResolver (  )  ;", "pathResolver . setAllowedLocations ( allowedLocation )  ;", "List < ResourceResolver >    resolvers    =    Arrays . asList ( versionResolver ,    pathResolver )  ;", "ResourceResolverChain   resolverChain    =    new   DefaultResourceResolverChain ( resolvers )  ;", "CssLinkResourceTransformer   cssLinkResourceTransformer    =    new   CssLinkResourceTransformer (  )  ;", "cssLinkResourceTransformer . setResourceUrlProvider ( resourceUrlProvider )  ;", "List < ResourceTransformer >    transformers    =    Collections . singletonList ( cssLinkResourceTransformer )  ;", "this . chain    =    new   DefaultResourceTransformerChain ( resolverChain ,    transformers )  ;", "this . transformer    =    new    (  )  ;", "this . transformer . setResourceUrlProvider ( resourceUrlProvider )  ;", "resourceHandler . setResourceResolvers ( resolvers )  ;", "resourceHandler . setResourceTransformers ( transformers )  ;", "resourceHandler . setLocations ( Collections . singletonList ( allowedLocation )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.AppCacheManifestTransformerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / static / error . appcache \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "this . chain    =    mock ( ResourceChain . class )  ;", "Resource   resource    =    new   ClassPathResource (  \" test / error . appcache \"  ,    getClass (  )  )  ;", "given ( this . chain . transform ( exchange ,    resource )  )  . willReturn ( Mono . just ( resource )  )  ;", "Resource   result    =    this . transformer . transform ( exchange ,    resource ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals ( resource ,    result )  ;", "}", "METHOD_END"], "methodName": ["syntaxErrorInManifest"], "fileName": "org.springframework.web.reactive.resource.AppCacheManifestTransformerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / static / test . appcache \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  ;", "versionResolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    new   ContentVersionStrategy (  )  )  )  ;", "PathResourceResolver   pathResolver    =    new   PathResourceResolver (  )  ;", "pathResolver . setAllowedLocations ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  ;", "List < ResourceResolver >    resolvers    =    Arrays . asList ( versionResolver ,    pathResolver )  ;", "ResourceResolverChain   resolverChain    =    new   DefaultResourceResolverChain ( resolvers )  ;", "List < Resource >    transformers    =    new   ArrayList <  >  (  )  ;", "transformers . add ( new   CssLinkResource (  )  )  ;", "this . chain    =    new   DefaultResourceChain ( resolverChain ,    transformers )  ;", "Resource   resource    =    new   ClassPathResource (  \" test / test . appcache \"  ,    getClass (  )  )  ;", "Resource   result    =    this . transformer . transform ( exchange ,    resource ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "byte [  ]    bytes    =    FileCopyUtils . copyToByteArray ( result . getInputStream (  )  )  ;", "String   content    =    new   String ( bytes ,     \" UTF -  8  \"  )  ;", "assertThat (  \" should   rewrite   resource   links \"  ,    content ,    Matchers . containsString (  \"  / static / foo - e 3  6 d 2 e 0  5  2  5  3 c 6 c 7  0  8  5 a 9  1  5  2  2 ce 4  3 a 0 b 4  . css \"  )  )  ;", "assertThat (  \" should   rewrite   resource   links \"  ,    content ,    Matchers . containsString (  \"  / static / bar -  1  1 e 1  6 cf 7  9 faee 7 ac 6  9  8 c 8  0  5 cf 2  8  2  4  8 d 2  . css \"  )  )  ;", "assertThat (  \" should   rewrite   resource   links \"  ,    content ,    Matchers . containsString (  \"  / static / js / bar - bd 5  0  8 c 6  2  2  3  5 b 8  3  2 d 9  6  0  2  9  8 ca 6 c 0 b 7  6  4  5  . js \"  )  )  ;", "assertThat (  \" should   not   rewrite   external   resources \"  ,    content ,    Matchers . containsString (  \"  /  / example . org / style . css \"  )  )  ;", "assertThat (  \" should   not   rewrite   external   resources \"  ,    content ,    Matchers . containsString (  \" http :  /  / example . org / image . png \"  )  )  ;", "assertThat (  \" should   generate   fingerprint \"  ,    content ,    Matchers . containsString (  \"  #    Hash :     8 eefc 9  0  4 df 3 bd 4  6  5  3  7 fa 7 bdbbc 5 ab 9 fb \"  )  )  ;", "}", "METHOD_END"], "methodName": ["transformManifest"], "fileName": "org.springframework.web.reactive.resource.AppCacheManifestTransformerTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   key    =    new   StringBuilder ( CachingResourceResolver . RESOLVED _ RESOURCE _ CACHE _ KEY _ PREFIX )  ;", "key . append ( requestPath )  ;", "if    ( exchange    !  =    null )     {", "String   encoding    =    exchange . getRequest (  )  . getHeaders (  )  . getFirst (  \" Accept - Encoding \"  )  ;", "if    (  ( encoding    !  =    null )     &  &     ( encoding . contains (  \" gzip \"  )  )  )     {", "key . append (  \"  + encoding = gzip \"  )  ;", "}", "}", "return   key . toString (  )  ;", "}", "METHOD_END"], "methodName": ["computeKey"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . cache ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolver"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" bar . css \"  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get ( file )  . header (  \" Accept - Encoding \"  ,     \" gzip \"  )  )  ;", "Resource   expected    =    this . chain . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "String   cacheKey    =     (  ( CachingResourceResolver . RESOLVED _ RESOURCE _ CACHE _ KEY _ PREFIX )     +    file )     +     \"  + encoding = gzip \"  ;", "assertEquals ( expected ,    this . cache . get ( cacheKey )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceAcceptEncodingInCacheKey"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" bar . css \"  ;", "Resource   expected    =    new   ClassPathResource (  (  \" test /  \"     +    file )  ,    getClass (  )  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "Resource   actual    =    this . chain . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceInternal"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource   expected    =    Mockito . mock ( Resource . class )  ;", "this . cache . put (  (  ( CachingResourceResolver . RESOLVED _ RESOURCE _ CACHE _ KEY _ PREFIX )     +     \" bar . css \"  )  ,    expected )  ;", "String   file    =     \" bar . css \"  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "Resource   actual    =    this . chain . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "assertSame ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceInternalFromCache"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "assertNull ( this . chain . resolveResource ( exchange ,     \" invalid . css \"  ,    this . locations )  . block (  . TIMEOUT )  )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceInternalNoMatch"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    Mockito . mock ( Resource . class )  ;", "Resource   gzResource    =    Mockito . mock ( Resource . class )  ;", "this . cache . put (  (  ( CachingResourceResolver . RESOLVED _ RESOURCE _ CACHE _ KEY _ PREFIX )     +     \" bar . css \"  )  ,    resource )  ;", "this . cache . put (  (  ( CachingResourceResolver . RESOLVED _ RESOURCE _ CACHE _ KEY _ PREFIX )     +     \" bar . css + encoding = gzip \"  )  ,    gzResource )  ;", "String   file    =     \" bar . css \"  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get ( file )  )  ;", "assertSame ( resource ,    this . chain . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  )  ;", "exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get ( file )  . header (  \" Accept - Encoding \"  ,     \" gzip \"  )  )  ;", "assertSame ( gzResource ,    this . chain . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceMatchingEncoding"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" bar . css \"  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get ( file )  )  ;", "Resource   expected    =    this . chain . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "String   cacheKey    =     ( CachingResourceResolver . RESOLVED _ RESOURCE _ CACHE _ KEY _ PREFIX )     +    file ;", "assertEquals ( expected ,    this . cache . get ( cacheKey )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceNoAcceptEncodingInCacheKey"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  / foo . css \"  ;", "String   actual    =    this . chain . resolveUrlPath ( expected ,    this . locations )  . block (  . TIMEOUT )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolverUrlPath"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" cached - imaginary . css \"  ;", "this . cache . put (  (  ( CachingResourceResolver . RESOLVED _ URL _ PATH _ CACHE _ KEY _ PREFIX )     +     \" imaginary . css \"  )  ,    expected )  ;", "String   actual    =    this . chain . resolveUrlPath (  \" imaginary . css \"  ,    this . locations )  . block (  . TIMEOUT )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolverUrlPathFromCache"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( this . chain . resolveUrlPath (  \" invalid . css \"  ,    this . locations )  . block ( CachingResourceResolverTests . TIMEOUT )  )  ;", "}", "METHOD_END"], "methodName": ["resolverUrlPathNoMatch"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . cache    =    new   ConcurrentMapCache (  \" resourceCache \"  )  ;", "List < ResourceResolver >    resolvers    =    new   ArrayList <  >  (  )  ;", "resolvers . add ( new    ( this . cache )  )  ;", "resolvers . add ( new   PathResourceResolver (  )  )  ;", "this . chain    =    new   DefaultResourceResolverChain ( resolvers )  ;", "this . locations    =    new   ArrayList (  )  ;", "this . locations . add ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.CachingResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . cache ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.springframework.web.reactive.resource.CachingResourceTransformer"}, {"methodBody": ["METHOD_START", "{", "String   requestPath    =     \" test / bar . css \"  ;", "String   version    =     \"  1  2  3  \"  ;", "assertEquals (  \" test / bar -  1  2  3  . css \"  ,    this . strategy . ad ( requestPath ,    version )  )  ;", "}", "METHOD_END"], "methodName": ["addVersionToUrl"], "fileName": "org.springframework.web.reactive.resource.ContentBasedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "String   hash    =     \"  7 fbe 7  6 cdac 6  0  9  3  7  8  4  8  9  5 bb 4  9  8  9  2  0  3 e 5 a \"  ;", "String   path    =     (  \" font - awesome / css / font - awesome . min -  \"     +    hash )     +     \"  . css \"  ;", "assertEquals ( hash ,    this . s . extractVersion ( path )  )  ;", "assertNull ( this . s . extractVersion (  \" foo / bar . css \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extractVersion"], "fileName": "org.springframework.web.reactive.resource.ContentBasedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "Resource   expected    =    new   ClassPathResource (  \" test / bar . css \"  ,    getClass (  )  )  ;", "String   hash    =    DigestUtils . md 5 DigestAsHex ( FileCopyUtils . copyToByteArray ( expected . getInputStream (  )  )  )  ;", "assertEquals ( hash ,    this . strategy . getResourceVersion ( expected )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceVersion"], "fileName": "org.springframework.web.reactive.resource.ContentBasedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" font - awesome / css / font - awesome . min % s % s . css \"  ;", "String   hash    =     \"  7 fbe 7  6 cdac 6  0  9  3  7  8  4  8  9  5 bb 4  9  8  9  2  0  3 e 5 a \"  ;", "assertEquals ( String . format ( file ,     \"  \"  ,     \"  \"  )  ,    this . strategy . remove ( String . format ( file ,     \"  -  \"  ,    hash )  ,    hash )  )  ;", "assertNull ( this . strategy . extract (  \" foo / bar . css \"  )  )  ;", "}", "METHOD_END"], "methodName": ["removeVersion"], "fileName": "org.springframework.web.reactive.resource.ContentBasedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "VersionResourceResolver   versionResourceResolver    =    new   VersionResourceResolver (  )  ;", "versionResourceResolver . setMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    this . strategy )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.ContentBasedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "int   schemeIndex    =    link . indexOf (  '  :  '  )  ;", "return    (  ( schemeIndex    >     0  )     &  &     (  !  ( link . subst (  0  ,    schemeIndex )  . contains (  \"  /  \"  )  )  )  )     |  |     (  ( link . indexOf (  \"  /  /  \"  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["hasScheme"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformer"}, {"methodBody": ["METHOD_START", "{", "SortedSet < CssLinkResourceTransformer . ContentChunkInfo >    links    =    new   TreeSet <  >  (  )  ;", "this . linkParsers . forEach (  (    parser )     -  >    parser . parse ( cssContent ,    links )  )  ;", "if    ( links . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "}", "int   index    =     0  ;", "List < CssLinkResourceTransformer . ContentChunkInfo >    result    =    new   ArrayList <  >  (  )  ;", "for    ( CssLinkResourceTransformer . ContentChunkInfo   link    :    links )     {", "result . add ( new   CssLinkResourceTransformer . ContentChunkInfo ( index ,    link . getStart (  )  ,    false )  )  ;", "result . add ( link )  ;", "index    =    link . getEnd (  )  ;", "}", "if    ( index    <     ( cssContent . length (  )  )  )     {", "result . add ( new   CssLinkResourceTransformer . ContentChunkInfo ( index ,    cssContent . length (  )  ,    false )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseContent"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformer"}, {"methodBody": ["METHOD_START", "{", "List < CssLinkResourceTransformer . ContentChunkInfo >    contentChunkInfos    =    parseContent ( cssContent )  ;", "if    ( contentChunkInfos . isEmpty (  )  )     {", "if    ( CssLinkResourceTransformer . logger . isTraceEnabled (  )  )     {", "CssLinkResourceTransformer . logger . trace (  \" No   links   found .  \"  )  ;", "}", "return   Mono . just ( resource )  ;", "}", "return   Flux . fromIterable ( contentChunkInfos )  . concatMap (  (    contentChunkInfo )     -  >     {", "String   contentChunk    =    contentChunkInfo . getContent ( cssContent )  ;", "if    (  ( contentChunkInfo . isLink (  )  )     &  &     (  !  ( hasScheme ( contentChunk )  )  )  )     {", "String   link    =    toAbsolutePath ( contentChunk ,    exchange )  ;", "return   resolveUrlPath ( link ,    exchange ,    resource ,    chain )  . defaultIfEmpty ( contentChunk )  ;", "} else    {", "return   Mono . just ( contentChunk )  ;", "}", "}  )  . reduce ( new   StringWriter (  )  ,     (    writer ,    chunk )     -  >     {", "writer . write ( chunk )  ;", "return   writer ;", "}  )  . map (  (    writer )     -  >     {", "byte [  ]    newContent    =    writer . toString (  )  . getBytes ( CssLinkResourceTransformer . DEFAULT _ CHARSET )  ;", "return   new   TransformedResource ( resource ,    newContent )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["transformContent"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformer"}, {"methodBody": ["METHOD_START", "{", "Resource   location    =    new   ClassPathResource (  \" test /  \"  ,    CssLinkResourceTransformerTests . class )  ;", "Path   original    =    Paths . get ( location . getFile (  )  . getAbsolutePath (  )  ,    filePath )  ;", "Path   copy    =    Paths . get ( location . getFile (  )  . getAbsolutePath (  )  ,    copyFilePath )  ;", "Files . deleteIfExists ( copy )  ;", "Files . copy ( original ,    copy )  ;", "copy . toFile (  )  . deleteOnExit (  )  ;", "}", "METHOD_END"], "methodName": ["createTempCopy"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformerTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathResource   allowedLocation    =    new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  ;", "ResourceWebHandler   resourceHandler    =    new   ResourceWebHandler (  )  ;", "ResourceUrlProvider   resourceUrlProvider    =    new   ResourceUrlProvider (  )  ;", "resourceUrlProvider . registerHandlers ( Collections . singletonMap (  \"  / static /  *  *  \"  ,    resourceHandler )  )  ;", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  ;", "versionResolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    new   ContentVersionStrategy (  )  )  )  ;", "PathResourceResolver   pathResolver    =    new   PathResourceResolver (  )  ;", "pathResolver . setAllowedLocations ( allowedLocation )  ;", "List < ResourceResolver >    resolvers    =    Arrays . asList ( versionResolver ,    pathResolver )  ;", "cssLinkResourceTransformer    =    new    (  )  ;", "cssLinkResourceTransformer . setResourceUrlProvider ( resourceUrlProvider )  ;", "List < ResourceTransformer >    transformers    =    Collections . singletonList ( cssLinkResourceTransformer )  ;", "resourceHandler . setResourceResolvers ( resolvers )  ;", "resourceHandler . setResourceTransformers ( transformers )  ;", "resourceHandler . setLocations ( Collections . singletonList ( allowedLocation )  )  ;", "ResourceResolverChain   resolverChain    =    new   DefaultResourceResolverChain ( resolvers )  ;", "this . transformerChain    =    new   DefaultResourceTransformerChain ( resolverChain ,    transformers )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / static / main . css \"  )  )  ;", "Resource   css    =    new   ClassPathResource (  \" test / main . css \"  ,    getClass (  )  )  ;", "String   expected    =     \"  \\ n \"     +     (  (  (  (  (  \"  @ import   url (  \\  \"  / static / bar -  1  1 e 1  6 cf 7  9 faee 7 ac 6  9  8 c 8  0  5 cf 2  8  2  4  8 d 2  . css ?  # iefix \\  \"  )  ;  \\ n \"     +     \"  @ import   url (  \\  '  / static / bar -  1  1 e 1  6 cf 7  9 faee 7 ac 6  9  8 c 8  0  5 cf 2  8  2  4  8 d 2  . css # bla - normal \\  '  )  ;  \\ n \"  )     +     \"  @ import   url (  / static / bar -  1  1 e 1  6 cf 7  9 faee 7 ac 6  9  8 c 8  0  5 cf 2  8  2  4  8 d 2  . css )  ;  \\ n \\ n \"  )     +     \"  @ import    \\  \"  / static / foo - e 3  6 d 2 e 0  5  2  5  3 c 6 c 7  0  8  5 a 9  1  5  2  2 ce 4  3 a 0 b 4  . css \\  \"  ;  \\ n \"  )     +     \"  @ import    \\  '  / static / foo - e 3  6 d 2 e 0  5  2  5  3 c 6 c 7  0  8  5 a 9  1  5  2  2 ce 4  3 a 0 b 4  . css \\  '  ;  \\ n \\ n \"  )     +     \" body    {    background :    url (  \\  \"  / static / images / image - f 4  4  8 cd 1 d 5 dba 8  2 b 7  7  4 f 3  2  0  2 c 8  7  8  2  3  0 b 3  . png ?  # iefix \\  \"  )     }  \\ n \"  )  ;", "StepVerifier . create ( this . transformerChain . transform ( exchange ,    css )  . cast ( dResource . class )  )  . consumeNextWith (  (    resource )     -  >     {", "String   result    =    new   String ( resource . getByteArray (  )  ,    StandardCharsets . UTF _  8  )  ;", "result    =    StringUtils . deleteAny ( result ,     \"  \\ r \"  )  ;", "assertEquals ( expected ,    result )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / static / external . css \"  )  )  ;", "ResourceResolverChain   resolverChain    =    Mockito . mock ( DefaultResourceResolverChain . class )  ;", "ResourceTransformerChain   transformerChain    =    new   DefaultResourceTransformerChain ( resolverChain ,    Collections . singletonList ( new    (  )  )  )  ;", "Resource   externalCss    =    new   ClassPathResource (  \" test / external . css \"  ,    getClass (  )  )  ;", "StepVerifier . create ( transformerChain . transform ( exchange ,    externalCss )  . cast ( TransformedResource . class )  )  . consumeNextWith (  (    resource )     -  >     {", "String   expected    =     \"  @ import   url (  \\  \" http :  /  / example . org / fonts / css \\  \"  )  ;  \\ n \"     +     (  \" body    {    background :    url (  \\  \" file :  /  /  / home / spring / image . png \\  \"  )     }  \\ n \"     +     \" figure    {    background :    url (  \\  \"  /  / example . org / style . css \\  \"  )  }  \"  )  ;", "String   result    =    new   String ( resource . getByteArray (  )  ,    StandardCharsets . UTF _  8  )  ;", "result    =    StringUtils . deleteAny ( result ,     \"  \\ r \"  )  ;", "assertEquals ( expected ,    result )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "Mockito . verify ( resolverChain ,    Mockito . never (  )  )  . resolveUrlPath (  \" http :  /  / example . org / fonts / css \"  ,    Collections . singletonList ( externalCss )  )  ;", "Mockito . verify ( resolverChain ,    Mockito . never (  )  )  . resolveUrlPath (  \" file :  /  /  / home / spring / image . png \"  ,    Collections . singletonList ( externalCss )  )  ;", "Mockito . verify ( resolverChain ,    Mockito . never (  )  )  . resolveUrlPath (  \"  /  / example . org / style . css \"  ,    Collections . singletonList ( externalCss )  )  ;", "}", "METHOD_END"], "methodName": ["transformExtLinksNotAllowed"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / static / foo . css \"  )  )  ;", "Resource   expected    =    new   ClassPathResource (  \" test / foo . css \"  ,    getClass (  )  )  ;", "StepVerifier . create ( this . tChain . transform ( exchange ,    expected )  )  . consumeNextWith (  (    resource )     -  >    assertSame ( expected ,    resource )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["transformNoLinks"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / static / main . css \"  )  )  ;", "Resource   original    =    new   ClassPathResource (  \" test / main . css \"  ,    getClass (  )  )  ;", "createTempCopy (  \" main . css \"  ,     \" main . css . gz \"  )  ;", "GzipResourceResolver . GzippedResource   expected    =    new   GzipResourceResolver . GzippedResource ( original )  ;", "StepVerifier . create ( this . tChain . transform ( exchange ,    expected )  )  . expectNext ( expected )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["transformWithGzippedResource"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / static / images / image . png \"  )  )  ;", "Resource   expected    =    new   ClassPathResource (  \" test / images / image . png \"  ,    getClass (  )  )  ;", "StepVerifier . create ( this . tChain . transform ( exchange ,    expected )  )  . expectNext ( expected )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["transformWithNonCssResource"], "fileName": "org.springframework.web.reactive.resource.CssLinkResourceTransformerTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . index )     <  =     ( this . resolvers . size (  )  )  )  ,     \" Current   index   exceeds   the   number   of   configured   ResourceResolvers \"  )  ;", "if    (  ( this . index )     =  =     (  ( this . resolvers . size (  )  )     -     1  )  )     {", "return   null ;", "}", "( this . index )  +  +  ;", "return   this . resolvers . get ( this . index )  ;", "}", "METHOD_END"], "methodName": ["getNext"], "fileName": "org.springframework.web.reactive.resource.DefaultResourceResolverChain"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . index )     <  =     ( this . transformers . size (  )  )  )  ,     \" Current   index   exceeds   the   number   of   configured   ResourceTransformer ' s \"  )  ;", "if    (  ( this . index )     =  =     (  ( this . transformers . size (  )  )     -     1  )  )     {", "return   null ;", "}", "( this . index )  +  +  ;", "return   this . transformers . get ( this . index )  ;", "}", "METHOD_END"], "methodName": ["getNext"], "fileName": "org.springframework.web.reactive.resource.DefaultResourceTransformerChain"}, {"methodBody": ["METHOD_START", "{", "return   this . resolverChain ;", "}", "METHOD_END"], "methodName": ["getResolverChain"], "fileName": "org.springframework.web.reactive.resource.DefaultResourceTransformerChain"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  (  ( this . version )     +     \"  /  \"  )     +     ( this . path )  )  ,    this . strategy . addVersion (  (  \"  /  \"     +     ( this . path )  )  ,    this . version )  )  ;", "}", "METHOD_END"], "methodName": ["addVersion"], "fileName": "org.springframework.web.reactive.resource.FixedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "String   relativePath    =     \"  .  .  /  \"     +     ( this . path )  ;", "assertEquals ( relativePath ,    this . strategy . ad ( relativePath ,    this . version )  )  ;", "}", "METHOD_END"], "methodName": ["addVersionRelativePath"], "fileName": "org.springframework.web.reactive.resource.FixedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "new   FixedVersionStrategy (  \"        \"  )  ;", "}", "METHOD_END"], "methodName": ["emptyPrefixVersion"], "fileName": "org.springframework.web.reactive.resource.FixedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( this . version ,    this . strategy . extractVersion (  (  (  ( this . version )     +     \"  /  \"  )     +     ( this . path )  )  )  )  ;", "assertNull ( this . strategy . extractVersion ( this . path )  )  ;", "}", "METHOD_END"], "methodName": ["extractVersion"], "fileName": "org.springframework.web.reactive.resource.FixedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  \"  /  \"     +     ( this . path )  )  ,    this . strategy . removeVersion (  (  (  ( this . version )     +     \"  /  \"  )     +     ( this . path )  )  ,    this . version )  )  ;", "}", "METHOD_END"], "methodName": ["removeVersion"], "fileName": "org.springframework.web.reactive.resource.FixedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "this . strategy    =    new   FixedVersionStrategy ( this . version )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.FixedVersionStrategyTests"}, {"methodBody": ["METHOD_START", "{", "String   value    =    exchange . getRequest (  )  . getHeaders (  )  . getFirst (  \" Accept - Encoding \"  )  ;", "return    ( value    !  =    null )     &  &     ( value . toLowerCase (  )  . contains (  \" gzip \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isGzipAccepted"], "fileName": "org.springframework.web.reactive.resource.GzipResourceResolver"}, {"methodBody": ["METHOD_START", "{", "Resource   location    =    new   ClassPathResource (  \" test /  \"  ,    GzipResourceResolverTests . class )  ;", "Resource   fileResource    =    new   FileSystemResource ( location . createRelative ( filePath )  . getFile (  )  )  ;", "Path   gzFilePath    =    Paths . get (  (  ( fileResource . getFile (  )  . getAbsolutePath (  )  )     +     \"  . gz \"  )  )  ;", "Files . deleteIfExists ( gzFilePath )  ;", "File   gzFile    =    Files . createFile ( gzFilePath )  . toFile (  )  ;", "GZIPOutputStream   out    =    new   GZIPOutputStream ( new   FileOutputStream ( gzFile )  )  ;", "FileCopyUtils . copy ( fileResource . getInputStream (  )  ,    out )  ;", "gzFile . deleteOnExit (  )  ;", "}", "METHOD_END"], "methodName": ["createGzFile"], "fileName": "org.springframework.web.reactive.resource.GzipResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "GzipResourceResolverTests . createGzFile (  \"  / js / foo . js \"  )  ;", "GzipResourceResolverTests . createGzFile (  \" foo - e 3  6 d 2 e 0  5  2  5  3 c 6 c 7  0  8  5 a 9  1  5  2  2 ce 4  3 a 0 b 4  . css \"  )  ;", "}", "METHOD_END"], "methodName": ["createGzippedResources"], "fileName": "org.springframework.web.reactive.resource.GzipResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  . header (  \" Accept - Encoding \"  ,     \" gzip \"  )  )  ;", "String   file    =     \" foo - e 3  6 d 2 e 0  5  2  5  3 c 6 c 7  0  8  5 a 9  1  5  2  2 ce 4  3 a 0 b 4  . css \"  ;", "Resource   resolved    =    this . resolver . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "String   gzFile    =    file    +     \"  . gz \"  ;", "Resource   resource    =    new   ClassPathResource (  (  \" test /  \"     +    gzFile )  ,    getClass (  )  )  ;", "assertEquals ( resource . getDescription (  )  ,    resolved . getDescription (  )  )  ;", "assertEquals ( new   ClassPathResource (  (  \" test /  \"     +    file )  )  . getFilename (  )  ,    resolved . getFilename (  )  )  ;", "assertTrue (  (  (  (  \" Expected    \"     +    resolved )     +     \"    to   be   of   type    \"  )     +     ( HttpResource . class )  )  ,     ( resolved   instanceof   HttpResource )  )  ;", "}", "METHOD_END"], "methodName": ["resolveFingerprintedGzippedFile"], "fileName": "org.springframework.web.reactive.resource.GzipResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  . header (  \" Accept - Encoding \"  ,     \" gzip \"  )  )  ;", "String   file    =     \" js / foo . js \"  ;", "Resource   resolved    =    this . resolver . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "String   gzFile    =    file    +     \"  . gz \"  ;", "Resource   gzResource    =    new   ClassPathResource (  (  \" test /  \"     +    gzFile )  ,    getClass (  )  )  ;", "assertEquals ( gzResource . getDescription (  )  ,    resolved . getDescription (  )  )  ;", "assertEquals ( new   ClassPathResource (  (  \" test /  \"     +    file )  )  . getFilename (  )  ,    resolved . getFilename (  )  )  ;", "assertTrue (  (  (  (  \" Expected    \"     +    resolved )     +     \"    to   be   of   type    \"  )     +     ( HttpResource . class )  )  ,     ( resolved   instanceof   HttpResource )  )  ;", "exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / js / foo . js \"  )  )  ;", "resolved    =    this . resolver . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "Resource   resource    =    new   ClassPathResource (  (  \" test /  \"     +    file )  ,    getClass (  )  )  ;", "assertEquals ( resource . getDescription (  )  ,    resolved . getDescription (  )  )  ;", "assertEquals ( new   ClassPathResource (  (  \" test /  \"     +    file )  )  . getFilename (  )  ,    resolved . getFilename (  )  )  ;", "assertFalse (  (  (  (  \" Expected    \"     +    resolved )     +     \"    to    * not *    be   of   type    \"  )     +     ( HttpResource . class )  )  ,     ( resolved   instanceof   HttpResource )  )  ;", "}", "METHOD_END"], "methodName": ["resolveFromCacheWithEncodingVariants"], "fileName": "org.springframework.web.reactive.resource.GzipResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  . header (  \" Accept - Encoding \"  ,     \" gzip \"  )  )  ;", "String   file    =     \" js / foo . js \"  ;", "Resource   resolved    =    this . resolver . resolveResource ( exchange ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "String   gzFile    =    file    +     \"  . gz \"  ;", "Resource   resource    =    new   ClassPathResource (  (  \" test /  \"     +    gzFile )  ,    getClass (  )  )  ;", "assertEquals ( resource . getDescription (  )  ,    resolved . getDescription (  )  )  ;", "assertEquals ( new   ClassPathResource (  (  \" test /  \"     +    file )  )  . getFilename (  )  ,    resolved . getFilename (  )  )  ;", "assertTrue (  (  (  (  \" Expected    \"     +    resolved )     +     \"    to   be   of   type    \"  )     +     ( HttpResource . class )  )  ,     ( resolved   instanceof   HttpResource )  )  ;", "}", "METHOD_END"], "methodName": ["resolveGzippedFile"], "fileName": "org.springframework.web.reactive.resource.GzipResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" js / foo . js \"  ;", "Resource   resolved    =    this . resolver . resolveResource ( null ,    file ,    this . locations )  . block (  . TIMEOUT )  ;", "String   gzFile    =    file    +     \"  . gz \"  ;", "Resource   gzResource    =    new   ClassPathResource (  (  \" test /  \"     +    gzFile )  ,    getClass (  )  )  ;", "assertEquals ( gzResource . getDescription (  )  ,    resolved . getDescription (  )  )  ;", "assertEquals ( new   ClassPathResource (  (  \" test /  \"     +    file )  )  . getFilename (  )  ,    resolved . getFilename (  )  )  ;", "assertTrue (  (  (  (  \" Expected    \"     +    resolved )     +     \"    to   be   of   type    \"  )     +     ( HttpResource . class )  )  ,     ( resolved   instanceof   HttpResource )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithNullRequest"], "fileName": "org.springframework.web.reactive.resource.GzipResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    new   ConcurrentMapCache (  \" resourceCache \"  )  ;", "Map < String ,    VersionStrategy >    versionStrategyMap    =    new   HashMap <  >  (  )  ;", "versionStrategyMap . put (  \"  /  *  *  \"  ,    new   ContentVersionStrategy (  )  )  ;", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  ;", "versionResolver . setStrategyMap ( versionStrategyMap )  ;", "List < ResourceResolver >    resolvers    =    new   ArrayList <  >  (  )  ;", "resolvers . add ( new   CachingResourceResolver ( cache )  )  ;", "resolvers . add ( new    (  )  )  ;", "resolvers . add ( versionResolver )  ;", "resolvers . add ( new   PathResourceResolver (  )  )  ;", "this . resolver    =    new   DefaultResourceResolverChain ( resolvers )  ;", "this . locations    =    new   ArrayList (  )  ;", "this . locations . add ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  ;", "this . locations . add ( new   ClassPathResource (  \" testalternatepath /  \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.GzipResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "if    ( isResourceUnderLocation ( resource ,    location )  )     {", "return   true ;", "}", "if    (  ( getAllowedLocations (  )  )     !  =    null )     {", "for    ( Resource   current    :    getAllowedLocations (  )  )     {", "if    ( isResourceUnderLocation ( resource ,    current )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkResource"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . allowedLocations ;", "}", "METHOD_END"], "methodName": ["getAllowedLocations"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolver"}, {"methodBody": ["METHOD_START", "{", "return   Flux . fromIterable ( locations )  . concatMap (  (    location )     -  >    getResource ( resourcePath ,    location )  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolver"}, {"methodBody": ["METHOD_START", "{", "try    {", "Resource    =    location . createRelative ( ath )  ;", "if    (  ( exists (  )  )     &  &     ( isReadable (  )  )  )     {", "if    ( checkResource (    location )  )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Found   match :     \"     +     )  ;", "}", "return   Mono . just (  ;", "} else", "if    ( logger . isTraceEnabled (  )  )     {", "Resource [  ]    allowedLocations    =    getAllowedLocations (  )  ;", "logger . trace (  (  (  (  (  (  (  (  (  (  (  \" Resource   path    \\  \"  \"     +    ath )     +     \"  \\  \"    was   successfully   resolved    \"  )     +     \" but    \\  \"  \"  )     +     ( getURL (  )  )  )     +     \"  \\  \"    is   neither   under   the    \"  )     +     \" current   location    \\  \"  \"  )     +     ( location . getURL (  )  )  )     +     \"  \\  \"    nor   under   any   of   the    \"  )     +     \" allowed   locations    \"  )     +     ( allowedLocations    !  =    null    ?    asList ( allowedLocations )     :     \"  [  ]  \"  )  )  )  ;", "}", "} else", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" No   match   for   location :     \"     +    location )  )  ;", "}", "return   Mono . empty (  )  ;", "}    catch    ( IOException   ex )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Failure   checking   for   relative   under   location    +     \"     +    location )  ,    ex )  ;", "}", "return   Mono . error ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( resourcePath . contains (  \"  %  \"  )  )     {", "try    {", "String   decodedPath    =    URLDecoder . decode ( resourcePath ,     \" UTF -  8  \"  )  ;", "if    (  ( decodedPath . contains (  \"  .  .  /  \"  )  )     |  |     ( decodedPath . contains (  \"  .  .  \\  \\  \"  )  )  )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Resolved   resource   path   contains   encoded    \\  \"  .  .  /  \\  \"    or    \\  \"  .  .  \\  \\  \\  \"  :     \"     +    resourcePath )  )  ;", "}", "return   true ;", "}", "}    catch    ( UnsupportedEncodingException   ex )     {", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isInvalidEncodedPath"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resource . getClass (  )  )     !  =     ( location . getClass (  )  )  )     {", "return   false ;", "}", "String   resourcePath ;", "String   locationPath ;", "if    ( resource   instanceof   UrlResource )     {", "resourcePath    =    resource . getURL (  )  . toExternalForm (  )  ;", "locationPath    =    StringUtils . cleanPath ( location . getURL (  )  . toString (  )  )  ;", "} else", "if    ( resource   instanceof   core . io . ClassPathResource )     {", "resourcePath    =     (  ( core . io . ClassPathResource )     ( resource )  )  . getPath (  )  ;", "locationPath    =    StringUtils . cleanPath (  (  ( core . io . ClassPathResource )     ( location )  )  . getPath (  )  )  ;", "} else    {", "resourcePath    =    resource . getURL (  )  . getPath (  )  ;", "locationPath    =    StringUtils . cleanPath ( location . getURL (  )  . getPath (  )  )  ;", "}", "if    ( locationPath . equals ( resourcePath )  )     {", "return   true ;", "}", "locationPath    =     (  ( locationPath . endsWith (  \"  /  \"  )  )     |  |     ( locationPath . isEmpty (  )  )  )     ?    locationPath    :    locationPath    +     \"  /  \"  ;", "return    ( resourcePath . startsWith ( locationPath )  )     &  &     (  !  ( isInvalidEncodedPath ( resourcePath )  )  )  ;", "}", "METHOD_END"], "methodName": ["isResourceUnderLocation"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolver"}, {"methodBody": ["METHOD_START", "{", "this . allowedLocations    =    locations ;", "}", "METHOD_END"], "methodName": ["setAllowedLocations"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolver"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" test / main . css \"  ,    PathResourceResolver . class )  ;", "assertTrue ( this . resolver . checkResource ( resource ,    resource )  )  ;", "}", "METHOD_END"], "methodName": ["checkFileLocation"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   locationUrl    =    new   UrlResource ( getClass (  )  . getResource (  \"  .  / test /  \"  )  )  . getURL (  )  . toExternalForm (  )  ;", "Resource   location    =    new   UrlResource ( locationUrl . replace (  \"  /  \"  ,     \"  /  .  .  / org /  \"  )  )  ;", "List < Resource >    locations    =    Collections . singletonList ( location )  ;", "assertNotNull ( this . resolver . resolveResource ( null ,     \" main . css \"  ,    locations ,    null )  . block ( Duration . ofMillis (  5  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkRelativeLocation"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource   location    =    new   ClassPathResource (  \" test /  \"  ,    PathResourceResolver . class )  ;", "testCheckResource ( location ,     \"  .  .  / testsecret / secret . txt \"  )  ;", "testCheckResource ( location ,     \" test /  .  .  /  .  .  / testsecret / secret . txt \"  )  ;", "location    =    new   UrlResource ( getClass (  )  . getResource (  \"  .  / test /  \"  )  )  ;", "String   secretPath    =    new   UrlResource ( getClass (  )  . getResource (  \" testsecret / secret . txt \"  )  )  . getURL (  )  . getPath (  )  ;", "testCheckResource ( location ,     (  \" file :  \"     +    secretPath )  )  ;", "testCheckResource ( location ,     (  \"  / file :  \"     +    secretPath )  )  ;", "testCheckResource ( location ,     (  \"  /  \"     +    secretPath )  )  ;", "testCheckResource ( location ,     (  \"  /  /  /  /  .  .  /  .  .  \"     +    secretPath )  )  ;", "testCheckResource ( location ,     \"  /  %  2 E %  2 E / testsecret / secret . txt \"  )  ;", "testCheckResource ( location ,     \"  /  %  2 e %  2 e / testsecret / secret . txt \"  )  ;", "testCheckResource ( location ,     (  \"     \"     +    secretPath )  )  ;", "testCheckResource ( location ,     (  \"  /        \"     +    secretPath )  )  ;", "testCheckResource ( location ,     (  \" url :  \"     +    secretPath )  )  ;", "}", "METHOD_END"], "methodName": ["checkResource"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setAllowedLocations ( new   ClassPathResource (  \" test /  \"  ,    PathResourceResolver . class )  ,    new   ClassPathResource (  \" testalternatepath /  \"  ,    PathResourceResolver . class )  )  ;", "Resource   location    =    new   ClassPathResource (  \" test / main . css \"  ,    PathResourceResolver . class )  ;", "String   actual    =    this . resolver . resolveUrlPath (  \"  .  .  / testalternatepath / bar . css \"  ,    Collections . singletonList ( location )  ,    null )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \"  .  .  / testalternatepath / bar . css \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["checkResourceWithAllowedLocations"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource   location    =    new   ClassPathResource (  \" test /  \"  ,    PathResourceResolver . class )  ;", "String   path    =     \" bar . css \"  ;", "List < Resource >    locations    =    Collections . singletonList ( location )  ;", "Resource   actual    =    this . resolver . resolveResource ( null ,    path ,    locations ,    null )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals ( location . createRelative ( path )  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveFromClasspath"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource   location    =    new   ClassPathResource (  \"  /  \"  )  ;", "String   path    =     \" org /  / web / reactive / resource / test / bar . css \"  ;", "List < Resource >    locations    =    Collections . singletonList ( location )  ;", "Resource   actual    =    this . resolver . resolveResource ( null ,    path ,    locations ,    null )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertNotNull ( actual )  ;", "}", "METHOD_END"], "methodName": ["resolveFromClasspathRoot"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource   webjarsLocation    =    new   ClassPathResource (  \"  / META - INF / resources / webjars /  \"  ,    PathResourceResolver . class )  ;", "String   path    =    this . resolver . resolveUrlPathInternal (  \"  \"  ,    Collections . singletonList ( webjarsLocation )  ,    null )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertNull ( path )  ;", "}", "METHOD_END"], "methodName": ["resolvePathRootResource"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < Resource >    locations    =    Collections . singletonList ( location )  ;", "Resource   actual    =    this . resolver . resolveResource ( null ,    requestPath ,    locations ,    null )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "if    (  (  !  ( location . createRelative ( requestPath )  . exists (  )  )  )     &  &     (  !  ( requestPath . contains (  \"  :  \"  )  )  )  )     {", "fail (  ( requestPath    +     \"    doesn ' t   actually   exist   as   a   relative   path \"  )  )  ;", "}", "assertNull ( actual )  ;", "}", "METHOD_END"], "methodName": ["testCheckResource"], "fileName": "org.springframework.web.reactive.resource.PathResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceUrlProvider ;", "}", "METHOD_END"], "methodName": ["getResourceUrlProvider"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( resourcePath . startsWith (  \"  /  \"  )  )     {", "ResourceUrlProvider   urlProvider    =    getResourceUrlProvider (  )  ;", "return   urlProvider    !  =    null    ?    urlProvider . getForUriString ( resourcePath ,    exchange )     :    Mono . empty (  )  ;", "} else    {", "return   tChain . getResolverChain (  )  . resolveUrlPath ( resourcePath ,    Collections . singletonList ( resource )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveUrlPath"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupport"}, {"methodBody": ["METHOD_START", "{", "this . resourceUrlProvider    =    resourceUrlProvider ;", "}", "METHOD_END"], "methodName": ["setResourceUrlProvider"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupport"}, {"methodBody": ["METHOD_START", "{", "String   requestPath    =    exchange . getRequest (  )  . getURI (  )  . getPath (  )  ;", "String   absolutePath    =    StringUtils . applyRelativePath ( requestPath ,    path )  ;", "return   StringUtils . cleanPath ( absolutePath )  ;", "}", "METHOD_END"], "methodName": ["toAbsolutePath"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupport"}, {"methodBody": ["METHOD_START", "{", "ResourceWebHandler   handler    =    new   ResourceWebHandler (  )  ;", "handler . setLocations ( Collections . singletonList ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  )  ;", "handler . setResourceResolvers ( resolvers )  ;", "ResourceUrlProvider   urlProvider    =    new   ResourceUrlProvider (  )  ;", "urlProvider . registerHandlers ( Collections . singletonMap (  \"  / resources /  *  *  \"  ,    handler )  )  ;", "return   urlProvider ;", "}", "METHOD_END"], "methodName": ["createResourceUrlProvider"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupportTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / resources / main . css \"  )  )  ;", "String   resourcePath    =     \"  / resources / bar . css \"  ;", "Resource   css    =    new   ClassPathResource (  \" test / main . css \"  ,    getClass (  )  )  ;", "String   actual    =    this . t . resolveUrlPath ( resourcePath ,    exchange ,    css ,    this . tChain )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  \"  / resources / bar -  1  1 e 1  6 cf 7  9 faee 7 ac 6  9  8 c 8  0  5 cf 2  8  2  4  8 d 2  . css \"  ,    actual )  ;", "assertEquals (  \"  / resources / bar -  1  1 e 1  6 cf 7  9 faee 7 ac 6  9  8 c 8  0  5 cf 2  8  2  4  8 d 2  . css \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveUrlPath"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupportTests"}, {"methodBody": ["METHOD_START", "{", "Resource   css    =    new   ClassPathResource (  \" test / main . css \"  ,    getClass (  )  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "String   actual    =    this . t . resolveUrlPath (  \" bar . css \"  ,    exchange ,    css ,    this . tChain )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  \" bar -  1  1 e 1  6 cf 7  9 faee 7 ac 6  9  8 c 8  0  5 cf 2  8  2  4  8 d 2  . css \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveUrlPathWithRelativePath"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupportTests"}, {"methodBody": ["METHOD_START", "{", "Resource   imagePng    =    new   ClassPathResource (  \" test / images / image . png \"  ,    getClass (  )  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "String   actual    =    this . t . resolveUrlPath (  \"  .  .  / bar . css \"  ,    exchange ,    imagePng ,    this . tChain )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  \"  .  .  / bar -  1  1 e 1  6 cf 7  9 faee 7 ac 6  9  8 c 8  0  5 cf 2  8  2  4  8 d 2  . css \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveUrlPathWithRelativePathInParentDirectory"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupportTests"}, {"methodBody": ["METHOD_START", "{", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  ;", "versionResolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    new   ContentVersionStrategy (  )  )  )  ;", "PathResourceResolver   pathResolver    =    new   PathResourceResolver (  )  ;", "pathResolver . setAllowedLocations ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  ;", "List < ResourceResolver >    resolvers    =    Arrays . asList ( versionResolver ,    pathResolver )  ;", "this . transformerChain    =    new   DefaultResourceTransformerChain ( new   DefaultResourceResolverChain ( resolvers )  ,    null )  ;", "this . transformer    =    new    . TestResourceTransformerSupport (  )  ;", "this . transformer . setResourceUrlProvider ( createResourceUrlProvider ( resolvers )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.ResourceTransformerSupportTests"}, {"methodBody": ["METHOD_START", "{", "ResourceUrlProvider . logger . debug (  \" Looking   for   resource   handler   mappings \"  )  ;", "Map < String ,    SimpleUrlHandlerMapping >    beans    =    context . getBeansOfType ( SimpleUrlHandlerMapping . class )  ;", "List < SimpleUrlHandlerMapping >    mappings    =    new   ArrayList <  >  ( beans . values (  )  )  ;", "AnnotationAwareOrderComparator . sort ( mappings )  ;", "mappings . forEach (  (    mapping )     -  >    mapping . getHandlerMap (  )  . forEach (  (    pattern ,    handler )     -  >     {", "if    ( handler   instanceof   ResourceWebHandler )     {", "ResourceWebHandler   resourceHandler    =     (  ( ResourceWebHandler )     ( handler )  )  ;", "if    ( ResourceUrlProvider . logger . isDebugEnabled (  )  )     {", "ResourceUrlProvider . logger . debug (  (  (  (  (  (  (  (  \" Found   resource   handler   mapping :    URL   pattern =  \\  \"  \"     +    pattern )     +     \"  \\  \"  ,     \"  )     +     \" locations =  \"  )     +     ( resourceHandler . getLocations (  )  )  )     +     \"  ,     \"  )     +     \" resolvers =  \"  )     +     ( resourceHandler . getResourceResolvers (  )  )  )  )  ;", "}", "this . handlerMap . put ( pattern ,    resourceHandler )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["detectResourceHandlers"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( ResourceUrlProvider . logger . isTraceEnabled (  )  )     {", "ResourceUrlProvider . logger . trace (  (  (  \" Getting   resource   URL   for   request   URL    \\  \"  \"     +    uriString )     +     \"  \\  \"  \"  )  )  ;", "}", "ServerHttpRequest   request    =    exchange . getRequest (  )  ;", "int   queryIndex    =    getQueryIndex ( uriString )  ;", "String   lookupPath    =    uriString . substring (  0  ,    queryIndex )  ;", "String   query    =    uriString . substring ( queryIndex )  ;", "PathContainer   parsedLookupPath    =    PathContainer . parsePath ( lookupPath )  ;", "if    ( ResourceUrlProvider . logger . isTraceEnabled (  )  )     {", "ResourceUrlProvider . logger . trace (  (  (  \" Getting   resource   URL   for   lookup   path    \\  \"  \"     +    lookupPath )     +     \"  \\  \"  \"  )  )  ;", "}", "return   resolveResourceUrl ( parsedLookupPath )  . map (  (    resolvedPath )     -  >     (  ( request . getPath (  )  . contextPath (  )  . value (  )  )     +    resolvedPath )     +    query )  ;", "}", "METHOD_END"], "methodName": ["getForUriString"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProvider"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . handlerMap )  ;", "}", "METHOD_END"], "methodName": ["getHandlerMap"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProvider"}, {"methodBody": ["METHOD_START", "{", "int   suffixIndex    =    path . length (  )  ;", "int   queryIndex    =    path . indexOf (  '  ?  '  )  ;", "if    ( queryIndex    >     0  )     {", "suffixIndex    =    queryIndex ;", "}", "int   hashIndex    =    path . indexOf (  '  #  '  )  ;", "if    ( hashIndex    >     0  )     {", "suffixIndex    =    Math . min ( suffixIndex ,    hashIndex )  ;", "}", "return   suffixIndex ;", "}", "METHOD_END"], "methodName": ["getQueryIndex"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( StringUtils . hasLength ( pattern )  )     &  &     (  !  ( pattern . startsWith (  \"  /  \"  )  )  )  )     {", "return    \"  /  \"     +    pattern ;", "} else    {", "return   pattern ;", "}", "}", "METHOD_END"], "methodName": ["prependLeadingSlash"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProvider"}, {"methodBody": ["METHOD_START", "{", "this . handlerMap . clear (  )  ;", "handlerMap . forEach (  (    rawPattern ,    resourceWebHandler )     -  >     {", "rawPattern    =     . prependLeadingSlash ( rawPattern )  ;", "PathPattern   pattern    =    this . patternParser . parse ( rawPattern )  ;", "this . handlerMap . put ( pattern ,    resourceWebHandler )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerHandlers"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProvider"}, {"methodBody": ["METHOD_START", "{", "return   this . handlerMap . entrySet (  )  . stream (  )  . filter (  (    entry )     -  >    entry . getKey (  )  . matches ( lookupPath )  )  . sorted (  (    entry 1  ,    entry 2  )     -  >    PathPattern . SPECIFICITY _ COMPARATOR . compare ( entry 1  . getKey (  )  ,    entry 2  . getKey (  )  )  )  . findFirst (  )  . map (  (    entry )     -  >     {", "PathContainer   path    =    entry . getKey (  )  . extractPathWithinPattern ( lookupPath )  ;", "int   endIndex    =     ( lookupPath . elements (  )  . size (  )  )     -     ( path . elements (  )  . size (  )  )  ;", "PathContainer   mapping    =    lookupPath . subPath (  0  ,    endIndex )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  \" Invoking   ResourceResolverChain   for   URL   pattern    \"     +     \"  \\  \"  \"  )     +     ( entry . getKey (  )  )  )     +     \"  \\  \"  \"  )  )  ;", "}", "ResourceWebHandler   handler    =    entry . getValue (  )  ;", "List < ResourceResolver >    resolvers    =    handler . getResourceResolvers (  )  ;", "ResourceResolverChain   chain    =    new   DefaultResourceResolverChain ( resolvers )  ;", "return   chain . resolveUrlPath ( path . value (  )  ,    handler . getLocations (  )  )  . map (  (    resolvedPath )     -  >     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Resolved   public   resource   URL   path    \\  \"  \"     +    resolvedPath )     +     \"  \\  \"  \"  )  )  ;", "}", "return    ( mapping . value (  )  )     +    resolvedPath ;", "}  )  ;", "}  )  . orElse ( Mono . empty (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceUrl"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProvider"}, {"methodBody": ["METHOD_START", "{", "ResourceWebHandler   otherHandler    =    new   ResourceWebHandler (  )  ;", "otherHandler . setLocations ( this . locations )  ;", "Map < String ,    VersionStrategy >    versionStrategyMap    =    new   HashMap <  >  (  )  ;", "versionStrategyMap . put (  \"  /  *  *  \"  ,    new   ContentVersionStrategy (  )  )  ;", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  ;", "versionResolver . setStrategyMap ( versionStrategyMap )  ;", "List < ResourceResolver >    resolvers    =    new   ArrayList <  >  (  )  ;", "resolvers . add ( versionResolver )  ;", "resolvers . add ( new   PathResourceResolver (  )  )  ;", "otherHandler . setResourceResolvers ( resolvers )  ;", "this . handlerMap . put (  \"  / resources /  *  . css \"  ,    otherHandler )  ;", "this . u . registerHandlers ( this . handlerMap )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "String   path    =     \"  / resources / foo . css \"  ;", "String   url    =    this . u . getForUriString ( path ,    exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  \"  / resources / foo - e 3  6 d 2 e 0  5  2  5  3 c 6 c 7  0  8  5 a 9  1  5  2  2 ce 4  3 a 0 b 4  . css \"  ,    url )  ;", "}", "METHOD_END"], "methodName": ["bestPatternMatch"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProviderTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    VersionStrategy >    versionStrategyMap    =    new   HashMap <  >  (  )  ;", "versionStrategyMap . put (  \"  /  *  *  \"  ,    new   ContentVersionStrategy (  )  )  ;", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  ;", "versionResolver . setStrategyMap ( versionStrategyMap )  ;", "List < ResourceResolver >    resolvers    =    new   ArrayList <  >  (  )  ;", "resolvers . add ( versionResolver )  ;", "resolvers . add ( new   PathResourceResolver (  )  )  ;", "this . handler . setResourceResolvers ( resolvers )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "String   path    =     \"  / resources / foo . css \"  ;", "String   url    =    this . u . getForUriString ( path ,    exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  \"  / resources / foo - e 3  6 d 2 e 0  5  2  5  3 c 6 c 7  0  8  5 a 9  1  5  2  2 ce 4  3 a 0 b 4  . css \"  ,    url )  ;", "}", "METHOD_END"], "methodName": ["getFingerprintedResourceUrl"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProviderTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "String   uriString    =     \"  / resources / foo . css \"  ;", "String   actual    =    this . u . getForUriString ( uriString ,    exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( uriString ,    actual )  ;", "}", "METHOD_END"], "methodName": ["getStaticResourceUrl"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProviderTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "String   url    =     \"  / resources / foo . css ? foo = bar & url = http :  /  / example . org \"  ;", "String   resolvedUrl    =    this . u . getForUriString ( url ,    exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( url ,    resolvedUrl )  ;", "url    =     \"  / resources / foo . css # hash \"  ;", "resolvedUrl    =    this . u . getForUriString ( url ,    exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( url ,    resolvedUrl )  ;", "}", "METHOD_END"], "methodName": ["getStaticResourceUrlRequestWithQueryOrHash"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProviderTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigWebApplicationContext   context    =    new   AnnotationConfigWebApplicationContext (  )  ;", "context . setServletContext ( new   MockServletContext (  )  )  ;", "context . register (  . HandlerMappingConfiguration . class )  ;", "context . refresh (  )  ;", "ResourceUrlProvider   urlProviderBean    =    context . getBean ( ResourceUrlProvider . class )  ;", "assertThat ( urlProviderBean . getHandlerMap (  )  ,    Matchers . hasKey (  . pattern (  \"  / resources /  *  *  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["initializeOnce"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProviderTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ResourceUrlProviderTests . PathPatternMatcher ( pattern )  ;", "}", "METHOD_END"], "methodName": ["pattern"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProviderTests"}, {"methodBody": ["METHOD_START", "{", "this . locations . add ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  ;", "this . locations . add ( new   ClassPathResource (  \" testalternatepath /  \"  ,    getClass (  )  )  )  ;", "this . handler . setLocations ( locations )  ;", "this . handler . afterPropertiesSet (  )  ;", "this . handlerMap . put (  \"  / resources /  *  *  \"  ,    this . handler )  ;", "this . u . registerHandlers ( this . handlerMap )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.ResourceUrlProviderTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    null ;", "char   prev    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( path . length (  )  )  ;    i +  +  )     {", "char   curr    =    path . charAt ( i )  ;", "try    {", "if    (  ( curr    =  =     '  /  '  )     &  &     ( prev    =  =     '  /  '  )  )     {", "if    ( sb    =  =    null )     {", "sb    =    new   StringBuilder ( path . substring (  0  ,    i )  )  ;", "}", "continue ;", "}", "if    ( sb    !  =    null )     {", "sb . append ( path . charAt ( i )  )  ;", "}", "}    finally    {", "prev    =    curr ;", "}", "}", "return   sb    !  =    null    ?    sb . toString (  )     :    path ;", "}", "METHOD_END"], "methodName": ["cleanDuplicateSlashes"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "boolean   slash    =    false ;", "for    ( int   i    =     0  ;    i    <     ( path . length (  )  )  ;    i +  +  )     {", "if    (  ( path . charAt ( i )  )     =  =     '  /  '  )     {", "slash    =    true ;", "} else", "if    (  (  ( path . charAt ( i )  )     >     '     '  )     &  &     (  ( path . charAt ( i )  )     !  =     1  2  7  )  )     {", "if    (  ( i    =  =     0  )     |  |     (  ( i    =  =     1  )     &  &    slash )  )     {", "return   path ;", "}", "path    =     ( slash )     ?     \"  /  \"     +     ( path . substring ( i )  )     :    path . substring ( i )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  \" Path   after   trimming   leading    '  /  '    and   control   characters :     \"     +    path )  )  ;", "}", "return   path ;", "}", "}", "return   slash    ?     \"  /  \"     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["cleanLeadingSlash"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResourceResolverChain ( getResourceResolvers (  )  )  ;", "}", "METHOD_END"], "methodName": ["createResolverChain"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResourceTransformerChain ( resolverChain ,    getResourceTransformers (  )  )  ;", "}", "METHOD_END"], "methodName": ["createTransformerChain"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheControl ;", "}", "METHOD_END"], "methodName": ["getCacheControl"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . locations ;", "}", "METHOD_END"], "methodName": ["getLocations"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "String   name    =    HandlerMapping . PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE ;", "PathContainer   pathWithinHandler    =    exchange . getRequiredAttribute ( name )  ;", "String   path    =    processPath ( pathWithinHandler . value (  )  )  ;", "if    (  (  !  ( StringUtils . hasText ( path )  )  )     |  |     ( isInvalidPath ( path )  )  )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Ignoring   invalid   resource   path    [  \"     +    path )     +     \"  ]  \"  )  )  ;", "}", "return   Mono . empty (  )  ;", "}", "if    ( isInvalidEncodedPath ( path )  )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Ignoring   invalid   resource   path   with   escape   sequences    [  \"     +    path )     +     \"  ]  \"  )  )  ;", "}", "return   Mono . empty (  )  ;", "}", "ResourceResolverChain   resolveChain    =    createResolverChain (  )  ;", "return   resolveChain . resolveResource ( exchange ,    path ,    getLocations (  )  )  . flatMap (  (    resource )     -  >     {", "ResourceTransformerChain   transformerChain    =    createTransformerChain ( resolveChain )  ;", "return   transformerChain . transform ( exchange ,    resource )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceHttpMessageWriter ;", "}", "METHOD_END"], "methodName": ["getResourceHttpMessageWriter"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceResolvers ;", "}", "METHOD_END"], "methodName": ["getResourceResolvers"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceTransformers ;", "}", "METHOD_END"], "methodName": ["getResourceTransformers"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( this . locations )  )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  \" Locations   list   is   empty .    No   resources   will   be   served   unless   a    \"     +     \" custom   ResourceResolver   is   configured   as   an   alternative   to   PathResourceResolver .  \"  )  )  ;", "}", "return ;", "}", "for    ( int   i    =     ( getResourceResolvers (  )  . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    (  ( getResourceResolvers (  )  . get ( i )  )    instanceof   PathResourceResolver )     {", "PathResourceResolver   resolver    =     (  ( PathResourceResolver )     ( getResourceResolvers (  )  . get ( i )  )  )  ;", "if    ( ObjectUtils . isEmpty ( resolver . getAllowedLocations (  )  )  )     {", "resolver . setAllowedLocations ( getLocations (  )  . toArray ( new   Resource [  0  ]  )  )  ;", "}", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["initAllowedLocations"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( path . contains (  \"  %  \"  )  )     {", "try    {", "St   decodedPath    =    URLDecoder . decode ( path ,     \" UTF -  8  \"  )  ;", "if    ( isInvalidPath ( decodedPath )  )     {", "return   true ;", "}", "decodedPath    =    processPath ( decodedPath )  ;", "if    ( isInvalidPath ( decodedPath )  )     {", "return   true ;", "}", "}    catch    ( IllegalArgumentException    |    UnsupportedEncodingException   ex )     {", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isInvalidEncodedPath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( ResourceWebHandler . logger . isTraceEnabled (  )  )     {", "ResourceWebHandler . logger . trace (  (  \" Applying    \\  \" invalid   path \\  \"    checks   to   path :     \"     +    path )  )  ;", "}", "if    (  ( path . contains (  \" WEB - INF \"  )  )     |  |     ( path . contains (  \" META - INF \"  )  )  )     {", "if    ( ResourceWebHandler . logger . isTraceEnabled (  )  )     {", "ResourceWebHandler . logger . trace (  \" Path   contains    \\  \" WEB - INF \\  \"    or    \\  \" META - INF \\  \"  .  \"  )  ;", "}", "return   true ;", "}", "if    ( path . contains (  \"  :  /  \"  )  )     {", "String   relativePath    =     (  ( path . charAt (  0  )  )     =  =     '  /  '  )     ?    path . substring (  1  )     :    path ;", "if    (  ( ResourceUtils . isUrl ( relativePath )  )     |  |     ( relativePath . startsWith (  \" url :  \"  )  )  )     {", "if    ( ResourceWebHandler . logger . isTraceEnabled (  )  )     {", "ResourceWebHandler . logger . trace (  \" Path   represents   URL   or   has    \\  \" url :  \\  \"    prefix .  \"  )  ;", "}", "return   true ;", "}", "}", "if    ( path . contains (  \"  .  .  \"  )  )     {", "path    =    StringUtils . cleanPath ( path )  ;", "if    ( path . contains (  \"  .  .  /  \"  )  )     {", "if    ( ResourceWebHandler . logger . isTraceEnabled (  )  )     {", "ResourceWebHandler . logger . trace (  \" Path   contains    \\  \"  .  .  /  \\  \"    after   call   to   StringUtils # cleanPath .  \"  )  ;", "}", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isInvalidPath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "path    =    StringUtils . replace ( path ,     \"  \\  \\  \"  ,     \"  /  \"  )  ;", "path    =    cleanDuplicateSlashes ( path )  ;", "return   cleanLeadingSlash ( path )  ;", "}", "METHOD_END"], "methodName": ["processPath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "this . cacheControl    =    cacheControl ;", "}", "METHOD_END"], "methodName": ["setCacheControl"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    exchange . getResponse (  )  . getHeaders (  )  ;", "long   length    =    contentLength (  )  ;", "headers . setContentLength ( length )  ;", "if    ( mediaType    !  =    null )     {", "headers . setContentType ( mediaType )  ;", "}", "if    ( instanceof   HttpResource )     {", "HttpHeaders   eaders    =     (  ( HttpResource )     (  )  . getResponseHeaders (  )  ;", "exchange . getResponse (  )  . getHeaders (  )  . putAll ( eaders )  ;", "}", "}", "METHOD_END"], "methodName": ["setHeaders"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "this . locations . clear (  )  ;", "if    ( locations    !  =    null )     {", "this . locations . addAll ( locations )  ;", "}", "}", "METHOD_END"], "methodName": ["setLocations"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "this . resourceHttpMessageWriter    =    httpMessageWriter ;", "}", "METHOD_END"], "methodName": ["setResourceHttpMessageWriter"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "this . resourceResolvers . clear (  )  ;", "if    ( resourceResolvers    !  =    null )     {", "this . resourceResolvers . addAll ( resourceResolvers )  ;", "}", "}", "METHOD_END"], "methodName": ["setResourceResolvers"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "this . resourceTransformers . clear (  )  ;", "if    ( resourceTransformers    !  =    null )     {", "this . resourceTransformers . addAll ( resourceTransformers )  ;", "}", "}", "METHOD_END"], "methodName": ["setResourceTransformers"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandler"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( exchange . getResponse (  )  . getBody (  )  )  . consumeNextWith (  (    buf )     -  >    assertEquals ( responseBody ,    DataBufferTestUtils . dumpString ( buf ,    StandardCharsets . UTF _  8  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["assertResponseBody"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" js /  \"  )  ;", "StepVerifier . create ( this . handler . handle ( exchange )  )  . expectErrorSatisfies (  (    err )     -  >     {", "assertThat ( err ,    instanceOf (  . class )  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,     (  ( ResponseStatusException )     ( err )  )  . getStatus (  )  )  ;", "}  )  . verify (  . TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["directory"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" underscorejs /  \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  0  ,    exchange . getResponse (  )  . getHeaders (  )  . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["directoryInJarFile"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "exchange . getResponse (  )  . getHeaders (  )  . setCacheControl ( CacheControl . noStore (  )  . getHeaderValue (  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals (  \" max - age =  3  6  0  0  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getCacheControl (  )  )  ;", "}", "METHOD_END"], "methodName": ["doOverwriteExistingCacheControlHeaders"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List < Resource >    paths    =    Collections . singletonList ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  ;", "ResourceWebHandler   handler    =    new   ResourceWebHandler (  )  ;", "handler . setLocations ( paths )  ;", "handler . afterPropertiesSet (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  . header (  \" Accept \"  ,     \" application / json , text / plain ,  *  /  *  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . html \"  )  ;", "handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( TEXT _ HTML ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMediaTypeWithFavorPathExtensionOff"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "HttpHeaders   headers    =    exchange . getResponse (  )  . getHeaders (  )  ;", "assertEquals ( MediaType . parseMediaType (  \" text / css \"  )  ,    headers . getContentType (  )  )  ;", "assertEquals (  1  7  ,    headers . getContentLength (  )  )  ;", "assertEquals (  \" max - age =  3  6  0  0  \"  ,    headers . getCacheControl (  )  )  ;", "assertTrue ( headers . containsKey (  \" Last - Modified \"  )  )  ;", "assertEquals (  (  ( headers . getLastModified (  )  )     /     1  0  0  0  )  ,     (  ( resourceLastModifiedDate (  \" test / foo . css \"  )  )     /     1  0  0  0  )  )  ;", "assertEquals (  \" bytes \"  ,    headers . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    headers . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "assertResponseBody ( exchange ,     \" h 1     {    color : red ;     }  \"  )  ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" baz . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "HttpHeaders   headers    =    exchange . getResponse (  )  . getHeaders (  )  ;", "assertEquals ( MediaType . parseMediaType (  \" text / css \"  )  ,    headers . getContentType (  )  )  ;", "assertEquals (  1  7  ,    headers . getContentLength (  )  )  ;", "assertEquals (  \" max - age =  3  6  0  0  \"  ,    headers . getCacheControl (  )  )  ;", "assertTrue ( headers . containsKey (  \" Last - Modified \"  )  )  ;", "assertEquals (  (  ( headers . getLastModified (  )  )     /     1  0  0  0  )  ,     (  ( resourceLastModifiedDate (  \" testalternatepath / baz . css \"  )  )     /     1  0  0  0  )  )  ;", "assertEquals (  \" bytes \"  ,    headers . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    headers . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "assertResponseBody ( exchange ,     \" h 1     {    color : red ;     }  \"  )  ;", "}", "METHOD_END"], "methodName": ["getResourceFromAlternatePath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" js / foo . js \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( MediaType . parseMediaType (  \" application / javascript \"  )  ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertResponseBody ( exchange ,     \" function   foo (  )     {    console . log (  \\  \" hello   world \\  \"  )  ;     }  \"  )  ;", "}", "METHOD_END"], "methodName": ["getResourceFromSubDirectory"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" js / baz . js \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "HttpHeaders   headers    =    exchange . getResponse (  )  . getHeaders (  )  ;", "assertEquals ( MediaType . parseMediaType (  \" application / javascript \"  )  ,    headers . getContentType (  )  )  ;", "assertResponseBody ( exchange ,     \" function   foo (  )     {    console . log (  \\  \" hello   world \\  \"  )  ;     }  \"  )  ;", "}", "METHOD_END"], "methodName": ["getResourceFromSubDirectoryOfAlternatePath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . head (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "HttpHeaders   headers    =    exchange . getResponse (  )  . getHeaders (  )  ;", "assertEquals ( MediaType . parseMediaType (  \" text / css \"  )  ,    headers . getContentType (  )  )  ;", "assertEquals (  1  7  ,    headers . getContentLength (  )  )  ;", "assertEquals (  \" max - age =  3  6  0  0  \"  ,    headers . getCacheControl (  )  )  ;", "assertTrue ( headers . containsKey (  \" Last - Modified \"  )  )  ;", "assertEquals (  (  ( headers . getLastModified (  )  )     /     1  0  0  0  )  ,     (  ( resourceLastModifiedDate (  \" test / foo . css \"  )  )     /     1  0  0  0  )  )  ;", "assertEquals (  \" bytes \"  ,    headers . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    headers . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "StepVerifier . create ( exchange . getResponse (  )  . getBody (  )  )  . expectErrorMatches (  (    ex )     -  >    ex . getMessage (  )  . startsWith (  \" No   content   was   written \"  )  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceHttpHeader"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . options (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  \" GET , HEAD , OPTIONS \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Allow \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceHttpOptions"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . css \"  )  ;", "this . handler . setCacheControl ( CacheControl . noStore (  )  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals (  \" no - store \"  ,    response . getHeaders (  )  . getCacheControl (  )  )  ;", "assertTrue ( response . getHeaders (  )  . containsKey (  \" Last - Modified \"  )  )  ;", "assertEquals (  (  ( response . getHeaders (  )  . getLastModified (  )  )     /     1  0  0  0  )  ,     (  ( resourceLastModifiedDate (  \" test / foo . css \"  )  )     /     1  0  0  0  )  )  ;", "assertEquals (  \" bytes \"  ,    response . getHeaders (  )  . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    response . getHeaders (  )  . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceNoCache"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . html \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "HttpHeaders   headers    =    exchange . getResponse (  )  . getHeaders (  )  ;", "assertEquals ( TEXT _ HTML ,    headers . getContentType (  )  )  ;", "assertEquals (  \" max - age =  3  6  0  0  \"  ,    headers . getCacheControl (  )  )  ;", "assertTrue ( headers . containsKey (  \" Last - Modified \"  )  )  ;", "assertEquals (  (  ( headers . getLastModified (  )  )     /     1  0  0  0  )  ,     (  ( resourceLastModifiedDate (  \" test / foo . html \"  )  )     /     1  0  0  0  )  )  ;", "assertEquals (  \" bytes \"  ,    headers . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    headers . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceWithHtmlMediaType"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "VersionResourceResolver   versionResolver    =    new   VersionResourceResolver (  )  ;", "versionResolver . addFixedVersionStrategy (  \" versionString \"  ,     \"  /  *  *  \"  )  ;", "this . handler . setResourceResolvers ( Arrays . asList ( versionResolver ,    new   PathResourceResolver (  )  )  )  ;", "this . handler . afterPropertiesSet (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" versionString / foo . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals (  \"  \\  \" versionString \\  \"  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "assertEquals (  \" bytes \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getVersionedResource"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "PathResourceResolver   resolver    =     (  ( PathResourceResolver )     ( this . handler . getResourceResolvers (  )  . get (  0  )  )  )  ;", "Resource [  ]    locations    =    resolver . getAllowedLocations (  )  ;", "assertEquals (  3  ,    locations . length )  ;", "assertEquals (  \" test /  \"  ,     (  ( ClassPathResource )     ( locations [  0  ]  )  )  . getPath (  )  )  ;", "assertEquals (  \" testalternatepath /  \"  ,     (  ( ClassPathResource )     ( locations [  1  ]  )  )  . getPath (  )  )  ;", "assertEquals (  \" META - INF / resources / webjars /  \"  ,     (  ( ClassPathResource )     ( locations [  2  ]  )  )  . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["initAllowedLocations"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathResource   location 1     =    new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  ;", "ClassPathResource   location 2     =    new   ClassPathResource (  \" testalternatepath /  \"  ,    getClass (  )  )  ;", "PathResourceResolver   pathResolver    =    new   PathResourceResolver (  )  ;", "pathResolver . setAllowedLocations ( location 1  )  ;", "handler    =    new    (  )  ;", "handler . setResourceResolvers ( Collections . singletonList ( pathResolver )  )  ;", "handler . setLocations ( Arrays . asList ( location 1  ,    location 2  )  )  ;", "handler . afterPropertiesSet (  )  ;", "Resource [  ]    locations    =    pathResolver . getAllowedLocations (  )  ;", "assertEquals (  1  ,    locations . length )  ;", "assertEquals (  \" test /  \"  ,     (  ( ClassPathResource )     ( locations [  0  ]  )  )  . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["initAllowedLocationsWithExplicitConfiguration"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \"  \"  )  ;", "StepVerifier . create ( this . handler . handle ( exchange )  )  . expectErrorSatisfies (  (    err )     -  >     {", "assertThat ( err ,    instanceOf (  . class )  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,     (  ( ResponseStatusException )     ( err )  )  . getStatus (  )  )  ;", "}  )  . verify (  . TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["missingResourcePath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "long   timestamp    =     (  (  ( resourceLastModified (  \" test / foo . css \"  )  )     /     1  0  0  0  )     *     1  0  0  0  )     -     1  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  \"  )  . ifModifiedSince ( timestamp )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertNull ( exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertResponseBody ( exchange ,     \" h 1     {    color : red ;     }  \"  )  ;", "}", "METHOD_END"], "methodName": ["modified"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["noPathWithinHandlerMappingAttribute"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  . ifModifiedSince ( resourceLastModified (  \" test / foo . css \"  )  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( NOT _ MODIFIED ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["notModified"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  \"  )  . header (  \" Range \"  ,     \" bytes =  0  -  1  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . txt \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( PARTIAL _ CONTENT ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  2  ,    exchange . getResponse (  )  . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals (  \" bytes    0  -  1  /  1  0  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Content - Range \"  )  )  ;", "assertEquals (  \" bytes \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "assertResponseBody ( exchange ,     \" So \"  )  ;", "}", "METHOD_END"], "methodName": ["partialContentByteRange"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  \"  )  . header (  \" range \"  ,     \" bytes =  9  -  1  0  0  0  0  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . txt \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( PARTIAL _ CONTENT ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals (  \" bytes    9  -  9  /  1  0  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Content - Range \"  )  )  ;", "assertEquals (  \" bytes \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "assertResponseBody ( exchange ,     \"  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["partialContentByteRangeLargeEnd"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  \"  )  . header (  \" range \"  ,     \" bytes =  9  -  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . txt \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( PARTIAL _ CONTENT ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals (  \" bytes    9  -  9  /  1  0  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Content - Range \"  )  )  ;", "assertEquals (  \" bytes \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "assertResponseBody ( exchange ,     \"  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["partialContentByteRangeNoEnd"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  \"  )  . header (  \" range \"  ,     \" bytes = foo   bar \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinMapping ( exchange ,     \" foo . txt \"  )  ;", "StepVerifier . create ( this . handler . handle ( exchange )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "assertEquals ( REQUESTED _ RANGE _ NOT _ SATISFIABLE ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  \" bytes \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Accept - Ranges \"  )  )  ;", "}", "METHOD_END"], "methodName": ["partialContentInvalidRangeHeader"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  \"  )  . header (  \" Range \"  ,     \" bytes =  0  -  1  ,     4  -  5  ,     8  -  9  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . txt \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( PARTIAL _ CONTENT ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertTrue ( exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  . toString (  )  . startsWith (  \" multipart / byteranges ; boundary =  \"  )  )  ;", "String   boundary    =     \"  -  -  \"     +     ( exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  . toString (  )  . substring (  3  0  )  )  ;", "Mono < DataBuffer >    reduced    =    Flux . from ( exchange . getResponse (  )  . getBody (  )  )  . reduce ( this . bufferFactory . allocateBuffer (  )  ,     (    previous ,    current )     -  >     {", "previous . write ( current )  ;", "DataBufferUtils . release ( current )  ;", "return   previous ;", "}  )  ;", "StepVerifier . create ( reduced )  . consumeNextWith (  (    buf )     -  >     {", "String   content    =    DataBufferTestUtils . dumpString ( buf ,    StandardCharsets . UTF _  8  )  ;", "String [  ]    ranges    =    StringUtils . tokenizeToStringArray ( content ,     \"  \\ r \\ n \"  ,    false ,    true )  ;", "assertEquals ( boundary ,    ranges [  0  ]  )  ;", "assertEquals (  \" Content - Type :    text / plain \"  ,    ranges [  1  ]  )  ;", "assertEquals (  \" Content - Range :    bytes    0  -  1  /  1  0  \"  ,    ranges [  2  ]  )  ;", "assertEquals (  \" So \"  ,    ranges [  3  ]  )  ;", "assertEquals ( boundary ,    ranges [  4  ]  )  ;", "assertEquals (  \" Content - Type :    text / plain \"  ,    ranges [  5  ]  )  ;", "assertEquals (  \" Content - Range :    bytes    4  -  5  /  1  0  \"  ,    ranges [  6  ]  )  ;", "assertEquals (  \"    t \"  ,    ranges [  7  ]  )  ;", "assertEquals ( boundary ,    ranges [  8  ]  )  ;", "assertEquals (  \" Content - Type :    text / plain \"  ,    ranges [  9  ]  )  ;", "assertEquals (  \" Content - Range :    bytes    8  -  9  /  1  0  \"  ,    ranges [  1  0  ]  )  ;", "assertEquals (  \" t .  \"  ,    ranges [  1  1  ]  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["partialContentMultipleByteRanges"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  \"  )  . header (  \" range \"  ,     \" bytes =  -  1  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . txt \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( PARTIAL _ CONTENT ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals (  \" bytes    9  -  9  /  1  0  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Content - Range \"  )  )  ;", "assertEquals (  \" bytes \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "assertResponseBody ( exchange ,     \"  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["partialContentSuffixRange"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  \"  )  . header (  \" range \"  ,     \" bytes =  -  1  1  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . txt \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "assertEquals ( PARTIAL _ CONTENT ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertEquals (  1  0  ,    exchange . getResponse (  )  . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals (  \" bytes    0  -  9  /  1  0  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Content - Range \"  )  )  ;", "assertEquals (  \" bytes \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Accept - Ranges \"  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get (  \" Accept - Ranges \"  )  . size (  )  )  ;", "assertResponseBody ( exchange ,     \" Some   text .  \"  )  ;", "}", "METHOD_END"], "methodName": ["partialContentSuffixRangeLargeSuffix"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertSame (  \"  / foo / bar \"  ,    this . handler . processPath (  \"  / foo / bar \"  )  )  ;", "assertSame (  \" foo / bar \"  ,    this . handler . processPath (  \" foo / bar \"  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  \"        / foo / bar \"  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  (  (  ( char )     (  1  )  )     +     \"  / foo / bar \"  )  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  (  (  ( char )     (  3  1  )  )     +     \"  / foo / bar \"  )  )  )  ;", "assertEquals (  \" foo / bar \"  ,    this . handler . processPath (  \"       foo / bar \"  )  )  ;", "assertEquals (  \" foo / bar \"  ,    this . handler . processPath (  (  (  ( char )     (  3  1  )  )     +     \" foo / bar \"  )  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  (  (  ( char )     (  1  2  7  )  )     +     \"  / foo / bar \"  )  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  (  (  ( char )     (  1  2  7  )  )     +     \"  / foo / bar \"  )  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  \"        /       foo / bar \"  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  \"        /        /       foo / bar \"  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  \"        /  /     /  /  /     /  /  /  /       foo / bar \"  )  )  ;", "assertEquals (  \"  / foo / bar \"  ,    this . handler . processPath (  (  (  (  (  ( char )     (  1  )  )     +     \"     /     \"  )     +     (  ( char )     (  1  2  7  )  )  )     +     \"     /  /    foo / bar \"  )  )  )  ;", "assertEquals (  \"  \"  ,    this . handler . processPath (  \"           \"  )  )  ;", "assertEquals (  \"  /  \"  ,    this . handler . processPath (  \"  /  \"  )  )  ;", "assertEquals (  \"  /  \"  ,    this . handler . processPath (  \"  /  /  /  \"  )  )  ;", "assertEquals (  \"  /  \"  ,    this . handler . processPath (  \"  /     /           /     \"  )  )  ;", "}", "METHOD_END"], "methodName": ["processPath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathResource ( resourceName ,    getClass (  )  )  . getFile (  )  . lastModified (  )  ;", "}", "METHOD_END"], "methodName": ["resourceLastModified"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathResource ( resourceName ,    getClass (  )  )  . getFile (  )  . lastModified (  )  ;", "}", "METHOD_END"], "methodName": ["resourceLastModifiedDate"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "for    ( HttpMethod   method    :    HttpMethod . values (  )  )     {", "NotFound ( method )  ;", "}", "}", "METHOD_END"], "methodName": ["resourceNotFound"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . method ( httpMethod ,     \"  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "setPathWithinHandlerMapping ( exchange ,     \" not - there . css \"  )  ;", "StepVerifier . create ( this . handler . handle ( exchange )  )  . expectErrorSatisfies (  (    err )     -  >     {", "assertThat ( err ,    instanceOf (  . class )  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,     (  ( ResponseStatusException )     ( err )  )  . getStatus (  )  )  ;", "}  )  . verify (  . TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["resourceNotFound"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "exchange . getAttributes (  )  . put ( HandlerMapping . PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE ,    PathContainer . parsePath ( path )  )  ;", "}", "METHOD_END"], "methodName": ["setPathWithinHandlerMapping"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List < Resource >    paths    =    new   ArrayList <  >  (  2  )  ;", "paths . add ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  ;", "paths . add ( new   ClassPathResource (  \" testalternatepath /  \"  ,    getClass (  )  )  )  ;", "paths . add ( new   ClassPathResource (  \" META - INF / resources / webjars /  \"  )  )  ;", "this . handler    =    new    (  )  ;", "this . handler . setLocations ( paths )  ;", "this . handler . setCacheControl ( CacheControl . maxAge (  3  6  0  0  ,    TimeUnit . SECONDS )  )  ;", "this . handler . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    mock ( Resource . class )  ;", "when ( resource . getFilename (  )  )  . thenThrow ( new   AssertionError (  \" Resource   should   not   be   resolved \"  )  )  ;", "when ( resource . getInputStream (  )  )  . thenThrow ( new   AssertionError (  \" Resource   should   not   be   resolved \"  )  )  ;", "ResourceResolver   resolver    =    mock ( ResourceResolver . class )  ;", "when ( resolver . resolveResource ( any (  )  ,    any (  )  ,    any (  )  ,    any (  )  )  )  . thenReturn ( Mono . just ( resource )  )  ;", "handler    =    new    (  )  ;", "handler . setLocations ( Collections . singletonList ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  )  ;", "handler . setResourceResolvers ( Collections . singletonList ( resolver )  )  ;", "handler . afterPropertiesSet (  )  ;", "testInvalidPath (  \"  .  .  / testsecret / secret . txt \"  ,    handler )  ;", "testInvalidPath (  \" test /  .  .  /  .  .  / testsecret / secret . txt \"  ,    handler )  ;", "testInvalidPath (  \"  :  /  .  .  /  .  .  / testsecret / secret . txt \"  ,    handler )  ;", "Resource   location    =    new   UrlResource ( getClass (  )  . getResource (  \"  .  / test /  \"  )  )  ;", "this . handler . setLocations ( Collections . singletonList ( location )  )  ;", "Resource   secretResource    =    new   UrlResource ( getClass (  )  . getResource (  \" testsecret / secret . txt \"  )  )  ;", "String   secretPath    =    secretResource . getURL (  )  . getPath (  )  ;", "testInvalidPath (  (  \" file :  \"     +    secretPath )  ,    handler )  ;", "testInvalidPath (  (  \"  / file :  \"     +    secretPath )  ,    handler )  ;", "testInvalidPath (  (  \" url :  \"     +    secretPath )  ,    handler )  ;", "testInvalidPath (  (  \"  / url :  \"     +    secretPath )  ,    handler )  ;", "testInvalidPath (  (  \"  /  .  .  /  .  .  \"     +    secretPath )  ,    handler )  ;", "testInvalidPath (  \"  /  %  2 E %  2 E / testsecret / secret . txt \"  ,    handler )  ;", "testInvalidPath (  \"  /  %  2 E %  2 E / testsecret / secret . txt \"  ,    handler )  ;", "testInvalidPath (  (  \"  %  2 F %  2 F %  2 E %  2 E %  2 F %  2 F %  2 E %  2 E \"     +    secretPath )  ,    handler )  ;", "}", "METHOD_END"], "methodName": ["testInvalidPath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,    requestPath )  ;", "StepVerifier . create ( handler . handle ( exchange )  )  . expectErrorSatisfies (  (    err )     -  >     {", "assertThat ( err ,    instanceOf (  . class )  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,     (  ( ResponseStatusException )     ( err )  )  . getStatus (  )  )  ;", "}  )  . verify (  . TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["testInvalidPath"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "for    ( HttpMethod   method    :    HttpMethod . values (  )  )     {", "testlvePathWithTraversal ( method )  ;", "}", "}", "METHOD_END"], "methodName": ["testResolvePathWithTraversal"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Resource   location    =    new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  ;", "this . handler . setLocations ( Collections . singletonList ( location )  )  ;", "testResolvePathWithTraversal ( httpMethod ,     \"  .  .  / testsecret / secret . txt \"  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     \" test /  .  .  /  .  .  / testsecret / secret . txt \"  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     \"  :  /  .  .  /  .  .  / testsecret / secret . txt \"  ,    location )  ;", "location    =    new   UrlResource ( getClass (  )  . getResource (  \"  .  / test /  \"  )  )  ;", "this . handler . setLocations ( Collections . singletonList ( location )  )  ;", "Resource   secretResource    =    new   UrlResource ( getClass (  )  . getResource (  \" testsecret / secret . txt \"  )  )  ;", "String   secretPath    =    secretResource . getURL (  )  . getPath (  )  ;", "testResolvePathWithTraversal ( httpMethod ,     (  \" file :  \"     +    secretPath )  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     (  \"  / file :  \"     +    secretPath )  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     (  \" url :  \"     +    secretPath )  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     (  \"  / url :  \"     +    secretPath )  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     (  \"  /  /  /  /  .  .  /  .  .  \"     +    secretPath )  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     \"  /  %  2 E %  2 E / testsecret / secret . txt \"  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     \"  %  2 F %  2 F %  2 E %  2 E %  2 F %  2 Ftestsecret / secret . txt \"  ,    location )  ;", "testResolvePathWithTraversal ( httpMethod ,     (  \" url :  \"     +    secretPath )  ,    location )  ;", "}", "METHOD_END"], "methodName": ["testResolvePathWithTraversal"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . method ( httpMethod ,     \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,    requestPath )  ;", "StepVerifier . create ( this . handler . handle ( exchange )  )  . expectErrorSatisfies (  (    err )     -  >     {", "assertThat ( err ,    instanceOf (  . class )  )  ;", "assertEquals ( HttpStatus . NOT _ FOUND ,     (  ( ResponseStatusException )     ( err )  )  . getStatus (  )  )  ;", "}  )  . verify (  . TIMEOUT )  ;", "if    (  (  !  ( location . createRelative ( requestPath )  . exists (  )  )  )     &  &     (  !  ( requestPath . contains (  \"  :  \"  )  )  )  )     {", "fail (  ( requestPath    +     \"    doesn ' t   actually   exist   as   a   relative   path \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testResolvePathWithTraversal"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . post (  \"  \"  )  )  ;", "setPathWithinHandlerMapping ( exchange ,     \" foo . css \"  )  ;", "this . handler . handle ( exchange )  . block (  . TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["unsupportedHttpMethod"], "fileName": "org.springframework.web.reactive.resource.ResourceWebHandlerTests"}, {"methodBody": ["METHOD_START", "{", "addVersionStrategy ( new   ContentVersionStrategy (  )  ,    pathPatterns )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addContentVersionStrategy"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolver"}, {"methodBody": ["METHOD_START", "{", "List < String >    patternsList    =    Arrays . asList ( pathPatterns )  ;", "List < String >    prefixedPatterns    =    new   ArrayList <  >  ( pathPatterns . length )  ;", "String   versionPrefix    =     \"  /  \"     +    version ;", "for    ( String   pattern    :    patternsList )     {", "prefixedPatterns . add ( pattern )  ;", "if    (  (  !  ( pattern . startsWith ( versionPrefix )  )  )     &  &     (  !  ( patternsList . contains (  ( versionPrefix    +    pattern )  )  )  )  )     {", "prefixedPatterns . add (  ( versionPrefix    +    pattern )  )  ;", "}", "}", "return   addStrategy ( new   FixedStrategy ( version )  ,    StringUtils . toStringArray ( prefixedPatterns )  )  ;", "}", "METHOD_END"], "methodName": ["addFixedVersionStrategy"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( String   pattern    :    pathPatterns )     {", "getStrategyMap (  )  . put ( pattern ,    strategy )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addVersionStrategy"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolver"}, {"methodBody": ["METHOD_START", "{", "String   path    =     \"  /  \"  . concat ( requestPath )  ;", "List < String >    matchingPatterns    =    new   ArrayList <  >  (  )  ;", "for    ( String   pattern    :    this . vStrategyMap . keySet (  )  )     {", "if    ( this . pathMatcher . match ( pattern ,    path )  )     {", "matchingPatterns . add ( pattern )  ;", "}", "}", "if    (  !  ( matchingPatterns . isEmpty (  )  )  )     {", "Comparator < String >    comparator    =    this . pathMatcher . getPatternComparator ( path )  ;", "matchingPatterns . sort ( comparator )  ;", "return   this . vStrategyMap . get ( matchingPatterns . get (  0  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getStrategyForPath"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . versionStrategyMap ;", "}", "METHOD_END"], "methodName": ["getStrategyMap"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolver"}, {"methodBody": ["METHOD_START", "{", "VersionStrategy   versionStrategy    =    getStrategyForPath ( requestPath )  ;", "if    ( versionStrategy    =  =    null )     {", "return   Mono . empty (  )  ;", "}", "String   candidate    =    versionStrategy . extractVersion ( requestPath )  ;", "if    ( StringUtils . isEmpty ( candidate )  )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" No   version   found   in   path    \\  \"  \"     +    requestPath )     +     \"  \\  \"  \"  )  )  ;", "}", "return   Mono . empty (  )  ;", "}", "String   simplePath    =    versionStrategy . removeVersion ( requestPath ,    candidate )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" Extracted   version   from   path ,    re - resolving   without   version :     \\  \"  \"     +    simplePath )     +     \"  \\  \"  \"  )  )  ;", "}", "return   chain . resolveResource ( exchange ,    simplePath ,    locations )  . filterWhen (  (     )     -  >    versionStrategy . getResourceVersion (  )  . map (  (    actual )     -  >     {", "if    ( candidate . equals ( actual )  )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" Resource   matches   extracted   version    [  \"     +    candidate )     +     \"  ]  \"  )  )  ;", "}", "return   true ;", "} else    {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  (  \" Potential      found   for    \\  \"  \"     +    requestPath )     +     \"  \\  \"  ,     \"  )     +     \" but   version    [  \"  )     +    candidate )     +     \"  ]    does   not   match \"  )  )  ;", "}", "return   false ;", "}", "}  )  )  . map (  (     )     -  >    new   FileNameVersionedResource (  ,    candidate )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVersionedResource"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolver"}, {"methodBody": ["METHOD_START", "{", "this . versionStrategyMap . clear (  )  ;", "this . versionStrategyMap . putAll ( map )  ;", "}", "METHOD_END"], "methodName": ["setStrategyMap"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolver"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    VersionStrategy >    strategies    =    new   HashMap <  >  (  )  ;", "VersionStrategy   jsStrategy    =    mock ( VersionStrategy . class )  ;", "VersionStrategy   catchAllStrategy    =    mock ( VersionStrategy . class )  ;", "strategies . put (  \"  /  *  *  \"  ,    catchAllStrategy )  ;", "strategies . put (  \"  /  *  *  /  *  . js \"  ,    jsStrategy )  ;", "this . resolver . setStrategyMap ( strategies )  ;", "assertEquals ( catchAllStrategy ,    this . resolver . getStrategyForPath (  \" foo . css \"  )  )  ;", "assertEquals ( catchAllStrategy ,    this . resolver . getStrategyForPath (  \" foo - js . css \"  )  )  ;", "assertEquals ( jsStrategy ,    this . resolver . getStrategyForPath (  \" foo . js \"  )  )  ;", "assertEquals ( jsStrategy ,    this . resolver . getStrategyForPath (  \" bar / foo . js \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getStrategyForPath"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" bar . css \"  ;", "expected    =    new   ClassPath (  (  \" test /  \"     +    file )  ,    getClass (  )  )  ;", "given ( this . chain . resolve ( null ,    file ,    this . locations )  )  . willReturn ( Mono . just ( expected )  )  ;", "this . resolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    this . versionStrategy )  )  ;", "actual    =    this . resolver . resolveInternal ( null ,    file ,    this . locations ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals ( expected ,    actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolve ( null ,    file ,    this . locations )  ;", "verify ( this . versionStrategy ,    never (  )  )  . extractVersion ( file )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceExisting"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   versionFile    =     \" bar - version . css \"  ;", "String   version    =     \" version \"  ;", "String   file    =     \" bar . css \"  ;", "given ( this . chain . resolve ( null ,    versionFile ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "given ( this . chain . resolve ( null ,    file ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "given ( this . versionStrategy . extractVersion ( versionFile )  )  . willReturn ( version )  ;", "given ( this . versionStrategy . removeVersion ( versionFile ,    version )  )  . willReturn ( file )  ;", "this . resolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    this . versionStrategy )  )  ;", "actual    =    this . resolver . resolveInternal ( null ,    versionFile ,    this . locations ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertNull ( actual )  ;", "verify ( this . versionStrategy ,    times (  1  )  )  . removeVersion ( versionFile ,    version )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceNoResourceAfterVersionRemoved"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" bar . css \"  ;", "given ( this . chain . resolve ( null ,    file ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "given ( this . versionStrategy . extractVersion ( file )  )  . willReturn (  \"  \"  )  ;", "this . resolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    this . versionStrategy )  )  ;", "actual    =    this . resolver . resolveInternal ( null ,    file ,    this . locations ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertNull ( actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolve ( null ,    file ,    this . locations )  ;", "verify ( this . versionStrategy ,    times (  1  )  )  . extractVersion ( file )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceNoVersionInPath"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" missing . css \"  ;", "given ( this . chain . resolve ( null ,    file ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "this . resolver . setStrategyMap ( Collections . emptyMap (  )  )  ;", "actual    =    this . resolver . resolveInternal ( null ,    file ,    this . locations ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertNull ( actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolve ( null ,    file ,    this . locations )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceNoVersionStrategy"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   versionFile    =     \" bar - version . css \"  ;", "String   version    =     \" version \"  ;", "String   file    =     \" bar . css \"  ;", "expected    =    new   ClassPath (  (  \" test /  \"     +    file )  ,    getClass (  )  )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / resources / bar - version . css \"  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "given ( this . chain . resolve ( exchange ,    versionFile ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "given ( this . chain . resolve ( exchange ,    file ,    this . locations )  )  . willReturn ( Mono . just ( expected )  )  ;", "given ( this . versionStrategy . extractVersion ( versionFile )  )  . willReturn ( version )  ;", "given ( this . versionStrategy . removeVersion ( versionFile ,    version )  )  . willReturn ( file )  ;", "given ( this . versionStrategy . getVersion ( expected )  )  . willReturn ( Mono . just ( version )  )  ;", "this . resolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    this . versionStrategy )  )  ;", "actual    =    this . resolver . resolveInternal ( exchange ,    versionFile ,    this . locations ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals ( expected . getFilename (  )  ,    actual . getFilename (  )  )  ;", "verify ( this . versionStrategy ,    times (  1  )  )  . getVersion ( expected )  ;", "assertThat ( actual ,    instanceOf ( Http . class )  )  ;", "assertEquals (  (  (  \"  \\  \"  \"     +    version )     +     \"  \\  \"  \"  )  ,     (  ( Http )     ( actual )  )  . getResponseHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceSuccess"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   versionFile    =     \" bar - version . css \"  ;", "String   version    =     \" version \"  ;", "String   file    =     \" bar . css \"  ;", "expected    =    new   ClassPath (  (  \" test /  \"     +    file )  ,    getClass (  )  )  ;", "given ( this . chain . resolve ( null ,    versionFile ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "given ( this . chain . resolve ( null ,    file ,    this . locations )  )  . willReturn ( Mono . just ( expected )  )  ;", "given ( this . versionStrategy . extractVersion ( versionFile )  )  . willReturn ( version )  ;", "given ( this . versionStrategy . removeVersion ( versionFile ,    version )  )  . willReturn ( file )  ;", "given ( this . versionStrategy . getVersion ( expected )  )  . willReturn ( Mono . just (  \" newer - version \"  )  )  ;", "this . resolver . setStrategyMap ( Collections . singletonMap (  \"  /  *  *  \"  ,    this . versionStrategy )  )  ;", "actual    =    this . resolver . resolveInternal ( null ,    versionFile ,    this . locations ,    this . chain )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertNull ( actual )  ;", "verify ( this . versionStrategy ,    times (  1  )  )  . getVersion ( expected )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceVersionDoesNotMatch"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . chain . resolveUrlPath (  \"  / foo . css \"  ,    this . locations )  )  . willReturn ( Mono . just (  \"  / foo . css \"  )  )  ;", "String   resolved    =    this . r . resolveUrlPathInternal (  \"  / foo . css \"  ,    this . locations ,    this . chain )  . block ( Duration . ofMillis (  1  0  0  0  )  )  ;", "assertThat ( resolved ,    is (  \"  / foo . css \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveUrlPathNoVersionStrategy"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . locations    =    new   ArrayList (  )  ;", "this . locations . add ( new   ClassPathResource (  \" test /  \"  ,    getClass (  )  )  )  ;", "this . locations . add ( new   ClassPathResource (  \" testalternatepath /  \"  ,    getClass (  )  )  )  ;", "this . resolver    =    new    (  )  ;", "this . chain    =    mock ( ResourceResolverChain . class )  ;", "this . versionStrategy    =    mock ( VersionStrategy . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . addFixedVersionStrategy (  \" fixedversion \"  ,     \"  / js /  *  *  \"  ,     \"  / css /  *  *  \"  ,     \"  / fixedversion / css /  *  *  \"  )  ;", "assertThat ( this . resolver . getStrategyMap (  )  . size (  )  ,    is (  4  )  )  ;", "assertThat ( this . resolver . getStrategyForPath (  \" js / something . js \"  )  ,    Matchers . instanceOf ( FixedVersionStrategy . class )  )  ;", "assertThat ( this . resolver . getStrategyForPath (  \" fixedversion / js / something . js \"  )  ,    Matchers . instanceOf ( FixedVersionStrategy . class )  )  ;", "assertThat ( this . resolver . getStrategyForPath (  \" css / something . css \"  )  ,    Matchers . instanceOf ( FixedVersionStrategy . class )  )  ;", "assertThat ( this . resolver . getStrategyForPath (  \" fixedversion / css / something . css \"  )  ,    Matchers . instanceOf ( FixedVersionStrategy . class )  )  ;", "}", "METHOD_END"], "methodName": ["shouldConfigureFixedPrefixAutomatically"], "fileName": "org.springframework.web.reactive.resource.VersionResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "int   startOffset    =     ( path . startsWith (  \"  /  \"  )  )     ?     1     :     0  ;", "int   endOffset    =    path . indexOf (  '  /  '  ,     1  )  ;", "if    ( endOffset    !  =     (  -  1  )  )     {", "String   webjar    =    path . substring ( startOffset ,    endOffset )  ;", "String   partialPath    =    path . substring ( endOffset )  ;", "String   webJarPath    =    webJarAssetLocator . getFullPath ( webjar ,    partialPath )  ;", "return   webJarPath . substring (  . WEBJARS _ LOCATION _ LENGTH )  ;", "}", "}    catch    ( MultipleMatchesException   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" WebJar   version   conflict   for    \\  \"  \"     +    path )     +     \"  \\  \"  \"  )  ,    ex )  ;", "}", "}    catch    ( IllegalArgumentException   ex )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" No   WebJar   resource   found   for    \\  \"  \"     +    path )     +     \"  \\  \"  \"  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findWebJarResourcePath"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolver"}, {"methodBody": ["METHOD_START", "{", "Resource   expected    =    mock ( Resource . class )  ;", "this . locations    =    Collections . singletonList ( new   ClassPathResource (  \"  / META - INF / resources / webjars /  \"  ,    getClass (  )  )  )  ;", "String   file    =     \" foo /  2  .  3  / foo . txt \"  ;", "given ( this . chain . resolveResource ( this . exchange ,    file ,    this . locations )  )  . willReturn ( Mono . just ( expected )  )  ;", "Resource   actual    =    this . resolver . resolveResource ( this . exchange ,    file ,    this . locations ,    this . chain )  . block (  . TIMEOUT )  ;", "assertEquals ( expected ,    actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolveResource ( this . exchange ,    file ,    this . locations )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceExisting"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" something / something . js \"  ;", "given ( this . chain . resolveResource ( this . exchange ,    file ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "Resource   actual    =    this . resolver . resolveResource ( this . exchange ,    file ,    this . locations ,    this . chain )  . block (  . TIMEOUT )  ;", "assertNull ( actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolveResource ( this . exchange ,    file ,    this . locations )  ;", "verify ( this . chain ,    never (  )  )  . resolveResource ( this . exchange ,    null ,    this . locations )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceNotFound"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . locations    =    Collections . singletonList ( new   ClassPathResource (  \"  / META - INF / resources / webjars /  \"  ,    getClass (  )  )  )  ;", "String   file    =     \" underscorejs / underscore . js \"  ;", "given ( this . chain . resolveResource ( this . exchange ,    file ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "Resource   expected    =    mock ( Resource . class )  ;", "String   expectedPath    =     \" underscorejs /  1  .  8  .  3  / underscore . js \"  ;", "given ( this . chain . resolveResource ( this . exchange ,    expectedPath ,    this . locations )  )  . willReturn ( Mono . just ( expected )  )  ;", "Resource   actual    =    this . resolver . resolveResource ( this . exchange ,    file ,    this . locations ,    this . chain )  . block (  . TIMEOUT )  ;", "assertEquals ( expected ,    actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolveResource ( this . exchange ,    file ,    this . locations )  ;", "}", "METHOD_END"], "methodName": ["resolveResourceWebJar"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . locations    =    Collections . singletonList ( new   ClassPathResource (  \"  / META - INF / resources / webjars /  \"  ,    getClass (  )  )  )  ;", "String   file    =     \"  / foo /  2  .  3  / foo . txt \"  ;", "given ( this . chain . resolveUrlPath ( file ,    this . locations )  )  . willReturn ( Mono . just ( file )  )  ;", "String   actual    =    this . resolver . resolveUrlPath ( file ,    this . locations ,    this . chain )  . block (  . TIMEOUT )  ;", "assertEquals ( file ,    actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolveUrlPath ( file ,    this . locations )  ;", "}", "METHOD_END"], "methodName": ["resolveUrlExisting"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . locations    =    Collections . singletonList ( new   ClassPathResource (  \"  / META - INF / resources / webjars /  \"  ,    getClass (  )  )  )  ;", "String   file    =     \" foo / foo . txt \"  ;", "given ( this . chain . resolveUrlPath ( file ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "String   actual    =    this . resolver . resolveUrlPath ( file ,    this . locations ,    this . chain )  . block (  . TIMEOUT )  ;", "assertNull ( actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolveUrlPath ( file ,    this . locations )  ;", "verify ( this . chain ,    never (  )  )  . resolveUrlPath (  \" foo /  2  .  3  / foo . txt \"  ,    this . locations )  ;", "}", "METHOD_END"], "methodName": ["resolveUrlExistingNotInJarFile"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" underscorejs / underscore . js \"  ;", "String   expected    =     \" underscorejs /  1  .  8  .  3  / underscore . js \"  ;", "given ( this . chain . resolveUrlPath ( file ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "given ( this . chain . resolveUrlPath ( expected ,    this . locations )  )  . willReturn ( Mono . just ( expected )  )  ;", "String   actual    =    this . resolver . resolveUrlPath ( file ,    this . locations ,    this . chain )  . block (  . TIMEOUT )  ;", "assertEquals ( expected ,    actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolveUrlPath ( file ,    this . locations )  ;", "verify ( this . chain ,    times (  1  )  )  . resolveUrlPath ( expected ,    this . locations )  ;", "}", "METHOD_END"], "methodName": ["resolveUrlWebJarResource"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   file    =     \" something / something . js \"  ;", "given ( this . chain . resolveUrlPath ( file ,    this . locations )  )  . willReturn ( Mono . empty (  )  )  ;", "String   actual    =    this . resolver . resolveUrlPath ( file ,    this . locations ,    this . chain )  . block (  . TIMEOUT )  ;", "assertNull ( actual )  ;", "verify ( this . chain ,    times (  1  )  )  . resolveUrlPath ( file ,    this . locations )  ;", "verify ( this . chain ,    never (  )  )  . resolveUrlPath ( null ,    this . locations )  ;", "}", "METHOD_END"], "methodName": ["resolveUrlWebJarResourceNotFound"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . locations    =    Collections . singletonList ( new   ClassPathResource (  \"  / META - INF / resources / webjars \"  )  )  ;", "this . resolver    =    new    (  )  ;", "this . chain    =    mock ( ResourceResolverChain . class )  ;", "this . exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.resource.WebJarsResourceResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   getContentTypeResolver (  )  . resolveMediaTypes ( exchange )  ;", "}", "METHOD_END"], "methodName": ["getAcceptableTypes"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    returnType    =    result . getReturnType (  )  . getRawClass (  )  ;", "return   getAdapterRegistry (  )  . getAdapter ( returnType ,    result . getReturnValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAdapter"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . adapterRegistry ;", "}", "METHOD_END"], "methodName": ["getAdapterRegistry"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . contentTypeResolver ;", "}", "METHOD_END"], "methodName": ["getContentTypeResolver"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "Set < MediaType >    mediaTypes    =    exchange . getAttribute ( HandlerMapping . PRODUCIBLE _ MEDIA _ TYPES _ ATTRIBUTE )  ;", "return   mediaTypes    !  =    null    ?    new   ArrayList ( mediaTypes )     :    producibleTypesSupplier . get (  )  ;", "}", "METHOD_END"], "methodName": ["getProducibleTypes"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "MediaType   contentType    =    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  ;", "if    (  ( contentType    !  =    null )     &  &     ( contentType . isConcrete (  )  )  )     {", "return   contentType ;", "}", "List < MediaType >    acceptableTypes    =    getAcceptableTypes ( exchange )  ;", "List < MediaType >    producibleTypes    =    getProducibleTypes ( exchange ,    producibleTypesSupplier )  ;", "Set < MediaType >    compatibleMediaTypes    =    new   LinkedHashSet <  >  (  )  ;", "for    ( MediaType   acceptable    :    acceptableTypes )     {", "for    ( MediaType   producible    :    producibleTypes )     {", "if    ( acceptable . isCompatibleWith ( producible )  )     {", "compatibleMediaTypes . add ( selectMoreSpecificMediaType ( acceptable ,    producible )  )  ;", "}", "}", "}", "List < MediaType >    result    =    new   ArrayList ( compatibleMediaTypes )  ;", "MediaType . sortBySpecificityAndQuality ( result )  ;", "for    ( MediaType   mediaType    :    result )     {", "if    ( mediaType . isConcrete (  )  )     {", "return   mediaType ;", "} else", "if    (  ( mediaType . equals ( MediaType . ALL )  )     |  |     ( mediaType . equals (  . MEDIA _ TYPE _ APPLICATION _ ALL )  )  )     {", "return   MediaType . APPLICATION _ OCTET _ STREAM ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["selectMediaType"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "producible    =    producible . copyQualityValue ( acceptable )  ;", "Comparator < MediaType >    comparator    =    MediaType . SPECIFICITY _ COMPARATOR ;", "return    ( comparator . compare ( acceptable ,    producible )  )     <  =     0     ?    acceptable    :    producible ;", "}", "METHOD_END"], "methodName": ["selectMoreSpecificMediaType"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "MediaType   text 8  8  5  9     =    MediaType . parseMediaType (  \" text / plain ; charset = ISO -  8  8  5  9  -  1  \"  )  ;", "MediaType   textUtf 8     =    MediaType . parseMediaType (  \" text / plain ; charset = UTF -  8  \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path \"  )  . accept ( text 8  8  5  9  )  )  ;", "MediaType   actual    =    this . r . selectMediaType ( exchange ,     (  )     -  >    Collections . singletonList ( textUtf 8  )  )  ;", "assertEquals ( text 8  8  5  9  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["charsetFromAcceptHeader"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List < MediaType >    producible    =    Collections . singletonList ( MediaType . ALL )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path \"  )  )  ;", "MediaType   actual    =    this . r . selectMediaType ( exchange ,     (  )     -  >    producible )  ;", "assertEquals ( MediaType . APPLICATION _ OCTET _ STREAM ,    actual )  ;", "}", "METHOD_END"], "methodName": ["noConcreteMediaType"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path \"  )  )  ;", "exchange . getAttributes (  )  . put ( HandlerMapping . PRODUCIBLE _ MEDIA _ TYPES _ ATTRIBUTE ,    Collections . singleton ( MediaType . IMAGE _ GIF )  )  ;", "List < MediaType >    mediaTypes    =    Arrays . asList ( MediaType . IMAGE _ JPEG ,    MediaType . IMAGE _ GIF ,    MediaType . IMAGE _ PNG )  ;", "MediaType   actual    =    r . selectMediaType ( exchange ,     (  )     -  >    mediaTypes )  ;", "assertEquals ( MediaType . IMAGE _ GIF ,    actual )  ;", "}", "METHOD_END"], "methodName": ["producibleMediaTypesRequestAttribute"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path \"  )  . header (  \" Accept \"  ,     \" text / plain ;    q =  0  .  5  ,    application / json \"  )  )  ;", "List < MediaType >    mediaTypes    =    Arrays . asList ( MediaType . TEXT _ PLAIN ,    MediaType . APPLICATION _ JSON _ UTF 8  )  ;", "MediaType   actual    =    this . r . selectMediaType ( exchange ,     (  )     -  >    mediaTypes )  ;", "assertEquals ( MediaType . APPLICATION _ JSON _ UTF 8  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["sortsByQuality"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HandlerResultHandlerTests . TestResultHandler   resultHandler    =    new   HandlerResultHandlerTests . TestResultHandler ( new   FixedContentTypeResolver ( MediaType . IMAGE _ GIF )  )  ;", "List < MediaType >    mediaTypes    =    Arrays . asList ( MediaType . IMAGE _ JPEG ,    MediaType . IMAGE _ GIF ,    MediaType . IMAGE _ PNG )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path \"  )  )  ;", "MediaType   actual    =    resultHandler . selectMediaType ( exchange ,     (  )     -  >    mediaTypes )  ;", "assertEquals ( MediaType . IMAGE _ GIF ,    actual )  ;", "}", "METHOD_END"], "methodName": ["usesContentTypeResolver"], "fileName": "org.springframework.web.reactive.result.HandlerResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBuffer   buffer    =    new   DefaultDataBufferFactory (  )  . allocateBuffer (  )  ;", "return   buffer . write ( text . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["asDataBuffer"], "fileName": "org.springframework.web.reactive.result.SimpleUrlHandlerMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / oops \"  )  )  ;", "RequestEntity < Void >    request    =    RequestEntity . get ( url )  . build (  )  ;", "try    {", "new   RestTemplate (  )  . exchange ( request ,    byte [  ]  . class )  ;", "}    catch    ( HttpClientErrorExcep   ex )     {", "assertEquals ( NOT _ FOUND ,    ex . getStatusCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testHandlerNotFound"], "fileName": "org.springframework.web.reactive.result.SimpleUrlHandlerMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / bar \"  )  )  ;", "RequEntity < Void >    requ    =    RequEntity . get ( url )  . build (  )  ;", "ResponseEntity < byte [  ]  >    response    =    new   RTemplate (  )  . exchange ( requ ,    byte [  ]  . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertArrayEquals (  \" bar \"  . getBytes (  \" UTF -  8  \"  )  ,    response . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRequestToBarHandler"], "fileName": "org.springframework.web.reactive.result.SimpleUrlHandlerMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / foo \"  )  )  ;", "RequEntity < Void >    requ    =    RequEntity . get ( url )  . build (  )  ;", "ResponseEntity < byte [  ]  >    response    =    new   RTemplate (  )  . exchange ( requ ,    byte [  ]  . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertArrayEquals (  \" foo \"  . getBytes (  \" UTF -  8  \"  )  ,    response . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRequestToFooHandler"], "fileName": "org.springframework.web.reactive.result.SimpleUrlHandlerMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   url    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / header \"  )  )  ;", "RequEntity < Void >    requ    =    RequEntity . get ( url )  . build (  )  ;", "ResponseEntity < byte [  ]  >    response    =    new   RTemplate (  )  . exchange ( requ ,    byte [  ]  . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  \" bar \"  ,    response . getHeaders (  )  . getFirst (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRequestToHeaderSettingHandler"], "fileName": "org.springframework.web.reactive.result.SimpleUrlHandlerMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "boolean   match    =    match ( exchange )  ;", "return    (  !  ( this . isNegated )  )     =  =    match ;", "}    catch    ( NotAcceptableStatusException    |    UnsupportedStatusException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.web.reactive.result.condition.AbstractMediaTypeExpression"}, {"methodBody": ["METHOD_START", "{", "boolean   isMatch ;", "if    (  ( this . value )     !  =    null )     {", "isMatch    =    match ( exchange )  ;", "} else    {", "isMatch    =    matchName ( exchange )  ;", "}", "return    ( this . isNegated )     !  =    isMatch ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.web.reactive.result.condition.AbstractNameValueExpression"}, {"methodBody": ["METHOD_START", "{", "return   getContent (  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.web.reactive.result.condition.AbstractRequestCondition"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( getLength (  )  )     =  =     ( other . getLength (  )  )  )  ,     (  (  (  \" Cannot   combine   CompositeRequestConditions   with   a   different   number   of   conditions .     \"     +     ( ObjectUtils . nullSafeToString ( this . requestConditions )  )  )     +     \"    and       \"  )     +     ( ObjectUtils . nullSafeToString ( other . requestConditions )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumberOfConditions"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   unwrap (  )  ;", "}", "METHOD_END"], "methodName": ["getConditions"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   this . requestConditions . length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestCondition"}, {"methodBody": ["METHOD_START", "{", "List < RequestCondition <  ?  >  >    result    =    new   ArrayList <  >  (  )  ;", "for    ( RequestConditionHolder   holder    :    this . requestConditions )     {", "result . add ( holder . getCondition (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["unwrap"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestCondition"}, {"methodBody": ["METHOD_START", "{", "RequestConditionHolder [  ]    wrappedConditions    =    new   RequestConditionHolder [ rawConditions . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( rawConditions . length )  ;    i +  +  )     {", "wrappedConditions [ i ]     =    new   RequestConditionHolder ( rawConditions [ i ]  )  ;", "}", "return   wrappedConditions ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestCondition"}, {"methodBody": ["METHOD_START", "{", "CompositeRequestCondition   cond 1     =    new   CompositeRequestCondition ( this . param 1  ,    this . header 1  )  ;", "CompositeRequestCondition   cond 2     =    new   CompositeRequestCondition ( this . param 2  ,    this . header 2  )  ;", "CompositeRequestCondition   cond 3     =    new   CompositeRequestCondition ( this . param 3  ,    this . header 3  )  ;", "assertEquals ( cond 3  ,    cond 1  . combine ( cond 2  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "CompositeRequestCondition   cond 1     =    new   CompositeRequestCondition ( this . param 1  )  ;", "CompositeRequestCondition   cond 2     =    new   CompositeRequestCondition ( this . param 1  ,    this . header 1  )  ;", "cond 1  . combine ( cond 2  )  ;", "}", "METHOD_END"], "methodName": ["combineDifferentLength"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "CompositeRequestCondition   empty    =    new   CompositeRequestCondition (  )  ;", "CompositeRequestCondition   notEmpty    =    new   CompositeRequestCondition ( this . param 1  )  ;", "assertSame ( empty ,    empty . combine ( empty )  )  ;", "assertSame ( notEmpty ,    notEmpty . combine ( empty )  )  ;", "assertSame ( notEmpty ,    empty . combine ( notEmpty )  )  ;", "}", "METHOD_END"], "methodName": ["combineEmpty"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "CompositeRequestCondition   cond 1     =    new   CompositeRequestCondition ( this . param 1  )  ;", "CompositeRequestCondition   cond 3     =    new   CompositeRequestCondition ( this . param 3  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "assertEquals (  1  ,    cond 1  . compareTo ( cond 3  ,    exchange )  )  ;", "assertEquals (  (  -  1  )  ,    cond 3  . compareTo ( cond 1  ,    exchange )  )  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "CompositeRequestCondition   cond 1     =    new   CompositeRequestCondition ( this . param 1  )  ;", "CompositeRequestCondition   cond 2     =    new   CompositeRequestCondition ( this . param 1  ,    this . header 1  )  ;", "cond 1  . compareTo ( cond 2  ,    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareDifferentLength"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "CompositeRequestCondition   empty    =    new   CompositeRequestCondition (  )  ;", "CompositeRequestCondition   notEmpty    =    new   CompositeRequestCondition ( this . param 1  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "assertEquals (  0  ,    empty . compareTo ( empty ,    exchange )  )  ;", "assertEquals (  (  -  1  )  ,    notEmpty . compareTo ( empty ,    exchange )  )  ;", "assertEquals (  1  ,    empty . compareTo ( notEmpty ,    exchange )  )  ;", "}", "METHOD_END"], "methodName": ["compareEmpty"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / path ? param 1  = paramValue 1  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "RequestCondition <  ?  >    condition 1     =    new   RequestMethodsRequestCondition ( RequestMethod . GET ,    RequestMethod . POST )  ;", "RequestCondition <  ?  >    condition 2     =    new   RequestMethodsRequestCondition ( RequestMethod . GET )  ;", "composite 1     =    new    ( this . param 1  ,    condition 1  )  ;", "composite 2     =    new    ( this . param 1  ,    condition 2  )  ;", "assertEquals ( composite 2  ,    composite 1  . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "CompositeRequestCondition   empty    =    new   CompositeRequestCondition (  )  ;", "assertSame ( empty ,    empty . getMatchingCondition ( MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["matchEmpty"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "CompositeRequestCondition   cond    =    new   CompositeRequestCondition ( this . param 1  )  ;", "assertNull ( cond . getMatchingCondition ( MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["noMatch"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "this . param 1     =    new   ParamsRequestCondition (  \" param 1  \"  )  ;", "this . param 2     =    new   ParamsRequestCondition (  \" param 2  \"  )  ;", "this . param 3     =    this . param 1  . combine ( this . param 2  )  ;", "this . header 1     =    new   HeadersRequestCondition (  \" header 1  \"  )  ;", "this . header 2     =    new   HeadersRequestCondition (  \" header 2  \"  )  ;", "this . header 3     =    this . header 1  . combine ( this . header 2  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.condition.CompositeRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "Set < MediaType >    result    =    new   LinkedHashSet <  >  (  )  ;", "for    (  . ConsumeMediaTypeExpression   expression    :    this . expressions )     {", "if    (  !  ( expression . isNegated (  )  )  )     {", "result . add ( expression . getMediaType (  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getConsumableMediaTypes"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashSet <  >  ( this . expressions )  ;", "}", "METHOD_END"], "methodName": ["getExpressions"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   this . expressions . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "Set < ConsumesRequestCondition . ConsumeMediaTypeExpression >    result    =    new   LinkedHashSet <  >  (  )  ;", "if    ( headers    !  =    null )     {", "for    ( String   header    :    headers )     {", "HeadersRequestCondition . HeaderExpression   expr    =    new   HeadersRequestCondition . HeaderExpression ( header )  ;", "if    (  \" Content - Type \"  . equalsIgnoreCase ( expr . name )  )     {", "for    ( MediaType   mediaType    :    MediaType . parseMediaTypes ( expr . value )  )     {", "result . add ( new   ConsumesRequestCondition . ConsumeMediaTypeExpression ( mediaType ,    expr . isNegated )  )  ;", "}", "}", "}", "}", "if    ( consumes    !  =    null )     {", "for    ( String   consume    :    consumes )     {", "result . add ( new   ConsumesRequestCondition . ConsumeMediaTypeExpression ( consume )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseExpressions"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "Collection < ConsumesRequestCondition . ConsumeMediaTypeExpression >    expressions    =    condition . getContent (  )  ;", "assertEquals (  \" Invalid   amount   of   conditions \"  ,    expressions . size (  )  ,    expected . length )  ;", "for    ( String   s    :    expected )     {", "boolean   found    =    false ;", "for    ( ConsumesRequestCondition . ConsumeMediaTypeExpression   expr    :    expressions )     {", "String   conditionMediaType    =    expr . getMediaType (  )  . toString (  )  ;", "if    ( conditionMediaType . equals ( s )  )     {", "found    =    true ;", "break ;", "}", "}", "if    (  ! found )     {", "fail (  (  (  \" Condition    [  \"     +    s )     +     \"  ]    not   found \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertConditions"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ConsumesRequestCondition   condition 1     =    new   ConsumesRequestCondition (  \" text / plain \"  )  ;", "ConsumesRequestCondition   condition 2     =    new   ConsumesRequestCondition (  \" application / xml \"  )  ;", "ConsumesRequestCondition   result    =    condition 1  . combine ( condition 2  )  ;", "assertEquals ( condition 2  ,    result )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ConsumesRequestCondition   condition 1     =    new   ConsumesRequestCondition (  \" text / plain \"  )  ;", "ConsumesRequestCondition   condition 2     =    new   ConsumesRequestCondition (  )  ;", "ConsumesRequestCondition   result    =    condition 1  . combine ( condition 2  )  ;", "assertEquals ( condition 1  ,    result )  ;", "}", "METHOD_END"], "methodName": ["combineWithDefault"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "condition 1     =    new    (  \"  *  /  *  \"  ,     \" text / plain \"  )  ;", "condition 2     =    new    (  \" text /  *  \"  ,     \" text / plain ; q =  0  .  7  \"  )  ;", "int   result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToMultiple"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "condition 1     =    new    (  \" text / plain \"  )  ;", "condition 2     =    new    (  \" text /  *  \"  )  ;", "int   result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToSingle"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    postExchange (  \" text / plain \"  )  ;", "condition    =    new    (  \" text / plain \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["consumesMatch"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    postExchange (  \" text / plain \"  )  ;", "condition    =    new    (  \" text / plain \"  ,     \" application / xml \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["consumesMultipleMatch"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    postExchange (  \"  0  1  \"  )  ;", "condition    =    new    (  \" text / plain \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["consumesParseError"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    postExchange (  \"  0  1  \"  )  ;", "condition    =    new    (  \"  ! text / plain \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["consumesParseErrorWithNegation"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    postExchange (  \" application / xml \"  )  ;", "condition    =    new    (  \" text / plain \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["consumesSingleNoMatch"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    postExchange (  \" text / plain \"  )  ;", "condition    =    new    (  \" text /  *  \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["consumesWildcardMatch"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ConsumesRequestCondition   condition    =    new   ConsumesRequestCondition (  \"  ! application / xml \"  )  ;", "assertEquals ( Collections . emptySet (  )  ,    condition . getConsumableMediaTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["getConsumableMediaTypesNegatedExpression"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    postExchange (  \" text / plain \"  )  ;", "condition    =    new    (  \" text / plain \"  ,     \" application / xml \"  )  ;", "result    =    condition . getMatchingCondition ( exchange )  ;", "assertConditions ( result ,     \" text / plain \"  )  ;", "condition    =    new    (  \" application / xml \"  )  ;", "result    =    condition . getMatchingCondition ( exchange )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["getMatchingCondition"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    postExchange (  \" text / plain \"  )  ;", "condition    =    new    (  \"  ! text / plain \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["negatedConsumesMatch"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    consumes    =    new   String [  ]  {     \" text / plain \"     }  ;", "String [  ]    headers    =    new   String [  ]  {     \" foo = bar \"  ,     \" content - type = application / xml , application / pdf \"     }  ;", "condition    =    new    ( consumes ,    headers )  ;", "assertConditions ( condition ,     \" text / plain \"  ,     \" application / xml \"  ,     \" application / pdf \"  )  ;", "}", "METHOD_END"], "methodName": ["parseConsumesAndHeaders"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( MockServerHttpRequest . post (  \"  /  \"  )  . header ( CONTENT _ TYPE ,    contentType )  )  ;", "}", "METHOD_END"], "methodName": ["postExchange"], "fileName": "org.springframework.web.reactive.result.condition.ConsumesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashSet <  >  ( this . expressions )  ;", "}", "METHOD_END"], "methodName": ["getExpressions"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestCondition"}, {"methodBody": ["METHOD_START", "{", "Set < HeadersRequestCondition . HeaderExpression >    expressions    =    new   LinkedHashSet <  >  (  )  ;", "if    ( headers    !  =    null )     {", "for    ( String   header    :    headers )     {", "HeadersRequestCondition . HeaderExpression   expr    =    new   HeadersRequestCondition . HeaderExpression ( header )  ;", "if    (  (  \" Accept \"  . equalsIgnoreCase ( expr . name )  )     |  |     (  \" Content - Type \"  . equalsIgnoreCase ( expr . name )  )  )     {", "continue ;", "}", "expressions . add ( expr )  ;", "}", "}", "return   expressions ;", "}", "METHOD_END"], "methodName": ["parseExpressions"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestCondition"}, {"methodBody": ["METHOD_START", "{", "HeadersRequestCondition   condition 1     =    new   HeadersRequestCondition (  \" foo = bar \"  )  ;", "HeadersRequestCondition   condition 2     =    new   HeadersRequestCondition (  \" foo = baz \"  )  ;", "HeadersRequestCondition   result    =    condition 1  . combine ( condition 2  )  ;", "Collection <  ?  >    conditions    =    result . getContent (  )  ;", "assertEquals (  2  ,    conditions . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "condition 1     =    new    (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "condition 2     =    new    (  \" foo \"  ,     \" bar \"  )  ;", "int   result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" foo \"  ,     \" bar \"  )  )  ;", "condition    =    new    (  \" foo \"  )  ;", "result    =    condition . getMatchingCondition ( exchange )  ;", "assertEquals ( condition ,    result )  ;", "condition    =    new    (  \" bar \"  )  ;", "result    =    condition . getMatchingCondition ( exchange )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["getMatchingCondition"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" foo \"  ,     \" bar \"  )  )  ;", "condition    =    new    (  \" foo = Bar \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["headerCaseSensitiveValueMatch"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   HeadersRequestCondition (  \" foo \"  )  ,    new   HeadersRequestCondition (  \" foo \"  )  )  ;", "assertEquals ( new   HeadersRequestCondition (  \" foo \"  )  ,    new   HeadersRequestCondition (  \" FOO \"  )  )  ;", "assertFalse ( new   HeadersRequestCondition (  \" foo \"  )  . equals ( new   HeadersRequestCondition (  \" bar \"  )  )  )  ;", "assertEquals ( new   HeadersRequestCondition (  \" foo = bar \"  )  ,    new   HeadersRequestCondition (  \" foo = bar \"  )  )  ;", "assertEquals ( new   HeadersRequestCondition (  \" foo = bar \"  )  ,    new   HeadersRequestCondition (  \" FOO = bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headerEquals"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "condition    =    new    (  \"  ! accept \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["headerNotPresent"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" Accept \"  ,     \"  \"  )  )  ;", "condition    =    new    (  \" accept \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["headerPresent"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" bar \"  ,     \"  \"  )  )  ;", "condition    =    new    (  \" foo \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["headerPresentNoMatch"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" foo \"  ,     \" bar \"  )  )  ;", "condition    =    new    (  \" foo = bar \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["headerValueMatch"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" foo \"  ,     \" baz \"  )  )  ;", "condition    =    new    (  \" foo !  = bar \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["headerValueMatchNegated"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" foo \"  ,     \" bazz \"  )  )  ;", "condition    =    new    (  \" foo = bar \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["headerValueNoMatch"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" foo \"  ,     \" bar \"  )  )  ;", "condition    =    new    (  \" foo !  = bar \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["headerValueNoMatchNegated"], "fileName": "org.springframework.web.reactive.result.condition.HeadersRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashSet <  >  ( this . expressions )  ;", "}", "METHOD_END"], "methodName": ["getExpressions"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "Set < ParamsRequestCondition . ParamExpression >    expressions    =    new   LinkedHashSet <  >  (  )  ;", "if    ( params    !  =    null )     {", "for    ( String   param    :    params )     {", "expressions . add ( new   ParamsRequestCondition . ParamExpression ( param )  )  ;", "}", "}", "return   expressions ;", "}", "METHOD_END"], "methodName": ["parseExpressions"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "ParamsRequestCondition   condition 1     =    new   ParamsRequestCondition (  \" foo = bar \"  )  ;", "ParamsRequestCondition   condition 2     =    new   ParamsRequestCondition (  \" foo = baz \"  )  ;", "ParamsRequestCondition   result    =    condition 1  . combine ( condition 2  )  ;", "Collection <  ?  >    conditions    =    result . getContent (  )  ;", "assertEquals (  2  ,    conditions . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  )  ;", "condition 1     =    new    (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  ;", "condition 2     =    new    (  \" foo \"  ,     \" bar \"  )  ;", "int   result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   ParamsRequestCondition (  \" foo \"  )  ,    new   ParamsRequestCondition (  \" foo \"  )  )  ;", "assertFalse ( new   ParamsRequestCondition (  \" foo \"  )  . equals ( new   ParamsRequestCondition (  \" bar \"  )  )  )  ;", "assertFalse ( new   ParamsRequestCondition (  \" foo \"  )  . equals ( new   ParamsRequestCondition (  \" FOO \"  )  )  )  ;", "assertEquals ( new   ParamsRequestCondition (  \" foo = bar \"  )  ,    new   ParamsRequestCondition (  \" foo = bar \"  )  )  ;", "assertFalse ( new   ParamsRequestCondition (  \" foo = bar \"  )  . equals ( new   ParamsRequestCondition (  \" FOO = bar \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paramEquals"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  )  ;", "assertNotNull ( new    (  \"  ! foo \"  )  . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["paramNotPresent"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ParamsRequestCondition   condition    =    new   ParamsRequestCondition (  \" foo \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( MockServerWebExchange . from ( get (  \"  / path ? foo =  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paramPresent"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ParamsRequestCondition   condition    =    new   ParamsRequestCondition (  \" foo \"  )  ;", "assertNull ( condition . getMatchingCondition ( MockServerWebExchange . from ( get (  \"  / path ? bar =  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paramPresentNoMatch"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ParamsRequestCondition   condition    =    new   ParamsRequestCondition (  \" foo \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( MockServerWebExchange . from ( get (  \"  / path ? foo \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paramPresentNullValue"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ParamsRequestCondition   condition    =    new   ParamsRequestCondition (  \" foo = bar \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( MockServerWebExchange . from ( get (  \"  / path ? foo = bar \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paramValueMatch"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ParamsRequestCondition   condition    =    new   ParamsRequestCondition (  \" foo = bar \"  )  ;", "assertNull ( condition . getMatchingCondition ( MockServerWebExchange . from ( get (  \"  / path ? foo = bazz \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paramValueNoMatch"], "fileName": "org.springframework.web.reactive.result.condition.ParamsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PathContainer   lookupPath    =    exchange . getRequest (  )  . getPath (  )  . pathWithinApplication (  )  ;", "return   patterns . stream (  )  . filter (  (    pattern )     -  >    pattern . matches ( lookupPath )  )  . collect ( Collectors . toCollection ( TreeSet :  : new )  )  ;", "}", "METHOD_END"], "methodName": ["getMatchingPatterns"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   this . patterns ;", "}", "METHOD_END"], "methodName": ["getPatterns"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "TreeSet < PathPattern >    sorted    =    new   TreeSet <  >  (  )  ;", "sorted . addAll ( patterns )  ;", "return   sorted ;", "}", "METHOD_END"], "methodName": ["toSortedSet"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   c 1     =    new   PatternsRequestCondition (  )  ;", "PatternsRequestCondition   c 2     =    new   PatternsRequestCondition (  )  ;", "assertEquals ( createPatternsCondition (  )  ,    c 1  . combine ( c 2  )  )  ;", "}", "METHOD_END"], "methodName": ["combineEmptySets"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   c 1     =    createPatternsCondition (  \"  / t 1  \"  ,     \"  / t 2  \"  )  ;", "PatternsRequestCondition   c 2     =    createPatternsCondition (  \"  / m 1  \"  ,     \"  / m 2  \"  )  ;", "assertEquals ( createPatternsCondition (  \"  / t 1  / m 1  \"  ,     \"  / t 1  / m 2  \"  ,     \"  / t 2  / m 1  \"  ,     \"  / t 2  / m 2  \"  )  ,    c 1  . combine ( c 2  )  )  ;", "}", "METHOD_END"], "methodName": ["combineMultiplePatterns"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   c 1     =    createPatternsCondition (  \"  / type 1  \"  ,     \"  / type 2  \"  )  ;", "PatternsRequestCondition   c 2     =    new   PatternsRequestCondition (  )  ;", "assertEquals ( createPatternsCondition (  \"  / type 1  \"  ,     \"  / type 2  \"  )  ,    c 1  . combine ( c 2  )  )  ;", "c 1     =    new   PatternsRequestCondition (  )  ;", "c 2     =    createPatternsCondition (  \"  / method 1  \"  ,     \"  / method 2  \"  )  ;", "assertEquals ( createPatternsCondition (  \"  / method 1  \"  ,     \"  / method 2  \"  )  ,    c 1  . combine ( c 2  )  )  ;", "}", "METHOD_END"], "methodName": ["combineOnePatternWithEmptySet"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo . html \"  )  )  ;", "c 1     =    createPatternsCondition (  \"  / foo .  *  \"  ,     \"  / foo . jpeg \"  )  ;", "c 2     =    createPatternsCondition (  \"  / foo .  *  \"  ,     \"  / foo . html \"  )  ;", "match 1     =    c 1  . getMatchingCondition ( exchange )  ;", "match 2     =    c 2  . getMatchingCondition ( exchange )  ;", "assertNotNull ( match 1  )  ;", "assertEquals (  1  ,    match 1  . compareTo ( match 2  ,    exchange )  )  ;", "}", "METHOD_END"], "methodName": ["compareNumberOfMatchingPatterns"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo \"  )  )  ;", "c 1     =    createPatternsCondition (  \"  / fo *  \"  )  ;", "c 2     =    createPatternsCondition (  \"  / foo \"  )  ;", "assertEquals (  1  ,    c 1  . compareTo ( c 2  ,    exchange )  )  ;", "c 1     =    createPatternsCondition (  \"  / fo *  \"  )  ;", "c 2     =    createPatternsCondition (  \"  /  * oo \"  )  ;", "assertEquals (  \" Patterns   are   equally   specific   even   if   not   the   same \"  ,     0  ,    c 1  . compareTo ( c 2  ,    exchange )  )  ;", "}", "METHOD_END"], "methodName": ["comparePatternSpecificity"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   c 1     =    createPatternsCondition (  \"  / foo *  \"  )  ;", "PatternsRequestCondition   c 2     =    createPatternsCondition (  \"  / foo *  \"  )  ;", "assertEquals (  0  ,    c 1  . compareTo ( c 2  ,    MockServerWebExchange . from ( get (  \"  / foo \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToConsistentWithEquals"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   PatternsRequestCondition ( Arrays . stream ( patterns )  . map (  (    rawPattern )     -  >    this . parser . parse ( rawPattern )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createPatternsCondition"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   c    =    createPatternsCondition (  \"  / a \"  ,     \"  / b \"  )  ;", "assertEquals (  2  ,    c . getPatterns (  )  . size (  )  )  ;", "Iterator < PathPattern >    itr    =    c . getPatterns (  )  . iterator (  )  ;", "assertEquals (  \"  / a \"  ,    itr . next (  )  . getPatternString (  )  )  ;", "assertEquals (  \"  / b \"  ,    itr . next (  )  . getPatternString (  )  )  ;", "}", "METHOD_END"], "methodName": ["equallyMatchingPatternsAreBothPresent"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   condition    =    createPatternsCondition (  \"  / foo \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo \"  )  )  ;", "PatternsRequestCondition   match    =    condition . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchDirectPath"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   condition    =    createPatternsCondition (  \"  / foo /  *  \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo / bar \"  )  )  ;", "PatternsRequestCondition   match    =    condition . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchPattern"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   condition    =    createPatternsCondition (  \"  / foo . jpg \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo . html \"  )  )  ;", "PatternsRequestCondition   match    =    condition . getMatchingCondition ( exchange )  ;", "assertNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchPatternContainsExtension"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   condition    =    createPatternsCondition (  \"  /  *  /  *  \"  ,     \"  / foo / bar \"  ,     \"  / foo /  *  \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo / bar \"  )  )  ;", "PatternsRequestCondition   match    =    condition . getMatchingCondition ( exchange )  ;", "PatternsRequestCondition   expected    =    createPatternsCondition (  \"  / foo / bar \"  ,     \"  / foo /  *  \"  ,     \"  /  *  /  *  \"  )  ;", "assertEquals ( expected ,    match )  ;", "}", "METHOD_END"], "methodName": ["matchSortPatterns"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo /  \"  )  )  ;", "condition    =    createPatternsCondition (  \"  / foo \"  )  ;", "match    =    condition . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "assertEquals (  \" Should   match   by   default \"  ,     \"  / foo \"  ,    match . getPatterns (  )  . iterator (  )  . next (  )  . getPatternString (  )  )  ;", "condition    =    createPatternsCondition (  \"  / foo \"  )  ;", "match    =    condition . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "assertEquals (  \" Trailing   slash   should   be   insensitive   to   useSuffixPatternMatch   settings    ( SPR -  6  1  6  4  ,    SPR -  5  6  3  6  )  \"  ,     \"  / foo \"  ,    match . getPatterns (  )  . iterator (  )  . next (  )  . getPatternString (  )  )  ;", "PathPatternParser   parser    =    new   PathPatternParser (  )  ;", "parser . setMatchOptionalTrailingSeparator ( false )  ;", "condition    =    new    ( parser . parse (  \"  / foo \"  )  )  ;", "match    =    condition . getMatchingCondition ( MockServerWebExchange . from ( get (  \"  / foo /  \"  )  )  )  ;", "assertNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchTrailingSlash"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "PatternsRequestCondition   c    =    createPatternsCondition (  \"  \"  )  ;", "assertEquals (  \" Do   not   prepend   empty   patterns    ( SPR -  8  2  5  5  )  \"  ,     \"  \"  ,    c . getPatterns (  )  . iterator (  )  . next (  )  . getPatternString (  )  )  ;", "}", "METHOD_END"], "methodName": ["prependNonEmptyPatternsOnly"], "fileName": "org.springframework.web.reactive.result.condition.PatternsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "if    ( index 1     !  =    index 2  )     {", "result    =    index 2     -    index 1  ;", "} else", "if    ( index 1     !  =     (  -  1  )  )     {", ". ProduceMediaTypeExpression   expr 1     =    condition 1  . getExpressionsToCompare (  )  . get ( index 1  )  ;", ". ProduceMediaTypeExpression   expr 2     =    condition 2  . getExpressionsToCompare (  )  . get ( index 2  )  ;", "result    =    expr 1  . compareTo ( expr 2  )  ;", "result    =     ( result    !  =     0  )     ?    result    :    expr 1  . getMediaType (  )  . compareTo ( expr 2  . getMediaType (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["compareMatchingMediaTypes"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   this . contentTypeResolver . resolveMediaTypes ( exchange )  ;", "}", "METHOD_END"], "methodName": ["getAcceptedMediaTypes"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashSet <  >  ( this . expressions )  ;", "}", "METHOD_END"], "methodName": ["getExpressions"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   this . expressions . isEmpty (  )     ?    mediaTypeAllList    :    this . expressions ;", "}", "METHOD_END"], "methodName": ["getExpressionsToCompare"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "Set < MediaType >    result    =    new   LinkedHashSet <  >  (  )  ;", "for    (  . ProduceMediaTypeExpression   expression    :    this . expressions )     {", "if    (  !  ( expression . isNegated (  )  )  )     {", "result . add ( expression . getMediaType (  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getProducibleMediaTypes"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( getExpressionsToCompare (  )  . size (  )  )  ;    i +  +  )     {", "MediaType   currentMediaType    =    getExpressionsToCompare (  )  . get ( i )  . getMediaType (  )  ;", "if    (  ( mediaType . getType (  )  . equalsIgnoreCase ( currentMediaType . getType (  )  )  )     &  &     ( mediaType . getSubtype (  )  . equalsIgnoreCase ( currentMediaType . getSubtype (  )  )  )  )     {", "return   i ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOfEqualMediaType"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( getExpressionsToCompare (  )  . size (  )  )  ;    i +  +  )     {", "if    ( mediaType . includes ( getExpressionsToCompare (  )  . get ( i )  . getMediaType (  )  )  )     {", "return   i ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOfIncludedMediaType"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "Set < ProducesRequestCondition . ProduceMediaTypeExpression >    result    =    new   LinkedHashSet <  >  (  )  ;", "if    ( headers    !  =    null )     {", "for    ( String   header    :    headers )     {", "HeadersRequestCondition . HeaderExpression   expr    =    new   HeadersRequestCondition . HeaderExpression ( header )  ;", "if    (  \" Accept \"  . equalsIgnoreCase ( expr . name )  )     {", "for    ( MediaType   mediaType    :    MediaType . parseMediaTypes ( expr . value )  )     {", "result . add ( new   ProducesRequestCondition . ProduceMediaTypeExpression ( mediaType ,    expr . isNegated )  )  ;", "}", "}", "}", "}", "if    ( produces    !  =    null )     {", "for    ( String   produce    :    produces )     {", "result . add ( new   ProducesRequestCondition . ProduceMediaTypeExpression ( produce )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseExpressions"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestCondition"}, {"methodBody": ["METHOD_START", "{", "Collection < ProducesRequestCondition . ProduceMediaTypeExpression >    expressions    =    condition . getContent (  )  ;", "assertEquals (  \" Invalid   number   of   conditions \"  ,    expressions . size (  )  ,    expected . length )  ;", "for    ( String   s    :    expected )     {", "boolean   found    =    false ;", "for    ( ProducesRequestCondition . ProduceMediaTypeExpression   expr    :    expressions )     {", "String   conditionMediaType    =    expr . getMediaType (  )  . toString (  )  ;", "if    ( conditionMediaType . equals ( s )  )     {", "found    =    true ;", "break ;", "}", "}", "if    (  ! found )     {", "fail (  (  (  \" Condition    [  \"     +    s )     +     \"  ]    not   found \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertConditions"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ProducesRequestCondition   condition 1     =    new   ProducesRequestCondition (  \" text / plain \"  )  ;", "ProducesRequestCondition   condition 2     =    new   ProducesRequestCondition (  \" application / xml \"  )  ;", "ProducesRequestCondition   result    =    condition 1  . combine ( condition 2  )  ;", "assertEquals ( condition 2  ,    result )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ProducesRequestCondition   condition 1     =    new   ProducesRequestCondition (  \" text / plain \"  )  ;", "ProducesRequestCondition   condition 2     =    new   ProducesRequestCondition (  )  ;", "ProducesRequestCondition   result    =    condition 1  . combine ( condition 2  )  ;", "assertEquals ( condition 1  ,    result )  ;", "}", "METHOD_END"], "methodName": ["combineWithDefault"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ProducesRequestCondition   html    =    new   ProducesRequestCondition (  \" text / html \"  )  ;", "ProducesRequestCondition   xml    =    new   ProducesRequestCondition (  \" application / xml \"  )  ;", "ProducesRequestCondition   none    =    new   ProducesRequestCondition (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" application / xml ,    text / html \"  )  )  ;", "assertTrue (  (  ( html . compareTo ( xml ,    exchange )  )     >     0  )  )  ;", "assertTrue (  (  ( xml . compareTo ( html ,    exchange )  )     <     0  )  )  ;", "assertTrue (  (  ( xml . compareTo ( none ,    exchange )  )     <     0  )  )  ;", "assertTrue (  (  ( none . compareTo ( xml ,    exchange )  )     >     0  )  )  ;", "assertTrue (  (  ( html . compareTo ( none ,    exchange )  )     <     0  )  )  ;", "assertTrue (  (  ( none . compareTo ( html ,    exchange )  )     >     0  )  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" application / xml ,    text /  *  \"  )  )  ;", "assertTrue (  (  ( html . compareTo ( xml ,    exchange )  )     >     0  )  )  ;", "assertTrue (  (  ( xml . compareTo ( html ,    exchange )  )     <     0  )  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" application / pdf \"  )  )  ;", "assertTrue (  (  ( html . compareTo ( xml ,    exchange )  )     =  =     0  )  )  ;", "assertTrue (  (  ( xml . compareTo ( html ,    exchange )  )     =  =     0  )  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / html ; q =  0  .  9  , application / xml \"  )  )  ;", "assertTrue (  (  ( html . compareTo ( xml ,    exchange )  )     >     0  )  )  ;", "assertTrue (  (  ( xml . compareTo ( html ,    exchange )  )     <     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text /  *  \"  )  )  ;", "condition 1     =    new    (  \" text / plain \"  )  ;", "condition 2     =    new    (  \" text / xhtml \"  )  ;", "int   result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  \" Should   have   used   MediaType . equals ( Object )    to   break   the   match \"  ,     ( result    <     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  \" Should   have   used   MediaType . equals ( Object )    to   break   the   match \"  ,     ( result    >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToEqualMatch"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  )  ;", "condition 1     =    new    (  )  ;", "condition 2     =    new    (  \" application / json \"  )  ;", "assertTrue (  \" Should   have   picked    '  *  /  *  '    condition   as   an   exact   match \"  ,     (  ( condition 1  . compareTo ( condition 2  ,    exchange )  )     <     0  )  )  ;", "assertTrue (  \" Should   have   picked    '  *  /  *  '    condition   as   an   exact   match \"  ,     (  ( condition 2  . compareTo ( condition 1  ,    exchange )  )     >     0  )  )  ;", "condition 1     =    new    (  \"  *  /  *  \"  )  ;", "condition 2     =    new    (  \" application / json \"  )  ;", "assertTrue (  (  ( condition 1  . compareTo ( condition 2  ,    exchange )  )     <     0  )  )  ;", "assertTrue (  (  ( condition 2  . compareTo ( condition 1  ,    exchange )  )     >     0  )  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \"  *  /  *  \"  )  )  ;", "condition 1     =    new    (  )  ;", "condition 2     =    new    (  \" application / json \"  )  ;", "assertTrue (  (  ( condition 1  . compareTo ( condition 2  ,    exchange )  )     <     0  )  )  ;", "assertTrue (  (  ( condition 2  . compareTo ( condition 1  ,    exchange )  )     >     0  )  )  ;", "condition 1     =    new    (  \"  *  /  *  \"  )  ;", "condition 2     =    new    (  \" application / json \"  )  ;", "assertTrue (  (  ( condition 1  . compareTo ( condition 2  ,    exchange )  )     <     0  )  )  ;", "assertTrue (  (  ( condition 2  . compareTo ( condition 1  ,    exchange )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToMediaTypeAll"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \"  *  /  *  ; q =  0  .  9  \"  )  )  ;", "condition 1     =    new    (  )  ;", "condition 2     =    new    (  \" application / json \"  )  ;", "assertTrue (  (  ( condition 1  . compareTo ( condition 2  ,    exchange )  )     <     0  )  )  ;", "assertTrue (  (  ( condition 2  . compareTo ( condition 1  ,    exchange )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToMediaTypeAllWithParameter"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ProducesRequestCondition   condition 1     =    new   ProducesRequestCondition (  \"  *  /  *  \"  ,     \" text / plain \"  )  ;", "ProducesRequestCondition   condition 2     =    new   ProducesRequestCondition (  \" text /  *  \"  ,     \" text / plain ; q =  0  .  7  \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / plain \"  )  )  ;", "int   result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToMultipleExpressions"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ProducesRequestCondition   condition 1     =    new   ProducesRequestCondition (  \" text /  *  \"  ,     \" text / plain \"  )  ;", "ProducesRequestCondition   condition 2     =    new   ProducesRequestCondition (  \" application /  *  \"  ,     \" application / xml \"  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / plain \"  ,     \" application / xml \"  )  )  ;", "int   result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" application / xml \"  ,     \" text / plain \"  )  )  ;", "result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToMultipleExpressionsAndMultipeAcceptHeaderValues"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / plain \"  )  )  ;", "condition 1     =    new    (  \" text / plain \"  )  ;", "condition 2     =    new    (  \" text /  *  \"  )  ;", "int   result    =    condition 1  . compareTo ( condition 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    condition 2  . compareTo ( condition 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToWithSingleExpression"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / plain \"  )  )  ;", "condition    =    new    (  \" text / plain \"  ,     \" application / xml \"  )  ;", "result    =    condition . getMatchingCondition ( exchange )  ;", "assertConditions ( result ,     \" text / plain \"  )  ;", "condition    =    new    (  \" application / xml \"  )  ;", "result    =    condition . getMatchingCondition ( exchange )  ;", "assertNull ( result )  ;", "}", "METHOD_END"], "methodName": ["getMatchingCondition"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ProducesRequestCondition   condition    =    new   ProducesRequestCondition (  \"  ! application / xml \"  )  ;", "assertEquals ( Collections . emptySet (  )  ,    condition . getProducibleMediaTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["getProducibleMediaTypes"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    produces    =    new   String [  ]  {     \" text / plain \"     }  ;", "String [  ]    headers    =    new   String [  ]  {     \" foo = bar \"  ,     \" accept = application / xml , application / pdf \"     }  ;", "condition    =    new    ( produces ,    headers )  ;", "assertConditions ( condition ,     \" text / plain \"  ,     \" application / xml \"  ,     \" application / pdf \"  )  ;", "}", "METHOD_END"], "methodName": ["instantiateWithProducesAndHeaderConditions"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / plain \"  )  )  ;", "condition    =    new    (  \" text / plain \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / plain \"  )  )  ;", "condition    =    new    (  \" text / plain \"  ,     \" application / xml \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["matchMultiple"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / plain \"  )  )  ;", "condition    =    new    (  \"  ! text / plain \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["matchNegated"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" bogus \"  )  )  ;", "condition    =    new    (  \" text / plain \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["matchParseError"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" bogus \"  )  )  ;", "condition    =    new    (  \"  ! text / plain \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["matchParseErrorWithNegation"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" application / xml \"  )  )  ;", "condition    =    new    (  \" text / plain \"  )  ;", "assertNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["matchSingle"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  . header (  \" Accept \"  ,     \" text / plain \"  )  )  ;", "condition    =    new    (  \" text /  *  \"  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["matchWildcard"], "fileName": "org.springframework.web.reactive.result.condition.ProducesRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    cond 1  . getClass (  )  ;", "Class <  ?  >    otherClazz    =    cond 2  . getClass (  )  ;", "if    (  !  ( clazz . equals ( otherClazz )  )  )     {", "throw   new   ClassCastException (  (  (  (  \" Incompatible   request   s :     \"     +    clazz )     +     \"    vs    \"  )     +    otherClazz )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertEqualConditionTypes"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . condition ;", "}", "METHOD_END"], "methodName": ["getCondition"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolder"}, {"methodBody": ["METHOD_START", "{", "RequestConditionHolder   params 1     =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \" name 1  \"  )  )  ;", "RequestConditionHolder   params 2     =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \" name 2  \"  )  )  ;", "RequestConditionHolder   expected    =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \" name 1  \"  ,     \" name 2  \"  )  )  ;", "assertEquals ( expected ,    params 1  . combine ( params 2  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestConditionHolder   empty    =    new   RequestConditionHolder ( null )  ;", "RequestConditionHolder   notEmpty    =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \" name \"  )  )  ;", "assertSame ( empty ,    empty . combine ( empty )  )  ;", "assertSame ( notEmpty ,    notEmpty . combine ( empty )  )  ;", "assertSame ( notEmpty ,    empty . combine ( notEmpty )  )  ;", "}", "METHOD_END"], "methodName": ["combineEmpty"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestConditionHolder   params    =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \" name \"  )  )  ;", "RequestConditionHolder   headers    =    new   RequestConditionHolder ( new   HeadersRequestCondition (  \" name \"  )  )  ;", "params . combine ( headers )  ;", "}", "METHOD_END"], "methodName": ["combineIncompatible"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestConditionHolder   params 1  1     =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \"  1  \"  )  )  ;", "RequestConditionHolder   params 1  2     =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \"  1  \"  ,     \"  2  \"  )  )  ;", "assertEquals (  1  ,    params 1  1  . compareTo ( params 1  2  ,    this . exchange )  )  ;", "assertEquals (  (  -  1  )  ,    params 1  2  . compareTo ( params 1  1  ,    this . exchange )  )  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestConditionHolder   empty    =    new   RequestConditionHolder ( null )  ;", "RequestConditionHolder   empty 2     =    new   RequestConditionHolder ( null )  ;", "RequestConditionHolder   notEmpty    =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \" name \"  )  )  ;", "assertEquals (  0  ,    empty . compareTo ( empty 2  ,    this . exchange )  )  ;", "assertEquals (  (  -  1  )  ,    notEmpty . compareTo ( empty ,    this . exchange )  )  ;", "assertEquals (  1  ,    empty . compareTo ( notEmpty ,    this . exchange )  )  ;", "}", "METHOD_END"], "methodName": ["compareEmpty"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestConditionHolder   params    =    new   RequestConditionHolder ( new   ParamsRequestCondition (  \" name \"  )  )  ;", "RequestConditionHolder   headers    =    new   RequestConditionHolder ( new   HeadersRequestCondition (  \" name \"  )  )  ;", "params . compareTo ( headers ,    this . exchange )  ;", "}", "METHOD_END"], "methodName": ["compareIncompatible"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestMethodsRequestCondition   rm    =    new   RequestMethodsRequestCondition ( RequestMethod . GET ,    RequestMethod . POST )  ;", "custom    =    new    ( rm )  ;", "RequestMethodsRequestCondition   expected    =    new   RequestMethodsRequestCondition ( RequestMethod . GET )  ;", "holder    =    custom . getMatchingCondition ( this . exchange )  ;", "assertNotNull ( holder )  ;", "assertEquals ( expected ,    holder . getCondition (  )  )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestConditionHolder   empty    =    new   RequestConditionHolder ( null )  ;", "assertSame ( empty ,    empty . getMatchingCondition ( this . exchange )  )  ;", "}", "METHOD_END"], "methodName": ["matchEmpty"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestMethodsRequestCondition   rm    =    new   RequestMethodsRequestCondition ( RequestMethod . POST )  ;", "custom    =    new    ( rm )  ;", "assertNull ( custom . getMatchingCondition ( this . exchange )  )  ;", "}", "METHOD_END"], "methodName": ["noMatch"], "fileName": "org.springframework.web.reactive.result.condition.RequestConditionHolderTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   none    =    RequestMappingInfo . paths (  )  . build (  )  ;", "RequestMappingInfo   oneMethod    =    RequestMappingInfo . paths (  )  . methods ( GET )  . build (  )  ;", "RequestMappingInfo   oneMethodOneParam    =    RequestMappingInfo . paths (  )  . methods ( GET )  . params (  \" foo \"  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / foo \"  )  )  ;", "Comparator < RequestMappingInfo >    comparator    =     (    info ,    otherInfo )     -  >    info . compareTo ( otherInfo ,    exchange )  ;", "List < RequestMappingInfo >    list    =    Arrays . asList ( none ,    oneMethod ,    oneMethodOneParam )  ;", "Collections . shuffle ( list )  ;", "list . sort ( comparator )  ;", "assertEquals ( oneMethodOneParam ,    list . get (  0  )  )  ;", "assertEquals ( oneMethod ,    list . get (  1  )  )  ;", "assertEquals ( none ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTwoHttpMethodsOneParam"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   info    =    RequestMappingInfo . paths (  )  . build (  )  ;", "assertEquals (  0  ,    info . getPatternsCondition (  )  . getPatterns (  )  . size (  )  )  ;", "assertEquals (  0  ,    info . getMethodsCondition (  )  . getMethods (  )  . size (  )  )  ;", "assertEquals ( true ,    info . getConsumesCondition (  )  . isEmpty (  )  )  ;", "assertEquals ( true ,    info . getProducesCondition (  )  . isEmpty (  )  )  ;", "assertNotNull ( info . getParamsCondition (  )  )  ;", "assertNotNull ( info . getHeadersCondition (  )  )  ;", "assertNull ( info . getCustomCondition (  )  )  ;", "}", "METHOD_END"], "methodName": ["createEmpty"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   info 1     =    RequestMappingInfo . paths (  \"  / foo \"  )  . methods ( GET )  . params (  \" foo = bar \"  )  . headers (  \" foo = bar \"  )  . consumes (  \" text / plain \"  )  . produces (  \" text / plain \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = customBar \"  )  )  . build (  )  ;", "RequestMappingInfo   info 2     =    RequestMappingInfo . paths (  \"  / foo \"  )  . methods ( GET )  . params (  \" foo = bar \"  )  . headers (  \" foo = bar \"  )  . consumes (  \" text / plain \"  )  . produces (  \" text / plain \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = customBar \"  )  )  . build (  )  ;", "assertEquals ( info 1  ,    info 2  )  ;", "assertEquals ( info 1  . hashCode (  )  ,    info 2  . hashCode (  )  )  ;", "info 2     =    RequestMappingInfo . paths (  \"  / foo \"  ,     \"  / NOOOOOO \"  )  . methods ( GET )  . params (  \" foo = bar \"  )  . headers (  \" foo = bar \"  )  . consumes (  \" text / plain \"  )  . produces (  \" text / plain \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = customBar \"  )  )  . build (  )  ;", "assertFalse ( info 1  . equals ( info 2  )  )  ;", "assertNotEquals ( info 1  . hashCode (  )  ,    info 2  . hashCode (  )  )  ;", "info 2     =    RequestMappingInfo . paths (  \"  / foo \"  )  . methods ( GET ,    POST )  . params (  \" foo = bar \"  )  . headers (  \" foo = bar \"  )  . consumes (  \" text / plain \"  )  . produces (  \" text / plain \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = customBar \"  )  )  . build (  )  ;", "assertFalse ( info 1  . equals ( info 2  )  )  ;", "assertNotEquals ( info 1  . hashCode (  )  ,    info 2  . hashCode (  )  )  ;", "info 2     =    RequestMappingInfo . paths (  \"  / foo \"  )  . methods ( GET )  . params (  \"  / NOOOOOO \"  )  . headers (  \" foo = bar \"  )  . consumes (  \" text / plain \"  )  . produces (  \" text / plain \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = customBar \"  )  )  . build (  )  ;", "assertFalse ( info 1  . equals ( info 2  )  )  ;", "assertNotEquals ( info 1  . hashCode (  )  ,    info 2  . hashCode (  )  )  ;", "info 2     =    RequestMappingInfo . paths (  \"  / foo \"  )  . methods ( GET )  . params (  \" foo = bar \"  )  . headers (  \"  / NOOOOOO \"  )  . consumes (  \" text / plain \"  )  . produces (  \" text / plain \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = customBar \"  )  )  . build (  )  ;", "assertFalse ( info 1  . equals ( info 2  )  )  ;", "assertNotEquals ( info 1  . hashCode (  )  ,    info 2  . hashCode (  )  )  ;", "info 2     =    RequestMappingInfo . paths (  \"  / foo \"  )  . methods ( GET )  . params (  \" foo = bar \"  )  . headers (  \" foo = bar \"  )  . consumes (  \" text / NOOOOOO \"  )  . produces (  \" text / plain \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = customBar \"  )  )  . build (  )  ;", "assertFalse ( info 1  . equals ( info 2  )  )  ;", "assertNotEquals ( info 1  . hashCode (  )  ,    info 2  . hashCode (  )  )  ;", "info 2     =    RequestMappingInfo . paths (  \"  / foo \"  )  . methods ( GET )  . params (  \" foo = bar \"  )  . headers (  \" foo = bar \"  )  . consumes (  \" text / plain \"  )  . produces (  \" text / NOOOOOO \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = customBar \"  )  )  . build (  )  ;", "assertFalse ( info 1  . equals ( info 2  )  )  ;", "assertNotEquals ( info 1  . hashCode (  )  ,    info 2  . hashCode (  )  )  ;", "info 2     =    RequestMappingInfo . paths (  \"  / foo \"  )  . methods ( GET )  . params (  \" foo = bar \"  )  . headers (  \" foo = bar \"  )  . consumes (  \" text / plain \"  )  . produces (  \" text / plain \"  )  . customCondition ( new   ParamsRequestCondition (  \" customFoo = NOOOOOO \"  )  )  . build (  )  ;", "assertFalse ( info 1  . equals ( info 2  )  )  ;", "assertNotEquals ( info 1  . hashCode (  )  ,    info 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . post (  \"  / foo \"  )  . contentType ( TEXT _ PLAIN )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "info    =     . paths (  \"  / foo \"  )  . consumes (  \" text / plain \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "info    =     . paths (  \"  / foo \"  )  . consumes (  \" application / xml \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchConsumesCondition"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / foo ? foo = bar \"  )  )  ;", "info    =     . paths (  \"  / foo \"  )  . params (  \" foo = bar \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "info    =     . paths (  \"  / foo \"  )  . params (  \" foo !  = bar \"  )  . customCondition ( new   ParamsRequestCondition (  \" foo !  = bar \"  )  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchCustomCondition"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / foo \"  )  . header (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "info    =     . paths (  \"  / foo \"  )  . headers (  \" foo = bar \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "info    =     . paths (  \"  / foo \"  )  . headers (  \" foo !  = bar \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchHeadersCondition"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / foo ? foo = bar \"  )  )  ;", "info    =     . paths (  \"  / foo \"  )  . params (  \" foo = bar \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "info    =     . paths (  \"  / foo \"  )  . params (  \" foo !  = bar \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchParamsCondition"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / foo \"  )  )  ;", "info    =     . paths (  \"  / foo *  \"  ,     \"  / bar \"  )  . build (  )  ;", "expected    =     . paths (  \"  / foo *  \"  )  . build (  )  ;", "assertEquals ( expected ,    info . getMatchingCondition ( exchange )  )  ;", "info    =     . paths (  \"  /  *  *  \"  ,     \"  / foo *  \"  ,     \"  / foo \"  )  . build (  )  ;", "expected    =     . paths (  \"  / foo \"  ,     \"  / foo *  \"  ,     \"  /  *  *  \"  )  . build (  )  ;", "assertEquals ( expected ,    info . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["matchPatternsCondition"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / foo \"  )  . accept ( TEXT _ PLAIN )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "info    =     . paths (  \"  / foo \"  )  . produces (  \" text / plain \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "info    =     . paths (  \"  / foo \"  )  . produces (  \" application / xml \"  )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchProducesCondition"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . options (  \"  / foo \"  )  . header (  \" Origin \"  ,     \" http :  /  / domain . com \"  )  . header ( ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" POST \"  )  )  ;", "info    =     . paths (  \"  / foo \"  )  . methods ( POST )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNotNull ( match )  ;", "info    =     . paths (  \"  / foo \"  )  . methods ( OPTIONS )  . build (  )  ;", "match    =    info . getMatchingCondition ( exchange )  ;", "assertNull (  \" Pre - flight   should   match   the   ACCESS _ CONTROL _ REQUEST _ METHOD \"  ,    match )  ;", "}", "METHOD_END"], "methodName": ["preFlightRequest"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   actual    =    RequestMappingInfo . paths (  \" foo \"  )  . build (  )  ;", "List < PathPattern >    patterns    =    new   ArrayList ( actual . getPatternsCondition (  )  . getPatterns (  )  )  ;", "assertEquals (  1  ,    patterns . size (  )  )  ;", "assertEquals (  \"  / foo \"  ,    patterns . get (  0  )  . getPatternString (  )  )  ;", "}", "METHOD_END"], "methodName": ["prependPatternWithSlash"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( PatternParseException . class )  ;", "this . thrown . expectMessage (  \" Expected   close   capture   character   after   variable   name    }  \"  )  ;", ". paths (  \"  /  { foo \"  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["throwWhenInvalidPattern"], "fileName": "org.springframework.web.reactive.result.condition.RequestMappingInfoTests"}, {"methodBody": ["METHOD_START", "{", "return   requestMethods    !  =    null    ?    Arrays . asList ( requestMethods )     :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["asList"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "return   this . methods ;", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "if    ( getMethods (  )  . isEmpty (  )  )     {", "return   this ;", "}", "HttpMethod   expectedMethod    =    request . getHeaders (  )  . getAccessControl (  )  ;", "return   match ( expectedMethod )  ;", "}", "METHOD_END"], "methodName": ["matchPreFlight"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "if    ( httpMethod    !  =    null )     {", "for    ( RequestMethod   method    :    getMethods (  )  )     {", "if    ( httpMethod . matches ( method . name (  )  )  )     {", "return   new    ( method )  ;", "}", "}", "if    (  ( httpMethod    =  =     ( HttpMethod . HEAD )  )     &  &     ( getMethods (  )  . contains ( GET )  )  )     {", "return    . HEAD _ CONDITION ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["matchRequestMethod"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestCondition"}, {"methodBody": ["METHOD_START", "{", "RequestMethodsRequestCondition   condition 1     =    new   RequestMethodsRequestCondition ( GET )  ;", "RequestMethodsRequestCondition   condition 2     =    new   RequestMethodsRequestCondition ( POST )  ;", "RequestMethodsRequestCondition   result    =    condition 1  . combine ( condition 2  )  ;", "assertEquals (  2  ,    result . getContent (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "RequestMethodsRequestCondition   c 1     =    new   RequestMethodsRequestCondition ( GET ,    HEAD )  ;", "RequestMethodsRequestCondition   c 2     =    new   RequestMethodsRequestCondition ( POST )  ;", "RequestMethodsRequestCondition   c 3     =    new   RequestMethodsRequestCondition (  )  ;", "ServerWebExchange   exchange    =    getExchange (  \" GET \"  )  ;", "int   result    =    c 1  . compareTo ( c 2  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    c 2  . compareTo ( c 1  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    >     0  )  )  ;", "result    =    c 2  . compareTo ( c 3  ,    exchange )  ;", "assertTrue (  (  \" Invalid   comparison   result :     \"     +    result )  ,     ( result    <     0  )  )  ;", "result    =    c 1  . compareTo ( c 1  ,    exchange )  ;", "assertEquals (  \" Invalid   comparison   result    \"  ,     0  ,    result )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( MockServerHttpRequest . method ( HttpMethod . valueOf ( method )  ,     \"  /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getExchange"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "testMatch ( new   RequestMethodsRequestCondition ( GET )  ,    GET )  ;", "testMatch ( new   RequestMethodsRequestCondition ( GET ,    POST )  ,    GET )  ;", "testNoMatch ( new   RequestMethodsRequestCondition ( GET )  ,    POST )  ;", "}", "METHOD_END"], "methodName": ["getMatchingCondition"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    getExchange (  \" OPTIONS \"  )  ;", "exchange . getRequest (  )  . getHeaders (  )  . add (  \" Origin \"  ,     \" http :  /  / example . com \"  )  ;", "exchange . getRequest (  )  . getHeaders (  )  . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" PUT \"  )  ;", "assertNotNull ( new    (  )  . getMatchingCondition ( exchange )  )  ;", "assertNotNull ( new    ( PUT )  . getMatchingCondition ( exchange )  )  ;", "assertNull ( new    ( DELETE )  . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["getMatchingConditionWithCorsPreFlight"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    getExchange (  \" PROPFIND \"  )  ;", "assertNotNull ( new    (  )  . getMatchingCondition ( exchange )  )  ;", "assertNull ( new    ( GET ,    POST )  . getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["getMatchingConditionWithCustomMethod"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "RequestMethodsRequestCondition   condition    =    new   RequestMethodsRequestCondition (  )  ;", "for    ( RequestMethod   method    :    RequestMethod . values (  )  )     {", "if    ( method    !  =     ( OPTIONS )  )     {", "ServerWebExchange   exchange    =    getExchange ( method . name (  )  )  ;", "assertNotNull ( condition . getMatchingCondition ( exchange )  )  ;", "}", "}", "testNoMatch ( condition ,    OPTIONS )  ;", "}", "METHOD_END"], "methodName": ["getMatchingConditionWithEmptyConditions"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "testMatch ( new   RequestMethodsRequestCondition ( HEAD )  ,    HEAD )  ;", "testMatch ( new   RequestMethodsRequestCondition ( GET )  ,    HEAD )  ;", "testNoMatch ( new   RequestMethodsRequestCondition ( POST )  ,    HEAD )  ;", "}", "METHOD_END"], "methodName": ["getMatchingConditionWithHttpHead"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    getExchange ( method . name (  )  )  ;", "actual    =    condition . getMatchingCondition ( exchange )  ;", "assertNotNull ( actual )  ;", "assertEquals ( Collections . singleton ( method )  ,    actual . getContent (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatch"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    getExchange ( method . name (  )  )  ;", "assertNull ( getMatchingCondition ( exchange )  )  ;", "}", "METHOD_END"], "methodName": ["testNoMatch"], "fileName": "org.springframework.web.reactive.result.condition.RequestMethodsRequestConditionTests"}, {"methodBody": ["METHOD_START", "{", "for    ( T   mapping    :    mappings )     {", "T   match    =    getMatching ( mapping ,    exchange )  ;", "if    ( match    !  =    null )     {", "matches . add ( new   Match ( match ,    this . mappingRegistry . gets (  )  . get ( mapping )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addMatchingMappings"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "HandlerMethod   handlerMethod ;", "if    ( handler   instanceof   String )     {", "String   beanName    =     (  ( String )     ( handler )  )  ;", "handlerMethod    =    new   HandlerMethod ( beanName ,     . obtainApplicationContext (  )  . getAutowireCapableBeanFactory (  )  ,    method )  ;", "} else    {", "handlerMethod    =    new   HandlerMethod ( handler ,    method )  ;", "}", "return   handlerMethod ;", "}", "METHOD_END"], "methodName": ["createHandlerMethod"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    handlerType    =     ( handler   instanceof   String )     ?    AbstractHandlerMethodMapping . obtainApplicationContext (  )  . getType (  (  ( String )     ( handler )  )  )     :    handler . getClass (  )  ;", "if    ( handlerType    !  =    null )     {", "final   Class <  ?  >    userType    =    ClassUtils . getUserClass ( handlerType )  ;", "Map < Method ,    T >    methods    =    MethodIntrospector . selectMethods ( userType ,     (  ( MethodIntrospector . MetadataLookup < T >  )     (  (    method )     -  >    getMappingForMethod ( method ,    userType )  )  )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  ( methods . size (  )  )     +     \"    request   handler   methods   found   on    \"  )     +    userType )     +     \"  :     \"  )     +    methods )  )  ;", "}", "methods . forEach (  (    key ,    mapping )     -  >     {", "Method   invocableMethod    =    AopUtils . selectInvocableMethod ( key ,    userType )  ;", "registerHandlerMethod ( handler ,    invocableMethod ,    mapping )  ;", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["detectHandlerMethods"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "this . mappingRegistry . acquireReadLock (  )  ;", "try    {", "return   Collections . unmodifiableMap ( this . mappingRegistry . gets (  )  )  ;", "}    finally    {", "this . mappingRegistry . releaseReadLock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getHandlerMethods"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "return   this . mappingRegistry ;", "}", "METHOD_END"], "methodName": ["getMappingRegistry"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["handleNoMatch"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["initCorsConfiguration"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Looking   for   request   mappings   in   application   context :     \"     +     (  . getApplicationContext (  )  )  )  )  ;", "}", "String [  ]    beanNames    =     . obtainApplicationContext (  )  . getBeanNamesForType ( Object . class )  ;", "for    ( String   beanName    :    beanNames )     {", "if    (  !  ( beanName . startsWith (  . SCOPED _ TARGET _ NAME _ PREFIX )  )  )     {", "Class <  ?  >    beanType    =    null ;", "try    {", "beanType    =     . obtainApplicationContext (  )  . getType ( beanName )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Could   not   resolve   target   class   for   bean   with   name    '  \"     +    beanName )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "if    (  ( beanType    !  =    null )     &  &     ( isHandler ( beanType )  )  )     {", "detectHandlerMethods ( beanName )  ;", "}", "}", "}", "handlerMethodsInitialized ( getHandlerMethods (  )  )  ;", "}", "METHOD_END"], "methodName": ["initHandlerMethods"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "List < AbstractHandlerMethodMapping < T >  . Match >    matches    =    new   ArrayList <  >  (  )  ;", "addMatchingMappings ( this . mappingRegistry . getMappings (  )  . keySet (  )  ,    matches ,    exchange )  ;", "if    (  !  ( matches . isEmpty (  )  )  )     {", "Comparator < AbstractHandlerMethodMapping < T >  . Match >    comparator    =    new   MatchComparator ( getMappingComparator ( exchange )  )  ;", "matches . sort ( comparator )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  (  \" Found    \"     +     ( matches . size (  )  )  )     +     \"    matching   mapping ( s )    for    [  \"  )     +     ( exchange . getRequest (  )  . getPath (  )  )  )     +     \"  ]     :     \"  )     +    matches )  )  ;", "}", "AbstractHandlerMethodMapping < T >  . Match   bestMatch    =    matches . get (  0  )  ;", "if    (  ( matches . size (  )  )     >     1  )     {", "if    ( CorsUtils . isPreFlightRequest ( exchange . getRequest (  )  )  )     {", "return   AbstractHandlerMethodMapping . PREFLIGHT _ AMBIGUOUS _ MATCH ;", "}", "AbstractHandlerMethodMapping < T >  . Match   secondBestMatch    =    matches . get (  1  )  ;", "if    (  ( comparator . compare ( bestMatch ,    secondBestMatch )  )     =  =     0  )     {", "Method   m 1     =    bestMatch . handlerMethod . getMethod (  )  ;", "Method   m 2     =    secondBestMatch . handlerMethod . getMethod (  )  ;", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Ambiguous   handler   methods   mapped   for   HTTP   path    '  \"     +     ( exchange . getRequest (  )  . getPath (  )  )  )     +     \"  '  :     {  \"  )     +    m 1  )     +     \"  ,     \"  )     +    m 2  )     +     \"  }  \"  )  )  ;", "}", "}", "handleMatch ( bestMatch . mapping ,    bestMatch . handlerMethod ,    exchange )  ;", "return   bestMatch . handlerMethod ;", "} else    {", "return   handleNoMatch ( this . mappingRegistry . getMappings (  )  . keySet (  )  ,    exchange )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupHandlerMethod"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "this . mappingRegistry . register ( mapping ,    handler ,    method )  ;", "}", "METHOD_END"], "methodName": ["registerHandlerMethod"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "this . mappingRegistry . register ( mapping ,    handler ,    method )  ;", "}", "METHOD_END"], "methodName": ["registerMapping"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "this . mappingRegistry . unregister ( mapping )  ;", "}", "METHOD_END"], "methodName": ["unregisterMapping"], "fileName": "org.springframework.web.reactive.result.method.AbstractHandlerMethodMapping"}, {"methodBody": ["METHOD_START", "{", "if    ( adapter . isNoValue (  )  )     {", "throw   new   IllegalArgumentException (  (  \" No   value      types   not   supported :     \"     +     ( param . getGenericParameterType (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertHasValues"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodArgumentResolverSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   IllegalStateException (  (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"    doesn ' t   support   reactive   type   wrapper :     \"  )     +     ( parameter . getGenericParameterType (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildReactiveWrapperException"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodArgumentResolverSupport"}, {"methodBody": ["METHOD_START", "{", "A   annotation    =    parameter . getParameterAnnotation ( annotationType )  ;", "if    ( annotation    =  =    null )     {", "return   false ;", "}", "parameter    =    parameter . nestedIfOptional (  )  ;", "Class <  ?  >    type    =    parameter . getNestedParameterType (  )  ;", "RAdapter   adapter    =    getAdapterRegistry (  )  . getAdapter ( type )  ;", "if    ( adapter    !  =    null )     {", "assertHasValues ( adapter ,    parameter )  ;", "parameter    =    parameter . nested (  )  ;", "type    =    parameter . getNestedParameterType (  )  ;", "}", "if    ( typePredicate . test ( annotation ,    type )  )     {", "if    ( adapter    =  =    null )     {", "return   true ;", "}", "throw   buildRWrapperException ( parameter )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkAnnotatedParamNoReactiveWrapper"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodArgumentResolverSupport"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    type    =    parameter . getParameterType (  )  ;", "RAdapter   adapter    =    getAdapterRegistry (  )  . getAdapter ( type )  ;", "if    ( adapter    !  =    null )     {", "assertHasValues ( adapter ,    parameter )  ;", "type    =    parameter . nested (  )  . getNestedParameterType (  )  ;", "}", "return   predicate . test ( type )  ;", "}", "METHOD_END"], "methodName": ["checkParameterType"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodArgumentResolverSupport"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    type    =    parameter . getParameterType (  )  ;", "RAdapter   adapter    =    getAdapterRegistry (  )  . getAdapter ( type )  ;", "if    ( adapter    !  =    null )     {", "assertHasValues ( adapter ,    parameter )  ;", "type    =    parameter . nested (  )  . getNestedParameterType (  )  ;", "}", "if    ( predicate . test ( type )  )     {", "if    ( adapter    =  =    null )     {", "return   true ;", "}", "throw   buildRWrapperException ( parameter )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkParameterTypeNoReactiveWrapper"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodArgumentResolverSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . adapterRegistry ;", "}", "METHOD_END"], "methodName": ["getAdapterRegistry"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodArgumentResolverSupport"}, {"methodBody": ["METHOD_START", "{", "this . mapping . registerMapping (  \"  / f ? o \"  ,    this . handler ,    this . method 1  )  ;", "this . mapping . registerMapping (  \"  / fo ?  \"  ,    this . handler ,    this . method 2  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / foo \"  )  )  ;", "Mono < Object >    result    =    this . mapping . getHandler ( exchange )  ;", "StepVerifier . create ( result )  . expectError ( IllegalStateException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["ambiguousMatch"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   key    =     \" foo \"  ;", "this . mapping . registerMapping ( key ,    this . handler ,    this . method 1  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get ( key )  )  ;", "Mono < Object >    result    =    this . mapping . getHandler ( exchange )  ;", "assertEquals ( this . method 1  ,     (  (  )     ( result . block (  )  )  )  . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["directMatch"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodMappingTests"}, {"methodBody": ["METHOD_START", "{", "this . mapping . registerMapping (  \"  / fo *  \"  ,    this . handler ,    this . method 1  )  ;", "this . mapping . registerMapping (  \"  / f *  \"  ,    this . handler ,    this . method 2  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / foo \"  )  )  ;", "Mono < Object >    result    =    this . mapping . getHandler ( exchange )  ;", "assertEquals ( this . method 1  ,     (  (  )     ( result . block (  )  )  )  . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["patternMatch"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodMappingTests"}, {"methodBody": ["METHOD_START", "{", "this . mapping . registerMapping (  \" foo \"  ,    this . handler ,    this . method 1  )  ;", "this . mapping . registerMapping (  \" foo \"  ,    this . handler ,    this . method 2  )  ;", "}", "METHOD_END"], "methodName": ["registerDuplicates"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   key 1     =     \"  / foo \"  ;", "String   key 2     =     \"  / foo *  \"  ;", "this . mapping . register ( key 1  ,    this . handler ,    this . method 1  )  ;", "this . mapping . register ( key 2  ,    this . handler ,    this . method 2  )  ;", "assertThat ( this . mapping . getRegistry (  )  . gets (  )  . keySet (  )  ,    Matchers . contains ( key 1  ,    key 2  )  )  ;", "}", "METHOD_END"], "methodName": ["registerMapping"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   key 1     =     \" foo \"  ;", "String   key 2     =     \" bar \"  ;", ". MyHandler   handler 1     =    new    . MyHandler (  )  ;", ". MyHandler   handler 2     =    new    . MyHandler (  )  ;", "this . mapping . registerMapping ( key 1  ,    handler 1  ,    this . method 1  )  ;", "this . mapping . registerMapping ( key 2  ,    handler 2  ,    this . method 1  )  ;", "assertThat ( this . mapping . getMappingRegistry (  )  . getMappings (  )  . keySet (  )  ,    Matchers . contains ( key 1  ,    key 2  )  )  ;", "}", "METHOD_END"], "methodName": ["registerMappingWithSameMethodAndTwoHandlerInstances"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodMappingTests"}, {"methodBody": ["METHOD_START", "{", "this . mapping    =    new   HandlerMethodMappingTests . MyHandlerMethodMapping (  )  ;", "this . handler    =    new   HandlerMethodMappingTests . MyHandler (  )  ;", "this . method 1     =    handler . getClass (  )  . getMethod (  \" handlerMethod 1  \"  )  ;", "this . method 2     =    handler . getClass (  )  . getMethod (  \" handlerMethod 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   key    =     \" foo \"  ;", "this . mapping . register ( key ,    this . handler ,    this . method 1  )  ;", "Mono < Object >    result    =    this . mapping . getHandler ( MockServerWebExchange . from ( MockServerHttpRequest . get ( key )  )  )  ;", "assertNotNull ( result . block (  )  )  ;", "this . mapping . unregister ( key )  ;", "result    =    this . mapping . getHandler ( MockServerWebExchange . from ( MockServerHttpRequest . get ( key )  )  )  ;", "assertNull ( result . block (  )  )  ;", "assertThat ( this . mapping . getRegistry (  )  . gets (  )  . keySet (  )  ,    Matchers . not ( Matchers . contains ( key )  )  )  ;", "}", "METHOD_END"], "methodName": ["unregisterMapping"], "fileName": "org.springframework.web.reactive.result.method.HandlerMethodMappingTests"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Invoking    '  \"     +     ( ClassUtils . getQualifiedName ( get (  )  ,    getBeanType (  )  )  )  )     +     \"  '    with   arguments    \"  )     +     ( Arrays . toString ( args )  )  )  )  ;", "}", "ReflectionUtils . makeAccessible ( getBridged (  )  )  ;", "Object   returnValue    =    getBridged (  )  . invoke ( getBean (  )  ,    args )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  \"     [  \"     +     ( ClassUtils . getQualifiedName ( get (  )  ,    getBeanType (  )  )  )  )     +     \"  ]    returned    [  \"  )     +    returnValue )     +     \"  ]  \"  )  )  ;", "}", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( providedArgs )  )     {", "return   Optional . empty (  )  ;", "}", "return   Arrays . stream ( providedArgs )  . filter (  (    arg )     -  >    pater . getPaterType (  )  . isInstance ( arg )  )  . findFirst (  )  ;", "}", "METHOD_END"], "methodName": ["findProvidedArgument"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . resolvers . stream (  )  . filter (  (    r )     -  >    r . supportsParameter ( param )  )  . findFirst (  )  . orElseThrow (  (  )     -  >    getArgumentError (  \" No   suitable   resolver   for \"  ,    param ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["findResolver"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   IllegalStateException ( getDetailedErrorMessage ( text ,    parameter )  ,    ex )  ;", "}", "METHOD_END"], "methodName": ["getArgumentError"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( text    +     \"    argument    \"  )     +     ( param . getParameterIndex (  )  )  )     +     \"    of   type    '  \"  )     +     ( param . getParameterType (  )  . getName (  )  )  )     +     \"  '    on    \"  )     +     ( getBridgedMethod (  )  . toGenericString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDetailedErrorMessage"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "String   argumentDetails    =    IntStream . range (  0  ,    args . length )  . mapToObj (  (    i )     -  >     ( args [ i ]  )     !  =    null    ?     (  (  (  (  (  \"  [  \"     +    i )     +     \"  ]  [ type =  \"  )     +     ( args [ i ]  . getClass (  )  . getName (  )  )  )     +     \"  ]  [ value =  \"  )     +     ( args [ i ]  )  )     +     \"  ]  \"     :     (  \"  [  \"     +    i )     +     \"  ]  [ null ]  \"  )  . collect ( Collectors . joining (  \"  ,  \"  ,     \"     \"  ,     \"     \"  )  )  ;", "return    (  (  \" Failed   to   invoke   handler      with   resolved   arguments :  \"     +    argumentDetails )     +     \" on    \"  )     +     ( getBridgedMethod (  )  . toGenericString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getInvocationErrorMessage"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["getParameterNameDiscoverer"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . resolvers ;", "}", "METHOD_END"], "methodName": ["getResolvers"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   resolveArguments ( exchange ,    bindingContext ,    providedArgs )  . flatMap (  (    args )     -  >     {", "try    {", "Object   value    =    doInvoke ( args )  ;", "HttpStatus   status    =    getResponseStatus (  )  ;", "if    ( status    !  =    null )     {", "exchange . getResponse (  )  . setStatusCode ( status )  ;", "}", "MethodParameter   returnType    =    getReturnType (  )  ;", "ReactiveAdapter   adapter    =    thisAdapterRegistry . getAdapter ( returnType . getParameterType (  )  )  ;", "boolean   asyncVoid    =    isAsyncVoidReturnType ( returnType ,    adapter )  ;", "if    (  (  ( value    =  =    null )     |  |    asyncVoid )     &  &     ( isResponseHandled ( args ,    exchange )  )  )     {", "logger . debug (  \" Response   fully   handled   in   controller   method \"  )  ;", "return   asyncVoid    ?    Mono . from ( adapter . toPublisher ( value )  )     :    Mono . empty (  )  ;", "}", "HandlerResult   result    =    new   HandlerResult ( this ,    value ,    returnType ,    bindingContext )  ;", "return   Mono . just ( result )  ;", "}    catch    (    ex )     {", "return   Mono . error ( ex . getTargetException (  )  )  ;", "}    catch    (    ex )     {", "return   Mono . error ( new   IllegalStateException ( getInvocationErrorMessage ( args )  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "if    (  ( reactiveAdapter    !  =    null )     &  &     ( reactiveAdapter . supportsEmpty (  )  )  )     {", "if    ( reactiveAdapter . isNoValue (  )  )     {", "return   true ;", "}", "Type   parameterType    =    returnType . getGenericParameterType (  )  ;", "if    ( parameterType   instanceof   ParameterizedType )     {", "ParameterizedType   type    =     (  ( ParameterizedType )     ( parameterType )  )  ;", "if    (  ( type . getActualTypeArguments (  )  . length )     =  =     1  )     {", "return   Void . class . equals ( type . getActualTypeArguments (  )  [  0  ]  )  ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAsyncVoidReturnType"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( getResponseStatus (  )  )     !  =    null )     |  |     ( exchange . isNotModified (  )  )  )     {", "return   true ;", "}", "for    ( Object   arg    :    args )     {", "if    (  ( arg   instanceof   ServerHttpResponse )     |  |     ( arg   instanceof   ServerWebExchange )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isResponseHandled"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   resolver . resolveArgument ( parameter ,    bindingContext ,    exchange )  . defaultIfEmpty (  . NO _ ARG _ VALUE )  . doOnError (  (    cause )     -  >     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug ( getDetailedErrorMessage (  \" Failed   to   resolve \"  ,    parameter )  ,    cause )  ;", "}", "}  )  ;", "}    catch    ( Exception   ex )     {", "throw   getArgumentError (  \" Failed   to   resolve \"  ,    parameter ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveArg"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( getMethodParameters (  )  )  )     {", "return    . EMPTY _ ARGS ;", "}", "try    {", "List < Mono < Object >  >    argMonos    =    Stream . of ( getMethodParameters (  )  )  . map (  (    param )     -  >     {", "param . initParameterNameDiscovery ( this . parameterNameDiscoverer )  ;", "return   findProvidedArgument ( param ,    providedArgs )  . map ( Mono :  : just )  . orElseGet (  (  )     -  >     {", "HandlerMethodArgumentResolver   resolver    =    findResolver ( param )  ;", "return   resolveArg ( resolver ,    param ,    bindingContext ,    exchange )  ;", "}  )  ;", "}  )  . collect ( Collectors . toList (  )  )  ;", "return   Mono . zip ( argMonos ,     (    argValues )     -  >    Stream . of ( argValues )  . map (  (    o )     -  >    o    !  =     (  . NO _ ARG _ VALUE )     ?    o    :    null )  . toArray (  )  )  ;", "}    catch    ( Throwable   ex )     {", "return   Mono . error ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveArguments"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . resolvers . clear (  )  ;", "this . resolvers . addAll ( resolvers )  ;", "}", "METHOD_END"], "methodName": ["setArgumentResolvers"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameDiscoverer    =    nameDiscoverer ;", "}", "METHOD_END"], "methodName": ["setParameterNameDiscoverer"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . reactiveAdapterRegistry    =    registry ;", "}", "METHOD_END"], "methodName": ["setReactiveAdapterRegistry"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( mono )  . consumeNextWith (  (        -  >     {", "assertEquals ( expected ,    getReturnValue (  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["assertHandlerResultValue"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Object >    resolvedValue    =    Mono . just (  1  )  ;", "Method   method    =    on (  . TestController . class )  . mockCall (  (    o )     -  >    o . singleArg ( null )  )  . method (  )  ;", "Mono < HandlerResult >    mono    =    invoke ( new    . TestController (  )  ,    method ,    resolverFor ( resolvedValue )  )  ;", "try    {", "mono . block (  )  ;", "fail (  \" Expected   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertThat ( ex . getMessage (  )  ,    is (  (  (  \" Failed   to   invoke   handler   method   with   resolved   arguments :     \"     +     (  \"  [  0  ]  [ type = Integer ]  [ value =  1  ]     \"     +     \" on    \"  )  )     +     ( method . toGenericString (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["illegalArgumentExceptionIsWrappedWithInvocationDetails"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    on ( InvocableHandlerMethodTests . TestController . class )  . mockCall ( InvocableHandlerMethodTests . TestController :  : exceptionMethod )  . method (  )  ;", "Mono < HandlerResult >    mono    =    invoke ( new   InvocableHandlerMethodTests . TestController (  )  ,    method )  ;", "try    {", "mono . block (  )  ;", "fail (  \" Expected   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertThat ( ex . getMessage (  )  ,    is (  \" boo \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invocationTargetExceptionIsUnwrapped"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "return   invoke ( handler ,    method ,    new   HandlerMethodArgumentResolver [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   hm    =    new   InvocableHandlerMethod ( handler ,    method )  ;", "hm . setArgumentResolvers ( Arrays . asList ( resolver )  )  ;", "return   hm . invoke ( this . exchange ,    new   BindingContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    on ( InvocableHandlerMethodTests . VoidController . class )  . mockCall ( InvocableHandlerMethodTests . VoidController :  : responseStatus )  . method (  )  ;", "HandlerResult   result    =    invoke ( new   InvocableHandlerMethodTests . VoidController (  )  ,    method )  . block ( Duration . ZERO )  ;", "assertNull (  \" Expected   no   result    ( i . e .    fully   handled )  \"  ,    result )  ;", "assertEquals ( BAD _ REQUEST ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAndHandle_VoidWithResponseStatus"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    on ( InvocableHandlerMethodTests . VoidController . class )  . mockCall (  (    c )     -  >    c . exchange ( exchange )  )  . method (  )  ;", "HandlerResult   result    =    invoke ( new   InvocableHandlerMethodTests . VoidController (  )  ,    method ,    resolverFor ( Mono . just ( this . exchange )  )  )  . block ( Duration . ZERO )  ;", "assertNull (  \" Expected   no   result    ( i . e .    fully   handled )  \"  ,    result )  ;", "assertEquals (  \" bar \"  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAndHandle_withExchange"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    on ( InvocableHandlerMethodTests . VoidController . class )  . mockCall (  (    c )     -  >    c . exchangeMonoVoid ( exchange )  )  . method (  )  ;", "HandlerResult   result    =    invoke ( new   InvocableHandlerMethodTests . VoidController (  )  ,    method ,    resolverFor ( Mono . just ( this . exchange )  )  )  . block ( Duration . ZERO )  ;", "assertNull (  \" Expected   no   result    ( i . e .    fully   handled )  \"  ,    result )  ;", "assertEquals (  \" body \"  ,    this . exchange . getResponse (  )  . getBodyAsString (  )  . block ( Duration . ZERO )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAndHandle_withExchangeAndMonoVoid"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . ifModifiedSince (  (  (  1  0     *     1  0  0  0  )     *     1  0  0  0  )  )  )  ;", "Method   method    =    on (  . VoidController . class )  . mockCall (  (    c )     -  >    c . notModified ( exchange )  )  . method (  )  ;", "HandlerResult   result    =    invoke ( new    . VoidController (  )  ,    method ,    resolverFor ( Mono . just ( exchange )  )  )  . block ( Duration . ZERO )  ;", "assertNull (  \" Expected   no   result    ( i . e .    fully   handled )  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["invokeAndHandle_withNotModified"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpResponse   response    =    this . exchange . getResponse (  )  ;", "Method   method    =    on (  . VoidController . class )  . mockCall (  (    c )     -  >    c . response ( response )  )  . method (  )  ;", "HandlerResult   result    =    invoke ( new    . VoidController (  )  ,    method ,    resolverFor ( Mono . just ( response )  )  )  . block ( Duration . ZERO )  ;", "assertNull (  \" Expected   no   result    ( i . e .    fully   handled )  \"  ,    result )  ;", "assertEquals (  \" bar \"  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAndHandle_withResponse"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "ServerHttpResponse   response    =    this . exchange . getResponse (  )  ;", "Method   method    =    on (  . VoidController . class )  . mockCall (  (    c )     -  >    c . responseMonoVoid ( response )  )  . method (  )  ;", "HandlerResult   result    =    invoke ( new    . VoidController (  )  ,    method ,    resolverFor ( Mono . just ( response )  )  )  . block ( Duration . ZERO )  ;", "assertNull (  \" Expected   no   result    ( i . e .    fully   handled )  \"  ,    result )  ;", "assertEquals (  \" body \"  ,    this . exchange . getResponse (  )  . getBodyAsString (  )  . block ( Duration . ZERO )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAndHandle_withResponseAndMonoVoid"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    on ( InvocableHandlerMethodTests . TestController . class )  . mockCall ( InvocableHandlerMethodTests . TestController :  : noArgs )  . method (  )  ;", "Mono < HandlerResult >    mono    =    invoke ( new   InvocableHandlerMethodTests . TestController (  )  ,    method )  ;", "assertHandlerResultValue ( mono ,     \" success \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithNoArguments"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Object >    resolvedValue    =    Mono . empty (  )  ;", "Method   method    =    on (  . TestController . class )  . mockCall (  (    o )     -  >    o . singleArg ( null )  )  . method (  )  ;", "Mono < HandlerResult >    mono    =    invoke ( new    . TestController (  )  ,    method ,    resolverFor ( resolvedValue )  )  ;", "assertHandlerResultValue ( mono ,     \" success : null \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithNoValue"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableMethod . on ( InvocableHandlerMethodTests . TestController . class )  . annotPresent ( ResponseStatus . class )  . resolveMethod (  )  ;", "Mono < HandlerResult >    mono    =    invoke ( new   InvocableHandlerMethodTests . TestController (  )  ,    method )  ;", "assertHandlerResultValue ( mono ,     \" created \"  )  ;", "assertThat ( this . exchange . getResponse (  )  . getStatusCode (  )  ,    is ( CREATED )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithResponseStatus"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Object >    resolvedValue    =    Mono . just (  \" value 1  \"  )  ;", "Method   method    =    on (  . TestController . class )  . mockCall (  (    o )     -  >    o . singleArg ( null )  )  . method (  )  ;", "Mono < HandlerResult >    mono    =    invoke ( new    . TestController (  )  ,    method ,    resolverFor ( resolvedValue )  )  ;", "assertHandlerResultValue ( mono ,     \" success : value 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithValue"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    on ( InvocableHandlerMethodTests . TestController . class )  . mockCall (  (    o )     -  >    o . singleArg ( null )  )  . method (  )  ;", "Mono < HandlerResult >    mono    =    invoke ( new   InvocableHandlerMethodTests . TestController (  )  ,    method )  ;", "try    {", "mono . block (  )  ;", "fail (  \" Expected   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertThat ( ex . getMessage (  )  ,    is (  (  (  \" No   suitable   resolver   for   argument    0    of   type    ' String '     \"     +     \" on    \"  )     +     ( method . toGenericString (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["noMatchingResolver"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodArgumentResolver   resolver    =    mock ( HandlerMethodArgumentResolver . class )  ;", "when ( resolver . supportsParameter ( any (  )  )  )  . thenReturn ( true )  ;", "when ( resolver . resolveArgument ( any (  )  ,    any (  )  ,    any (  )  )  )  . thenReturn ( resolvedValue )  ;", "return   resolver ;", "}", "METHOD_END"], "methodName": ["resolverFor"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Object >    resolvedValue    =    Mono . error ( new   UnsupportedMediaTypeStatusException (  \" boo \"  )  )  ;", "Method   method    =    on (  . TestController . class )  . mockCall (  (    o )     -  >    o . singleArg ( null )  )  . method (  )  ;", "Mono < HandlerResult >    mono    =    invoke ( new    . TestController (  )  ,    method ,    resolverFor ( resolvedValue )  )  ;", "try    {", "mono . block (  )  ;", "fail (  \" Expected   UnsupportedMediaTypeStatusException \"  )  ;", "}    catch    ( UnsupportedMediaTypeStatusException   ex )     {", "assertThat ( ex . getMessage (  )  ,    is (  \" Response   status    4  1  5    with   reason    \\  \" boo \\  \"  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolverThrowsException"], "fileName": "org.springframework.web.reactive.result.method.InvocableHandlerMethodTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . name )     !  =    null )     &  &     (  ( other . name )     !  =    null )  )     {", "St   separator    =     \"  #  \"  ;", "return    (  ( this . name )     +    separator )     +     ( other . name )  ;", "} else", "if    (  ( this . name )     !  =    null )     {", "return   this . name ;", "} else    {", "return    ( other . name )     !  =    null    ?    other . name    :    null ;", "}", "}", "METHOD_END"], "methodName": ["combineNames"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . consumesCondition ;", "}", "METHOD_END"], "methodName": ["getConsumesCondition"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . customConditionHolder . getCondition (  )  ;", "}", "METHOD_END"], "methodName": ["getCustomCondition"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . headersCondition ;", "}", "METHOD_END"], "methodName": ["getHeadersCondition"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . methodsCondition ;", "}", "METHOD_END"], "methodName": ["getMethodsCondition"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . paramsCondition ;", "}", "METHOD_END"], "methodName": ["getParamsCondition"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . patternsCondition ;", "}", "METHOD_END"], "methodName": ["getPatternsCondition"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . producesCondition ;", "}", "METHOD_END"], "methodName": ["getProducesCondition"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestMappingInfo . DefaultBuilder ( paths )  ;", "}", "METHOD_END"], "methodName": ["paths"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfo"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( mono )  . consumeErrorWith (  (    error )     -  >     {", "assertEquals ( exceptionClass ,    error . getClass (  )  )  ;", "consumer . accept (  (  ( T )     ( error )  )  )  ;", "}  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["assertError"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "Method   expected    =    ResolvableMethod . on ( RequestMappingInfoHandlerMappingTests . TestController . class )  . annot ( MvcAnnotationPredicates . getMapping (  \"  / foo \"  )  . params (  \" p \"  )  )  . resolveMethod (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo ? p = anything \"  )  )  ;", "HandlerMethod   hm    =     (  ( HandlerMethod )     ( this . handlerMapping . getHandler ( exchange )  . block (  )  )  )  ;", "assertEquals ( expected ,    hm . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerBestMatch"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "Method   expected    =    ResolvableMethod . on ( RequestMappingInfoHandlerMappingTests . TestController . class )  . annot ( MvcAnnotationPredicates . getMapping (  \"  / foo \"  )  . params (  )  )  . resolveMethod (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / foo \"  )  )  ;", "HandlerMethod   hm    =     (  ( HandlerMethod )     ( this . handlerMapping . getHandler ( exchange )  . block (  )  )  )  ;", "assertEquals ( expected ,    hm . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerDirectMatch"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "Method   expected    =    ResolvableMethod . on ( RequestMappingInfoHandlerMappingTests . TestController . class )  . annot ( MvcAnnotationPredicates . requestMapping (  \"  \"  )  )  . resolveMethod (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  \"  )  )  ;", "HandlerMethod   hm    =     (  ( HandlerMethod )     ( this . handlerMapping . getHandler ( exchange )  . block (  )  )  )  ;", "assertEquals ( expected ,    hm . getMethod (  )  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  /  \"  )  )  ;", "hm    =     (  ( HandlerMethod )     ( this . handlerMapping . getHandler ( exchange )  . block (  )  )  )  ;", "assertEquals ( expected ,    hm . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerEmptyPathMatch"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "Method   expected    =    ResolvableMethod . on ( RequestMappingInfoHandlerMappingTests . TestController . class )  . annot ( MvcAnnotationPredicates . requestMapping (  \"  / ba *  \"  )  . method ( RequestMethod . GET ,    RequestMethod . HEAD )  )  . resolveMethod (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / bar \"  )  )  ;", "HandlerMethod   hm    =     (  ( HandlerMethod )     ( this . handlerMapping . getHandler ( exchange )  . block (  )  )  )  ;", "assertEquals ( expected ,    hm . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerGlobMatch"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMethod >    allMethodExceptTrace    =    new   ArrayList ( Arrays . asList ( HttpMethod . values (  )  )  )  ;", "allMethodExceptTrace . remove ( TRACE )  ;", "testHttpOptions (  \"  / foo \"  ,    EnumSet . of ( GET ,    HEAD )  )  ;", "testHttpOptions (  \"  / person /  1  \"  ,    EnumSet . of ( PUT )  )  ;", "testHttpOptions (  \"  / persons \"  ,    EnumSet . copyOf ( allMethodExceptTrace )  )  ;", "testHttpOptions (  \"  / something \"  ,    EnumSet . of ( PUT ,    POST )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerHttpOptions"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "testHttpMediaTypeNotSupportedException (  \"  / person /  1  \"  )  ;", "testHttpMediaTypeNotSupportedException (  \"  / person /  1  /  \"  )  ;", "testHttpMediaTypeNotSupportedException (  \"  / person /  1  . json \"  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerMediaTypeNotSupported"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / content \"  )  . accept ( APPLICATION _ XML )  )  ;", "this . handlerMapping . getHandler ( exchange )  . block (  )  ;", "String   name    =     . PRODUCIBLE _ MEDIA _ TYPES _ ATTRIBUTE ;", "assertEquals ( Collections . singleton ( APPLICATION _ XML )  ,    exchange . getAttributes (  )  . get ( name )  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  / content \"  )  . accept ( APPLICATION _ JSON )  )  ;", "this . handlerMapping . getHandler ( exchange )  . block (  )  ;", "assertNull (  \" Negated   expression   shouldn ' t   be   listed   as   producible   type \"  ,    exchange . getAttributes (  )  . get ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerProducibleMediaTypesAttribute"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / users \"  )  . accept ( APPLICATION _ XML )  )  ;", "this . handlerMapping . registerHandler ( new    . UserController (  )  )  ;", "Mono < Object >    mono    =    this . handlerMapping . getHandler ( exchange )  ;", "StepVerifier . create ( mono )  . expectError ( NotAcceptableStatusException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerRequestMethodMatchFalsePositive"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( post (  \"  / bar \"  )  )  ;", "Mono < Object >    mono    =    this . h . getHandler ( exchange )  ;", "assertError ( mono ,    MethodNotAllowedException . class ,     (    ex )     -  >    assertEquals ( EnumSet . of ( HttpMethod . GET ,    HttpMethod . HEAD )  ,    ex . getSupportedMethods (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerRequestMethodNotAllowed"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    put (  \"  / person /  1  \"  )  . header (  \" content - type \"  ,     \" bogus \"  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "Mono < Object >    mono    =    this . h . getHandler ( exchange )  ;", "assertError ( mono ,    UnsupportedMediaTypeStatusException . class ,     (    ex )     -  >    assertEquals (  (  \" Response   status    4  1  5    with   reason    \\  \" Invalid   mime   type    \\  \" bogus \\  \"  :     \"     +     \" does   not   contain    \\  '  /  \\  '  \\  \"  \"  )  ,    ex . getMessage (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerTestInvalidContentType"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "testMediaTypeNotAcceptable (  \"  / persons \"  )  ;", "testMediaTypeNotAcceptable (  \"  / persons /  \"  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerTestMediaTypeNotAcceptable"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / params \"  )  )  ;", "Mono < Object >    mono    =    this . h . getHandler ( exchange )  ;", "assertError ( mono ,    ServerWebInputException . class ,     (    ex )     -  >     {", "assertThat ( ex . getReason (  )  ,    containsString (  \"  [ foo = bar ]  \"  )  )  ;", "assertThat ( ex . getReason (  )  ,    containsString (  \"  [ bar = baz ]  \"  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerTestRequestParamMismatch"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Map < String ,    MultiValueMap < String ,    String >  >  )     ( exchange . getAttributes (  )  . get ( HandlerMapping . MATRIX _ VARIABLES _ ATTRIBUTE )  )  )  . get ( uriVarName )  ;", "}", "METHOD_END"], "methodName": ["getMatrixVariables"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Map < String ,    String >  )     ( exchange . getAttributes (  )  . get ( HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE )  )  )  ;", "}", "METHOD_END"], "methodName": ["getUriTemplateVariables"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   info    =    RequestMappingInfo . paths ( pattern )  . build (  )  ;", "this . handlerMapping . handleMatch ( info ,     . handlerMethod ,    exchange )  ;", "}", "METHOD_END"], "methodName": ["handleMatch"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   key    =    RequestMappingInfo . paths (  \"  /  { path 1  }  /  2  \"  ,     \"  /  *  *  \"  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  1  /  2  \"  )  )  ;", "this . handlerMapping . handleMatch ( key ,     . handlerMethod ,    exchange )  ;", "PathPattern   bestMatch    =     (  ( PathPattern )     ( exchange . getAttributes (  )  . get ( HandlerMapping . BEST _ MATCHING _ PATTERN _ ATTRIBUTE )  )  )  ;", "assertEquals (  \"  /  { path 1  }  /  2  \"  ,    bestMatch . getPatternString (  )  )  ;", "HandlerMethod   mapped    =     (  ( HandlerMethod )     ( exchange . getAttributes (  )  . get ( HandlerMapping . BEST _ MATCHING _ HANDLER _ ATTRIBUTE )  )  )  ;", "assertSame (  . handlerMethod ,    mapped )  ;", "}", "METHOD_END"], "methodName": ["handleMatchBestMatchingPatternAttribute"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   key    =    RequestMappingInfo . paths (  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  1  /  2  \"  )  )  ;", "this . handlerMapping . handleMatch ( key ,     . handlerMethod ,    exchange )  ;", "PathPattern   bestMatch    =     (  ( PathPattern )     ( exchange . getAttributes (  )  . get ( HandlerMapping . BEST _ MATCHING _ PATTERN _ ATTRIBUTE )  )  )  ;", "assertEquals (  \"  /  1  /  2  \"  ,    bestMatch . getPatternString (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMatchBestMatchingPatternAttributeNoPatternsDefined"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    matrixVariables ;", "Map < String ,    String >    uriVariables ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / cars ; colors = red , blue , green ; year =  2  0  1  2  \"  )  )  ;", "hMatch ( exchange ,     \"  /  { cars }  \"  )  ;", "matrixVariables    =    getMatrixVariables ( exchange ,     \" cars \"  )  ;", "uriVariables    =    getUriTemplateVariables ( exchange )  ;", "assertNotNull ( matrixVariables )  ;", "assertEquals ( Arrays . asList (  \" red \"  ,     \" blue \"  ,     \" green \"  )  ,    matrixVariables . get (  \" colors \"  )  )  ;", "assertEquals (  \"  2  0  1  2  \"  ,    matrixVariables . getFirst (  \" year \"  )  )  ;", "assertEquals (  \" cars \"  ,    uriVariables . get (  \" cars \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMatchMatrixVariables"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    method ( GET ,    URI . create (  \"  / path ; mvar = a %  2 fb \"  )  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "handleMatch ( exchange ,     \"  /  { filter }  \"  )  ;", "MultiValueMap < String ,    String >    matrixVariables    =    getMatrixVariables ( exchange ,     \" filter \"  )  ;", "Map < String ,    String >    uriVariables    =    getUriTemplateVariables ( exchange )  ;", "assertNotNull ( matrixVariables )  ;", "assertEquals ( Collections . singletonList (  \" a / b \"  )  ,    matrixVariables . get (  \" mvar \"  )  )  ;", "assertEquals (  \" path \"  ,    uriVariables . get (  \" filter \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMatchMatrixVariablesDecoding"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  /  1  /  2  \"  )  )  ;", "RequestMappingInfo   key    =    RequestMappingInfo . paths (  \"  /  { path 1  }  /  { path 2  }  \"  )  . build (  )  ;", "this . handlerMapping . handleMatch ( key ,     . handlerMethod ,    exchange )  ;", "String   name    =    HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ;", "Map < String ,    String >    uriVariables    =     (  ( Map < String ,    String >  )     ( exchange . getAttributes (  )  . get ( name )  )  )  ;", "assertNotNull ( uriVariables )  ;", "assertEquals (  \"  1  \"  ,    uriVariables . get (  \" path 1  \"  )  )  ;", "assertEquals (  \"  2  \"  ,    uriVariables . get (  \" path 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMatchUriTemplateVariables"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   key    =    RequestMappingInfo . paths (  \"  /  { group }  /  { identifier }  \"  )  . build (  )  ;", "URI   url    =    URI . create (  \"  / group / a %  2 Fb \"  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( method ( GET ,    url )  )  ;", "this . handlerMapping . handleMatch ( key ,     . handlerMethod ,    exchange )  ;", "String   name    =    HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    String >    uriVariables    =     (  ( Map < String ,    String >  )     ( exchange . getAttributes (  )  . get ( name )  )  )  ;", "assertNotNull ( uriVariables )  ;", "assertEquals (  \" group \"  ,    uriVariables . get (  \" group \"  )  )  ;", "assertEquals (  \" a / b \"  ,    uriVariables . get (  \" identifier \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMatchUriTemplateVariablesDecode"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "this . handlerMapping    =    new   RequestMappingInfoHandlerMappingTests . TestRequestMappingInfoHandlerMapping (  )  ;", "this . handlerMapping . registerHandler ( new   RequestMappingInfoHandlerMappingTests . TestController (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    put ( url )  . contentType ( APPLICATION _ JSON )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "Mono < Object >    mono    =    this . h . getHandler ( exchange )  ;", "assertError ( mono ,    UnsupportedMediaTypeStatusException . class ,     (    ex )     -  >    assertEquals (  \" Invalid   supported   consumable   media   types \"  ,    Collections . singletonList ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ,    ex . getSupportedMediaTypes (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testHttpMediaTypeNotSupportedException"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . options ( requestURI )  )  ;", "HandlerMethod   handlerMethod    =     (  ( HandlerMethod )     ( this . h . getHandler ( exchange )  . block (  )  )  )  ;", "BindingContext   bindingContext    =    new   BindingContext (  )  ;", "InvocableHandlerMethod   invocable    =    new   InvocableHandlerMethod ( handlerMethod )  ;", "Mono < HandlerResult >    mono    =    invocable . invoke ( exchange ,    bindingContext )  ;", "HandlerResult   result    =    mono . block (  )  ;", "assertNotNull ( result )  ;", "Object   value    =    result . getReturnValue (  )  ;", "assertNotNull ( value )  ;", "assertEquals ( HttpHeaders . class ,    value . getClass (  )  )  ;", "assertEquals ( allowedMethods ,     (  ( HttpHeaders )     ( value )  )  . getAllow (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHttpOptions"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( get ( url )  . accept ( APPLICATION _ JSON )  )  ;", "Mono < Object >    mono    =    this . h . getHandler ( exchange )  ;", "assertError ( mono ,    NotAcceptableStatusException . class ,     (    ex )     -  >    assertEquals (  \" Invalid   supported   producible   media   types \"  ,    Collections . singletonList ( new   MediaType (  \" application \"  ,     \" xml \"  )  )  ,    ex . getSupportedMediaTypes (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMediaTypeNotAcceptable"], "fileName": "org.springframework.web.reactive.result.method.RequestMappingInfoHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate . getParameterNameDiscoverer (  )  ;", "}", "METHOD_END"], "methodName": ["getParameterNameDiscoverer"], "fileName": "org.springframework.web.reactive.result.method.SyncInvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate . getResolvers (  )  . stream (  )  . map (  (    resolver )     -  >     (  ( SyncHandlerMethodArgumentResolver )     ( resolver )  )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getResolvers"], "fileName": "org.springframework.web.reactive.result.method.SyncInvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "MonoProcessor < HandlerResult >    processor    =    MonoProcessor . create (  )  ;", "this . delegate . invoke ( exchange ,    bindingContext ,    providedArgs )  . subscribeWith ( processor )  ;", "if    ( processor . isTerminated (  )  )     {", "Throwable   ex    =    processor . getError (  )  ;", "if    ( ex    !  =    null )     {", "throw   ex   instanceof   ServerErrorException    ?     (  ( ServerErrorException )     ( ex )  )     :    new   ServerErrorException (  (  \" Failed   to   invoke :     \"     +     ( getShortLogMessage (  )  )  )  ,    getMethod (  )  ,    ex )  ;", "}", "return   processor . peek (  )  ;", "} else    {", "throw   new   IllegalStateException (  \"    should   have   completed   synchronously .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeForHandlerResult"], "fileName": "org.springframework.web.reactive.result.method.SyncInvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . delegate . setArgumentResolvers ( new   ArrayList <  >  ( resolvers )  )  ;", "}", "METHOD_END"], "methodName": ["setArgumentResolvers"], "fileName": "org.springframework.web.reactive.result.method.SyncInvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . delegate . setParameterNameDiscoverer ( nameDiscoverer )  ;", "}", "METHOD_END"], "methodName": ["setParameterNameDiscoverer"], "fileName": "org.springframework.web.reactive.result.method.SyncInvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ] s    =    parameter . getParameterAnnotations (  )  ;", "for    ( Annotation   ann    : s )     {", "Validated   validatedAnn    =    AnnotationUtils . getAnnotation ( ann ,    Validated . class )  ;", "if    (  ( validatedAnn    !  =    null )     |  |     ( annType (  )  . getSimpleName (  )  . startsWith (  \" Valid \"  )  )  )     {", "Object   hints    =     ( validatedAnn    !  =    null )     ?    validatedAnn . value (  )     :    AnnotationUtils . getValue ( ann )  ;", "return   hints   instanceof   Object [  ]     ?     (  ( Object [  ]  )     ( hints )  )     :    new   Object [  ]  {    hints    }  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["extractValidationHints"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . messageReaders ;", "}", "METHOD_END"], "methodName": ["getMessageReaders"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   ServerWebInputException (  (  \" Request   body   is   missing :     \"     +     ( param . getExecutable (  )  . toGenericString (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMissingBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "return   ex   instanceof   DecodingException    ?    new   ServerWebInputException (  \" Failed   to   read   HTTP   message \"  ,    parameter ,    ex )     :    ex ;", "}", "METHOD_END"], "methodName": ["handleReadError"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . readBody ( bodyParameter ,    null ,    isBodyRequired ,    bindingContext ,    exchange )  ;", "}", "METHOD_END"], "methodName": ["readBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   bodyType    =    ResolvableType . forMethodParameter ( bodyParam )  ;", "ResolvableType   actualType    =     ( actualParam    =  =    null )     ?    bodyType    :    ResolvableType . forMethodParameter ( actualParam )  ;", "Class <  ?  >    resolvedType    =    bodyType . resolve (  )  ;", "ReactiveAdapter   adapter    =     ( resolvedType    !  =    null )     ?    getAdapterRegistry (  )  . getAdapter ( resolvedType )     :    null ;", "ResolvableType   elementType    =     ( adapter    !  =    null )     ?    bodyType . getGeneric (  )     :    bodyType ;", "ServerHttpRequest   request    =    exchange . getRequest (  )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "MediaType   contentType    =    request . getHeaders (  )  . getContentType (  )  ;", "MediaType   mediaType    =     ( contentType    !  =    null )     ?    contentType    :    MediaType . APPLICATION _ OCTET _ STREAM ;", "Supplier < Throwable >    missingBodyError    =     ( isBodyRequired    |  |     (  ( adapter    !  =    null )     &  &     (  !  ( adapter . supportsEmpty (  )  )  )  )  )     ?     (  )     -  >    handleMissingBody ( bodyParam )     :    null ;", "for    ( HttpMessageReader <  ?  >    reader    :    getMessageReaders (  )  )     {", "if    ( reader . canRead ( elementType ,    mediaType )  )     {", "Map < String ,    Object >    readHints    =    Collections . emptyMap (  )  ;", "if    (  ( adapter    !  =    null )     &  &     ( adapter . isMultiValue (  )  )  )     {", "Flux <  ?  >    flux    =    reader . read ( actualType ,    elementType ,    request ,    response ,    readHints )  ;", "flux    =    flux . onErrorResume (  (    ex )     -  >    Flux . error ( handleReadError ( bodyParam ,    ex )  )  )  ;", "if    ( missingBodyError    !  =    null )     {", "flux    =    flux . switchIfEmpty ( Flux . error ( missingBodyError )  )  ;", "}", "Object [  ]    hints    =    extractValidationHints ( bodyParam )  ;", "if    ( hints    !  =    null )     {", "flux    =    flux . doOnNext (  (    target )     -  >    validate ( target ,    hints ,    bodyParam ,    bindingContext ,    exchange )  )  ;", "}", "return   Mono . just ( adapter . fromPublisher ( flux )  )  ;", "} else    {", "Mono <  ?  >    mono    =    reader . readMono ( actualType ,    elementType ,    request ,    response ,    readHints )  ;", "mono    =    mono . onErrorResume (  (    ex )     -  >    Mono . error ( handleReadError ( bodyParam ,    ex )  )  )  ;", "if    ( missingBodyError    !  =    null )     {", "mono    =    mono . switchIfEmpty ( Mono . error ( missingBodyError )  )  ;", "}", "Object [  ]    hints    =    extractValidationHints ( bodyParam )  ;", "if    ( hints    !  =    null )     {", "mono    =    mono . doOnNext (  (    target )     -  >    validate ( target ,    hints ,    bodyParam ,    bindingContext ,    exchange )  )  ;", "}", "return   adapter    !  =    null    ?    Mono . just ( adapter . fromPublisher ( mono )  )     :    Mono . from ( mono )  ;", "}", "}", "}", "HttpMethod   method    =    request . getMethod (  )  ;", "if    (  (  ( contentType    =  =    null )     &  &     ( method    !  =    null )  )     &  &     (  . SUPPORTED _ METHODS . contains ( method )  )  )     {", "Flux < DataBuffer >    body    =    request . getBody (  )  . doOnNext (  (    o )     -  >     {", "throw   new   UnsupportedMediaTypeStatusException ( mediaType ,    this . supportedMediaTypes )  ;", "}  )  ;", "if    ( missingBodyError    !  =    null )     {", "body    =    body . switchIfEmpty ( Mono . error ( missingBodyError )  )  ;", "}", "return   adapter    !  =    null    ?    Mono . just ( adapter . fromPublisher ( body )  )     :    Mono . from ( body )  ;", "}", "return   Mono . error ( new   UnsupportedMediaTypeStatusException ( mediaType ,    this . supportedMediaTypes )  )  ;", "}", "METHOD_END"], "methodName": ["readBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "String   name    =    Conventions . getVariableNameForParameter ( param )  ;", "WebExchangeDataBinder   binder    =    binding . createDataBinder ( exchange ,    target ,    name )  ;", "binder . validate ( validationHints )  ;", "if    ( binder . getBindingResult (  )  . hasErrors (  )  )     {", "throw   new   bind . support . WebExchangeBindException ( param ,    binder . getBindingResult (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( adapter . isNoValue (  )  )     {", "return   ResolvableType . forClass ( Void . class )  ;", "} else", "if    ( genericType    !  =     ( ResolvableType . NONE )  )     {", "return   genericType ;", "} else    {", "return   ResolvableType . forClass ( Object . class )  ;", "}", "}", "METHOD_END"], "methodName": ["getElementType"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageWriterResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   getMessageWriters (  )  . stream (  )  . filter (  (    converter )     -  >    converter . canWrite ( elementType ,    null )  )  . flatMap (  (    converter )     -  >    converter . getWritableMediaTypes (  )  . stream (  )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMediaTypesFor"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageWriterResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . messageWriters ;", "}", "METHOD_END"], "methodName": ["getMessageWriters"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageWriterResultHandler"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   bodyType    =    ResolvableType . forMethodParameter ( bodyParameter )  ;", "ResolvableType   actualType    =     ( actualParameter    =  =    null )     ?    bodyType    :    ResolvableType . forMethodParameter ( actualParameter )  ;", "Class <  ?  >    bodyClass    =    bodyType . resolve (  )  ;", "ReactiveAdapter   adapter    =    getAdapterRegistry (  )  . getAdapter ( bodyClass ,    body )  ;", "Publisher <  ?  >    publisher ;", "ResolvableType   elementType ;", "if    ( adapter    !  =    null )     {", "publisher    =    adapter . toPublisher ( body )  ;", "ResolvableType   genericType    =    bodyType . getGeneric (  0  )  ;", "elementType    =    getElementType ( adapter ,    genericType )  ;", "} else    {", "publisher    =    Mono . justOrEmpty ( body )  ;", "elementType    =     (  (  ( bodyClass    =  =    null )     |  |     ( bodyClass . equals ( Object . class )  )  )     &  &     ( body    !  =    null )  )     ?    ResolvableType . forInstance ( body )     :    bodyType ;", "}", "if    (  (  ( void . class )     =  =     ( elementType . getRawClass (  )  )  )     |  |     (  ( Void . class )     =  =     ( elementType . getRawClass (  )  )  )  )     {", "return   Mono . from (  (  ( Publisher < Void >  )     ( publisher )  )  )  ;", "}", "ServerHttpRequest   request    =    exchange . getRequest (  )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "MediaType   bestMediaType    =    selectMediaType ( exchange ,     (  )     -  >    getMediaTypesFor ( elementType )  )  ;", "if    ( bestMediaType    !  =    null )     {", "for    ( HttpMessageWriter <  ?  >    writer    :    getMessageWriters (  )  )     {", "if    ( writer . canWrite ( elementType ,    bestMediaType )  )     {", "return   writer . write (  (  ( Publisher )     ( publisher )  )  ,    actualType ,    elementType ,    bestMediaType ,    request ,    response ,    Collections . emptyMap (  )  )  ;", "}", "}", "} else    {", "if    ( getMediaTypesFor ( elementType )  . isEmpty (  )  )     {", "return   Mono . error ( new   IllegalStateException (  (  \" No   writer   for    :     \"     +    elementType )  )  )  ;", "}", "}", "return   Mono . error ( new   server . NotAcceptableStatusException ( getMediaTypesFor ( elementType )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageWriterResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . writeBody ( body ,    bodyParameter ,    null ,    exchange )  ;", "}", "METHOD_END"], "methodName": ["writeBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractMessageWriterResultHandler"}, {"methodBody": ["METHOD_START", "{", "WebDataBinder   binder    =    bindingContext . createDataBinder ( exchange ,    namedValueInfo . name )  ;", "try    {", "value    =    binder . convertIfNecessary ( value ,    parameter . getParameterType (  )  ,    parameter )  ;", "}    catch    ( ConversionNotSupportedException   ex )     {", "throw   new   server . ServerErrorException (  \" Conversion   not   supported .  \"  ,    parameter ,    ex )  ;", "}    catch    ( TypeMismatchException   ex )     {", "throw   new   server . ServerWebInputException (  \" Type   mismatch .  \"  ,    parameter ,    ex )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["applyConversion"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    null ;", "try    {", "if    (  ( nInfo . defaultValue )     !  =    null )     {", "value    =    resolveStringValue ( nInfo . defaultValue )  ;", "} else", "if    (  ( nInfo . required )     &  &     (  !  ( parameter . isOptional (  )  )  )  )     {", "handleMissingValue ( nInfo . name ,    parameter ,    exchange )  ;", "}", "value    =    handleNullValue ( nInfo . name ,    value ,    parameter . getNestedParameterType (  )  )  ;", "value    =    applyConversion ( value ,    nInfo ,    parameter ,    bindingContext ,    exchange )  ;", "handleResolvedValue ( value ,    nInfo . name ,    parameter ,    model ,    exchange )  ;", "return   Mono . justOrEmpty ( value )  ;", "}    catch    ( Throwable   ex )     {", "return   Mono . error ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getDefaultValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "AbstractNamedValueArgumentResolver . NamedValueInfo   namedValueInfo    =    this . namedValueInfoCache . get ( parameter )  ;", "if    ( namedValueInfo    =  =    null )     {", "namedValueInfo    =    createNamedValueInfo ( parameter )  ;", "namedValueInfo    =    updateNamedValueInfo ( parameter ,    namedValueInfo )  ;", "this . namedValueInfoCache . put ( parameter ,    namedValueInfo )  ;", "}", "return   namedValueInfo ;", "}", "METHOD_END"], "methodName": ["getNamedValueInfo"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "String   typeName    =    parameter . getNestedParameterType (  )  . getSimpleName (  )  ;", "throw   new   server . ServerWebInputException (  (  (  (  (  \" Missing   argument    '  \"     +    name )     +     \"  '    for   method    \"  )     +     \" parameter   of   type    \"  )     +    typeName )  ,    parameter )  ;", "}", "METHOD_END"], "methodName": ["handleMissingValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "handleMissingValue ( name ,    parameter )  ;", "}", "METHOD_END"], "methodName": ["handleMissingValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "if    ( Boolean . TYPE . equals ( paramType )  )     {", "return   Boolean . FALSE ;", "} else", "if    ( paramType . isPrimitive (  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Optional    \"     +     ( paramType . getSimpleName (  )  )  )     +     \"    parameter    '  \"  )     +    name )     +     \"  '    is   present   but   c   be   translated   into   a \"  )     +     \"    null   value   due   to   being   declared   as   a   primitive   type .     \"  )     +     \" Consider   declaring   it   as   object   wrapper   for   the   corresponding   primitive   type .  \"  )  )  ;", "}", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["handleNullValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . configurableBeanFactory )     =  =    null )     |  |     (  ( this . expressionContext )     =  =    null )  )     {", "return   value ;", "}", "String   placeholdersResolved    =    this . configurableBeanFactory . resolveEmbeddedValue ( value )  ;", "BeanExpression   expr    =    this . configurableBeanFactory . getBeanExpression (  )  ;", "if    ( expr    =  =    null )     {", "return   value ;", "}", "return   expr . evaluate ( placeholdersResolved ,    this . expressionContext )  ;", "}", "METHOD_END"], "methodName": ["resolveStringValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "String   name    =    info . name ;", "if    ( info . name . isEmpty (  )  )     {", "name    =    parameter . getParameterName (  )  ;", "if    ( name    =  =    null )     {", "String   type    =    parameter . getNestedParameterType (  )  . getName (  )  ;", "throw   new   IllegalArgumentException (  (  (  (  \" Name   for   argument   type    [  \"     +    type )     +     \"  ]    not    \"  )     +     \" available ,    and   parameter   name   information   not   found   in   class   file   either .  \"  )  )  ;", "}", "}", "String   defaultValue    =     ( DEFAULT _ NONE . equals ( info . defaultValue )  )     ?    null    :    info . defaultValue ;", "return   new    . NamedValueInfo ( name ,    info . required ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["updateNamedValueInfo"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractNamedValueArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    List < String >  >    entry    :    headers . entrySet (  )  )     {", "for    ( String   value    :    entry . getValue (  )  )     {", "builder . header ( entry . getKey (  )  ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addHeaders"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . restTemplate ;", "}", "METHOD_END"], "methodName": ["getRestTemplate"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   RestTemplate (  )  ;", "}", "METHOD_END"], "methodName": ["initRestTemplate"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   getRestTemplate (  )  . exchange ( prepareGet ( url ,    headers )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["performGet"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setAccept ( Collecs . singletonList ( out )  )  ;", "return   getRestTemplate (  )  . exchange ( prepareGet ( url ,    headers )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["performGet"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setAccept ( Collecs . singletonList ( out )  )  ;", "return   this . restTemplate . exchange ( prepareGet ( url ,    headers )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["performGet"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   getRestTemplate (  )  . exchange ( prepareOptions ( url ,    headers )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["performOptions"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   getRestTemplate (  )  . exchange ( preparePost ( url ,    headers ,    body )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["performPost"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( in )  ;", "if    ( out    !  =    null )     {", "headers . setAccept ( Collecs . singletonList ( out )  )  ;", "}", "return   getRestTemplate (  )  . exchange ( preparePost ( url ,    headers ,    body )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["performPost"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setContentType ( in )  ;", "if    ( out    !  =    null )     {", "headers . setAccept ( Collecs . singletonList ( out )  )  ;", "}", "return   getRestTemplate (  )  . exchange ( preparePost ( url ,    headers ,    body )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["performPost"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +    url )  )  ;", "Entity . HeadersBuilder <  ?  >    builder    =    Entity . get ( uri )  ;", "addHeaders ( builder ,    headers )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["prepareGet"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +    url )  )  ;", "Entity . HeadersBuilder <  ?  >    builder    =    Entity . options ( uri )  ;", "addHeaders ( builder ,    headers )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["prepareOptions"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +    url )  )  ;", "Entity . BodyBuilder   builder    =    Entity . post ( uri )  ;", "addHeaders ( builder ,    headers )  ;", "return   builder . body ( body )  ;", "}", "METHOD_END"], "methodName": ["preparePost"], "fileName": "org.springframework.web.reactive.result.method.annotation.AbstractRequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resolver ,     \"  ' resolvers '    must   not   be   null \"  )  ;", "this . customs . addAll ( Arrays . asList ( resolver )  )  ;", "}", "METHOD_END"], "methodName": ["addCustomResolver"], "fileName": "org.springframework.web.reactive.result.method.annotation.ArgumentResolverConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   this . customResolvers ;", "}", "METHOD_END"], "methodName": ["getCustomResolvers"], "fileName": "org.springframework.web.reactive.result.method.annotation.ArgumentResolverConfigurer"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context 1     =    new   AnnotationConfigApplicationContext (  )  ;", "context 1  . register (  . WebAppConfig . class )  ;", "context 1  . refresh (  )  ;", "AnnotationConfigApplicationContext   context 2     =    new   AnnotationConfigApplicationContext (  )  ;", "context 2  . register (  . WebAppConfig . class )  ;", "context 2  . refresh (  )  ;", "HttpHandler   webApp 1 Handler    =    WebHttpHandlerBuilder . applicationContext ( context 1  )  . build (  )  ;", "HttpHandler   webApp 2 Handler    =    WebHttpHandlerBuilder . applicationContext ( context 2  )  . build (  )  ;", "ReactorHttpServer   server    =    new   ReactorHttpServer (  )  ;", "server . registerHttpHandler (  \"  / webApp 1  \"  ,    webApp 1 Handler )  ;", "server . registerHttpHandler (  \"  / webApp 2  \"  ,    webApp 2 Handler )  ;", "server . afterPropertiesSet (  )  ;", "server . start (  )  ;", "try    {", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "String   actual ;", "String   url    =     (  \" http :  /  / localhost :  \"     +     ( server . getPort (  )  )  )     +     \"  / webApp 1  / test \"  ;", "actual    =    restTemplate . getForObject ( url ,    String . class )  ;", "assertEquals (  \" Tested   in    / webApp 1  \"  ,    actual )  ;", "url    =     (  \" http :  /  / localhost :  \"     +     ( server . getPort (  )  )  )     +     \"  / webApp 2  / test \"  ;", "actual    =    restTemplate . getForObject ( url ,    String . class )  ;", "assertEquals (  \" Tested   in    / webApp 2  \"  ,    actual )  ;", "}    finally    {", "server . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["multipleWebFluxApps"], "fileName": "org.springframework.web.reactive.result.method.annotation.ContextPathIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . WebAppConfig . class )  ;", "context . refresh (  )  ;", "File   base    =    new   File ( System . getProperty (  \" tmpdir \"  )  )  ;", "TomcatHttpServer   server    =    new   TomcatHttpServer ( base . getAbsolutePath (  )  )  ;", "server . setContextPath (  \"  / app \"  )  ;", "server . setServletMapping (  \"  / api /  *  \"  )  ;", "HttpHandler   httpHandler    =    WebHttpHandlerBuilder . applicationContext ( context )  . build (  )  ;", "server . setHandler ( httpHandler )  ;", "server . afterPropertiesSet (  )  ;", "server . start (  )  ;", "try    {", "RestTemplate   restTemplate    =    new   RestTemplate (  )  ;", "String   actual ;", "String   url    =     (  \" http :  /  / localhost :  \"     +     ( server . getPort (  )  )  )     +     \"  / app / api / test \"  ;", "actual    =    restTemplate . getForObject ( url ,    String . class )  ;", "assertEquals (  \" Tested   in    / app / api \"  ,    actual )  ;", "}    finally    {", "server . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["servletPathMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.ContextPathIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingHandlerAdapter   adapter    =    new   RequestMappingHandlerAdapter (  )  ;", "adapter . setApplicationContext ( context )  ;", "adapter . afterPropertiesSet (  )  ;", "return   adapter ;", "}", "METHOD_END"], "methodName": ["createAdapter"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    controller . getClass (  )  . getMethod ( methodName )  ;", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( controller ,    method )  ;", "return   adapter . handle ( this . exchange ,    handlerMethod )  . block ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ControllerAdviceTests . TestConfig . class )  ;", "RequestMappingHandlerAdapter   adapter    =    createAdapter ( context )  ;", "ControllerAdviceTests . TestController   controller    =    context . getBean ( ControllerAdviceTests . TestController . class )  ;", "Validator   validator    =    mock ( Validator . class )  ;", "controller . setValidator ( validator )  ;", "BindingContext   bindingContext    =    handle ( adapter ,    controller ,     \" handle \"  )  . getBindingContext (  )  ;", "WebExchangeDataBinder   binder    =    bindingContext . createDataBinder ( this . exchange ,     \" name \"  )  ;", "assertEquals ( Collections . singletonList ( validator )  ,    binder . getValidators (  )  )  ;", "}", "METHOD_END"], "methodName": ["initBinderAdvice"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ControllerAdviceTests . TestConfig . class )  ;", "RequestMappingHandlerAdapter   adapter    =    createAdapter ( context )  ;", "ControllerAdviceTests . TestController   controller    =    context . getBean ( ControllerAdviceTests . TestController . class )  ;", "Model   model    =    handle ( adapter ,    controller ,     \" handle \"  )  . getModel (  )  ;", "assertEquals (  2  ,    model . asMap (  )  . size (  )  )  ;", "assertEquals (  \" lAttr 1  \"  ,    model . asMap (  )  . get (  \" attr 1  \"  )  )  ;", "assertEquals (  \" gAttr 2  \"  ,    model . asMap (  )  . get (  \" attr 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeAdvice"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "testException ( new   IllegalAccessException (  )  ,     \" SecondControllerAdvice :    IllegalAccessException \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveExceptionGlobalHandler"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "testException ( new   IllegalStateException (  )  ,     \" OneControllerAdvice :    IllegalStateException \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveExceptionGlobalHandlerOrdered"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "AssertionError   error    =    new   AssertionError (  \" argh \"  )  ;", "testException ( error ,    error . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveExceptionWithAssertionError"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "AssertionError   cause    =    new   AssertionError (  \" argh \"  )  ;", "FatalBeanException   exception    =    new   FatalBeanException (  \" wrapped \"  ,    cause )  ;", "testException ( exception ,    cause . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveExceptionWithAssertionErrorAsRootCause"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "testException ( new   ArrayIndexOutOfBoundsException (  )  ,     \" HandlerMethod :    handle \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveExceptionWithHandlerMethodArg"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    new   AnnotationConfigApplicationContext ( ControllerAdviceTests . TestConfig . class )  ;", "RequestMappingHandlerAdapter   adapter    =    createAdapter ( context )  ;", "ControllerAdviceTests . TestController   controller    =    context . getBean ( ControllerAdviceTests . TestController . class )  ;", "controller . setException ( exception )  ;", "Object   actual    =    handle ( adapter ,    controller ,     \" handle \"  )  . getReturnValue (  )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["testException"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerAdviceTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" Hello       +     \\ u 0  0 e 0  !  \"  ;", "assertEquals ( expected ,    performGet (  \"  / param ? name =  %  2  0  %  2 B +  % C 3  % A 0  \"  ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleWithEncodedParam"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerInputIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" Hello   George !  \"  ;", "assertEquals ( expected ,    performGet (  \"  / param ? name = George \"  ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleWithParam"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerInputIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" p =  1  1  ,    q 2  =  2  2  ,    q 4  =  4  4  \"  ;", "String   url    =     \"  / first ; p =  1  1  / second ; q =  2  2  / third - fourth ; q =  4  4  \"  ;", "assertEquals ( expected ,    performGet ( url ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["matrixVariable"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerInputIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableListableBeanFactory   beanFactory    =    context . getBeanFactory (  )  ;", "registrar . add ( new   RequestParamMethodArgumentResolver ( beanFactory ,    Registry ,    false )  )  ;", "registrar . add ( new   RequestParamMapMethodArgumentResolver ( Registry )  )  ;", "registrar . add ( new   PathVariableMethodArgumentResolver ( beanFactory ,    Registry )  )  ;", "registrar . add ( new   PathVariableMapMethodArgumentResolver ( Registry )  )  ;", "registrar . add ( new   MatrixVariableMethodArgumentResolver ( beanFactory ,    Registry )  )  ;", "registrar . add ( new   MatrixVariableMapMethodArgumentResolver ( Registry )  )  ;", "registrar . addIfRequestBody (  (    readers )     -  >    new   RequestBodyArgumentResolver ( readers ,    Registry )  )  ;", "registrar . addIfRequestBody (  (    readers )     -  >    new   RequestPartMethodArgumentResolver ( readers ,    Registry )  )  ;", "registrar . addIfModelAttribute (  (  )     -  >    new   ModelAttributeMethodArgumentResolver ( Registry ,    false )  )  ;", "registrar . add ( new   RequestHeaderMethodArgumentResolver ( beanFactory ,    Registry )  )  ;", "registrar . add ( new   RequestHeaderMapMethodArgumentResolver ( Registry )  )  ;", "registrar . add ( new   CookieValueMethodArgumentResolver ( beanFactory ,    Registry )  )  ;", "registrar . add ( new   ExpressionValueMethodArgumentResolver ( beanFactory ,    Registry )  )  ;", "registrar . add ( new   SessionAttributeMethodArgumentResolver ( beanFactory ,    Registry )  )  ;", "registrar . add ( new   RequestAttributeMethodArgumentResolver ( beanFactory ,    Registry )  )  ;", "registrar . addIfRequestBody (  (    readers )     -  >    new   HttpEntityArgumentResolver ( readers ,    Registry )  )  ;", "registrar . add ( new   ModelArgumentResolver ( Registry )  )  ;", "registrar . addIfModelAttribute (  (  )     -  >    new   ErrorsMethodArgumentResolver ( Registry )  )  ;", "registrar . add ( new   ServerWebExchangeArgumentResolver ( Registry )  )  ;", "registrar . add ( new   PrincipalArgumentResolver ( Registry )  )  ;", "registrar . addIfRequestBody (  (    readers )     -  >    new   SessionStatusMethodArgumentResolver (  )  )  ;", "registrar . add ( new   WebSessionArgumentResolver ( Registry )  )  ;", "registrar . addCustomResolvers (  )  ;", "registrar . add ( new   RequestParamMethodArgumentResolver ( beanFactory ,    Registry ,    true )  )  ;", "registrar . addIfModelAttribute (  (  )     -  >    new   ModelAttributeMethodArgumentResolver ( Registry ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["addResolversTo"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   invocable    =    new   InvocableHandlerMethod ( bean ,    method )  ;", "invocable . setArgumentResolvers ( this . modelAttributeResolvers )  ;", "return   invocable ;", "}", "METHOD_END"], "methodName": ["createAttributeMethod"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    handlerType    =    handlerMethod . getBeanType (  )  ;", "Object   targetBean    =    handlerMethod . getBean (  )  ;", "Method   targetMethod    =    this . exceptionHandlerCache . computeIfAbsent ( handlerType ,    ExceptionHand :  : new )  . resolveMethodByThrowable ( ex )  ;", "if    ( targetMethod    =  =    null )     {", "for    ( ControllerAdviceBean   advice    :    this . exceptionHandlerAdviceCache . keySet (  )  )     {", "if    ( advice . isApplicableToBeanType ( handlerType )  )     {", "targetBean    =    advice . resolveBean (  )  ;", "targetMethod    =    this . exceptionHandlerAdviceCache . get ( advice )  . resolveMethodByThrowable ( ex )  ;", "if    ( targetMethod    !  =    null )     {", "break ;", "}", "}", "}", "}", "if    ( targetMethod    =  =    null )     {", "return   null ;", "}", "InvocableHandlerMethod   invocable    =    new   InvocableHandlerMethod ( targetBean ,    targetMethod )  ;", "invocable . setArgumentResolvers ( this . exceptionHandlerResolvers )  ;", "return   invocable ;", "}", "METHOD_END"], "methodName": ["getExceptionHandlerMethod"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "SyncInvocableHandlerMethod   invocable    =    new   SyncInvocableHandlerMethod ( bean ,    method )  ;", "invocable . setArgumentResolvers ( this . initBinderResolvers )  ;", "return   invocable ;", "}", "METHOD_END"], "methodName": ["getInitBinderMethod"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "List < SyncInvocableHandlerMethod >    result    =    new   ArrayList <  >  (  )  ;", "Class <  ?  >    handlerType    =    handlerMethod . getBeanType (  )  ;", "this . initBinderAdviceCache . forEach (  (    adviceBean ,    methods )     -  >     {", "if    ( adviceBean . isApplicableToBeanType ( handlerType )  )     {", "Object   bean    =    adviceBean . resolveBean (  )  ;", "methods . forEach (  (    method )     -  >    result . add ( getInitBinderMethod ( bean ,    method )  )  )  ;", "}", "}  )  ;", "this . initBinderMethodCache . computeIfAbsent ( handlerType ,     (    aClass )     -  >    MethodIntrospector . selectMethods ( handlerType ,     . BINDER _ METHODS )  )  . forEach (  (    method )     -  >     {", "Object   bean    =    handlerMethod . getBean (  )  ;", "result . add ( getInitBinderMethod ( bean ,    method )  )  ;", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getInitBinderMethods"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "List < InvocableHandlerMethod >    result    =    new   ArrayList <  >  (  )  ;", "Class <  ?  >    handlerType    =    handlerMethod . getBeanType (  )  ;", "this . modelAttributeAdviceCache . forEach (  (    adviceBean ,    methods )     -  >     {", "if    ( adviceBean . isApplicableToBeanType ( handlerType )  )     {", "Object   bean    =    adviceBean . resolveBean (  )  ;", "methods . forEach (  (    method )     -  >    result . add ( createAttributeMethod ( bean ,    method )  )  )  ;", "}", "}  )  ;", "this . modelAttributeMethodCache . computeIfAbsent ( handlerType ,     (    aClass )     -  >    MethodIntrospector . selectMethods ( handlerType ,     . ATTRIBUTE _ METHODS )  )  . forEach (  (    method )     -  >     {", "Object   bean    =    handlerMethod . getBean (  )  ;", "result . add ( createAttributeMethod ( bean ,    method )  )  ;", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getModelAttributeMethods"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   invocable    =    new   InvocableHandlerMethod ( handlerMethod )  ;", "invocable . setArgumentResolvers ( this . requestMappingResolvers )  ;", "invocable . setReactiveAdapterRegistry ( this . reactiveAdapterRegistry )  ;", "return   invocable ;", "}", "METHOD_END"], "methodName": ["getRequestMappingMethod"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    handlerType    =    handlerMethod . getBeanType (  )  ;", "SessionAttributesHandler   result    =    this . sessionAttributesHandlerCache . get ( handlerType )  ;", "if    ( result    =  =    null )     {", "synchronized ( this . sessionAttributesHandlerCache )     {", "result    =    this . sessionAttributesHandlerCache . get ( handlerType )  ;", "if    ( result    =  =    null )     {", "result    =    new   SessionAttributesHandler ( handlerType )  ;", "this . sessionAttributesHandlerCache . put ( handlerType ,    result )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getSessionAttributesHandler"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( applicationContext    =  =    null )     {", "return ;", "}", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  \" Looking   for    @ ControllerAdvice :     \"     +    applicationContext )  )  ;", "}", "List < ControllerAdviceBean >    beans    =    ControllerAdviceBean . findAnnotatedBeans ( applicationContext )  ;", "AnnotationAwareOrderComparator . sort ( beans )  ;", "for    ( ControllerAdviceBean   bean    :    beans )     {", "Class <  ?  >    beanType    =    bean . getBeanType (  )  ;", "if    ( beanType    !  =    null )     {", "Set < Method >    attrMethods    =    MethodIntrospector . selectMethods ( beanType ,     . ATTRIBUTE _ METHODS )  ;", "if    (  !  ( attrMethods . isEmpty (  )  )  )     {", "this . modelAttributeAdviceCache . put ( bean ,    attrMethods )  ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  \" Detected    @ ModelAttribute   methods   in    \"     +    bean )  )  ;", "}", "}", "Set < Method >    binderMethods    =    MethodIntrospector . selectMethods ( beanType ,     . BINDER _ METHODS )  ;", "if    (  !  ( binderMethods . isEmpty (  )  )  )     {", "this . initBinderAdviceCache . put ( bean ,    binderMethods )  ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  \" Detected    @ InitBinder   methods   in    \"     +    bean )  )  ;", "}", "}", "ExceptionHandlerMethodResolver   resolver    =    new   ExceptionHandlerMethodResolver ( beanType )  ;", "if    ( resolver . hasExceptionMappings (  )  )     {", "this . exceptionHandlerAdviceCache . put ( bean ,    resolver )  ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  \" Detected    @ ExceptionHandler   methods   in    \"     +    bean )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["initControllerAdviceCaches"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   invocable    =    this . methodResolver . getExceptionHandlerMethod ( new   ResponseStatusException ( HttpStatus . BAD _ REQUEST ,     \" reason \"  )  ,    this . handlerMethod )  ;", "assertNotNull (  \" No   match \"  ,    invocable )  ;", "assertEquals (  . TestController . class ,    invocable . getBeanType (  )  )  ;", "List < HandlerMethodArgumentResolver >    resolvers    =    invocable . getResolvers (  )  ;", "AtomicInteger   index    =    new   AtomicInteger (  (  -  1  )  )  ;", "assertEquals ( RequestParamMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestParamMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PathVariableMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PathVariableMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( MatrixVariableMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( MatrixVariableMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestHeaderMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestHeaderMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( CookieValueMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ExpressionValueMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( SessionAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ModelArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ServerWebExchangeArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PrincipalArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( WebSessionArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals (  . CustomArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals (  . CustomSyncArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestParamMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionHandlerArgumentResolvers"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   invocable    =    this . methodResolver . getExceptionHandlerMethod ( new   IllegalStateException (  \" reason \"  )  ,    this . handlerMethod )  ;", "assertNotNull ( invocable )  ;", "assertEquals (  . TestControllerAdvice . class ,    invocable . getBeanType (  )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionHandlerFromControllerAdvice"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < SyncInvocableHandlerMethod >    methods    =    this . methodResolver . getInitBinderMethods ( this . handlerMethod )  ;", "assertEquals (  \" Expected   one   each   from   Controller    +    ControllerAdvice \"  ,     2  ,    methods . size (  )  )  ;", "SyncInvocableHandlerMethod   invocable    =    methods . get (  0  )  ;", "List < SyncHandlerMethodArgumentResolver >    resolvers    =    invocable . getResolvers (  )  ;", "AtomicInteger   index    =    new   AtomicInteger (  (  -  1  )  )  ;", "assertEquals ( RequestParamMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestParamMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PathVariableMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PathVariableMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( MatrixVariableMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( MatrixVariableMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestHeaderMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestHeaderMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( CookieValueMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ExpressionValueMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ModelArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ServerWebExchangeArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals (  . CustomSyncArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestParamMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["initBinderArgumentResolvers"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < InvocableHandlerMethod >    methods    =    this . methodResolver . getModelAttributeMethods ( this . handlerMethod )  ;", "assertEquals (  \" Expected   one   each   from   Controller    +    ControllerAdvice \"  ,     2  ,    methods . size (  )  )  ;", "InvocableHandlerMethod   invocable    =    methods . get (  0  )  ;", "List < HandlerMethodArgumentResolver >    resolvers    =    invocable . getResolvers (  )  ;", "AtomicInteger   index    =    new   AtomicInteger (  (  -  1  )  )  ;", "assertEquals ( RequestParamMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestParamMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PathVariableMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PathVariableMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( MatrixVariableMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( MatrixVariableMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ModelAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestHeaderMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestHeaderMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( CookieValueMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ExpressionValueMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( SessionAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ModelArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ErrorsMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ServerWebExchangeArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PrincipalArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( WebSessionArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals (  . CustomArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals (  . CustomSyncArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestParamMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ModelAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeArgumentResolvers"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   resolvers . get ( index . incrementAndGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   invocable    =    this . methodResolver . getRequestMappingMethod ( this . handlerMethod )  ;", "List < HandlerMethodArgumentResolver >    resolvers    =    invocable . getResolvers (  )  ;", "AtomicInteger   index    =    new   AtomicInteger (  (  -  1  )  )  ;", "assertEquals ( RequestParamMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestParamMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PathVariableMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PathVariableMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( MatrixVariableMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( MatrixVariableMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestBodyArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestPartMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ModelAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestHeaderMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestHeaderMapMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( CookieValueMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ExpressionValueMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( SessionAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( HttpEntityArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ModelArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ErrorsMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ServerWebExchangeArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( PrincipalArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( SessionStatusMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( WebSessionArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals (  . CustomArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals (  . CustomSyncArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( RequestParamMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "assertEquals ( ModelAttributeMethodArgumentResolver . class ,     . next ( resolvers ,    index )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestMappingArgumentResolvers"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "ArgumentResolverConfigurer   resolvers    =    new   ArgumentResolverConfigurer (  )  ;", "resolvers . addCustomResolver ( new    . CustomArgumentResolver (  )  )  ;", "resolvers . addCustomResolver ( new    . CustomSyncArgumentResolver (  )  )  ;", "ServerCodecConfigurer   codecs    =    ServerCodecConfigurer . create (  )  ;", "codecs . customCodecs (  )  . decoder ( new   ByteArrayDecoder (  )  )  ;", "codecs . customCodecs (  )  . decoder ( new   ByteBufferDecoder (  )  )  ;", "AnnotationConfigApplicationContext   applicationContext    =    new   AnnotationConfigApplicationContext (  )  ;", "applicationContext . registerBean (  . TestControllerAdvice . class )  ;", "applicationContext . refresh (  )  ;", "this . methodResolver    =    new   ControllerMethodResolver ( resolvers ,    codecs . getReaders (  )  ,    ReactiveAdapterRegistry . getSharedInstance (  )  ,    applicationContext )  ;", "Method   method    =    on (  . TestController . class )  . mockCall (  . TestController :  : handle )  . method (  )  ;", "this . handlerMethod    =    new   HandlerMethod ( new    . TestController (  )  ,    method )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.reactive.result.method.annotation.ControllerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . resolver . supportsParameter ( this . stringParameter )  )  ;", "try    {", "this . resolver . supportsParameter ( this . cookieMonoParameter )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotSupportParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "Mono < Object >    mono    =    resolver . resolve ( this . cookieParameter ,    this . bindingContext ,    exchange )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.reactive.result.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "HttpCookie   expected    =    new   HttpCookie (  \" name \"  ,     \" foo \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . cookie ( expected )  )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . cookieParameter ,    this . bindingContext ,    exchange )  ;", "assertEquals ( expected ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveCookieArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "Object   result    =    this . resolver . resolve ( this . cookieStringParameter ,    this . bindingContext ,    exchange )  . block (  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveCookieDefaultValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "HttpCookie   cookie    =    new   HttpCookie (  \" name \"  ,     \" foo \"  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( mock . http . server . reactive . test . MockServerHttpRequest . get (  \"  /  \"  )  . cookie ( cookie )  )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( this . cookieStringParameter ,    this . bindingContext ,    exchange )  ;", "assertEquals (  \" Invalid   result \"  ,    cookie . getValue (  )  ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveCookieStringArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . refresh (  )  ;", "ReactiveAdapterRegistry   adapterRegistry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "this . resolver    =    new    ( context . getBeanFactory (  )  ,    adapterRegistry )  ;", "this . bindingContext    =    new   BindingContext (  )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" params \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "this . cookieParameter    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "this . cookieStringParameter    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "this . stringParameter    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "this . cookieMonoParameter    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . cookieParameter )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . cookieStringParameter )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.CookieValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performGet (  \"  / no \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertNull ( entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals (  \" no \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualGetRequestWithoutAnnotation"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performPost (  \"  / no \"  ,    this . headers ,    null ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertNull ( entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals (  \" no - post \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualPostRequestWithoutAnnotation"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performGet (  \"  / customized \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / site 1  . com \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals ( false ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "assertEquals (  (  -  1  )  ,    entity . getHeaders (  )  . getAccessControlMaxAge (  )  )  ;", "assertEquals (  \" customized \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithCustomizedAnnotation"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performGet (  \"  / default \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \"  *  \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals ( false ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "assertEquals (  \" default \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithDefaultAnnotation"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "ResponseEntity < String >    entity    =    performGet (  \"  / default \"  ,    headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertNull ( entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals (  \" default \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithDefaultAnnotationAndNoOrigin"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" header 1  \"  )  ;", "ResponseEntity < String >    entity    =    performOptions (  \"  / ambiguous - header \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / site 1  . com \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertArrayEquals ( new   HttpMethod [  ]  {    HttpMethod . GET    }  ,    entity . getHeaders (  )  . getAccessControlAllowMethods (  )  . toArray (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" header 1  \"     }  ,    entity . getHeaders (  )  . getAccessControlAllowHeaders (  )  . toArray (  )  )  ;", "assertEquals ( true ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "}", "METHOD_END"], "methodName": ["ambiguousHeaderPreflightRequest"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "ResponseEntity < String >    entity    =    performOptions (  \"  / ambiguous - produces \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / site 1  . com \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertArrayEquals ( new   HttpMethod [  ]  {    HttpMethod . GET    }  ,    entity . getHeaders (  )  . getAccessControlAllowMethods (  )  . toArray (  )  )  ;", "assertEquals ( true ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "}", "METHOD_END"], "methodName": ["ambiguousProducesPreflightRequest"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performGet (  \"  / foo \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \"  *  \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals ( false ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "assertEquals (  \" foo \"  ,    entity . getBody (  )  )  ;", "entity    =    performGet (  \"  / bar \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \"  *  \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals ( false ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "assertEquals (  \" bar \"  ,    entity . getBody (  )  )  ;", "entity    =    performGet (  \"  / baz \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / site 1  . com \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals ( true ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "assertEquals (  \" baz \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["classLevel"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performGet (  \"  / origin - placeholder \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / site 1  . com \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals (  \" placeholder \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["customOriginDefinedViaPlaceholder"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performGet (  \"  / origin - value - attribute \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / site 1  . com \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals (  \" value - attribute \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["customOriginDefinedViaValueAttribute"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" header 1  ,    header 2  \"  )  ;", "ResponseEntity < String >    entity    =    performOptions (  \"  / customized \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / site 1  . com \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertArrayEquals ( new   HttpMethod [  ]  {    HttpMethod . GET    }  ,    entity . getHeaders (  )  . getAccessControlAllowMethods (  )  . toArray (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" header 1  \"  ,     \" header 2  \"     }  ,    entity . getHeaders (  )  . getAccessControlAllowHeaders (  )  . toArray (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" header 3  \"  ,     \" header 4  \"     }  ,    entity . getHeaders (  )  . getAccessControlExposeHeaders (  )  . toArray (  )  )  ;", "assertEquals ( false ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "assertEquals (  1  2  3  ,    entity . getHeaders (  )  . getAccessControlMaxAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithCustomizedAnnotation"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "ResponseEntity < Void >    entity    =    performOptions (  \"  / default \"  ,    this . headers ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \"  *  \"  ,    entity . getHeaders (  )  . getAccessControlAllow (  )  )  ;", "assertEquals (  1  8  0  0  ,    entity . getHeaders (  )  . getAccessControlMaxAge (  )  )  ;", "assertEquals ( false ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "}", "METHOD_END"], "methodName": ["preflightRequestWithDefaultAnnotation"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "super . setup (  )  ;", "this . headers    =    new   HttpHeaders (  )  ;", "this . headers . set (  \" http :  /  / site 1  . com \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.CrossOriginAnnotationIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( parameter . getParameterIndex (  )  )     >     0  )  ,     \" Errors   argument   must   be   declared   immediately   after   a   model   attribute   argument \"  )  ;", "int   index    =     ( parameter . getParameterIndex (  )  )     -     1  ;", "MethodParameter   attributeParam    =    MethodParameter . forExecutable ( parameter . getExecutable (  )  ,    index )  ;", "ReactiveAdapter   adapter    =    getAdapterRegistry (  )  . getAdapter ( attributeParam . getParameterType (  )  )  ;", "Assert . state (  ( adapter    =  =    null )  ,     (  \" An    @ ModelAttribute   and   an   Errors / BindingResult   argument    \"     +     (  (  \" cannot   both   be   declared   with   an   async   type   wrapper .     \"     +     \" Either   declare   the    @ ModelAttribute   without   an   async   wrapper   type   or    \"  )     +     \" handle   a   WebExchangeBindException   error   signal   through   the   async   type .  \"  )  )  )  ;", "ModelAttribute   ann    =    parameter . getParameterA ( ModelAttribute . class )  ;", "String   name    =     (  ( ann    !  =    null )     &  &     ( StringUtils . hasText ( ann . value (  )  )  )  )     ?    ann . value (  )     :    Conventions . getVariableNameForParameter ( attributeParam )  ;", "Object   errors    =    context . getModel (  )  . asMap (  )  . get (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +    name )  )  ;", "Assert . state (  ( errors    !  =    null )  ,     (  )     -  >     (  \" An   Errors / BindingResult   argument   is   expected    \"     +     (  (  \" immediately   after   the    @ ModelAttribute   argument   to   which   it   applies .     \"     +     \" For    @ RequestBody   and    @ RequestPart   arguments ,    please   declare   them   with   a   reactive    \"  )     +     \" type   wrapper   and   use   its   onError   operators   to   handle   WebExchangeBindException :     \"  )  )     +     ( parameter . getMethod (  )  )  )  ;", "return   errors ;", "}", "METHOD_END"], "methodName": ["getErrors"], "fileName": "org.springframework.web.reactive.result.method.annotation.ErrorsMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "DataBinder   binder    =    this . bindingContext . createDataBinder ( this . exchange ,    target ,    name )  ;", "return   binder . getBindingR (  )  ;", "}", "METHOD_END"], "methodName": ["createBindingResult"], "fileName": "org.springframework.web.reactive.result.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "BindingResult   bindingResult    =    createBindingResult ( new   ErrorsMethodArgumentResolverTests . Foo (  )  ,     \" foo \"  )  ;", "this . bindingContext . getModel (  )  . asMap (  )  . put (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +     \" foo \"  )  ,    bindingResult )  ;", "MethodParameter   parameter    =    this . testMethod . arg ( Errors . class )  ;", "Object   actual    =    this . resolver . resolveArgument ( parameter ,    this . bindingContext ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertSame ( bindingResult ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.web.reactive.result.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . expectedException . expectMessage (  (  \" An   Errors / BindingResult   argument   is   expected    \"     +     \" immediately   after   the    @ ModelAttribute   argument \"  )  )  ;", "MethodParameter   parameter    =    this . testMethod . arg ( Errors . class )  ;", "this . resolver . resolve ( parameter ,    this . bindingContext ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithBindingResultNotFound"], "fileName": "org.springframework.web.reactive.result.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "BindingResult   bindingResult    =    createBindingResult ( new   ErrorsMethodArgumentResolverTests . Foo (  )  ,     \" foo \"  )  ;", "MonoProcessor < BindingResult >    monoProcessor    =    MonoProcessor . create (  )  ;", "monoProcessor . onNext ( bindingResult )  ;", "this . bindingContext . getModel (  )  . asMap (  )  . put (  (  ( BindingResult . MODEL _ KEY _ PREFIX )     +     \" foo \"  )  ,    monoProcessor )  ;", "MethodParameter   parameter    =    this . testMethod . arg ( Errors . class )  ;", "Object   actual    =    this . resolver . resolveArgument ( parameter ,    this . bindingContext ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertSame ( bindingResult ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveWithMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . expectedException . expectMessage (  (  \" An    @ ModelAttribute   and   an   Errors / BindingResult   argument    \"     +     \" cannot   both   be   declared   with   an   async   type   wrapper .  \"  )  )  ;", "MethodParameter   parameter    =    this . testMethod . arg ( BindingResult . class )  ;", "this . resolver . resolve ( parameter ,    this . bindingContext ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithMonoOnBindingResultAndModelAttribute"], "fileName": "org.springframework.web.reactive.result.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   parameter    =    this . testMethod . arg ( Errors . class )  ;", "assertTrue ( this . resolver . supportsParameter ( parameter )  )  ;", "parameter    =    this . testMethod . arg ( BindingResult . class )  ;", "assertTrue ( this . resolver . supportsParameter ( parameter )  )  ;", "parameter    =    this . testMethod . arg ( ResolvableType . forClassWithGenerics ( Mono . class ,    Errors . class )  )  ;", "assertTrue ( this . resolver . supportsParameter ( parameter )  )  ;", "parameter    =    this . testMethod . arg ( String . class )  ;", "assertFalse ( this . resolver . supportsParameter ( parameter )  )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.web.reactive.result.method.annotation.ErrorsMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . resolver . supportsParameter ( this . paramNotSupported )  )  ;", "try    {", "this . resolver . supportsParameter ( this . paramAlsoNotSupported )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotSupport"], "fileName": "org.springframework.web.reactive.result.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" systemProperty \"  ,     \"  2  2  \"  )  ;", "try    {", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramSystemProperty ,    new   BindingContext (  )  ,    this . exchange )  ;", "Object   value    =    mono . block (  )  ;", "assertEquals (  2  2  ,    value )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveSystemProperty"], "fileName": "org.springframework.web.reactive.result.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . refresh (  )  ;", "ReactiveAdapterRegistry   adapterRegistry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "this . resolver    =    new    ( context . getBeanFactory (  )  ,    adapterRegistry )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" params \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "this . paramSystemProperty    =    new   MethodParameter ( method ,     0  )  ;", "this . paramNotSupported    =    new   MethodParameter ( method ,     1  )  ;", "this . paramAlsoNotSupported    =    new   MethodParameter ( method ,     2  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . paramSystemProperty )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.ExpressionValueMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . add ( ACCEPT ,    TEXT _ HTML _ VALUE )  ;", "ResponseEntity < St >    entity    =    performGet (  \"  / ambiguous \"  ,    this . headers ,    St . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \"  *  \"  ,    entity . getHeaders (  )  . getAccessControlAllowOrigin (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithAmbiguousMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performGet (  \"  / cors \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \"  *  \"  ,    entity . getHeaders (  )  . getAccessControlAllowOrigin (  )  )  ;", "assertEquals (  \" cors \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithCorsEnabled"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "performGet (  \"  / cors - restricted \"  ,    this . headers ,    St . class )  ;", "fail (  )  ;", "}    catch    ( HttpClientErrorException   e )     {", "assertEquals ( FORBIDDEN ,    e . getStatusCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["actualRequestWithCorsRejected"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < String >    entity    =    performGet (  \"  / welcome \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertNull ( entity . getHeaders (  )  . getAccessControlAllowOrigin (  )  )  ;", "assertEquals (  \" welcome \"  ,    entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["actualRequestWithoutCorsEnabled"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "ResponseEntity < String >    entity    =    performOptions (  \"  / ambiguous \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / localhost :  9  0  0  0  \"  ,    entity . getHeaders (  )  . getAccessControlAllowOrigin (  )  )  ;", "assertThat ( entity . getHeaders (  )  . getAccessControlAllowMs (  )  ,    contains ( GET )  )  ;", "assertEquals ( true ,    entity . getHeaders (  )  . getAccessControlAllowCredentials (  )  )  ;", "assertThat ( entity . getHeaders (  )  . get ( VARY )  ,    contains ( ORIGIN ,    ACCESS _ CONTROL _ REQUEST _ METHOD ,    ACCESS _ CONTROL _ REQUEST _ HEADERS )  )  ;", "}", "METHOD_END"], "methodName": ["preFlightRequestWithAmbiguousMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "ResponseEntity < String >    entity    =    performOptions (  \"  / cors \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \"  *  \"  ,    entity . getHeaders (  )  . getAccessControlAllowOrigin (  )  )  ;", "assertThat ( entity . getHeaders (  )  . getAccessControlAllowMs (  )  ,    contains ( GET ,    HEAD ,    POST )  )  ;", "}", "METHOD_END"], "methodName": ["preFlightRequestWithCorsEnabled"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "performOps (  \"  / cors - restricted \"  ,    this . headers ,    String . class )  ;", "fail (  )  ;", "}    catch    ( HttpClientErrorExcep   e )     {", "assertEquals ( FORBIDDEN ,    e . getStatusCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["preFlightRequestWithCorsRejected"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . headers . set ( ORIGIN ,     \" http :  /  / foo \"  )  ;", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "ResponseEntity < String >    entity    =    performOptions (  \"  / cors - restricted \"  ,    this . headers ,    String . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  \" http :  /  / foo \"  ,    entity . getHeaders (  )  . getAccessControlAllowOrigin (  )  )  ;", "assertThat ( entity . getHeaders (  )  . getAccessControlAllowMs (  )  ,    contains ( GET ,    POST )  )  ;", "}", "METHOD_END"], "methodName": ["preFlightRequestWithCorsRestricted"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . headers . add ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "performOps (  \"  / welcome \"  ,    this . headers ,    String . class )  ;", "fail (  )  ;", "}    catch    ( HttpClientErrorExcep   e )     {", "assertEquals ( FORBIDDEN ,    e . getStatusCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["preFlightRequestWithoutCorsEnabled"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "super . setup (  )  ;", "this . headers    =    new   HttpHeaders (  )  ;", "this . headers . setOrigin (  \" http :  /  / localhost :  9  0  0  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.GlobalCorsConfigIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   RequestEntity . class . equals ( entityType )     ?    new   RequestEntity ( body ,    request . getHeaders (  )  ,    request . getMethod (  )  ,    request . getURI (  )  )     :    new   HttpEntity ( body ,    request . getHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["createEntity"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageReader <  ?  >  >    readers    =    new   ArrayList <  >  (  )  ;", "readers . add ( new   DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "return   new    ( readers ,    ReactiveAdapterRegistry . getSharedInstance (  )  )  ;", "}", "METHOD_END"], "methodName": ["createResolver"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . resolver . supportsParameter ( this . testMethod . arg ( Mono . class ,    String . class )  )  )  ;", "assertFalse ( this . resolver . supportsParameter ( this . testMethod . arg ( String . class )  )  )  ;", "try    {", "this . resolver . supportsParameter ( this . testMethod . arg ( Mono . class ,    httpEntityType ( String . class )  )  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotSupport"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( CompletableFuture . class ,    String . class )  ;", "< CompletableFuture < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "entity . getBody (  )  . whenComplete (  (    body ,    ex )     -  >     {", "assertNull ( body )  ;", "assertNull ( ex )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithCompletableFuture"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( Flowable . class ,    String . class )  ;", "< Flowable < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "StepVerifier . create ( entity . getBody (  )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithFlowable"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( Flux . class ,    String . class )  ;", "< Flux < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "StepVerifier . create ( entity . getBody (  )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithFlux"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( Mono . class ,    String . class )  ;", "< Mono < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "StepVerifier . create ( entity . getBody (  )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( Observable . class ,    String . class )  ;", "< Observable < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "StepVerifier . create ( RxReactiveStreams . toPublisher ( entity . getBody (  )  )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithObservable"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( Maybe . class ,    String . class )  ;", "< Maybe < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "StepVerifier . create ( entity . getBody (  )  . toFlowable (  )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithRxJava2Maybe"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( Observable . class ,    String . class )  ;", "< io . reactivex . Observable < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "StepVerifier . create ( entity . getBody (  )  . toFlowable ( BUFFER )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithRxJava2Observable"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( Single . class ,    String . class )  ;", "< io . reactivex . Single < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "StepVerifier . create ( entity . getBody (  )  . toFlowable (  )  )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithRxJava2Single"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( Single . class ,    String . class )  ;", "< Single < String >  >    entity    =    resolveValueWithEmptyBody ( type )  ;", "StepVerifier . create ( RxReactiveStreams . toPublisher ( entity . getBody (  )  )  )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithSingle"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    httpEntityType ( String . class )  ;", "< Object >    entity    =    resolveValueWithEmptyBody ( type )  ;", "assertNull ( entity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithString"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forClassWithGenerics ( HttpEntity . class ,     ( ObjectUtils . isEmpty ( generics )     ?    ResolvableType . forClass ( bodyType )     :    ResolvableType . forClassWithGenerics ( bodyType ,    generics )  )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityType"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postExchange (  \" line 1  \"  )  ;", "ResolvableType   type    =    httpEntityType ( CompletableFuture . class ,    String . class )  ;", "< CompletableFuture < String >  >    httpEntity    =    resolveValue ( exchange ,    type )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    httpEntity . getHeaders (  )  )  ;", "assertEquals (  \" line 1  \"  ,    httpEntity . getBody (  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityWithCompletableFutureBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postExchange (  \" line 1  \\ nline 2  \\ nline 3  \\ n \"  )  ;", "ResolvableType   type    =    httpEntityType ( Flux . class ,    String . class )  ;", "< Flux < String >  >    httpEntity    =    resolveValue ( exchange ,    type )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    httpEntity . getHeaders (  )  )  ;", "StepVerifier . create ( httpEntity . getBody (  )  )  . expectNext (  \" line 1  \"  )  . expectNext (  \" line 2  \"  )  . expectNext (  \" line 3  \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityWithFluxBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postExchange (  \" line 1  \"  )  ;", "ResolvableType   type    =    httpEntityType ( Mono . class ,    String . class )  ;", "< Mono < String >  >    httpEntity    =    resolveValue ( exchange ,    type )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    httpEntity . getHeaders (  )  )  ;", "assertEquals (  \" line 1  \"  ,    httpEntity . getBody (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityWithMonoBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postExchange (  \" line 1  \"  )  ;", "ResolvableType   type    =    httpEntityType ( Maybe . class ,    String . class )  ;", "< Maybe < String >  >    httpEntity    =    resolveValue ( exchange ,    type )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    httpEntity . getHeaders (  )  )  ;", "assertEquals (  \" line 1  \"  ,    httpEntity . getBody (  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityWithRxJava2MaybeBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postExchange (  \" line 1  \"  )  ;", "ResolvableType   type    =    httpEntityType ( Single . class ,    String . class )  ;", "< io . reactivex . Single < String >  >    httpEntity    =    resolveValue ( exchange ,    type )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    httpEntity . getHeaders (  )  )  ;", "assertEquals (  \" line 1  \"  ,    httpEntity . getBody (  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityWithRxJava2SingleBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postExchange (  \" line 1  \"  )  ;", "ResolvableType   type    =    httpEntityType ( Single . class ,    String . class )  ;", "< Single < String >  >    httpEntity    =    resolveValue ( exchange ,    type )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    httpEntity . getHeaders (  )  )  ;", "assertEquals (  \" line 1  \"  ,    httpEntity . getBody (  )  . toBlocking (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityWithSingleBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postExchange (  \" line 1  \"  )  ;", "ResolvableType   type    =    httpEntityType ( String . class )  ;", "< String >    httpEntity    =    resolveValue ( exchange ,    type )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    httpEntity . getHeaders (  )  )  ;", "assertEquals (  \" line 1  \"  ,    httpEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpEntityWithStringBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( post (  \"  / path \"  )  . header (  \" foo \"  ,     \" bar \"  )  . contentType ( TEXT _ PLAIN )  . body ( body )  )  ;", "}", "METHOD_END"], "methodName": ["postExchange"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postExchange (  \" line 1  \"  )  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Request . class ,    String . class )  ;", "Request < String >    request    =    resolveValue ( exchange ,    type )  ;", "assertEquals ( exchange . getRequest (  )  . getMethod (  )  ,    request . getMethod (  )  )  ;", "assertEquals ( exchange . getRequest (  )  . getURI (  )  ,    request . getUrl (  )  )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    request . getHeaders (  )  )  ;", "assertEquals (  \" line 1  \"  ,    request . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestEntity"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Mono < Object >    result    =    this . resolver . resolve ( param ,    new   BindingContext (  )  ,    exchange )  ;", "Object   value    =    result . block ( Duration . ofSeconds (  5  )  )  ;", "assertNotNull ( value )  ;", "assertTrue (  (  \" Unexpected   return   value   type :     \"     +     ( value . getClass (  )  )  )  ,    param . getParameterType (  )  . isAssignableFrom ( value . getClass (  )  )  )  ;", "return    (  ( T )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["resolveValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( post (  \"  / path \"  )  )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Mono < Object >    result    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    exchange )  ;", "< String >    httpEntity    =     (  (  < String >  )     ( result . block ( Duration . ofSeconds (  5  )  )  )  )  ;", "assertEquals ( exchange . getRequest (  )  . getHeaders (  )  ,    httpEntity . getHeaders (  )  )  ;", "return    (  (  < T >  )     ( httpEntity )  )  ;", "}", "METHOD_END"], "methodName": ["resolveValueWithEmptyBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "testSupports ( this . testMethod . arg ( httpEntityType ( String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( Mono . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( Single . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( Single . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( Maybe . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( CompletableFuture . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( Flux . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( Observable . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( Observable . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( httpEntityType ( Flowable . class ,    String . class )  )  )  ;", "testSupports ( this . testMethod . arg ( ResolvableType . forClassWithGenerics ( RequestEntity . class ,    String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( parameter )  )  ;", "}", "METHOD_END"], "methodName": ["testSupports"], "fileName": "org.springframework.web.reactive.result.method.annotation.HttpEntityArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionStatus ;", "}", "METHOD_END"], "methodName": ["getSessionStatus"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContext"}, {"methodBody": ["METHOD_START", "{", "HandlerResult   result    =    binderMethod . invokeForHandlerResult ( exchange ,    this . binderMethodContext ,    dataBinder )  ;", "if    (  ( result    !  =    null )     &  &     (  ( result . getReturnValue (  )  )     !  =    null )  )     {", "throw   new   IllegalStateException (  (  \"  @    methods   should   return   void :     \"     +    binderMethod )  )  ;", "}", "if    (  !  ( this . binderMethodContext . getModel (  )  . asMap (  )  . isEmpty (  )  )  )     {", "throw   new   IllegalStateException (  (  \"  @    methods   should   not   add   model   attributes :     \"     +    binderMethod )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeBinderMethod"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . saveModelOper    !  =    null )     {", "this . saveModelOperrun (  )  ;", "}", "}", "METHOD_END"], "methodName": ["saveModel"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContext"}, {"methodBody": ["METHOD_START", "{", "this . saveModelOperation    =     (  )     -  >     {", "if    ( getSessionStatus (  )  . isComplete (  )  )     {", "attributesHandler . cleanupAttributes ( session )  ;", "} else    {", "attributesHandler . storeAttributes ( session ,    getModel (  )  . asMap (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["setSessionContext"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContext"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "context    =    create (  \" initBinder \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    context . createDataBinder ( exchange ,    null ,    null )  ;", "assertNotNull ( dataBinder . getDisallowedFields (  )  )  ;", "assertEquals (  \" id \"  ,    dataBinder . getDisallowedFields (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["createBinder"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContextTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "context    =    create (  \" initBinderWithAttributeName \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    context . createDataBinder ( exchange ,    null ,    null )  ;", "assertNull ( dataBinder . getDisallowedFields (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBinderNullAttrName"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContextTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / path ? requestParam =  2  2  \"  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "ReactiveAdapterRegistry   adapterRegistry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "this . argumentResolvers . add ( new   RequestParamMethodArgumentResolver ( null ,    adapterRegistry ,    false )  )  ;", "context    =    create (  \" initBinderTypeConversion \"  ,    WebDataBinder . class ,    int . class )  ;", "WebDataBinder   dataBinder    =    context . createDataBinder ( exchange ,    null ,     \" foo \"  )  ;", "assertNotNull ( dataBinder . getDisallowedFields (  )  )  ;", "assertEquals (  \" requestParam -  2  2  \"  ,    dataBinder . getDisallowedFields (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["createBinderTypeConversion"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContextTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "context    =    create (  \" initBinderWithAttributeName \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    context . createDataBinder ( exchange ,    null ,     \" foo \"  )  ;", "assertNotNull ( dataBinder . getDisallowedFields (  )  )  ;", "assertEquals (  \" id \"  ,    dataBinder . getDisallowedFields (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["createBinderWithAttrName"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContextTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "context    =    create (  \" initBinderWithAttributeName \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    context . createDataBinder ( exchange ,    null ,     \" invalidName \"  )  ;", "assertNull ( dataBinder . getDisallowedFields (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBinderWithAttrNameNoMatch"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContextTests"}, {"methodBody": ["METHOD_START", "{", "ConversionService   conversionService    =    new   DefaultFormattingConversionService (  )  ;", "bindingInitializer . setConversionService ( conversionService )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "context    =    create (  \" initBinder \"  ,    WebDataBinder . class )  ;", "WebDataBinder   dataBinder    =    context . createDataBinder ( exchange ,    null ,    null )  ;", "assertSame ( conversionService ,    dataBinder . getConversionService (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBinderWithGlobalInitialization"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContextTests"}, {"methodBody": ["METHOD_START", "{", "Object   handler    =    new   InitBinderBindingContextTests . InitBinderHandler (  )  ;", "Method   method    =    handler . getClass (  )  . getMethod ( methodName ,    parameterTypes )  ;", "SyncInvocableHandlerMethod   handlerMethod    =    new   SyncInvocableHandlerMethod ( handler ,    method )  ;", "handlerMethod . setArgumentResolvers ( new   ArrayList <  >  ( this . argumentResolvers )  )  ;", "handlerMethod . setParameterNameDiscoverer ( new   LocalVariableTableParameterNameDiscoverer (  )  )  ;", "return   new   InitBinderBindingContext ( this . bindingInitializer ,    Collections . singletonList ( handlerMethod )  )  ;", "}", "METHOD_END"], "methodName": ["createBindingContext"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContextTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "context    =    create (  \" initBinderReturnValue \"  ,    WebDataBinder . class )  ;", "context . createDataBinder ( exchange ,    null ,     \" invalidName \"  )  ;", "}", "METHOD_END"], "methodName": ["returnValueNotExpected"], "fileName": "org.springframework.web.reactive.result.method.annotation.InitBinderBindingContextTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  }  \"  ;", "assertEquals ( expected ,    performGet (  \"  / response / raw \"  ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewResponse"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  [  \"     +     (  \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  ,  \\  \" withView 2  \\  \"  : null ,  \\  \" withoutView \\  \"  : null }  ,  \"     +     \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  ,  \\  \" withView 2  \\  \"  : null ,  \\  \" withoutView \\  \"  : null }  ]  \"  )  ;", "assertEquals ( expected ,    performPost (  \"  / request / entity / flux \"  ,    APPLICATION _ JSON ,    Arrays . asList ( new    . JacksonViewBean (  \" with \"  ,     \" with \"  ,     \" without \"  )  ,    new    . JacksonViewBean (  \" with \"  ,     \" with \"  ,     \" without \"  )  )  ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewWithEntityFluxRequest"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  ,  \\  \" withView 2  \\  \"  : null ,  \\  \" withoutView \\  \"  : null }  \"  ;", "assertEquals ( expected ,    performPost (  \"  / request / entity / mono \"  ,    APPLICATION _ JSON ,    new    . JacksonViewBean (  \" with \"  ,     \" with \"  ,     \" without \"  )  ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewWithEntityMonoRequest"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  [  \"     +     (  \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  ,  \\  \" withView 2  \\  \"  : null ,  \\  \" withoutView \\  \"  : null }  ,  \"     +     \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  ,  \\  \" withView 2  \\  \"  : null ,  \\  \" withoutView \\  \"  : null }  ]  \"  )  ;", "List <  . JacksonViewBean >    beans    =    Arrays . asList ( new    . JacksonViewBean (  \" with \"  ,     \" with \"  ,     \" without \"  )  ,    new    . JacksonViewBean (  \" with \"  ,     \" with \"  ,     \" without \"  )  )  ;", "assertEquals ( expected ,    performPost (  \"  / request / flux \"  ,    APPLICATION _ JSON ,    beans ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewWithFluxRequest"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  [  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  }  ,  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  }  ]  \"  ;", "assertEquals ( expected ,    performGet (  \"  / response / flux \"  ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewWithFluxResponse"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  ,  \\  \" withView 2  \\  \"  : null ,  \\  \" withoutView \\  \"  : null }  \"  ;", "assertEquals ( expected ,    performPost (  \"  / request / mono \"  ,    APPLICATION _ JSON ,    new    . JacksonViewBean (  \" with \"  ,     \" with \"  ,     \" without \"  )  ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewWithMonoRequest"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  }  \"  ;", "assertEquals ( expected ,    performGet (  \"  / response / mono \"  ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewWithMonoResponse"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  }  \"  ;", "assertEquals ( expected ,    performGet (  \"  / response / entity \"  ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewWithMonoResponseEntity"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  ,  \\  \" withView 2  \\  \"  : null ,  \\  \" withoutView \\  \"  : null }  \"  ;", "assertEquals ( expected ,    performPost (  \"  / request / raw \"  ,    APPLICATION _ JSON ,    new    . JacksonViewBean (  \" with \"  ,     \" with \"  ,     \" without \"  )  ,    APPLICATION _ JSON _ UTF 8  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["jsonViewWithRequest"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonHintsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < JacksonStreamingIntegrationTests . Person >    result    =    this . webClient . get (  )  . uri (  \"  / stream \"  )  . accept ( APPLICATION _ STREAM _ JSON )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . bodyToFlux (  . class )  )  ;", "StepVerifier . create ( result )  . expectNext ( new   JacksonStreamingIntegrationTests . Person (  \" foo    0  \"  )  )  . expectNext ( new   JacksonStreamingIntegrationTests . Person (  \" foo    1  \"  )  )  . thenCancel (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["jsonStreaming"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonStreamingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < JacksonStreamingIntegrationTests . Person >    result    =    this . webClient . get (  )  . uri (  \"  / stream \"  )  . accept ( new   MediaType (  \" application \"  ,     \" stream + x - jackson - smile \"  )  )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . bodyToFlux (  . class )  )  ;", "StepVerifier . create ( result )  . expectNext ( new   JacksonStreamingIntegrationTests . Person (  \" foo    0  \"  )  )  . expectNext ( new   JacksonStreamingIntegrationTests . Person (  \" foo    1  \"  )  )  . thenCancel (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["smileStreaming"], "fileName": "org.springframework.web.reactive.result.method.annotation.JacksonStreamingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( MultiValueMap . class . isAssignableFrom ( parameter . getParameterType (  )  )  )  )     {", "ResolvableType [  ]    genericTypes    =    ResolvableType . forParameter ( parameter )  . getGenerics (  )  ;", "if    (  ( genericTypes . length )     =  =     2  )     {", "Class <  ?  >    declaredClass    =    genericTypes [  1  ]  . getRawClass (  )  ;", "return    ( declaredClass    =  =    null )     |  |     (  !  ( List . class . isAssignableFrom ( declaredClass )  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isSingleValueMap"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariableMapMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MultiValueMap < String ,    String >  >    matrixVariables    =    this . exchange . getAttribute ( HandlerMapping . MATRIX _ VARIABLES _ ATTRIBUTE )  ;", "MultiValueMap < String ,    String >    params    =    new   util . LinkedMultiValueMap (  )  ;", "matrixVariables . put ( pathVarName ,    params )  ;", "return   params ;", "}", "METHOD_END"], "methodName": ["getMatrixVariables"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    getMatrixVariables (  \" cars \"  )  ;", "params . add (  \" colors \"  ,     \" red \"  )  ;", "params . add (  \" colors \"  ,     \" green \"  )  ;", "params . add (  \" colors \"  ,     \" blue \"  )  ;", "params . add (  \" year \"  ,     \"  2  0  1  2  \"  )  ;", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . matrixAttribute (  )  . noName (  )  )  . arg ( Map . class ,    String . class ,    String . class )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    String >    map    =     (  ( Map < String ,    String >  )     ( this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  )  )  ;", "assertNotNull ( map )  ;", "assertEquals (  \" red \"  ,    map . get (  \" colors \"  )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . matrixAttribute (  )  . noPathVar (  )  )  . arg ( MultiValueMap . class ,    String . class ,    String . class )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "MultiValueMap < String ,    String >    multivalueMap    =     (  ( MultiValueMap < String ,    String >  )     ( this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  )  )  ;", "assertEquals ( Arrays . asList (  \" red \"  ,     \" green \"  ,     \" blue \"  )  ,    multivalueMap . get (  \" colors \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params 2     =    getMatrixVariables (  \" planes \"  )  ;", "params 2  . add (  \" colors \"  ,     \" yellow \"  )  ;", "params 2  . add (  \" colors \"  ,     \" orange \"  )  ;", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . matrixAttribute (  )  . pathVar (  \" cars \"  )  )  . arg ( MultiValueMap . class ,    String . class ,    String . class )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    String >    map    =     (  ( Map < String ,    String >  )     ( this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    map )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNoMatch"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . matrixAttribute (  )  . noName (  )  )  . arg ( Map . class ,    String . class ,    String . class )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    String >    map    =     (  ( Map < String ,    String >  )     ( this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    map )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNoParams"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params 1     =    getMatrixVariables (  \" cars \"  )  ;", "params 1  . add (  \" colors \"  ,     \" red \"  )  ;", "params 1  . add (  \" colors \"  ,     \" purple \"  )  ;", "MultiValueMap < String ,    String >    params 2     =    getMatrixVariables (  \" planes \"  )  ;", "params 2  . add (  \" colors \"  ,     \" yellow \"  )  ;", "params 2  . add (  \" colors \"  ,     \" orange \"  )  ;", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . matrixAttribute (  )  . pathVar (  \" cars \"  )  )  . arg ( MultiValueMap . class ,    String . class ,    String . class )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    String >    mapForPathVar    =     (  ( Map < String ,    String >  )     ( this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  )  )  ;", "assertNotNull ( mapForPathVar )  ;", "assertEquals ( Arrays . asList (  \" red \"  ,     \" purple \"  )  ,    mapForPathVar . get (  \" colors \"  )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . matrixAttribute (  )  . noName (  )  )  . arg ( Map . class ,    String . class ,    String . class )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    String >    mapAll    =     (  ( Map < String ,    String >  )     ( this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  )  )  ;", "assertNotNull ( mapAll )  ;", "assertEquals (  \" red \"  ,    mapAll . get (  \" colors \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentPathVariable"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . exchange . getAttributes (  )  . put ( HandlerMapping . MATRIX _ VARIABLES _ ATTRIBUTE ,    new   LinkedHashMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . resolver . supportsParameter ( this . testMethod . arg ( String . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . noName (  )  )  . arg ( Map . class ,    String . class ,    String . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . noPathVar (  )  )  . arg ( MultiValueMap . class ,    String . class ,    String . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . pathVar (  \" cars \"  )  )  . arg ( MultiValueMap . class ,    String . class ,    String . class )  )  )  ;", "assertFalse ( this . resolver . supportsParameter ( this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . name (  \" name \"  )  )  . arg ( Map . class ,    String . class ,    String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    MultiValueMap < String ,    String >  >    matrixVariables    =    this . exchange . getAttribute ( HandlerMapping . MATRIX _ VARIABLES _ ATTRIBUTE )  ;", "MultiValueMap < String ,    String >    params    =    new   util . LinkedMultiValueMap (  )  ;", "matrixVariables . put ( pathVarName ,    params )  ;", "return   params ;", "}", "METHOD_END"], "methodName": ["getVariablesFor"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    getVariablesFor (  \" cars \"  )  ;", "params . add (  \" colors \"  ,     \" red \"  )  ;", "params . add (  \" colors \"  ,     \" green \"  )  ;", "params . add (  \" colors \"  ,     \" blue \"  )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . noName (  )  )  . arg ( List . class ,    String . class )  ;", "assertEquals ( Arrays . asList (  \" red \"  ,     \" green \"  ,     \" blue \"  )  ,    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . matrixAttribute (  )  . name (  \" year \"  )  )  . arg ( int . class )  ;", "Object   actual    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  ;", "assertEquals (  2  0  1  3  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentDefaultValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "getVariablesFor (  \" var 1  \"  )  . add (  \" colors \"  ,     \" red \"  )  ;", "getVariablesFor (  \" var 2  \"  )  . add (  \" colors \"  ,     \" green \"  )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . noName (  )  )  . arg ( List . class ,    String . class )  ;", "this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentMultipleMatches"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    params    =    getVariablesFor (  \" cars \"  )  ;", "params . add (  \" anotherYear \"  ,     \"  2  0  1  2  \"  )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . name (  \" year \"  )  )  . arg ( int . class )  ;", "Object   actual    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  ;", "assertEquals (  2  0  1  3  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNoMatch"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "getVariablesFor (  \" cars \"  )  . add (  \" year \"  ,     \"  2  0  0  6  \"  )  ;", "getVariablesFor (  \" bikes \"  )  . add (  \" year \"  ,     \"  2  0  0  5  \"  )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . name (  \" year \"  )  )  . arg ( int . class )  ;", "Object   actual    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  ;", "assertEquals (  2  0  0  6  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentPathVariable"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . matrixAttribute (  )  . noName (  )  )  . arg ( List . class ,    String . class )  ;", "this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentRequired"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . exchange . getAttributes (  )  . put ( HandlerMapping . MATRIX _ VARIABLES _ ATTRIBUTE ,    new   LinkedHashMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . resolver . supportsParameter ( this . testMethod . arg ( String . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . noName (  )  )  . arg ( List . class ,    String . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testM ( MvcAnnotationPredicates . matrixAttribute (  )  . name (  \" year \"  )  )  . arg ( int . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.MatrixVariablesMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  ;", "MethodParameter   param    =    this . testMethod . arg (  . TestBean [  ]  . class )  ;", ". TestBean [  ]    value    =    resolveValue ( param ,    body )  ;", "assertArrayEquals ( new    . TestBean [  ]  {    new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    new    . TestBean (  \" f 2  \"  ,     \" b 2  \"  )     }  ,    value )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    post (  \"  / path \"  )  . contentType ( APPLICATION _ JSON )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Mono . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Mono <  . TestBean >    result    =     (  ( Mono <  . TestBean >  )     ( this . resolver . readBody ( param ,    true ,    this . bindingContext ,    exchange )  . block (  )  )  )  ;", "StepVerifier . create ( result )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Flowable . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Flowable <  ?  >    flowable    =    resolveValue ( param ,    body )  ;", "assertEquals ( Arrays . asList ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    new    . TestBean (  \" f 2  \"  ,     \" b 2  \"  )  )  ,    flowable . toList (  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["flowableTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Flux . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Flux <  . TestBean >    flux    =    resolveValue ( param ,    body )  ;", "assertEquals ( Arrays . asList ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    new    . TestBean (  \" f 2  \"  ,     \" b 2  \"  )  )  ,    flux . collectList (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["fluxTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( CompletableFuture . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "CompletableFuture <  ?  >    future    =    resolveValue ( param ,    body )  ;", "assertEquals ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    future . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["futureTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( List . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "List <  ?  >    list    =    resolveValue ( param ,    body )  ;", "assertEquals ( Arrays . asList ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    new    . TestBean (  \" f 2  \"  ,     \" b 2  \"  )  )  ,    list )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  \"  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" f 1  \"  )  ;", "map . put (  \" bar \"  ,     \" b 1  \"  )  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Map . class ,    String . class ,    String . class )  ;", "Mrameter   param    =    this . testMrg ( type )  ;", "Map < String ,    String >    actual    =    resolveValue ( param ,    body )  ;", "assertEquals ( map ,    actual )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    post (  \"  / path \"  )  . body (  \"  {  \\  \" bar \\  \"  :  \\  \" BARBAR \\  \"  ,  \\  \" foo \\  \"  :  \\  \" FOOFOO \\  \"  }  \"  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Mono . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Mono < Object >    result    =    this . resolver . readBody ( param ,    true ,    this . bindingContext ,    exchange )  ;", "Mono <  . TestBean >    value    =     (  ( Mono <  . TestBean >  )     ( result . block ( Duration . ofSeconds (  1  )  )  )  )  ;", "StepVerifier . create ( value )  . expectError ( UnsupportedMediaTypeStatusException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["missingContentType"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Mono . class ,    ResolvableType . forClassWithGenerics ( List . class ,     . TestBean . class )  )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Mono <  ?  >    mono    =    resolveValue ( param ,    body )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( mono . block ( Duration . ofSeconds (  5  )  )  )  )  ;", "assertEquals ( Arrays . asList ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    new    . TestBean (  \" f 2  \"  ,     \" b 2  \"  )  )  ,    list )  ;", "}", "METHOD_END"], "methodName": ["monoList"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bar \\  \"  :  \\  \" BARBAR \\  \"  ,  \\  \" foo \\  \"  :  \\  \" FOOFOO \\  \"  }  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Mono . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Mono < Object >    mono    =    resolveValue ( param ,    body )  ;", "assertEquals ( new    . TestBean (  \" FOOFOO \"  ,     \" BARBAR \"  )  ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["monoTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Observable . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Observable <  ?  >    observable    =    resolveValue ( param ,    body )  ;", "assertEquals ( Arrays . asList ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    new    . TestBean (  \" f 2  \"  ,     \" b 2  \"  )  )  ,    observable . toList (  )  . toBlocking (  )  . first (  )  )  ;", "}", "METHOD_END"], "methodName": ["observableTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    MessageReaderArgumentResolverTests . AbstractParameterizedController . class . getMethod (  \" handleDto \"  ,    MessageReaderArgumentResolverTests . Identifiable . class )  ;", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( new   MessageReaderArgumentResolverTests . ConcreteParameterizedController (  )  ,    method )  ;", "MethodParameter   methodParam    =    handlerMethod . getMethodParameters (  )  [  0  ]  ;", "MessageReaderArgumentResolverTests . SimpleBean   simpleBean    =    resolveValue ( methodParam ,     \"  {  \\  \" name \\  \"     :     \\  \" Jad \\  \"  }  \"  )  ;", "assertEquals (  \" Jad \"  ,    simpleBean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedMethodArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    post (  \"  / path \"  )  . contentType ( MediaType . APPLICATION _ JSON )  . body ( body )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "Mono < Object >    result    =    this . r . readBody ( param ,    true ,    this . bindingContext ,    exchange )  ;", "Object   value    =    result . block ( Duration . ofSeconds (  5  )  )  ;", "assertNotNull ( value )  ;", "assertTrue (  (  \" Unexpected   return   value   type :     \"     +    value )  ,    param . getParameterType (  )  . isAssignableFrom ( value . getClass (  )  )  )  ;", "return    (  ( T )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["resolveValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageReader <  ?  >  >    readers    =    new   ArrayList <  >  (  )  ;", "Arrays . asList ( decoders )  . forEach (  (    decoder )     -  >    readers . add ( new   DecoderHttpMessageReader <  >  ( decoder )  )  )  ;", "return   new   Abstract ( readers )     {", "@ Override", "public   boolean   supportsParameter ( MethodParameter   parameter )     {", "return   false ;", "}", "@ Override", "public   Mono < Object >    resolveArgument ( MethodParameter   p ,    BindingContext   bc ,    ServerWebExchange   e )     {", "return   null ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["resolver"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Maybe . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Maybe <  . TestBean >    maybe    =    resolveValue ( param ,    body )  ;", "assertEquals ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    maybe . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["rxJava2MaybeTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 2  \\  \"  }  ]  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Observable . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "io . reactivex . Observable <  ?  >    observable    =    resolveValue ( param ,    body )  ;", "assertEquals ( Arrays . asList ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    new    . TestBean (  \" f 2  \"  ,     \" b 2  \"  )  )  ,    observable . toList (  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["rxJava2ObservableTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Single . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "io . reactivex . Single <  . TestBean >    single    =    resolveValue ( param ,    body )  ;", "assertEquals ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    single . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["rxJava2SingleTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setValidator ( new    . TestBeanValidator (  )  )  ;", "this . bindingContext    =    new   BindingContext ( initializer )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Single . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Single <  . TestBean >    single    =    resolveValue ( param ,    body )  ;", "assertEquals ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    single . toBlocking (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["singleTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  \"  ;", "MethodParameter   param    =    this . testMethod . arg (  . TestBean . class )  ;", ". TestBean   value    =    resolveValue ( param ,    body )  ;", "assertEquals ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  ,    value )  ;", "}", "METHOD_END"], "methodName": ["testBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  [  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  ,  \\  \" foo \\  \"  :  \\  \" f 1  \\  \"  }  ,  {  \\  \" bar \\  \"  :  \\  \" b 2  \\  \"  }  ]  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Flux . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Flux <  . TestBean >    flux    =    resolveValue ( param ,    body )  ;", "StepVerifier . create ( flux )  . expectNext ( new    . TestBean (  \" f 1  \"  ,     \" b 1  \"  )  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["validateFluxTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {  \\  \" bar \\  \"  :  \\  \" b 1  \\  \"  }  \"  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( Mono . class ,     . TestBean . class )  ;", "MethodParameter   param    =    this . testMethod . arg ( type )  ;", "Mono <  . TestBean >    mono    =    resolveValue ( param ,    body )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["validateMonoTestBean"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageReaderArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( this . exchange . getResponse (  )  . getBody (  )  )  . consumeNextWith (  (    buf )     -  >    assertEquals ( responseBody ,    dumpString ( buf ,    StandardCharsets . UTF _  8  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["assertResponseBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageWriter <  ?  >  >    writerList ;", "if    ( ObjectUtils . isEmpty ( writers )  )     {", "writerList    =    new   ArrayList (  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   ByteBufferEncoder (  )  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( CharSequenceEncoder . allMimeTypes (  )  )  )  ;", "writerList . add ( new   ResourceHttpMessageWriter (  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   Jaxb 2 XmlEncoder (  )  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   Jackson 2 JsonEncoder (  )  )  )  ;", "} else    {", "writerList    =    Arrays . asList ( writers )  ;", "}", "RequestedContentTypeResolver   resolver    =    new   RequestedContentTypeResolverBuilder (  )  . build (  )  ;", "return   new   Abstract ( writerList ,    resolver )     {  }  ;", "}", "METHOD_END"], "methodName": ["initResultHandler"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   returnType    =    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( List . class ,    MessageWriterResultHandlerTests . ParentClass . class )  ;", "List < MessageWriterResultHandlerTests . ParentClass >    body    =    Arrays . asList ( new   MessageWriterResultHandlerTests . Foo (  \" foo \"  )  ,    new   MessageWriterResultHandlerTests . Bar (  \" bar \"  )  )  ;", "this . resultHandler . writeBody ( body ,    returnType ,    this . exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON _ UTF 8  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertResponseBody (  (  \"  [  {  \\  \" type \\  \"  :  \\  \" foo \\  \"  ,  \\  \" parentProperty \\  \"  :  \\  \" foo \\  \"  }  ,  \"     +     \"  {  \\  \" type \\  \"  :  \\  \" bar \\  \"  ,  \\  \" parentProperty \\  \"  :  \\  \" bar \\  \"  }  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["jacksonTypeOfListElement"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MessageWriterResultHandlerTests . SimpleBean   body    =    new   MessageWriterResultHandlerTests . SimpleBean (  1  2  3 L ,     \" foo \"  )  ;", "MethodParameter   type    =    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( MessageWriterResultHandlerTests . Identifiable . class )  ;", "this . resultHandler . writeBody ( body ,    type ,    this . exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON _ UTF 8  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertResponseBody (  \"  {  \\  \" id \\  \"  :  1  2  3  ,  \\  \" name \\  \"  :  \\  \" foo \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["jacksonTypeWithSubType"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   returnType    =    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( List . class ,    MessageWriterResultHandlerTests . Identifiable . class )  ;", "List < MessageWriterResultHandlerTests . SimpleBean >    body    =    Arrays . asList ( new   MessageWriterResultHandlerTests . SimpleBean (  1  2  3 L ,     \" foo \"  )  ,    new   MessageWriterResultHandlerTests . SimpleBean (  4  5  6 L ,     \" bar \"  )  )  ;", "this . resultHandler . writeBody ( body ,    returnType ,    this . exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON _ UTF 8  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertResponseBody (  \"  [  {  \\  \" id \\  \"  :  1  2  3  ,  \\  \" name \\  \"  :  \\  \" foo \\  \"  }  ,  {  \\  \" id \\  \"  :  4  5  6  ,  \\  \" name \\  \"  :  \\  \" bar \\  \"  }  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["jacksonTypeWithSubTypeOfListElement"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . resultHandler . writeBody ( body ,    returnType ,    this . exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertNull ( this . exchange . getResponse (  )  . getHeaders (  )  . get (  \" Content - Type \"  )  )  ;", "StepVerifier . create ( this . exchange . getResponse (  )  . getBody (  )  )  . expectErrorMatches (  (    ex )     -  >    ex . getMessage (  )  . startsWith (  \" No   content   was   written \"  )  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["testVoid"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   body    =    new   ByteArrayOutputStream (  )  ;", "MethodParameter   type    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( OutputStream . class )  ;", "HttpMessageWriter <  ?  >    writer    =    new   EncoderHttpMessageWriter ( new   ByteBufferEncoder (  )  )  ;", "Mono < Void >    mono    =    initResultHandler ( writer )  . writeBody ( body ,    type ,    this . exchange )  ;", "StepVerifier . create ( mono )  . expectError ( IllegalStateException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["unsupportedReturnType"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . exchange . getAttributes (  )  . put ( HandlerMapping . PRODUCIBLE _ MEDIA _ TYPES _ ATTRIBUTE ,    Collections . singleton ( MediaType . APPLICATION _ JSON )  )  ;", "String   body    =     \" foo \"  ;", "MethodParameter   type    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( String . class )  ;", "this . resultHandler . writeBody ( body ,    type ,    this . exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON _ UTF 8  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["useDefaultCharset"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Resource   body    =    new   ClassPathResource (  \" logo . png \"  ,    getClass (  )  )  ;", "MethodParameter   type    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Resource . class )  ;", "this . resultHandler . writeBody ( body ,    type ,    this . exchange )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  \" image / png \"  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Content - Type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["useDefaultContentType"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testVoid ( null ,    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( void . class )  )  ;", "testVoid ( Mono . empty (  )  ,    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( Mono . class ,    Void . class )  )  ;", "testVoid ( Flux . empty (  )  ,    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( Flux . class ,    Void . class )  )  ;", "testVoid ( Completable . complete (  )  ,    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( Completable . class )  )  ;", "testVoid ( Observable . empty (  )  ,    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( Observable . class ,    Void . class )  )  ;", "MethodParameter   type    =    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( Completable . class )  ;", "testVoid ( io . reactivex . Completable . complete (  )  ,    type )  ;", "type    =    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( Observable . class ,    Void . class )  ;", "testVoid ( io . reactivex . Observable . empty (  )  ,    type )  ;", "type    =    ResolvableMethod . on ( MessageWriterResultHandlerTests . TestController . class )  . resolveReturnType ( Flowable . class ,    Void . class )  ;", "testVoid ( Flowable . empty (  )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["voidReturnType"], "fileName": "org.springframework.web.reactive.result.method.annotation.MessageWriterResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testResolveArgument ( this . testMethod . arg ( Model . class )  )  ;", "testResolveArgument ( this . testMethod . arg ( Map . class ,    String . class ,    Object . class )  )  ;", "testResolveArgument ( this . testMethod . arg ( ModelMap . class )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( Model . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( Map . class ,    String . class ,    Object . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( ModelMap . class )  )  )  ;", "assertFalse ( this . resolver . supportsParameter ( this . testMethod . arg ( Object . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "BindingContext   context    =    new   BindingContext (  )  ;", "Object   result    =    this . resolver . resolve ( parameter ,    context ,    this . exchange )  . block ( Duration . ZERO )  ;", "assertSame ( context . getModel (  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testResolveArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ctor . getParameterCount (  )  )     =  =     0  )     {", "return   Mono . just ( BeanUtils . instantiateClass ( ctor )  )  ;", "}", "return   WebExchangeDataBinder . extractValuesToBind ( exchange )  . map (  (    bindValues )     -  >     {", "ConstructorProperties   cp    =    ctor . getAnnotation (  . class )  ;", "String [  ]    paramNames    =     ( cp    !  =    null )     ?    cp . value (  )     :     . parameterNameDiscoverer . getParameterNames ( ctor )  ;", "Assert . state (  ( paramNames    !  =    null )  ,     (  )     -  >     \" Cannot   resolve   parameter   names   for   constructor    \"     +    ctor )  ;", "Class <  ?  >  [  ]  <  ?  >    paramTypes    =    ctor . getParameterTypes (  )  ;", "Assert . state (  ( paramNames . length    =  =    paramTypes . length )  ,     (  )     -  >     (  (  \" Invalid   number   of   parameter   names :     \"     +    paramNames . length )     +     \"    for   constructor    \"  )     +    ctor )  ;", "Object [  ]    args    =    new   Object [ paramTypes . length ]  ;", "WebDataBinder   binder    =    context . createDataBinder ( exchange ,    null ,    attributeName )  ;", "String   fieldDefaultPrefix    =    binder . getFieldDefaultPrefix (  )  ;", "String   fieldMarkerPrefix    =    binder . getFieldMarkerPrefix (  )  ;", "for    ( int   i    =     0  ;    i    <    paramNames . length ;    i +  +  )     {", "String   paramName    =    paramNames [ i ]  ;", "Class <  ?  >    paramType    =    paramTypes [ i ]  ;", "Object   value    =    bindValues . get ( paramName )  ;", "if    ( value    =  =    null )     {", "if    ( fieldDefaultPrefix    !  =    null )     {", "value    =    bindValues . get (  ( fieldDefaultPrefix    +    paramName )  )  ;", "}", "if    (  ( value    =  =    null )     &  &     ( fieldMarkerPrefix    !  =    null )  )     {", "if    (  ( bindValues . get (  ( fieldMarkerPrefix    +    paramName )  )  )     !  =    null )     {", "value    =    binder . getEmptyValue ( paramType )  ;", "}", "}", "}", "value    =     ( value   instanceof   List )     ?     (  ( List <  ?  >  )     ( value )  )  . toArray (  )     :    value ;", "MethodParameter   methodParam    =    new   MethodParameter ( ctor ,    i )  ;", "if    (  ( value    =  =    null )     &  &     ( methodParam . isOptional (  )  )  )     {", "args [ i ]     =     (  ( methodParam . getParameterType (  )  )     =  =     (  . class )  )     ?    Optional . empty (  )     :    null ;", "} else    {", "args [ i ]     =    binder . convertIfNecessary ( value ,    paramTypes [ i ]  ,    methodParam )  ;", "}", "}", "return   BeanUtils . instantiateClass ( ctor ,    args )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["constructAttribute"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    ctor    =    BeanUtils . findPrimaryConstructor ( clazz )  ;", "if    ( ctor    =  =    null )     {", "Constructor <  ?  >  [  ]    ctors    =    clazz . getConstructors (  )  ;", "if    (  ( ctors . length )     =  =     1  )     {", "ctor    =    ctors [  0  ]  ;", "} else    {", "try    {", "ctor    =    clazz . getDeclaredConstructor (  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   IllegalStateException (  (  \" No   primary   or   default   constructor   found   for    \"     +    clazz )  ,    ex )  ;", "}", "}", "}", "return   construct ( ctor ,    attributeName ,    context ,    exchange )  ;", "}", "METHOD_END"], "methodName": ["createAttribute"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "return   model . asMap (  )  . entrySet (  )  . stream (  )  . filter (  (    entry )     -  >     {", "if    (  !  ( entry . getKey (  )  . startsWith ( aName )  )  )     {", "return   false ;", "}", "ReactiveAdapter   adapter    =    getAdapterRegistry (  )  . getAdapter ( null ,    entry . getValue (  )  )  ;", "if    ( adapter    =  =    null )     {", "return   false ;", "}", "String   name    =    aName    +     ( ClassUtils . getShortName ( adapter . getReactiveType (  )  )  )  ;", "return   entry . getKey (  )  . equals ( name )  ;", "}  )  . findFirst (  )  . map (  (    entry )     -  >     {", "model . asMap (  )  . remove ( entry . getKey (  )  )  ;", "return   entry . getValue (  )  ;", "}  )  . orElse ( null )  ;", "}", "METHOD_END"], "methodName": ["findAndRemoveReactiveAttribute"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "int   i    =    parameter . getParameterIndex (  )  ;", "Class <  ?  >  [  ]    paramTypes    =    parameter . getExecutable (  )  . getParameterTypes (  )  ;", "return    (  ( paramTypes . length )     >     ( i    +     1  )  )     &  &     ( Errors . class . isAssignableFrom ( paramTypes [  ( i    +     1  )  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["hasErrorsArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Object   attribute    =    context . getModel (  )  . asMap (  )  . get ( attributeName )  ;", "if    ( attribute    =  =    null )     {", "attribute    =    findAndRemoveReactive ( context . getModel (  )  ,    attributeName )  ;", "}", "if    ( attribute    =  =    null )     {", "Class <  ?  >    attributeClass    =    attributeType . getRawClass (  )  ;", "Assert . state (  ( attributeClass    !  =    null )  ,     \" No   attribute   class \"  )  ;", "return   create ( attributeName ,    attributeClass ,    context ,    exchange )  ;", "}", "ReactiveAdapter   adapterFrom    =    getAdapterRegistry (  )  . getAdapter ( null ,    attribute )  ;", "if    ( adapterFrom    !  =    null )     {", "Assert . isTrue (  (  !  ( adapterFrom . isMultiValue (  )  )  )  ,     \" Data   binding   only   supports   single - value   async   types \"  )  ;", "return   Mono . from ( adapterFrom . toPublisher ( attribute )  )  ;", "} else    {", "return   Mono . justOrEmpty ( attribute )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareAttributeMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ] s    =    parameter . getParameterAnnotations (  )  ;", "for    ( Annotation   ann    : s )     {", "Validated   validAnnot    =    AnnotationUtils . getAnnotation ( ann ,    Validated . class )  ;", "if    (  ( validAnnot    !  =    null )     |  |     ( annType (  )  . getSimpleName (  )  . startsWith (  \" Valid \"  )  )  )     {", "Object   hints    =     ( validAnnot    !  =    null )     ?    validAnnot . value (  )     :    AnnotationUtils . getValue ( ann )  ;", "Object   hintArray    =     ( hints   instanceof   Object [  ]  )     ?     (  ( Object [  ]  )     ( hints )  )     :    new   Object [  ]  {    hints    }  ;", "binder . validate ( hintArray )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateIfApplicable"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "testBindBar ( this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( ModelAttributeMethodArgumentResolverTests . Bar . class )  )  ;", "}", "METHOD_END"], "methodName": ["bindDataClass"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ModelAttributeMethodArgumentResolverTests . Foo   foo    =    new   ModelAttributeMethodArgumentResolverTests . Foo (  )  ;", "foo . setName (  \" Jim \"  )  ;", "this . bindContext . getModel (  )  . addAttribute ( foo )  ;", "MethodParameter   parameter    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testBindFoo (  \" foo \"  ,    parameter ,     (    value )     -  >     {", "assertEquals (  . class ,    value . getClass (  )  )  ;", "return    (  ( Foo )     ( value )  )  ;", "}  )  ;", "assertSame ( foo ,    this . bindContext . getModel (  )  . asMap (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["bindExisting"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ModelAttributeMethodArgumentResolverTests . Foo   foo    =    new   ModelAttributeMethodArgumentResolverTests . Foo (  )  ;", "foo . setName (  \" Jim \"  )  ;", "this . bindContext . getModel (  )  . addAttribute (  \" fooMono \"  ,    Mono . just ( foo )  )  ;", "MethodParameter   parameter    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testBindFoo (  \" foo \"  ,    parameter ,     (    value )     -  >     {", "assertEquals (  . class ,    value . getClass (  )  )  ;", "return    (  ( Foo )     ( value )  )  ;", "}  )  ;", "assertSame ( foo ,    this . bindContext . getModel (  )  . asMap (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["bindExistingMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ModelAttributeMethodArgumentResolverTests . Foo   foo    =    new   ModelAttributeMethodArgumentResolverTests . Foo (  )  ;", "foo . setName (  \" Jim \"  )  ;", "String   modelKey    =     \" fooMono \"  ;", "this . bindContext . getModel (  )  . addAttribute ( modelKey ,    Mono . just ( foo )  )  ;", "MethodParameter   parameter    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( Mono . class ,    ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testBindFoo ( modelKey ,    parameter ,     (    mono )     -  >     {", "assertTrue ( mono . getClass (  )  . getName (  )  ,     ( mono   instanceof   Mono )  )  ;", "Object   value    =     (  ( Mono <  ?  >  )     ( mono )  )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  . class ,    value . getClass (  )  )  ;", "return    (  ( Foo )     ( value )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["bindExistingMonoToMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ModelAttributeMethodArgumentResolverTests . Foo   foo    =    new   ModelAttributeMethodArgumentResolverTests . Foo (  )  ;", "foo . setName (  \" Jim \"  )  ;", "this . bindContext . getModel (  )  . addAttribute (  \" fooSingle \"  ,    Single . just ( foo )  )  ;", "MethodParameter   parameter    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testBindFoo (  \" foo \"  ,    parameter ,     (    value )     -  >     {", "assertEquals (  . class ,    value . getClass (  )  )  ;", "return    (  ( Foo )     ( value )  )  ;", "}  )  ;", "assertSame ( foo ,    this . bindContext . getModel (  )  . asMap (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["bindExistingSingle"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "testBindFoo (  \" foo \"  ,    this . testMethod . annotPresent ( ModelAttribute . class )  . arg ( ModelAttributeMethodArgumentResolverTests . Foo . class )  ,     (    value )     -  >     {", "assertEquals (  . class ,    value . getClass (  )  )  ;", "return    (  ( Foo )     ( value )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["createAndBind"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   parameter    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( Mono . class ,    ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testBindFoo (  \" fooMono \"  ,    parameter ,     (    mono )     -  >     {", "assertTrue ( mono . getClass (  )  . getName (  )  ,     ( mono   instanceof   Mono )  )  ;", "Object   value    =     (  ( Mono <  ?  >  )     ( mono )  )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  . class ,    value . getClass (  )  )  ;", "return    (  ( Foo )     ( value )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["createAndBindToMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   parameter    =    this . testMethod . annotPresent ( ModelAttribute . class )  . arg ( Single . class ,    ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testBindFoo (  \" fooSingle \"  ,    parameter ,     (    single )     -  >     {", "assertTrue ( single . getClass (  )  . getName (  )  ,     ( single   instanceof   Single )  )  ;", "Object   value    =     (  ( Single <  ?  >  )     ( single )  )  . toBlocking (  )  . value (  )  ;", "assertEquals (  . class ,    value . getClass (  )  )  ;", "return    (  ( Foo )     ( value )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["createAndBindToSingle"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelAttributeMethodArgumentResolver ( ReactiveAdapterRegistry . getSharedInstance (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["createResolver"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   MockServerWebExchange . from ( MockServerHttpRequest . post (  \"  /  \"  )  . contentType ( APPLICATION _ FORM _ URLENCODED )  . body ( formData )  )  ;", "}", "METHOD_END"], "methodName": ["postForm"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setValidator ( validator )  ;", "this . bindContext    =    new   BindingContext ( initializer )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ModelAttributeMethodArgumentResolver   resolver    =    new   ModelAttributeMethodArgumentResolver ( ReactiveAdapterRegistry . getSharedInstance (  )  ,    false )  ;", "MethodParameter   param    =    this . testMethod . annotPresent ( ModelAttribute . class )  . arg (  . Foo . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( ModelAttribute . class )  . arg ( Mono . class ,     . Foo . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg (  . Foo . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( Mono . class ,     . Foo . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ModelAttributeMethodArgumentResolver   resolver    =    new   ModelAttributeMethodArgumentResolver ( ReactiveAdapterRegistry . getSharedInstance (  )  ,    true )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg (  . Foo . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( Mono . class ,     . Foo . class )  ;", "assertTrue ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( String . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( Mono . class ,    String . class )  ;", "assertFalse ( resolver . supportsParameter ( param )  )  ;", "}", "METHOD_END"], "methodName": ["supportsWithDefaultResolution"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    createResolver (  )  . resolveArgument ( param ,    this . bindContext ,    postForm (  \" name = Robert & age =  2  5  & count =  1  \"  )  )  . block ( Duration . ZERO )  ;", ". Bar   bar    =     (  (  . Bar )     ( value )  )  ;", "assertEquals (  \" Robert \"  ,    bar . getName (  )  )  ;", "assertEquals (  2  5  ,    bar . getAge (  )  )  ;", "assertEquals (  1  ,    bar . getCount (  )  )  ;", "String   key    =     \" bar \"  ;", "String   bindingResultKey    =     ( BindingResult . MODEL _ KEY _ PREFIX )     +    key ;", "Map < String ,    Object >    map    =    bindContext . getModel (  )  . asMap (  )  ;", "assertEquals ( map . toString (  )  ,     2  ,    map . size (  )  )  ;", "assertSame ( bar ,    map . get ( key )  )  ;", "assertNotNull ( map . get ( bindingResultKey )  )  ;", "assertTrue (  (  ( map . get ( bindingResultKey )  )    instanceof   BindingResult )  )  ;", "}", "METHOD_END"], "methodName": ["testBindBar"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    createResolver (  )  . resolveArgument ( param ,    this . bindContext ,    postForm (  \" name = Robert & age =  2  5  \"  )  )  . block ( Duration . ZERO )  ;", ". Foo   foo    =    valueExtractor . apply ( value )  ;", "assertEquals (  \" Robert \"  ,    foo . getName (  )  )  ;", "assertEquals (  2  5  ,    foo . getAge (  )  )  ;", "String   bindingResultKey    =     ( BindingResult . MODEL _ KEY _ PREFIX )     +    modelKey ;", "Map < String ,    Object >    map    =    bindContext . getModel (  )  . asMap (  )  ;", "assertEquals ( map . toString (  )  ,     2  ,    map . size (  )  )  ;", "assertSame ( foo ,    map . get ( modelKey )  )  ;", "assertNotNull ( map . get ( bindingResultKey )  )  ;", "assertTrue (  (  ( map . get ( bindingResultKey )  )    instanceof   BindingResult )  )  ;", "}", "METHOD_END"], "methodName": ["testBindFoo"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    postForm (  \" age = invalid \"  )  ;", "Mono <  ?  >    mono    =    create (  )  . resolveArgument ( param ,    this . bindContext ,    exchange )  ;", "mono    =    valueMonoExtractor . apply ( mono )  ;", "StepVerifier . create ( mono )  . consumeErrorWith (  (    ex )     -  >     {", "assertTrue (  ( ex   instanceof   WebExchangeBindException )  )  ;", "WebExchangeBindException   bindException    =     (  ( WebExchangeBindException )     ( ex )  )  ;", "assertEquals (  1  ,    bindException . getErrorCount (  )  )  ;", "assertTrue ( bindException . hasFieldErrors (  \" age \"  )  )  ;", "}  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["testValidationError"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   parameter    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testValidationError ( parameter ,    Function . identity (  )  )  ;", "}", "METHOD_END"], "methodName": ["validationError"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   parameter    =    this . testMethod . annotNotPresent ( ModelAttribute . class )  . arg ( Mono . class ,    ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testValidationError ( parameter ,     (    resolvedArgumentMono )     -  >     {", "Object   value    =    resolvedArgumentMono . block ( Duration . ofSeconds (  5  )  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   Mono )  )  ;", "return    (  ( Mono <  ?  >  )     ( value )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["validationErrorToMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   parameter    =    this . testMethod . annotPresent ( ModelAttribute . class )  . arg ( Single . class ,    ModelAttributeMethodArgumentResolverTests . Foo . class )  ;", "testValidationError ( parameter ,     (    resolvedArgumentMono )     -  >     {", "Object   value    =    resolvedArgumentMono . block ( Duration . ofSeconds (  5  )  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   Single )  )  ;", "return   Mono . from ( RxReactiveStreams . toPublisher (  (  ( Single <  ?  >  )     ( value )  )  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["validationErrorToSingle"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "for    ( MethodParameter   parameter    :    handlerMethod . getMethodParameters (  )  )     {", "if    ( parameter . hasParameterAnnotation ( ModelAttribute . class )  )     {", "String   name    =     . getNameForParameter ( parameter )  ;", "Class <  ?  >    paramType    =    parameter . getParameterType (  )  ;", "if    ( sessionAttributesHandler . isHandlerSessionAttribute ( name ,    paramType )  )     {", "result . add ( name )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findModelAttributes"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializer"}, {"methodBody": ["METHOD_START", "{", "return   Optional . ofNullable ( AnnotatedElementUtils . findMergedAnnotation ( param . getAnnotatedElement (  )  ,    ModelAttribute . class )  )  . filter (  (    ann )     -  >    StringUtils . hasText ( ann . value (  )  )  )  . map ( ModelAttribute :  : value )  . orElse ( Conventions . getVariableNameForParameter ( param )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeName"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializer"}, {"methodBody": ["METHOD_START", "{", "ModelAttribute   ann    =    parameter . getParameterAnnotation ( ModelAttribute . class )  ;", "String   name    =     ( ann    !  =    null )     ?    ann . value (  )     :    null ;", "return   StringUtils . hasText ( name )     ?    name    :    Conventions . getVariableNameForParameter ( parameter )  ;", "}", "METHOD_END"], "methodName": ["getNameForParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializer"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    handlerResult . getReturnValue (  )  ;", "if    ( value    !  =    null )     {", "ResolvableType   type    =    handlerResult . getReturnType (  )  ;", "RAdapter   adapter    =    this . adapterRegistry . getAdapter ( type . getRawClass (  )  ,    value )  ;", "if    ( isAsyncVoidType ( type ,    adapter )  )     {", "return   Mono . from ( adapter . toPublisher ( value )  )  ;", "}", "String   name    =    getAttributeName ( handlerResult . getReturnTypeSource (  )  )  ;", "bindingContext . getModel (  )  . asMap (  )  . putIfAbsent ( name ,    value )  ;", "}", "return   Mono . empty (  )  ;", "}", "METHOD_END"], "methodName": ["handleResult"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializer"}, {"methodBody": ["METHOD_START", "{", "List < InvocableHandlerMethod >    modelMethods    =    this . methodResolver . getModelAttributeMethods ( handlerMethod )  ;", "SessionAttributesHandler   sessionAttributesHandler    =    this . methodResolver . getSessionAttributesHandler ( handlerMethod )  ;", "if    (  !  ( sessionAttributesHandler . hasSessionAttributes (  )  )  )     {", "return   invokeModelAttributeMethods ( bindingContext ,    modelMethods ,    exchange )  ;", "}", "return   exchange . getSession (  )  . flatMap (  (    session )     -  >     {", "Map < String ,    Object >    attributes    =    sessionAttributesHandler . retrieveAttributes ( session )  ;", "bindingContext . getModel (  )  . mergeAttributes ( attributes )  ;", "bindingContext . setSessionContext ( sessionAttributesHandler ,    session )  ;", "return   invokeModelAttributeMethods ( bindingContext ,    modelMethods ,    exchange )  . doOnSuccess (  (    aVoid )     -  >    findModelAttributes ( handlerMethod ,    sessionAttributesHandler )  . forEach (  (    name )     -  >     {", "if    (  !  ( bindingContext . getModel (  )  . containsAttribute ( name )  )  )     {", "Object   value    =    session . getRequiredAttribute ( name )  ;", "bindingContext . getModel (  )  . addAttribute ( name ,    value )  ;", "}", "}  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["initModel"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializer"}, {"methodBody": ["METHOD_START", "{", "List < Mono < HandlerResult >  >    resultList    =    new   ArrayList <  >  (  )  ;", "modelMethods . forEach (  (    invocable )     -  >    resultList . add ( invocable . invoke ( exchange ,    bindingContext )  )  )  ;", "return   Mono . zip ( resultList ,     (    objectArray )     -  >    Arrays . stream ( objectArray )  . map (  (    object )     -  >    handleResult (  (  ( HandlerResult )     ( object )  )  ,    bindingContext )  )  . collect ( Collectors . toList (  )  )  )  . flatMap ( Mono :  : when )  ;", "}", "METHOD_END"], "methodName": ["invokeModelAttributeMethods"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializer"}, {"methodBody": ["METHOD_START", "{", "return    ( adapter    !  =    null )     &  &     (  ( adapter . isNoValue (  )  )     |  |     (  ( type . resolveGeneric (  )  )     =  =     ( Void . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAsyncVoidType"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializer"}, {"methodBody": ["METHOD_START", "{", "WebSession   session    =    this . exchange . getSession (  )  . block ( Duration . ZERO )  ;", "assertNotNull ( session )  ;", ". TestBean   testBean    =    new    . TestBean (  \" Session   Bean \"  )  ;", "session . getAttributes (  )  . put (  \" bean \"  ,    testBean )  ;", ". TestController   controller    =    new    . TestController (  )  ;", "InitBinderBindingContext   context    =    getBindingContext ( controller )  ;", "Method   method    =    ResolvableMethod . on (  . TestController . class )  . annotPresent ( GetMapping . class )  . resolveMethod (  )  ;", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( controller ,    method )  ;", "this . modelInitializer . initModel ( handlerMethod ,    context ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "context . getSessionStatus (  )  . setComplete (  )  ;", "context . saveModel (  )  ;", "assertEquals (  0  ,    session . getAttributes (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["clearModelAttributeFromSession"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializerTests"}, {"methodBody": ["METHOD_START", "{", "List < SyncInvocableHandlerMethod >    binderMethods    =    MethodIntrospector . selectMethods ( controller . getClass (  )  ,    ModelInitializerTests . BINDER _ METHODS )  . stream (  )  . map (  (    method )     -  >    new   SyncInvocableHandlerMethod ( controller ,    method )  )  . collect ( Collectors . toList (  )  )  ;", "WebBindingInitializer   bindingInitializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "return   new   InitBinderBindingContext ( bindingInitializer ,    binderMethods )  ;", "}", "METHOD_END"], "methodName": ["getBindingContext"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializerTests"}, {"methodBody": ["METHOD_START", "{", "Validator   validator    =    mock ( Validator . class )  ;", ". TestController   controller    =    new    . TestController (  )  ;", "controller . setValidator ( validator )  ;", "InitBinderBindingContext   context    =    getBindingContext ( controller )  ;", "Method   method    =    ResolvableMethod . on (  . TestController . class )  . annotPresent ( GetMapping . class )  . resolveMethod (  )  ;", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( controller ,    method )  ;", "this . modelInitializer . initModel ( handlerMethod ,    context ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "WebExchangeDataBinder   binder    =    context . createDataBinder ( this . exchange ,     \" name \"  )  ;", "assertEquals ( Collections . singletonList ( validator )  ,    binder . getValidators (  )  )  ;", "}", "METHOD_END"], "methodName": ["initBinderMethod"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializerTests"}, {"methodBody": ["METHOD_START", "{", "ModelInitializerTests . TestController   controller    =    new   ModelInitializerTests . TestController (  )  ;", "InitBinderBindingContext   context    =    getBindingContext ( controller )  ;", "Method   method    =    ResolvableMethod . on ( ModelInitializerTests . TestController . class )  . annotPresent ( GetMapping . class )  . resolveMethod (  )  ;", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( controller ,    method )  ;", "this . modelInitializer . initModel ( handlerMethod ,    context ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "Map < String ,    Object >    model    =    context . getModel (  )  . asMap (  )  ;", "assertEquals (  5  ,    model . size (  )  )  ;", "Object   value    =    model . get (  \" bean \"  )  ;", "assertEquals (  \" Bean \"  ,     (  ( ModelInitializerTests . TestBean )     ( value )  )  . getName (  )  )  ;", "value    =    model . get (  \" monoBean \"  )  ;", "assertEquals (  \" Mono   Bean \"  ,     (  ( Mono < ModelInitializerTests . TestBean >  )     ( value )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  . getName (  )  )  ;", "value    =    model . get (  \" singleBean \"  )  ;", "assertEquals (  \" Single   Bean \"  ,     (  ( rx . Single < ModelInitializerTests . TestBean >  )     ( value )  )  . toBlocking (  )  . value (  )  . getName (  )  )  ;", "value    =    model . get (  \" voidMethodBean \"  )  ;", "assertEquals (  \" Void   Method   Bean \"  ,     (  ( ModelInitializerTests . TestBean )     ( value )  )  . getName (  )  )  ;", "value    =    model . get (  \" voidMonoMethodBean \"  )  ;", "assertEquals (  \" Void   Mono   Method   Bean \"  ,     (  ( ModelInitializerTests . TestBean )     ( value )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributeMethods"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializerTests"}, {"methodBody": ["METHOD_START", "{", "ModelInitializerTests . TestController   controller    =    new   ModelInitializerTests . TestController (  )  ;", "InitBinderBindingContext   context    =    getBindingContext ( controller )  ;", "Method   method    =    ResolvableMethod . on ( ModelInitializerTests . TestController . class )  . annotPresent ( PostMapping . class )  . resolveMethod (  )  ;", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( controller ,    method )  ;", "try    {", "this . modelInitializer . initModel ( handlerMethod ,    context ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertEquals (  \" Required   attribute    ' missing - bean '    is   missing .  \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["requiredSessionAttributeMissing"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializerTests"}, {"methodBody": ["METHOD_START", "{", "WebSession   session    =    this . exchange . getSession (  )  . block ( Duration . ZERO )  ;", "assertNotNull ( session )  ;", ". TestBean   testBean    =    new    . TestBean (  \" Session   Bean \"  )  ;", "session . getAttributes (  )  . put (  \" bean \"  ,    testBean )  ;", ". TestController   controller    =    new    . TestController (  )  ;", "InitBinderBindingContext   context    =    getBindingContext ( controller )  ;", "Method   method    =    ResolvableMethod . on (  . TestController . class )  . annotPresent ( GetMapping . class )  . resolveMethod (  )  ;", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( controller ,    method )  ;", "this . modelInitializer . initModel ( handlerMethod ,    context ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "context . saveModel (  )  ;", "assertEquals (  1  ,    session . getAttributes (  )  . size (  )  )  ;", "assertEquals (  \" Session   Bean \"  ,     (  (  . TestBean )     ( session . getRequiredAttribute (  \" bean \"  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["retrieveModelAttributeFromSession"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializerTests"}, {"methodBody": ["METHOD_START", "{", "ModelInitializerTests . TestController   controller    =    new   ModelInitializerTests . TestController (  )  ;", "InitBinderBindingContext   context    =    getBindingContext ( controller )  ;", "Method   method    =    ResolvableMethod . on ( ModelInitializerTests . TestController . class )  . annotPresent ( GetMapping . class )  . resolveMethod (  )  ;", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( controller ,    method )  ;", "this . modelInitializer . initModel ( handlerMethod ,    context ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "WebSession   session    =    this . exchange . getSession (  )  . block ( Duration . ZERO )  ;", "assertNotNull ( session )  ;", "assertEquals (  0  ,    session . getAttributes (  )  . size (  )  )  ;", "context . saveModel (  )  ;", "assertEquals (  1  ,    session . getAttributes (  )  . size (  )  )  ;", "assertEquals (  \" Bean \"  ,     (  ( ModelInitializerTests . TestBean )     ( session . getRequiredAttribute (  \" bean \"  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["saveModelAttributeToSession"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializerTests"}, {"methodBody": ["METHOD_START", "{", "ReactiveAdapterRegistry   adapterRegistry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "ArgumentResolverConfigurer   resolverConfigurer    =    new   ArgumentResolverConfigurer (  )  ;", "resolverConfigurer . addCustomResolver ( new   ModelArgumentResolver ( adapterRegistry )  )  ;", "ControllerMethodResolver   methodResolver    =    new   ControllerMethodResolver ( resolverConfigurer ,    Collections . emptyList (  )  ,    adapterRegistry ,    new   StaticApplicationContext (  )  )  ;", "this . modelInitializer    =    new    ( methodResolver ,    adapterRegistry )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.reactive.result.method.annotation.ModelInitializerTests"}, {"methodBody": ["METHOD_START", "{", "MultipartBodyBuilder   builder    =    new   MultipartBodyBuilder (  )  ;", "builder . part (  \" fieldPart \"  ,     \" fieldValue \"  )  ;", "builder . part (  \" fileParts \"  ,    new   ClassPathResource (  \" foo . txt \"  ,    MultipartHttpMessageReader . class )  )  ;", "builder . part (  \" fileParts \"  ,    new   ClassPathResource (  \" logo . png \"  ,    getClass (  )  )  )  ;", "builder . part (  \" jsonPart \"  ,    new    . Person (  \" Jason \"  )  )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["generateBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    webClient . post (  )  . uri (  \"  / modelAttribute \"  )  . syncBody ( generateBody (  )  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    body )     -  >    assertEquals (  \" FormBean [ fieldValue ,  [ fileParts : foo . txt , fileParts : logo . png ]  ]  \"  ,    body )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["modelAttribute"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   part   instanceof   FilePart    ?     (  ( part . name (  )  )     +     \"  :  \"  )     +     (  (  ( FilePart )     ( part )  )  . filename (  )  )     :    part . name (  )  ;", "}", "METHOD_END"], "methodName": ["partDescription"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   partsFlux . log (  )  . collectList (  )  . map ( MultipartIntegrationTests :  : partListDescription )  ;", "}", "METHOD_END"], "methodName": ["partFluxDescription"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   parts . stream (  )  . map ( MultipartIntegrationTests :  : partDescription )  . collect ( Collectors . joining (  \"  ,  \"  ,     \"  [  \"  ,     \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["partListDescription"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   partsMap . keySet (  )  . stream (  )  . sorted (  )  . map (  (    key )     -  >    partListDescription ( partsMap . get ( key )  )  )  . collect ( Collectors . joining (  \"  ,  \"  ,     \" Map [  \"  ,     \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["partMapDescription"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    webClient . post (  )  . uri (  \"  / requestBodyFlux \"  )  . syncBody ( generateBody (  )  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    body )     -  >    assertEquals (  \"  [ fieldPart , fileParts : foo . txt , fileParts : logo . png , jsonPart ]  \"  ,    body )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["requestBodyFlux"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < String >    result    =    webClient . post (  )  . uri (  \"  / requestBodyMap \"  )  . syncBody ( generateBody (  )  )  . retrieve (  )  . bodyToMono ( String . class )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    body )     -  >    assertEquals (  \" Map [  [ fieldPart ]  ,  [ fileParts : foo . txt , fileParts : logo . png ]  ,  [ jsonPart ]  ]  \"  ,    body )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["requestBodyMap"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ClientResponse >    result    =    webClient . post (  )  . uri (  \"  / requestPart \"  )  . syncBody ( generateBody (  )  )  . exchange (  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    response )     -  >    assertEquals ( HttpStatus . OK ,    response . statusCode (  )  )  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["requestPart"], "fileName": "org.springframework.web.reactive.result.method.annotation.MultipartIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return    ( Map . class . isAssignableFrom ( type )  )     &  &     (  !  ( StringUtils . hasText ( pathVariable . value (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["allVariables"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMapMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    uriTemplateVars    =    new   HashMap <  >  (  )  ;", "uriTemplateVars . put (  \" name 1  \"  ,     \" value 1  \"  )  ;", "uriTemplateVars . put (  \" name 2  \"  ,     \" value 2  \"  )  ;", "this . exchange . getAttributes (  )  . put ( HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ,    uriTemplateVars )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramMap ,    new   BindingContext (  )  ,    this . exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertEquals ( uriTemplateVars ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Object >    mono    =    this . resolver . resolveArgument ( this . paramMap ,    new   BindingContext (  )  ,    this . exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNoUriVars"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   PathVariableMapMethodArgumentResolver ( ReactiveAdapterRegistry . getSharedInstance (  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" handle \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "this . paramMap    =    new   MethodParameter ( method ,     0  )  ;", "this . paramNamedMap    =    new   MethodParameter ( method ,     1  )  ;", "this . paramMapNoAnnot    =    new   MethodParameter ( method ,     2  )  ;", "this . paramMonoMap    =    new   MethodParameter ( method ,     3  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( resolver . supportsParameter ( paramMap )  )  ;", "assertFalse ( resolver . supportsParameter ( paramNamedMap )  )  ;", "assertFalse ( resolver . supportsParameter ( paramMapNoAnnot )  )  ;", "try    {", "this . resolver . supportsParameter ( this . paramMonoMap )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( Map . class . isAssignableFrom ( type )  )  )     |  |     ( StringUtils . hasText ( pathVariable . name (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["singlePathVariable"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "BindingContext   bindingContext    =    new   BindingContext (  )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramNamedString ,    bindingContext ,    this . exchange )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectError ( ServerErrorException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["handleMissingValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "BindingContext   bindingContext    =    new   BindingContext (  )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramNotRequired ,    bindingContext ,    this . exchange )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["nullIfNotRequired"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    uriTemplateVars    =    new   HashMap <  >  (  )  ;", "uriTemplateVars . put (  \" name \"  ,     \" value \"  )  ;", "this . exchange . getAttributes (  )  . put ( HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ,    uriTemplateVars )  ;", "BindingContext   bindingContext    =    new   BindingContext (  )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramNamedString ,    bindingContext ,    this . exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertEquals (  \" value \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    uriTemplateVars    =    new   HashMap <  >  (  )  ;", "uriTemplateVars . put (  \" name \"  ,     \" value \"  )  ;", "this . exchange . getAttributes (  )  . put ( HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ,    uriTemplateVars )  ;", "BindingContext   bindingContext    =    new   BindingContext (  )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramNotRequired ,    bindingContext ,    this . exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertEquals (  \" value \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNotRequired"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    uriTemplateVars    =    new   HashMap <  >  (  )  ;", "uriTemplateVars . put (  \" name \"  ,     \" value \"  )  ;", "this . exchange . getAttributes (  )  . put ( HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ,    uriTemplateVars )  ;", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultFormattingConversionService (  )  )  ;", "BindingContext   bindingContext    =    new   BindingContext ( initializer )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramOptional ,    bindingContext ,    this . exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertEquals ( Optional . of (  \" value \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentWrappedAsOptional"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   PathVariableMethodArgumentResolver ( null ,    ReactiveAdapterRegistry . getSharedInstance (  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" handle \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "paramNamedString    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "paramString    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "paramNotRequired    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "paramOptional    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "paramMono    =    new   SynthesizingMethodParameter ( method ,     4  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . paramNamedString )  )  ;", "assertFalse ( this . resolver . supportsParameter ( this . paramString )  )  ;", "try    {", "this . resolver . supportsParameter ( this . paramMono )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "BindingContext   bindingContext    =    new   BindingContext (  )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramOptional ,    bindingContext ,    this . exchange )  ;", "StepVerifier . create ( mono )  . consumeNextWith (  (    value )     -  >     {", "assertTrue (  ( value   instanceof   Optional )  )  ;", "assertFalse (  (  ( Optional <  ?  >  )     ( value )  )  . isPresent (  )  )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["wrapEmptyWithOptional"], "fileName": "org.springframework.web.reactive.result.method.annotation.PathVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( Principal . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( Mono . class ,    Principal . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( Single . class ,    Principal . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.PrincipalArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestAttribute (  )  . noName (  )  )  . arg ( RequestAttributeMethodArgumentResolverTests . Foo . class )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "RequestAttributeMethodArgumentResolverTests . Foo   foo    =    new   RequestAttributeMethodArgumentResolverTests . Foo (  )  ;", "this . exchange . getAttributes (  )  . put (  \" foo \"  ,    foo )  ;", "mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertSame ( foo ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestAttribute (  )  . noName (  )  )  . arg ( Mono . class ,    RequestAttributeMethodArgumentResolverTests . Foo . class )  ;", "RequestAttributeMethodArgumentResolverTests . Foo   foo    =    new   RequestAttributeMethodArgumentResolverTests . Foo (  )  ;", "Mono < RequestAttributeMethodArgumentResolverTests . Foo >    fooMono    =    Mono . just ( foo )  ;", "this . exchange . getAttributes (  )  . put (  \" fooMono \"  ,    fooMono )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertSame ( fooMono ,    mono . block ( Duration . ZERO )  )  ;", "Single < RequestAttributeMethodArgumentResolverTests . Foo >    singleMono    =    Single . just ( foo )  ;", "this . exchange . getAttributes (  )  . clear (  )  ;", "this . exchange . getAttributes (  )  . put (  \" fooMono \"  ,    singleMono )  ;", "mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "Object   value    =    mono . block ( Duration . ZERO )  ;", "assertTrue (  ( value   instanceof   Mono )  )  ;", "assertSame ( foo ,     (  ( Mono <  ?  >  )     ( value )  )  . block ( Duration . ZERO )  )  ;", "this . exchange . getAttributes (  )  . clear (  )  ;", "mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertSame ( Mono . empty (  )  ,    mono . block ( Duration . ZERO )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMonoParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestAttribute (  )  . name (  \" foo \"  )  . notRequired (  )  )  . arg (  )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertNull ( mono . block (  )  )  ;", ". Foo   foo    =    new    . Foo (  )  ;", "this . exchange . getAttributes (  )  . put (  \" foo \"  ,    foo )  ;", "mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertSame ( foo ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveNotRequired"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestAttribute (  )  . name (  \" foo \"  )  )  . arg ( Optional . class ,    RequestAttributeMethodArgumentResolverTests . Foo . class )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertNotNull ( mono . block (  )  )  ;", "assertEquals ( Optional . class ,    mono . block (  )  . getClass (  )  )  ;", "assertFalse (  (  ( Optional <  ?  >  )     ( mono . block (  )  )  )  . isPresent (  )  )  ;", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultFormattingConversionService (  )  )  ;", "BindingContext   bindingContext    =    new   BindingContext ( initializer )  ;", "RequestAttributeMethodArgumentResolverTests . Foo   foo    =    new   RequestAttributeMethodArgumentResolverTests . Foo (  )  ;", "this . exchange . getAttributes (  )  . put (  \" foo \"  ,    foo )  ;", "mono    =    this . resolver . resolveArgument ( param ,    bindingContext ,    this . exchange )  ;", "assertNotNull ( mono . block (  )  )  ;", "assertEquals ( Optional . class ,    mono . block (  )  . getClass (  )  )  ;", "Optional <  ?  >    optional    =     (  ( Optional <  ?  >  )     ( mono . block (  )  )  )  ;", "assertTrue ( optional . isPresent (  )  )  ;", "assertSame ( foo ,    optional . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveOptional"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestAttribute (  )  . name (  \" specialFoo \"  )  )  . arg (  )  ;", ". Foo   foo    =    new    . Foo (  )  ;", "this . exchange . getAttributes (  )  . put (  \" specialFoo \"  ,    foo )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertSame ( foo ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithName"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . refresh (  )  ;", "ReactiveAdapterRegistry   registry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "this . resolver    =    new    ( context . getBeanFactory (  )  ,    registry )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . annot ( MvcAnnotationPredicates . requestAttribute (  )  . noName (  )  )  . arg ( RequestAttributeMethodArgumentResolverTests . Foo . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . annotPresent ( RequestAttribute . class )  . arg ( Mono . class ,    RequestAttributeMethodArgumentResolverTests . Foo . class )  )  )  ;", "assertFalse ( this . resolver . supportsParameter ( this . testMethod . annotNotPresent ( RequestAttribute . class )  . arg (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( CompletableFuture . class ,    String . class )  ;", "CompletableFuture < String >    future    =    resolveValueWithEmptyBody ( param )  ;", "future . whenComplete (  (    text ,    ex )     -  >     {", "assertNull ( text )  ;", "assertNotNull ( ex )  ;", "}  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  . notRequired (  )  )  . arg ( CompletableFuture . class ,    String . class )  ;", "future    =    resolveValueWithEmptyBody ( param )  ;", "future . whenComplete (  (    text ,    ex )     -  >     {", "assertNotNull ( text )  ;", "assertNull ( ex )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithCompletableFuture"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( Flux . class ,    String . class )  ;", "StepVerifier . create (  (  ( Flux < Void >  )     ( resolveValueWithEmptyBody ( param )  )  )  )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  . notRequired (  )  )  . arg ( Flux . class ,    String . class )  ;", "StepVerifier . create (  (  ( Flux < Void >  )     ( resolveValueWithEmptyBody ( param )  )  )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithFlux"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( Maybe . class ,    String . class )  ;", "Maybe < String >    maybe    =    resolveValueWithEmptyBody ( param )  ;", "StepVerifier . create ( maybe . toFlowable (  )  )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  . notRequired (  )  )  . arg ( Maybe . class ,    String . class )  ;", "maybe    =    resolveValueWithEmptyBody ( param )  ;", "StepVerifier . create ( maybe . toFlowable (  )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithMaybe"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( Mono . class ,    String . class )  ;", "StepVerifier . create (  (  ( Mono < Void >  )     ( resolveValueWithEmptyBody ( param )  )  )  )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  . notRequired (  )  )  . arg ( Mono . class ,    String . class )  ;", "StepVerifier . create (  (  ( Mono < Void >  )     ( resolveValueWithEmptyBody ( param )  )  )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( Observable . class ,    String . class )  ;", "Observable < String >    observable    =    resolveValueWithEmptyBody ( param )  ;", "StepVerifier . create ( RxReactiveStreams . toPublisher ( observable )  )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  . notRequired (  )  )  . arg ( Observable . class ,    String . class )  ;", "observable    =    resolveValueWithEmptyBody ( param )  ;", "StepVerifier . create ( RxReactiveStreams . toPublisher ( observable )  )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithObservable"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( Single . class ,    String . class )  ;", "Single < String >    single    =    resolveValueWithEmptyBody ( param )  ;", "StepVerifier . create ( RxReactiveStreams . toPublisher ( single )  )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  . notRequired (  )  )  . arg ( Single . class ,    String . class )  ;", "single    =    resolveValueWithEmptyBody ( param )  ;", "StepVerifier . create ( RxReactiveStreams . toPublisher ( single )  )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithSingle"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( String . class )  ;", "resolveValueWithEmptyBody ( param )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithString"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  . notRequired (  )  )  . arg ( String . class )  ;", "String   body    =    resolveValueWithEmptyBody ( param )  ;", "assertNull ( body )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithStringNotRequired"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestBody (  )  . notRequired (  )  )  . arg ( Map . class )  ;", "String   body    =    resolveValueWithEmptyBody ( param )  ;", "assertNull ( body )  ;", "}", "METHOD_END"], "methodName": ["emptyBodyWithoutContentType"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( post (  \"  / path \"  )  . body ( body )  )  ;", "Mono < Object >    result    =    this . resolver . readBody ( param ,    true ,    new   BindingContext (  )  ,    exchange )  ;", "Object   value    =    result . block ( Duration . ofSeconds (  5  )  )  ;", "assertNotNull ( value )  ;", "assertTrue (  (  \" Unexpected   return   value   type :     \"     +    value )  ,    param . getParameterType (  )  . isAssignableFrom ( value . getClass (  )  )  )  ;", "return    (  ( T )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["resolveValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . post (  \"  / path \"  )  )  ;", "Mono < Object >    result    =    this . resolver . resolve ( param ,    new   BindingContext (  )  ,    exchange )  ;", "Object   value    =    result . block ( Duration . ofSeconds (  5  )  )  ;", "if    ( value    !  =    null )     {", "assertTrue (  (  \" Unexpected   parameter   type :     \"     +    value )  ,    param . getParameterType (  )  . isAssignableFrom ( value . getClass (  )  )  )  ;", "}", "return    (  ( T )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["resolveValueWithEmptyBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageReader <  ?  >  >    readers    =    new   ArrayList <  >  (  )  ;", "readers . add ( new   DecoderHttpMessageReader ( StringDecoder . allMimeTypes (  )  )  )  ;", "this . resolver    =    new    ( readers ,    ReactiveAdapterRegistry . getSharedInstance (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" line 1  \"  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( String . class )  ;", "String   value    =    resolveValue ( param ,    body )  ;", "assertEquals ( body ,    value )  ;", "}", "METHOD_END"], "methodName": ["stringBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param ;", "param    =    this . testM ( MvcAnnotationPredicates . requestBody (  )  )  . arg ( Mono . class ,    String . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMNotPresent ( RequestBody . class )  . arg ( String . class )  ;", "assertFalse ( this . resolver . supportsParameter ( param )  )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestBodyArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   Map . class . isAssignableFrom ( type )  ;", "}", "METHOD_END"], "methodName": ["allParams"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMapMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value 1     =     \" bar \"  ;", "String   value 2     =     \" baz \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header ( name ,    value 1  ,    value 2  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "HttpHeaders   expected    =    new   HttpHeaders (  )  ;", "expected . add ( name ,    value 1  )  ;", "expected . add ( name ,    value 2  )  ;", "Mono < Object >    mono    =    resolver . resolve ( paramHttpHeaders ,    null ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   HttpHeaders )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveHttpHeadersArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value    =     \" bar \"  ;", "Map < String ,    String >    expected    =    Collections . singletonMap ( name ,    value )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header ( name ,    value )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "Mono < Object >    mono    =    resolver . resolve ( paramMap ,    null ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   Map )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMapArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" foo \"  ;", "String   value 1     =     \" bar \"  ;", "String   value 2     =     \" baz \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header ( name ,    value 1  ,    value 2  )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "MultiValueMap < String ,    String >    expected    =    new   util . LinkedMultiValueMap (  1  )  ;", "expected . add ( name ,    value 1  )  ;", "expected . add ( name ,    value 2  )  ;", "Mono < Object >    mono    =    resolver . resolveArgument ( paramMultiValueMap ,    null ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   MultiValueMap )  )  ;", "assertEquals (  \" Invalid   result \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMultiValueMapArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver    =    new   RequestHeaderMapMethodArgumentResolver ( ReactiveAdapterRegistry . getSharedInstance (  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" params \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "paramMap    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "paramMultiValueMap    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "paramHttpHeaders    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "paramUnsupported    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "paramUnsupported    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "paramAlsoUnsupported    =    new   SynthesizingMethodParameter ( method ,     4  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Map   parameter   not   supported \"  ,    resolver . supportsParameter ( paramMap )  )  ;", "assertTrue (  \" MultiValueMap   parameter   not   supported \"  ,    resolver . supportsParameter ( paramMultiValueMap )  )  ;", "assertTrue (  \" HttpHeaders   parameter   not   supported \"  ,    resolver . supportsParameter ( paramHttpHeaders )  )  ;", "assertFalse (  \" non -  @ RequestParam   map   supported \"  ,    resolver . supportsParameter ( paramUnsupported )  )  ;", "try    {", "this . resolver . supportsParameter ( this . paramAlsoUnsupported )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return    !  ( Map . class . isAssignableFrom ( type )  )  ;", "}", "METHOD_END"], "methodName": ["singleParam"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "String   rfc 1  1  2  3 val    =     \" Thu ,     2  1    Apr    2  0  1  6     1  7  :  1  1  :  0  8     +  0  1  0  0  \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" name \"  ,    rfc 1  1  2  3 val )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramDate ,    this . bindingContext ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   Date )  )  ;", "assertEquals ( new   Date ( rfc 1  1  2  3 val )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["dateConversion"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   rfc 1  1  2  3 val    =     \" Thu ,     2  1    Apr    2  0  1  6     1  7  :  1  1  :  0  8     +  0  1  0  0  \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" name \"  ,    rfc 1  1  2  3 val )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramInstant ,    this . bindingContext ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   Instant )  )  ;", "assertEquals ( Instant . from ( DateTimeFormatter . RFC _  1  1  2  3  _ DATE _ TIME . parse ( rfc 1  1  2  3 val )  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["instantConversion"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Object >    mono    =    resolver . resolveArgument ( this . paramNamedValueStringArray ,    this . bindingContext ,    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramNamedDefaultValueStringHeader ,    this . bindingContext ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" systemProperty \"  ,     \" bar \"  )  ;", "try    {", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramSystemProperty ,    this . bindingContext ,    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveDefaultValueFromSystemProperty"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" foo \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" bar \"  ,    expected )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "System . setProperty (  \" systemProperty \"  ,     \" bar \"  )  ;", "try    {", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramResolvedNameWithExpression ,    this . bindingContext ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals ( expected ,    result )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveNameFromSystemPropertyThroughExpression"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" foo \"  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" bar \"  ,    expected )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "System . setProperty (  \" systemProperty \"  ,     \" bar \"  )  ;", "try    {", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramResolvedNameWithPlaceholder ,    this . bindingContext ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals ( expected ,    result )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveNameFromSystemPropertyThroughPlaceholder"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" foo \"  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" name \"  ,    expected )  )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramNamedDefaultValueStringHeader ,    this . bindingContext ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   String )  )  ;", "assertEquals ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveStringArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . header (  \" name \"  ,     \" foo \"  ,     \" bar \"  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "Mono < Object >    mono    =    this . resolver . resolve ( this . paramNamedValueStringArray ,    this . bindingContext ,    exchange )  ;", "Object   result    =    mono . block (  )  ;", "assertTrue (  ( result   instanceof   String [  ]  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" foo \"  ,     \" bar \"     }  ,     (  ( String [  ]  )     ( result )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveStringArrayArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . refresh (  )  ;", "ReactiveAdapterRegistry   adapterRegistry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "this . resolver    =    new    ( context . getBeanFactory (  )  ,    adapterRegistry )  ;", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultFormattingConversionService (  )  )  ;", "this . bindingContext    =    new   BindingContext ( initializer )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" params \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "this . paramNamedDefaultValueStringHeader    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "this . paramNamedValueStringArray    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "this . paramSystemProperty    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "this . paramResolvedNameWithExpression    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "this . paramResolvedNameWithPlaceholder    =    new   SynthesizingMethodParameter ( method ,     4  )  ;", "this . paramNamedValueMap    =    new   SynthesizingMethodParameter ( method ,     5  )  ;", "this . paramDate    =    new   SynthesizingMethodParameter ( method ,     6  )  ;", "this . paramInstant    =    new   SynthesizingMethodParameter ( method ,     7  )  ;", "this . paramMono    =    new   SynthesizingMethodParameter ( method ,     8  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" String   parameter   not   supported \"  ,    resolver . supportsParameter ( paramNamedDefaultValueStringHeader )  )  ;", "assertTrue (  \" String   array   parameter   not   supported \"  ,    resolver . supportsParameter ( paramNamedValueStringArray )  )  ;", "assertFalse (  \" non -  @ RequestParam   parameter   supported \"  ,    resolver . supportsParameter ( paramNamedValueMap )  )  ;", "try    {", "this . resolver . supportsParameter ( this . paramMono )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestHeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Processed   date !  \"  ,    performPost (  \"  / date - param ? date =  2  0  1  6  -  1  0  -  3  1  & date - pattern = YYYY - mm - dd \"  ,    new   HttpHeaders (  )  ,    null ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleDateParam"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingDataBindingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    formData    =    new   LinkedMultiValueMap (  )  ;", "formData . add (  \" name \"  ,     \" George \"  )  ;", "formData . add (  \" age \"  ,     \"  5  \"  )  ;", "assertEquals (  \" Processed   form :    Foo [ id =  1  ,    name =  ' George '  ,    age =  5  ]  \"  ,    performPost (  \"  / foos /  1  \"  ,    APPLICATION _ FORM _ URLENCODED ,    formData ,    TEXT _ PLAIN ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleForm"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingDataBindingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expected ,    performGet ( url ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingExceptionHandlingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  / mono - error \"  ,     \" Recovered   from   error :    Argument \"  )  ;", "}", "METHOD_END"], "methodName": ["errorBeforeFirstItem"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingExceptionHandlingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "performGet (  \"  / SPR -  1  6  0  5  1  \"  ,    new   HttpHeaders (  )  ,    St . class )  . getBody (  )  ;", "fail (  )  ;", "}    catch    ( Throwable   ex )     {", "St   message    =    ex . getMessage (  )  ;", "assertNotNull ( message )  ;", "assertTrue (  (  \" Actual :     \"     +    message )  ,    message . startsWith (  \" Error   while   extracting   response \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["exceptionAfterSeveralItems"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingExceptionHandlingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  / thrown - exception \"  ,     \" Recovered   from   error :    State \"  )  ;", "}", "METHOD_END"], "methodName": ["thrownException"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingExceptionHandlingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  / thrown - exception - with - cause \"  ,     \" Recovered   from   error :    State \"  )  ;", "}", "METHOD_END"], "methodName": ["thrownExceptionWithCause"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingExceptionHandlingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  / thrown - exception - with - cause - to - handle \"  ,     \" Recovered   from   error :    IO \"  )  ;", "}", "METHOD_END"], "methodName": ["thrownExceptionWithCauseToHandle"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingExceptionHandlingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . argumentResolverConfigurer ;", "}", "METHOD_END"], "methodName": ["getArgumentResolverConfigurer"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . messageReaders ;", "}", "METHOD_END"], "methodName": ["getMessageReaders"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . reactiveAdapterRegistry ;", "}", "METHOD_END"], "methodName": ["getReactiveAdapterRegistry"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . webBindingInitializer ;", "}", "METHOD_END"], "methodName": ["getWebBindingInitializer"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . methodResolver )     !  =    null )  ,     \" Not   initialized \"  )  ;", "InvocableHandlerMethod   invocable    =    this . methodResolver . getExceptionHandlerMethod ( exception ,    handlerMethod )  ;", "if    ( invocable    !  =    null )     {", "try    {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Invoking    @ ExceptionHandler   method :     \"     +     ( invocable . getMethod (  )  )  )  )  ;", "}", "bindingContext . getModel (  )  . asMap (  )  . clear (  )  ;", "Throwable   cause    =    exception . getCause (  )  ;", "if    ( cause    !  =    null )     {", "return   invocable . invoke ( exchange ,    bindingContext ,    exception ,    cause ,    handlerMethod )  ;", "} else    {", "return   invocable . invoke ( exchange ,    bindingContext ,    exception ,    handlerMethod )  ;", "}", "}    catch    ( Throwable   invocationEx )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  \" Failed   to   invoke :     \"     +     ( invocable . getMethod (  )  )  )  ,    invocationEx )  ;", "}", "}", "}", "return   Mono . error ( exception )  ;", "}", "METHOD_END"], "methodName": ["handleException"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . argumentResolverConfigurer    =    configurer ;", "}", "METHOD_END"], "methodName": ["setArgumentResolverConfigurer"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageReaders ,     \"  ' messageReaders '    must   not   be   null \"  )  ;", "this . messageReaders    =    messageReaders ;", "}", "METHOD_END"], "methodName": ["setMessageReaders"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . reactiveAdapterRegistry    =    registry ;", "}", "METHOD_END"], "methodName": ["setReactiveAdapterRegistry"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . webBindingInitializer    =    webBindingInitializer ;", "}", "METHOD_END"], "methodName": ["setWebBindingInitializer"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "RequestMapping   requestMapping    =    AnnotatedElementUtils . findMergedAnnotation ( element ,    RequestMapping . class )  ;", "RequestCondition <  ?  >    condition    =     ( element   instanceof   Class )     ?    getCustomTypeCondition (  (  ( Class <  ?  >  )     ( element )  )  )     :    getCustomMethodCondition (  (  ( Method )     ( element )  )  )  ;", "return   requestMapping    !  =    null    ?    createRequestMappingInfo ( requestMapping ,    condition )     :    null ;", "}", "METHOD_END"], "methodName": ["createRequestMappingInfo"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo . Builder   builder    =    RequestMappingInfo . paths ( resolveEmbeddedValuesInPatterns ( requestMapping . path (  )  )  )  . methods ( requestMapping . method (  )  )  . params ( requestMapping . params (  )  )  . headers ( requestMapping . headers (  )  )  . consumes ( requestMapping . consumes (  )  )  . produces ( requestMapping . produces (  )  )  . mappingName ( requestMapping . name (  )  )  ;", "if    ( customCondition    !  =    null )     {", "builder . customCondition ( customCondition )  ;", "}", "return   builder . options ( this . config )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createRequestMappingInfo"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "return   this . contentTypeResolver ;", "}", "METHOD_END"], "methodName": ["getContentTypeResolver"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getCustomMethodCondition"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getCustomTypeCondition"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . embeddedValueResolver )     !  =    null )     {", "St   resolved    =    this . embeddedValueResolver . resolveStValue ( value )  ;", "return   resolved    !  =    null    ?    resolved    :     \"  \"  ;", "} else    {", "return   value ;", "}", "}", "METHOD_END"], "methodName": ["resolveCorsAnnotationValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . embeddedValueResolver )     =  =    null )     {", "return   patterns ;", "} else    {", "St [  ]    resolvedPatterns    =    new   St [ patterns . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( patterns . length )  ;    i +  +  )     {", "resolvedPatterns [ i ]     =    this . embeddedValueResolver . resolveStValue ( patterns [ i ]  )  ;", "}", "return   resolvedPatterns ;", "}", "}", "METHOD_END"], "methodName": ["resolveEmbeddedValuesInPatterns"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( contentTypeResolver ,     \"  ' contentTypeResolver '    must   not   be   null \"  )  ;", "this . contentTypeResolver    =    contentTypeResolver ;", "}", "METHOD_END"], "methodName": ["setContentTypeResolver"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "if    (  =  =    null )     {", "return ;", "}", "for    ( String   origin    :    origins (  )  )     {", "config . addAllowedOrigin ( resolveCorsAnnotationValue ( origin )  )  ;", "}", "for    ( RequestMethod   method    :    methods (  )  )     {", "config . addAllowedMethod ( method . name (  )  )  ;", "}", "for    ( String   header    :    allowedHeaders (  )  )     {", "config . addAllowedHeader ( resolveCorsAnnotationValue ( header )  )  ;", "}", "for    ( String   header    :    exposedHeaders (  )  )     {", "config . addExposedHeader ( resolveCorsAnnotationValue ( header )  )  ;", "}", "String   allowCredentials    =    resolveCorsAnnotationValue ( allowCredentials (  )  )  ;", "if    (  \" true \"  . equalsIgnoreCase ( allowCredentials )  )     {", "config . setAllowCredentials ( true )  ;", "} else", "if    (  \" false \"  . equalsIgnoreCase ( allowCredentials )  )     {", "config . setAllowCredentials ( false )  ;", "} else", "if    (  !  ( allowCredentials . isEmpty (  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  \"  @ CrossOrigin \\  ' s   allowCredentials   value   must   be    \\  \" true \\  \"  ,     \\  \" false \\  \"  ,     \"     +     \" or   an   empty   string    (  \\  \"  \\  \"  )  :    current   value   is    [  \"  )     +    allowCredentials )     +     \"  ]  \"  )  )  ;", "}", "if    (  (  ( maxAge (  )  )     >  =     0  )     &  &     (  ( config . getMaxAge (  )  )     =  =    null )  )     {", "config . setMaxAge ( maxAge (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateCorsConfig"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMapping"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    RequestMappingHandlerMappingTests . ComposedAnnotationController . class ;", "Method   method    =    clazz . getMethod ( methodName )  ;", "RequestMappingInfo   info    =    this . handlerMapping . getMappingForMethod ( method ,    clazz )  ;", "assertNotNull ( info )  ;", "Set < PathPattern >    paths    =    info . getPatternsCondition (  )  . getPatterns (  )  ;", "assertEquals (  1  ,    paths . size (  )  )  ;", "assertEquals ( path ,    paths . iterator (  )  . next (  )  . getPatternString (  )  )  ;", "Set < RequestMethod >    methods    =    info . getMethodsCondition (  )  . getMethods (  )  ;", "assertEquals (  1  ,    methods . size (  )  )  ;", "assertEquals ( requestMethod ,    methods . iterator (  )  . next (  )  )  ;", "return   info ;", "}", "METHOD_END"], "methodName": ["assertComposedAnnotationMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =    requestMethod . name (  )  . toLowerCase (  )  ;", "String   path    =     \"  /  \"     +    methodName ;", "return   assertComposedAMapping ( methodName ,    path ,    requestMethod )  ;", "}", "METHOD_END"], "methodName": ["assertComposedAnnotationMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "assertComposedAnnotationMapping ( DELETE )  ;", "}", "METHOD_END"], "methodName": ["deleteMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "assertComposedAnnotationMapping ( GET )  ;", "}", "METHOD_END"], "methodName": ["getMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   requestMappingInfo    =    assertComposedAnnotationMapping ( GET )  ;", "assertArrayEquals ( new   MediaType [  ]  {    MediaType . ALL    }  ,    new   ArrayList ( requestMappingInfo . getConsumesCondition (  )  . getConsumableMediaTypes (  )  )  . toArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMappingOverridesConsumesFromTypeLevelAnnotation"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "assertComposedAnnotationMapping ( PATCH )  ;", "}", "METHOD_END"], "methodName": ["patchMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "assertComposedAnnotationMapping ( POST )  ;", "}", "METHOD_END"], "methodName": ["postMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "assertComposedAnnotationMapping ( PUT )  ;", "}", "METHOD_END"], "methodName": ["putMapping"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "this . handlerMapping . setEmbeddedValueResolver (  (    value )     -  >     \"  /  $  { pattern }  / bar \"  . equals ( value )     ?     \"  / foo / bar \"     :    value )  ;", "String [  ]    patterns    =    new   String [  ]  {     \"  / foo \"  ,     \"  /  $  { pattern }  / bar \"     }  ;", "String [  ]    result    =    this . handlerMapping . resolveEmbeddedValuesInPatterns ( patterns )  ;", "assertArrayEquals ( new   String [  ]  {     \"  / foo \"  ,     \"  / foo / bar \"     }  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveEmbeddedValuesInPatterns"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingInfo   info    =    assertComposedAnnotationMapping (  \" postJson \"  ,     \"  / postJson \"  ,    POST )  ;", "assertEquals ( APPLICATION _ JSON _ VALUE ,    info . getConsumesCondition (  )  . getConsumableMediaTypes (  )  . iterator (  )  . next (  )  . toString (  )  )  ;", "assertEquals ( APPLICATION _ JSON _ VALUE ,    info . getProducesCondition (  )  . getProducibleMediaTypes (  )  . iterator (  )  . next (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveRequestMappingViaComposedAnnotation"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "this . handlerMapping . setApplicationContext ( wac )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerMappingTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / text \"  ;", "HttpHeaders   headers    =    getRestTemplate (  )  . headForHeaders ( url )  ;", "String   contentType    =    headers . getFirst (  \" Content - Type \"  )  ;", "assertNotNull ( contentType )  ;", "assertEquals (  \" text / html ; charset = utf -  8  \"  ,    contentType . toLowerCase (  )  )  ;", "assertEquals (  3  ,    headers . getContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpHead"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    expected    =    new   String [  ]  {     \"  0  \"  ,     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"  ,     \"  4  \"     }  ;", "assertArrayEquals ( expected ,    performGet (  \"  / stream \"  ,    new   HttpHeaders (  )  ,    String [  ]  . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["stream"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" Hello !  \"  ;", "assertEquals ( expected ,    performGet (  \"  / raw - response / flowable \"  ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferResponseBodyWithFlowable"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" Hello !  \"  ;", "assertEquals ( expected ,    performGet (  \"  / raw - response / flux \"  ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferResponseBodyWithFlux"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" Hello !  \"  ;", "ResponseEntity < String >    responseEntity    =    performGet (  \"  / raw - response / mono \"  ,    new   HttpHeaders (  )  ,    String . class )  ;", "assertEquals (  6  ,    responseEntity . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals ( expected ,    responseEntity . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferResponseBodyWithMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" Hello !  \"  ;", "assertEquals ( expected ,    performGet (  \"  / raw - response / observable \"  ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferResponseBodyWithObservable"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . Person   expected    =    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ;", "assertEquals ( expected ,    performGet (  \"  / raw - response / publisher \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferResponseBodyWithPublisher"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" Hello !  \"  ;", "assertEquals ( expected ,    performGet (  \"  / raw - response / rxjava 2  - observable \"  ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferResponseBodyWithRxJava2Observable"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    entity    =    performPost (  \"  / person - create / flowable \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ,    null ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithFlowableJson"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . People   people    =    new   RequestMappingMessageConversionIntegrationTests . People ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "ResponseEntity < Void >    response    =    performPost (  \"  / person - create / flowable \"  ,    APPLICATION _ XML ,    people ,    null ,    Void . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithFlowableXml"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    entity    =    performPost (  \"  / person - create / flux \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ,    null ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithFluxJson"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . People   people    =    new   RequestMappingMessageConversionIntegrationTests . People ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "ResponseEntity < Void >    response    =    performPost (  \"  / person - create / flux \"  ,    APPLICATION _ XML ,    people ,    null ,    Void . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithFluxXml"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    entity    =    performPost (  \"  / person - create / mono \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    null ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  1  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    entity    =    performPost (  \"  / person - create / observable \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ,    null ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithObservableJson"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . People   people    =    new   RequestMappingMessageConversionIntegrationTests . People ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "ResponseEntity < Void >    response    =    performPost (  \"  / person - create / observable \"  ,    APPLICATION _ XML ,    people ,    null ,    Void . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithObservableXml"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    entity    =    performPost (  \"  / person - create / publisher \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ,    null ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithPublisherJson"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . People   people    =    new   RequestMappingMessageConversionIntegrationTests . People ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "ResponseEntity < Void >    response    =    performPost (  \"  / person - create / publisher \"  ,    APPLICATION _ XML ,    people ,    null ,    Void . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithPublisherXml"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    entity    =    performPost (  \"  / person - create / rxjava 2  - observable \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ,    null ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithRxJava2ObservableJson"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . People   people    =    new   RequestMappingMessageConversionIntegrationTests . People ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "String   url    =     \"  / person - create / rxjava 2  - observable \"  ;", "ResponseEntity < Void >    response    =    performPost ( url ,    APPLICATION _ XML ,    people ,    null ,    Void . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertEquals (  2  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithRxJava2ObservableXml"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    entity    =    performPost (  \"  / person - create / rxjava 2  - single \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    null ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  1  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithRxJava2Single"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    entity    =    performPost (  \"  / person - create / single \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    null ,    Void . class )  ;", "assertEquals ( OK ,    entity . getStatusCode (  )  )  ;", "assertEquals (  1  ,    getApplicationContext (  )  . getBean ( RequestMappingMessageConversionIntegrationTests . PersonCreateController . class )  . persons . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["personCreateWithSingle"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . Person   expected    =    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / person \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . Person   expected    =    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / completable - future \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithCompletableFuture"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    expected    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / flux \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithFlux"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    expected    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / list \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithList"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . Person   expected    =    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / mono \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . Person   expected    =    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / mono - declared - as - object \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithMonoDeclaredAsObject"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . Person   expected    =    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / mono - response - entity \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithMonoResponseEntity"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   actual    =    performGet (  \"  / person - response / mono - response - entity - xml \"  ,    new   HttpHeaders (  )  ,    String . class )  . getBody (  )  ;", "assertEquals (  (  \"  <  ? xml    =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" UTF -  8  \\  \"    standalone =  \\  \" yes \\  \"  ?  >  \"     +     \"  < person >  < name > Robert <  / name >  <  / person >  \"  )  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithMonoResponseEntityXml"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    expected    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / observable \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithObservable"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    expected    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / publisher \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithPublisher"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "RequestMappingMessageConversionIntegrationTests . Person   expected    =    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ;", "assertEquals ( expected ,    performGet (  \"  / person - response / single \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personResponseBodyWithSingle"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    performPost (  \"  / person - transform / person \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransform"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    performPost (  \"  / person - transform / completable - future \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithCompletableFuture"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    req    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "List <  ?  >    res    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" MARIE \"  )  )  ;", "assertEquals ( res ,    performPost (  \"  / person - transform / flowable \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    req ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithFlowable"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    req    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "List <  ?  >    res    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" MARIE \"  )  )  ;", "assertEquals ( res ,    performPost (  \"  / person - transform / flux \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    req ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithFlux"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    performPost (  \"  / person - transform / mono \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithMono"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    req    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "List <  ?  >    res    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" MARIE \"  )  )  ;", "assertEquals ( res ,    performPost (  \"  / person - transform / observable \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    req ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithObservable"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    req    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "List <  ?  >    res    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" MARIE \"  )  )  ;", "assertEquals ( res ,    performPost (  \"  / person - transform / publisher \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    req ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithPublisher"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    performPost (  \"  / person - transform / rxjava 2  - maybe \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithRxJava2Maybe"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    req    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Marie \"  )  )  ;", "List <  ?  >    res    =    Arrays . asList ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" MARIE \"  )  )  ;", "assertEquals ( res ,    performPost (  \"  / person - transform / rxjava 2  - observable \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    req ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . PERSON _ LIST )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithRxJava2Observable"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    performPost (  \"  / person - transform / rxjava 2  - single \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithRxJava2Single"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   RequestMappingMessageConversionIntegrationTests . Person (  \" ROBERT \"  )  ,    performPost (  \"  / person - transform / single \"  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    new   RequestMappingMessageConversionIntegrationTests . Person (  \" Robert \"  )  ,    RequestMappingMessageConversionIntegrationTests . JSON ,    RequestMappingMessageConversionIntegrationTests . Person . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["personTransformWithSingle"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < byte [  ]  >    response    =    performGet (  \"  / resource \"  ,    new   HttpHeaders (  )  ,    byte [  ]  . class )  ;", "assertEquals ( OK ,    response . getStatusCode (  )  )  ;", "assertTrue ( response . hasBody (  )  )  ;", "assertEquals (  9  5  1  ,    response . getHeaders (  )  . getContentLength (  )  )  ;", "assertEquals (  9  5  1  ,    response . getBody (  )  . length )  ;", "assertEquals ( new   MediaType (  \" image \"  ,     \" png \"  )  ,    response . getHeaders (  )  . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["resource"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingMessageConversionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / html \"  )  )  ;", "Entity < Void >    request    =    Entity . get ( uri )  . ifNoneMatch (  \"  \\  \" deadb 3  3 f 8 badf 0  0 d \\  \"  \"  )  . build (  )  ;", "ResponseEntity < String >    response    =    getRestTemplate (  )  . exchange ( request ,    String . class )  ;", "assertEquals ( NOT _ MODIFIED ,    response . getStatusCode (  )  )  ;", "assertNull ( response . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["etagCheckWithNotModifiedResponse"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingViewResolutionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  < html >  < body > Hello :    Jason !  <  / body >  <  / html >  \"  ;", "assertEquals ( expected ,    performGet (  \"  / html ? name = Jason \"  ,    TEXT _ HTML ,    String . class )  . getBody (  )  )  ;", "}", "METHOD_END"], "methodName": ["html"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingViewResolutionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "SimpleClientHttpRequestFactory   factory    =    new   SimpleClientHttpRequestFactory (  )     {", "@ Override", "protected   void   prepareConnection ( HttpURLConnection   conn ,    String   method )    throws   IOException    {", "super . prepareConnection ( conn ,    method )  ;", "conn . setInstanceFollowRedirects ( false )  ;", "}", "}  ;", "URI   uri    =    new   URI (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  / redirect \"  )  )  ;", "RequestEntity < Void >    request    =    RequestEntity . get ( uri )  . accept ( ALL )  . build (  )  ;", "ResponseEntity < Void >    response    =    new   client . RestTemplate ( factory )  . exchange ( request ,    Void . class )  ;", "assertEquals ( SEE _ OTHER ,    response . getStatusCode (  )  )  ;", "assertEquals (  \"  /  \"  ,    response . getHeaders (  )  . getLocation (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["redirect"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestMappingViewResolutionIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return    ( Map . class . isAssignableFrom ( type )  )     &  &     (  !  ( StringUtils . hasText ( requestParam . name (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["allParams"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMapMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . resolver . resolveArgument ( parameter ,    null ,    exchange )  . block ( Duration . ofMillis (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . name (  \"  \"  )  )  . arg ( Map . class )  ;", "Object   result    =    resolve ( param ,    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path ? foo = bar \"  )  )  )  ;", "assertTrue (  ( result   instanceof   Map )  )  ;", "assertEquals ( Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMapArgumentWithQueryString"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( MultiValueMap . class )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path ? foo = bar & foo = baz \"  )  )  ;", "Object   result    =    resolve ( param ,    exchange )  ;", "assertTrue (  ( result   instanceof   MultiValueMap )  )  ;", "assertEquals ( Collections . singletonMap (  \" foo \"  ,    Arrays . asList (  \" bar \"  ,     \" baz \"  )  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveMultiValueMapArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . name (  \"  \"  )  )  . arg ( Map . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( MultiValueMap . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . name (  \" name \"  )  )  . arg ( Map . class )  ;", "assertFalse ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( Map . class )  ;", "assertFalse ( this . resolver . supportsParameter ( param )  )  ;", "try    {", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  )  . arg ( Mono . class ,    Map . class )  ;", "this . resolver . supportsParameter ( param )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMapMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( Map . class . isAssignableFrom ( type )  )  )     |  |     ( StringUtils . hasText ( requestParam . name (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["singleParam"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "ReactiveAdapterRegistry   adapterRegistry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "this . resolver    =    new    ( null ,    adapterRegistry ,    false )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( String . class )  ;", "assertFalse ( this . resolver . supportsParameter ( param )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotSupportParameterWithDefaultResolutionTurnedOff"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param ;", "try    {", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  )  . arg ( Mono . class ,    String . class )  ;", "this . resolver . supportsParameter ( param )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "try    {", "param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( Mono . class ,    String . class )  ;", "this . resolver . supportsParameter ( param )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotSupportReactiveWrapper"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "MethodParameter   param    =    this . testMethod . annotPresent (  . class )  . arg ( String [  ]  . class )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    this . bindContext ,    exchange )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["missingRequestParam"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . resolver . resolveArgument ( parameter ,    this . bindContext ,    exchange )  . block ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  \" bar \"  )  )  . arg ( String . class )  ;", "assertEquals (  \" bar \"  ,    resolve ( param ,    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  )  . arg ( String . class )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path ? name =  \"  )  )  ;", "assertEquals (  \"  \"  ,    resolve ( param ,    exchange )  )  ;", "}", "METHOD_END"], "methodName": ["resolveEmptyValueRequiredWithoutDefault"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path ? name =  \"  )  )  ;", "MethodParameter   param    =    this . testM ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  \" bar \"  )  )  . arg ( String . class )  ;", "Object   result    =    resolve ( param ,    exchange )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveEmptyValueToDefault"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( String . class )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / path ? stringNotAnnot =  \"  )  . build (  )  ;", "assertEquals (  \"  \"  ,    resolve ( param ,    MockServerWebExchange . from ( request )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveEmptyValueWithoutDefault"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "MethodParameter   param    =    this . testMethod . arg ( ResolvableType . forClassWithGenerics ( Optional . class ,    Integer . class )  )  ;", "Object   result    =    resolve ( param ,    exchange )  ;", "assertEquals ( Optional . empty (  )  ,    result )  ;", "exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path ? name =  1  2  3  \"  )  )  ;", "result    =    resolve ( param ,    exchange )  ;", "assertEquals ( Optional . class ,    result . getClass (  )  )  ;", "Optional <  ?  >    value    =     (  ( Optional <  ?  >  )     ( result )  )  ;", "assertTrue ( value . isPresent (  )  )  ;", "assertEquals (  1  2  3  ,    value . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveOptionalParamValue"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / path ? stringNotAnnot = plainValue \"  )  . build (  )  ;", "ServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "MethodParameter   param    =    this . testMethod . annotNotPresent (  . class )  . arg ( String . class )  ;", "Object   result    =    resolve ( param ,    exchange )  ;", "assertEquals (  \" plainValue \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveSimpleTypeParam"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annotNotPresent ( RequestParam . class )  . arg ( String . class )  ;", "assertNull ( resolve ( param ,    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveSimpleTypeParamToNull"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annotPresent ( RequestParam . class )  . arg ( String [  ]  . class )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  / path ? name = foo & name = bar \"  )  . build (  )  ;", "Object   result    =    resolve ( param ,    MockServerWebExchange . from ( request )  )  ;", "assertTrue (  ( result   instanceof   String [  ]  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" foo \"  ,     \" bar \"     }  ,     (  ( String [  ]  )     ( result )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveStringArray"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  \" bar \"  )  )  . arg ( String . class )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / path ? name = foo \"  )  )  ;", "assertEquals (  \" foo \"  ,    resolve ( param ,    exchange )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithQueryString"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ReactiveAdapterRegistry   adapterRegistry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "this . resolver    =    new    ( null ,    adapterRegistry ,    true )  ;", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultFormattingConversionService (  )  )  ;", "this . bindContext    =    new   BindingContext ( initializer )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  \" bar \"  )  )  . arg ( String . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotPresent (  . class )  . arg ( String [  ]  . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . name (  \" name \"  )  )  . arg ( Map . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . name (  \"  \"  )  )  . arg ( Map . class )  ;", "assertFalse ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annotNotPresent (  . class )  . arg ( String . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  )  . arg ( String . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "param    =    this . testMethod . annot ( MvcAnnotationPredicates . requestParam (  )  . notRequired (  )  )  . arg ( String . class )  ;", "assertTrue ( this . resolver . supportsParameter ( param )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestParamMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   reason    =     (  \" Required   request   part    '  \"     +    name )     +     \"  '    is   not   present \"  ;", "return   new   server . ServerWebInputException ( reason ,    param )  ;", "}", "METHOD_END"], "methodName": ["getMissingPartException"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestPartMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "String   partName    =     ( requestPart    !  =    null )     ?    requestPart . name (  )     :     \"  \"  ;", "if    ( partName . isEmpty (  )  )     {", "partName    =    methodParam . getParameterName (  )  ;", "if    ( partName    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  \" Request   part   name   for   argument   type    [  \"     +     ( methodParam . getNestedParameterType (  )  . getName (  )  )  )     +     \"  ]    not   specified ,    and   parameter   name   information   not   found   in   class   file   either .  \"  )  )  ;", "}", "}", "return   partName ;", "}", "METHOD_END"], "methodName": ["getPartName"], "fileName": "org.springframework.web.reactive.result.method.annotation.RequestPartMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  0  0  ,    this . resultHandler . getOrder (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultOrder"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseBodyResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HandlerMethod   handlerMethod    =    new   HandlerMethod ( controller ,    method )  ;", "return   new   HandlerResult ( handlerMethod ,    null ,    handlerMethod . getReturnType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerResult"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseBodyResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageWriter <  ?  >  >    writerList    =    new   ArrayList <  >  (  5  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   ByteBufferEncoder (  )  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( CharSequenceEncoder . allMimeTypes (  )  )  )  ;", "writerList . add ( new   ResourceHttpMessageWriter (  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   Jaxb 2 XmlEncoder (  )  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   Jackson 2 JsonEncoder (  )  )  )  ;", "RequestedContentTypeResolver   resolver    =    new   RequestedContentTypeResolverBuilder (  )  . build (  )  ;", "this . resultHandler    =    new    ( writerList ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseBodyResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   controller    =    new   ResponseBodyResultHandlerTests . TestController (  )  ;", "Method   method ;", "method    =    ResolvableMethod . on ( ResponseBodyResultHandlerTests . TestController . class )  . annotPresent ( ResponseBody . class )  . resolveMethod (  )  ;", "testSupports ( controller ,    method )  ;", "method    =    ResolvableMethod . on ( ResponseBodyResultHandlerTests . TestController . class )  . annotNotPresent ( ResponseBody . class )  . resolveMethod (  \" doWork \"  )  ;", "HandlerResult   handlerResult    =    getHandlerResult ( controller ,    method )  ;", "assertFalse ( this . resultHandler . supports ( handlerResult )  )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseBodyResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   controller    =    new   ResponseBodyResultHandlerTests . TestRestController (  )  ;", "Method   method ;", "method    =    ResolvableMethod . on ( ResponseBodyResultHandlerTests . TestRestController . class )  . returning ( String . class )  . resolveMethod (  )  ;", "testSupports ( controller ,    method )  ;", "method    =    ResolvableMethod . on ( ResponseBodyResultHandlerTests . TestRestController . class )  . returning ( Mono . class ,    String . class )  . resolveMethod (  )  ;", "testSupports ( controller ,    method )  ;", "method    =    ResolvableMethod . on ( ResponseBodyResultHandlerTests . TestRestController . class )  . returning ( Single . class ,    String . class )  . resolveMethod (  )  ;", "testSupports ( controller ,    method )  ;", "method    =    ResolvableMethod . on ( ResponseBodyResultHandlerTests . TestRestController . class )  . returning ( Completable . class )  . resolveMethod (  )  ;", "testSupports ( controller ,    method )  ;", "}", "METHOD_END"], "methodName": ["supportsRestController"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseBodyResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HandlerResult   handlerResult    =    getHandlerResult ( controller ,    method )  ;", "assertTrue ( this . r . supports ( handlerResult )  )  ;", "}", "METHOD_END"], "methodName": ["testSupports"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseBodyResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return    ( clazz    !  =    null )     &  &     (  (  ( HttpEntity . class . isAssignableFrom ( clazz )  )     &  &     (  !  ( RequestEntity . class . isAssignableFrom ( clazz )  )  )  )     |  |     ( HttpHeaders . class . isAssignableFrom ( clazz )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSupportedType"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandler"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    valueType    =    result . getReturnType (  )  . getRawClass (  )  ;", "Object   value    =    result . getReturnValue (  )  ;", "if    (  (  ( valueType    =  =    null )     |  |     ( valueType . equals ( Object . class )  )  )     &  &     ( value    !  =    null )  )     {", "valueType    =    value . getClass (  )  ;", "}", "return   valueType ;", "}", "METHOD_END"], "methodName": ["resolveReturnValueType"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandler"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( status ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "if    ( body    !  =    null )     {", "assertResponseBody ( exchange ,    body )  ;", "} else    {", "assertResponseBodyIsEmpty ( exchange )  ;", "}", "if    ( etag    !  =    null )     {", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get ( ETAG )  . size (  )  )  ;", "assertEquals ( etag ,    exchange . getResponse (  )  . getHeaders (  )  . getETag (  )  )  ;", "}", "if    ( lastModified . isAfter ( Instant . EPOCH )  )     {", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . get ( LAST _ MODIFIED )  . size (  )  )  ;", "assertEquals ( lastModified . toEpochMilli (  )  ,    exchange . getResponse (  )  . getHeaders (  )  . getLastModified (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertConditionalResponse"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( exchange . getResponse (  )  . getBody (  )  )  . consumeNextWith (  (    buf )     -  >    assertEquals ( responseBody ,    DataBufferTestUtils . dumpString ( buf ,    StandardCharsets . UTF _  8  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["assertResponseBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( exchange . getResponse (  )  . getBody (  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["assertResponseBodyIsEmpty"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List < HttpMessageWriter <  ?  >  >    writerList ;", "if    ( ObjectUtils . isEmpty ( writers )  )     {", "writerList    =    new   ArrayList (  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   ByteBufferEncoder (  )  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( CharSequenceEncoder . textPlainOnly (  )  )  )  ;", "writerList . add ( new   ResourceHttpMessageWriter (  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   Jaxb 2 XmlEncoder (  )  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( new   Jackson 2 JsonEncoder (  )  )  )  ;", "writerList . add ( new   EncoderHttpMessageWriter ( CharSequenceEncoder . allMimeTypes (  )  )  )  ;", "} else    {", "writerList    =    Arrays . asList ( writers )  ;", "}", "RequestedContentTypeResolver   resolver    =    new   RequestedContentTypeResolverBuilder (  )  . build (  )  ;", "return   new    ( writerList ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["createHandler"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . resultHandler . getOrder (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultOrder"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    null ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( String . class )  ;", "assertFalse ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Completable . class )  ;", "assertFalse ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Flux . class )  ;", "assertFalse ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotSupport"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forClassWithGenerics ( ResponseEntity . class ,    bodyType )  ;", "}", "METHOD_END"], "methodName": ["entity"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  )  ;", "exchange . getAttributes (  )  . put ( HandlerMapping . PRODUCIBLE _ MEDIA _ TYPES _ ATTRIBUTE ,    Collections . singleton ( MediaType . APPLICATION _ JSON )  )  ;", "MethodParameter   type    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Mono . class ,    ResponseEntity . class )  ;", "HandlerResult   result    =    new   HandlerResult ( new    . TestController (  )  ,    Mono . just ( ResponseEntity . ok (  )  . body (  \" body \"  )  )  ,    type )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( OK ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertResponseBody ( exchange ,     \" body \"  )  ;", "}", "METHOD_END"], "methodName": ["handleMonoWithWildcardBodyType"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  )  ;", "exchange . getAttributes (  )  . put ( HandlerMapping . PRODUCIBLE _ MEDIA _ TYPES _ ATTRIBUTE ,    Collections . singleton ( MediaType . APPLICATION _ JSON )  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Mono . class ,    ResponseEntity . class )  ;", "HandlerResult   result    =    new   HandlerResult ( new    . TestController (  )  ,    Mono . just ( ResponseEntity . notFound (  )  . build (  )  )  ,    returnType )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( NOT _ FOUND ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertResponseBodyIsEmpty ( exchange )  ;", "}", "METHOD_END"], "methodName": ["handleMonoWithWildcardBodyTypeAndNullBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   returnValue    =    Mono . just ( ResponseEntity . notFound (  )  . build (  )  )  ;", "MethodParameter   type    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Mono . class ,    entity ( String . class )  )  ;", "HandlerResult   result    =    handlerResult ( returnValue ,    type )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( NOT _ FOUND ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertResponseBodyIsEmpty ( exchange )  ;", "}", "METHOD_END"], "methodName": ["handleResponseEntityWithNullBody"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   returnValue    =    ResponseEntity . ok (  \" abc \"  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( String . class )  )  ;", "testHandle ( returnValue ,    returnType )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Object . class )  ;", "testHandle ( returnValue ,    returnType )  ;", "returnValue    =    Mono . just ( ResponseEntity . ok (  \" abc \"  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Mono . class ,    entity ( String . class )  )  ;", "testHandle ( returnValue ,    returnType )  ;", "returnValue    =    Mono . just ( ResponseEntity . ok (  \" abc \"  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Single . class ,    entity ( String . class )  )  ;", "testHandle ( returnValue ,    returnType )  ;", "returnValue    =    Mono . just ( ResponseEntity . ok (  \" abc \"  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( CompletableFuture . class ,    entity ( String . class )  )  ;", "testHandle ( returnValue ,    returnType )  ;", "}", "METHOD_END"], "methodName": ["handleReturnTypes"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   etag    =     \"  \\  \" deadb 3  3 f 8 badf 0  0 d \\  \"  \"  ;", "String   newEtag    =     \"  \\  \" changed - etag - value \\  \"  \"  ;", "Instant   currentTime    =    Instant . now (  )  . truncatedTo ( ChronoUnit . SECONDS )  ;", "Instant   oneMinAgo    =    currentTime . minusSeconds (  6  0  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  . ifNoneMatch ( etag )  . ifModifiedSince ( currentTime . toEpochMilli (  )  )  )  ;", "ResponseEntity < String >    entity    =    ResponseEntity . ok (  )  . eTag ( newEtag )  . lastModified ( oneMinAgo . toEpochMilli (  )  )  . body (  \" body \"  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( String . class )  )  ;", "HandlerResult   result    =    handlerResult ( entity ,    returnType )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertConditionalResponse ( exchange ,    OK ,     \" body \"  ,    newEtag ,    oneMinAgo )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValueChangedETagAndLastModified"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   eTag    =     \"  \\  \" deadb 3  3 f 8 badf 0  0 d \\  \"  \"  ;", "Instant   currentTime    =    Instant . now (  )  . truncatedTo ( ChronoUnit . SECONDS )  ;", "Instant   oneMinAgo    =    currentTime . minusSeconds (  6  0  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  . ifNoneMatch ( eTag )  . ifModifiedSince ( currentTime . toEpochMilli (  )  )  )  ;", "ResponseEntity < String >    entity    =    ResponseEntity . ok (  )  . eTag ( eTag )  . lastModified ( oneMinAgo . toEpochMilli (  )  )  . body (  \" body \"  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( String . class )  )  ;", "HandlerResult   result    =    handlerResult ( entity ,    returnType )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertConditionalResponse ( exchange ,    NOT _ MODIFIED ,    null ,    eTag ,    oneMinAgo )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValueETagAndLastModified"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   etagValue    =     \"  \\  \" deadb 3  3 f 8 badf 0  0 d \\  \"  \"  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  . ifNoneMatch ( etagValue )  )  ;", "ResponseEntity < String >    entity    =    ResponseEntity . ok (  )  . eTag ( etagValue )  . body (  \" body \"  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( String . class )  )  ;", "HandlerResult   result    =    handlerResult ( entity ,    returnType )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertConditionalResponse ( exchange ,    NOT _ MODIFIED ,    null ,    etagValue ,    Instant . MIN )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValueEtag"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  . ifNoneMatch (  \" unquoted \"  )  )  ;", "ResponseEntity < String >    entity    =    ResponseEntity . ok (  )  . eTag (  \"  \\  \" deadb 3  3 f 8 badf 0  0 d \\  \"  \"  )  . body (  \" body \"  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( String . class )  )  ;", "HandlerResult   result    =    handlerResult ( entity ,    returnType )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( OK ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertResponseBody ( exchange ,     \" body \"  )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValueEtagInvalidIfNoneMatch"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Instant   currentTime    =    Instant . now (  )  . truncatedTo ( ChronoUnit . SECONDS )  ;", "Instant   oneMinAgo    =    currentTime . minusSeconds (  6  0  )  ;", "long   timestamp    =    currentTime . toEpochMilli (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  . ifModifiedSince ( timestamp )  )  ;", "ResponseEntity < String >    entity    =    ResponseEntity . ok (  )  . lastModified ( oneMinAgo . toEpochMilli (  )  )  . body (  \" body \"  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( String . class )  )  ;", "HandlerResult   result    =    handlerResult ( entity ,    returnType )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertConditionalResponse ( exchange ,    NOT _ MODIFIED ,    null ,    null ,    oneMinAgo )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValueLastModified"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerResult ( new   ResponseEntityResultHandlerTests . TestController (  )  ,    returnValue ,    returnType )  ;", "}", "METHOD_END"], "methodName": ["handlerResult"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . setAllow ( new   LinkedHashSet ( Arrays . asList ( GET ,    POST ,    OPTIONS )  )  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( Void . class )  )  ;", "HandlerResult   result    =    handlerResult ( headers ,    returnType )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( OK ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . size (  )  )  ;", "assertEquals (  \" GET , POST , OPTIONS \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Allow \"  )  )  ;", "assertResponseBodyIsEmpty ( exchange )  ;", "}", "METHOD_END"], "methodName": ["httpHeaders"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "URI   location    =    new   URI (  \"  / path \"  )  ;", "ResponseEntity < Void >    value    =    ResponseEntity . created ( location )  . build (  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( Void . class )  )  ;", "HandlerResult   result    =    handlerResult ( value ,    returnType )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( CREATED ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  1  ,    exchange . getResponse (  )  . getHeaders (  )  . size (  )  )  ;", "assertEquals ( location ,    exchange . getResponse (  )  . getHeaders (  )  . getLocation (  )  )  ;", "assertResponseBodyIsEmpty ( exchange )  ;", "}", "METHOD_END"], "methodName": ["responseEntityHeaders"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ResponseEntity < Void >    value    =    ResponseEntity . noContent (  )  . build (  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( Void . class )  )  ;", "HandlerResult   result    =    handlerResult ( value ,    returnType )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  )  ;", "this . resultHandler . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( NO _ CONTENT ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  0  ,    exchange . getResponse (  )  . getHeaders (  )  . size (  )  )  ;", "assertResponseBodyIsEmpty ( exchange )  ;", "}", "METHOD_END"], "methodName": ["responseEntityStatusCode"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . resultHandler    =    createHandler (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    null ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( entity ( String . class )  )  ;", "assertTrue ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Mono . class ,    entity ( String . class )  )  ;", "assertTrue ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Single . class ,    entity ( String . class )  )  ;", "assertTrue ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( CompletableFuture . class ,    entity ( String . class )  )  ;", "assertTrue ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( HttpHeaders . class )  ;", "assertTrue ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "value    =    ResponseEntity . ok (  \" testing \"  )  ;", "returnType    =    ResolvableMethod . on (  . TestController . class )  . resolveReturnType ( Object . class )  ;", "assertTrue ( this . resultHandler . supports ( handlerResult ( value ,    returnType )  )  )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  )  ;", "HandlerResult   result    =    handlerResult ( returnValue ,    returnType )  ;", "this . r . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( OK ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  \" text / plain ; charset = UTF -  8  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" Content - Type \"  )  )  ;", "assertResponseBody ( exchange ,     \" abc \"  )  ;", "}", "METHOD_END"], "methodName": ["testHandle"], "fileName": "org.springframework.web.reactive.result.method.annotation.ResponseEntityResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TimeZone   timeZone    =    null ;", "if    ( localeContext   instanceof   TimeZoneAwareLocaleContext )     {", "timeZone    =     (  ( TimeZoneAwareLocaleContext )     ( localeContext )  )  . getTimeZone (  )  ;", "}", "return   timeZone ;", "}", "METHOD_END"], "methodName": ["getTimeZone"], "fileName": "org.springframework.web.reactive.result.method.annotation.ServerWebExchangeArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "testResolveArgument ( this . testMethod . arg ( ServerWebExchange . class )  ,    this . exchange )  ;", "testResolveArgument ( this . testMethod . arg ( ServerHttpRequest . class )  ,    this . exchange . getRequest (  )  )  ;", "testResolveArgument ( this . testMethod . arg ( ServerHttpResponse . class )  ,    this . exchange . getResponse (  )  )  ;", "testResolveArgument ( this . testMethod . arg ( HttpMethod . class )  ,    GET )  ;", "testResolveArgument ( this . testMethod . arg ( TimeZone . class )  ,    TimeZone . getDefault (  )  )  ;", "testResolveArgument ( this . testMethod . arg ( ZoneId . class )  ,    ZoneId . systemDefault (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.ServerWebExchangeArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    this . testMethod . arg ( UriComponentsBuilder . class )  ;", "Object   value    =    this . resolver . resolv ( param ,    new   BindingContext (  )  ,    this . exchange )  . block (  )  ;", "assertNotNull ( value )  ;", "assertEquals ( UriComponentsBuilder . class ,    value . getClass (  )  )  ;", "assertEquals (  \"  / path / next \"  ,     (  ( UriComponentsBuilder )     ( value )  )  . path (  \"  / next \"  )  . build (  )  . toUriString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveUriComponentsBuilder"], "fileName": "org.springframework.web.reactive.result.method.annotation.ServerWebExchangeArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( ServerWebExchange . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( ServerHttpRequest . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( ServerHttpResponse . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( HttpMethod . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( Locale . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( TimeZone . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( ZoneId . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( UriComponentsBuilder . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( UriBuilder . class )  )  )  ;", "assertFalse ( this . resolver . supportsParameter ( this . testMethod . arg ( String . class )  )  )  ;", "try    {", "this . resolver . supportsParameter ( this . testMethod . arg ( Mono . class ,    ServerWebExchange . class )  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  \" Unexpected   error   message :  \\ n \"     +     ( ex . getMessage (  )  )  )  ,    ex . getMessage (  )  . startsWith (  \"    doesn ' t   support   reactive   type   wrapper \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.ServerWebExchangeArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Mono < Object >    mono    =    this . resolver . resolveArgument ( parameter ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertEquals ( expected ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolveArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.ServerWebExchangeArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    new   SynthesizingMethodParameter ( this . handleMethod ,    parameterIndex )  ;", "param . initParameterNameDiscovery ( new   DefaultParameterNameDiscoverer (  )  )  ;", "GenericType . resolveParameterType ( param ,    this . resolver . getClass (  )  )  ;", "return   param ;", "}", "METHOD_END"], "methodName": ["initMethodParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    initMethodParameter (  0  )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "StepVerifier . create ( mono )  . expectError ( ServerWebInputException . class )  . verify (  )  ;", ". Foo   foo    =    new    . Foo (  )  ;", "when ( this . session . getAttribute (  \" foo \"  )  )  . thenReturn ( foo )  ;", "mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertSame ( foo ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    initMethodParameter (  2  )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertNull ( mono . block (  )  )  ;", ". Foo   foo    =    new    . Foo (  )  ;", "when ( this . session . getAttribute (  \" foo \"  )  )  . thenReturn ( foo )  ;", "mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertSame ( foo ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveNotRequired"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    initMethodParameter (  3  )  ;", "Optional < Object >    actual    =     (  ( Optional < Object >  )     ( this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  . block (  )  )  )  ;", "assertNotNull ( actual )  ;", "assertFalse ( actual . isPresent (  )  )  ;", "ConfigurableWebBindingInitializer   initializer    =    new   ConfigurableWebBindingInitializer (  )  ;", "initializer . setConversionService ( new   DefaultFormattingConversionService (  )  )  ;", "BindingContext   bindingContext    =    new   BindingContext ( initializer )  ;", ". Foo   foo    =    new    . Foo (  )  ;", "when ( this . session . getAttribute (  \" foo \"  )  )  . thenReturn ( foo )  ;", "actual    =     (  ( Optional < Object >  )     ( this . resolver . resolveArgument ( param ,    bindingContext ,    this . exchange )  . block (  )  )  )  ;", "assertNotNull ( actual )  ;", "assertTrue ( actual . isPresent (  )  )  ;", "assertSame ( foo ,    actual . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveOptional"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   param    =    initMethodParameter (  1  )  ;", ". Foo   foo    =    new    . Foo (  )  ;", "when ( this . session . getAttribute (  \" specialFoo \"  )  )  . thenReturn ( foo )  ;", "Mono < Object >    mono    =    this . resolver . resolveArgument ( param ,    new   BindingContext (  )  ,    this . exchange )  ;", "assertSame ( foo ,    mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithName"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . refresh (  )  ;", "ReactiveAdapterRegistry   adapterRegistry    =    ReactiveAdapterRegistry . getSharedInstance (  )  ;", "this . resolver    =    new    ( context . getBeanFactory (  )  ,    adapterRegistry )  ;", "this . session    =    mock ( WebSession . class )  ;", "WebSessionManager   sessionManager    =    new   MockWebSessionManager ( this . session )  ;", "ServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "this . exchange    =    new   DefaultServerWebExchange ( request ,    new   MockServerHttpResponse (  )  ,    sessionManager ,    ServerCodecConfigurer . create (  )  ,    new   AcceptHeaderLocaleContextResolver (  )  )  ;", "this . handleMethod    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" handleWithSessionAttribute \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( new   MethodParameter ( this . handleMethod ,     0  )  )  )  ;", "assertFalse ( this . resolver . supportsParameter ( new   MethodParameter ( this . handleMethod ,     4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributeMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . knownAttributeNames . forEach (  (    name )     -  >    session . getAttributes (  )  . remove ( name )  )  ;", "}", "METHOD_END"], "methodName": ["cleanupAttributes"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( this . attributeNames . isEmpty (  )  )  )     |  |     (  !  ( this . attributeTypes . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasSessionAttributes"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeName ,     \" Attribute   name   must   not   be   null \"  )  ;", "if    (  ( this . attributeNames . contains ( attributeName )  )     |  |     ( this . attributeTypes . contains ( attributeType )  )  )     {", "this . knowNames . add ( attributeName )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isHandlerSessionAttribute"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "this . knowNames . forEach (  (    name )     -  >     {", "Object   value    =    session . getAttribute ( name )  ;", "if    ( value    !  =    null )     {", "attributes . put ( name ,    value )  ;", "}", "}  )  ;", "return   attributes ;", "}", "METHOD_END"], "methodName": ["retrieveAttributes"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "attributes . keySet (  )  . forEach (  (    name )     -  >     {", "Object   value    =    attributes . get ( name )  ;", "if    (  ( value    !  =    null )     &  &     ( isHandler ( name ,    value . getClass (  )  )  )  )     {", "session . getAttributes (  )  . put ( name ,    value )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["storeAttributes"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandler"}, {"methodBody": ["METHOD_START", "{", "WebSession   session    =    new   InMemoryWebSessionStore (  )  . createWebSession (  )  . block ( Duration . ZERO )  ;", "assertNotNull ( session )  ;", "session . getAttributes (  )  . put (  \" attr 1  \"  ,     \" value 1  \"  )  ;", "session . getAttributes (  )  . put (  \" attr 2  \"  ,     \" value 2  \"  )  ;", "session . getAttributes (  )  . put (  \" attr 3  \"  ,    new   TestBean (  )  )  ;", "this . s . cleanupAttributes ( session )  ;", "assertNull ( session . getAttributes (  )  . get (  \" attr 1  \"  )  )  ;", "assertNull ( session . getAttributes (  )  . get (  \" attr 2  \"  )  )  ;", "assertNotNull ( session . getAttributes (  )  . get (  \" attr 3  \"  )  )  ;", "this . s . isHandlerSessionAttribute (  \" attr 3  \"  ,    TestBean . class )  ;", "this . s . cleanupAttributes ( session )  ;", "assertNull ( session . getAttributes (  )  . get (  \" attr 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cleanupAttributes"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . sessionAttributesHandler . isHandlerSessionAttribute (  \" attr 1  \"  ,    String . class )  )  ;", "assertTrue ( this . sessionAttributesHandler . isHandlerSessionAttribute (  \" attr 2  \"  ,    String . class )  )  ;", "assertTrue ( this . sessionAttributesHandler . isHandlerSessionAttribute (  \" simple \"  ,    TestBean . class )  )  ;", "assertFalse ( this . sessionAttributesHandler . isHandlerSessionAttribute (  \" simple \"  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["isSessionAttribute"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandlerTests"}, {"methodBody": ["METHOD_START", "{", "WebSession   session    =    new   InMemoryWebSessionStore (  )  . createWebSession (  )  . block ( Duration . ZERO )  ;", "assertNotNull ( session )  ;", "session . getAttributes (  )  . put (  \" attr 1  \"  ,     \" value 1  \"  )  ;", "session . getAttributes (  )  . put (  \" attr 2  \"  ,     \" value 2  \"  )  ;", "session . getAttributes (  )  . put (  \" attr 3  \"  ,    new   TestBean (  )  )  ;", "session . getAttributes (  )  . put (  \" attr 4  \"  ,    new   TestBean (  )  )  ;", "assertEquals (  \" Named   attributes    ( attr 1  ,    attr 2  )    should   be    ' known '    right   away \"  ,    new   HashSet ( Arrays . asList (  \" attr 1  \"  ,     \" attr 2  \"  )  )  ,    s . retrieveAttributes ( session )  . keySet (  )  )  ;", "s . isHandlerSessionAttribute (  \" attr 3  \"  ,    TestBean . class )  ;", "assertEquals (  \" Named   attributes    ( attr 1  ,    attr 2  )    and   resolved   attribute    ( att 3  )    should   be    ' known '  \"  ,    new   HashSet ( Arrays . asList (  \" attr 1  \"  ,     \" attr 2  \"  ,     \" attr 3  \"  )  )  ,    s . retrieveAttributes ( session )  . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["retrieveAttributes"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandlerTests"}, {"methodBody": ["METHOD_START", "{", "WebSession   session    =    new   InMemoryWebSessionStore (  )  . createWebSession (  )  . block ( Duration . ZERO )  ;", "assertNotNull ( session )  ;", "ModelMap   model    =    new   ModelMap (  )  ;", "model . put (  \" attr 1  \"  ,     \" value 1  \"  )  ;", "model . put (  \" attr 2  \"  ,     \" value 2  \"  )  ;", "model . put (  \" attr 3  \"  ,    new   TestBean (  )  )  ;", "s . storeAttributes ( session ,    model )  ;", "assertEquals (  \" value 1  \"  ,    session . getAttributes (  )  . get (  \" attr 1  \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    session . getAttributes (  )  . get (  \" attr 2  \"  )  )  ;", "assertTrue (  (  ( session . getAttributes (  )  . get (  \" attr 3  \"  )  )    instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["storeAttributes"], "fileName": "org.springframework.web.reactive.result.method.annotation.SessionAttributesHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  ( this . server )    instanceof   ReactorHttpServer )  )  ;", "Flux < String >    result    =    this . webClient . get (  )  . uri (  \"  / infinite \"  )  . accept ( TEXT _ EVENT _ STREAM )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . bodyToFlux (  . class )  )  ;", "StepVerifier . create ( result )  . expectNext (  \" foo    0  \"  )  . expectNext (  \" foo    1  \"  )  . thenCancel (  )  . verify ( Duration . ofSeconds (  5 L )  )  ;", ". SseController   controller    =    this . wac . getBean (  . SseController . class )  ;", "controller . cancellation . block ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["serverDetectsClientDisconnect"], "fileName": "org.springframework.web.reactive.result.method.annotation.SseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < ServerSentEvent < String >  >    result    =    this . webClient . get (  )  . uri (  \"  / event \"  )  . accept ( TEXT _ EVENT _ STREAM )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . body ( toFlux ( new   ParameterizedTypeReference < ServerSentEvent < String >  >  (  )     {  }  )  )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \"  0  \"  ,    event . id (  )  )  ;", "assertEquals (  \" foo \"  ,    event . data (  )  )  ;", "assertEquals (  \" bar \"  ,    event . comment (  )  )  ;", "assertNull ( event . event (  )  )  ;", "assertNull ( event . retry (  )  )  ;", "}  )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \"  1  \"  ,    event . id (  )  )  ;", "assertEquals (  \" foo \"  ,    event . data (  )  )  ;", "assertEquals (  \" bar \"  ,    event . comment (  )  )  ;", "assertNull ( event . event (  )  )  ;", "assertNull ( event . retry (  )  )  ;", "}  )  . thenCancel (  )  . verify ( Duration . ofSeconds (  5 L )  )  ;", "}", "METHOD_END"], "methodName": ["sseAsEvent"], "fileName": "org.springframework.web.reactive.result.method.annotation.SseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < ServerSentEvent < String >  >    result    =    this . webClient . get (  )  . uri (  \"  / event \"  )  . accept ( TEXT _ EVENT _ STREAM )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . body ( toFlux ( new   ParameterizedTypeReference < ServerSentEvent < String >  >  (  )     {  }  )  )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \"  0  \"  ,    event . id (  )  )  ;", "assertEquals (  \" foo \"  ,    event . data (  )  )  ;", "assertEquals (  \" bar \"  ,    event . comment (  )  )  ;", "assertNull ( event . event (  )  )  ;", "assertNull ( event . retry (  )  )  ;", "}  )  . consumeNextWith (  (    event )     -  >     {", "assertEquals (  \"  1  \"  ,    event . id (  )  )  ;", "assertEquals (  \" foo \"  ,    event . data (  )  )  ;", "assertEquals (  \" bar \"  ,    event . comment (  )  )  ;", "assertNull ( event . event (  )  )  ;", "assertNull ( event . retry (  )  )  ;", "}  )  . thenCancel (  )  . verify ( Duration . ofSeconds (  5 L )  )  ;", "}", "METHOD_END"], "methodName": ["sseAsEventWithoutAcceptHeader"], "fileName": "org.springframework.web.reactive.result.method.annotation.SseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < SseIntegrationTests . Person >    result    =    this . webClient . get (  )  . uri (  \"  / person \"  )  . accept ( TEXT _ EVENT _ STREAM )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . bodyToFlux (  . class )  )  ;", "StepVerifier . create ( result )  . expectNext ( new   SseIntegrationTests . Person (  \" foo    0  \"  )  )  . expectNext ( new   SseIntegrationTests . Person (  \" foo    1  \"  )  )  . thenCancel (  )  . verify ( Duration . ofSeconds (  5 L )  )  ;", "}", "METHOD_END"], "methodName": ["sseAsPerson"], "fileName": "org.springframework.web.reactive.result.method.annotation.SseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    result    =    this . webClient . get (  )  . uri (  \"  / string \"  )  . accept ( TEXT _ EVENT _ STREAM )  . exchange (  )  . flatMapMany (  (    response )     -  >    response . bodyToFlux (  . class )  )  ;", "StepVerifier . create ( result )  . expectNext (  \" foo    0  \"  )  . expectNext (  \" foo    1  \"  )  . thenCancel (  )  . verify ( Duration . ofSeconds (  5 L )  )  ;", "}", "METHOD_END"], "methodName": ["sseAsString"], "fileName": "org.springframework.web.reactive.result.method.annotation.SseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "BindingContext   context    =    new   BindingContext (  )  ;", "WebSession   session    =    mock ( WebSession . class )  ;", "WebSessionManager   manager    =     (    exchange )     -  >    Mono . just ( session )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . build (  )  ;", "ServerWebExchange   exchange    =    new   server . adapter . DefaultServerWebExchange ( request ,    new   MockServerHttpResponse (  )  ,    manager ,    ServerCodecConfigurer . create (  )  ,    new   AcceptHeaderLocaleContextResolver (  )  )  ;", "MethodParameter   param    =    this . testMethod . arg ( WebSession . class )  ;", "Object   actual    =    this . resolver . resolveArgument ( param ,    context ,    exchange )  . block (  )  ;", "assertSame ( session ,    actual )  ;", "param    =    this . testMethod . arg ( Mono . class ,    WebSession . class )  ;", "actual    =    this . resolver . resolveArgument ( param ,    context ,    exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertTrue ( Mono . class . isAssignableFrom ( actual . getClass (  )  )  )  ;", "assertSame ( session ,     (  ( Mono <  ?  >  )     ( actual )  )  . block (  )  )  ;", "param    =    this . testMethod . arg ( Single . class ,    WebSession . class )  ;", "actual    =    this . resolver . resolveArgument ( param ,    context ,    exchange )  . block (  )  ;", "assertNotNull ( actual )  ;", "assertTrue ( Single . class . isAssignableFrom ( actual . getClass (  )  )  )  ;", "assertSame ( session ,     (  ( Single <  ?  >  )     ( actual )  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolverArgument"], "fileName": "org.springframework.web.reactive.result.method.annotation.WebSessionArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( WebSession . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( Mono . class ,    WebSession . class )  )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . testMethod . arg ( Single . class ,    WebSession . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.web.reactive.result.method.annotation.WebSessionArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.springframework.web.reactive.result.view.AbstractUrlBasedView"}, {"methodBody": ["METHOD_START", "{", "this . url    =    url ;", "}", "METHOD_END"], "methodName": ["setUrl"], "fileName": "org.springframework.web.reactive.result.view.AbstractUrlBasedView"}, {"methodBody": ["METHOD_START", "{", "return   new   RequestContext ( exchange ,    model ,    obtainApplicationContext (  )  ,    getRequestDataValueProcessor (  )  )  ;", "}", "METHOD_END"], "methodName": ["createRequestContext"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultCharset ;", "}", "METHOD_END"], "methodName": ["getDefaultCharset"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "int   size    =     ( model    !  =    null )     ?    model . size (  )     :     0  ;", "Map < St ,    Object >    attributes    =    new   LinkedHashMap <  >  ( size )  ;", "if    ( model    !  =    null )     {", "attributes . putAll ( model )  ;", "}", "return   resolveAsyncAttributes ( attributes )  . then ( Mono . just ( attributes )  )  ;", "}", "METHOD_END"], "methodName": ["getModelAttributes"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "return   this . requestContextAttribute ;", "}", "METHOD_END"], "methodName": ["getRequestContextAttribute"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    getApplicationContext (  )  ;", "if    (  ( context    !  =    null )     &  &     ( context . containsBean (  . REQUEST _ DATA _ VALUE _ PROCESSOR _ BEAN _ NAME )  )  )     {", "return   context . getBean (  . REQUEST _ DATA _ VALUE _ PROCESSOR _ BEAN _ NAME ,    RequestDataValueProcessor . class )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getRequestDataValueProcessor"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    getApplicationContext (  )  ;", "Assert . state (  ( applicationContext    !  =    null )  ,     \" No   ApplicationContext \"  )  ;", "return   applicationContext ;", "}", "METHOD_END"], "methodName": ["obtainApplicationContext"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    new   ArrayList <  >  (  )  ;", "List < Mono <  ?  >  >    valueMonos    =    new   ArrayList <  >  (  )  ;", "for    ( Map . Entry < String ,     ?  >    entry    :    model . entrySet (  )  )     {", "Object   value    =    entry . getValue (  )  ;", "if    ( value    =  =    null )     {", "continue ;", "}", "ReactiveAdapter   adapter    =    this . adapterRegistry . getAdapter ( null ,    value )  ;", "if    ( adapter    !  =    null )     {", "names . add ( entry . getKey (  )  )  ;", "if    ( adapter . isMultiValue (  )  )     {", "Flux < Object >    fluxValue    =    Flux . from ( adapter . toPublisher ( value )  )  ;", "valueMonos . add ( fluxValue . collectList (  )  . defaultIfEmpty ( Collections . emptyList (  )  )  )  ;", "} else    {", "Mono < Object >    monoValue    =    Mono . from ( adapter . toPublisher ( value )  )  ;", "valueMonos . add ( monoValue . defaultIfEmpty (  . NO _ VALUE )  )  ;", "}", "}", "}", "if    ( names . isEmpty (  )  )     {", "return   Mono . empty (  )  ;", "}", "return   Mono . zip ( valueMonos ,     (    values )     -  >     {", "for    ( int   i    =     0  ;    i    <    values . length ;    i +  +  )     {", "if    (  ( values [ i ]  )     !  =     (  . NO _ VALUE )  )     {", "model . put ( names . get ( i )  ,    values [ i ]  )  ;", "} else    {", "model . remove ( names . get ( i )  )  ;", "}", "}", "return    . NO _ VALUE ;", "}  )  . then (  )  ;", "}", "METHOD_END"], "methodName": ["resolveAsyncAttributes"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( defaultCharset ,     \"  ' defaultCharset '    must   not   be   null \"  )  ;", "this . defaultCharset    =    defaultCharset ;", "}", "METHOD_END"], "methodName": ["setDefaultCharset"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "this . requestContextAttribute    =    requestContextAttribute ;", "}", "METHOD_END"], "methodName": ["setRequestContextAttribute"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( supportedMediaTypes ,     \" MediaType   List   must   not   be   empty \"  )  ;", "this . mediaTypes . clear (  )  ;", "this . mediaTypes . addAll ( supportedMediaTypes )  ;", "}", "METHOD_END"], "methodName": ["setSupportedMediaTypes"], "fileName": "org.springframework.web.reactive.result.view.AbstractView"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean 1     =    new   TestBean (  \" Bean 1  \"  )  ;", "TestBean   testBean 2     =    new   TestBean (  \" Bean 2  \"  )  ;", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "attributes . put (  \" attr 1  \"  ,    Mono . just ( testBean 1  )  )  ;", "attributes . put (  \" attr 2  \"  ,    Flux . just ( testBean 1  ,    testBean 2  )  )  ;", "attributes . put (  \" attr 3  \"  ,    Single . just ( testBean 2  )  )  ;", "attributes . put (  \" attr 4  \"  ,    Observable . just ( testBean 1  ,    testBean 2  )  )  ;", "attributes . put (  \" attr 5  \"  ,    Mono . empty (  )  )  ;", ". TestView   view    =    new    . TestView (  )  ;", "StepVerifier . create ( view . render ( attributes ,    null ,    this . exchange )  )  . verifyComplete (  )  ;", "Map < String ,    Object >    actual    =    view . attributes ;", "assertEquals ( testBean 1  ,    actual . get (  \" attr 1  \"  )  )  ;", "assertArrayEquals ( new   TestBean [  ]  {    testBean 1  ,    testBean 2     }  ,     (  ( List < TestBean >  )     ( actual . get (  \" attr 2  \"  )  )  )  . toArray (  )  )  ;", "assertEquals ( testBean 2  ,    actual . get (  \" attr 3  \"  )  )  ;", "assertArrayEquals ( new   TestBean [  ]  {    testBean 1  ,    testBean 2     }  ,     (  ( List < TestBean >  )     ( actual . get (  \" attr 4  \"  )  )  )  . toArray (  )  )  ;", "assertNull ( actual . get (  \" attr 5  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveAsyncAttributes"], "fileName": "org.springframework.web.reactive.result.view.AbstractViewTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this . bindingResult )     !  =    null    ?    this . bindingResult . findEditor ( this . expression ,    valueClass )     :    null ;", "}", "METHOD_END"], "methodName": ["findEditor"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . actualValue ;", "}", "METHOD_END"], "methodName": ["getActualValue"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . value )    instanceof   String )     {", "return    (  ( String )     ( this . value )  )  ;", "}", "if    (  ( this . value )     !  =    null )     {", "return   this . htmlEscape    ?    HtmlUtils . htmlEscape ( this . value . toString (  )  )     :    this . value . toString (  )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayValue"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . editor ;", "}", "METHOD_END"], "methodName": ["getEditor"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return    !  ( ObjectUtils . isEmpty ( this . errorCodes )  )     ?    this . errorCodes [  0  ]     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getErrorCode"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . errorCodes ;", "}", "METHOD_END"], "methodName": ["getErrorCodes"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "String [  ]    errorMessages    =    initErrorMessages (  )  ;", "return    ( errorMessages . length )     >     0     ?    errorMessages [  0  ]     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getErrorMessage"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   initErrorMessages (  )  ;", "}", "METHOD_END"], "methodName": ["getErrorMessages"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . arrayToDelimitedString ( initErrorMessages (  )  ,    delimiter )  ;", "}", "METHOD_END"], "methodName": ["getErrorMessagesAsString"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . errors ;", "}", "METHOD_END"], "methodName": ["getErrors"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . expression ;", "}", "METHOD_END"], "methodName": ["getExpression"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . valueType ;", "}", "METHOD_END"], "methodName": ["getValueType"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "String [  ]    errorCodes    =    new   String [ objectErrors . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( objectErrors . size (  )  )  ;    i +  +  )     {", "ObjectError   error    =    objectErrors . get ( i )  ;", "errorCodes [ i ]     =    error . getCode (  )  ;", "}", "return   errorCodes ;", "}", "METHOD_END"], "methodName": ["initErrorCodes"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . errorMessages )     =  =    null )     {", "if    (  ( this . objectErrors )     !  =    null )     {", "this . errorMessages    =    new   St [ this . objectErrors . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( this . objectErrors . size (  )  )  ;    i +  +  )     {", "ObjectError   error    =    this . objectErrors . get ( i )  ;", "this . errorMessages [ i ]     =    this . requestContext . getMessage ( error ,    this . htmlEscape )  ;", "}", "} else    {", "this . errorMessages    =    new   St [  0  ]  ;", "}", "}", "return   this . errorMessages ;", "}", "METHOD_END"], "methodName": ["initErrorMessages"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "return    ( this . errorCodes . length )     >     0  ;", "}", "METHOD_END"], "methodName": ["isError"], "fileName": "org.springframework.web.reactive.result.view.BindStatus"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( RedirectView . class ,    this . view )  ;", "return    (  ( RedirectView )     ( this . view )  )  ;", "}", "METHOD_END"], "methodName": ["getRedirectView"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . headers )     =  =    null )     {", "this . headers    =    new   HttpHeaders (  )  ;", "}", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . model )     =  =    null )     {", "this . model    =    new   ExtdModelMap (  )  ;", "}", "return   this . model ;", "}", "METHOD_END"], "methodName": ["initModel"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilder"}, {"methodBody": ["METHOD_START", "{", "Rendering   rendering    =    Rendering . view (  \" abc \"  )  . build (  )  ;", "assertEquals (  \" abc \"  ,    rendering . view (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    rendering . modelAttributes (  )  )  ;", "assertNull ( rendering . status (  )  )  ;", "assertEquals (  0  ,    rendering . headers (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultValues"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Rendering   rendering    =    Rendering . redirectTo (  \" abc \"  )  . build (  )  ;", "Object   view    =    rendering . view (  )  ;", "assertEquals ( RedirectView . class ,    view . getClass (  )  )  ;", "assertEquals (  \" abc \"  ,     (  ( RedirectView )     ( view )  )  . getUrl (  )  )  ;", "assertTrue (  (  ( RedirectView )     ( view )  )  . isContextRelative (  )  )  ;", "assertFalse (  (  ( RedirectView )     ( view )  )  . isPropagateQuery (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultValuesForRedirect"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Rendering   rendering    =    Rendering . view (  \" foo \"  )  . header (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "assertEquals (  1  ,    rendering . headers (  )  . size (  )  )  ;", "assertEquals ( Collections . singletonList (  \" bar \"  )  ,    rendering . headers (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["header"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . add (  \" foo \"  ,     \" bar \"  )  ;", "rendering    =     . view (  \" foo \"  )  . headers ( headers )  . build (  )  ;", "assertEquals ( headers ,    rendering . headers (  )  )  ;", "}", "METHOD_END"], "methodName": ["httpHeaders"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   LinkedHashMap <  >  (  )  ;", "map . put (  \" foo \"  ,    new    . Foo (  )  )  ;", "map . put (  \" bar \"  ,    new    . Bar (  )  )  ;", "Rendering   rendering    =    Rendering . view (  \" foo \"  )  . model ( map )  . build (  )  ;", "assertEquals ( map ,    rendering . modelAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["model"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "DefaultRenderingBuilderTests . Foo   foo    =    new   DefaultRenderingBuilderTests . Foo (  )  ;", "Rendering   rendering    =    Rendering . view (  \" foo \"  )  . modelAttribute ( foo )  . build (  )  ;", "assertEquals ( Collections . singletonMap (  \" foo \"  ,    foo )  ,    rendering . modelAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttribute"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "DefaultRenderingBuilderTests . Foo   foo    =    new   DefaultRenderingBuilderTests . Foo (  )  ;", "DefaultRenderingBuilderTests . Bar   bar    =    new   DefaultRenderingBuilderTests . Bar (  )  ;", "Rendering   rendering    =    Rendering . view (  \" foo \"  )  . modelAttributes ( foo ,    bar )  . build (  )  ;", "Map < String ,    Object >    map    =    new   LinkedHashMap <  >  (  2  )  ;", "map . put (  \" foo \"  ,    foo )  ;", "map . put (  \" bar \"  ,    bar )  ;", "assertEquals ( map ,    rendering . modelAttributes (  )  )  ;", "}", "METHOD_END"], "methodName": ["modelAttributes"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Rendering   rendering    =    Rendering . redirectTo (  \" foo \"  )  . contextRelative ( false )  . build (  )  ;", "Object   view    =    rendering . view (  )  ;", "assertEquals ( RedirectView . class ,    view . getClass (  )  )  ;", "assertFalse (  (  ( RedirectView )     ( view )  )  . isContextRelative (  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectWithAbsoluteUrl"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Rendering   rendering    =    Rendering . redirectTo (  \" foo \"  )  . propagateQuery ( true )  . build (  )  ;", "Object   view    =    rendering . view (  )  ;", "assertEquals ( RedirectView . class ,    view . getClass (  )  )  ;", "assertTrue (  (  ( RedirectView )     ( view )  )  . isPropagateQuery (  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectWithPropagateQuery"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Rendering   rendering    =    Rendering . view (  \" foo \"  )  . build (  )  ;", "assertEquals (  \" foo \"  ,    rendering . view (  )  )  ;", "}", "METHOD_END"], "methodName": ["viewName"], "fileName": "org.springframework.web.reactive.result.view.DefaultRenderingBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   this . writer ;", "}", "METHOD_END"], "methodName": ["getMessageWriter"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterView"}, {"methodBody": ["METHOD_START", "{", "return   this . modelKeys ;", "}", "METHOD_END"], "methodName": ["getModelKeys"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterView"}, {"methodBody": ["METHOD_START", "{", "if    ( model    =  =    null )     {", "return   null ;", "}", "Map < String ,     ?  >    result    =    model . entrySet (  )  . stream (  )  . filter ( this :  : isMatch )  . collect ( Collectors . toMap ( Map . Entry :  : getKey ,    Map . Entry :  : getValue )  )  ;", "if    ( result . isEmpty (  )  )     {", "return   null ;", "} else", "if    (  ( result . size (  )  )     =  =     1  )     {", "return   result . values (  )  . iterator (  )  . next (  )  ;", "} else", "if    ( this . canWriteMap )     {", "return   result ;", "} else    {", "throw   new   IllegalStateException (  (  (  (  (  \" Multiple   matches   found :     \"     +    result )     +     \"    but    \"  )     +     \" Map   rendering   is   not   supported   by    \"  )     +     ( get (  )  . getClass (  )  . getName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getObjectToRender"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterView"}, {"methodBody": ["METHOD_START", "{", "if    (  ( entry . getValue (  )  )     =  =    null )     {", "return   false ;", "}", "if    (  (  !  ( getModelKeys (  )  . isEmpty (  )  )  )     &  &     (  !  ( getModelKeys (  )  . contains ( entry . getKey (  )  )  )  )  )     {", "return   false ;", "}", "ResolvableType   type    =    ResolvableType . forInstance ( entry . getValue (  )  )  ;", "return   get (  )  . canWrite ( type ,    null )  ;", "}", "METHOD_END"], "methodName": ["isMatch"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterView"}, {"methodBody": ["METHOD_START", "{", "this . modelKeys . clear (  )  ;", "if    ( modelKeys    !  =    null )     {", "this . modelKeys . addAll ( modelKeys )  ;", "}", "}", "METHOD_END"], "methodName": ["setModelKeys"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterView"}, {"methodBody": ["METHOD_START", "{", "Publisher < T >    input    =    Mono . justOrEmpty ( value )  ;", "ResolvableType   elementType    =    ResolvableType . forClass ( value . getClass (  )  )  ;", "return    (  (  < T >  )     ( this . writer )  )  . write ( input ,    elementType ,    contentType ,    exchange . getResponse (  )  ,    Collections . emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterView"}, {"methodBody": ["METHOD_START", "{", "this . view . render ( this . model ,    APPLICATION _ JSON ,    this . exchange )  . block ( Duration . ZERO )  ;", "return   this . exchange . getResponse (  )  . getBodyAsString (  )  . block ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["doRender"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "return   DataBufferTestUtils . dumpString ( buf ,    StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["dumpString"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view . setModelKeys ( new   HashSet <  >  ( Arrays . asList (  \" foo 1  \"  ,     \" foo 2  \"  )  )  )  ;", "this . model . addAttribute (  \" foo 1  \"  ,    Collections . singleton (  \" bar 1  \"  )  )  ;", "this . model . addAttribute (  \" foo 2  \"  ,    Collections . singleton (  \" bar 2  \"  )  )  ;", "this . model . addAttribute (  \" foo 3  \"  ,    Collections . singleton (  \" bar 3  \"  )  )  ;", "assertEquals (  \"  {  \\  \" foo 1  \\  \"  :  [  \\  \" bar 1  \\  \"  ]  ,  \\  \" foo 2  \\  \"  :  [  \\  \" bar 2  \\  \"  ]  }  \"  ,    doRender (  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleMatches"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view    =    new   HttpMessageWriterView ( CharSequenceEncoder . allMimeTypes (  )  )  ;", "this . view . setModelKeys ( new   HashSet <  >  ( Arrays . asList (  \" foo 1  \"  ,     \" foo 2  \"  )  )  )  ;", "this . model . addAttribute (  \" foo 1  \"  ,     \" bar 1  \"  )  ;", "this . model . addAttribute (  \" foo 2  \"  ,     \" bar 2  \"  )  ;", "try    {", "doRender (  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "String   message    =    ex . getMessage (  )  ;", "TestCase . assertTrue ( message ,    message . contains (  \" Map   rendering   is   not   supported \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["multipleMatchesNotSupported"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view . setModelKeys ( Collections . singleton (  \" foo 2  \"  )  )  ;", "this . model . addAttribute (  \" foo 1  \"  ,     \" bar 1  \"  )  ;", "assertEquals (  \"  \"  ,    doRender (  )  )  ;", "}", "METHOD_END"], "methodName": ["noMatch"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view    =    new   HttpMessageWriterView ( new   Jaxb 2 XmlEncoder (  )  )  ;", "this . view . setModelKeys ( new   HashSet <  >  ( Collections . singletonList (  \" foo 1  \"  )  )  )  ;", "this . model . addAttribute (  \" foo 1  \"  ,     \" bar 1  \"  )  ;", "assertEquals (  \"  \"  ,    doRender (  )  )  ;", "}", "METHOD_END"], "methodName": ["noMatchBecauseNotSupported"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    pojoData    =    new   LinkedHashMap <  >  (  )  ;", "pojoData . put (  \" foo \"  ,     \" f \"  )  ;", "pojoData . put (  \" bar \"  ,     \" b \"  )  ;", "this . model . addAttribute (  \" pojoData \"  ,    pojoData )  ;", "thissetModelKeys ( Collections . singleton (  \" pojoData \"  )  )  ;", "thisrender ( this . model ,    APPLICATION _ JSON ,    exchange )  . block ( Duration . ZERO )  ;", "StepVerifier . create ( this . exchange . getResponse (  )  . getBody (  )  )  . consumeNextWith (  (    buf )     -  >    assertEquals (  \"  {  \\  \" foo \\  \"  :  \\  \" f \\  \"  ,  \\  \" bar \\  \"  :  \\  \" b \\  \"  }  \"  ,    dumpString ( buf )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view . setModelKeys ( Collections . singleton (  \" foo 2  \"  )  )  ;", "this . model . addAttribute (  \" foo 1  \"  ,    Collections . singleton (  \" bar 1  \"  )  )  ;", "this . model . addAttribute (  \" foo 2  \"  ,    Collections . singleton (  \" bar 2  \"  )  )  ;", "this . model . addAttribute (  \" foo 3  \"  ,    Collections . singleton (  \" bar 3  \"  )  )  ;", "assertEquals (  \"  [  \\  \" bar 2  \\  \"  ]  \"  ,    doRender (  )  )  ;", "}", "METHOD_END"], "methodName": ["singleMatch"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Arrays . asList ( MediaType . parseMediaType (  \" application / json ; charset = UTF -  8  \"  )  ,    MediaType . parseMediaType (  \" application /  *  + json ; charset = UTF -  8  \"  )  )  ,    this . view . getSupportedMediaTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["supportedMediaTypes"], "fileName": "org.springframework.web.reactive.result.view.HttpMessageWriterViewTests"}, {"methodBody": ["METHOD_START", "{", "Mono < ClientResponse >    result    =    webClient . get (  )  . uri (  (  (  \" http :  /  / localhost :  \"     +     ( this . port )  )     +     \"  /  \"  )  )  . exchange (  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    response )     -  >     {", "assertEquals ( HttpStatus . OK ,    response . statusCode (  )  )  ;", "assertEquals ( Locale . GERMANY ,    response . headers (  )  . asHttpHeaders (  )  . getContentLanguage (  )  )  ;", "}  )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["fixedLocale"], "fileName": "org.springframework.web.reactive.result.view.LocaleContextResolverIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   query    =    request . getURI (  )  . getRawQuery (  )  ;", "if    (  !  ( StringUtils . hasText ( query )  )  )     {", "return   new   StringBuilder ( targetUrl )  ;", "}", "int   index    =    targetUrl . indexOf (  '  #  '  )  ;", "String   fragment    =     ( index    >     (  -  1  )  )     ?    targetUrl . substring ( index )     :    null ;", "StringBuilder    =    new   StringBuilder (  )  ;", "append (  ( index    !  =     (  -  1  )     ?    targetUrl . substring (  0  ,    index )     :    targetUrl )  )  ;", "append (  (  ( targetUrl . indexOf (  '  ?  '  )  )     <     0     ?     '  ?  '     :     '  &  '  )  )  . append ( query )  ;", "if    ( fragment    !  =    null )     {", "append ( fragment )  ;", "}", "return", "}", "METHOD_END"], "methodName": ["appendCurrentRequestQuery"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "String   url    =    getUrl (  )  ;", "Assert . state (  ( url    !  =    null )  ,     \"  ' url '    not   set \"  )  ;", "ServerHttpRequest   request    =    exchange . getRequest (  )  ;", "StringBuilder   targetUrl    =    new   StringBuilder (  )  ;", "if    (  ( isContextRelative (  )  )     &  &     ( url . startsWith (  \"  /  \"  )  )  )     {", "targetUrl . append ( request . getPath (  )  . contextPath (  )  . value (  )  )  ;", "}", "targetUrl . append ( url )  ;", "if    ( StringUtils . hasText ( targetUrl )  )     {", "Map < String ,    String >    uriVars    =    getCurrentUriVariables ( exchange )  ;", "targetUrl    =    expandTargetUrlTemplate ( targetUrl . toString (  )  ,    model ,    uriVars )  ;", "}", "if    ( isPropagateQuery (  )  )     {", "targetUrl    =    appendCurrentRequestQuery ( targetUrl . toString (  )  ,    request )  ;", "}", "String       =    targetUrl . toString (  )  ;", "RequestDataValueProcessor   processor    =    getRequestDataValueProcessor (  )  ;", "return   processor    !  =    null    ?    processor . processUrl ( exchange ,     )     :     ;", "}", "METHOD_END"], "methodName": ["createTargetUrl"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "return   UriUtils . encode ( text ,    StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["encodeUriVariable"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    RedirectView . URI _ TEMPLATE _ VARIABLE _ PATTERN . matcher ( targetUrl )  ;", "boolean   found    =    matcher . find (  )  ;", "if    (  ! found )     {", "return   new   StringBuilder ( targetUrl )  ;", "}", "StringBuilder   result    =    new   StringBuilder (  )  ;", "int   endLastMatch    =     0  ;", "while    ( found )     {", "String   name    =    matcher . group (  1  )  ;", "Object   value    =     ( model . containsKey ( name )  )     ?    model . get ( name )     :    uriVariables . get ( name )  ;", "Assert . notNull ( value ,     (  (  \" No   value   for   URI   variable    '  \"     +    name )     +     \"  '  \"  )  )  ;", "result . append ( targetUrl . substring ( endLastMatch ,    matcher . start (  )  )  )  ;", "result . append ( encodeUriVariable ( value . toString (  )  )  )  ;", "endLastMatch    =    matcher . end (  )  ;", "found    =    matcher . find (  )  ;", "}", "result . append ( targetUrl . substring ( endLastMatch ,    targetUrl . length (  )  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["expandTargetUrlTemplate"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "String   name    =    HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ;", "return   exchange . getAttributeOrDefault ( name ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentUriVariables"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "return   this . hosts ;", "}", "METHOD_END"], "methodName": ["getHosts"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "return   this . statusCode ;", "}", "METHOD_END"], "methodName": ["getStatusCode"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "return   this . contextRelative ;", "}", "METHOD_END"], "methodName": ["isContextRelative"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "return   this . propagateQuery ;", "}", "METHOD_END"], "methodName": ["isPropagateQuery"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( this . hosts )  )     {", "return   false ;", "}", "St   targetHost    =    UriComponentsBuilder . fromUriSt ( targetUrl )  . build (  )  . getHost (  )  ;", "if    ( StUtils . isEmpty ( targetHost )  )     {", "return   false ;", "}", "for    ( St   host    :    this . hosts )     {", "if    ( targetHost . equals ( host )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isRemoteHost"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "String   transformedUrl    =     ( isRemoteHost ( targetUrl )  )     ?    targetUrl    :    exchange . transformUrl ( targetUrl )  ;", "ServerHttpResponse   response    =    exchange . getResponse (  )  ;", "response . getHeaders (  )  . setLocation ( URI . create ( transformedUrl )  )  ;", "response . setStatusCode ( getStatusCode (  )  )  ;", "return   Mono . empty (  )  ;", "}", "METHOD_END"], "methodName": ["sendRedirect"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "this . contextRelative    =    contextRelative ;", "}", "METHOD_END"], "methodName": ["setContextRelative"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "this . hosts    =    hosts ;", "}", "METHOD_END"], "methodName": ["setHosts"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "this . propagateQuery    =    propagateQuery ;", "}", "METHOD_END"], "methodName": ["setPropagateQuery"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue ( statusCode . is 3 xxRedirection (  )  ,     \" Not   a   redirect   status   code \"  )  ;", "this . statusCode    =    statusCode ;", "}", "METHOD_END"], "methodName": ["setStatusCode"], "fileName": "org.springframework.web.reactive.result.view.RedirectView"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \"  / test . html \"  ;", "view    =    new    ( url )  ;", "view . render ( new   HashMap (  )  ,    TEXT _ HTML ,    this . exchange )  . block (  )  ;", "assertEquals ( URI . create (  \"  / context / test . html \"  )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextRelative"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \"  / test . html ? id =  1  \"  ;", "view    =    new    ( url )  ;", "view . render ( new   HashMap (  )  ,    TEXT _ HTML ,    this . exchange )  . block (  )  ;", "assertEquals ( URI . create (  \"  / context / test . html ? id =  1  \"  )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["contextRelativeQueryParam"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / url . somewhere . com \"  ;", "view    =    new    ( url ,    HttpStatus . FOUND )  ;", "view . render ( new   HashMap (  )  ,    TEXT _ HTML ,    this . exchange )  . block (  )  ;", "assertEquals ( FOUND ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( URI . create ( url )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["customStatusCode"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / url . somewhere . com \"  ;", "view    =    new    ( url )  ;", "view . render ( new   HashMap (  )  ,    TEXT _ HTML ,    this . exchange )  . block (  )  ;", "assertEquals ( SEE _ OTHER ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( URI . create ( url )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultStatusCode"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / url . somewhere . com ? foo =  { foo }  \"  ;", "Map < String ,    String >    attributes    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "this . exchange . getAttributes (  )  . put ( HandlerMapping . URI _ TEMPLATE _ VARIABLES _ ATTRIBUTE ,    attributes )  ;", "view    =    new    ( url )  ;", "view . render ( new   HashMap (  )  ,    TEXT _ HTML ,    exchange )  . block (  )  ;", "assertEquals ( URI . create (  \" http :  /  / url . somewhere . com ? foo = bar \"  )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["expandUriTemplateVariablesFromExchangeAttribute"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" http :  /  / url . somewhere . com ? foo =  { foo }  \"  ;", "Map < String ,    String >    model    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "view    =    new    ( url )  ;", "view . render ( model ,    TEXT _ HTML ,    this . exchange )  . block (  )  ;", "assertEquals ( URI . create (  \" http :  /  / url . somewhere . com ? foo = bar \"  )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["expandUriTemplateVariablesFromModel"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "RedirectView   rv    =    new   RedirectView ( null )  ;", "rv . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["noUrlSet"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "RedirectView   view    =    new   RedirectView (  \" http :  /  / url . somewhere . com ? foo = bar # bazz \"  )  ;", "view . setPropagateQuery ( true )  ;", "this . exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \" http :  /  / url . somewhere . com ? a = b & c = d \"  )  )  ;", "view . render ( new   HashMap (  )  ,    TEXT _ HTML ,    this . exchange )  . block (  )  ;", "assertEquals ( SEE _ OTHER ,    this . exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals ( URI . create (  \" http :  /  / url . somewhere . com ? foo = bar & a = b & c = d # bazz \"  )  ,    this . exchange . getResponse (  )  . getHeaders (  )  . getLocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["propagateQueryParams"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "RedirectView   view    =    new   RedirectView (  \"  \"  )  ;", "assertFalse ( view . isRemoteHost (  \" http :  /  / url . somewhere . com \"  )  )  ;", "assertFalse ( view . isRemoteHost (  \"  / path \"  )  )  ;", "assertFalse ( view . isRemoteHost (  \" http :  /  / url . somewhereelse . com \"  )  )  ;", "view . setHosts (  \" url . somewhere . com \"  )  ;", "assertFalse ( view . isRemoteHost (  \" http :  /  / url . somewhere . com \"  )  )  ;", "assertFalse ( view . isRemoteHost (  \"  / path \"  )  )  ;", "assertTrue ( view . isRemoteHost (  \" http :  /  / url . somewhereelse . com \"  )  )  ;", "}", "METHOD_END"], "methodName": ["remoteHost"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "this . exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  / context / path \"  )  . contextPath (  \"  / context \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.view.RedirectViewTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultRenderingBuilder ( new   RedirectView ( url )  )  ;", "}", "METHOD_END"], "methodName": ["redirectTo"], "fileName": "org.springframework.web.reactive.result.view.Rendering"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultRenderingBuilder ( name )  ;", "}", "METHOD_END"], "methodName": ["view"], "fileName": "org.springframework.web.reactive.result.view.Rendering"}, {"methodBody": ["METHOD_START", "{", "this . locale    =    locale ;", "}", "METHOD_END"], "methodName": ["changeLocale"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "this . locale    =    locale ;", "this . meZone    =    meZone ;", "}", "METHOD_END"], "methodName": ["changeLocale"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   new   BindStatus ( this ,    path ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBindStatus"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   new   BindStatus ( this ,    path ,    htmlEscape )  ;", "}", "METHOD_END"], "methodName": ["getBindStatus"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . exchange . getRequest (  )  . getPath (  )  . contextPath (  )  . value (  )  ;", "}", "METHOD_END"], "methodName": ["getContextPath"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "String   url    =    StringUtils . applyRelativePath (  (  ( getContextPath (  )  )     +     \"  /  \"  )  ,    relativeUrl )  ;", "return   getExchange (  )  . transformUrl ( url )  ;", "}", "METHOD_END"], "methodName": ["getContextUrl"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "String   url    =    StringUtils . applyRelativePath (  (  ( getContextPath (  )  )     +     \"  /  \"  )  ,    relativeUrl )  ;", "UriTemplate   template    =    new   UriTemplate ( url )  ;", "url    =    template . expand ( params )  . toASCIIString (  )  ;", "return   getExchange (  )  . transformUrl ( url )  ;", "}", "METHOD_END"], "methodName": ["getContextUrl"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultHtmlEscape ;", "}", "METHOD_END"], "methodName": ["getDefaultHtmlEscape"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   getErrors ( name ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getErrors"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . errorsMap )     =  =    null )     {", "this . errorsMap    =    new   HashMap (  )  ;", "}", "Errors   errors    =    this . errorsMap . get ( name )  ;", "if    ( errors    =  =    null )     {", "errors    =    getModelObject (  (  ( BindingRMODEL _ KEY _ PREFIX )     +    name )  )  ;", "if    ( errors    =  =    null )     {", "return   null ;", "}", "}", "if    ( errors   instanceof   BindException )     {", "errors    =     (  ( BindException )     ( errors )  )  . getBindingR )  ;", "}", "if    ( htmlEscape    &  &     (  !  ( errors   instanceof   EscapedErrors )  )  )     {", "errors    =    new   EscapedErrors ( errors )  ;", "} else", "if    (  (  ! htmlEscape )     &  &     ( errors   instanceof   EscapedErrors )  )     {", "errors    =     (  ( EscapedErrors )     ( errors )  )  . getSource (  )  ;", "}", "this . errorsMap . put ( name ,    errors )  ;", "return   errors ;", "}", "METHOD_END"], "methodName": ["getErrors"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . exchange ;", "}", "METHOD_END"], "methodName": ["getExchange"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . locale ;", "}", "METHOD_END"], "methodName": ["getLocale"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   getMessage ( code ,    null ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   getMessage ( code ,    args ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    this . messageSource . getMessage ( code ,    args ,    this . locale )  ;", "return   htmlEscape    ?    HtmlUtils . htmlEscape ( msg )     :    msg ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   getMessage ( code ,    args ,    defaultMessage ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    this . messageSource . getMessage ( code ,    args ,    defaultMessage ,    this . locale )  ;", "if    ( msg    =  =    null )     {", "return    \"  \"  ;", "}", "return   htmlEscape    ?    HtmlUtils . htmlEscape ( msg )     :    msg ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   getMessage ( code ,    null ,    defaultMessage ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   getMessage ( code ,     ( args    !  =    null    ?    args . toArray (  )     :    null )  ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   getMessage ( code ,     ( args    !  =    null    ?    args . toArray (  )     :    null )  ,    defaultMessage ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   getMessage ( resolvable ,    isDefaultHtmlEscape (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "String   msg    =    this . messageSource . getMessage ( resolvable ,    this . locale )  ;", "return   htmlEscape    ?    HtmlUtils . htmlEscape ( msg )     :    msg ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSource ;", "}", "METHOD_END"], "methodName": ["getMessageSource"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . model ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "T   modelObject    =     (  ( T )     ( this . model . get ( modelName )  )  )  ;", "if    ( modelObject    =  =    null )     {", "modelObject    =    this . exchange . getAttribute ( modelName )  ;", "}", "return   modelObject ;", "}", "METHOD_END"], "methodName": ["getModelObject"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . exchange . getRequest (  )  . getURI (  )  . getQuery (  )  ;", "}", "METHOD_END"], "methodName": ["getQueryString"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . dataValueProcessor ;", "}", "METHOD_END"], "methodName": ["getRequestDataValueProcessor"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . exchange . getRequest (  )  . getURI (  )  . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["getRequestPath"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return   this . timeZone ;", "}", "METHOD_END"], "methodName": ["getTimeZone"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . defaultHtmlEscape )     !  =    null )     &  &     ( this . defaultHtmlEscape . booleanValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultHtmlEscape"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "this . defaultHtmlEscape    =    defaultHtmlEscape ;", "}", "METHOD_END"], "methodName": ["setDefaultHtmlEscape"], "fileName": "org.springframework.web.reactive.result.view.RequestContext"}, {"methodBody": ["METHOD_START", "{", "this . applicationContext    =    new   GenericApplicationContext (  )  ;", "this . applicationContext . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.web.reactive.result.view.RequestContextTests"}, {"methodBody": ["METHOD_START", "{", "RequestContext   context    =    new   RequestContext ( this . exchange ,    this . model ,    this . applicationContext )  ;", "assertEquals (  \"  / foo / bar \"  ,    context . getContextUrl (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetContextUrl"], "fileName": "org.springframework.web.reactive.result.view.RequestContextTests"}, {"methodBody": ["METHOD_START", "{", "RequestContext   context    =    new   RequestContext ( this . exchange ,    this . model ,    this . applicationContext )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "map . put (  \" spam \"  ,     \" bucket \"  )  ;", "assertEquals (  \"  / foo / bar ? spam = bucket \"  ,    context . getContextUrl (  \"  { foo }  ? spam =  { spam }  \"  ,    map )  )  ;", "}", "METHOD_END"], "methodName": ["testGetContextUrlWithMap"], "fileName": "org.springframework.web.reactive.result.view.RequestContextTests"}, {"methodBody": ["METHOD_START", "{", "RequestContext   context    =    new   RequestContext ( this . exchange ,    this . model ,    this . applicationContext )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar   baz \"  )  ;", "map . put (  \" spam \"  ,     \"  & bucket =  \"  )  ;", "assertEquals (  \"  / foo / bar %  2  0 baz ? spam =  %  2  6 bucket %  3 D \"  ,    context . getContextUrl (  \"  { foo }  ? spam =  { spam }  \"  ,    map )  )  ;", "}", "METHOD_END"], "methodName": ["testGetContextUrlWithMapEscaping"], "fileName": "org.springframework.web.reactive.result.view.RequestContextTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    getApplicationContext (  )  ;", "if    ( context    !  =    null )     {", "Object   initialized    =    context . getAutowireCapableBeanFactory (  )  . initializeBean (  ,    Name )  ;", "if    ( initialized   instanceof   View )     {", "return    (  ( View )     ( initialized )  )  ;", "}", "}", "return    ;", "}", "METHOD_END"], "methodName": ["applyLifecycleMethods"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "String [  ]    viewNames    =    getViewNames (  )  ;", "return    ( viewNames    =  =    null )     |  |     ( PatternMatchUtils . simpleMatch ( viewNames ,    viewName )  )  ;", "}", "METHOD_END"], "methodName": ["canHandle"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    viewClass    =    getViewClass (  )  ;", "Assert . state (  ( viewClass    !  =    null )  ,     \" No   view   class \"  )  ;", "Abstract   view    =     (  ( Abstract )     ( BeanUtils . instantiateClass ( viewClass )  )  )  ;", "view . setSupportedMediaTypes ( getSupportedMediaTypes (  )  )  ;", "view . setRequestContextAttribute ( getRequestContextAttribute (  )  )  ;", "view . setDefaultCharset ( getDefaultCharset (  )  )  ;", "view . setUrl (  (  (  ( getPrefix (  )  )     +    viewName )     +     ( getSuffix (  )  )  )  )  ;", "return   view ;", "}", "METHOD_END"], "methodName": ["createView"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . prefix ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . requestContextAttribute ;", "}", "METHOD_END"], "methodName": ["getRequestContextAttribute"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . suffix ;", "}", "METHOD_END"], "methodName": ["getSuffix"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . viewClass ;", "}", "METHOD_END"], "methodName": ["getViewClass"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . viewNames ;", "}", "METHOD_END"], "methodName": ["getViewNames"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "return   AbstractUrlBasedView . class ;", "}", "METHOD_END"], "methodName": ["requiredViewClass"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "this . prefix    =     ( prefix    !  =    null )     ?    prefix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setPrefix"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "this . redirectViewProvider    =    redirectViewProvider ;", "}", "METHOD_END"], "methodName": ["setRedirectViewProvider"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "this . requestContextAttribute    =    requestContextAttribute ;", "}", "METHOD_END"], "methodName": ["setRequestContextAttribute"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "this . suffix    =     ( suffix    !  =    null )     ?    suffix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setSuffix"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( viewClass    !  =    null )     &  &     (  !  ( requiredViewClass (  )  . isAssignableFrom ( viewClass )  )  )  )     {", "String   name    =    viewClass . getName (  )  ;", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Given   view   class    [  \"     +    name )     +     \"  ]     \"  )     +     \" is   not   of   type    [  \"  )     +     ( requiredViewClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "this . viewClass    =    viewClass ;", "}", "METHOD_END"], "methodName": ["setViewClass"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "this . viewNames    =    viewNames ;", "}", "METHOD_END"], "methodName": ["setViewNames"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolver"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setRedirectViewProvider (  (    url )     -  >    new   RedirectView ( url ,    HttpStatus . FOUND )  )  ;", "Mono < View >    mono    =    this . resolver . resolveViewName (  \" redirect : foo \"  ,    Locale . US )  ;", "StepVerifier . create ( mono )  . consumeNextWith (  (    view )     -  >     {", "assertEquals (  . class ,    view . getClass (  )  )  ;", "RedirectView   redirectView    =     (  ( RedirectView )     ( view )  )  ;", "assertEquals (  \" foo \"  ,    redirectView . getUrl (  )  )  ;", "assertEquals ( HttpStatus . FOUND ,    redirectView . getStatusCode (  )  )  ;", "}  )  . expectComplete (  )  . verify ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["customizedRedirectView"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolverTests"}, {"methodBody": ["METHOD_START", "{", "Mono < View >    mono    =    this . resolver . resolveViewName (  \" redirect : foo \"  ,    Locale . US )  ;", "StepVerifier . create ( mono )  . consumeNextWith (  (    view )     -  >     {", "assertEquals (  . class ,    view . getClass (  )  )  ;", "RedirectView   redirectView    =     (  ( RedirectView )     ( view )  )  ;", "assertEquals (  \" foo \"  ,    redirectView . getUrl (  )  )  ;", "assertEquals ( HttpStatus . SEE _ OTHER ,    redirectView . getStatusCode (  )  )  ;", "}  )  . expectComplete (  )  . verify ( Duration . ZERO )  ;", "}", "METHOD_END"], "methodName": ["redirectView"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolverTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . refresh (  )  ;", "this . resolver    =    new    (  )  ;", "this . resolver . setApplicationContext ( context )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setViewClass ( UrlBasedViewResolverTests . TestView . class )  ;", "this . resolver . setViewNames (  \" my *  \"  )  ;", "Mono < View >    mono    =    this . resolver . resolveViewName (  \" my - view \"  ,    Locale . US )  ;", "assertNotNull ( mono . block (  )  )  ;", "mono    =    this . resolver . resolveViewName (  \" not - my - view \"  ,    Locale . US )  ;", "assertNull ( mono . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["viewNames"], "fileName": "org.springframework.web.reactive.result.view.UrlBasedViewResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getSupportedMediaTypes"], "fileName": "org.springframework.web.reactive.result.view.View"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isRedirectView"], "fileName": "org.springframework.web.reactive.result.view.View"}, {"methodBody": ["METHOD_START", "{", "String   path    =    exchange . getRequest (  )  . getPath (  )  . pathWithinApplication (  )  . value (  )  ;", "if    ( path . startsWith (  \"  /  \"  )  )     {", "path    =    path . substring (  1  )  ;", "}", "if    ( path . endsWith (  \"  /  \"  )  )     {", "path    =    path . substring (  0  ,     (  ( path . length (  )  )     -     1  )  )  ;", "}", "return   StringUtils . stripFilenameExtension ( path )  ;", "}", "METHOD_END"], "methodName": ["getDefaultViewName"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultViews ;", "}", "METHOD_END"], "methodName": ["getDefaultViews"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   views . stream (  )  . flatMap (  (    view )     -  >    view . getSupportedMediaTypes (  )  . stream (  )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMediaTypes"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   Optional . ofNullable ( returnType . getMethodAnnotation ( ModelAttribute . class )  )  . filter (  (    ann )     -  >    StringUtils . hasText ( ann . value (  )  )  )  . map ( ModelAttribute :  : value )  . orElse ( Conventions . getVariableNameForParameter ( returnType )  )  ;", "}", "METHOD_END"], "methodName": ["getNameForReturnValue"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . viewResolvers )  ;", "}", "METHOD_END"], "methodName": ["getViewResolvers"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   parameter . hasMethodAnnotation ( ModelAttribute . class )  ;", "}", "METHOD_END"], "methodName": ["hasModelAnnotation"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  !  ( name . startsWith ( MODEL _ KEY _ PREFIX )  )  )     &  &     ( value    !  =    null )  )     &  &     (  !  ( value . getClass (  )  . isArray (  )  )  )  )     &  &     (  !  ( value   instanceof   Collection )  )  )     &  &     (  !  ( value   instanceof   Map )  )  )     &  &     (  !  ( BeanUtils . isSimpleValueType ( value . getClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isBindingCandidate"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( View   view    :    views )     {", "if    ( view . isRedirectView (  )  )     {", "return   view . render ( model ,    null ,    exchange )  ;", "}", "}", "List < MediaType >    mediaTypes    =    getMediaTypes ( views )  ;", "MediaType   bestMediaType    =    selectMediaType ( exchange ,     (  )     -  >    mediaTypes )  ;", "if    ( bestMediaType    !  =    null )     {", "for    ( View   view    :    views )     {", "for    ( MediaType   mediaType    :    view . getSupportedMediaTypes (  )  )     {", "if    ( mediaType . isCompatibleWith ( bestMediaType )  )     {", "return   view . render ( model ,    mediaType ,    exchange )  ;", "}", "}", "}", "}", "throw   new   server . NotAcceptableStatusException ( mediaTypes )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "return   Flux . fromIterable ( getViewResolvers (  )  )  . concatMap (  (    resolver )     -  >    resolver . resolveViewName ( viewName ,    locale )  )  . collectList (  )  . map (  (    views )     -  >     {", "if    ( views . isEmpty (  )  )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   resolve   view   with   name    '  \"     +    viewName )     +     \"  '  .  \"  )  )  ;", "}", "views . addAll ( getDefaultViews (  )  )  ;", "return   views ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["resolveViews"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "this . defaultViews . clear (  )  ;", "if    ( defaultViews    !  =    null )     {", "this . defaultViews . addAll ( defaultViews )  ;", "}", "}", "METHOD_END"], "methodName": ["setDefaultViews"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    context . getModel (  )  . asMap (  )  ;", "model . keySet (  )  . stream (  )  . filter (  (    name )     -  >    isBindingCandidate ( name ,    model . get ( name )  )  )  . filter (  (    name )     -  >     !  ( model . containsKey (  (  ( BindingRMODEL _ KEY _ PREFIX )     +    name )  )  )  )  . forEach (  (    name )     -  >     {", "WebExchangeDataBinder   binder    =    context . createDataBinder ( exchange ,    model . get ( name )  ,    name )  ;", "model . put (  (  ( BindingRMODEL _ KEY _ PREFIX )     +    name )  ,    binder . getBindingR )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["updateBindingContext"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandler"}, {"methodBody": ["METHOD_START", "{", "StepVerifier . create ( exchange . getResponse (  )  . getBody (  )  )  . consumeNextWith (  (    buf )     -  >    assertEquals ( responseBody ,    DataBufferTestUtils . dumpString ( buf ,    StandardCharsets . UTF _  8  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["assertResponseBody"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ViewResolutionResultHandlerTests . TestBean   value    =    new   ViewResolutionResultHandlerTests . TestBean (  \" Joe \"  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( ViewResolutionResultHandlerTests . TestBean . class )  ;", "HandlerResult   handlerResult    =    new   HandlerResult ( new   Object (  )  ,    value ,    returnType ,    this . bindingContext )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / account \"  )  . accept ( MediaType . APPLICATION _ JSON )  )  ;", "ViewResolutionResultHandlerTests . TestView   defaultView    =    new   ViewResolutionResultHandlerTests . TestView (  \" jsonView \"  ,    MediaType . APPLICATION _ JSON )  ;", "resultHandler ( Collections . singletonList ( defaultView )  ,    new   ViewResolutionResultHandlerTests . TestViewResolver (  \" account \"  )  )  . handleResult ( exchange ,    handlerResult )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals ( MediaType . APPLICATION _ JSON ,    exchange . getResponse (  )  . getHeaders (  )  . getContentType (  )  )  ;", "assertResponseBody ( exchange ,     (  \" jsonView :     {  \"     +     (  (  (  \" testBean =  \"     +     \" BeanPropertyBindingResult :     0    errors ,     \"  )     +     \" testBean = TestBean [ name = Joe ]  \"  )     +     \"  }  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contentNegotiation"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ViewResolutionResultHandlerTests . TestBean   value    =    new   ViewResolutionResultHandlerTests . TestBean (  \" Joe \"  )  ;", "MethodParameter   returnType    =    ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( ViewResolutionResultHandlerTests . TestBean . class )  ;", "HandlerResult   handlerResult    =    new   HandlerResult ( new   Object (  )  ,    value ,    returnType ,    this . bindingContext )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / account \"  )  . accept ( MediaType . APPLICATION _ JSON )  )  ;", "ViewResolutionResultHandler   resultHandler    =    resultHandler ( new   ViewResolutionResultHandlerTests . TestViewResolver (  \" account \"  )  )  ;", "Mono < Void >    mono    =    resultHandler . handleResult ( exchange ,    handlerResult )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectError ( NotAcceptableStatusException . class )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["contentNegotiationWith406"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HandlerResult   handlerResult    =    new   HandlerResult ( new   Object (  )  ,     \" redirect :  /  \"  ,    ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotNotPresent ( ModelAttribute . class )  . resolveReturnType ( String . class )  ,    this . bindingContext )  ;", "UrlBasedViewResolver   viewResolver    =    new   UrlBasedViewResolver (  )  ;", "viewResolver . setApplicationContext ( new   StaticApplicationContext (  )  )  ;", "ViewResolutionResultHandler   resultHandler    =    resultHandler ( viewResolver )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / account \"  )  . accept ( MediaType . APPLICATION _ JSON )  )  ;", "resultHandler . handleResult ( exchange ,    handlerResult )  . block ( Duration . ZERO )  ;", "MockServerHttpResponse   response    =    exchange . getResponse (  )  ;", "assertEquals (  3  0  3  ,    response . getStatusCode (  )  . value (  )  )  ;", "assertEquals (  \"  /  \"  ,    response . getHeaders (  )  . getLocation (  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentNegotiationWithRedirect"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testDefaultViewName ( null ,    ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotPresent ( ModelAttribute . class )  . resolveReturnType ( String . class )  )  ;", "testDefaultViewName ( Mono . empty (  )  ,    ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Mono . class ,    String . class )  )  ;", "testDefaultViewName ( Mono . empty (  )  ,    ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Mono . class ,    Void . class )  )  ;", "testDefaultViewName ( Completable . complete (  )  ,    ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Completable . class )  )  ;", "}", "METHOD_END"], "methodName": ["defaultViewName"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   returnValue ;", "MethodParameter   returnType ;", "ViewResolver   resolver    =    new    . TestViewResolver (  \" account \"  )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . resolveReturnType ( View . class )  ;", "returnValue    =    new    . TestView (  \" account \"  )  ;", "testHandle (  \"  / path \"  ,    returnType ,    returnValue ,     \" account :     { id =  1  2  3  }  \"  )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . resolveReturnType ( Mono . class ,    View . class )  ;", "returnValue    =    Mono . just ( new    . TestView (  \" account \"  )  )  ;", "testHandle (  \"  / path \"  ,    returnType ,    returnValue ,     \" account :     { id =  1  2  3  }  \"  )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . annotNotPresent ( ModelAttribute . class )  . resolveReturnType ( String . class )  ;", "returnValue    =     \" account \"  ;", "testHandle (  \"  / path \"  ,    returnType ,    returnValue ,     \" account :     { id =  1  2  3  }  \"  ,    resolver )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . annotPresent ( ModelAttribute . class )  . resolveReturnType ( String . class )  ;", "returnValue    =     \"  1  2  3  \"  ;", "testHandle (  \"  / account \"  ,    returnType ,    returnValue ,     \" account :     { id =  1  2  3  ,    myString =  1  2  3  }  \"  ,    resolver )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . resolveReturnType ( Mono . class ,    String . class )  ;", "returnValue    =    Mono . just (  \" account \"  )  ;", "testHandle (  \"  / path \"  ,    returnType ,    returnValue ,     \" account :     { id =  1  2  3  }  \"  ,    resolver )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . resolveReturnType ( Model . class )  ;", "returnValue    =    new   ConcurrentModel (  )  . addAttribute (  \" name \"  ,     \" Joe \"  )  ;", "testHandle (  \"  / account \"  ,    returnType ,    returnValue ,     \" account :     { id =  1  2  3  ,    name = Joe }  \"  ,    resolver )  ;", "ResolvableType . clearCache (  )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . annotNotPresent ( ModelAttribute . class )  . resolveReturnType ( Map . class )  ;", "returnValue    =    Collections . singletonMap (  \" name \"  ,     \" Joe \"  )  ;", "testHandle (  \"  / account \"  ,    returnType ,    returnValue ,     \" account :     { id =  1  2  3  ,    name = Joe }  \"  ,    resolver )  ;", "ResolvableType . clearCache (  )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . annotPresent ( ModelAttribute . class )  . resolveReturnType ( Map . class )  ;", "returnValue    =    Collections . singletonMap (  \" name \"  ,     \" Joe \"  )  ;", "testHandle (  \"  / account \"  ,    returnType ,    returnValue ,     \" account :     { id =  1  2  3  ,    myMap =  { name = Joe }  }  \"  ,    resolver )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . resolveReturnType (  . TestBean . class )  ;", "returnValue    =    new    . TestBean (  \" Joe \"  )  ;", "String   responseBody    =     \" account :     { id =  1  2  3  ,     \"     +     (  (  \" testBean =  \"     +     \" BeanPropertyBindingResult :     0    errors ,     \"  )     +     \" testBean = TestBean [ name = Joe ]  }  \"  )  ;", "testHandle (  \"  / account \"  ,    returnType ,    returnValue ,    responseBody ,    resolver )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . annotPresent ( ModelAttribute . class )  . resolveReturnType ( Long . class )  ;", "testHandle (  \"  / account \"  ,    returnType ,     9  9 L ,     \" account :     { id =  1  2  3  ,    myLong =  9  9  }  \"  ,    resolver )  ;", "returnType    =    ResolvableMethod . on (  . Handler . class )  . resolveReturnType ( Rendering . class )  ;", "HttpStatus   status    =    HttpStatus . UNPROCESSABLE _ ENTITY ;", "returnValue    =    Rendering . view (  \" account \"  )  . modelAttribute (  \" a \"  ,     \" a 1  \"  )  . status ( status )  . header (  \" h \"  ,     \" h 1  \"  )  . build (  )  ;", "String   expected    =     \" account :     { a = a 1  ,    id =  1  2  3  }  \"  ;", "ServerWebExchange   exchange    =    testHandle (  \"  / path \"  ,    returnType ,    returnValue ,    expected ,    resolver )  ;", "assertEquals ( status ,    exchange . getResponse (  )  . getStatusCode (  )  )  ;", "assertEquals (  \" h 1  \"  ,    exchange . getResponse (  )  . getHeaders (  )  . getFirst (  \" h \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleReturnValueTypes"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testHandle (  \"  / account \"  ,    ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotNotPresent ( ModelAttribute . class )  . resolveReturnType ( String . class )  ,     \" profile \"  ,     \" profile :     { id =  1  2  3  }  \"  ,    new   ViewResolutionResultHandlerTests . TestViewResolver (  \" account \"  )  ,    new   ViewResolutionResultHandlerTests . TestViewResolver (  \" profile \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleWithMultipleResolvers"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List < ViewResolver >    resolverList    =    Arrays . asList ( resolvers )  ;", "RequestedContentTypeResolver   contentTypeResolver    =    new   HeaderContentTypeResolver (  )  ;", "handler    =    new    ( resolverList ,    contentTypeResolver )  ;", "handler . setDefaultViews ( defaultViews )  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["resultHandler"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   resultHandler ( Collections . emptyList (  )  ,    resolvers )  ;", "}", "METHOD_END"], "methodName": ["resultHandler"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotPresent ( ModelAttribute . class )  . resolveReturnType ( String . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotNotPresent ( ModelAttribute . class )  . resolveReturnType ( String . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Mono . class ,    String . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Rendering . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Mono . class ,    Rendering . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( View . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Mono . class ,    View . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( void . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Mono . class ,    Void . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Completable . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Model . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotPresent ( ModelAttribute . class )  . resolveReturnType ( Map . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotNotPresent ( ModelAttribute . class )  . resolveReturnType ( Map . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( ViewResolutionResultHandlerTests . TestBean . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotPresent ( ModelAttribute . class )  . resolveReturnType ( Long . class )  )  ;", "testDoesNotSupport ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . annotNotPresent ( ModelAttribute . class )  . resolveReturnType ( Long . class )  )  ;", "testSupports ( ResolvableMethod . on ( ViewResolutionResultHandlerTests . Handler . class )  . resolveReturnType ( Mono . class )  )  ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . bindingContext . getModel (  )  . addAttribute (  \" id \"  ,     \"  1  2  3  \"  )  ;", "HandlerResult   result    =    new   HandlerResult ( new   Object (  )  ,    returnValue ,    returnType ,    this . bindingContext )  ;", "ViewResolutionResultHandler   handler    =    resultHandler ( new    . TestViewResolver (  \" account \"  )  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / account \"  )  )  ;", "handler . handleResult ( exchange ,    result )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertResponseBody ( exchange ,     \" account :     { id =  1  2  3  }  \"  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  / account /  \"  )  )  ;", "handler . handleResult ( exchange ,    result )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertResponseBody ( exchange ,     \" account :     { id =  1  2  3  }  \"  )  ;", "exchange    =    MockServerWebExchange . from ( get (  \"  / account .  1  2  3  \"  )  )  ;", "handler . handleResult ( exchange ,    result )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertResponseBody ( exchange ,     \" account :     { id =  1  2  3  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultViewName"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testSupports ( returnType ,    false )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotSupport"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Model   model    =    this . bindingContext . getModel (  )  ;", "model . asMap (  )  . clear (  )  ;", "model . addAttribute (  \" id \"  ,     \"  1  2  3  \"  )  ;", "HandlerResult   result    =    new   HandlerResult ( new   Object (  )  ,    returnValue ,    returnType ,    this . bindingContext )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get ( path )  )  ;", "r ( resolvers )  . handleResult ( exchange ,    result )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertResponseBody ( exchange ,    responseBody )  ;", "return   exchange ;", "}", "METHOD_END"], "methodName": ["testHandle"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testSupports ( returnType ,    true )  ;", "}", "METHOD_END"], "methodName": ["testSupports"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ViewResolutionResultHandler   resultHandler    =    resultHandler ( mock ( ViewResolver . class )  )  ;", "HandlerResult   handlerResult    =    new   HandlerResult ( new   Object (  )  ,    null ,    returnType ,    this . bindingContext )  ;", "assertEquals ( supports ,    resultHandler . supports ( handlerResult )  )  ;", "}", "METHOD_END"], "methodName": ["testSupports"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   returnValue    =     \" account \"  ;", "MethodParameter   returnType    =    ResolvableMethod . on (  . Handler . class )  . annotPresent ( ModelAttribute . class )  . resolveReturnType ( String . class )  ;", "HandlerResult   result    =    new   HandlerResult ( new   Object (  )  ,    returnValue ,    returnType ,    this . bindingContext )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( get (  \"  / path \"  )  )  ;", "Mono < Void >    mono    =    resultHandler (  )  . handleResult ( exchange ,    result )  ;", "StepVerifier . create ( mono )  . expectNextCount (  0  )  . expectErrorMessage (  \" Could   not   resolve   view   with   name    ' path '  .  \"  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["unresolvedViewName"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ViewResolutionResultHandlerTests . TestViewResolver   resolver 1     =    new   ViewResolutionResultHandlerTests . TestViewResolver (  \" account \"  )  ;", "ViewResolutionResultHandlerTests . TestViewResolver   resolver 2     =    new   ViewResolutionResultHandlerTests . TestViewResolver (  \" profile \"  )  ;", "resolver 1  . setOrder (  2  )  ;", "resolver 2  . setOrder (  1  )  ;", "List < ViewResolver >    resolvers    =    resultHandler ( resolver 1  ,    resolver 2  )  . getViewResolvers (  )  ;", "assertEquals ( Arrays . asList ( resolver 2  ,    resolver 1  )  ,    resolvers )  ;", "}", "METHOD_END"], "methodName": ["viewResolverOrder"], "fileName": "org.springframework.web.reactive.result.view.ViewResolutionResultHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultCharset ;", "}", "METHOD_END"], "methodName": ["getDefaultCharset"], "fileName": "org.springframework.web.reactive.result.view.ViewResolverSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . mediaTypes ;", "}", "METHOD_END"], "methodName": ["getSupportedMediaTypes"], "fileName": "org.springframework.web.reactive.result.view.ViewResolverSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( defaultCharset ,     \" Default   Charset   must   not   be   null \"  )  ;", "this . defaultCharset    =    defaultCharset ;", "}", "METHOD_END"], "methodName": ["setDefaultCharset"], "fileName": "org.springframework.web.reactive.result.view.ViewResolverSupport"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.web.reactive.result.view.ViewResolverSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( supportedMediaTypes ,     \" MediaType   List   must   not   be   empty \"  )  ;", "this . mediaTypes . clear (  )  ;", "this . mediaTypes . addAll ( supportedMediaTypes )  ;", "}", "METHOD_END"], "methodName": ["setSupportedMediaTypes"], "fileName": "org.springframework.web.reactive.result.view.ViewResolverSupport"}, {"methodBody": ["METHOD_START", "{", "this . configuration    =    configuration ;", "}", "METHOD_END"], "methodName": ["setConfiguration"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerConfigurer"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   BeanFactoryUtils . beanOfTypeIncludingAncestors ( obtainApplicationContext (  )  ,    FreeMarkerConfig . class ,    true ,    false )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "throw   new   context . ApplicationContextException (  (  \" Must   define   a   single   FreeMarkerConfig   bean   in   this   web   application   context    \"     +     (  \"  ( may   be   inherited )  :    FreeMarkerConfigurer   is   the   usual   implementation .     \"     +     \" This   bean   may   be   given   any   name .  \"  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["autodetectConfiguration"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "return   Optional . ofNullable ( mediaType )  . map ( MimeType :  : getCharset )  . orElse ( getDefaultCharset (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "return   this . configuration ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "return   this . encoding ;", "}", "METHOD_END"], "methodName": ["getEncoding"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "ObjectWrapper   ow    =    obtainConfiguration (  )  . getObjectWrapper (  )  ;", "Version   version    =    Configuration . DEFAULT _ INCOMPATIBLE _ IMPROVEMENTS ;", "return   ow    !  =    null    ?    ow    :    new   template . DefaultObjectWrapperBuilder ( version )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getObjectWrapper"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "return    ( getEncoding (  )  )     !  =    null    ?    obtainConfiguration (  )  . getTemplate ( getUrl (  )  ,    locale ,    getEncoding (  )  )     :    obtainConfiguration (  )  . getTemplate ( getUrl (  )  ,    locale )  ;", "}", "METHOD_END"], "methodName": ["getTemplate"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "SimpleHash   fmModel    =    new   SimpleHash ( getObjectWrapper (  )  )  ;", "fmModel . putAll ( model )  ;", "return   fmModel ;", "}", "METHOD_END"], "methodName": ["getTemplateModel"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "Configuration   configuration    =    getConfiguration (  )  ;", "Assert . state (  ( configuration    !  =    null )  ,     \" No   Configuration   set \"  )  ;", "return   configuration ;", "}", "METHOD_END"], "methodName": ["obtainConfiguration"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "this . configuration    =    configuration ;", "}", "METHOD_END"], "methodName": ["setConfiguration"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "this . encoding    =    encoding ;", "}", "METHOD_END"], "methodName": ["setEncoding"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerView"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   byteBuffer    =    dataBuffer . asByteBuffer (  )  ;", "final   byte [  ]    bytes    =    new   byte [ byteBuffer . remaining (  )  ]  ;", "byteBuffer . get ( bytes )  ;", "return   new   St ( bytes ,    StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["asString"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerViewTests"}, {"methodBody": ["METHOD_START", "{", "FreeMarkerView   view    =    new   FreeMarkerView (  )  ;", "view . setConfiguration ( this . freeMarkerConfig )  ;", "view . setUrl (  \" test . ftl \"  )  ;", "assertTrue ( view . checkResourceExists ( Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["checkResourceExists"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerViewTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerViewTests"}, {"methodBody": ["METHOD_START", "{", "this . exception . expect ( ApplicationContextException . class )  ;", "this . exception . expectMessage (  \" Must   define   a   single   FreeMarkerConfig   bean \"  )  ;", "view    =    new    (  )  ;", "view . setApplicationContext ( this . context )  ;", "view . setUrl (  \" anythingButNull \"  )  ;", "view . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["noFreeMarkerConfig"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerViewTests"}, {"methodBody": ["METHOD_START", "{", "this . exception . expect ( IllegalArgumentException . class )  ;", "this . exception . expectMessage (  \" Property    ' url '    is   required \"  )  ;", "freeMarkerView    =    new    (  )  ;", "freeMarkerView . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["noTemplateName"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerViewTests"}, {"methodBody": ["METHOD_START", "{", "FreeMarkerView   view    =    new   FreeMarkerView (  )  ;", "view . setConfiguration ( this . freeMarkerConfig )  ;", "view . setUrl (  \" test . ftl \"  )  ;", "ModelMap   model    =    new   ExtendedModelMap (  )  ;", "model . addAttribute (  \" hello \"  ,     \" hi   FreeMarker \"  )  ;", "view . render ( model ,    null ,    this . exchange )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "StepVerifier . create ( this . exchange . getResponse (  )  . getBody (  )  )  . consumeNextWith (  (    buf )     -  >    assertEquals (  \"  < html >  < body > hi   FreeMarker <  / body >  <  / html >  \"  ,    asString ( buf )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerViewTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   GenericApplicationContext (  )  ;", "this . context . refresh (  )  ;", "FreeMarkerConfigurer   configurer    =    new   FreeMarkerConfigurer (  )  ;", "configurer . setPreferFileSystemAccess ( false )  ;", "configurer . setTemplateLoaderPath (  . TEMPLATE _ PATH )  ;", "configurer . setResourceLoader ( this . context )  ;", "this . freeMarkerConfig    =    configurer . createConfiguration (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.view.freemarker.FreeMarkerViewTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ScriptTemplatingConfiguration . class )  ;", "ctx . refresh (  )  ;", "ScriptTemplateView   view    =    new   ScriptTemplateView (  )  ;", "view . setApplicationContext ( ctx )  ;", "view . setUrl ( viewUrl )  ;", "view . afterPropertiesSet (  )  ;", "return   view ;", "}", "METHOD_END"], "methodName": ["createViewWithUrl"], "fileName": "org.springframework.web.reactive.result.view.script.JRubyScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    new   HashMap <  >  (  )  ;", "model . put (  \" title \"  ,     \" Layout   example \"  )  ;", "model . put (  \" body \"  ,     \" This   is   the   body \"  )  ;", "String   url    =     \" org /  / web / reactive / result / view / script / jruby / template . erb \"  ;", "MockServerHttpResponse   response    =    renderViewWithModel ( url ,    model )  ;", "assertEquals (  \"  < html >  < head >  < title > Layout   example <  / title >  <  / head >  < body >  < p > This   is   the   body <  / p >  <  / body >  <  / html >  \"  ,    response . getBodyAsString (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderTemplate"], "fileName": "org.springframework.web.reactive.result.view.script.JRubyScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ScriptTemplateView   view    =    createViewWithUrl ( viewUrl )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "view . renderInternal ( model ,    TEXT _ HTML ,    exchange )  . block (  )  ;", "return   exchange . getResponse (  )  ;", "}", "METHOD_END"], "methodName": ["renderViewWithModel"], "fileName": "org.springframework.web.reactive.result.view.script.JRubyScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register (  . ScriptTemplatingConfiguration . class )  ;", "ctx . refresh (  )  ;", "ScriptTemplateView   view    =    new   ScriptTemplateView (  )  ;", "view . setApplicationContext ( ctx )  ;", "view . setUrl ( viewUrl )  ;", "view . afterPropertiesSet (  )  ;", "return   view ;", "}", "METHOD_END"], "methodName": ["createViewWithUrl"], "fileName": "org.springframework.web.reactive.result.view.script.JythonScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    new   HashMap <  >  (  )  ;", "model . put (  \" title \"  ,     \" Layout   example \"  )  ;", "model . put (  \" body \"  ,     \" This   is   the   body \"  )  ;", "String   url    =     \" org /  / web / reactive / result / view / script / jython / template . html \"  ;", "MockServerHttpResponse   response    =    renderViewWithModel ( url ,    model )  ;", "assertEquals (  \"  < html >  < head >  < title > Layout   example <  / title >  <  / head >  < body >  < p > This   is   the   body <  / p >  <  / body >  <  / html >  \"  ,    response . getBodyAsString (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderTemplate"], "fileName": "org.springframework.web.reactive.result.view.script.JythonScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ScriptTemplateView   view    =    createViewWithUrl ( viewUrl )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "view . renderInternal ( model ,    TEXT _ HTML ,    exchange )  . block (  )  ;", "return   exchange . getResponse (  )  ;", "}", "METHOD_END"], "methodName": ["renderViewWithModel"], "fileName": "org.springframework.web.reactive.result.view.script.JythonScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( configuration )  ;", "ctx . refresh (  )  ;", "View   view    =    new   View (  )  ;", "view . setApplicationContext ( ctx )  ;", "view . setUrl ( viewUrl )  ;", "view . afterPropertiesSet (  )  ;", "return   view ;", "}", "METHOD_END"], "methodName": ["createViewWithUrl"], "fileName": "org.springframework.web.reactive.result.view.script.KotlinScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ScriptTemplateView   view    =    createViewWithUrl ( viewUrl ,    configuration )  ;", "MockServerHttpRequest   request    =    MockServerHttpRequest . get (  \"  /  \"  )  . acceptLanguageAsLocales ( locale )  . build (  )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( request )  ;", "view . renderInternal ( model ,    TEXT _ HTML ,    exchange )  . block (  )  ;", "return   exchange . getResponse (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.springframework.web.reactive.result.view.script.KotlinScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    new   HashMap <  >  (  )  ;", "model . put (  \" foo \"  ,     \" Foo \"  )  ;", "String   url    =     \" org / springframework / web / reactive / result / view / script / kotlin / template . kts \"  ;", "MockServerHttpResponse   response    =    render ( url ,    model ,    Locale . ENGLISH ,     . ScriptTemplatingConfiguration . class )  ;", "assertEquals (  \"  < html >  < body >  \\ n < p > Hello   Foo <  / p >  \\ n <  / body >  <  / html >  \"  ,    response . getBodyAsString (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderTemplateWithEnglishLocale"], "fileName": "org.springframework.web.reactive.result.view.script.KotlinScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    new   HashMap <  >  (  )  ;", "model . put (  \" foo \"  ,     \" Foo \"  )  ;", "String   url    =     \" org / springframework / web / reactive / result / view / script / kotlin / template . kts \"  ;", "MockServerHttpResponse   response    =    render ( url ,    model ,    Locale . FRENCH ,     . ScriptTemplatingConfiguration . class )  ;", "assertEquals (  \"  < html >  < body >  \\ n < p > Bonjour   Foo <  / p >  \\ n <  / body >  <  / html >  \"  ,    response . getBodyAsString (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderTemplateWithFrenchLocale"], "fileName": "org.springframework.web.reactive.result.view.script.KotlinScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    new   HashMap <  >  (  )  ;", "model . put (  \" header \"  ,     \"  < html >  < body >  \"  )  ;", "model . put (  \" hello \"  ,     \" Hello \"  )  ;", "model . put (  \" foo \"  ,     \" Foo \"  )  ;", "model . put (  \" footer \"  ,     \"  <  / body >  <  / html >  \"  )  ;", "String   url    =     \" org / springframework / web / reactive / result / view / script / kotlin / eval . kts \"  ;", "Class <  ?  >    configClass    =     . ScriptTemplatingConfigurationWithoutRenderFunction . class ;", "MockServerHttpResponse   response    =    render ( url ,    model ,    Locale . ENGLISH ,    configClass )  ;", "assertEquals (  \"  < html >  < body >  \\ n < p > Hello   Foo <  / p >  \\ n <  / body >  <  / html >  \"  ,    response . getBodyAsString (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderTemplateWithoutRenderFunction"], "fileName": "org.springframework.web.reactive.result.view.script.KotlinScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext (  )  ;", "ctx . register ( configuration )  ;", "ctx . refresh (  )  ;", "View   view    =    new   View (  )  ;", "view . setApplicationContext ( ctx )  ;", "view . setUrl ( viewUrl )  ;", "view . afterPropertiesSet (  )  ;", "return   view ;", "}", "METHOD_END"], "methodName": ["createViewWithUrl"], "fileName": "org.springframework.web.reactive.result.view.script.NashornScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ScriptTemplateView   view    =    createViewWithUrl ( viewUrl ,    configuration )  ;", "MockServerWebExchange   exchange    =    MockServerWebExchange . from ( MockServerHttpRequest . get (  \"  /  \"  )  )  ;", "view . renderInternal ( model ,    TEXT _ HTML ,    exchange )  . block (  )  ;", "return   exchange . getResponse (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.springframework.web.reactive.result.view.script.NashornScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    model    =    new   HashMap <  >  (  )  ;", "model . put (  \" title \"  ,     \" Layout   example \"  )  ;", "model . put (  \" body \"  ,     \" This   is   the   body \"  )  ;", "String   url    =     \" org / springframework / web / reactive / result / view / script / nashorn / template . html \"  ;", "MockServerHttpResponse   response    =    render ( url ,    model ,     . ScriptTemplatingConfiguration . class )  ;", "assertEquals (  \"  < html >  < head >  < title > Layout   example <  / title >  <  / head >  < body >  < p > This   is   the   body <  / p >  <  / body >  <  / html >  \"  ,    response . getBodyAsString (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderTemplate"], "fileName": "org.springframework.web.reactive.result.view.script.NashornScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     \" org / springframework / web / reactive / result / view / script / nashorn / template . html \"  ;", "Class <  ?  >    configClass    =     . ScriptTemplatingWithUrlConfiguration . class ;", "MockServerHttpResponse   response    =    render ( url ,    null ,    configClass )  ;", "assertEquals (  (  (  \"  < html >  < head >  < title > Check   url   parameter <  / title >  <  / head >  < body >  < p >  \"     +    url )     +     \"  <  / p >  <  / body >  <  / html >  \"  )  ,    response . getBodyAsString (  )  . block (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderTemplateWithUrl"], "fileName": "org.springframework.web.reactive.result.view.script.NashornScriptTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.web.reactive.result.view.script.RenderingContext"}, {"methodBody": ["METHOD_START", "{", "return   this . locale ;", "}", "METHOD_END"], "methodName": ["getLocale"], "fileName": "org.springframework.web.reactive.result.view.script.RenderingContext"}, {"methodBody": ["METHOD_START", "{", "return   this . templateLoader ;", "}", "METHOD_END"], "methodName": ["getTemplateLoader"], "fileName": "org.springframework.web.reactive.result.view.script.RenderingContext"}, {"methodBody": ["METHOD_START", "{", "return   this . url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.springframework.web.reactive.result.view.script.RenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . charset    =    charset ;", "}", "METHOD_END"], "methodName": ["setCharset"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . engine    =    engine ;", "}", "METHOD_END"], "methodName": ["setEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . engineName    =    engineName ;", "}", "METHOD_END"], "methodName": ["setEngineName"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . renderFunction    =    renderFunction ;", "}", "METHOD_END"], "methodName": ["setRenderFunction"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . renderObject    =    renderObject ;", "}", "METHOD_END"], "methodName": ["setRenderObject"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . resourceLoaderPath    =    resourceLoaderPath ;", "}", "METHOD_END"], "methodName": ["setResourceLoaderPath"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . scripts    =    scriptNames ;", "}", "METHOD_END"], "methodName": ["setScripts"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . sharedEngine    =    sharedEngine ;", "}", "METHOD_END"], "methodName": ["setSharedEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateConfigurer"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   BeanFactoryUtils . beanOfTypeIncludingAncestors ( obtainApplicationContext (  )  ,    ScriptTemplateConfig . class ,    true ,    false )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "throw   new   context . ApplicationContextException (  (  \" Expected   a   single   ScriptTemplateConfig   bean   in   the   current    \"     +     (  \" web   application   context   or   the   parent   root   context :    ScriptTemplateConfigurer   is    \"     +     \" the   usual   implementation .    This   bean   may   have   any   name .  \"  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["autodetectViewConfig"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "ScriptEngineManager   scriptEngineManager    =    this . scriptEngineManager ;", "if    ( scriptEngineManager    =  =    null )     {", "scriptEngineManager    =    new   ScriptEngineManager ( obtainApplicationContext (  )  . getClassLoader (  )  )  ;", "this . scriptEngineManager    =    scriptEngineManager ;", "}", "ScriptEngine   engine    =    StandardScriptUtils . retrieveEngineByName ( scriptEngineManager ,    engineName )  ;", "loadScripts ( engine )  ;", "return   engine ;", "}", "METHOD_END"], "methodName": ["createEngineFromName"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "if    ( Boolean . FALSE . equals ( this . sharedEngine )  )     {", "Assert . state (  (  ( this . engineN )     !  =    null )  ,     \" No   engine   n   specified \"  )  ;", "return   createEngineFromN ( this . engineN )  ;", "} else    {", "Assert . state (  (  ( this . engine )     !  =    null )  ,     \" No   shared   engine   available \"  )  ;", "return   this . engine ;", "}", "}", "METHOD_END"], "methodName": ["getEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . resourceLoaderPaths )     !  =    null )     {", "for    ( String   path    :    this . resourceLoaderPaths )     {", "Resource   resource    =    obtainApplicationContext (  )  . getResource (  ( path    +    location )  )  ;", "if    ( resource . exists (  )  )     {", "return   resource ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    getResource ( path )  ;", "if    ( resource    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \"    resource    [  \"     +    path )     +     \"  ]    not   found \"  )  )  ;", "}", "InputStreamReader   reader    =    new   InputStreamReader ( resource . getInputStream (  )  ,    getDefaultCharset (  )  )  ;", "return   FileCopyUtils . copyToString ( reader )  ;", "}", "METHOD_END"], "methodName": ["getTemplate"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . isEmpty ( this . scripts )  )  )     {", "for    ( String   script    :    this . scripts )     {", "Resource   resource    =    getResource ( script )  ;", "if    ( resource    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" Script   resource    [  \"     +    script )     +     \"  ]    not   found \"  )  )  ;", "}", "try    {", "engine . eval ( new   InputStreamReader ( resource . getInputStream (  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  (  \" Failed   to   evaluate   script    [  \"     +    script )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["loadScripts"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "this . engine    =    engine ;", "}", "METHOD_END"], "methodName": ["setEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "this . engineName    =    engineName ;", "}", "METHOD_END"], "methodName": ["setEngineName"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "this . renderFunction    =    functionName ;", "}", "METHOD_END"], "methodName": ["setRenderFunction"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "this . renderObject    =    renderObject ;", "}", "METHOD_END"], "methodName": ["setRenderObject"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "String [  ]    paths    =    StringUtils . commaDelimitedListToStringArray ( resourceLoaderPath )  ;", "this . resourceLoaderPaths    =    new   String [  ( paths . length )     +     1  ]  ;", "this . resourceLoaderPaths [  0  ]     =     \"  \"  ;", "for    ( int   i    =     0  ;    i    <     ( paths . length )  ;    i +  +  )     {", "String   path    =    paths [ i ]  ;", "if    (  (  !  ( path . endsWith (  \"  /  \"  )  )  )     &  &     (  !  ( path . endsWith (  \"  :  \"  )  )  )  )     {", "path    =    path    +     \"  /  \"  ;", "}", "this . resourceLoaderPaths [  ( i    +     1  )  ]     =    path ;", "}", "}", "METHOD_END"], "methodName": ["setResourceLoaderPath"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "this . scripts    =    scripts ;", "}", "METHOD_END"], "methodName": ["setScripts"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "this . sharedEngine    =    sharedEngine ;", "}", "METHOD_END"], "methodName": ["setSharedEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateView"}, {"methodBody": ["METHOD_START", "{", "ScriptTemplateViewResolver   resolver    =    new   ScriptTemplateViewResolver (  )  ;", "Assert . assertEquals ( ScriptTemplateView . class ,    resolver . requiredViewClass (  )  )  ;", "DirectFieldAccessor   viewAccessor    =    new   DirectFieldAccessor ( resolver )  ;", "Class <  ?  >    viewClass    =     (  ( Class <  ?  >  )     ( viewAccessor . getPropertyValue (  \" viewClass \"  )  )  )  ;", "Assert . assertEquals ( ScriptTemplateView . class ,    viewClass )  ;", "}", "METHOD_END"], "methodName": ["viewClass"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewResolverTests"}, {"methodBody": ["METHOD_START", "{", "ScriptEngine   engine    =    mock ( ScriptTemplateViewTests . InvocableScriptEngine . class )  ;", "given ( engine . get (  \" key \"  )  )  . willReturn (  \" value \"  )  ;", "this . view . setEngine ( engine )  ;", "this . view . setRenderFunction (  \" render \"  )  ;", "this . view . setApplicationContext ( this . context )  ;", "engine    =    this . view . getEngine (  )  ;", "assertNotNull ( engine )  ;", "assertEquals (  \" value \"  ,    engine . get (  \" key \"  )  )  ;", "DirectFieldAccessor   accessor    =    new   DirectFieldAccessor ( this . view )  ;", "assertNull ( accessor . getPropertyValue (  \" renderObject \"  )  )  ;", "assertEquals (  \" render \"  ,    accessor . getPropertyValue (  \" renderFunction \"  )  )  ;", "assertEquals ( StandardCharsets . UTF _  8  ,    accessor . getPropertyValue (  \" defaultCharset \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customEngineAndRenderFunction"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "ScriptTemplateViewTests . InvocableScriptEngine   engine    =    mock ( ScriptTemplateViewTests . InvocableScriptEngine . class )  ;", "this . configurer . setEngine ( engine )  ;", "this . configurer . setRenderObject (  \" Template \"  )  ;", "this . configurer . setRenderFunction (  \" render \"  )  ;", "this . configurer . setCharset ( StandardCharsets . ISO _  8  8  5  9  _  1  )  ;", "this . configurer . setSharedEngine ( true )  ;", "DirectFieldAccessor   accessor    =    new   DirectFieldAccessor ( this . view )  ;", "this . view . setApplicationContext ( this . context )  ;", "assertEquals ( engine ,    accessor . getPropertyValue (  \" engine \"  )  )  ;", "assertEquals (  \" Template \"  ,    accessor . getPropertyValue (  \" renderObject \"  )  )  ;", "assertEquals (  \" render \"  ,    accessor . getPropertyValue (  \" renderFunction \"  )  )  ;", "assertEquals ( StandardCharsets . ISO _  8  8  5  9  _  1  ,    accessor . getPropertyValue (  \" defaultCharset \"  )  )  ;", "assertEquals ( true ,    accessor . getPropertyValue (  \" sharedEngine \"  )  )  ;", "}", "METHOD_END"], "methodName": ["detectScriptTemplateConfigWithEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "this . configurer . setEngineName (  \" nashorn \"  )  ;", "this . configurer . setRenderObject (  \"  \"  )  ;", "this . configurer . setRenderFunction (  \" render \"  )  ;", "DirectFieldAccessor   accessor    =    new   DirectFieldAccessor ( this . view )  ;", "this . view . setApplicationContext ( this . context )  ;", "assertEquals (  \" nashorn \"  ,    accessor . getPropertyValue (  \" engineName \"  )  )  ;", "assertNotNull ( accessor . getPropertyValue (  \" engine \"  )  )  ;", "assertEquals (  \"  \"  ,    accessor . getPropertyValue (  \" renderObject \"  )  )  ;", "assertEquals (  \" render \"  ,    accessor . getPropertyValue (  \" renderFunction \"  )  )  ;", "assertEquals ( StandardCharsets . UTF _  8  ,    accessor . getPropertyValue (  \" defaultCharset \"  )  )  ;", "}", "METHOD_END"], "methodName": ["detectScriptTemplateConfigWithEngineName"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view . setEngine ( mock ( ScriptTemplateViewTests . InvocableScriptEngine . class )  )  ;", "this . view . setEngineName (  \" test \"  )  ;", "this . view . setRenderFunction (  \" render \"  )  ;", "this . expectedException . expect ( IllegalArgumentException . class )  ;", "this . view . setApplicationContext ( this . context )  ;", "this . expectedException . expectMessage ( contains (  \"  ' engine '    or    ' engineName '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["engineAndEngineNameBothDefined"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view . setEngine ( mock ( ScriptTemplateViewTests . InvocableScriptEngine . class )  )  ;", "this . view . setRenderFunction (  \" render \"  )  ;", "this . view . setSharedEngine ( false )  ;", "this . expectedException . expect ( IllegalArgumentException . class )  ;", "this . view . setApplicationContext ( this . context )  ;", "this . expectedException . expectMessage ( contains (  \" sharedEngine \"  )  )  ;", "}", "METHOD_END"], "methodName": ["engineSetterAndNonSharedEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "this . expectedException . expect ( ApplicationContextException . class )  ;", "this . view . setApplicationContext ( new   StaticApplicationContext (  )  )  ;", "this . expectedException . expectMessage ( contains (  \" Config \"  )  )  ;", "}", "METHOD_END"], "methodName": ["missingScriptTemplateConfig"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "this . context . refresh (  )  ;", "this . view . setResourceLoaderPath (  \" classpath : org / springframework / web / reactive / result / view / script /  \"  )  ;", "this . view . setUrl (  \" missing . txt \"  )  ;", "this . view . setEngine ( mock (  . InvocableScriptEngine . class )  )  ;", "this . configurer . setRenderFunction (  \" render \"  )  ;", "this . view . setApplicationContext ( this . context )  ;", "assertFalse ( this . view . checkResourceExists ( Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["missingTemplate"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view . setEngine ( mock ( ScriptEngine . class )  )  ;", "this . view . setApplicationContext ( this . context )  ;", "}", "METHOD_END"], "methodName": ["nonInvocableScriptEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "this . view . setEngine ( mock ( ScriptEngine . class )  )  ;", "this . view . setRenderFunction (  \" render \"  )  ;", "this . expectedException . expect ( IllegalArgumentException . class )  ;", "this . view . setApplicationContext ( this . context )  ;", "}", "METHOD_END"], "methodName": ["nonInvocableScriptEngineWithRenderFunction"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "int   iterations    =     2  0  ;", "thisetEngineName (  \" nashorn \"  )  ;", "thisetRenderFunction (  \" render \"  )  ;", "thisetSharedEngine ( false )  ;", "thisetApplicationContext ( this . context )  ;", "ExecutorService   executor    =    Executors . newFixedThreadPool (  4  )  ;", "List < Future < Boolean >  >    results    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <    iterations ;    i +  +  )     {", "results . add ( executor . submit (  (  )     -  >     ( view . getEngine (  )  )     !  =    null )  )  ;", "}", "assertEquals ( iterations ,    results . size (  )  )  ;", "for    ( int   i    =     0  ;    i    <    iterations ;    i +  +  )     {", "assertTrue ( results . get ( i )  . get (  )  )  ;", "}", "executor . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["nonSharedEngine"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "this . configurer    =    new   ScriptTemplateConfigurer (  )  ;", "this . context    =    new   StaticApplicationContext (  )  ;", "this . context . getBeanFactory (  )  . registerSingleton (  \" scriptTemplateConfigurer \"  ,    this . configurer )  ;", "this . view    =    new    (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.result.view.script.ScriptTemplateViewTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketClient [  ]    clients    =    new   WebSocketClient [  ]  {    new   TomcatWebSocketClient (  )  ,    new   JettyWebSocketClient (  )  ,    new   ReactorNettyWebSocketClient (  )  ,    new   UndertowWebSocketClient ( Xnio . getInstance (  )  . createWorker ( EMPTY )  )     }  ;", "Map < HttpServer ,    Class <  ?  >  >    servers    =    new   LinkedHashMap <  >  (  )  ;", "servers . put ( new   TomcatHttpServer (  . TMP _ DIR . getAbsolutePath (  )  ,    WsContextListener . class )  ,     . TomcatConfig . class )  ;", "servers . put ( new   JettyHttpServer (  )  ,     . JettyConfig . class )  ;", "servers . put ( new   ReactorHttpServer (  )  ,     . ReactorNettyConfig . class )  ;", "servers . put ( new   UndertowHttpServer (  )  ,     . UndertowConfig . class )  ;", "Flux < WebSocketClient >    f 1     =    Flux . fromArray ( clients )  . concatMap (  (    c )     -  >    Flux . just ( c )  . repeat ( servers . size (  )  )  )  ;", "Flux < HttpServer >    f 2     =    Flux . fromIterable ( servers . keySet (  )  )  . repeat ( clients . length )  ;", "Flux < Class <  ?  >  >    f 3     =    Flux . fromIterable ( servers . values (  )  )  . repeat ( clients . length )  ;", "return   Flux . zip ( f 1  ,    f 2  ,    f 3  )  . map ( Tuple 3  :  : toArray )  . collectList (  )  . block (  )  . toArray ( new   Object [  ( clients . length )     *     ( servers . size (  )  )  ]  [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["arguments"], "fileName": "org.springframework.web.reactive.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . register (  . DispatcherConfig . class ,    this . serverConfigClass )  ;", "context . register ( getWebConfigClass (  )  )  ;", "context . refresh (  )  ;", "return   WebHttpHandlerBuilder . applicationContext ( context )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createHttpHandler"], "fileName": "org.springframework.web.reactive.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   URI (  (  (  \" ws :  /  / localhost :  \"     +     ( this . port )  )     +    path )  )  ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.springframework.web.reactive.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . server . setHandler ( createHttpHandler (  )  )  ;", "this . server . afterPropertiesSet (  )  ;", "this . server . start (  )  ;", "this . port    =    this . server . getPort (  )  ;", "if    (  ( this . client )    instanceof   Lifecycle )     {", "(  ( Lifecycle )     ( this . client )  )  . start (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.reactive.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . client )    instanceof   Lifecycle )     {", "(  ( Lifecycle )     ( this . client )  )  . stop (  )  ;", "}", "this . server . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.springframework.web.reactive.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this . code )     =  =     ( other . code )  ;", "}", "METHOD_END"], "methodName": ["equalsCode"], "fileName": "org.springframework.web.reactive.socket.CloseStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . code ;", "}", "METHOD_END"], "methodName": ["getCode"], "fileName": "org.springframework.web.reactive.socket.CloseStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . reason ;", "}", "METHOD_END"], "methodName": ["getReason"], "fileName": "org.springframework.web.reactive.socket.CloseStatus"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( reason ,     \" Reason   must   not   be   empty \"  )  ;", "return   new    ( this . code ,    reason )  ;", "}", "METHOD_END"], "methodName": ["withReason"], "fileName": "org.springframework.web.reactive.socket.CloseStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.web.reactive.socket.HandshakeInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . principalMono ;", "}", "METHOD_END"], "methodName": ["getPrincipal"], "fileName": "org.springframework.web.reactive.socket.HandshakeInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . protocol ;", "}", "METHOD_END"], "methodName": ["getSubProtocol"], "fileName": "org.springframework.web.reactive.socket.HandshakeInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . uri ;", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.springframework.web.reactive.socket.HandshakeInfo"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getSubProtocols"], "fileName": "org.springframework.web.reactive.socket.WebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . add (  \" my - header \"  ,     \" my - value \"  )  ;", "MonoProcessor < Object >    output    =    MonoProcessor . create (  )  ;", "this . client . execute ( getUrl (  \"  / custom - header \"  )  ,    headers ,     (    session )     -  >    session . receive (  )  . map ( Message :  : getPayloadAsText )  . subscribeWith ( output )  . then (  )  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals (  \" my - header : my - value \"  ,    output . block ( Duration . ofMillis (  5  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["customHeader"], "fileName": "org.springframework.web.reactive.socket.WebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "int   count    =     1  0  0  ;", "Flux < String >    input    =    Flux . range (  1  ,    count )  . map (  (    index )     -  >     \" msg -  \"     +    index )  ;", "ReplayProcessor < Object >    output    =    ReplayProcessor . create ( count )  ;", "this . client . execute ( getUrl (  \"  / echo \"  )  ,     (    session )     -  >     {", ". logger . debug (  \" Starting   to   send   messages \"  )  ;", "return   session . send ( input . doOnNext (  (    s )     -  >     . logger . debug (  (  \" outbound    \"     +    s )  )  )  . map ( session :  : textMessage )  )  . thenMany ( session . receive (  )  . take ( count )  . map ( WebSocketMessage :  : getPayloadAsText )  )  . subscribeWith ( output )  . doOnNext (  (    s )     -  >     . logger . debug (  (  \" inbound    \"     +    s )  )  )  . then (  )  . doOnSuccessOrError (  (    aVoid ,    ex )     -  >     . logger . debug (  (  \" Done   with    \"     +     ( ex    !  =    null    ?    ex . getMessage (  )     :     \" success \"  )  )  )  )  ;", "}  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "assertEquals ( input . collectList (  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ,    output . collectList (  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["echo"], "fileName": "org.springframework.web.reactive.socket.WebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   protocol    =     \" echo - v 1  \"  ;", "AtomicReference < HandshakeInfo >    infoRef    =    new   AtomicReference <  >  (  )  ;", "MonoProcessor < Object >    output    =    MonoProcessor . create (  )  ;", "this . client . execute ( getUrl (  \"  / sub - protocol \"  )  ,    new   Handler (  )     {", "@ Override", "public   List < String >    getSubProtocols (  )     {", "return   Collections . singletonList ( protocol )  ;", "}", "@ Override", "public   Mono < Void >    handle ( Session   session )     {", "infoRef . set ( session . getHandshakeInfo (  )  )  ;", "return   session . receive (  )  . map ( Message :  : getPayloadAsText )  . subscribeWith ( output )  . then (  )  ;", "}", "}  )  . block ( Duration . ofMillis (  5  0  0  0  )  )  ;", "HandshakeInfo   info    =    infoRef . get (  )  ;", "assertThat ( info . getHeaders (  )  . getFirst (  \" Upgrade \"  )  ,    Matchers . equalToIgnoringCase (  \" websocket \"  )  )  ;", "assertEquals ( protocol ,    info . getHeaders (  )  . getFirst (  \" Sec -  - Protocol \"  )  )  ;", "assertEquals (  \" Wrong   protocol   accepted \"  ,    protocol ,    info . getSubProtocol (  )  )  ;", "assertEquals (  \" Wrong   protocol   detected   on   the   server   side \"  ,    protocol ,    output . block ( Duration . ofMillis (  5  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["subProtocol"], "fileName": "org.springframework.web.reactive.socket.WebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . payload ;", "}", "METHOD_END"], "methodName": ["getPayload"], "fileName": "org.springframework.web.reactive.socket.WebSocketMessage"}, {"methodBody": ["METHOD_START", "{", "return   getPayloadAsText ( StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["getPayloadAsText"], "fileName": "org.springframework.web.reactive.socket.WebSocketMessage"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [ this . payload . readableByteCount (  )  ]  ;", "this . payload . read ( bytes )  ;", "return   new   String ( bytes ,    charset )  ;", "}", "METHOD_END"], "methodName": ["getPayloadAsText"], "fileName": "org.springframework.web.reactive.socket.WebSocketMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.web.reactive.socket.WebSocketMessage"}, {"methodBody": ["METHOD_START", "{", "DataBufferUtils . release ( this . payload )  ;", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.springframework.web.reactive.socket.WebSocketMessage"}, {"methodBody": ["METHOD_START", "{", "DataBufferUtils . retain ( this . payload )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["retain"], "fileName": "org.springframework.web.reactive.socket.WebSocketMessage"}, {"methodBody": ["METHOD_START", "{", "return   close ( CloseStatus . NORMAL )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.web.reactive.socket.WebSocketSession"}, {"methodBody": ["METHOD_START", "{", "AbstractListenerWebSocketSession < T >  . WebSocketSendProcessor   sendProcessor    =    this . sendProcessor ;", "Assert . state (  ( sendProcessor    !  =    null )  ,     \" No   WebSocketSendProcessor   available \"  )  ;", "return   sendProcessor ;", "}", "METHOD_END"], "methodName": ["getSendProcessor"], "fileName": "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . receivePublisher . onAllDataRead (  )  ;", "< T >  . WebSocketSendProcessor   sendProcessor    =    this . sendProcessor ;", "if    ( sendProcessor    !  =    null )     {", "sendProcessor . cancel (  )  ;", "sendProcessor . onComplete (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleClose"], "fileName": "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . receivePublisher . onError ( ex )  ;", "< T >  . WebSocketSendProcessor   sendProcessor    =    this . sendProcessor ;", "if    ( sendProcessor    !  =    null )     {", "sendProcessor . cancel (  )  ;", "sendProcessor . onError ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . receivePublisher . handleMessage ( message )  ;", "}", "METHOD_END"], "methodName": ["handleMessage"], "fileName": "org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.web.reactive.socket.adapter.AbstractWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . delegateSession )     !  =    null )     {", "ByteBuffer   buffer    =    ByteBuffer . wrap ( message ,    offset ,    length )  ;", "Message   webSocketMessage    =    toMessage ( Message . Type . BINARY ,    buffer )  ;", "delegateSession . handleMessage ( webSocketMessage . getType (  )  ,    webSocketMessage )  ;", "}", "}", "METHOD_END"], "methodName": ["onWebSocketBinary"], "fileName": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . delegateSession )     !  =    null )     {", "this . delegateSession . hClose ( new   CloseStatus ( statusCode ,    reason )  )  ;", "}", "}", "METHOD_END"], "methodName": ["onWebSocketClose"], "fileName": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . delegateSession    =    sessionFactory . apply ( session )  ;", "this . delegate . handle ( this . delegateSession )  . subscribe ( this . delegateSession )  ;", "}", "METHOD_END"], "methodName": ["onWebSocketConnect"], "fileName": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . delegateSession )     !  =    null )     {", "this . delegateSession . hError ( cause )  ;", "}", "}", "METHOD_END"], "methodName": ["onWebSocketError"], "fileName": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . delegateSession )     !  =    null )     {", "if    (  ( OpCode . PONG )     =  =     ( frame . getOpCode (  )  )  )     {", "ByteBuffer   buffer    =     (  ( frame . getPayload (  )  )     !  =    null )     ?    frame . getPayload (  )     :     . EMPTY _ PAYLOAD ;", "WebSocketMessage   webSocketMessage    =    toMessage ( WebSocketMessage . Type . PONG ,    buffer )  ;", "delegateSession . handleMessage ( webSocketMessage . getType (  )  ,    webSocketMessage )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["onWebSocketFrame"], "fileName": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . delegateSession )     !  =    null )     {", "Message   webSocketMessage    =    toMessage ( Message . Type . TEXT ,    message )  ;", "this . delegateSession . handleMessage ( webSocketMessage . getType (  )  ,    webSocketMessage )  ;", "}", "}", "METHOD_END"], "methodName": ["onWebSocketText"], "fileName": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "WebSocketSession   session    =    this . delegateSession ;", "Assert . state (  ( session    !  =    null )  ,     \" Cannot   create   message   without   a   session \"  )  ;", "if    ( WebSocketMessage . Type . TEXT . equals ( type )  )     {", "byte [  ]    bytes    =     (  ( String )     ( message )  )  . getBytes ( StandardCharsets . UTF _  8  )  ;", "DataBuffer   buffer    =    session . bufferFactory (  )  . wrap ( bytes )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . TEXT ,    buffer )  ;", "} else", "if    ( WebSocketMessage . Type . BINARY . equals ( type )  )     {", "DataBuffer   buffer    =    session . bufferFactory (  )  . wrap (  (  ( ByteBuffer )     ( message )  )  )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . BINARY ,    buffer )  ;", "} else", "if    ( WebSocketMessage . Type . PONG . equals ( type )  )     {", "DataBuffer   buffer    =    session . bufferFactory (  )  . wrap (  (  ( ByteBuffer )     ( message )  )  )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . PONG ,    buffer )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unexpected   message   type :     \"     +    message )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.web.reactive.socket.adapter.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "ByteBuf   byteBuf    =    NettyDataBufferFactory . toByteBuf ( message . getPayload (  )  )  ;", "if    ( WebSocketMessage . Type . TEXT . equals ( message . getType (  )  )  )     {", "return   new   io . netty . handler . codec . http . websocketx . TextWebSocketFrame ( byteBuf )  ;", "} else", "if    ( WebSocketMessage . Type . BINARY . equals ( message . getType (  )  )  )     {", "return   new   io . netty . handler . codec . http . websocketx . BinarFrame ( byteBuf )  ;", "} else", "if    ( WebSocketMessage . Type . PING . equals ( message . getType (  )  )  )     {", "return   new   io . netty . handler . codec . http . websocketx . PingWebSocketFrame ( byteBuf )  ;", "} else", "if    ( WebSocketMessage . Type . PONG . equals ( message . getType (  )  )  )     {", "return   new   io . netty . handler . codec . http . websocketx . PongWebSocketFrame ( byteBuf )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unexpected   message   type :     \"     +     ( message . getType (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toFrame"], "fileName": "org.springframework.web.reactive.socket.adapter.NettyWebSocketSessionSupport"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   payload    =    bufferFactory (  )  . wrap ( frame . content (  )  )  ;", "return   new   WebSocketMessage (  . MESSAGE _ TYPES . get ( frame . getClass (  )  )  ,    payload )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.web.reactive.socket.adapter.NettyWebSocketSessionSupport"}, {"methodBody": ["METHOD_START", "{", "WebSocketSession   session    =    this . delegateSession ;", "Assert . state (  ( session    !  =    null )  ,     \" Cannot   create   message   without   a   session \"  )  ;", "if    ( message   instanceof   String )     {", "byte [  ]    bytes    =     (  ( String )     ( message )  )  . getBytes ( StandardCharsets . UTF _  8  )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . TEXT ,    session . bufferFactory (  )  . wrap ( bytes )  )  ;", "} else", "if    ( message   instanceof   ByteBuffer )     {", "core . io . buffer . DataBuffer   buffer    =    session . bufferFactory (  )  . wrap (  (  ( ByteBuffer )     ( message )  )  )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . BINARY ,    buffer )  ;", "} else", "if    ( message   instanceof   PongMessage )     {", "core . io . buffer . DataBuffer   buffer    =    session . bufferFactory (  )  . wrap (  (  ( PongMessage )     ( message )  )  . getApplicationData (  )  )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . PONG ,    buffer )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unexpected   message   type :     \"     +    message )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.web.reactive.socket.adapter.StandardWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    ( WebSocketMessage . Type . TEXT . equals ( type )  )     {", "byte [  ]    bytes    =     (  ( String )     ( message )  )  . getBytes ( StandardCharsets . UTF _  8  )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . TEXT ,    session . bufferFactory (  )  . wrap ( bytes )  )  ;", "} else", "if    ( WebSocketMessage . Type . BINARY . equals ( type )  )     {", "core . io . buffer . DataBuffer   buffer    =    session . bufferFactory (  )  . allocateBuffer (  )  . write (  (  ( ByteBuffer [  ]  )     ( message )  )  )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . BINARY ,    buffer )  ;", "} else", "if    ( WebSocketMessage . Type . PONG . equals ( type )  )     {", "core . io . buffer . DataBuffer   buffer    =    session . bufferFactory (  )  . allocateBuffer (  )  . write (  (  ( ByteBuffer [  ]  )     ( message )  )  )  ;", "return   new   WebSocketMessage ( WebSocketMessage . Type . PONG ,    buffer )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unexpected   message   type :     \"     +    message )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.web.reactive.socket.adapter.UndertowWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   JettyWebSocketHandlerAdapter ( handler ,     (    session )     -  >     {", "UpgradeResponse   response    =    session . getUpgradeResponse (  )  ;", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "response . getHeaders (  )  . forEach ( responseHeaders :  : put )  ;", "HandshakeInfo   info    =    afterHandshake ( url ,    responseHeaders )  ;", "return   new   JettyWebSocketSession ( session ,    info ,    this . bufferFactory ,    completion )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["createJettyHandler"], "fileName": "org.springframework.web.reactive.socket.client.JettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "MonoProcessor < Void >    completionMono    =    MonoProcessor . create (  )  ;", "return   Mono . fromCallable (  (  )     -  >     {", "List < String >    protocols    =    beforeHandshake ( url ,    headers ,    handler )  ;", "UpgradeRequest   upgradeRequest    =    new   UpgradeRequest (  )  ;", "upgradeRequest . setSubProtocols ( protocols )  ;", "Object   jettyHandler    =    createJettyHandler ( url ,    handler ,    completionMono )  ;", "UpgradeListener   upgradeListener    =    new   DefaultUpgradeListener ( headers )  ;", "return   this . jetty . connect ( jettyHandler ,    url ,    upgradeRequest ,    upgradeListener )  ;", "}  )  . then ( completionMono )  ;", "}", "METHOD_END"], "methodName": ["executeInternal"], "fileName": "org.springframework.web.reactive.socket.client.JettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . jettyClient ;", "}", "METHOD_END"], "methodName": ["getJettyClient"], "fileName": "org.springframework.web.reactive.socket.client.JettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . httpClient ;", "}", "METHOD_END"], "methodName": ["getHttpClient"], "fileName": "org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "headers . forEach ( nettyHeaders :  : set )  ;", "}", "METHOD_END"], "methodName": ["setNettyHeaders"], "fileName": "org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "response . responseHeaders (  )  . forEach (  (    entry )     -  >     {", "St   name    =    entry . getKey (  )  ;", "headers . put ( name ,    response . responseHeaders (  )  . getAll ( name )  )  ;", "}  )  ;", "return   headers ;", "}", "METHOD_END"], "methodName": ["toHttpHeaders"], "fileName": "org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . bufferFactory ;", "}", "METHOD_END"], "methodName": ["bufferFactory"], "fileName": "org.springframework.web.reactive.socket.client.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardWebSocketHandlerAdapter ( handler ,     (    session )     -  >     {", "HttpHeaders   responseHeaders    =    configurator . getResponseHeaders (  )  ;", "HandshakeInfo   info    =    afterHandshake ( url ,    responseHeaders )  ;", "return   createWebSocketSession ( session ,    info ,    completion )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["createEndpoint"], "fileName": "org.springframework.web.reactive.socket.client.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   ClientEndpointConfig . Builder . create (  )  . configurator ( configurator )  . preferredSubprotocols ( subProtocols )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createEndpointConfig"], "fileName": "org.springframework.web.reactive.socket.client.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardWebSocketSession ( session ,    info ,    this . bufferFactory ,    completion )  ;", "}", "METHOD_END"], "methodName": ["createWebSocketSession"], "fileName": "org.springframework.web.reactive.socket.client.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "MonoProcessor < Void >    completionMono    =    MonoProcessor . create (  )  ;", "return   Mono . fromCallable (  (  )     -  >     {", "List < String >    protocols    =    beforeHandshake ( url ,    requestHeaders ,    handler )  ;", "DefaultConfigurator   configurator    =    new   DefaultConfigurator ( requestHeaders )  ;", "Endpoint   endpoint    =    createEndpoint ( url ,    handler ,    completionMono ,    configurator )  ;", "ClientEndpointConfig   config    =    createEndpointConfig ( configurator ,    protocols )  ;", "return   this . wontainer . connectToServer ( endpoint ,    config ,    url )  ;", "}  )  . subscribeOn ( Schedulers . elastic (  )  )  . then ( completionMono )  ;", "}", "METHOD_END"], "methodName": ["executeInternal"], "fileName": "org.springframework.web.reactive.socket.client.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketContainer ;", "}", "METHOD_END"], "methodName": ["getWebSocketContainer"], "fileName": "org.springframework.web.reactive.socket.client.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "ConnectionBuilder   builder    =    WebSocketClient . connectionBuilder ( getXnioWorker (  )  ,    new   DefaultByteBufferPool ( false ,    getPoolBufferSize (  )  )  ,    url )  ;", "this . builderConsumer . accept ( builder )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["createConnectionBuilder"], "fileName": "org.springframework.web.reactive.socket.client.UndertowWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "MonoProcessor < Void >    completion    =    MonoProcessor . create (  )  ;", "return   Mono . fromCallable (  (  )     -  >     {", "ConnectionBuilder   builder    =    createConnectionBuilder ( url )  ;", "List < String >    protocols    =    beforeHandshake ( url ,    headers ,    handler )  ;", "DefaultNegotiation   negotiation    =    new   DefaultNegotiation ( protocols ,    headers ,    builder )  ;", "builder . setClientNegotiation ( negotiation )  ;", "return   builder . connect (  )  . addNotifier ( new   HandlingNotifier < hannel ,    Object >  (  )     {", "@ Override", "public   void   handleDone ( hannel   channel ,    Object   attachment )     {", "handleChannel ( url ,    handler ,    completion ,    negotiation ,    channel )  ;", "}", "@ Override", "public   void   handleFailed ( IOException   ex ,    Object   attachment )     {", "completion . onError ( new   IllegalStateException (  \" Failed   to   connect \"  ,    ex )  )  ;", "}", "}  ,    null )  ;", "}  )  . then ( completion )  ;", "}", "METHOD_END"], "methodName": ["executeInternal"], "fileName": "org.springframework.web.reactive.socket.client.UndertowWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . builderConsumer ;", "}", "METHOD_END"], "methodName": ["getConnectionBuilderConsumer"], "fileName": "org.springframework.web.reactive.socket.client.UndertowWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . poolBufferSize ;", "}", "METHOD_END"], "methodName": ["getPoolBufferSize"], "fileName": "org.springframework.web.reactive.socket.client.UndertowWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . worker ;", "}", "METHOD_END"], "methodName": ["getXnioWorker"], "fileName": "org.springframework.web.reactive.socket.client.UndertowWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "HandshakeInfo   info    =    afterHandshake ( url ,    negotiation . getResponseHeaders (  )  )  ;", "Session   session    =    new   Session ( channel ,    info ,    bufferFactory ,    completion )  ;", "HandlerAdapter   adapter    =    new   HandlerAdapter ( session )  ;", "channel . getReceiveSetter (  )  . set ( adapter )  ;", "channel . resumeReceives (  )  ;", "handler . handle ( session )  . subscribe ( session )  ;", "}", "METHOD_END"], "methodName": ["handleChannel"], "fileName": "org.springframework.web.reactive.socket.client.UndertowWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "this . poolBufferSize    =    poolBufferSize ;", "}", "METHOD_END"], "methodName": ["setPoolBufferSize"], "fileName": "org.springframework.web.reactive.socket.client.UndertowWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Handshake   response :     \"     +    url )     +     \"  ,     \"  )     +    responseHeaders )  )  ;", "}", "String   protocol    =    responseHeaders . getFirst (  . SEC _ WEBSOCKET _ PROTOCOL )  ;", "return   new   HandshakeInfo ( url ,    responseHeaders ,    Mono . empty (  )  ,    protocol )  ;", "}", "METHOD_END"], "methodName": ["afterHandshake"], "fileName": "org.springframework.web.reactive.socket.client.WebSocketClientSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Execut   handshake   to    \"     +    url )  )  ;", "}", "return   handler . getSubProtocols (  )  ;", "}", "METHOD_END"], "methodName": ["beforeHandshake"], "fileName": "org.springframework.web.reactive.socket.client.WebSocketClientSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getUpgradeStrategy (  )  )    instanceof   Lifecycle )     {", "(  ( Lifecycle )     ( getUpgradeStrategy (  )  )  )  . start (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doStart"], "fileName": "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getUpgradeStrategy (  )  )    instanceof   Lifecycle )     {", "(  ( Lifecycle )     ( getUpgradeStrategy (  )  )  )  . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doStop"], "fileName": "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService"}, {"methodBody": ["METHOD_START", "{", "return   this . upgradeStrategy ;", "}", "METHOD_END"], "methodName": ["getUpgradeStrategy"], "fileName": "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService"}, {"methodBody": ["METHOD_START", "{", "if    ( HandshakeWebSocketService . logger . isDebugEnabled (  )  )     {", "HandshakeWebSocketService . logger . debug ( reason )  ;", "}", "return   Mono . error ( new   ServerWebInputException ( reason )  )  ;", "}", "METHOD_END"], "methodName": ["handleBadRequest"], "fileName": "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService"}, {"methodBody": ["METHOD_START", "{", "String   className ;", "if    ( HandshakeWebSocketService . tomcatPresent )     {", "className    =     \" TomcatRequestUpgradeStrategy \"  ;", "} else", "if    ( HandshakeWebSocketService . jettyPresent )     {", "className    =     \" JettyRequestUpgradeStrategy \"  ;", "} else", "if    ( HandshakeWebSocketService . undertowPresent )     {", "className    =     \" UndertowRequestUpgradeStrategy \"  ;", "} else", "if    ( HandshakeWebSocketService . reactorNettyPresent )     {", "className    =     \" ReactorNettyRequestUpgradeStrategy \"  ;", "} else    {", "throw   new   IllegalStateException (  \" No   suitable   default   RequestUpgradeStrategy   found \"  )  ;", "}", "try    {", "className    =     \" upgrade .  \"     +    className ;", "Class <  ?  >    clazz    =    ClassUtils . forName ( className ,    HandshakeWebSocketService . class . getClassLoader (  )  )  ;", "return    (  ( RequestUpgradeStrategy )     ( ReflectionUtils . accessibleConstructor ( clazz )  . newInstance (  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  \" Failed   to   instantiate   RequestUpgradeStrategy :     \"     +    className )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["initUpgradeStrategy"], "fileName": "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService"}, {"methodBody": ["METHOD_START", "{", "String   protocolHeader    =    headers . getFirst ( HandshakeWebSocketService . SEC _ WEBSOCKET _ PROTOCOL )  ;", "if    ( protocolHeader    !  =    null )     {", "List < String >    supportedProtocols    =    handler . getSubProtocols (  )  ;", "for    ( String   protocol    :    StringUtils . commaDelimitedListToStringArray ( protocolHeader )  )     {", "if    ( supportedProtocols . contains ( protocol )  )     {", "return   protocol ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["selectProtocol"], "fileName": "org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketService ;", "}", "METHOD_END"], "methodName": ["getWebSocketService"], "fileName": "org.springframework.web.reactive.socket.server.support.WebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . protocols    =    protocols ;", "}", "METHOD_END"], "methodName": ["setSubprotocols"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.DefaultServerEndpointConfig"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    exchange . getRequest (  )  ;", "Mono < Principal >    principal    =    exchange . getPrincipal (  )  ;", "return   new   HandshakeInfo ( request . getURI (  )  ,    request . getHeaders (  )  ,    principal ,    protocol )  ;", "}", "METHOD_END"], "methodName": ["getHandshakeInfo"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.JettyRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( AbstractServerHttpRequest . class ,    request )  ;", "return    (  ( AbstractServerHttpRequest )     ( request )  )  . getNativeRequest (  )  ;", "}", "METHOD_END"], "methodName": ["getHttpServletRequest"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.JettyRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( AbstractServerHttpResponse . class ,    response )  ;", "return    (  ( AbstractServerHttpResponse )     ( response )  )  . getNativeResponse (  )  ;", "}", "METHOD_END"], "methodName": ["getHttpServletResponse"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.JettyRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   webSocketPolicy ;", "}", "METHOD_END"], "methodName": ["getWebSocketPolicy"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.JettyRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "this . webSocketPolicy    =    webSocketPolicy ;", "}", "METHOD_END"], "methodName": ["setWebSocketPolicy"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.JettyRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . servletContext )     !  =    null )     {", "return ;", "}", "synchronized ( this . lifecycleMonitor )     {", "if    (  ( this . servletContext )     =  =    null )     {", "this . servletContext    =    r . getServletContext (  )  ;", "start (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["startLazily"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.JettyRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    exchange . getRequest (  )  ;", "Mono < Principal >    principal    =    exchange . getPrincipal (  )  ;", "return   new   HandshakeInfo ( request . getURI (  )  ,    request . getHeaders (  )  ,    principal ,    protocol )  ;", "}", "METHOD_END"], "methodName": ["getHandshakeInfo"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   this . asyncSendTimeout ;", "}", "METHOD_END"], "methodName": ["getAsyncSendTimeout"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . serverContainer )     =  =    null )     {", "Object   container    =    request . getServletContext (  )  . getAttribute (  . SERVER _ CONTAINER _ ATTR )  ;", "Assert . state (  ( container   instanceof   WsServerContainer )  ,     \" ServletContext   attribute    ' ServerContainer '    not   found .  \"  )  ;", "this . serverContainer    =     (  ( WsServerContainer )     ( container )  )  ;", "initServerContainer ( this . serverContainer )  ;", "}", "return   this . serverContainer ;", "}", "METHOD_END"], "methodName": ["getContainer"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "ServerHttpRequest   request    =    exchange . getRequest (  )  ;", "Mono < Principal >    principal    =    exchange . getPrincipal (  )  ;", "return   new   HandshakeInfo ( request . getURI (  )  ,    request . getHeaders (  )  ,    principal ,    protocol )  ;", "}", "METHOD_END"], "methodName": ["getHandshakeInfo"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( AbstractServerHttpRequest . class ,    request ,     \" ServletServerHttpRequest   required \"  )  ;", "return    (  ( AbstractServerHttpRequest )     ( request )  )  . getNativeRequest (  )  ;", "}", "METHOD_END"], "methodName": ["getHttpServletRequest"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( AbstractServerHttpResponse . class ,    response ,     \" ServletServerHttpResponse   required \"  )  ;", "return    (  ( AbstractServerHttpResponse )     ( response )  )  . getNativeResponse (  )  ;", "}", "METHOD_END"], "methodName": ["getHttpServletResponse"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   this . maxBinaryMessageBufferSize ;", "}", "METHOD_END"], "methodName": ["getMaxBinaryMessageBufferSize"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   this . maxSessionIdleTimeout ;", "}", "METHOD_END"], "methodName": ["getMaxSessionIdleTimeout"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   this . maxTextMessageBufferSize ;", "}", "METHOD_END"], "methodName": ["getMaxTextMessageBufferSize"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . asyncSendTimeout )     !  =    null )     {", "Container . setAsyncSendTimeout ( this . asyncSendTimeout )  ;", "}", "if    (  ( this . maxSessionIdleTimeout )     !  =    null )     {", "Container . setDefaultMaxSessionIdleTimeout ( this . maxSessionIdleTimeout )  ;", "}", "if    (  ( this . maxTextMessageBufferSize )     !  =    null )     {", "Container . setDefaultMaxTextMessageBufferSize ( this . maxTextMessageBufferSize )  ;", "}", "if    (  ( this . maxBinaryMessageBufferSize )     !  =    null )     {", "Container . setDefaultMaxBinaryMessageBufferSize ( this . maxBinaryMessageBufferSize )  ;", "}", "}", "METHOD_END"], "methodName": ["initServerContainer"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "this . asyncSendTimeout    =    timeoutInMillis ;", "}", "METHOD_END"], "methodName": ["setAsyncSendTimeout"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "this . maxBinaryMessageBufferSize    =    bufferSize ;", "}", "METHOD_END"], "methodName": ["setMaxBinaryMessageBufferSize"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "this . maxSessionIdleTimeout    =    timeoutInMillis ;", "}", "METHOD_END"], "methodName": ["setMaxSessionIdleTimeout"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "this . maxTextMessageBufferSize    =    bufferSize ;", "}", "METHOD_END"], "methodName": ["setMaxTextMessageBufferSize"], "fileName": "org.springframework.web.reactive.socket.server.upgrade.TomcatRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   new   DispatcherHandler ( applicationContext )  ;", "}", "METHOD_END"], "methodName": ["createDispatcherHandler"], "fileName": "org.springframework.web.reactive.support.AbstractDispatcherHandlerInitializer"}, {"methodBody": ["METHOD_START", "{", "HttpHandler   httpHandler    =    new   HttpWebHandlerAdapter ( webHandler )  ;", "return   new   ServletHttpHandlerAdapter ( httpHandler )  ;", "}", "METHOD_END"], "methodName": ["createHandlerAdapter"], "fileName": "org.springframework.web.reactive.support.AbstractDispatcherHandlerInitializer"}, {"methodBody": ["METHOD_START", "{", "return   AbstractDispatcherHandlerInitializer . DEFAULT _ SERVLET _ MAPPING ;", "}", "METHOD_END"], "methodName": ["getServletMapping"], "fileName": "org.springframework.web.reactive.support.AbstractDispatcherHandlerInitializer"}, {"methodBody": ["METHOD_START", "{", "return   AbstractDispatcherHandlerInitializer . DEFAULT _ SERVLET _ NAME ;", "}", "METHOD_END"], "methodName": ["getServletName"], "fileName": "org.springframework.web.reactive.support.AbstractDispatcherHandlerInitializer"}, {"methodBody": ["METHOD_START", "{", "if    ( context   instanceof   ConfigurableApplicationContext )     {", "ConfigurableApplicationContext   cac    =     (  ( ConfigurableApplicationContext )     ( context )  )  ;", "if    (  !  ( cac . isA (  )  )  )     {", "cac . refresh (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["refreshApplicationContext"], "fileName": "org.springframework.web.reactive.support.AbstractDispatcherHandlerInitializer"}, {"methodBody": ["METHOD_START", "{", "if    ( applicationContext   instanceof   ConfigurableApplicationContext )     {", "ConfigurableApplicationContext   context    =     (  ( ConfigurableApplicationContext )     ( applicationContext )  )  ;", ". ServletContextDestroyedListener   listener    =    new    . ServletContextDestroyedListener ( context )  ;", "servletContext . addListener ( listener )  ;", "}", "}", "METHOD_END"], "methodName": ["registerCloseListener"], "fileName": "org.springframework.web.reactive.support.AbstractDispatcherHandlerInitializer"}, {"methodBody": ["METHOD_START", "{", "String   servletName    =    getServletName (  )  ;", "Assert . hasLength ( servletName ,     \" getServletName (  )    must   not   return   null   or   empty \"  )  ;", "ApplicationContext   applicationContext    =    createApplicationContext (  )  ;", "Assert . notNull ( applicationContext ,     \" createApplicationContext (  )    must   not   return   null \"  )  ;", "refreshApplicationContext ( applicationContext )  ;", "registerCloseListener ( servletContext ,    applicationContext )  ;", "WebHandler   dispatcherHandler    =    create ( applicationContext )  ;", "Assert . notNull ( dispatcherHandler ,     \" create ( ApplicationContext )    must   not   return   null \"  )  ;", "ServletHttpHandlerAdapter   handlerAdapter    =    createHandlerAdapter ( dispatcherHandler )  ;", "Assert . notNull ( handlerAdapter ,     \" createHandlerAdapter ( WebHandler )    must   not   return   null \"  )  ;", "ServletRegistration . Dynamic   registration    =    servletContext . addServlet ( servletName ,    handlerAdapter )  ;", "if    ( registration    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" Failed   to   register   servlet   with   name    '  \"     +    servletName )     +     \"  '  .     \"  )     +     \" Check   if   there   is   another   servlet   registered   under   the   same   name .  \"  )  )  ;", "}", "registration . setLoadOnStartup (  1  )  ;", "registration . addMapping ( getServletMapping (  )  )  ;", "registration . setAsyncSupported ( true )  ;", "customizeRegistration ( registration )  ;", "}", "METHOD_END"], "methodName": ["registerDispatcherHandler"], "fileName": "org.springframework.web.reactive.support.AbstractDispatcherHandlerInitializer"}, {"methodBody": ["METHOD_START", "{", "return   new   ServletHttpHandlerAdapter ( httpHandler )  ;", "}", "METHOD_END"], "methodName": ["createServlet"], "fileName": "org.springframework.web.reactive.support.AbstractServletHttpHandlerAdapterInitializer"}, {"methodBody": ["METHOD_START", "{", "return   AbstractServletHttpHandlerAdapterInitializer . DEFAULT _ SERVLET _ NAME ;", "}", "METHOD_END"], "methodName": ["getServletName"], "fileName": "org.springframework.web.reactive.support.AbstractServletHttpHandlerAdapterInitializer"}, {"methodBody": ["METHOD_START", "{", "String   servletName    =    getServletName (  )  ;", "Assert . hasLength ( servletName ,     \" getServletName (  )    must   not   return   null   or   empty \"  )  ;", "HttpHandler   httpHandler    =    createHttpHandler (  )  ;", "Assert . notNull ( httpHandler ,     \" createHttpHandler (  )    must   not   return   null \"  )  ;", "servlet    =    createServlet ( httpHandler )  ;", "Assert . notNull ( servlet ,     \" createServlet ( HttpHandler )    must   not   return   null \"  )  ;", "ServletRegistration . Dynamic   registration    =    servletContext . addServlet ( servletName ,    servlet )  ;", "if    ( registration    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" Failed   to   register   servlet   with   name    '  \"     +    servletName )     +     \"  '  .     \"  )     +     \" Check   if   there   is   another   servlet   registered   under   the   same   name .  \"  )  )  ;", "}", "registration . setLoadOnStartup (  1  )  ;", "registration . addMapping ( getServletMappings (  )  )  ;", "registration . setAsyncSupported ( true )  ;", "customizeRegistration ( registration )  ;", "}", "METHOD_END"], "methodName": ["registerHandlerAdapter"], "fileName": "org.springframework.web.reactive.support.AbstractServletHttpHandlerAdapterInitializer"}]