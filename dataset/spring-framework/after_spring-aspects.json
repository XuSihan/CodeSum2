[{"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  \" org / springframework / aop / aspectj / autoproxy / ajcAutoproxyTests . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["noAutoproxyingOfAjcCompiledAspects"], "fileName": "org.springframework.aop.aspectj.autoproxy.AutoProxyWithCodeStyleAspectsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.beans.factory.aspectj.ShouldBeConfiguredBySpring"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.beans.factory.aspectj.ShouldBeConfiguredBySpring"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  \" org / springframework / beans / factory / aspectj / springConfigured . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["springConfiguredAndAutoProxyUsedTogether"], "fileName": "org.springframework.beans.factory.aspectj.SpringConfiguredWithAutoProxyingTests"}, {"methodBody": ["METHOD_START", "{", "try    ( ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / beans / factory / aspectj / beanConfigurerTests . xml \"  )  )     {", "ShouldBeConfiguredBySpring   myObject    =    new   ShouldBeConfiguredBySpring (  )  ;", "assertEquals (  \" Rod \"  ,    myObject . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["injection"], "fileName": "org.springframework.beans.factory.aspectj.XmlBeanConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "throw    (  ( E )     ( e )  )  ;", "}", "METHOD_END"], "methodName": ["throwAny"], "fileName": "org.springframework.cache.aspectj.AnyThrow"}, {"methodBody": ["METHOD_START", "{", "AnyThrow .  < RuntimeException > throwAny ( e )  ;", "}", "METHOD_END"], "methodName": ["throwUnchecked"], "fileName": "org.springframework.cache.aspectj.AnyThrow"}, {"methodBody": ["METHOD_START", "{", "AnnotationCacheAspect   aspect    =    ctx . getBean (  \" internalCacheAspect \"  ,    AnnotationCacheAspect . class )  ;", "Assert . assertSame ( ctx . getBean (  \" keyGenerator \"  )  ,    aspect . getKeyGenerator (  )  )  ;", "}", "METHOD_END"], "methodName": ["testKeyStrategy"], "fileName": "org.springframework.cache.aspectj.AspectJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationCacheAspect   cacheAspect    =    AnnotationCacheAspect . aspectOf (  )  ;", "if    (  ( this . cacheResolver )     !  =    null )     {", "cacheAspect . setCacheResolver ( this . cacheResolver )  ;", "} else", "if    (  ( this . cacheManager )     !  =    null )     {", "cacheAspect . setCacheManager ( this . cacheManager )  ;", "}", "if    (  ( this . keyGenerator )     !  =    null )     {", "cacheAspect . setKeyGenerator ( this . keyGenerator )  ;", "}", "if    (  ( this . errorHandler )     !  =    null )     {", "cacheAspect . setErrorHandler ( this . errorHandler )  ;", "}", "return   cacheAspect ;", "}", "METHOD_END"], "methodName": ["cacheAspect"], "fileName": "org.springframework.cache.aspectj.AspectJCachingConfiguration"}, {"methodBody": ["METHOD_START", "{", "load ( AspectJEnableCachingIsolatedTests . FullCachingConfig . class )  ;", "AnnotationCacheAspect   aspect    =    this . ctx . getBean ( AnnotationCacheAspect . class )  ;", "assertSame ( this . ctx . getBean (  \" cacheResolver \"  )  ,    aspect . getCacheResolver (  )  )  ;", "assertSame ( this . ctx . getBean (  \" keyGenerator \"  )  ,    aspect . getKeyGenerator (  )  )  ;", "}", "METHOD_END"], "methodName": ["bothSetOnlyResolverIsUsed"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . ctx )     !  =    null )     {", "this . ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeContext"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "load ( AspectJEnableCachingIsolatedTests . EmptyConfigSupportConfig . class )  ;", "AnnotationCacheAspect   aspect    =    this . ctx . getBean ( AnnotationCacheAspect . class )  ;", "assertNotNull ( aspect . getCacheResolver (  )  )  ;", "assertEquals ( SimpleCacheResolver . class ,    aspect . getCacheResolver (  )  . getClass (  )  )  ;", "assertSame ( this . ctx . getBean ( CacheManager . class )  ,     (  ( SimpleCacheResolver )     ( aspect . getCacheResolver (  )  )  )  . getCacheManager (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyConfigSupport"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "this . ctx    =    new   AnnotationConfigApplicationContext ( config )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "load (  . MultiCacheManagerConfig . class )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" bean   of   type   CacheManager \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["multipleCacheManagerBeans"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "load ( AspectJEnableCachingIsolatedTests . MultiCacheManagerConfigurer . class )  ;", "}", "METHOD_END"], "methodName": ["multipleCacheManagerBeans_implementsCachingConfigurer"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "load (  . MultiCacheManagerConfigurer . class ,     . EnableCachingConfig . class )  ;", "}    catch    ( BeanCreationException   ex )     {", "Throwable   root    =    ex . getRootCause (  )  ;", "assertTrue (  ( root   instanceof   IllegalStateException )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" implementations   of   CachingConfigurer \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["multipleCachingConfigurers"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "load (  . EmptyConfig . class )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" No   bean   of   type   CacheManager \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["noCacheManagerBeans"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "load ( AspectJEnableCachingIsolatedTests . SingleCacheManagerConfig . class )  ;", "}", "METHOD_END"], "methodName": ["singleCacheManagerBean"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "load ( AspectJEnableCachingIsolatedTests . EnableCachingConfig . class )  ;", "AnnotationCacheAspect   aspect    =    this . ctx . getBean ( AnnotationCacheAspect . class )  ;", "assertSame ( this . ctx . getBean (  \" errorHandler \"  ,    CacheErrorHandler . class )  ,    aspect . getErrorHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheErrorHandler"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "load ( AspectJEnableCachingIsolatedTests . EnableCachingConfig . class )  ;", "AnnotationCacheAspect   aspect    =    this . ctx . getBean ( AnnotationCacheAspect . class )  ;", "assertSame ( this . ctx . getBean (  \" keyGenerator \"  ,    KeyGenerator . class )  ,    aspect . getKeyGenerator (  )  )  ;", "}", "METHOD_END"], "methodName": ["testKeyStrategy"], "fileName": "org.springframework.cache.aspectj.AspectJEnableCachingIsolatedTests"}, {"methodBody": ["METHOD_START", "{", "JCacheCacheAspect   cacheAspect    =    JCacheCacheAspect . aspectOf (  )  ;", "cacheAspect . setCacheOperationSource ( cacheOperationSource (  )  )  ;", "return   cacheAspect ;", "}", "METHOD_END"], "methodName": ["cacheAspect"], "fileName": "org.springframework.cache.aspectj.AspectJJCacheConfiguration"}, {"methodBody": ["METHOD_START", "{", "long   count    =    exceptionCounter . getAndIncrement (  )  ;", "if    ( matchFilter )     {", "throw   new   IOException (  (  (  \" Expec   exception    (  \"     +    count )     +     \"  )  \"  )  )  ;", "} else    {", "throw   new   NullPointerException (  (  (  \" Expec   exception    (  \"     +    count )     +     \"  )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["throwCheckedException"], "fileName": "org.springframework.cache.config.AnnotatedJCacheableService"}, {"methodBody": ["METHOD_START", "{", "long   count    =    exceptionCounter . getAndIncrement (  )  ;", "if    ( matchFilter )     {", "throw   new   UnsupporOperationException (  (  (  \" Expec   exception    (  \"     +    count )     +     \"  )  \"  )  )  ;", "} else    {", "throw   new   NullPointerException (  (  (  \" Expec   exception    (  \"     +    count )     +     \"  )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["throwException"], "fileName": "org.springframework.cache.config.AnnotatedJCacheableService"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   sb    =    new   StringBuilder ( methodName )  ;", "for    ( Object   param    :    params )     {", "sb . append ( param )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateKey"], "fileName": "org.springframework.cache.config.SomeCustomKeyGenerator"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.cache.config.TestEntity"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.cache.config.TestEntity"}, {"methodBody": ["METHOD_START", "{", "try    ( AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( AnnotationBeanConfigurerTests . Config . class )  )     {", "ShouldBeConfiguredBySpring   myObject    =    new   ShouldBeConfiguredBySpring (  )  ;", "assertEquals (  \" Rod \"  ,    myObject . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["injection"], "fileName": "org.springframework.context.annotation.aspectj.AnnotationBeanConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationBeanConfigurerAspect . aspectOf (  )  ;", "}", "METHOD_END"], "methodName": ["beanConfigurerAspect"], "fileName": "org.springframework.context.annotation.aspectj.SpringConfiguredConfiguration"}, {"methodBody": ["METHOD_START", "{", "AnnotationAsyncExecutionAspectTests . ClassWithoutAsyncAnnotation   obj    =    new   AnnotationAsyncExecutionAspectTests . ClassWithoutAsyncAnnotation (  )  ;", "obj . incrementAsync (  )  ;", "executor . waitForCompletion (  )  ;", "assertEquals (  1  ,    obj . counter )  ;", "assertEquals (  1  ,    executor . submitStartCounter )  ;", "assertEquals (  1  ,    executor . submitCompleteCounter )  ;", "}", "METHOD_END"], "methodName": ["asyncMethodGetsRoutedAsynchronously"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAsyncExecutionAspectTests . ClassWithoutAsyncAnnotation   obj    =    new   AnnotationAsyncExecutionAspectTests . ClassWithoutAsyncAnnotation (  )  ;", "Future < Integer >    future    =    obj . incrementReturningAFuture (  )  ;", "assertEquals (  5  ,    future . get (  )  . intValue (  )  )  ;", "assertEquals (  1  ,    obj . counter )  ;", "assertEquals (  1  ,    executor . submitStartCounter )  ;", "assertEquals (  1  ,    executor . submitCompleteCounter )  ;", "}", "METHOD_END"], "methodName": ["asyncMethodReturningFutureGetsRoutedAsynchronouslyAndReturnsAFuture"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( AnnotationAsyncExecutionAspectTests . ClassWithException . class ,     \" failWithVoid \"  )  ;", "TestableAsyncUncaughtExceptionHandler   exceptionHandler    =    new   TestableAsyncUncaughtExceptionHandler (  )  ;", "AnnotationAsyncExecutionAspect . aspectOf (  )  . setExceptionHandler ( exceptionHandler )  ;", "try    {", "assertFalse (  \" Handler   should   not   have   been   called \"  ,    exceptionHandler . isCalled (  )  )  ;", "AnnotationAsyncExecutionAspectTests . ClassWithException   obj    =    new   AnnotationAsyncExecutionAspectTests . ClassWithException (  )  ;", "obj . failWithVoid (  )  ;", "exceptionHandler . await (  3  0  0  0  )  ;", "exceptionHandler . assertCalledWith ( m ,    UnsupportedOperationException . class )  ;", "}    finally    {", "AnnotationAsyncExecutionAspect . aspectOf (  )  . setExceptionHandler ( defaultExceptionHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["exceptionHandlerCalled"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( AnnotationAsyncExecutionAspectTests . ClassWithException . class ,     \" failWithVoid \"  )  ;", "TestableAsyncUncaughtExceptionHandler   exceptionHandler    =    new   TestableAsyncUncaughtExceptionHandler ( true )  ;", "AnnotationAsyncExecutionAspect . aspectOf (  )  . setExceptionHandler ( exceptionHandler )  ;", "try    {", "assertFalse (  \" Handler   should   not   have   been   called \"  ,    exceptionHandler . isCalled (  )  )  ;", "AnnotationAsyncExecutionAspectTests . ClassWithException   obj    =    new   AnnotationAsyncExecutionAspectTests . ClassWithException (  )  ;", "try    {", "obj . failWithVoid (  )  ;", "exceptionHandler . await (  3  0  0  0  )  ;", "exceptionHandler . assertCalledWith ( m ,    UnsupportedOperationException . class )  ;", "}    catch    ( Exception   ex )     {", "fail (  (  \" No   unexpected   exception   should   have   been   received   but   got    \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}    finally    {", "AnnotationAsyncExecutionAspect . aspectOf (  )  . setExceptionHandler ( defaultExceptionHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["exceptionHandlerNeverThrowsUnexpectedException"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAsyncExecutionAspectTests . ClassWithAsyncAnnotation   obj    =    new   AnnotationAsyncExecutionAspectTests . ClassWithAsyncAnnotation (  )  ;", "Future < Integer >    future    =    obj . incrementReturningAFuture (  )  ;", "assertEquals (  5  ,    future . get (  )  . intValue (  )  )  ;", "assertEquals (  1  ,    obj . counter )  ;", "assertEquals (  1  ,    executor . submitStartCounter )  ;", "assertEquals (  1  ,    executor . submitCompleteCounter )  ;", "}", "METHOD_END"], "methodName": ["methodReturningFutureInAsyncClassGetsRoutedAsynchronouslyAndReturnsAFuture"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "beanFactory . registerBeanDefinition (  \" e 1  \"  ,    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  )  ;", "AnnotationAsyncExecutionAspect . aspectOf (  )  . setBeanFactory ( beanFactory )  ;", ". ClassWithQualifiedAsyncMethods   obj    =    new    . ClassWithQualifiedAsyncMethods (  )  ;", "Future < Thread >    defaultThread    =    obj . defaultWork (  )  ;", "assertThat ( defaultThread . get (  )  ,    not ( Thread . currentThread (  )  )  )  ;", "assertThat ( defaultThread . get (  )  . getName (  )  ,    not ( startsWith (  \" e 1  -  \"  )  )  )  ;", "ListenableFuture < Thread >    e 1 Thread    =    obj . e 1 Work (  )  ;", "assertThat ( e 1 Thread . get (  )  . getName (  )  ,    startsWith (  \" e 1  -  \"  )  )  ;", "CompletableFuture < Thread >    e 1 OtherThread    =    obj . e 1 OtherWork (  )  ;", "assertThat ( e 1 OtherThread . get (  )  . getName (  )  ,    startsWith (  \" e 1  -  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["qualifiedAsyncMethodsAreRoutedToCorrectExecutor"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "executor    =    new    . CountingExecutor (  )  ;", "AnnotationAsyncExecutionAspect . aspectOf (  )  . setExecutor ( executor )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAsyncExecutionAspectTests . ClassWithoutAsyncAnnotation   obj    =    new   AnnotationAsyncExecutionAspectTests . ClassWithoutAsyncAnnotation (  )  ;", "obj . increment (  )  ;", "assertEquals (  1  ,    obj . counter )  ;", "assertEquals (  0  ,    executor . submitStartCounter )  ;", "assertEquals (  0  ,    executor . submitCompleteCounter )  ;", "}", "METHOD_END"], "methodName": ["syncMethodGetsRoutedSynchronously"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", ". ClassWithAsyncAnnotation   obj    =    new    . ClassWithAsyncAnnotation (  )  ;", "obj . increment (  )  ;", "executor . waitForCompletion (  )  ;", "assertEquals (  1  ,    obj . counter )  ;", "assertEquals (  1  ,    executor . submitStartCounter )  ;", "assertEquals (  1  ,    executor . submitCompleteCounter )  ;", "}", "METHOD_END"], "methodName": ["voidMethodInAsyncClassGetsRoutedAsynchronously"], "fileName": "org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . context )     !  =    null )     {", "this . context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["after"], "fileName": "org.springframework.scheduling.aspectj.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( context . containsBean ( ASYNC _ EXECUTION _ ASPECT _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["asyncAspectRegistered"], "fileName": "org.springframework.scheduling.aspectj.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   exceptionHandler    =    context . getBean (  \" testExceptionHandler \"  )  ;", "Object       =    context . getBean ( ASYNC _ EXECUTION _ ASPECT _ BEAN _ NAME )  ;", "assertSame ( exceptionHandler ,    new   DirectFieldAccessor (  )  . getPropertyValue (  \" exceptionHandler \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncPostProcessorExceptionHandlerReference"], "fileName": "org.springframework.scheduling.aspectj.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "Object   executor    =    context . getBean (  \" testExecutor \"  )  ;", "Object       =    context . getBean ( ASYNC _ EXECUTION _ ASPECT _ BEAN _ NAME )  ;", "assertSame ( executor ,    new   DirectFieldAccessor (  )  . getPropertyValue (  \" defaultExecutor \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asyncPostProcessorExecutorReference"], "fileName": "org.springframework.scheduling.aspectj.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   ClassPathXmlApplicationContext (  \" annotationDrivenContext . xml \"  ,    AnnotationDrivenBeanDefinitionParserTests . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.scheduling.aspectj.AnnotationDrivenBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAsyncExecutionAspect   asyncAspect    =    AnnotationAsyncExecutionAspect . aspectOf (  )  ;", "if    (  ( this . executor )     !  =    null )     {", "asyncAspect . setExecutor ( this . executor )  ;", "}", "if    (  ( this . exceptionHandler )     !  =    null )     {", "asyncAspect . setExceptionHandler ( this . exceptionHandler )  ;", "}", "return   asyncAspect ;", "}", "METHOD_END"], "methodName": ["asyncAdvisor"], "fileName": "org.springframework.scheduling.aspectj.AspectJAsyncConfiguration"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Handler   not   called \"  ,    descriptor )  ;", "assertEquals (  \" Wrong   exception   type \"  ,    expectedType ,    descriptor . ex . getClass (  )  )  ;", "assertEquals (  \" Wrong   method \"  ,    expectedMethod ,    descriptor . method )  ;", "}", "METHOD_END"], "methodName": ["assertCalledWith"], "fileName": "org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . latch . await ( timeout ,    TimeUnit . MILLISECONDS )  ;", "}    catch    (    e )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "METHOD_END"], "methodName": ["await"], "fileName": "org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "return    ( descriptor )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isCalled"], "fileName": "org.springframework.scheduling.aspectj.TestableAsyncUncaughtExceptionHandler"}, {"methodBody": ["METHOD_START", "{", "AnnotationTransactionAspect   txAspect    =    AnnotationTransactionAspect . aspectOf (  )  ;", "if    (  ( this . txManager )     !  =    null )     {", "txAspect . setr ( this . txManager )  ;", "}", "return   txAspect ;", "}", "METHOD_END"], "methodName": ["transactionAspect"], "fileName": "org.springframework.transaction.aspectj.AspectJTransactionManagementConfiguration"}, {"methodBody": ["METHOD_START", "{", "doInTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["doSomething"], "fileName": "org.springframework.transaction.aspectj.ClassWithPrivateAnnotatedMember"}, {"methodBody": ["METHOD_START", "{", "doInTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["doSomething"], "fileName": "org.springframework.transaction.aspectj.ClassWithProtectedAnnotatedMember"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . txManager . begun )  ;", "new    . JtaAnnotationPrivateAnnotatedMember (  )  . doInTransaction (  )  ;", "assertEquals (  1  ,    this . txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["commitOnAnnotatedPrivateMethod"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . txManager . begun )  ;", "new    . JtaAnnotationProtectedAnnotatedMember (  )  . doInTransaction (  )  ;", "assertEquals (  1  ,    this . txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["commitOnAnnotatedProtectedMethod"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . txManager . begun )  ;", "new    . JtaAnnotationPublicAnnotatedMember (  )  . echo ( null )  ;", "assertEquals (  1  ,    this . txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["commitOnAnnotatedPublicMethod"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . txManager . begun )  ;", "InterruptedException   test    =    new   InterruptedException (  )  ;", "try    {", "new    . JtaAnnotationPublicAnnotatedMember (  )  . echo ( test )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( Throwable   throwable )     {", "assertEquals (  \" wrong   exception \"  ,    test ,    throwable )  ;", "}", "assertEquals (  1  ,    this . txManager . rollbacks )  ;", "assertEquals (  0  ,    this . txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["matchingRollbackOnApplied"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . txManager . begun )  ;", "new    . JtaAnnotationPrivateAnnotatedMember (  )  . doSomething (  )  ;", "assertEquals (  1  ,    this . txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["nonAnnotatedMethodCallingPrivateMethod"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . txManager . begun )  ;", "new    . JtaAnnotationProtectedAnnotatedMember (  )  . doSomething (  )  ;", "assertEquals (  1  ,    this . txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["nonAnnotatedMethodCallingProtectedMethod"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . txManager . begun )  ;", "IOException   test    =    new   IOException (  )  ;", "try    {", "new    . JtaAnnotationPublicAnnotatedMember (  )  . echo ( test )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( Throwable   throwable )     {", "assertEquals (  \" wrong   exception \"  ,    test ,    throwable )  ;", "}", "assertEquals (  1  ,    this . txManager . commits )  ;", "assertEquals (  0  ,    this . txManager . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["nonMatchingRollbackOnApplied"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . txManager . begun )  ;", "new   Tests . NotTransactional (  )  . noop (  )  ;", "assertEquals (  0  ,    this . txManager . begun )  ;", "}", "METHOD_END"], "methodName": ["notTransactional"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "this . txManager . clear (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.transaction.aspectj.JtaTransactionAspectsTests"}, {"methodBody": ["METHOD_START", "{", "if    ( t    !  =    null )     {", "row   t ;", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["echo"], "fileName": "org.springframework.transaction.aspectj.MethodAnnotationOnClassWithNoInterface"}, {"methodBody": ["METHOD_START", "{", "txManager . clear (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "methodAnnotaOnly . echo ( null )  ;", "assertEquals (  1  ,    txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["commitOnAnnotatedMethod"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "txManager . clear (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "beanWithAnnotatedPrivateMethod . doSometh (  )  ;", "assertEquals (  1  ,    txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["commitOnAnnotatedPrivateMethod"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "txManager . clear (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "beanWithAnnotatedProtectedMethod . doIn (  )  ;", "assertEquals (  1  ,    txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["commitOnAnnotatedProtectedMethod"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "txManager . clear (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "annotationOnlyOnClassWithNoInterface . nonalMethod (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "}", "METHOD_END"], "methodName": ["commitOnNonAnnotatedNonPublicMethodInTransactionalType"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "final   Exception   ex    =    new   Exception (  )  ;", "try    {", "testRollback (  (  )     -  >    annotationOnlyOnClassWithNoInterface . echo ( ex )  ,    false )  ;", "fail (  \" Should   have   thrown   Exception \"  )  ;", "}    catch    ( Exception   ex 2  )     {", "assertSame ( ex ,    ex 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["defaultCommitOnAnnotatedClass"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "final   Exception   ex    =    new   Exception (  )  ;", "try    {", "testRollback (  (  )     -  >    new    . SubclassOfClassWithTransactionalAnnotation (  )  . echo ( ex )  ,    false )  ;", "fail (  \" Should   have   thrown   Exception \"  )  ;", "}    catch    ( Exception   ex 2  )     {", "assertSame ( ex ,    ex 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["defaultCommitOnSubclassOfAnnotatedClass"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "final   Exception   ex    =    new   Exception (  )  ;", "try    {", "testRollback (  (  )     -  >    new    . SubclassOfClassWithTransactionalMethodAnnotation (  )  . echo ( ex )  ,    false )  ;", "fail (  \" Should   have   thrown   Exception \"  )  ;", "}    catch    ( Exception   ex 2  )     {", "assertSame ( ex ,    ex 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["defaultCommitOnSubclassOfClassWithTransactionalMethodAnnotated"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeException   ex    =    new   RuntimeException (  )  ;", "try    {", "testRollback (  (  )     -  >    annotationOnlyOnClassWithNoInterface . echo ( ex )  ,    true )  ;", "fail (  \" Should   have   thrown   RuntimeException \"  )  ;", "}    catch    ( RuntimeException   ex 2  )     {", "assertSame ( ex ,    ex 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["defaultRollbackOnAnnotatedClass"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationTransactionAspect . aspectOf (  )  . setTransactionManager ( txManager )  ;", "}", "METHOD_END"], "methodName": ["initContext"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "final   Exception   ex    =    new   Exception (  )  ;", "testNotTransactional (  (  )     -  >    new    . ImplementsAnnotatedInterface (  )  . echo ( ex )  ,    ex )  ;", "}", "METHOD_END"], "methodName": ["noCommitOnImplementationOfAnnotatedInterface"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "final   Exception   rollbackProvokingException    =    new   RuntimeException (  )  ;", "testNotTransactional (  (  )     -  >    new    . ImplementsAnnotatedInterface (  )  . echo ( rollbackProvokingException )  ,    rollbackProvokingException )  ;", "}", "METHOD_END"], "methodName": ["noRollbackOnImplementationOfAnnotatedInterface"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "txManager . clear (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "new    . NotTransactional (  )  . noop (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "}", "METHOD_END"], "methodName": ["notTransactional"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "txManager . clear (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "annotaOnlyOnClassWithNoInterface . echo ( null )  ;", "assertEquals (  1  ,    txManager . commits )  ;", "}", "METHOD_END"], "methodName": ["testCommitOnAnnotatedClass"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "txManager . clear (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "try    {", "toc . performalOperation (  )  ;", "}    catch    ( Throwable   t )     {", "if    ( expected    =  =    null )     {", "fail (  (  \" Expected    \"     +    expected )  )  ;", "}", "assertSame ( expected ,    t )  ;", "}    finally    {", "assertEquals (  0  ,    txManager . begun )  ;", "}", "}", "METHOD_END"], "methodName": ["testNotTransactional"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "txManager . clear (  )  ;", "assertEquals (  0  ,    txManager . begun )  ;", "try    {", "toc . performalOperation (  )  ;", "}    finally    {", "assertEquals (  1  ,    txManager . begun )  ;", "assertEquals (  ( rollback    ?     0     :     1  )  ,    txManager . commits )  ;", "assertEquals (  ( rollback    ?     1     :     0  )  ,    txManager . rollbacks )  ;", "}", "}", "METHOD_END"], "methodName": ["testRollback"], "fileName": "org.springframework.transaction.aspectj.TransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "if    ( t    !  =    null )     {", "row   t ;", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["echo"], "fileName": "org.springframework.transaction.aspectj.TransactionalAnnotationOnlyOnClassWithNoInterface"}]